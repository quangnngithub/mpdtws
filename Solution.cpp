#include "PDS.h"
#include <iomanip>
using namespace std;

/*NOTE 25.11.2013: C2C doesn't have vioTWSP: 1) p-sp-c2c -->vioTWSP of p
                                             2) c2c-sp-d -->vioTWSP of d
                                             3) p-sp-c2c-sp-d-->vioTSP of p and d*/ 
//MAX 300 vehicles; each vehicle max 50 trips

//
//int *nextArrTemp, *nextArrB;
//bool *routedTemp, *routed;
//int *numCusPRouted; //SPToCusP[idCus] = idsp that is assigned to
//int *numCusDRouted; //SPToCusP[idCus] = idsp that is assigned to
//int *numCusPSP; //numCusPSP[idsp] = number of cusP assigned to idsp
//int **CusPSP; // CusPSP[sp][j] = id of customerP #j assigned to sp; j = 1,..,numCusPSP[sp] 



//double COEFCAP, COEFTWC, COEFTWSP; //coeficient vioCAP, vioTWCus, vioTWSP
bool FOUNDNEWBESTATTHISIT;

//int vioCAPC; double vioTWCC, vioTWSPC, COSTBEST, FITBEST; //total vioCAPCurrent, vioTWCurrent, COSTcurrent FITCurrent, COSTBEST, FITBEST
//double penalty; 
//double VCAP_START, VTWSP_START, VTWCUS_START;
//double FITSTAR;
//int nTypeCus, nTypeSP;
//int exceed,Q, nD1, nP1, nSP1, nC2C, nOrder, startidC2C, endidC2CP, startidC2CD, endidC2C, startidP, endidP, startidD, endidD, startidWS, endidWS, totalNODE, totalNODE1;
//int IT, ITBEST;

//int TABUD1[100], TABUD2[100], TABUSP1, TABUSP2, TABUP1, TABUP2, TABUC2C1, TABUC2C2; //interval of tabu for cusD, SP, cusP, cusC2C
//double thetaD1, thetaD2, thetaSP1, thetaSP2, thetaP1, thetaP2, thetaC2C1, thetaC2C2;
//int ITTabuMoveSP, ITTabuP, ITTabuC2C;

Solution *Elite;
int *ratioE;
int sizeE,cursizeE=0;


//bool *checkUsed;
//int ITTabuCustomerZone[100];
//
//int ***tabu; //tabu[type][idCus][#neighbor]
//
//VariationptrDD *deleteCus; //deleteCus[cus i]: delete customer i from its current leg
//VariationptrI **insertCus; //insertCus[cus i][neighbor of i]: insert its neighbor after customer i
//VariationptrIE *insertCusEmptyVeh; //insertCusEmptyVeh[cur i]: insert customer i into new empty leg of empty vehicle
//int **insertC2CDAfter; int **moveC2CDAfter;
//For delivery customer: moveCus = moveCusOneTrip;
//For pickup customers: moveCus = moveCusOneTrip/moveCusSameVehicleDifTrip
VariationptrEx **moveCus;//moveCus[cus i][neighbor of i]: move its neighbor after customer i

//VariationptrEx **exchangeCus; //exchangeCus[cus i][neighbor of i]: exchange customer i and its neighbor
VariationptrT1 **twoOPTstarCus; //2opt*Cus[cus i][neighbor of i]
int ***frequency;

//VariationptrSP **mergeSP; //mergeSP[spi][idVeh]: delete spi from idVeh and merge all customers currently served by spi to all other vehi with spi
//moveT best_move,moveE; //moveE: use to evaluate the neighborhoods
//double COSTINIT, FITINIT, FITSTART; int VEHINIT;
int NVEH, NSP;

int COOLITER; //(after how many iterations) when to change prob of selecting move on sp
int	COOLPROB; //change howmuch of prob of selecting move on sp
int COOLTIMES; 



int main2(int argc, char *argv[])
{
	return 0;
//	srand((unsigned)time(NULL));
//    //Problem P1;P1.createInstanceC2C_SP8("PDSDATA/PDS30.txt","C2CDATA/30.txt");
//	/*char *filename; filename = argv[1];Problem P1(filename);
//	//Problem P1("C2CDATA/1.txt");
//	//Problem *P1 = new Problem(filename);
//	P1.initData(); Q = P1.Q; 
//	nP1 = P1.nP + 1; nD1 = P1.nD + 1; nSP1 = P1.nSP + 1;
//	startidWS = P1.startidWS; endidWS = P1.endidWS;
//	startidP = P1.startidP; endidP = P1.endidP;
//	startidD = P1.startidD; endidD = P1.endidD;
//	startidC2C = P1.startidC2C; endidC2CP = P1.endidC2CP; startidC2CD = P1.startidC2CD; endidC2C = P1.endidC2C;
//	
//	totalNODE = P1.nSP + P1.nP + P1.nD + P1.nC2C;
//	totalNODE1 = totalNODE + 1;
//	Solution sol(&P1);
//	
//	COEFCAP = 1; COEFTWC = 1; COEFTWSP = 1;
//
//    VCAP_START = 1; VCAP = VCAP_START;
//	VTWCUS_START = 1; VTWCUS = VTWCUS_START;
//	VTWSP_START = 1; VTWSP = VTWSP_START; 
//
//	//typeofseed, int typeofINIT, int typeofAssCusPToSP, int valueFEE)
//	cout<<"CREATE INITSOL: ";
//	sol.initSol(2,2,2,5);

//	sol.showSolutionTempToCheck();
//	sol.checkSolution();
//	COSTINIT = sol.cost;
//	FITINIT = sol.fitness;
//	VEHINIT = sol.numVeh;*/
//
//	char *filename; filename = argv[1];
//	cout<<"File name = "<<filename<<"-"<<endl;
//
//	thetaD1 = atof(argv[2]); thetaD2 = atof(argv[3]); 
//	thetaP1 = atof(argv[4]); thetaP2 = atof(argv[5]);
//	thetaC2C1 = atof(argv[6]); thetaC2C2 = atof(argv[7]);
//	thetaSP1 = atof(argv[8]); thetaSP2 = atof(argv[9]); 
//
//	//penalty = atof(argv[10]); penalty += 1; //penalty = (double) penalty1;
//	int maxIT = atoi(argv[11]);
//
//    /*COOLITER = atoi(argv[12]); //when to change prob of selecting move on sp
//	COOLPROB = atoi(argv[13]); //change howmuch of prob of selecting move on sp
//	COOLTIMES = atoi(argv[14]); //do diversification after COOLTIMES consecutives times doing cooling without improvement on best solution
//    */
//	//Problem P1(filename);  nTypeCus = 3; nTypeSP = 2;
//
//	P1.initData();
//	cout<<"FINI initData()"<<endl;
//	Q = P1.Q; 
//	nP1 = P1.nP + 1; nD1 = P1.nD + 1; nSP1 = P1.nSP + 1;
//	startidWS = P1.startidWS; endidWS = P1.endidWS;
//	startidP = P1.startidP; endidP = P1.endidP;
//	startidD = P1.startidD; endidD = P1.endidD;
//	startidC2C = P1.startidC2C; endidC2CP = P1.endidC2CP; startidC2CD = P1.startidC2CD; endidC2C = P1.endidC2C;
//	
//	totalNODE = P1.nSP + P1.nP + P1.nD + P1.nC2C;
//	totalNODE1 = totalNODE + 1;
//
//	cout<<"Solution sol(&P1);"<<endl;
//	Solution sol(&P1);
//    cout<<"FINI Solution sol(&P1);"<<endl;	
////	COEFCAP = 1; COEFTWC = 1; COEFTWSP = 1;
//
//    VCAP_START = 1; VCAP = VCAP_START;
//	VTWCUS_START = 1; VTWCUS = VTWCUS_START;
//	VTWSP_START = 1; VTWSP = VTWSP_START; 
//
//	//typeofseed, int typeofINIT, int typeofAssCusPToSP, int valueFEE)
//	cout<<"CREATE INITSOL: ";
//	sol.initSol(2,2,2,5);
//	sol.showSolutionTempToCheck();
//	sol.checkSolution();
//	COSTINIT = sol.cost;
//	FITINIT = sol.fitness;
//	VEHINIT = sol.numVeh;
//
//    double temp;
//	for (int i=1;i<=P1.nSP;i++)
//	{
//		temp = (double)(P1.numCusDSP[i]);
//		TABUD1[i] = (int) (thetaD1*log10(temp));
//		TABUD2[i] = (int) (thetaD2* log10(temp));
//	}
//	temp = (double) P1.nSP;
//	temp = log10(temp);
//	TABUP1 = (int) (thetaP1*temp);
//	TABUP2 = (int) (thetaP2*temp);
//	temp = (double) P1.nC2C;
//	TABUC2C1 = (int) (thetaC2C1 * log10(temp));
//	TABUC2C2 = (int) (thetaC2C2 * log10(temp));
//	
//	cout<<"Tabu for CusP = ["<<TABUP1<<", "<<TABUP2<<"]; cusC2C = ["<<TABUC2C1<<", "<<TABUC2C2<<"]"<<endl;
//	cout<<"startidC2C = "<<startidC2C<<"; endidC2C = "<<endidC2C<<"; startidP = "<<startidP<<"; endidP = "<<endidP<<"; startidD = "<<startidD<<"; endidD = "<<endidD<<endl;
//
//	/*int numVehS = sol.numVeh;
//	TABUSP1 = (int) ((P1.nSP * numVehS) /thetaSP1);
//	TABUSP2 = (int) ((P1.nSP * numVehS) /thetaSP2);
//	cout<<"TabuSP1 = "<<TABUSP1<<", TabuSP2 = "<<TABUSP2<<endl;
//
//	COOLITER = COOLITER*((nSP * numVehS) + nD + nP); //when to change prob of selecting move on sp
//    cout<<"Random 7 neighborhoods for COOLITER = "<<COOLITER<<" iterations"<<endl;
//	cout<<"COOLPROB = "<<COOLPROB<<"; COOLTIMES = "<<COOLTIMES<<endl;*/
//
//	sizeE = 10;
// 	/*Elite = new Solution[sizeE];
//	for (int i=0;i<sizeE;i++) Elite[i].init(&P1);
//	ratioE = new int[sizeE];*/
//	//sol.callTABU(maxIT);
}



/**************************************************** TABU 27/11/2013 ***************************************************/
//void Solution::callTABU(int max_iteration)
//{
//    cout<<"Cost = "<<cost<<"; fit = "<<fitness<<"; fea = "<<feasible<<endl; 
//    Solution solBEST(problem);
//
//   if (feasible==1)
//   {
//        COSTBEST = cost;
//        FITBEST = fitness;     
//		vioCAPC=0; vioTWCC=0;
//		vioTWSPC=0;
//		solBEST = (*this);
//		FITSTART=fitness;
//   }    
//   else
//   {
//       COSTBEST = PDS_INFINITY;
//	   FITBEST = PDS_INFINITY; FITSTART=FITBEST;
//	   vioCAPC=0; vioTWCC=0; vioTWSPC=0;
//	   for (int i=0;i<numVeh;i++)
//		   if (seg[i].numTrips>0)
//	          {vioCAPC += seg[i].vioCAP; vioTWCC +=seg[i].vioTWC;vioTWSPC+=seg[i].vioTWSP;}
//   } 
// 
//   cout<<"Start init_parametersTABU_CUS: "<<endl;
//   IT = -1;
//   init_parametersTABU_CUS(nTypeCus);
//
//   
//   cout<<"Start init_arrayTABU: "<<endl;
//   init_arrayTABU();
//   cout<<"---------------------------- TabuMAIN: "<<endl;
//
//   TabuMAIN(max_iteration, solBEST);
//   freeMEM(nTypeCus);
//
//
//}

//void Solution::init_parametersTABU_CUS(int nType)
//{
//	int i,j,k, size;
//
//	tabu = new int**[nType];  //tabu[type][idCus][#neighbor]
//    frequency = new int**[nType]; //frequency[type][idCus][#neighbor]
//
//	for (i=0;i<nType;i++)
//	{
//		  tabu[i] = new int*[totalNODE1];
//		  frequency[i] = new int*[totalNODE1];
//	      for (j=0;j<totalNODE1;j++) 
//		  {
//			  size = problem->node[j].neighborSize;
//			  tabu[i][j] = new int[size];
//			  frequency[i][j] = new int [size];
//		      for (k=0;k<size;k++) 
//			  {
//				  tabu[i][j][k]=-1; //tabu[type][idCus][#Neighbor]
//				  frequency[i][j][k] = 0;
//			  }
//		  }
//	}
//
////	cout<<"HERE 1"<<endl;
//  try
//  {
//	 deleteCus = new (nothrow) VariationptrDD[totalNODE1];
//	 if (deleteCus == 0)
//	 {
//		 cout << "Error deleteCus: memory could not be allocated";
//		 exit(-1);
//	 }
//	 insertCus = new (nothrow)VariationptrI*[totalNODE1];
//	 if (insertCus == 0)
//	 {
//		 cout << "Error insertCus: memory could not be allocated";
//		 exit(-1);
//	 }
//
//	 insertCusEmptyVeh = new (nothrow)  VariationptrIE[totalNODE1];
//	 if (insertCusEmptyVeh == 0)
//	 {
//		 cout << "Error insertCusEmptyVeh: memory could not be allocated";
//		 exit(-1);
//	 }
//
//	 insertC2CDAfter = new (nothrow) int*[problem->endidC2C+1];
//	 if (insertC2CDAfter == 0)
//	 {
//		 cout << "Error insertC2CDAfter: memory could not be allocated";
//		 exit(-1);
//	 }
//
//	 moveC2CDAfter = new (nothrow) int*[problem->endidC2C+1];
//	 if (moveC2CDAfter == 0)
//	 {
//		 cout << "Error moveC2CDAfter: memory could not be allocated";
//		 exit(-1);
//	 }
//
//	 moveCus = new (nothrow) VariationptrEx*[totalNODE1];
//	 if (moveCus == 0)
//	 {
//		 cout << "Error moveCus: memory could not be allocated";
//		 exit(-1);
//	 }
//
//	 exchangeCus = new (nothrow) VariationptrEx*[totalNODE1];
//	 if (exchangeCus == 0)
//	 {
//		 cout << "Error exchangeCus: memory could not be allocated";
//		 exit(-1);
//	 }
//
//	 twoOPTstarCus = new (nothrow) VariationptrT1*[totalNODE1];
//	 if (twoOPTstarCus == 0)
//	 {
//		 cout << "Error twoOPTstarCus: memory could not be allocated";
//		 exit(-1);
//	 }
//  }
//  catch (int e)
//  {
//    cout << "An exception occurred. Exception Nr. " << e << '\n';
//  }
//
//	 /*deleteCus = new VariationptrDD[totalNODE1];
//     insertCus = new VariationptrI*[totalNODE1];
//     insertCusEmptyVeh = new VariationptrIE[totalNODE1];
//     insertC2CDAfter = new int*[problem->endidC2C+1];moveC2CDAfter = new int *[problem->endidC2C + 1];
//	 moveCus = new VariationptrEx*[totalNODE1];
//     exchangeCus = new VariationptrEx*[totalNODE1];
//     twoOPTstarCus = new VariationptrT1*[totalNODE1];*/
//
////  cout<<"HERE 2"<<endl;
//try
//  {
//	   for (i = startidC2C; i <= endidC2C; i++)
//	   {
//		   size = problem->node[i].neighborSize;
//		   insertC2CDAfter[i] = new int[size];
//		   moveC2CDAfter[i] = new int[size];
//		   for (j = 0; j< size; j++)
//		   {
//			   insertC2CDAfter[i][j] = -1;
//			   moveC2CDAfter[i][j] = -1;
//		   }
//	   }
//	   for (i = 0; i < startidC2C; i++)
//	   {
//		   insertC2CDAfter[i] = new int[1];
//		   moveC2CDAfter[i] = new int[1];
//		   insertC2CDAfter[i][0] = -1;
//		   moveC2CDAfter[i][0] = -1;
//	   }
//  }
//  catch (int e)
//  {
//    cout << "(1) An exception occurred. Exception Nr. " << e << '\n';
//  }
//
// // cout<<"HERE 3"<<endl;
//try
//  {
//	   cout<<"startidC2C = "<<startidC2C<<"; size neighbors = "<<problem->node[startidC2C].neighborSize<<endl;
//	   for (i = 0; i < startidC2C; i++)
//	   {
//		  deleteCus[i] = new variationDD();
//		  insertCusEmptyVeh[i] = new variationIE();
//		  insertCus[i] = new VariationptrI[1];
//		  moveCus[i] = new VariationptrEx[1];
//		  exchangeCus[i] = new VariationptrEx[1]; 
//		  twoOPTstarCus[i] = new VariationptrT1[1];
//				  insertCus[i][0] = new variationI();
//				  moveCus[i][0] = new variationEx();
//				  exchangeCus[i][0] = new variationEx();
//				  twoOPTstarCus[i][0] = new variationT1();
//	   }
//	   for (i = startidP; i <= endidD;i++)
//	   {
//		  // cout<<"WORKING ON cus "<<i<<endl;
//		  size = problem->node[i].neighborSize;
//		  deleteCus[i] = new variationDD();
//		  insertCusEmptyVeh[i] = new variationIE();
//		  insertCus[i] = new VariationptrI[size];
//		  moveCus[i] = new VariationptrEx[size];
//		  exchangeCus[i] = new VariationptrEx[size]; 
//		  twoOPTstarCus[i] = new VariationptrT1[size];
//		  //frequency[i] = new int[size];
//		  for (j=0; j < size; j++)
//		  {
//			  insertCus[i][j] = new variationI();
//			  moveCus[i][j] = new variationEx();
//			  exchangeCus[i][j] = new variationEx();
//			  twoOPTstarCus[i][j] = new variationT1();
//			  //frequency[i][j]=0;
//		  }
//	   }
//	   for (i = startidC2C; i <= endidC2C;i++)
//	   {
//		  // cout<<"WORKING ON cus "<<i<<endl;
//		  size = problem->node[i].neighborSize;
//		  deleteCus[i] = new variationDD();
//		  insertCusEmptyVeh[i] = new variationIE();
//		  insertCus[i] = new VariationptrI[size];
//		  moveCus[i] = new VariationptrEx[size];
//		  twoOPTstarCus[i] = new VariationptrT1[size];
//		  //frequency[i] = new int[size];
//		  for (j=0; j < size; j++)
//		  {
//			  insertCus[i][j] = new variationI();
//			  moveCus[i][j] = new variationEx();
//			  twoOPTstarCus[i][j] = new variationT1();
//			  //frequency[i][j]=0;
//		  }
//	   }
//
//	   for (i=startidC2C;i<= endidC2CP;i++) 
//	   {
//			size = problem->nodeC2C[i].neighborSizeExchange;
//		    exchangeCus[i] = new VariationptrEx[size]; 
//			for (j = 0; j < size; j++) exchangeCus[i][j] = new variationEx();
//	   }
//
//  }
//  catch (int e)
//  {
//    cout << "(2) An exception occurred. Exception Nr. " << e << '\n';
//  }
//  cout<<"insertCus[startidC2C][1]->var_vioCAP = "<<insertCus[startidC2C][1]->var_vioCAP<<endl;
//
//}



//void Solution::init_arrayTABU()
//{
//    int idVeh, idTrip, lastT;
//    int assSP;
//    double cStartS;
//    
//    exceed = (int) (problem->Q * 1.2);
//    int i,j, k, start, end, nextTrip;
//
//
//    //1st Transform: Remove customer:
//    cout<<"1st. Remove customers: "<<endl; 
//	
//	//cout<<"1.Remove customer"<<endl;
//	for (idVeh=0;idVeh<numVeh;idVeh++)
//		if (seg[idVeh].numTrips > 0) UpdateDeleteArray(idVeh);
//
//	//5.2 2opt* pickup customers:
//
//    //2nd Transform: Insert customers:
//    cout<<"2.1 Insert delivery customers between trips: "<<endl;
//	//2.1 Insert delivery customers:
//	for (i=1; i<=nSP; i++) 
//	{
//		start = problem->startCusDSP[i]; end = problem->endCusDSP[i];
//		for (j=start;j<=end;j++)
//		{
//			//1.for each customer j, calculate to insert it into the empty vehicle:
//			cal_InsertCusDIntoEmptyVeh(j, i);
//			idVeh = route_num[j]; idTrip = trip_num[j];
//			nextTrip = idTrip + 1;
//			//2.for each customer j, calculate insertCus[j][#its neighbor]:
//			if (j == seg[idVeh].Trip[idTrip].lastCus)
//			{
//				if (nextTrip == seg[idVeh].numTrips) //lastTrip
//				{
//					for (k=0; k < problem->node[j].neighborSize; k++)
//					{
//						if (nextArr[j] != problem->node[j].neighborNode[k].id)
//						{
//							//calculate: insert neighbor #k after j:
//							cal_InsertCusDIAfterJ_LastC_LastTrip(j,k, idVeh, idTrip); //27/11/2013
//						}
//						//else //neighbor k is already after j 
//					}
//				}
//				else //not the last trip; j is last cus
//				{
//					if (seg[idVeh].Trip[nextTrip].Type == 1) //nextTrip is delivery trip; j is last cus
//					{
//						for (k=0; k < problem->node[j].neighborSize; k++)
//						{
//							if (nextArr[j] != problem->node[j].neighborNode[k].id)
//							{
//								//calculate: insert neighbor #k after j:
//								cal_InsertCusDIAfterJ_LastC_NextTripD(j,k,idVeh, idTrip); //27/11/2013
//							}
//							//else //neighbor k is already after j 
//						}
//					}
//					else  //nextTrip is pickup trip OR C2C; j is last trip
//					{
//						for (k=0; k < problem->node[j].neighborSize; k++)
//						{
//							if (nextArr[j] != problem->node[j].neighborNode[k].id)
//							{
//								//calculate: insert neighbor #k after j:
//								cal_InsertCusDIAfterJ_LastC_NextTripP_OR_C2C(j,k,idVeh, idTrip); //27/11/2013
//							}
//							//else //neighbor k is already after j 
//						}
//					}//end nextTrip is pickup trip OR C2C; j is last trip
//				}//end not the last trip; j is last cus
//			}
//			else //j is not the last cus
//			{
//				if (nextTrip == seg[idVeh].numTrips) //lastTrip
//				{
//					for (k=0; k < problem->node[j].neighborSize; k++)
//					{
//						if (nextArr[j] != problem->node[j].neighborNode[k].id)
//						{
//							//calculate: insert neighbor #k after j:
//							cal_InsertCusDIAfterJ_NotLastC_LastTrip(j,k, idVeh, idTrip); //27/11/2013
//						}
//						//else //neighbor k is already after j 
//					}
//				}
//				else //not the last trip; j is not the last cus
//				{
//					if (seg[idVeh].Trip[nextTrip].Type == 1)//nextTrip is delivery trip
//					{
//						for (k=0; k < problem->node[j].neighborSize; k++)
//						{
//							if (nextArr[j] != problem->node[j].neighborNode[k].id)
//							{
//								//calculate: insert neighbor #k after j:
//								cal_InsertCusDIAfterJ_NotLastC_NextTripD(j,k,idVeh, idTrip); //27/11/2013
//							}
//							//else //neighbor k is already after j 
//						}
//					}
//					else //nextTrip is pickup trip or C2C
//					{
//						for (k=0; k < problem->node[j].neighborSize; k++)
//						{
//							if (nextArr[j] != problem->node[j].neighborNode[k].id)
//							{
//								//calculate: insert neighbor #k after j:
//								cal_InsertCusDIAfterJ_NotLastC_NextTripP_OR_C2C(j,k,idVeh, idTrip); //27/11/2013
//							}
//							//else //neighbor k is already after j 
//						}
//					}//end nextTrip is pickup trip or C2C
//				}//end //not the last trip; j is not the last cus
//			}//end j is not the last cus
//		}
//	}
//
//	//2.2 Insert pickup customers:
//    cout<<"2.2 Insert pickup customers between trips: "<<endl;
//	for (j= startidP; j <= endidP; j++)
//	{
//		idVeh = route_num[j]; idTrip = trip_num[j];
//		assSP = seg[idVeh].Trip[idTrip].assSP;
//		lastT = seg[idVeh].numTrips - 1;
//
//		if (idTrip == 0 && seg[idVeh].Trip[idTrip].numCus == 1)
//		{
//			if (lastT == 0) //vehicle with only 1 pickup trip with one customer
//			{
//				//curC now points to the last cus:
//				for (k=0; k < problem->node[j].neighborSize; k++)
//				{
//					i = problem->node[j].neighborNode[k].id;
//					if (problem->belong[i][assSP])
//					{		
//						SUBcal_InsertCusPIAfterJ_LastC_1CusFirstTrip(j, i, idVeh, 0, insertCus[j][k]->var_vioCAP, insertCus[j][k]->var_cost, insertCus[j][k]->var_vioTWC, insertCus[j][k]->var_vioTWSP, cStartS);
//						insertCus[j][k]->atIT = IT;
//					}
//				}
//			}
//			else
//			{
//				int nextT = 1;
//				if (seg[idVeh].Trip[nextT].Type==1) //idTrip is pickup, nextT is delivery
//				{
//						if (assSP == seg[idVeh].Trip[nextT].assSP) //curC is the not last pickup customer, nextTrip is delivery trip, sameSP
//						{
//								for (k=0; k < problem->node[j].neighborSize; k++)
//								{
//									i = problem->node[j].neighborNode[k].id;
//									if (problem->belong[i][assSP])
//									{
//										cal_InsertCusPIAfterJ_LastC_NextTripD_SameSP_1CusFirstTrip(j, i, idVeh, 0, insertCus[j][k]->var_vioCAP, insertCus[j][k]->var_cost, insertCus[j][k]->var_vioTWC, insertCus[j][k]->var_vioTWSP);
//										insertCus[j][k]->atIT = IT;
//									}
//								}
//						}
//						else //nextTrip is delivery trip, difSP
//						{
//							for (k=0; k < problem->node[j].neighborSize; k++)
//							{
//								i = problem->node[j].neighborNode[k].id;
//								if (problem->belong[i][assSP])
//								{
//									cal_InsertCusPIAfterJ_LastC_NextTripD_DifSP_1CusFirstTrip(j, i, idVeh, 0, insertCus[j][k]->var_vioCAP, insertCus[j][k]->var_cost, insertCus[j][k]->var_vioTWC, insertCus[j][k]->var_vioTWSP);
//									insertCus[j][k]->atIT = IT;
//								}
//							}
//						}
//				}//end idTrip is pickup, nextT is delivery trip
//				else //if (seg[idVeh].Trip[nextT].Type==0 || 2)//idTrip is pickup, nextT is pickup OR C2C
//				{
//					for (k=0; k < problem->node[j].neighborSize; k++)
//					{
//						i = problem->node[j].neighborNode[k].id;
//						if (problem->belong[i][assSP])
//						{
//							cal_InsertCusPIAfterJ_LastC_NextTripPORC2C_1CusFirstTrip(j, i, idVeh, 0, insertCus[j][k]->var_vioCAP, insertCus[j][k]->var_cost, insertCus[j][k]->var_vioTWC, insertCus[j][k]->var_vioTWSP);
//							insertCus[j][k]->atIT = IT;
//						}
//					}
//				}//end idTrip is pickup, nextT is pickup OR C2C
//			}
//		}
//		else //idTrip has > 1 cus
//		{
//			if (seg[idVeh].Trip[idTrip].lastCus == j) // j is the last pickcustomer
//			{
//					if (idTrip == lastT) // j is the last pickup custmer of the last trip
//					{
//						for (k=0; k < problem->node[j].neighborSize; k++)
//						{
//							i = problem->node[j].neighborNode[k].id;
//							if (problem->belong[i][assSP])
//							if (nextArr[j] != i)
//							{
//								SUBcal_InsertCusPIAfterJ_LastC(j, i, idVeh, idTrip, insertCus[j][k]->var_vioCAP, insertCus[j][k]->var_cost, insertCus[j][k]->var_vioTWC, insertCus[j][k]->var_vioTWSP, cStartS);
//								insertCus[j][k]->atIT = IT;
//							}
//							//else //neighbor k is already after j
//						}
//					}
//					else // j is the last pickup customer of the first/middle trip
//					{
//						int nextT = idTrip + 1;
//						if (seg[idVeh].Trip[nextT].Type == 1)
//						{
//							if (seg[idVeh].Trip[idTrip].assSP == seg[idVeh].Trip[nextT].assSP) //j is the last pickup customer, nextTrip is delivery trip, sameSP
//							{
//								for (k=0; k < problem->node[j].neighborSize; k++)
//								{
//									i = problem->node[j].neighborNode[k].id;
//									if (problem->belong[i][assSP])
//										if (nextArr[j] != i)
//										{
//											//Update 9.12.2013
//										   insertCus[j][k]->var_vioCAP = 0; insertCus[j][k]->var_cost =0; 
//										   insertCus[j][k]->var_vioTWC = 0; insertCus[j][k]->var_vioTWSP = 0;
//										   cal_InsertCusPIAfterJ_LastC_NextTripD_SameSP(j, i, idVeh, idTrip, insertCus[j][k]->var_vioCAP, insertCus[j][k]->var_cost, insertCus[j][k]->var_vioTWC, insertCus[j][k]->var_vioTWSP);
//										   insertCus[j][k]->atIT = IT;
//										}
//									//else //neighbor k is already after j
//								}
//							}
//							else //j is the last pickup customer, nextTrip is delivery trip, difSP
//							{
//								for (k=0; k < problem->node[j].neighborSize; k++)
//								{
//									i = problem->node[j].neighborNode[k].id;
//									if (problem->belong[i][assSP])
//									if (nextArr[j] != i)
//									{
//										//Update 9.12.2013
//									   insertCus[j][k]->var_vioCAP = 0; insertCus[j][k]->var_cost =0; 
//									   insertCus[j][k]->var_vioTWC = 0; insertCus[j][k]->var_vioTWSP = 0;
//									   cal_InsertCusPIAfterJ_LastC_NextTripD_DifSP(j, i, idVeh, idTrip, insertCus[j][k]->var_vioCAP, insertCus[j][k]->var_cost, insertCus[j][k]->var_vioTWC, insertCus[j][k]->var_vioTWSP);
//									   insertCus[j][k]->atIT = IT;
//									}
//									//else //neighbor k is already after j
//								}
//							}
//						}
//						else //if (seg[idVeh].Trip[nextT].Type == 0||2) //j is the last pickup customer, nextTrip is pickup trip OR C2C
//						{
//							for (k=0; k < problem->node[j].neighborSize; k++)
//							{
//								i = problem->node[j].neighborNode[k].id;
//								if (problem->belong[i][assSP])
//								if (nextArr[j] != i)
//								{
//									//Update 9.12.2013
//								   insertCus[j][k]->var_vioCAP = 0; insertCus[j][k]->var_cost =0; 
//								   insertCus[j][k]->var_vioTWC = 0; insertCus[j][k]->var_vioTWSP = 0;
//								   cal_InsertCusPIAfterJ_LastC_NextTripPORC2C(j, i, idVeh, idTrip, insertCus[j][k]->var_vioCAP, insertCus[j][k]->var_cost, insertCus[j][k]->var_vioTWC, insertCus[j][k]->var_vioTWSP);
//								   insertCus[j][k]->atIT = IT;
//								}
//								//else //neighbor k is already after j
//							}
//					   } //end j is the last pickup customer, nextTrip is pickup trip OR C2C
//					}
//			}
//			else //j is not the last pickup customer
//			{
//				if (idTrip == lastT) // j is the not last pickup custmer of the last trip
//				{
//					for (k=0; k < problem->node[j].neighborSize; k++)
//					{
//						i = problem->node[j].neighborNode[k].id;
//						if (problem->belong[i][assSP])
//						if (nextArr[j] != i)
//						{
//							SUBcal_InsertCusPIAfterJ_NotLastC(j, i, idVeh, idTrip, insertCus[j][k]->var_vioCAP, insertCus[j][k]->var_cost, insertCus[j][k]->var_vioTWC, insertCus[j][k]->var_vioTWSP, cStartS);
//							insertCus[j][k]->atIT = IT;
//						}
//						//else //neighbor k is already after j
//					}
//				}
//				else // j is the not last pickup customer of the first/middle trip
//				{
//					int nextT = idTrip + 1;
//					if (seg[idVeh].Trip[nextT].Type == 1)
//					{
//						if (seg[idVeh].Trip[idTrip].assSP == seg[idVeh].Trip[nextT].assSP) //j is the not last pickup customer, nextTrip is delivery trip, sameSP
//						{
//							for (k=0; k < problem->node[j].neighborSize; k++)
//							{
//								i = problem->node[j].neighborNode[k].id;
//								if (problem->belong[i][assSP])
//								if (nextArr[j] != i)
//								{
//									//Update 9.12.2013
//								   insertCus[j][k]->var_vioCAP = 0; insertCus[j][k]->var_cost =0; 
//								   insertCus[j][k]->var_vioTWC = 0; insertCus[j][k]->var_vioTWSP = 0;
//
//								   cal_InsertCusPIAfterJ_NotLastC_NextTripD_SameSP(j, i, idVeh, idTrip, insertCus[j][k]->var_vioCAP, insertCus[j][k]->var_cost, insertCus[j][k]->var_vioTWC, insertCus[j][k]->var_vioTWSP);
//								   insertCus[j][k]->atIT = IT;
//								}
//								//else //neighbor k is already after j
//							}
//						}
//						else //j is not the last pickup customer, nextTrip is delivery trip, difSP
//						{
//							for (k=0; k < problem->node[j].neighborSize; k++)
//							{
//								i = problem->node[j].neighborNode[k].id;
//								if (problem->belong[i][assSP])
//								if (nextArr[j] != i)
//								{
//									//Update 9.12.2013
//								   insertCus[j][k]->var_vioCAP = 0; insertCus[j][k]->var_cost =0; 
//								   insertCus[j][k]->var_vioTWC = 0; insertCus[j][k]->var_vioTWSP = 0;
//								
//								   cal_InsertCusPIAfterJ_NotLastC_NextTripD_DifSP(j, i, idVeh, idTrip, insertCus[j][k]->var_vioCAP, insertCus[j][k]->var_cost, insertCus[j][k]->var_vioTWC, insertCus[j][k]->var_vioTWSP);
//								   insertCus[j][k]->atIT = IT;
//								}
//								//else //neighbor k is already after j
//							}
//						}
//					}
//					else //if (seg[idVeh].Trip[nextT].Type == 0 ||2)//j is not the last pickup customer, nextTrip is pickup trip OR C2C
//					{
//						for (k=0; k < problem->node[j].neighborSize; k++)
//						{
//							i = problem->node[j].neighborNode[k].id;
//							if (problem->belong[i][assSP])
//							if (nextArr[j] != i)
//							{
//								//Update 9.12.2013
//							   insertCus[j][k]->var_vioCAP = 0; insertCus[j][k]->var_cost =0; 
//							   insertCus[j][k]->var_vioTWC = 0; insertCus[j][k]->var_vioTWSP = 0;
//							   cal_InsertCusPIAfterJ_NotLastC_NextTripPORC2C(j, i, idVeh, idTrip, insertCus[j][k]->var_vioCAP, insertCus[j][k]->var_cost, insertCus[j][k]->var_vioTWC, insertCus[j][k]->var_vioTWSP);
//							   insertCus[j][k]->atIT = IT;
//							}
//							//else //neighbor k is already after j
//						}
//					} //end j is not the last pickup customer, nextTrip is pickup trip OR C2C
//				}
//			}//end //j is not the last pickup customer
//		}
//	}//end for j
//
//    cout<<"2.3 Insert C2C customers between trips: "<<endl;
//    //cout<<"insertCus[j][1]->var_vioCAP = "<<insertCus[startidC2C][1]->var_vioCAP<<endl;
//	int insertAfter;
//	for (j = startidC2C; j <= endidC2C; j++)
//	{
//		idVeh = route_num[j]; idTrip = trip_num[j];
//		lastT = seg[idVeh].numTrips - 1;
//		int nextSP = seg[idVeh].Trip[idTrip].nextSP;
//		if (idTrip == 0 && seg[idVeh].Trip[idTrip].numCus == 2 && nextSP > 0)
//		{
//			for (k=0; k < problem->node[j].neighborSize; k++)
//			{
//				i = problem->node[j].neighborNode[k].id; //for sure i is C2CP
//				if (problem->belong[i][nextSP])
//				{		
//					insertCus[j][k]->var_cost = 0;insertCus[j][k]->var_vioTWC = 0; insertCus[j][k]->var_vioTWSP = 0;insertCus[j][k]->var_vioCAP = 0;
//					SUBcal_InsertCusC2CIAfterJ_2CusFirstTrip_nextD(j,i,idVeh,nextSP, lastT,insertCus[j][k]->var_cost,insertCus[j][k]->var_vioTWC, insertCus[j][k]->var_vioTWSP,insertCus[j][k]->var_vioCAP,insertC2CDAfter[j][k],cStartS);
//					//cout<<"("<<j<<", "<<i<<") = "<<insertC2CDAfter[j][k]<<endl; 
//				}
//			}
// 		}
//		else
//		{
//			if (seg[idVeh].Trip[idTrip].lastCus == j) //j was the last cus of C2CTrip
//			{
//				if (idTrip == lastT) //j was last cus of last C2C trip
//				{
//					for (k=0; k < problem->node[j].neighborSize; k++)
//					{
//						i = problem->node[j].neighborNode[k].id;
//						if (nextArr[j] != i)
//						{
//							insertCus[j][k]->var_cost = 0;
//							insertCus[j][k]->var_vioTWC = 0;
//							cal_InsertCusC2CIAfterJ_LastC_LastTrip(depart[j],j, i, idVeh, idTrip,insertCus[j][k]->var_cost, insertCus[j][k]->var_vioTWC);
//							
//							insertCus[j][k]->var_vioTWSP = 0;
//							insertCus[j][k]->var_vioCAP = 0;
//							insertC2CDAfter[j][k] = i;
//							insertCus[j][k]->atIT = IT;
//							//cout<<"("<<j<<", "<<i<<") = "<<insertC2CDAfter[j][k]<<endl; 
//						}
//						//else //neighbor k is already after j
//					}
//				}
//				else //j was the last cus of not last C2C trip
//				{
//					if (nextSP > 0) //nextT is DTrip
//					{
//						for (k=0; k < problem->node[j].neighborSize; k++)
//						{
//							i = problem->node[j].neighborNode[k].id;
//							if (nextArr[j] != i)
//								if (problem->belong[i][nextSP])
//								{
//									insertCus[j][k]->var_cost = 0;
//									insertCus[j][k]->var_vioTWSP = 0;
//									insertCus[j][k]->var_vioTWC = 0;
//									cal_InsertCusC2CIAfterJ_LastC_NextD(depart[j],j, i, idVeh, idTrip,nextSP,insertCus[j][k]->var_cost,insertCus[j][k]->var_vioTWC, insertCus[j][k]->var_vioTWSP);
//									insertCus[j][k]->var_vioCAP = 0;
//									insertC2CDAfter[j][k] = i;
//									insertCus[j][k]->atIT = IT;
//									//cout<<"("<<j<<", "<<i<<") = "<<insertC2CDAfter[j][k]<<endl; 
//								}
//							//else //neighbor k is already after j
//						}
//					}
//					else //nextT is PTrip OR C2CTrip; j was the last cus of not last C2Ctrip
//					{
//						int nextT = idTrip + 1;
//						if (seg[idVeh].Trip[nextT].Type == 0) //nextT is pickup trip
//						{
//							int nextSP1 = seg[idVeh].Trip[nextT].assSP; 
//							for (k=0; k < problem->node[j].neighborSize; k++)
//							{
//								i = problem->node[j].neighborNode[k].id;
//								if (nextArr[j] != i && problem->belong[i][nextSP1])
//								{
//									insertCus[j][k]->var_cost = 0;insertCus[j][k]->var_vioTWSP = 0;insertCus[j][k]->var_vioTWC = 0;
//									cal_InsertCusC2CIAfterJ_LastC_NextTripPORC2C(depart[j],j,i,idVeh, idTrip,insertCus[j][k]->var_cost,insertCus[j][k]->var_vioTWC,insertCus[j][k]->var_vioTWSP);
//									insertCus[j][k]->var_vioCAP = 0;
//									insertC2CDAfter[j][k] = i;
//									insertCus[j][k]->atIT = IT;
//									//cout<<"("<<j<<", "<<i<<") = "<<insertC2CDAfter[j][k]<<endl; 
//								}
//								//else //neighbor k is already after j
//							}
//						}
//						else //nextT is C2C Trip
//						{
//							for (k=0; k < problem->node[j].neighborSize; k++)
//							{
//								i = problem->node[j].neighborNode[k].id;
//								if (nextArr[j] != i)
//								{
//									insertCus[j][k]->var_cost = 0;insertCus[j][k]->var_vioTWSP = 0;insertCus[j][k]->var_vioTWC = 0;
//									cal_InsertCusC2CIAfterJ_LastC_NextTripPORC2C(depart[j],j,i,idVeh, idTrip,insertCus[j][k]->var_cost,insertCus[j][k]->var_vioTWC,insertCus[j][k]->var_vioTWSP);
//									insertCus[j][k]->var_vioCAP = 0;
//									insertC2CDAfter[j][k] = i;
//									insertCus[j][k]->atIT = IT;
//									//cout<<"("<<j<<", "<<i<<") = "<<insertC2CDAfter[j][k]<<endl; 
//								}
//								//else //neighbor k is already after j
//							}
//						}
//					}//end nextT is PTrip OR C2CTrip
//				}//end j was the last cus of not last C2CTrip
//			}
//			else //j was not the last cus of C2CTrip:
//			{
//				if (idTrip == lastT) //j was not last cus of last C2C trip
//				{
//					for (k=0; k < problem->node[j].neighborSize; k++)
//					{
//						i = problem->node[j].neighborNode[k].id;
//						if (nextArr[j] != i)
//						{
//							insertCus[j][k]->atIT = IT;
//							insertCus[j][k]->var_vioTWSP = 0;
//							SUBcal_InsertCusC2CIAfterJ_NotLastC_LastTrip(depart[j],CAPCus[j],j,i,idVeh,idTrip,insertCus[j][k]->var_cost,insertCus[j][k]->var_vioTWC, insertCus[j][k]->var_vioCAP,insertAfter);
//							insertC2CDAfter[j][k] = insertAfter;
//							//cout<<"("<<j<<", "<<i<<") = "<<insertC2CDAfter[j][k]<<endl; 
//						}
//						//else //neighbor k is already after j
//					}
//				}
//				else //j was not the last cus of not last C2C trip
//				{
//					if (nextSP > 0) //nextT is DTrip
//					{
//						for (k=0; k < problem->node[j].neighborSize; k++)
//						{
//							i = problem->node[j].neighborNode[k].id;
//							if (nextArr[j] != i && problem->belong[i][nextSP])
//							{
//								insertCus[j][k]->atIT = IT;
//							    SUBcal_InsertCusC2CIAfterJ_NotLastC_NextD(depart[j],CAPCus[j],j,i,idVeh,idTrip,nextSP,insertCus[j][k]->var_cost,insertCus[j][k]->var_vioTWC, insertCus[j][k]->var_vioTWSP, insertCus[j][k]->var_vioCAP, insertAfter);
//								insertC2CDAfter[j][k] = insertAfter;
//								//cout<<"("<<j<<", "<<i<<") = "<<insertC2CDAfter[j][k]<<endl; 
//							}
//							//else //neighbor k is already after j
//						}
//					}
//					else //nextT is PTrip OR C2CTrip; j was not the last cus of not last C2Ctrip
//					{
//						int nextT = idTrip + 1;
//						if (seg[idVeh].Trip[nextT].Type == 0) //nextT is pickup trip
//						{
//							int nextSP1 = seg[idVeh].Trip[nextT].assSP;
//							for (k=0; k < problem->node[j].neighborSize; k++)
//							{
//								i = problem->node[j].neighborNode[k].id;
//								if (nextArr[j] != i && problem->belong[i][nextSP1])
//								{
//									insertCus[j][k]->atIT = IT;
//									SUBcal_InsertCusC2CIAfterJ_NotLastC_NextTripPORC2C(depart[j],CAPCus[j],j,i,idVeh,idTrip,insertCus[j][k]->var_cost,insertCus[j][k]->var_vioTWC, insertCus[j][k]->var_vioTWSP, insertCus[j][k]->var_vioCAP, insertAfter);
//									insertC2CDAfter[j][k] = insertAfter;
//									//cout<<"("<<j<<", "<<i<<") = "<<insertC2CDAfter[j][k]<<endl; 
//								}
//								//else //neighbor k is already after j
//							}
//						}
//						else //nextT is C2C Trip
//						{
//							for (k=0; k < problem->node[j].neighborSize; k++)
//							{
//								i = problem->node[j].neighborNode[k].id;
//								if (nextArr[j] != i)
//								{
//									insertCus[j][k]->atIT = IT;
//									SUBcal_InsertCusC2CIAfterJ_NotLastC_NextTripPORC2C(depart[j],CAPCus[j],j,i,idVeh,idTrip,insertCus[j][k]->var_cost,insertCus[j][k]->var_vioTWC, insertCus[j][k]->var_vioTWSP, insertCus[j][k]->var_vioCAP, insertAfter);
//									insertC2CDAfter[j][k] = insertAfter;
//									//cout<<"("<<j<<", "<<i<<") = "<<insertC2CDAfter[j][k]<<endl; 
//								}
//								//else //neighbor k is already after j
//							}
//						}//end //nextT is C2C Trip
//					}//end nextT is PTrip OR C2CTrip
//				}//end j was not the last cus of not last C2CTrip
//			}//end j was not the last cus of C2CTrip
//		}
//	}//end j
//    //cout<<"insertCus[j][1]->var_vioCAP = "<<insertCus[startidC2C][1]->var_vioCAP<<endl;
//
//	//3rd Tramsform: Move customer in one trip:
//	//3.1 Move delivery customer in one trip
//	cout<<"3.1 Move delivery customer in one trip"<<endl;
//	for (int ii=1; ii<=nSP; ii++) 
//	{
//		start = problem->startCusDSP[ii]; end = problem->endCusDSP[ii];
//		for (j=start;j<=end;j++)
//		{
//			idVeh = route_num[j]; idTrip = trip_num[j];
//			lastT = seg[idVeh].numTrips - 1;
//			if (idTrip == lastT) //j belongs to the last trip
//			{
//				//for each customer j, calculate moveCus[j][#its neighbor]: move its neighbor after j
//				for (k=0;k<problem->node[j].neighborSize; k++)
//				{
//					i = problem->node[j].neighborNode[k].id;
//             		if (nextArr[j] != i)
//					   if (idVeh == route_num[i]) //j and its neighbor are in the same route:
//					   {
//						   cal_MoveCusDIAfterJ_oneTrip_LastTrip(j,k, idVeh, idTrip); //calculate: move neighbor #k after j:
//					       //cout<<"(a "<<j<<", "<<i<<", "<<moveCus[j][k]->var_cost<<"), ";
//					   }
//				}
//			}
//			else //j doesn't belong to the last trip
//			{
//				int nextT = idTrip + 1;
//				if (seg[idVeh].Trip[nextT].Type == 1) //nextTrip is delivery trip
//				{
//					//for each customer j, calculate moveCusOneLeg[j][#its neighbor]: move its neighbor after j
//					for (k=0;k<problem->node[j].neighborSize; k++)
//					{
//						i = problem->node[j].neighborNode[k].id;
//             			if (nextArr[j] != i)
//						   if (idVeh == route_num[i]) //j and its neighbor are in the same route:
//						   {
//							   cal_MoveCusDIAfterJ_oneTrip_NextTripD(j,k, idVeh, idTrip); //calculate: move neighbor #k after j:
//						       //cout<<"(c "<<j<<", "<<i<<", "<<moveCus[j][k]->var_cost<<"), ";
//						   }
//					}
//				}
//				else //if (seg[idVeh].Trip[nextT].Type == 0 || 2 ) //nextTrip is pickup trip OR C2C
//				{
//					//for each customer j, calculate moveCusOneLeg[j][#its neighbor]: move its neighbor after j
//					for (k=0;k<problem->node[j].neighborSize; k++)
//					{
//						i = problem->node[j].neighborNode[k].id;
//             			if (nextArr[j] != i )
//						   if (idVeh == route_num[i]) //j and its neighbor are in the same route:
//						   {
//							   cal_MoveCusDIAfterJ_oneTrip_NextTripPORC2C(j,k, idVeh, idTrip); //calculate: move neighbor #k after j:
//						       //cout<<"(b "<<j<<", "<<i<<", "<<moveCus[j][k]->var_cost<<"), ";
//						   }
//					}
//				}
//			}
//		}
//	}
//
//	//3.2 Move pickup customers in one trip:
//	cout<<"3.2. Move pickup customers in one trip/oneveh+diftrip:"<<endl;
//	for (j= startidP; j <= endidP; j++)
//	{
//		idVeh = route_num[j]; idTrip = trip_num[j];
//		int assSP = seg[idVeh].Trip[idTrip].assSP;
//		lastT = seg[idVeh].numTrips - 1;
//		if (idTrip == lastT)
//		{
//			 //for each customer j, calculate moveCus[j][#its neighbor]: move its neighbor after j
//			 for (k=0;k<problem->node[j].neighborSize; k++)
//			 {
//				 i = problem->node[j].neighborNode[k].id;
//             	 if (nextArr[j] != i )
//					   if (idVeh == route_num[i])
//					   {
//						   if (idTrip == trip_num[i]) //j and its neighbor are in the same route:
//						   {
//							   cal_MoveCusPIAfterJ_oneTrip_LastTrip(j, i, idVeh, idTrip, moveCus[j][k]->var_cost, moveCus[j][k]->var_vioTWC, moveCus[j][k]->var_vioTWSP, cStartS);
//							   moveCus[j][k]->atIT = IT;
//						   }
//						   else if (problem->belong[i][assSP])
//						   {
//							   cal_MoveCusPIAfterJ_oneVeh(j, idTrip, i, trip_num[i], idVeh, moveCus[j][k]->var_cost, moveCus[j][k]->var_costi, moveCus[j][k]->var_costj, moveCus[j][k]->var_vioTWC, moveCus[j][k]->var_vioTWCi, moveCus[j][k]->var_vioTWCj, moveCus[j][k]->var_vioTWSP, moveCus[j][k]->var_vioTWSPi, moveCus[j][k]->var_vioTWSPj, moveCus[j][k]->var_vioCAP);
//							   moveCus[j][k]->atIT = IT;
//						   }
//					   }
//			 }
//		}
//		else //not the last trip
//		{
//			int nextT = idTrip + 1;
//			if (seg[idVeh].Trip[nextT].Type == 1) //nextTrip is delivery trip
//			{
//				if (seg[idVeh].Trip[idTrip].assSP == seg[idVeh].Trip[nextT].assSP) //nextTrip is delivery trip; same SP with previous pickup trip
//				{
//					 for (k=0;k<problem->node[j].neighborSize; k++)
//					 {
//						 i = problem->node[j].neighborNode[k].id;
//             			 if (nextArr[j] != i)
//							   if (idVeh == route_num[i])
//							   {
//								   if (idTrip == trip_num[i]) //j and its neighbor are in the same route:
//								   {
//									   cal_MoveCusPIAfterJ_oneTrip_NextTripD_SameSP(j, i, idVeh, idTrip, moveCus[j][k]->var_cost, moveCus[j][k]->var_vioTWC, moveCus[j][k]->var_vioTWSP);
//									   moveCus[j][k]->atIT = IT;
//								   }
//								   else if (problem->belong[i][assSP])
//								   {
//										cal_MoveCusPIAfterJ_oneVeh(j, idTrip, i, trip_num[i], idVeh, moveCus[j][k]->var_cost, moveCus[j][k]->var_costi, moveCus[j][k]->var_costj, moveCus[j][k]->var_vioTWC, moveCus[j][k]->var_vioTWCi, moveCus[j][k]->var_vioTWCj, moveCus[j][k]->var_vioTWSP, moveCus[j][k]->var_vioTWSPi, moveCus[j][k]->var_vioTWSPj, moveCus[j][k]->var_vioCAP);
//										moveCus[j][k]->atIT = IT;
//								   }
//							   }
//					 }
//				}
//				else //nextTrip is delivery trip; dif SP
//				{
//					 for (k=0;k<problem->node[j].neighborSize; k++)
//					 {
//						 i = problem->node[j].neighborNode[k].id;
//             			 if (nextArr[j] != i)
//							   if (idVeh == route_num[i])
//							   {
//								   if (idTrip == trip_num[i]) //j and its neighbor are in the same route:
//								   {
//									   cal_MoveCusPIAfterJ_oneTrip_NextTripD_DifSP(j, i, idVeh, idTrip, moveCus[j][k]->var_cost, moveCus[j][k]->var_vioTWC, moveCus[j][k]->var_vioTWSP);
//									   moveCus[j][k]->atIT = IT;
//								   }
//								   else if (problem->belong[i][assSP])
//								   {
//										cal_MoveCusPIAfterJ_oneVeh(j, idTrip, i, trip_num[i], idVeh, moveCus[j][k]->var_cost, moveCus[j][k]->var_costi, moveCus[j][k]->var_costj, moveCus[j][k]->var_vioTWC, moveCus[j][k]->var_vioTWCi, moveCus[j][k]->var_vioTWCj, moveCus[j][k]->var_vioTWSP, moveCus[j][k]->var_vioTWSPi, moveCus[j][k]->var_vioTWSPj, moveCus[j][k]->var_vioCAP);
//										moveCus[j][k]->atIT = IT;
//								   }
//							   }
//					 }
//				}//end nextTrip is delivery trip; dif SP
//			}
//			else //if (seg[idVeh].Trip[nextT].Type == 0 || 2) //nextTrip is pickup trip OR C2C
//			{
//				 for (k=0;k<problem->node[j].neighborSize; k++)
//				 {
//					 i = problem->node[j].neighborNode[k].id;
//             		 if (nextArr[j] != i)
//						   if (idVeh == route_num[i])
//						   {
//							   if (idTrip == trip_num[i]) //j and its neighbor are in the same route:
//							   {
//								   cal_MoveCusPIAfterJ_oneTrip_NextTripPORC2C(j, i, idVeh, idTrip, moveCus[j][k]->var_cost, moveCus[j][k]->var_vioTWC, moveCus[j][k]->var_vioTWSP);
//						       	   moveCus[j][k]->atIT = IT;
//							   }
//							   else if (problem->belong[i][assSP])
//							   {
//									cal_MoveCusPIAfterJ_oneVeh(j, idTrip, i, trip_num[i], idVeh, moveCus[j][k]->var_cost, moveCus[j][k]->var_costi, moveCus[j][k]->var_costj, moveCus[j][k]->var_vioTWC, moveCus[j][k]->var_vioTWCi, moveCus[j][k]->var_vioTWCj, moveCus[j][k]->var_vioTWSP, moveCus[j][k]->var_vioTWSPi, moveCus[j][k]->var_vioTWSPj, moveCus[j][k]->var_vioCAP);
//									moveCus[j][k]->atIT = IT;
//							   }
//						   }
//				 }
//			}//end nextTrip is pickup trip OR C2C trip
//		}//end not the last trip
//	}
//
//	cout<<"3.3 Move C2C order in one trip/oneVeh"<<endl;
//	for (j = startidC2C; j <= endidC2C; j++)
//	{
//		idVeh = route_num[j]; idTrip = trip_num[j];
//		lastT = seg[idVeh].numTrips - 1;
//		int nextSP = seg[idVeh].Trip[idTrip].nextSP; 
//		//Move after j
//		if (nextSP > 0) //j doesnot belong to last trip; nextTrip is DTrip
//		{
//			if (seg[idVeh].Trip[idTrip].lastCus == j) //j was the last cus of C2CTrip; not last trip
//			{
//				 for (k=0;k<problem->node[j].neighborSize; k++)
//				 {
//					 i = problem->node[j].neighborNode[k].id;
//     				 if (nextArr[j] != i && problem->belong[i][nextSP])
//						   if (idVeh == route_num[i])
//						   {
//							   if (idTrip == trip_num[i]) //j and its neighbor are in the same leg:
//							   {
//								   //cout<<"cal_MoveCusC2CIAfterJ_oneTrip_LastC("<<endl;
//								   cal_MoveCusC2CIAfterJ_oneTrip_LastC(j, i, k, idVeh, idTrip); //14/12/2013
//							   }
//							   else 
//							   {
//								   //cout<<"cal_MoveCusC2CIAfterJ_oneVeh_LastC"<<endl;
//								   cal_MoveCusC2CIAfterJ_oneVeh_LastC(j, idTrip, i, trip_num[i], idVeh,k); //14/12/2013
//							   }
//								//cout<<"MOVE ("<<j<<", "<<i<<") = "<<moveC2CDAfter[j][k]<<endl; 
//						   }
//				 }//end for k
//			}
//			else //j is not the last cus; nextTrip is DTrip
//			{
//				 for (k=0;k<problem->node[j].neighborSize; k++)
//				 {
//					 i = problem->node[j].neighborNode[k].id;
// 					 if (nextArr[j] != i && problem->belong[i][nextSP])
//						   if (idVeh == route_num[i])
//						   {
//							   if (idTrip == trip_num[i]) //j and its neighbor are in the same leg:
//							   {
//									moveCus[j][k]->var_cost = 0;
//									moveCus[j][k]->var_vioCAP = 0;
//									moveCus[j][k]->var_vioTWC = 0;
//									moveCus[j][k]->var_vioTWSP = 0;
//									//cout<<"cal_MoveCusC2CIAfterJ_oneTrip_NotLastC_nextD"<<endl;
//									cal_MoveCusC2CIAfterJ_oneTrip_NotLastC_nextD(j,i,idVeh,idTrip,nextSP,moveCus[j][k]->var_cost,moveCus[j][k]->var_vioTWC,moveCus[j][k]->var_vioTWSP,moveCus[j][k]->var_vioCAP,moveC2CDAfter[j][k]);
//									moveCus[j][k]->atIT = IT; 					
//							   }
//							   else 
//							   {
//								   //cout<<"cal_MoveCusC2CIAfterJ_oneVeh_NotLastC"<<endl;
//								   cal_MoveCusC2CIAfterJ_oneVeh_NotLastC(j, idTrip, i, trip_num[i], idVeh, k);
//							   }
//								//cout<<"MOVE ("<<j<<", "<<i<<") = "<<moveC2CDAfter[j][k]<<endl; 
//						   }
//				 }//end for k
//			}//end j is not the last cus; nextTrip is DTrip
//		}
//		else //nextSP < 0: nextTrip is PTrip OR C2C or is last Trip
//		{
//			if (seg[idVeh].Trip[idTrip].lastCus == j) //j was the last cus of C2CTrip
//			{
//					if (idTrip == lastT) //j is last cus of last C2C trip
//					{
//						 for (k=0;k<problem->node[j].neighborSize; k++)
//						 {
//							 i = problem->node[j].neighborNode[k].id;
//             				 if (nextArr[j] != i)
// 								   if (idVeh == route_num[i])
//								   {
//									   if (idTrip == trip_num[i]) //j and its neighbor are in the same leg:
//									   {
//										   //cout<<"cal_MoveCusC2CIAfterJ_oneTrip_LastTrip_LastC("<<endl;
//										   cal_MoveCusC2CIAfterJ_oneTrip_LastTrip_LastC(j, i, k, idVeh, idTrip);//14/12/2013
//									   }
//									   else //in different leg:
//									   {
//										   //cout<<"cal_MoveCusC2CIAfterJ_oneVeh_LastC("<<endl;
//										   cal_MoveCusC2CIAfterJ_oneVeh_LastC(j, idTrip, i, trip_num[i], idVeh,k);//14/12/2013
//									   }
//	   									//cout<<"MOVE ("<<j<<", "<<i<<") = "<<moveC2CDAfter[j][k]<<endl; 
//								   }
//						 }//end for k
//					}
//					else //j is the last cus, not last trip
//					{
//						 int nextT = idTrip + 1;
//						 if (seg[idVeh].Trip[nextT].Type == 0) //nextT is pickup trip; 
//						 {
//							 int nextSP1 = seg[idVeh].Trip[nextT].assSP;
//							 for (k=0;k<problem->node[j].neighborSize; k++)
//							 {
//								 i = problem->node[j].neighborNode[k].id;
//             					 if (nextArr[j] != i && problem->belong[i][nextSP1])
// 									   if (idVeh == route_num[i])
//									   {
//										   if (idTrip == trip_num[i]) //j and its neighbor are in the same leg:
//										   {
//											   //cout<<"cal_MoveCusC2CIAfterJ_oneTrip_LastC("<<endl;
//											   cal_MoveCusC2CIAfterJ_oneTrip_LastC(j, i, k, idVeh, idTrip); //14/12/2013
//										   }
//										   else 
//										   {
//											   //cout<<"cal_MoveCusC2CIAfterJ_oneVeh_LastC"<<endl;
//											   cal_MoveCusC2CIAfterJ_oneVeh_LastC(j, idTrip, i, trip_num[i], idVeh,k); //14/12/2013
//										   }
//		   									//cout<<"MOVE ("<<j<<", "<<i<<") = "<<moveC2CDAfter[j][k]<<endl; 
//									   }
//							 }//end for k
//						 }
//						 else //nextT is C2Ctrip; can't be DTrip because nextSP <0
//						 {
//							 for (k=0;k<problem->node[j].neighborSize; k++)
//							 {
//								 i = problem->node[j].neighborNode[k].id;
//             					 if (nextArr[j] != i)
// 									   if (idVeh == route_num[i])
//									   {
//										   if (idTrip == trip_num[i]) //j and its neighbor are in the same leg:
//										   {
//											   //cout<<"cal_MoveCusC2CIAfterJ_oneTrip_LastC("<<endl;
//											   cal_MoveCusC2CIAfterJ_oneTrip_LastC(j, i, k, idVeh, idTrip); //14/12/2013
//										   }
//										   else 
//										   {
//											   //cout<<"cal_MoveCusC2CIAfterJ_oneVeh_LastC"<<endl;
//											   cal_MoveCusC2CIAfterJ_oneVeh_LastC(j, idTrip, i, trip_num[i], idVeh,k); //14/12/2013
//										   }
//		   									//cout<<"MOVE ("<<j<<", "<<i<<") = "<<moveC2CDAfter[j][k]<<endl; 
//									   }
//							 }//end for k
//						 }//nextT is C2C Trip
//					}//end j is the last cus, not last trip
//			}
//			else //j is not the last cus
//			{
//					if (idTrip == lastT) //j is not last cus of last C2C trip
//					{
//						 for (k=0;k<problem->node[j].neighborSize; k++)
//						 {
//							 i = problem->node[j].neighborNode[k].id;
//             				 if (nextArr[j] != i)
// 								   if (idVeh == route_num[i])
//								   {
//									   if (idTrip == trip_num[i]) //j and its neighbor are in the same leg:
//									   {
//											moveCus[j][k]->var_cost = 0;
//											moveCus[j][k]->var_vioCAP = 0;
//											moveCus[j][k]->var_vioTWC = 0;
//											//cout<<"cal_MoveCusC2CIAfterJ_oneTrip_LastTrip_NotLastC"<<endl;
//											cal_MoveCusC2CIAfterJ_oneTrip_LastTrip_NotLastC(j,i,idVeh,idTrip,moveCus[j][k]->var_cost,moveCus[j][k]->var_vioTWC, moveCus[j][k]->var_vioCAP, moveC2CDAfter[j][k]); //14/12/2013
//											moveCus[j][k]->var_vioTWSP = 0;
//											moveCus[j][k]->atIT = IT;  
//									   }
//									   else 
//									   {
//										   //cout<<"cal_MoveCusC2CIAfterJ_oneVeh_NotLastC"<<endl;
//										   cal_MoveCusC2CIAfterJ_oneVeh_NotLastC(j, idTrip, i, trip_num[i], idVeh, k);
//									   }
//	   									//cout<<"MOVE ("<<j<<", "<<i<<") = "<<moveC2CDAfter[j][k]<<endl; 
//								   }
//						 }//end for k
//					}
//					else //j is not the last cus, not last trip (nextT is PTrip OR c2c; can't DTrip because nextSP < 0)
//					{
//						 int nextT = idTrip + 1;
//						 if (seg[idVeh].Trip[nextT].Type == 0) //nextT is pTrip
//						 {
//							 int nextSP1 = seg[idVeh].Trip[nextT].assSP;
//							 for (k=0;k<problem->node[j].neighborSize; k++)
//							 {
//								 i = problem->node[j].neighborNode[k].id;
//         						 if (nextArr[j] != i && problem->belong[i][nextSP1])
//									   if (idVeh == route_num[i])
//									   {
//										   if (idTrip == trip_num[i]) //j and its neighbor are in the same leg:
//										   {
//												moveCus[j][k]->var_cost = 0;
//												moveCus[j][k]->var_vioCAP = 0;
//												moveCus[j][k]->var_vioTWC = 0;
//												moveCus[j][k]->var_vioTWSP = 0;
//												//cout<<"cal_MoveCusC2CIAfterJ_oneTrip_NotLastC_NextTripPORC2C"<<endl;
//												cal_MoveCusC2CIAfterJ_oneTrip_NotLastC_NextTripPORC2C(j,i,idVeh,idTrip,moveCus[j][k]->var_cost,moveCus[j][k]->var_vioTWC, moveCus[j][k]->var_vioTWSP,moveCus[j][k]->var_vioCAP, moveC2CDAfter[j][k]); 
//												moveCus[j][k]->atIT = IT; 
//										   }
//										   else 
//										   {
//											   //cout<<"cal_MoveCusC2CIAfterJ_oneVeh_NotLastC: j = "<<j<<" with idTrip = "<<idTrip<<"; i = "<<i<<" with idTrip = "<<trip_num[i]<<endl;
//											   cal_MoveCusC2CIAfterJ_oneVeh_NotLastC(j, idTrip, i, trip_num[i], idVeh, k);
//										   }
//		   									//cout<<"MOVE ("<<j<<", "<<i<<") = "<<moveC2CDAfter[j][k]<<endl; 
//									   }
//							 }//end for k
//						 }
//						 else //nextT is C2CTrip can't Dtrip because nextSP < 0
//						 {
//							 for (k=0;k<problem->node[j].neighborSize; k++)
//							 {
//								 i = problem->node[j].neighborNode[k].id;
//         						 if (nextArr[j] != i)
//									   if (idVeh == route_num[i])
//									   {
//										   if (idTrip == trip_num[i]) //j and its neighbor are in the same leg:
//										   {
//												moveCus[j][k]->var_cost = 0;
//												moveCus[j][k]->var_vioCAP = 0;
//												moveCus[j][k]->var_vioTWC = 0;
//												moveCus[j][k]->var_vioTWSP = 0;
//												//cout<<"cal_MoveCusC2CIAfterJ_oneTrip_NotLastC_NextTripPORC2C"<<endl;
//												cal_MoveCusC2CIAfterJ_oneTrip_NotLastC_NextTripPORC2C(j,i,idVeh,idTrip,moveCus[j][k]->var_cost,moveCus[j][k]->var_vioTWC, moveCus[j][k]->var_vioTWSP,moveCus[j][k]->var_vioCAP, moveC2CDAfter[j][k]); 
//												moveCus[j][k]->atIT = IT; 
//										   }
//										   else 
//										   {
//											   //cout<<"cal_MoveCusC2CIAfterJ_oneVeh_NotLastC: j = "<<j<<" with idTrip = "<<idTrip<<"; i = "<<i<<" with idTrip = "<<trip_num[i]<<endl;
//											   cal_MoveCusC2CIAfterJ_oneVeh_NotLastC(j, idTrip, i, trip_num[i], idVeh, k);
//										   }
//		   									//cout<<"MOVE ("<<j<<", "<<i<<") = "<<moveC2CDAfter[j][k]<<endl; 
//									   }
//							 }//end for k
//						 }//end //nextT is C2CTrip can't Dtrip because nextSP < 0
//					}//end j is not the last cus, not last trip
//			}//end j is not the last trip
//		}//end nextSP < 0
//	}//end j
//	
//	//4th Transform: Exchange customer:
// 	//4.1 Exchange delivery customers:
//	cout<<"4.1 Exchange delivery customers"<<endl;
//
//	for (i=1; i<=nSP; i++) 
//	{
//		start = problem->startCusDSP[i]; end = problem->endCusDSP[i];
//		for (j=start;j<=end;j++)
//		{
//			//for each customer j, calculate exchangeCus[j][#its neighbor]:
//          	for (k=0;k<problem->node[j].neighborSize; k++)
//			{
//				    //calculate: exchange customer j and its neighbor #k:
//					cal_ExchangeCusDIAndJ(j,k);
//				    exchangeCus[j][k]->atIT=IT;
//			}
//		}
//	}
//
// 	//4.2 Exchange pickup customers:
//	cout<<"4.2 Exchange pickup customers"<<endl;
//
//	for (j=startidP; j <= endidP; j++) 
//	{
//		//for each customer j, calculate exchangeCus[j][#its neighbor]:
//		assSP = seg[route_num[j]].Trip[trip_num[j]].assSP;
//      	for (k=0;k<problem->node[j].neighborSize; k++)
//		{
//			//calculate: exchange customer j and its neighbor #k:
//			i = problem->node[j].neighborNode[k].id;
//			if (problem->belong[i][assSP] && problem->belong[j][seg[route_num[i]].Trip[trip_num[i]].assSP])
//			{
//				cal_ExchangeCusPIAndJ(j,k);
//			    exchangeCus[j][k]->atIT=IT;
//			}
//		}
//	}
//
//	cout<<"4.3 Exchange c2c customers"<<endl;
//	for (j=startidC2C; j<= endidC2CP;j++) //exchange neighbors C2CP and C2CP
//	{
//		idVeh = route_num[j]; idTrip = trip_num[j];
//		for (k=0;k<problem->nodeC2C[j].neighborSizeExchange;k++)
//		{
//			//calculate: exchange customer j and its neighbor #k:
//			i = problem->nodeC2C[j].neighborNodeExchange[k].id;
//			if (i >= problem->startidC2CD)
//			{
//				cout<<"ERROR: i = "<<i<<" is not c2cp"<<endl;cout<<"j = "<<j<<"; i is its "<<k<<" neighbors"<<endl;
//			    cout<<"C2CP id = "<<problem->startidC2C<<"... "<<problem->endidC2CP<<endl;
//			    cout<<"C2CD id = "<<problem->startidC2CD<<" ... "<<problem->endidC2C<<endl;
//			    exit(-1);
//			}
//			cal_ExchangeCusC2CIAndJ(j,k);
//			exchangeCus[j][k]->atIT=IT;
//		}//for k
//	}
//
//	//5th Transform: 2opt*:
//	//5.1 2opt* delivery customers:
//	cout<<"5.1 2opt* delivery customers"<<endl;
//
//	int i1,startj, startNeighbor;
// 	for (i1=1; i1<=nSP; i1++)  //don't check the last sp
//	{
//		start = problem->startCusDSP[i1]; end = problem->endCusDSP[i1];
//		for (j=start;j<=end;j++)
//		{
//			//for each customer j, calculate twoOPTCus[j][#its neighbor]:
//            startj = pos[j];
//			idVeh = route_num[j]; idTrip = trip_num[j];
//			int nextTrip = idTrip + 1;
//			if (nextTrip == seg[idVeh].numTrips) //j belongs to the last Trip
//			{
//				for (k=0;k<problem->node[j].neighborSize; k++)
//				{
//					  //calculate: 2opt* customer j and its neighbor #k:
//					  i = problem->node[j].neighborNode[k].id;
//					  //cout<<"($j = "<<j<<", "<<i<<": ";
//					  if (idVeh != route_num[i]) //j and its neighbor i belong to different vehicles
//							 cal_twoOPTstarCusDIAndJ(j,k); //27/11/2013
//					  else //j and i belong to the same trip
//					  {
//						  //j has to be placed before its neighbor #k in the current route:
//						  if (nextArr[j] != i)
//						  {
//							  startNeighbor = pos[i];
//							  if (startj < startNeighbor)
//								  cal_twoOPTstarCusDIAndJ_oneTrip_LastTrip(j,k); //27/11/2013
//						  }
//					  }
// 					  twoOPTstarCus[j][k]->atIT=IT;
//    			}
//			}
//			else //j doesn't belongs to the last trip
//			{
//				if (seg[idVeh].Trip[nextTrip].Type == 1) //nextTrip is delivery 
//				{
//					for (k=0;k<problem->node[j].neighborSize; k++)
//					{
//							//calculate: exchange customer j and its neighbor #k:
//						  i = problem->node[j].neighborNode[k].id;
//						  //cout<<"(#j = "<<j<<", "<<i<<": ";
//						  if (idVeh != route_num[i])
//								 cal_twoOPTstarCusDIAndJ(j,k); //27/11/2013
//						  else 
//						  {
//							  //j has to be placed before its neighbor #k in the current route:
//							  if (nextArr[j]!= i)
//							  {
//								  startNeighbor = pos[i];
//								  if (startj < startNeighbor)
//								  {
//									  //cout<<"j = "<<j<<"; i = "<<idI<<"; startj = "<<startj<<"; startNeighbor = "<<startNeighbor<<endl;
//									  //cout<<"8. j = "<<j<<"; i = "<<i<<endl;
//									  cal_twoOPTstarCusDIAndJ_oneTrip_NextTripD(j,k);
//								  }
//							  }
//
//						  }
// 						  twoOPTstarCus[j][k]->atIT=IT;
//    				}
//				}
//				else //if (seg[idVeh].Trip[nextTrip].Type == 0 ||2)//nextTrip is pickup OR C2C
//				{
//					for (k=0;k<problem->node[j].neighborSize; k++)
//					{
//						  //calculate: exchange customer j and its neighbor #k:
//						  
//						  i = problem->node[j].neighborNode[k].id;
//						  //cout<<"(@j = "<<j<<", "<<i<<": ";
//						  if (idVeh != route_num[i])
//								 cal_twoOPTstarCusDIAndJ(j,k);
//						  else 
//						  {
//							  //j has to be placed before its neighbor #k in the current route:
//							  if (nextArr[j] != i)
//							  {
//								  startNeighbor = pos[i];
//								  if (startj < startNeighbor)
//									  cal_twoOPTstarCusDIAndJ_oneTrip_NextTripPORC2C(j,k);
//							  }
//
//						  }
// 						  twoOPTstarCus[j][k]->atIT=IT;
//    				}
//				}//end nextTrip is pickup OR C2C
//			}//end j doesn't belongs to the first trip
//		}
//	}
//
//	cout<<"5.2 2opt* pickup customers"<<endl;
//
// 	for (j=startidP;j <= endidP;j++)
//	{
//			//for each customer j, calculate twoOPTCusP[j][$its neighbor]:
//			idVeh = route_num[j]; idTrip = trip_num[j];
//			assSP = seg[idVeh].Trip[idTrip].assSP;
//			for (k=0;k<problem->node[j].neighborSize; k++)
//			{
//				  //calculate: exchange customer j and its neighbor #k:
//				  i = problem->node[j].neighborNode[k].id;
//				  if (assSP != seg[route_num[i]].Trip[trip_num[i]].assSP)
//				     twoOPTstarCus[j][k]->var_vioCAP = PDS_INFINITY_INT;
//				  else
//				  {
//					  if (idVeh != route_num[i]) //dif veh, dif trip
//					  {
//						  cal_twoOPTstarCusPIAndJ(j,k);
//					  }
//					  else //same vehicle
//					  {
//						  if (idTrip == trip_num[i]) //same trip, same vehicle
//						  {
//							  //j has to be placed before its neighbor #k in the current route:
//							  if (pos[i] > pos[j] && nextArr[j] != i)  
//							  {
//								  cal_twoOPTstarCusPIAndJ_oneTrip(j,k);
//							  }
//							  else twoOPTstarCus[j][k]->var_vioCAP = PDS_INFINITY_INT;
//						  }//end same trip, same vehicle
//					  }//end same vehicle
//				  }
// 				  twoOPTstarCus[j][k]->atIT=IT;
//    		}
//	}
//
//    cout<<"6th. Move sp: "<<endl; 
//	/*for (idVeh=0;idVeh<numVeh;idVeh++)
//	{
//		//cout<<"At vehicle "<<idVeh<<endl;
//		UpdateMoveSPArray_MoveOut(idVeh);
//		UpdateMoveSPArrayEmptyVeh(idVeh);
//		//UpdateMoveSPArray_MoveIn(idVeh);
//	}*/
//}

//------------------------------------------------- TABU ----------------------------------------------------/
//bool Solution::TabuMAIN1(int max_iteration, Solution &solBEST)
//{
//     int i;
//
//	 moveE.obj = new variationTQ();
//	 best_move.obj = new variationTQ();
//     best_move.feasible=0;
//	 best_move.obj->var_fitness = PDS_INFINITY;
//     
//     double fitstart = fitness;
//     double fitIMP = fitstart;
//     double fitFEA = PDS_INFINITY;
//
//     int updateBEST=0;
//     int type;
//     int numVehBEST=numVeh; //int ITBEST=-1;
//
//	 
//	 for (i=1;i<=problem->nSP;i++) ITTabuCustomerZone[i]=0;
//	 ITTabuP = 0;
//	 ITTabuMoveSP=0;
//
// 	 int nonIMP=0; 
//	 int PROB=0;  int numCool=0, loopDIVER=0;
//	 bool CONT = 1;
//
//
//     IT=0;
//	 do
//	 {
//		   IT++;
//		   if (PROB==0) type = Rand(0,6); //7 neighborhoods are shared the same probability of selection
//		   else
//		   {
//				type = Rand(0, PROB);
//				if (type== PROB) type = 6;
//				else type = Rand(0,5);
//		   }
//		   //cout<<"ITER "<<IT<<": type = "<<type<<endl;
//		   //Initialization costs of movement:
//		   best_move.obj->var_cost = PDS_INFINITY;
//		   best_move.obj->var_fitness = PDS_INFINITY;
//		   CallEvaluate(type);
//
//		   if (best_move.obj->var_fitness < PDS_INFINITY) 
//		   {
//				  // cout<<"best_move.obj = "<<best_move.obj->var_fitness<<endl;
//				   if (best_move.type <=2) 
//				   {
//					   cout<<"atIT = "<<IT<<": On pickup cus; type = "<<best_move.type<<"; j = "<<best_move.idCus1<<" of trip("<<route_num[best_move.idCus1]<<", "<<trip_num[best_move.idCus1]<<"); i = "<<best_move.idCus2<<" of trip("<<route_num[best_move.idCus2]<<", "<<trip_num[best_move.idCus2]<<")"<<endl;
//					   update_solutionCusP(best_move);
//				   }
//				   else  if (best_move.type <=5) 
//				   {
//					   cout<<"atIT = "<<IT<<": On delivery cus; type = "<<best_move.type<<"; j = "<<best_move.idCus1<<" of trip("<<route_num[best_move.idCus1]<<", "<<trip_num[best_move.idCus1]<<"); i = "<<best_move.idCus2<<" of trip("<<route_num[best_move.idCus2]<<", "<<trip_num[best_move.idCus2]<<")"<<endl;
//					   update_solutionCusD(best_move);
//				   }
//				   /*else if (best_move.type == 6)
//				   {
//					   //cout<<"atIT = "<<IT<<": MoveSP"<<endl;
//					   update_solutionSP(best_move);
//				   }*/
//				   update_parameters();
//				   //cout<<"vioCAPC = "<<vioCAPC<<"; vioTWCus = "<<vioTWCC<<"; vioTWSP = "<<vioTWSPC<<endl;
//				   if (vioCAPC==0 && vioTWCC==0 && vioTWSPC==0)
//				   {
//					   //nonFEA=0;
//					   if (PDSGREATER(FITBEST,fitness))
//					   {
//							 cout<<"NEW BEST SOL: checking....";
//							 FITBEST = fitness; COSTBEST = cost; numVehBEST = numVehUsed;
//
//							 solBEST = (*this); 
//							 bool correct = solBEST.checkSolution();
//							 if (!correct) {cout<<"ERROR!!!!!!!!!"<<endl; exit(-1);}
//							 else cout<<"finish: FIT = "<<FITBEST<<"; COST = "<<COSTBEST<<endl;
//							 ITBEST = IT;
//							 solBEST.showSolution();
//							 nonIMP = 0;
//							 pushElite(PROB);
//					   }
//					  // else cout<<"FEASIBLE IT "<<IT<<"("<<best_move.type<<"): cost = "<<cost<<"; numVehUsed = "<<numVehUsed<<endl;
//				   }//end if (feasible)
//				   nonIMP ++;
//				   if (nonIMP%COOLITER==0) //after COOLITER iterations without improvement, do Cooling or Diversification:
//				   {
//					   if (numCool == COOLTIMES)
//					   {
//						   if  (cursizeE > 0)
//						   {
//								   numCool=0; 
//								   cout<<"Elite: ";
//								   for (int cut=0;cut<cursizeE;cut++)
//									   cout<<Elite[cut].fitness<<"\t";
//								   cout<<endl;
//
//								   PROB = popElite();
//								   cout<<"--> Pop the one with fit = "<<fitness<<endl;
//								   //REinit tabu:
//								   init_arrayTABU(); 
//						   }
//						   else CONT=0;
//					   }
//					   else
//					   {
//						   PROB += COOLPROB; nonIMP=0; numCool++;
//						   cout<<"At iter "<<IT<<": update PROB = "<<PROB<<"; curSOL: (fit = "<<fitness<<", cost = "<<cost<<", "<<feasible<<")"<<endl;
//					   }
//				   }
//		   } //end if (best_move.obj->var_fitness < TMM_INFINITY)
//	 } while (IT<=max_iteration && CONT);
//	 
//	 //showSolution();
//     delete best_move.obj;
//	 delete moveE.obj;
//	 solBEST.checkSolution();
//	 solBEST.showSolution();
//
//	cout<<solBEST.cost<<"   "<<solBEST.numVehUsed<<"   "<<endl;
//	cout<<COSTINIT<<"   "<<VEHINIT<<endl;
//	cout<<ITBEST<<endl;
//	cout<<"-----------------------"<<endl;
//	cout<<solBEST.cost<<endl;
//	cout<<solBEST.numVehUsed<<endl;
//	cout<<COSTINIT<<endl;
//	cout<<VEHINIT<<endl;
//	cout<<ITBEST<<endl;
//	solBEST.calReport();
//	return 1;
//}


//bool Solution::TabuMAIN(int max_iteration, Solution &solBEST)
//{
//     int i;
//	 moveE.obj = new variationTQ();
//	 best_move.obj = new variationTQ();
//     best_move.feasible=0;
//	 best_move.obj->var_fitness = PDS_INFINITY;
//     
//     double fitstart = fitness;
//     double fitIMP = fitstart;
//     double fitFEA = PDS_INFINITY;
//
//     int updateBEST=0;
//     int type;
//     int numVehBEST=numVeh; //int ITBEST=-1;
//
//	 
//	 for (i=1;i<=problem->nSP;i++) ITTabuCustomerZone[i]=0;
//	 ITTabuP = 0; ITTabuC2C = 0;
//	 ITTabuMoveSP=0;
//
//     IT=0;
//	 do
//	 {
//		   IT++;
//		   type = 6;
//		   //cout<<"ITER "<<IT<<": type = "<<type<<endl;
//		   //Initialization costs of movement:
//		   best_move.obj->var_cost = PDS_INFINITY;
//		   best_move.obj->var_fitness = PDS_INFINITY;
//		   CallEvaluate(type);
//
//		   if (best_move.obj->var_fitness < PDS_INFINITY) 
//		   {
//				  // cout<<"best_move.obj = "<<best_move.obj->var_fitness<<endl;
//				   if (best_move.type <=2) 
//				   {
//					   cout<<"atIT = "<<IT<<": On pickup cus; type = "<<best_move.type<<"; j = "<<best_move.idCus1<<"("<<problem->node[best_move.idCus1].id<<") of trip("<<route_num[best_move.idCus1]<<", "<<trip_num[best_move.idCus1]<<"); i = "<<best_move.idCus2<<"("<<problem->node[best_move.idCus2].id<<") of trip("<<route_num[best_move.idCus2]<<", "<<trip_num[best_move.idCus2]<<")"<<endl;
//					   update_solutionCusP(best_move);
//				   }
//				   else  if (best_move.type <=5) 
//				   {
//					   cout<<"atIT = "<<IT<<": On delivery cus; type = "<<best_move.type<<"; j = "<<best_move.idCus1<<"("<<problem->node[best_move.idCus1].id<<") of trip("<<route_num[best_move.idCus1]<<", "<<trip_num[best_move.idCus1]<<"); i = "<<best_move.idCus2<<"("<<problem->node[best_move.idCus2].id<<") of trip("<<route_num[best_move.idCus2]<<", "<<trip_num[best_move.idCus2]<<")"<<endl;
//					   update_solutionCusD(best_move);
//				   }
//				   else if (best_move.type == 6)
//				   {
//					   cout<<"atIT = "<<IT<<": On C2C; type = "<<best_move.type<<"; move i = "<<best_move.idCus2<<"("<<problem->node[best_move.idCus2].id<<") of trip("<<route_num[best_move.idCus2]<<", "<<trip_num[best_move.idCus2]<<") after j = "<<best_move.idCus1<<"("<<problem->node[best_move.idCus1].id<<") of trip("<<route_num[best_move.idCus1]<<", "<<trip_num[best_move.idCus1]<<");"<<endl;
//					   int jj = best_move.idCus1;
//					   int nextSP = seg[route_num[jj]].Trip[trip_num[jj]].nextSP;
//					   if (nextSP > 0)
//					   {
//						   int ii = best_move.idCus1;
//					       cout<<ii<<" belong to sp "<<nextSP<<" = "<<problem->belong[ii][nextSP]<<endl;
//					   }
//					   update_solutionC2C(best_move);
//				   }
//				   /*else if (best_move.type == 9)
//				   {
//					   //cout<<"atIT = "<<IT<<": MoveSP"<<endl;
//					   update_solutionSP(best_move);
//				   }*/
//				   update_parameters();
//				   cout<<"vioCAPC = "<<vioCAPC<<"; vioTWCus = "<<vioTWCC<<"; vioTWSP = "<<vioTWSPC<<endl;
//				   if (vioCAPC==0 && vioTWCC==0 && vioTWSPC==0)
//				   {
//					   //nonFEA=0;
//					   if (PDSGREATER(FITBEST,fitness))
//					   {
//							 cout<<"NEW BEST SOL at IT = "<<IT<<": checking....";
//							 FITBEST = fitness; COSTBEST = cost; numVehBEST = numVehUsed;
//
//							 solBEST = (*this); 
//							 bool correct = solBEST.checkSolution();
//							 if (!correct) {cout<<"ERROR!!!!!!!!!"<<endl; exit(-1);}
//							 else cout<<"finish: FIT = "<<FITBEST<<"; COST = "<<COSTBEST<<endl;
//							 ITBEST = IT;
//							 //solBEST.showSolution();
//							 if (FITBEST < 0)
//							 {
//								 cout<<"ERRORRRRRRRRRRRRR  FITBEST = "<<FITBEST<<" < 0"<<endl;
//								 cout<<"numVehUsed = "<<numVehUsed<<endl;
//
//								for (int ii=0;i<numVeh;i++)
//								{
//									int numT = seg[ii].numTrips;
//									for (int jj=0;jj<numT;jj++)
//									{
//										if (seg[ii].Trip[jj].fitness < eps)
//										{
//											cout<<"FITNESS of trip ("<<ii<<", "<<jj<<") = "<<seg[ii].Trip[jj].fitness<<endl;
//										}
//									}
//								}
//								 exit(-1);
//							 }
//					   }
//					  // else cout<<"FEASIBLE IT "<<IT<<"("<<best_move.type<<"): cost = "<<cost<<"; numVehUsed = "<<numVehUsed<<endl;
//				   }//end if (feasible)
//		   } //end if (best_move.obj->var_fitness < TMM_INFINITY)
//	 } while (IT<=max_iteration);
//	 
//	 //showSolution();
//     delete best_move.obj;
//	 delete moveE.obj;
//	 solBEST.checkSolution();
//	 solBEST.showSolutionTempToCheck();
//
//	cout<<solBEST.cost<<"   "<<solBEST.numVehUsed<<"   "<<endl;
//	cout<<COSTINIT<<"   "<<VEHINIT<<endl;
//	cout<<ITBEST<<endl;
//	cout<<"-----------------------"<<endl;
//	cout<<solBEST.cost<<endl;
//	cout<<solBEST.numVehUsed<<endl;
//	cout<<COSTINIT<<endl;
//	cout<<VEHINIT<<endl;
//	cout<<ITBEST<<endl;
//	//solBEST.calReport();
//	return 1;
//}
//
//void Solution::pushElite(int PROB)
//{
//	int i;
//	if (cursizeE < sizeE)
//	{
//		if (cursizeE==0)
//		{
//             cursizeE++;
//			 Elite[0] = (*this);
//			 ratioE[0] = PROB;
//		}
//		else
//		{
//		    int dif;
//			int maxTrip,criteriaBound,idDel=-1,smallest = totalNODE + 100;
//			//if (cursizeE > 100) {cout<<"Elite set > 100 ERRORRRRRRRRR "<<endl;exit(-1);}
//			for (i=0;i<cursizeE;i++)
//			{
//                 maxTrip = max(numTrips, Elite[i].numTrips)/2;
//                 criteriaBound = (int) (0.05*totalNODE + maxTrip); 
//                 dif = Difference(i);  
//				 if (dif <= criteriaBound) //should be replaced
//				 {
//					 if (dif < smallest)
//					 {
//						 smallest = dif;
//						 idDel=i;
//					 }
//				 }
//			}
//			if (idDel !=-1) 
//			{
//				Elite[idDel] = (*this);  //replace
//				ratioE[idDel] = PROB;
//				cout<<"Replace = "<<smallest<<";";
//			}
//			else 
//			{
//				Elite[cursizeE] = (*this);
//				ratioE[cursizeE] = PROB;
//				cursizeE++;
//			}
//		}
//	}
//	else //elite set is full
//	{
//		    //find the one most similar (smallest difference):
//		    int smallest = totalNODE+100, idDel = -1;
//            int dif;
//			for (i=0;i<sizeE;i++)
//			{
//                 dif = Difference(i);  
//				 if (dif < smallest)
//				 {
//					  smallest = dif;
//					  idDel=i;
//				 }
//			}
//			Elite[idDel] = (*this);
//			ratioE[idDel] = PROB;
//	}
//    cout<<"Elite: ";
//	for (int cut=0;cut<cursizeE;cut++)
//		   cout<<Elite[cut].fitness<<"("<<ratioE[cut]<<");   ";
//	cout<<endl;
//
//
//}
//
//
//int Solution::Difference(int idElite)
//{
//   int i,dif = 0;
//   for (i=startidP;i<=endidD;i++)
//      if (nextArr[i] != Elite[idElite].nextArr[i]) dif++;
//   return dif;
//}
//
//
//int Solution::popElite()
//{
//   int i,j=cursizeE-1;
//   int idElite = Rand(0,j);
//   (*this) = Elite[idElite];
//   int PROB = ratioE[idElite];
//   if (idElite < j)
//   {
//	   for (i=idElite;i<j;i++) 
//	   {
//		   Elite[i] = Elite[i+1];
//		   ratioE[i] = ratioE[i+1];
//	   }
//   }
//   cursizeE=j;
//   return PROB;
//}
//
//
//void Solution::update_parameters()
//{
//	if (vioCAPC==0)
//	{
//		VCAP = (double) (VCAP/(penalty));
//		if (VCAP < 1E-3) VCAP = (double) VCAP_START; 
//		//IT_inCAP=0;
//	}
//	else 
//	{
//		/*IT_inCAP++;
//        if (IT_inCAP > MAXIT_inCAP) VCAP *=(1+penalty);
//		else VCAP =VCAP+1;*/
//		VCAP*=(penalty);
//		if (VCAP > 100000) VCAP=VCAP_START;
//	}
//	if (vioTWCC==0)
//	{
//		VTWCUS = (double) (VTWCUS/(penalty));
//		if (VTWCUS < 1E-3) VTWCUS = (double) VTWCUS_START;
//	}
//	else 
//	{
//		VTWCUS *=(penalty);
//		if (VTWCUS >100000) VTWCUS=VTWCUS_START;
//	}
//	
//	//double temp = abs(vioTWSPC - vioTWSPCOLD);
//	//if (temp > eps) //TWSP changed
//	//{
//		if (vioTWSPC==0)
//		{
//			VTWSP = (double) (VTWSP/(penalty));
//			if (VTWSP < 0.001) VTWSP = (double) VTWSP_START;
//		}
//		else 
//		{
//			VTWSP *=(penalty);
//			if (VTWSP >10000000) VTWSP=VTWSP_START;		}
//	//	vioTWSPCOLD = vioTWSPC;
//	//}
//	//if (vioTWSPC>0) {cout<<"TWSPC >0!!!!!!!!!!"<<endl;getch();}
//	UpdateCostFitnessFeasible1(); //dont need to check tung trip like in UpdateCostFitnessFeasible
//	//cout<<"COEF: VCAP = "<<VCAP<<"; VTWCUS = "<<VTWCUS<<"; VTWSP = "<<VTWSP<<endl;
//	//showSolution();
//}


//void Solution::CallEvaluate(int type)
//{
//     int j,k;
//	 int numNeighbor;
//	 FOUNDNEWBESTATTHISIT = 0;
//
//	 if (type <= 2) //DEAL WITH PICKUP CUSTOMERS:
//	 {
//		 moveE.type=type;
//		 for (j=startidP; j<= endidP; j++)
//		 {
//               moveE.idCus1 = j;
//			   //insert its #k neighbor after it:
//			   numNeighbor = problem->node[j].neighborSize;
//			   for (k=0; k < numNeighbor;k++)
//			   {
//				   moveE.idNeighbor = k;
//				   moveE.idCus2 = problem->node[j].neighborNode[k].id;
//				   evaluate_moveCusP(moveE);
//			   }
//		 }//end for i 
//	 }
//	 else if (type <= 5) //DEAL WITH DELIVERY CUSTOMERS:
//	 {
//		 moveE.type = type - 3;
//		 for (j=startidD; j<= endidD;j++)
//		 {
//               moveE.idCus1 = j;
//			   //insert its #k neighbor after it:
//			   numNeighbor = problem->node[j].neighborSize;
//			   for (k=0; k<numNeighbor;k++)
//			   {
//				   moveE.idNeighbor = k;
//				   moveE.idCus2 = problem->node[j].neighborNode[k].id;
//				   evaluate_moveCusD(moveE);
//			   }
//		 }
//		 if (moveE.type == 0) //insert customer to a new Empty vehicle
//		 {
//			if (numVehUsed <numVeh)
//			{
//			   moveE.idCus1=0;
//			   for (j=startidD; j <= endidD;j++)
//			   {
//					moveE.idCus2=j;
//				   //insert i into new empty veh:
//					evaluate_moveCusD(moveE);
//			   }
//			}
//		 }
//	 }
//	 else if (type == 6)
//	 {
//		 moveE.type = type - 6;
//		 for (j=startidC2C; j <= endidC2C;j++)
//		 {
//               moveE.idCus1 = j;
//			   //insert its #k neighbor after j:
//			   numNeighbor = problem->node[j].neighborSize;
//			   for (k=0; k<numNeighbor;k++)
//			   {
//				   moveE.idNeighbor = k;
//				   moveE.idCus2 = problem->node[j].neighborNode[k].id;
//				   evaluate_moveCusC2C(moveE);
//			   }
//		 }
//	 }
//	 else if (type == 7) //exchange C2C
//	 {
//	 }
//	 /*else if (type == 9) //moveSP:
//	 {
//	 	   moveE.type = type - 6;
//		   int u, v, uu, vv, si,sj, sucsi,sucsj, lastTripu, lastTripv, vEmpty;
//		   bool Emptyu;
//		   if (numVehUsed < numVeh)
//		   {
//			   for (v=0;v<numVeh;v++)
//				   if (seg[v].numTrips == 0) {vEmpty = v;break;}
//			   for (u=0;u<numVeh;u++)
//				   if (seg[u].numTrips >0)
//				   {
//					   Emptyu = 0;
//					   if (seg[u].numTrips == 1) Emptyu = 1;
//					   else if (seg[u].numTrips == 2)
//					   {
//						   if (seg[u].Trip[1].coordinate) Emptyu = 1;
//					   }
//					   if (Emptyu)
//					   {
//						   moveE.idVeh2 = u;
//						   uu = 0;
//						   si = seg[u].Trip[uu].assSP;  moveE.idCus2 = si;
//						   //2.To vehicle v not empty:
//						   for (v=0;v<numVeh;v++)
//								if (u != v && seg[v].numTrips >0)
//								{
//									   moveE.idVeh1 = v;
//									   moveE.idCus1 = 0;
//									   evaluate_moveSP(moveE); //move si of vehicle u at the beginning of vehicle v
//									  
//									   lastTripv = seg[v].numTrips-1;
//									   vv = 0;
//									   while (vv < lastTripv)
//									   {
//										   sj = seg[v].Trip[vv].assSP;
//										   moveE.idCus1 = sj;
//										   evaluate_moveSP(moveE);//move si of vehicle u after sj of vehicle v
//										   vv ++;
//										   sucsj = seg[v].Trip[vv].assSP;
//										   if (sj==sucsj) vv ++;
//									   }//end while vv
//									   if (vv == lastTripv)
//									   {
//										   sj = seg[v].Trip[vv].assSP;
//										   moveE.idCus1 = sj;
//										   evaluate_moveSP(moveE);//move si of vehicle u after sj of vehicle v
//									   }
//							   }	
//					   }
//					   else //vehicle u not empty after the move:
//					   {
//						   lastTripu = seg[u].numTrips-1;
//						   moveE.idVeh2 = u;
//						   uu = 0;
//						   while (uu < lastTripu)
//						   {
//							    si = seg[u].Trip[uu].assSP;  moveE.idCus2 = si;
//							   //1. Empty vehicle:
//								moveE.idVeh1 = vEmpty; moveE.idCus1 = 0;
//								evaluate_moveSP_EmptyVeh(moveE);
//							   //2.To vehicle v not empty:
//							   for (v=0;v<numVeh;v++)
//								if (u != v && seg[v].numTrips >0)
//								{
//								   moveE.idVeh1 = v;
//								   moveE.idCus1 = 0;
//								   evaluate_moveSP(moveE); //move si of vehicle u at the beginning of vehicle v
//								  
//								   lastTripv = seg[v].numTrips-1;
//								   vv = 0;
//								   while (vv < lastTripv)
//								   {
//									   sj = seg[v].Trip[vv].assSP;
//									   moveE.idCus1 = sj;
//									   evaluate_moveSP(moveE);//move si of vehicle u after sj of vehicle v
//									   vv ++;
//									   sucsj = seg[v].Trip[vv].assSP;
//									   if (sj==sucsj) vv ++;
//								   }//end while vv
//								   if (vv == lastTripv)
//								   {
//									   sj = seg[v].Trip[vv].assSP;
//									   moveE.idCus1 = sj;
//									   evaluate_moveSP(moveE);//move si of vehicle u after sj of vehicle v
//								   }
//							   }	
//							   uu++;
//							   sucsi = seg[u].Trip[uu].assSP;
//							   if (si == sucsi) uu++;
//						   }//end while (uu < lastTripu)
//						   if (uu == lastTripu)
//						   {
//							   if (seg[u].Trip[uu].Type == 0)
//							   {
//								   si = seg[u].Trip[uu].assSP;  moveE.idCus2 = si;
//								   //1.Empty v vehicle:
//								   moveE.idVeh1 = vEmpty;
//								   moveE.idCus1 = 0;
//								   evaluate_moveSP_EmptyVeh(moveE);
//								   //2.Vehicle v not empty
//								   for (v=0;v<numVeh;v++)
//									   if (u != v && seg[v].numTrips >0)
//									   {
//										   moveE.idVeh1 = v;
//										   moveE.idCus1 = 0;
//										   evaluate_moveSP(moveE); //move si of vehicle u at the beginning of vehicle v
//										  
//										   lastTripv = seg[v].numTrips-1;
//										   vv = 0;
//										   while (vv < lastTripv)
//										   {
//											   sj = seg[v].Trip[vv].assSP;
//											   moveE.idCus1 = sj;
//											   evaluate_moveSP(moveE);//move si of vehicle u after sj of vehicle v
//											   vv ++;
//											   sucsj = seg[v].Trip[vv].assSP;
//											   if (sj==sucsj) vv ++;
//										   }//end while vv
//										   if (vv == lastTripv)
//										   {
//											   sj = seg[v].Trip[vv].assSP;
//											   moveE.idCus1 = sj;
//											   evaluate_moveSP(moveE);//move si of vehicle u after sj of vehicle v
//										   }
//									   }
//							   }
//						   }
//					   }//end not empty after the move
//				   }//end if (seg[u].numTrips >0)
//		   }
//		   else //don't need to calculate to insert into empty vehicle:
//		   {
//			   for (u=0;u<numVeh;u++)
//				   if (seg[u].numTrips >0)
//				   {
//					   Emptyu = 0;
//					   if (seg[u].numTrips == 1) Emptyu = 1;
//					   else if (seg[u].numTrips == 2)
//					   {
//						   if (seg[u].Trip[1].coordinate) Emptyu = 1;
//					   }
//					   if (Emptyu) //vehicle u empty after the move
//					   {
//						   moveE.idVeh2 = u;
//						   uu = 0;
//						   si = seg[u].Trip[uu].assSP;  moveE.idCus2 = si;
//						   //2.To vehicle v not empty:
//						   for (v=0;v<numVeh;v++)
//								if (u != v && seg[v].numTrips >0)
//								{
//									   moveE.idVeh1 = v;
//									   moveE.idCus1 = 0;
//									   evaluate_moveSP(moveE); //move si of vehicle u at the beginning of vehicle v
//									  
//									   lastTripv = seg[v].numTrips-1;
//									   vv = 0;
//									   while (vv < lastTripv)
//									   {
//										   sj = seg[v].Trip[vv].assSP;
//										   moveE.idCus1 = sj;
//										   evaluate_moveSP(moveE);//move si of vehicle u after sj of vehicle v
//										   vv ++;
//										   sucsj = seg[v].Trip[vv].assSP;
//										   if (sj==sucsj) vv ++;
//									   }//end while vv
//									   if (vv == lastTripv)
//									   {
//										   sj = seg[v].Trip[vv].assSP;
//										   moveE.idCus1 = sj;
//										   evaluate_moveSP(moveE);//move si of vehicle u after sj of vehicle v
//									   }
//							   }	
//					   }
//					   else //vehicle u not empty after the move:
//					   {
//						   lastTripu = seg[u].numTrips-1;
//						   moveE.idVeh2 = u;
//						   uu = 0;
//						   while (uu < lastTripu)
//						   {
//							    si = seg[u].Trip[uu].assSP;  moveE.idCus2 = si;
//							   //2.To vehicle v not empty:
//							   for (v=0;v<numVeh;v++)
//								if (u != v && seg[v].numTrips >0)
//								{
//								   moveE.idVeh1 = v;
//								   moveE.idCus1 = 0;
//								   evaluate_moveSP(moveE); //move si of vehicle u at the beginning of vehicle v
//								  
//								   lastTripv = seg[v].numTrips-1;
//								   vv = 0;
//								   while (vv < lastTripv)
//								   {
//									   sj = seg[v].Trip[vv].assSP;
//									   moveE.idCus1 = sj;
//									   evaluate_moveSP(moveE);//move si of vehicle u after sj of vehicle v
//									   vv ++;
//									   sucsj = seg[v].Trip[vv].assSP;
//									   if (sj==sucsj) vv ++;
//								   }//end while vv
//								   if (vv == lastTripv)
//								   {
//									   sj = seg[v].Trip[vv].assSP;
//									   moveE.idCus1 = sj;
//									   evaluate_moveSP(moveE);//move si of vehicle u after sj of vehicle v
//								   }
//							   }	
//							   uu++;
//							   sucsi = seg[u].Trip[uu].assSP;
//							   if (si == sucsi) uu++;
//						   }//end while (uu < lastTripu)
//						   if (uu == lastTripu)
//						   {
//							   if (seg[u].Trip[uu].Type == 0)
//							   {
//								   si = seg[u].Trip[uu].assSP;  moveE.idCus2 = si;
//								   //2.Vehicle v not empty
//								   for (v=0;v<numVeh;v++)
//									   if (u != v && seg[v].numTrips >0)
//									   {
//										   moveE.idVeh1 = v;
//										   moveE.idCus1 = 0;
//										   evaluate_moveSP(moveE); //move si of vehicle u at the beginning of vehicle v
//										  
//										   lastTripv = seg[v].numTrips-1;
//										   vv = 0;
//										   while (vv < lastTripv)
//										   {
//											   sj = seg[v].Trip[vv].assSP;
//											   moveE.idCus1 = sj;
//											   evaluate_moveSP(moveE);//move si of vehicle u after sj of vehicle v
//											   vv ++;
//											   sucsj = seg[v].Trip[vv].assSP;
//											   if (sj==sucsj) vv ++;
//										   }//end while vv
//										   if (vv == lastTripv)
//										   {
//											   sj = seg[v].Trip[vv].assSP;
//											   moveE.idCus1 = sj;
//											   evaluate_moveSP(moveE);//move si of vehicle u after sj of vehicle v
//										   }
//									   }
//							   }
//						   }
//					   }//end not empty after the move
//				   }//end if (seg[u].numTrips >0)
//		   }//end don't need to calculate to insert into empty vehicle
//
//	 }*/
//}
//

//
//void Solution::evaluate_moveCusP(moveT move)
//{
//	int i,j,k;
//	j=move.idCus1; i = move.idCus2;
//	k = move.idNeighbor;
//	int jLON = j; int kLON = k;
//
//	if (move.type==0) // 1-0 move: move i after j
//	{
//		if (nextArr[j] == i) return;
//		if (route_num[j] == route_num[i])
//		{
//			if (trip_num[j] == trip_num[i]) 
//		    {
//				//return;
//				move.obj->var_vioTWC = moveCus[j][k]->var_vioTWC; 
//				move.obj->var_vioTWSP = moveCus[j][k]->var_vioTWSP;
//				move.obj->var_cost = moveCus[j][k]->var_cost;
//				move.obj->var_vioCAP = 0;
//				move.obj->var_fitness = move.obj->var_cost + VTWCUS * move.obj->var_vioTWC + VTWSP*move.obj->var_vioTWSP; 
//				j=i;k=0;
//	    	}
//			else //sameVeh, dif trip:
//			{
//				int assSPj = seg[route_num[j]].Trip[trip_num[j]].assSP;
//				if (problem->belong[i][assSPj])
//				{
//					move.obj->var_vioTWC = moveCus[j][k]->var_vioTWC; 
//					move.obj->var_vioTWSP = moveCus[j][k]->var_vioTWSP;
//					move.obj->var_cost = moveCus[j][k]->var_cost;
//					move.obj->var_vioCAP = moveCus[j][k]->var_vioCAP;
//					move.obj->var_fitness = move.obj->var_cost + VCAP*move.obj->var_vioCAP + VTWSP*move.obj->var_vioTWSP + VTWCUS *move.obj->var_vioTWC; 
//					j=i;k=0;
//				}
//				else return;
//				//return;
//			}//end sameveh, dif trip
//		}
//		else //dif vehicles
//		{
//			//return;
//			int assSPj = seg[route_num[j]].Trip[trip_num[j]].assSP;
//			if (problem->belong[i][assSPj])
//			{
//				move.obj->var_vioCAP = (deleteCus[i]->var_vioCAP + insertCus[j][k]->var_vioCAP);
//				move.obj->var_vioTWSP = (deleteCus[i]->var_vioTWSP + insertCus[j][k]->var_vioTWSP);
//				move.obj->var_vioTWC = deleteCus[i]->var_vioTWC + insertCus[j][k]->var_vioTWC;
//				move.obj->var_cost = (deleteCus[i]->var_cost + insertCus[j][k]->var_cost);
//				move.obj->empty = deleteCus[i]->empty;
//				move.obj->var_fitness = move.obj->var_cost + VCAP*move.obj->var_vioCAP + VTWSP*move.obj->var_vioTWSP + VTWCUS *move.obj->var_vioTWC; 
//				if (move.obj->empty) move.obj->var_fitness -= F;
//				j=i;k=0;
//			}
//			else return;
//		}
//	}
//	else if (move.type==1) // 1-1 exchange: exchange i and j
//	{
//		bool ok = 0;
//		/*if (route_num[j] == route_num[i]) //same vehicle
//		 if (problem->belong[j][seg[route_num[i]].Trip[trip_num[i]].assSP] && problem->belong[i][seg[route_num[j]].Trip[trip_num[j]].assSP])
//            ok = 1;*/
//		//if (route_num[j] == route_num[i] && trip_num[j] == trip_num[i]) ok = 1; //same vehicle, same trip
//  
//		if (route_num[j] == route_num[i] && trip_num[j] == trip_num[i]) ok = 1;
//		else if (problem->belong[j][seg[route_num[i]].Trip[trip_num[i]].assSP] && problem->belong[i][seg[route_num[j]].Trip[trip_num[j]].assSP])
//		   ok = 1;
//		if (ok)
//		{
//            move.obj->var_vioCAP = exchangeCus[j][k]->var_vioCAP;
//			move.obj->var_vioTWC = exchangeCus[j][k]->var_vioTWC;
//			move.obj->var_vioTWSP = exchangeCus[j][k]->var_vioTWSP;
//			move.obj->var_cost = exchangeCus[j][k]->var_cost;
//			move.obj->var_fitness = move.obj->var_cost + VCAP*move.obj->var_vioCAP + VTWSP*move.obj->var_vioTWSP + VTWCUS *move.obj->var_vioTWC; 
//		}
//		else return;
//	}
//	else if (move.type==2) // 2opt* exchange
//	{
//		if (seg[route_num[j]].Trip[trip_num[j]].assSP != seg[route_num[i]].Trip[trip_num[i]].assSP) return;
//		if (route_num[j] == route_num[i]) //same vehicle:
//		{
//			if (nextArr[j]==i) return;
//			if (pos[j] < pos[i])
//			{
//				move.obj->var_vioTWC = twoOPTstarCus[j][k]->var_vioTWC; 
//				move.obj->var_vioCAP = 0;
//				move.obj->var_vioTWSP = twoOPTstarCus[j][k]->var_vioTWSP;
//				move.obj->var_cost = twoOPTstarCus[j][k]->var_cost;
//				move.obj->empty = 0;
//				move.obj->var_fitness = move.obj->var_cost + VTWSP*move.obj->var_vioTWSP + VTWCUS * move.obj->var_vioTWC; 
//			}
//			else return;
//		}
//		else //different vehicles:
//		{
//				if (twoOPTstarCus[j][k]->var_vioCAP == PDS_INFINITY_INT) return;
//				else
//				{
//					move.obj->var_vioTWC = twoOPTstarCus[j][k]->var_vioTWC; 
//					move.obj->var_vioCAP = twoOPTstarCus[j][k]->var_vioCAP;
//					move.obj->var_vioTWSP = twoOPTstarCus[j][k]->var_vioTWSP;
//					move.obj->var_cost = twoOPTstarCus[j][k]->var_cost;
//					move.obj->empty = twoOPTstarCus[j][k]->empty;
//					move.obj->var_fitness = move.obj->var_cost + VCAP*move.obj->var_vioCAP + VTWSP*move.obj->var_vioTWSP + VTWCUS *move.obj->var_vioTWC; 
//					if (move.obj->empty) move.obj->var_fitness -= F;
//				}
//		}
//	}
//    
//  
//	  //evaluate tabu flag
//	  move.tabu = 1; bool FOUNDNEWBEST = 0;
//	  if ((vioCAPC + move.obj->var_vioCAP==0) 
//									  && (vioTWCC + move.obj->var_vioTWC==0) && (vioTWSPC + move.obj->var_vioTWSP==0) 
//									  && (fitness + move.obj->var_fitness < FITBEST - eps1))
//	  {
//		  move.tabu=0;
//		  /*if (move.type == 0 && k == 0)
//		  {
//			  double var1 = fitness + move.obj->var_fitness;
//			  double var2 = cost + move.obj->var_cost;
//			  cout<<"NEW BEST = (cost = "<<var2<<", fit = "<<var1<<" < "<<FITBEST<<"); currentSOL(cost = "<<cost<<", fit = "<<fitness<<"): Move cus i = "<<j<<": tabu = "<<tabu[move.type][j][k]<<"; ITTabuP = "<<ITTabuP<<endl;
//			  cout<<"varfit = "<<move.obj->var_fitness<<"; varcost = "<<move.obj->var_cost<<"; empty = "<<move.obj->empty<<endl;
//		  }*/
//		  FOUNDNEWBEST = 1;
//	  }
//	  else  
//	  {
//		  if (move.type == 0)
//		  {
//			  //checking BOTH: if i can be moved and i is moved after j
//			  if(tabu[0][j][k] < ITTabuP  && tabu[0][jLON][kLON] < ITTabuP)// && frequency[move.type][jLON][kLON] < 15)
//				  move.tabu = 0;
//		  }
//		  else if (tabu[move.type][j][k] < ITTabuP)// && frequency[move.type][jLON][kLON] < 15)
//		  {
//			  move.tabu = 0;
//		  }
//	  }
//	  //Diversification continue
//	  //if (move.obj->var_fitness > eps1)
//		//  move.obj->var_fitness += diver*cost*(frequency[j][k]/IT);
//
//	  if (move.tabu==0)
//	  {
//		  //WILL HAVE DIVERSIFICATION HERE..... LATER......
//		  if (FOUNDNEWBESTATTHISIT) //already found at least NEWBEST in this iteration: HAVE TO DO THIS BECAUSE PENALTY IS NOT BIG ENOUGH TO KEEP THE FEASIBLE NEWBEST ONE
//		  {
//			  if (FOUNDNEWBEST) //therefore just compare if still find NEWBEST:
//			  {
//				  if (move.obj->var_fitness < best_move.obj->var_fitness - eps1)
//				  {
//					  best_move = move;
//  					  //cout<<"CUSP: BEST_MOVE.type = "<<best_move.type<<endl;
//				  }
//			  }
//		  }
//		  else //not found any NEWBEST in this iteration yet:
//		  {
//			  if (FOUNDNEWBEST) //first newBEST found in this iteration:
//			  {
//				  FOUNDNEWBESTATTHISIT = 1;
//				  best_move = move;
//			  }
//			  else if (move.obj->var_fitness < best_move.obj->var_fitness - eps1) //not found any newBEST yet:
//			  {
//					  best_move = move;
//  					  //cout<<"CUSP: BEST_MOVE.type = "<<best_move.type<<endl;
//			  }
//		  }
//	  }
//}
//
//
//void Solution::evaluate_moveCusD(moveT move)
//{
//	int i,j,k;
//	j = move.idCus1; i = move.idCus2;
//	k = move.idNeighbor;
//
//	if (move.type==0) // 1-0 move: move i after j
//	{
//   		    //cout<<"j = "<<j<<"; i = "<<i<<endl;
//			if (j==0) //create new trip in an empty vehicle, and insesrt i as the first customer of that leg:
//			{
//				if (numTripDSP[problem->node[i].zone] <= problem->minTripSP[problem->node[i].zone]) return; 
//				if (deleteCus[i]->atIT == -100) return; //delete it will make #legs served sp < min required
//				move.obj->var_vioTWC = deleteCus[i]->var_vioTWC + insertCusEmptyVeh[i]->var_vioTWC;
//				move.obj->var_cost = deleteCus[i]->var_cost + insertCusEmptyVeh[i]->var_cost;
//				move.obj->var_vioCAP = deleteCus[i]->var_vioCAP;
//				move.obj->var_vioTWSP= deleteCus[i]->var_vioTWSP;
//				move.obj->var_fitness = move.obj->var_cost + VCAP*move.obj->var_vioCAP + VTWCUS*move.obj->var_vioTWC + VTWSP*move.obj->var_vioTWSP + F; 
//				j=i;k=0;
//			}
//			else
//			{
//				if (route_num[j] == route_num[i]) 
//				{
//					if (nextArr[j] == i) return;
//					else
//					{
//						move.obj->var_vioTWC = moveCus[j][k]->var_vioTWC;
//						move.obj->var_vioTWSP = moveCus[j][k]->var_vioTWSP;
//						move.obj->var_cost = moveCus[j][k]->var_cost;
//						move.obj->var_vioCAP = 0;
//						move.obj->var_fitness = move.obj->var_cost + VTWCUS*move.obj->var_vioTWC + VTWSP*move.obj->var_vioTWSP; 
//						j=i;k=0;
//					}
//				}
//				else // j and i are in different trips
//				{
//					if (numTripDSP[problem->node[i].zone] <= problem->minTripSP[problem->node[i].zone]) return; 
//					if (deleteCus[i]->atIT==-100) return; //delete it will make #legs served sp < min required
//					move.obj->var_vioCAP = (deleteCus[i]->var_vioCAP + insertCus[j][k]->var_vioCAP);
//					move.obj->var_vioTWC = (deleteCus[i]->var_vioTWC + insertCus[j][k]->var_vioTWC);
//					move.obj->var_vioTWSP = (deleteCus[i]->var_vioTWSP + insertCus[j][k]->var_vioTWSP);
//					move.obj->var_cost = (deleteCus[i]->var_cost + insertCus[j][k]->var_cost);
//					move.obj->empty = deleteCus[i]->empty;
//					move.obj->var_fitness = move.obj->var_cost + VCAP*move.obj->var_vioCAP + VTWCUS*move.obj->var_vioTWC + VTWSP*move.obj->var_vioTWSP; 
//					if (move.obj->empty) move.obj->var_fitness -= F;
//					j=i;k=0;
//				}
//			}
//	}
//	else if (move.type==1) // 1-1 exchange: exchange i and j
//	{
//		    move.atIT = exchangeCus[j][k]->atIT;
//            move.obj->var_vioCAP = exchangeCus[j][k]->var_vioCAP;
//			move.obj->var_vioTWC = exchangeCus[j][k]->var_vioTWC;
//			move.obj->var_vioTWSP = exchangeCus[j][k]->var_vioTWSP;
//			move.obj->var_cost = exchangeCus[j][k]->var_cost;
//			move.obj->var_fitness = move.obj->var_cost + VCAP*move.obj->var_vioCAP + VTWCUS*move.obj->var_vioTWC + VTWSP*move.obj->var_vioTWSP; 
//	}
//	else if (move.type==2) // 2opt* exchange
//	{
//        if (route_num[j] != route_num[i])
//		{   
//				//return;
//				if (twoOPTstarCus[j][k]->var_vioCAP == PDS_INFINITY_INT) return;
//				else
//				{
//					move.obj->var_vioCAP = twoOPTstarCus[j][k]->var_vioCAP;
//					move.obj->var_vioTWC = twoOPTstarCus[j][k]->var_vioTWC;
//					move.obj->var_vioTWSP = twoOPTstarCus[j][k]->var_vioTWSP;
//					move.obj->var_cost = twoOPTstarCus[j][k]->var_cost;
//					move.obj->empty = twoOPTstarCus[j][k]->empty;
//					move.obj->var_fitness = move.obj->var_cost + VCAP*move.obj->var_vioCAP + VTWCUS*move.obj->var_vioTWC + VTWSP*move.obj->var_vioTWSP; 
//					if (move.obj->empty) move.obj->var_fitness -= F;
//				}
//		} 
//		else //same trip:
//		{
//			if (nextArr[j]==i) return;
//            if (pos[j] < pos[i])
//			{
//				move.obj->var_vioCAP = 0;
//				move.obj->var_vioTWC = twoOPTstarCus[j][k]->var_vioTWC;
//				move.obj->var_vioTWSP = twoOPTstarCus[j][k]->var_vioTWSP;
//				move.obj->var_cost = twoOPTstarCus[j][k]->var_cost;
//				move.obj->var_vioCAP = 0;
//				move.obj->empty = 0;
//				move.obj->var_fitness = move.obj->var_cost + VTWCUS*move.obj->var_vioTWC + VTWSP*move.obj->var_vioTWSP; 
//			}
//			else return;
//		}
//	}
//    
//
//	  move.tabu = 1; bool FOUNDNEWBEST = 0;
//	  if ((vioCAPC + move.obj->var_vioCAP==0) 
//									  && (vioTWCC + move.obj->var_vioTWC==0) && (vioTWSPC + move.obj->var_vioTWSP==0) 
//									  && (fitness + move.obj->var_fitness < FITBEST - eps1))
//	  {
//		  move.tabu=0;
//		  /*if (move.type == 0 && k == 0)
//		  {
//			  double var1 = fitness + move.obj->var_fitness;
//			  double var2 = cost + move.obj->var_cost;
//			  cout<<"NEW BEST = (cost = "<<var2<<", fit = "<<var1<<" < "<<FITBEST<<"); currentSOL(cost = "<<cost<<", fit = "<<fitness<<"): Move cus i = "<<j<<": tabu = "<<tabu[move.type][j][k]<<"; ITTabuP = "<<ITTabuP<<endl;
//			  cout<<"varfit = "<<move.obj->var_fitness<<"; varcost = "<<move.obj->var_cost<<"; empty = "<<move.obj->empty<<endl;
//		  }*/
//		  FOUNDNEWBEST = 1;
//	  }
//	  else if (tabu[move.type][j][k] < ITTabuCustomerZone[problem->node[j].zone])
//	  {
//		  move.tabu = 0;
//		  /*if (move.type == 0 && k == 0)
//			  cout<<"(Move cus j = "<<j<<": tabu = "<<tabu[move.type][j][k]<<"; ITTabuP = "<<ITTabuP<<endl;*/
//	  }
//
//	  if (move.tabu==0)
//	  {
//		  //WILL HAVE DIVERSIFICATION HERE..... LATER......
//		  if (FOUNDNEWBESTATTHISIT) //already found at least NEWBEST in this iteration
//		  {
//			  if (FOUNDNEWBEST) //therefore just compare if still find NEWBEST:
//			  {
//				  if (move.obj->var_fitness < best_move.obj->var_fitness - eps1)
//				  {
//					  best_move = move;
//					  best_move.type = move.type + 3;
//  					  //cout<<"CUSP: BEST_MOVE.type = "<<best_move.type<<endl;
//				  }
//			  }
//		  }
//		  else //not found any NEWBEST in this iteration yet:
//		  {
//			  if (FOUNDNEWBEST) //first newBEST found in this iteration:
//			  {
//				  FOUNDNEWBESTATTHISIT = 1;
//				  best_move = move;
//				  best_move.type = move.type + 3;
//			  }
//			  else if (move.obj->var_fitness < best_move.obj->var_fitness - eps1) //not found any newBEST yet:
//			  {
//					  best_move = move;
//					  best_move.type = move.type + 3;
//  					  //cout<<"CUSP: BEST_MOVE.type = "<<best_move.type<<endl;
//			  }
//		  }
//	  }
//
//	 /* 
//	    
//	  //evaluate tabu flag
//	  move.tabu = 1;
//	  //cout<<"j = "<<j<<"; k = "<<k<<"; move.type = "<<move.type<<"; zone = "<<problem->node[j].zone<<endl;
//	  if (tabu[move.type][j][k] < ITTabuCustomerZone[problem->node[j].zone] 
//	                                  || (vioCAPC + move.obj->var_vioCAP==0 
//									  && vioTWCC + move.obj->var_vioTWC==0 
//									  && vioTWSPC + move.obj->var_vioTWSP==0 && fitness + move.obj->var_fitness < FITBEST - eps1))
//		  move.tabu=0;
//     //Diversification continue
//	  //if (move.obj->var_fitness > eps1)
//		//  move.obj->var_fitness += diver*cost*(frequency[j][k]/IT);
//	  if (move.tabu==0)
//	  {
//		  //WILL HAVE DIVERSIFICATION HERE..... LATER......
//		  if (move.obj->var_fitness < best_move.obj->var_fitness - eps1)
//		  {
//			  best_move = move;
//			  best_move.type = move.type + 3;
//			  //cout<<"CUSD: BEST_MOVE.type = "<<best_move.type<<endl;
//		  }
//	  }*/
//}
//
//
//
//
//
//void Solution::evaluate_moveCusC2C(moveT move)
//{
//	int i,j,k;
//	j=move.idCus1; i = move.idCus2;
//	k = move.idNeighbor;
//	int jLON = j; int kLON = k;
//	int idVeh = route_num[j]; int idTrip = trip_num[j];
//	int nextSP = seg[idVeh].Trip[idTrip].nextSP;
//	bool cont = 0;
//
//	if (move.type==0) // 1-0 move: move i after j
//	{
//		if (nextArr[j] == i) return;
//		if (route_num[j] == route_num[i]) //same vehicle
//		{
//			if (nextSP > 0)
//			{
//				if (problem->belong[i][nextSP]) cont = 1;
//				//else cont = 0;
//			}
//			else
//			{
//				if (idTrip == seg[idVeh].numTrips - 1) cont = 1;
//				else //nextT is PORC2C
//				{
//					int nextT = idTrip + 1;
//					if (seg[idVeh].Trip[nextT].Type == 2) cont = 1;
//					else //nextT is PTrip
//					{
//						nextSP = seg[idVeh].Trip[nextT].assSP;
//						if (problem->belong[i][nextSP]) cont = 1;
//						//else cont = 0;
//					}
//				}
//			}
//			if (cont)
//			{
//				move.obj->var_vioTWC = moveCus[j][k]->var_vioTWC; 
//				move.obj->var_vioTWSP = moveCus[j][k]->var_vioTWSP;
//				move.obj->var_cost = moveCus[j][k]->var_cost;
//				move.obj->var_vioCAP = moveCus[j][k]->var_vioCAP;
//				move.obj->var_fitness = move.obj->var_cost + VCAP*move.obj->var_vioCAP + VTWSP*move.obj->var_vioTWSP + VTWCUS *move.obj->var_vioTWC; 
//				j=i;k=0;
//			} else return;
//		}
//		else //dif vehicles
//		{
//			/*cout<<"j = "<<j<<"; i = "<<i<<";k = "<<k<<";";
//			cout<<"ii = "<<problem->node[j].neighborNode[k].id<<"; #neighbors = "<<problem->node[j].neighborSize<<endl;
//			cout<<"deleteCus[i]->var_vioCAP = "<<deleteCus[i]->var_vioCAP<<endl;
//			cout<<"insertCus[20][1]->var_vioCAP = "<<insertCus[20][1]->var_vioCAP<<endl;
//			cout<<"insertCus[j][1]->var_vioCAP = "<<insertCus[j][1]->var_vioCAP<<endl;
//			cout<<"insertCus[j][k]->var_vioCAP = "<<insertCus[j][k]->var_vioCAP<<endl;*/
//			if (nextSP > 0)
//			{
//				if (problem->belong[i][nextSP]) cont = 1;
//				//else cont = 0;
//			}
//			else
//			{
//				if (idTrip == seg[idVeh].numTrips - 1) cont = 1;
//				else //nextT is PORC2C
//				{
//					int nextT = idTrip + 1;
//					if (seg[idVeh].Trip[nextT].Type == 2) cont = 1;
//					else //nextT is PTrip
//					{
//						nextSP = seg[idVeh].Trip[nextT].assSP;
//						if (problem->belong[i][nextSP]) cont = 1;
//						//else cont = 0;
//					}
//				}
//			}
//
//			if (cont)
//			{
//				move.obj->var_vioCAP = (deleteCus[i]->var_vioCAP + insertCus[j][k]->var_vioCAP);
//			
//				//cout<<"deleteCus[i]->var_vioTWSP = "<<deleteCus[i]->var_vioTWSP<<"; insertCus[j][k]->var_vioTWSP = "<<insertCus[j][k]->var_vioTWSP<<endl;
//				move.obj->var_vioTWSP = (deleteCus[i]->var_vioTWSP + insertCus[j][k]->var_vioTWSP);
//				move.obj->var_vioTWC = deleteCus[i]->var_vioTWC + insertCus[j][k]->var_vioTWC;
//				move.obj->var_cost = (deleteCus[i]->var_cost + insertCus[j][k]->var_cost);
//				move.obj->empty = deleteCus[i]->empty;
//				move.obj->var_fitness = move.obj->var_cost + VCAP*move.obj->var_vioCAP + VTWSP*move.obj->var_vioTWSP + VTWCUS *move.obj->var_vioTWC; 
//				if (move.obj->empty) move.obj->var_fitness -= F;
//				j=i;k=0;
//			} else return;
//		}
//	}
//	else if (move.type==1) // 1-1 exchange: exchange i and j
//	{
//        move.obj->var_vioCAP = exchangeCus[j][k]->var_vioCAP;
//		move.obj->var_vioTWC = exchangeCus[j][k]->var_vioTWC;
//		move.obj->var_vioTWSP = exchangeCus[j][k]->var_vioTWSP;
//		move.obj->var_cost = exchangeCus[j][k]->var_cost;
//		move.obj->var_fitness = move.obj->var_cost + VCAP*move.obj->var_vioCAP + VTWSP*move.obj->var_vioTWSP + VTWCUS *move.obj->var_vioTWC; 
//	}
//    
//  
//	  //evaluate tabu flag
//	  move.tabu = 1; bool FOUNDNEWBEST = 0;
//	  if ((vioCAPC + move.obj->var_vioCAP==0) 
//									  && (vioTWCC + move.obj->var_vioTWC==0) && (vioTWSPC + move.obj->var_vioTWSP==0) 
//									  && (fitness + move.obj->var_fitness < FITBEST - eps1))
//	  {
//		  move.tabu=0;
//		  /*if (move.type == 0 && k == 0)
//		  {
//			  double var1 = fitness + move.obj->var_fitness;
//			  double var2 = cost + move.obj->var_cost;
//			  cout<<"NEW BEST = (cost = "<<var2<<", fit = "<<var1<<" < "<<FITBEST<<"); currentSOL(cost = "<<cost<<", fit = "<<fitness<<"): Move cus i = "<<j<<": tabu = "<<tabu[move.type][j][k]<<"; ITTabuP = "<<ITTabuP<<endl;
//			  cout<<"varfit = "<<move.obj->var_fitness<<"; varcost = "<<move.obj->var_cost<<"; empty = "<<move.obj->empty<<endl;
//		  }*/
//		  FOUNDNEWBEST = 1;
//	  }
//	  else  
//	  {
//		  if (move.type == 0)
//		  {
//			  //checking BOTH: if i can be moved and i is moved after j
//			  if(tabu[0][j][k] < ITTabuC2C  && tabu[0][jLON][kLON] < ITTabuC2C)// && frequency[move.type][jLON][kLON] < 15)
//				  move.tabu = 0;
//		  }
//		  else if (tabu[move.type][j][k] < ITTabuC2C)// && frequency[move.type][jLON][kLON] < 15)
//		  {
//			  move.tabu = 0;
//		  }
//	  }
//	  //Diversification continue
//	  //if (move.obj->var_fitness > eps1)
//		//  move.obj->var_fitness += diver*cost*(frequency[j][k]/IT);
//
//	  if (move.tabu==0)
//	  {
//		  //WILL HAVE DIVERSIFICATION HERE..... LATER......
//		  if (FOUNDNEWBESTATTHISIT) //already found at least NEWBEST in this iteration: HAVE TO DO THIS BECAUSE PENALTY IS NOT BIG ENOUGH TO KEEP THE FEASIBLE NEWBEST ONE
//		  {
//			  if (FOUNDNEWBEST) //therefore just compare if still find NEWBEST:
//			  {
//				  if (move.obj->var_fitness < best_move.obj->var_fitness - eps1)
//				  {
//					  best_move = move;
//  					  best_move.type = move.type + 6;
//  					  //cout<<"CUSP: BEST_MOVE.type = "<<best_move.type<<endl;
//				  }
//			  }
//		  }
//		  else //not found any NEWBEST in this iteration yet:
//		  {
//			  if (FOUNDNEWBEST) //first newBEST found in this iteration:
//			  {
//				  FOUNDNEWBESTATTHISIT = 1;
//				  best_move = move;
//				  best_move.type = move.type + 6;
//			  }
//			  else if (move.obj->var_fitness < best_move.obj->var_fitness - eps1) //not found any newBEST yet:
//			  {
//					  best_move = move;
//   					  best_move.type = move.type + 6;
//  					  //cout<<"CUSP: BEST_MOVE.type = "<<best_move.type<<endl;
//			  }
//		  }
//	  }
//}
//
//
//void Solution::update_solutionCusD(moveT best_move)
//{
//	//see on 2/12/2013
//	 int i, j,k;
//	 j= best_move.idCus1; i = best_move.idCus2;	
//	 k = best_move.idNeighbor;
//     int type = best_move.type - 3;
//	 int fromVeh, toVeh, fromTrip, toTrip;
//		
//	 fromVeh = route_num[i]; fromTrip = trip_num[i];
//	 toVeh = route_num[j]; toTrip = trip_num[j];
//     bool sameVeh = 0;
//	 if (fromVeh == toVeh) sameVeh = 1;
//     bool empty;
//	 int atSP = seg[fromVeh].Trip[fromTrip].assSP;
//	 ITTabuCustomerZone[atSP] += 1; 
//
//	 double buon = -cost; double buon1 = - vioTWSP; double buon2 = -vioTWC; int buon3 = -vioCAP;
//	 //cout<<"Update_solutionCusD: type = "<<type<<": ";
//	/* showSegment(fromVeh);
//	if (sameVeh== 0) showSegment(toVeh);*/
//
//	 if (type == 0) //move 1-0: move Customer idCus2 (i) after idCus1 (j)
//	 {
//		 if (j==0) //move customer i into new empty vehicle:
//		 {
//			 if (seg[fromVeh].Trip[fromTrip].numCus == 1)
//			 {
//				 int assSP =seg[fromVeh].Trip[fromTrip].assSP;
//			 	 if (numTripDSP[assSP] == problem->minTripSP[assSP])
//				 {
//					cout<<"Delete customer "<<i<<" from veh "<<fromVeh<<" trip "<<fromTrip<<": ";showTripCost(fromVeh, fromTrip);
//					cout<<"deleteCus[i]->atIT = -100 ==??? === "<<deleteCus[i]->atIT<<endl;
//					cout<<"Number of vehicles served sp "<<seg[fromVeh].Trip[fromTrip].assSP<<" = "<<numTripDSP[seg[fromVeh].Trip[fromTrip].assSP]<<" < required min = "<<problem->minTripSP[seg[fromVeh].Trip[fromTrip].assSP]<<endl;
//					for (int ii=0;ii<numVeh;ii++)
//						if (seg[ii].numTrips>0) {cout<<"******* Vehicle "<<ii<<": "<<endl; showSegment(ii);}
//				    exit(-1);
//				 }
//				 empty = Update_EmptyTripD(fromVeh, fromTrip);
//				 cout<<"Move cus "<<i<<" into new empty vehicle"<<endl;
//				 toVeh = CreateNewVeh_DTrip(i);
//				 UpdateArray(toVeh);
// 				 if (empty == 0) UpdateArray(fromVeh);
//			 }
//			 else
//		     {
//				 cout<<"Del cus "<<i<<" from ("<<fromVeh<<", "<<fromTrip<<") has >= 2 cus, and insert into new empty vehicle "<<toVeh<<endl;
//				 deleteCusDTrip(fromVeh, fromTrip, i);
//				 toVeh = CreateNewVeh_DTrip(i);
//				 UpdateArray(toVeh);
// 				 UpdateArray(fromVeh);
//			 }
//			 tabu[type][i][0] = ITTabuCustomerZone[atSP] + Rand(TABUD1[atSP],TABUD2[atSP]);
//			 toTrip = 0;
//			 if (fromVeh == toVeh) 
//			 {
//				 sameVeh = 1;j=i;empty=0;
//			     cout<<"THERE IS THE CASE WHERE DELETE CUS from a vehicle 1 trip and trip with one cus, and then reinsert cus into this vehicle"<<endl;
//				 exit(-1);
//			 }
//		 }
//		 else // j!=0 
//		 {
//			 if (sameVeh) // i and j are in the same trip
//			 {
//				 cout<<"Move cus "<<i<<" after cus "<<j<<" in the same trip ("<<fromVeh<<", "<<fromTrip<<")"<<endl;
//				 cout<<"moveCus["<<j<<"]["<<k<<"]->atIT = "<<moveCus[j][k]->atIT<<"; varcost = "<<moveCus[j][k]->var_cost<<endl;
//				 
//				 moveCusDTrip(j,i,fromVeh,fromTrip);
//				 UpdateArray(fromVeh);
//			 }
//			 else // i and j are in different trips:
//			 {
//				 if (seg[fromVeh].Trip[fromTrip].numCus == 1)
//				 {
//						 cout<<"Del cus "<<i<<" from ("<<fromVeh<<", "<<fromTrip<<") make it empty; then move it after cus "<<j<<" on trip ("<<toVeh<<", "<<toTrip<<")"<<endl;
//					     empty = Update_EmptyTripD(fromVeh, fromTrip);
//						 insertCusDTrip(j,i, toVeh, toTrip);
//						 if (empty == 0) UpdateArray(fromVeh);
//				 }
//				 else
//				 {
//						 cout<<"Del cus "<<i<<" from ("<<fromVeh<<", "<<fromTrip<<"); then move it after cus "<<j<<" on trip ("<<toVeh<<", "<<toTrip<<")"<<endl;
//						 deleteCusDTrip(fromVeh, fromTrip, i);
//						 insertCusDTrip(j,i, toVeh, toTrip);
//						 UpdateArray(fromVeh);
//				 }
//				 UpdateArray(toVeh);
//			 }//end i and j are in different trips
//			 tabu[type][i][0] = ITTabuCustomerZone[atSP] + Rand(TABUD1[atSP], TABUD2[atSP]);
//		 }//end j !=0
//		 /*showSegment(fromVeh);
//		 if (sameVeh == 0) showSegment(toVeh);*/
//	 }
//	 else if (type == 1) //exchange 1-1: exchange customer idCus2 and idCus1 (CASE1: same vehicle / CASE2: 2 vehicles)
//	 {
//		 cout<<"Exchange cus i = "<<i<<" on ("<<fromVeh<<", "<<fromTrip<<") with cus j = "<<j<<" on trip ("<<toVeh<<", "<<toTrip<<"): atIT = "<<exchangeCus[j][k]->atIT<<endl;
//		 exchangeCusDTrip(j,i);
//		 tabu[type][j][k] = ITTabuCustomerZone[atSP] + Rand(TABUD1[atSP], TABUD2[atSP]);
//         int kk = problem->node[j].neighborOF[i];
//		 if (kk > 0) tabu[type][i][kk] = ITTabuCustomerZone[atSP] + Rand(TABUD1[atSP], TABUD2[atSP]);
//		 /*showSegment(fromVeh);
//		 if (sameVeh == 0) showSegment(toVeh);*/
//
//		 UpdateArray(toVeh); 
//		 if (!sameVeh) UpdateArray(fromVeh); 
//	 }
//	 else if (type == 2) //2 opt*
//	 {
//		 if (sameVeh)
//		 {
//			 cout<<"2opt* on same trip ("<<fromVeh<<", "<<fromTrip<<") between j = "<<j<<" and i = "<<i<<": atIT = "<<twoOPTstarCus[j][k]->atIT<<endl;
//			 twoOPTstarCusDTrip_oneTrip(j,i, fromVeh, fromTrip); 
//			 //showSegment(fromVeh);
//			 UpdateArray(fromVeh);
//		 }
//		 else //dif vehicle
//		 {
//			 //cout<<"2opt* between j = "<<j<<" on ("<<toVeh<<", "<<toTrip<<") with i = "<<i<<" on ("<<fromVeh<<", "<<fromTrip<<"): atIT = "<<twoOPTstarCus[j][k]->atIT<<endl;
//			 twoOPTstarCusDTrip(j, toVeh, toTrip, i, fromVeh, fromTrip);
//			 /*showSegment(fromVeh);
//			 showSegment(toVeh);*/
//			 if (seg[fromVeh].numTrips > 0) UpdateArray(fromVeh);
//			 UpdateArray(toVeh);
//	 	 }//end dif vehicle
//		 tabu[type][j][k] = ITTabuCustomerZone[atSP] + Rand(TABUD1[atSP], TABUD2[atSP]); 
//		 int kk = problem->node[j].neighborOF[i];
//		 if (kk > 0) tabu[type][i][kk] = ITTabuCustomerZone[atSP] + Rand(TABUD1[atSP], TABUD2[atSP]);
//	 }//end 2opt*
//
//	 //UpdateSolutionAfterMove();
//	 //cout<<"IT = "<<IT<<":Cus D Type = "<<type<<": varcost = "<<best_move.obj->var_cost<<"; varvioTWSP = "<<best_move.obj->var_vioTWSP<<"; varvioTWC = "<<best_move.obj->var_vioTWC<<"; varvioCAP = "<<best_move.obj->var_vioCAP<<"; vioCAPC = "<<vioCAPC<<"; vioTWCus = "<<vioTWCC<<"; vioTWSP = "<<vioTWSPC<<endl;
//
//	 UpdateCostFitnessFeasible();
//	 buon +=cost; buon1 += vioTWSP; buon2 += vioTWC; buon3 += vioCAP;
//	 double chan = fabs(best_move.obj->var_cost - buon);
//	 //cout<<"correct = "<<buon<<" == ??? === "<<best_move.obj->var_cost<<endl;
//	 if (chan > eps1)
//	 {
//		 cout<<"MoveCusD of move = "<<best_move.type<<" at IT = "<<IT<<endl;
//		 cout<<"Solution::update_solutionCusD ERROR varcost: correct = "<<buon<<"; error = "<<best_move.obj->var_cost<<endl;
//		 showSegment(fromVeh);
//		 if (sameVeh == 0) showSegment(toVeh);
//		 exit(-1);//getch();
//	 }
//
//	 chan = fabs(best_move.obj->var_vioTWSP - buon1);
//	 if (chan > eps1)
//	 {
//		 cout<<"MoveCusD of move = "<<best_move.type<<" at IT = "<<IT<<endl;
//		 cout<<"Solution::update_solutionCusD ERROR varvioTWSP: correct = "<<buon1<<"; error = "<<best_move.obj->var_vioTWSP<<endl;
//		 showSegment(fromVeh);
//		 if (sameVeh == 0) showSegment(toVeh);
//		
//		 exit(-1);//getch();
//	 }
//	 chan = fabs(best_move.obj->var_vioTWC - buon2);
//	 if (chan > eps1)
//	 {
//		 cout<<"MoveCusD of move = "<<best_move.type<<" at IT = "<<IT<<endl;
//		 cout<<"Solution::update_solutionCusD ERROR varvioTWC: correct = "<<buon2<<"; error = "<<best_move.obj->var_vioTWC<<endl;
//		 exit(-1);//getch();
//	 }
//	 int chan2 = abs(best_move.obj->var_vioCAP - buon3);
//	 if (chan2 > eps1)
//	 {
//		 cout<<"MoveCusD of move = "<<best_move.type<<" at IT = "<<IT<<endl;
//		 cout<<"Solution::update_solutionCusD ERROR varvioCAP: correct = "<<buon3<<"; error = "<<best_move.obj->var_vioCAP<<endl;
//		 showSegment(fromVeh);
//		 if (sameVeh == 0) showSegment(toVeh);
//		 exit(-1);//getch();
//	 }
//}
//
//void Solution::update_solutionCusP(moveT best_move)
//{
//	//see on 2/12/2013
//	 int i, j,k;
//	 j= best_move.idCus1; i = best_move.idCus2;	
//	 k = best_move.idNeighbor;
//     int type = best_move.type;
//	 int fromVeh, toVeh, fromTrip, toTrip;
//		
//	 fromVeh = route_num[i]; fromTrip = trip_num[i];
//	 toVeh = route_num[j]; toTrip = trip_num[j];
//     bool sameVeh = 0; bool sameTrip = 0;
//	 
//	 ITTabuP += 1;
//	 if (fromVeh == toVeh) 
//	 {
//		 sameVeh = 1;
//		 if (fromTrip == toTrip) sameTrip = 1;
//	 }
//
//	 bool empty;
//
//	 double buon = -cost; double buon1 = - vioTWSP; double buon2 = -vioTWC; int buon3 = -vioCAP;
//	 double buon4 = fitness;
//	 //showSegment(fromVeh);
//	 //if (sameVeh== 0) showSegment(toVeh);
//	 //bool buc = 0;
//
//	 if (type == 0) //move 1-0: move Customer idCus2 (i) after idCus1 (j)
//	 {
//			 empty = 0;
//			 if (moveCus[j][k]->var_vioTWSP > eps) tabu[0][j][k] = ITTabuP + 30; //Update 17/11/2013
//			 if (sameTrip) // i and j are in the same trip
//			 {
//				 cout<<"Move cus "<<i<<" after cus "<<j<<" in the same trip ("<<fromVeh<<", "<<fromTrip<<")"<<endl;
//				 cout<<"moveCus["<<j<<"]["<<k<<"]->atIT = "<<moveCus[j][k]->atIT<<"; varcost = "<<moveCus[j][k]->var_cost<<"; varvioTWC = "<<moveCus[j][k]->var_vioTWC<<"; varvioTWSP = "<<moveCus[j][k]->var_vioTWSP<<endl;
//				 cout<<"tabu[0][i][0] = "<<tabu[0][i][0]<<"; ITTabuP = "<<ITTabuP<<endl;
//				 //if (tabu[0][i][0] > ITTabuP) buc = 1;
//				// cout<<"CALL  moveCusPTrip_OneTrip("<<endl;
//				 moveCusPTrip_OneTrip(j,i,fromVeh,fromTrip); // 27/11/2013
//				 UpdateArray(fromVeh);
//			 }
//			 else // i and j are in different trips:
//			 {
//				 if (sameVeh) //same vehicle, dif trips:
//				 {
//					 cout<<"Move cus "<<i<<" from trip "<<fromTrip<<" after cus "<<j<<" in trip "<<toTrip<<" on veh "<<fromVeh<<endl;
//					 cout<<"moveCusOneVeh["<<j<<"]["<<k<<"]->atIT = "<<moveCus[j][k]->atIT<<"; varcost = "<<moveCus[j][k]->var_cost<<endl;
//					 //cout<<"moveCusOneVeh["<<j<<"]["<<k<<"]->atIT = "<<moveCus[j][k]->atIT<<"; varcost = "<<moveCus[j][k]->var_cost<<"; vari = "<<moveCus[j][k]->var_costi<<"; varj = "<<moveCus[j][k]->var_costj<<endl;
//				     cout<<"varvioTWC = "<<moveCus[j][k]->var_vioTWC<<"; vari = "<<moveCus[j][k]->var_vioTWCi<<"; varj = "<<moveCus[j][k]->var_vioTWCj<<endl;
//					// cout<<"varvioTWSP = "<<moveCus[j][k]->var_vioTWSP<<"; vari = "<<moveCus[j][k]->var_vioTWSPi<<"; varj = "<<moveCus[j][k]->var_vioTWSPj<<endl;
//					 cout<<"tabu[0]["<<i<<"][0] = "<<tabu[0][i][0]<<"; ITTabuP = "<<ITTabuP<<endl;
//					// cout<<"CALL moveCusPTrip_OneVeh"<<endl;
//					 moveCusPTrip_OneVeh(j, toTrip, i, fromTrip, fromVeh); // 27/11/2013
//					// cout<<"Move xong, now calling UpdateArray"<<endl;
//					 UpdateArray(fromVeh);
//				 }
//				 else //dif vehicles
//				 {
//					 if (seg[fromVeh].Trip[fromTrip].numCus == 1)
//					 {
//							 cout<<"Del cus "<<i<<" from ("<<fromVeh<<", "<<fromTrip<<") make it empty; then move it after cus "<<j<<" on trip ("<<toVeh<<", "<<toTrip<<")"<<endl;
//			 				 cout<<"deleteCus["<<i<<"]->atIT = "<<deleteCus[i]->atIT<<"; varcost = "<<deleteCus[i]->var_cost<<"; varvioTWC = "<<deleteCus[i]->var_vioTWC<<"; varvioTWSP = "<<deleteCus[i]->var_vioTWSP<<endl;
//							 cout<<"insertCus["<<j<<"]["<<k<<"]->atIT = "<<insertCus[j][k]->atIT<<"; varcost = "<<insertCus[j][k]->var_cost<<"; varvioTWC = "<<insertCus[j][k]->var_vioTWC<<"; varvioTWSP = "<<insertCus[j][k]->var_vioTWSP<<endl;
//							 cout<<"tabu[0][i][0] = "<<tabu[0][i][0]<<"; ITTabuP = "<<ITTabuP<<endl;
//							 //if (tabu[0][i][0] > ITTabuP) buc = 1;
//							// cout<<"CALL Update_EmptyTripP"<<endl;
//							 Update_EmptyTripP(fromVeh, fromTrip);
//							// cout<<"CALL insertCusPTrip"<<endl; 
//							 insertCusPTrip(j,i, toVeh, toTrip, seg[toVeh].numTrips - 1);
//							 UpdateArray(toVeh);
//							 if (seg[fromVeh].numTrips > 0) UpdateArray(fromVeh);
//					 }
//					 else
//					 {
//							 cout<<"Del cus "<<i<<" from ("<<fromVeh<<", "<<fromTrip<<"); then move it after cus "<<j<<" on trip ("<<toVeh<<", "<<toTrip<<")"<<endl;
//			 				 cout<<"deleteCus["<<i<<"]->atIT = "<<deleteCus[i]->atIT<<"; varcost = "<<deleteCus[i]->var_cost<<"; varvioTWC = "<<deleteCus[i]->var_vioTWC<<"; varvioTWSP = "<<deleteCus[i]->var_vioTWSP<<endl;
//							 cout<<"insertCus["<<j<<"]["<<k<<"]->atIT = "<<insertCus[j][k]->atIT<<"; varcost = "<<insertCus[j][k]->var_cost<<"; varvioTWC = "<<insertCus[j][k]->var_vioTWC<<"; varvioTWSP = "<<insertCus[j][k]->var_vioTWSP<<endl;
//							 cout<<"tabu[0][i][0] = "<<tabu[0][i][0]<<"; ITTabuP = "<<ITTabuP<<endl;
//							 //if (tabu[0][i][0] > ITTabuP) buc = 1;
//							 //cout<<"CALL deleteCusPTrip"<<endl; 
//							 deleteCusPTrip(fromVeh, fromTrip, predArr[i], i, nextArr[i]);
//							// cout<<"CALL insertCusPTrip"<<endl; 
//							 insertCusPTrip(j,i, toVeh, toTrip, seg[toVeh].numTrips - 1);
//							 UpdateArray(fromVeh);
//							 UpdateArray(toVeh);
//					 }
//				 }//end dif vehicles
//
//			 }//end i ans j are in different trips*/
//			 //tabu[type][j][k] = ITTabuP + Rand(TABUP1, TABUP2);
//	 		 tabu[type][i][0] = ITTabuP + Rand(TABUP1, TABUP2);
//			 frequency[type][j][k]++;
//			 //cout<<"Setting tabu for moving cus "<<i<<" ater "<<j<<" = "<<tabu[type][j][k]<<endl;
//			 //showSegment(fromVeh);
//			 //if (sameVeh == 0) showSegment(toVeh);
//	 }
//	 else if (type == 1) //exchange 1-1: exchange customer idCus2 and idCus1 (CASE1: same vehicle / CASE2: 2 vehicles)
//	 {
//		 if (sameVeh) 
//		 {
//			 if (sameTrip)
//			 {
//				 /*cout<<"Exchange cus "<<j<<" with cus "<<i<<" on the same trip ("<<fromVeh<<", "<<fromTrip<<")"<<endl;
//				 cout<<"exchangeCus["<<j<<"]["<<k<<"]->atIT = "<<exchangeCus[j][k]->atIT<<"; varcost = "<<exchangeCus[j][k]->var_cost<<"; varvioTWC = "<<exchangeCus[j][k]->var_vioTWC<<"; varvioTWSP = "<<exchangeCus[j][k]->var_vioTWSP<<endl;
//			     */
//				 exchangeCusPTrip_OneTrip(j,i,fromVeh,fromTrip);
//			 }
//			 else
//			 {
//				 /*cout<<"Exchange cus "<<j<<" on trip "<<toTrip<<" with cus "<<i<<" on trip "<<fromTrip<<" on the same vehicle "<<fromVeh<<endl;
//				 cout<<"exchangeCus["<<j<<"]["<<k<<"]->atIT = "<<exchangeCus[j][k]->atIT<<"; varcost = "<<exchangeCus[j][k]->var_cost<<endl;
//				 cout<<"varvioTWC = "<<exchangeCus[j][k]->var_vioTWC<<"; varvioTWCi = "<<exchangeCus[j][k]->var_vioTWCi<<"; varvioTWCj = "<<exchangeCus[j][k]->var_vioTWCj<<endl;
//				 cout<<"varvioTWSP = "<<exchangeCus[j][k]->var_vioTWSP<<"; varvioTWSPi = "<<exchangeCus[j][k]->var_vioTWSPi<<"; varvioTWSPj = "<<exchangeCus[j][k]->var_vioTWSPj<<endl;
//				 cout<<"varcosti = "<<exchangeCus[j][k]->var_costi<<"; varcostj = "<<exchangeCus[j][k]->var_costj<<endl;
//				 */
//				 exchangeCusPTrip_OneVeh(j, toTrip, i, fromTrip, fromVeh);
//			 }
//			 UpdateArray(fromVeh);
//		 }
//		 else 
//		 {
//			 /*cout<<"Exchange cus "<<j<<" on veh ("<<toVeh<<", "<<toTrip<<") with cus "<<i<<" on veh ("<<fromVeh<<", "<<fromTrip<<")"<<endl;
//			 cout<<"exchangeCus["<<j<<"]["<<k<<"]->atIT = "<<exchangeCus[j][k]->atIT<<"; varcost = "<<exchangeCus[j][k]->var_cost<<endl;
//			 cout<<"varvioTWC = "<<exchangeCus[j][k]->var_vioTWC<<"; varvioTWCi = "<<exchangeCus[j][k]->var_vioTWCi<<"; varvioTWCj = "<<exchangeCus[j][k]->var_vioTWCj<<endl;
//			 cout<<"varvioTWSP = "<<exchangeCus[j][k]->var_vioTWSP<<"; varvioTWSPi = "<<exchangeCus[j][k]->var_vioTWSPi<<"; varvioTWSPj = "<<exchangeCus[j][k]->var_vioTWSPj<<endl;
//			 cout<<"varcosti = "<<exchangeCus[j][k]->var_costi<<"; varcostj = "<<exchangeCus[j][k]->var_costj<<endl;
//			 */
//			 int prei = predArr[i]; int suci = nextArr[i]; int lastCOLDi = seg[fromVeh].Trip[fromTrip].lastCus;
//			 int prej = predArr[j]; int sucj = nextArr[j]; int lastCOLDj = seg[toVeh].Trip[toTrip].lastCus;
//			 replaceCusPTrip(prei, i, suci, j, lastCOLDi, fromVeh, fromTrip,seg[fromVeh].numTrips - 1); //insert j between prei and suci, delete the cus between (prei, suci): if prei < 0 that means insert j at the beginning of the trip 
//			 replaceCusPTrip(prej,j, sucj, i, lastCOLDj, toVeh, toTrip, seg[toVeh].numTrips - 1); //insert i between prej and sucj: if prej < 0 that means insert i at the beginning of the trip 
//			 UpdateArray(fromVeh);
//			 UpdateArray(toVeh);
//		 }
//	     //showSegment(fromVeh);
//		 //if (sameVeh == 0) showSegment(toVeh);
//		 tabu[type][j][k] = ITTabuP + Rand(TABUP1, TABUP2);
//	 	 frequency[type][j][k]++;
//	 }
//	 else if (type == 2) //2 opt*
//	 {
//		 if (sameTrip)
//		 {
// 			 //cout<<"2opt* on same trip ("<<fromVeh<<", "<<fromTrip<<") between j = "<<j<<" and i = "<<i<<": atIT = "<<twoOPTstarCus[j][k]->atIT<<endl;
//			 twoOPTstarCusPTrip_oneTrip(j,i, fromVeh, fromTrip); 
//			 //showSegment(fromVeh);
//			 UpdateArray(fromVeh);
//		 }
//		 else //dif vehicle
//		 {
//			 /*cout<<"2opt* between j = "<<j<<" on ("<<toVeh<<", "<<toTrip<<") with i = "<<i<<" on ("<<fromVeh<<", "<<fromTrip<<"): atIT = "<<twoOPTstarCus[j][k]->atIT<<endl;
//			 cout<<"varvioTWCi = "<<twoOPTstarCus[j][k]->var_vioTWCi<<"; varvioTWCj = "<<twoOPTstarCus[j][k]->var_vioTWCj<<"; varvioTWC = "<<twoOPTstarCus[j][k]->var_vioTWC<<endl;
//			 cout<<"varvioTWSPi = "<<twoOPTstarCus[j][k]->var_vioTWSPi<<"; varvioTWSPj = "<<twoOPTstarCus[j][k]->var_vioTWSPj<<endl;
//			 */
//			 twoOPTstarCusPTrip(j, toVeh, toTrip, i, fromVeh, fromTrip);
//			 /*showSegment(fromVeh);
//			 showSegment(toVeh);*/
//			 UpdateArray(toVeh); 
//			 if (seg[fromVeh].numTrips > 0) UpdateArray(fromVeh);
//		 }
//		 tabu[type][j][k] = ITTabuP + Rand(TABUP1, TABUP2);
//	 	 frequency[type][j][k]++;
//	 }//end 2opt*
//
//	 //UpdateSolutionAfterMove();
//
//	 UpdateCostFitnessFeasible();
//	 //cout<<"IT = "<<IT<<":Cus P Type = "<<type<<": varcost = "<<best_move.obj->var_cost<<"; varvioTWSP = "<<best_move.obj->var_vioTWSP<<"; varvioTWC = "<<best_move.obj->var_vioTWC<<"; varvioCAP = "<<best_move.obj->var_vioCAP<<"; vioCAPC = "<<vioCAPC<<"; vioTWCus = "<<vioTWCC<<"; vioTWSP = "<<vioTWSPC<<endl;
//	 buon +=cost; buon1 += vioTWSP; buon2 += vioTWC; buon3 += vioCAP;
//
//	 double chan = fabs(best_move.obj->var_cost - buon);
//	 //cout<<"correct = "<<buon<<" == ??? === "<<best_move.obj->var_cost<<endl;
//	 if (chan > eps1)
//	 {
//		 cout<<"MoveCusP of move = "<<best_move.type<<" at IT = "<<IT<<endl;
//		 cout<<"Solution::update_solutionCusP ERROR varcost: correct = "<<buon<<"; error = "<<best_move.obj->var_cost<<endl;
//		 showSegment(fromVeh);
//		 if (sameVeh == 0) showSegment(toVeh);
//		 exit(-1);//getch();
//	 }
//
//	 chan = fabs(best_move.obj->var_vioTWSP - buon1);
//	 if (chan > 0.002)
//	 {
//		 cout<<"MoveCusP of move = "<<best_move.type<<" at IT = "<<IT<<endl;
//		 cout<<"Solution::update_solutionCusP ERROR varvioTWSP: correct = "<<buon1<<"; error = "<<best_move.obj->var_vioTWSP<<endl;
//		 showSegment(fromVeh);
//		 if (sameVeh == 0) showSegment(toVeh);
//		 exit(-1);//getch();
//	 }
//	 chan = fabs(best_move.obj->var_vioTWC - buon2);
//	 if (chan > eps1)
//	 {
//		 cout<<"MoveCusP of move = "<<best_move.type<<" at IT = "<<IT<<endl;
//		 cout<<"Solution::update_solutionCusP ERROR varvioTWC: correct = "<<buon2<<"; error = "<<best_move.obj->var_vioTWC<<endl;
//		 showSegment(fromVeh);
//		 if (sameVeh == 0) showSegment(toVeh);
//		 exit(-1);//getch();
//	 }
//	 int chan2 = abs(best_move.obj->var_vioCAP - buon3);
//	 if (chan2 > eps1)
//	 {
//		 cout<<"MoveCusP of move = "<<best_move.type<<" at IT = "<<IT<<endl;
//		 cout<<"Solution::update_solutionCusP ERROR varvioCAP: correct = "<<buon3<<"; error = "<<best_move.obj->var_vioCAP<<endl;
//		 showSegment(fromVeh);
//		 if (sameVeh == 0) showSegment(toVeh);
//		 exit(-1);//getch();
//	 }
//	 /*if (buc)
//	 {
//		 if (vioCAPC >0 || vioTWCC > eps || vioTWSPC > eps) 
//		 {
//			 cout<<"ERRROR TABU............."<<endl;
//			 exit(-1);
//		 }
//		 else
//		 {
//		   if (PDSGREATER(fitness, FITBEST))
//		   {
//			   cout<<"NOT CREATE NEW BEST: fitnessOLD = "<<buon4<<"; fitnessNEW = "<<fitness<<" > "<<FITBEST<<"; but still do tabu ERRROR TABU............."<<endl;
//			   cout<<"cost sol = "<<cost<<endl;
//			   cout<<"varfit = "<<best_move.obj->var_fitness<<"; varcost = "<<best_move.obj->var_cost<<"; empty = "<<best_move.obj->empty<<endl;
//			   cout<<"numVeh = "<<numVeh<<"; numVehUsed = "<<numVehUsed<<endl;
//			   showSolution();
//			   cout<<"NOT CREATE NEW BEST: fitnessOLD = "<<buon4<<"; fitnessNEW = "<<fitness<<" > "<<FITBEST<<"; but still do tabu ERRROR TABU............."<<endl;
//			   exit(-1);
//		   }
//		 }
//	 }*/
//}
//
//
//
//
//void Solution::update_solutionC2C(moveT best_move)
//{
//	 //10/12/2013
//	 int i, j,k, cusDi;
//	 j= best_move.idCus1; i = best_move.idCus2;	
//	 k = best_move.idNeighbor; cusDi = problem->node[i].delID;
//     int type = best_move.type - 6;
//	 int fromVeh, toVeh, fromTrip, toTrip;
//		
//	 fromVeh = route_num[i]; fromTrip = trip_num[i];
//	 toVeh = route_num[j]; toTrip = trip_num[j];
//     bool sameVeh = 0; bool sameTrip = 0;
//	 
//	 ITTabuC2C += 1;
//	 if (fromVeh == toVeh) 
//	 {
//		 sameVeh = 1;
//		 if (fromTrip == toTrip) sameTrip = 1;
//	 }
//
//	 bool empty;
//
//	 double buon = -cost; double buon1 = - vioTWSP; double buon2 = -vioTWC; int buon3 = -vioCAP;
//	 double buon4 = fitness;
//	 //showSegment(fromVeh);
//	 //if (sameVeh== 0) showSegment(toVeh);
//	 //bool buc = 0;
//
//	 cout<<"---------------------------------------------- IT = "<<IT<<"--------------------------------------------"<<endl;
//	 if (type == 0) //move 1-0: move Customer idCus2 (i) after idCus1 (j)
//	 {
//			 empty = 0;
//			 if (sameTrip) // i and j are in the same trip
//			 {
//				 cout<<"Move C2CP "<<i<<" after cus "<<j<<" and C2CD "<<cusDi<<" after cus "<<moveC2CDAfter[j][k]<<" in the same trip ("<<fromVeh<<", "<<fromTrip<<") update@IT = "<<moveCus[j][k]->atIT<<endl;
//				 cout<<"Trip before moving: "; showTripCus(fromVeh,fromTrip);
//				 //cout<<"----------------------------------------------------------"<<endl;showTripCusCAP(fromVeh,fromTrip);
//				 moveCusC2CTrip_OneTrip(j,i,moveC2CDAfter[j][k],fromVeh,fromTrip); // 27/11/2013 OK 12/1/2014
//				 UpdateArray(fromVeh);
//			 }
//			 else // i and j are in different trips:
//			 {
//				 if (sameVeh) //same vehicle, dif trips:
//				 {
//					 cout<<"Move C2CP "<<i<<" from trip "<<fromTrip<<" after cus "<<j<<" in trip "<<toTrip<<" on veh "<<fromVeh<<" (C2CD "<<cusDi<<" after cus "<<moveC2CDAfter[j][k]<<")"<<endl;
//					 //showSegment(fromVeh);
//					 moveCusC2CTrip_OneVeh(j, toTrip, i, fromTrip, fromVeh, moveC2CDAfter[j][k]); // 27/11/2013 OK 12/1/2014
//					 UpdateArray(fromVeh);
//				 }
//				 else //dif vehicles
//				 {
//					 cout<<"deleteCus["<<i<<"]->var_vioCAP = "<<deleteCus[i]->var_vioCAP<<"; varvioTWC = "<<deleteCus[i]->var_vioTWC<<endl;
//					 cout<<"insertCus["<<j<<"][i]->var_vioCAP = "<<insertCus[j][k]->var_vioCAP<<"; varvioTWC = "<<insertCus[j][k]->var_vioTWC<<endl;
//					 if (seg[fromVeh].Trip[fromTrip].numCus == 2)
//					 {
//							 cout<<"Del (C2CP, C2CD) = ("<<i<<", "<<cusDi<<") from ("<<fromVeh<<", "<<fromTrip<<") make it empty; then move it after cus "<<j<<" on trip ("<<toVeh<<", "<<toTrip<<")"<<endl;
//							 //cout<<"numCj = "<<seg[toVeh].Trip[toTrip].numCus<<"; nextSP = "<<seg[toVeh].Trip[toTrip].nextSP<<endl;
//							 Update_EmptyTripC2C(fromVeh, fromTrip);
//							 //cout<<"Now insert: calling insertCusC2CTrip"<<endl;
//							 insertCusC2CTrip(j,i,insertC2CDAfter[j][k],toVeh, toTrip,seg[toVeh].numTrips - 1); //OK 12/1/2014
//							 UpdateArray(toVeh);
//							 if (seg[fromVeh].numTrips > 0) UpdateArray(fromVeh);
//					 }
//					 else
//					 {
//							 cout<<"Del (C2CP, C2CD) = ("<<i<<", "<<cusDi<<") from ("<<fromVeh<<", "<<fromTrip<<"); then move it after cus "<<j<<" on trip ("<<toVeh<<", "<<toTrip<<")"<<endl;
//							 cout<<"Trip ("<<fromVeh<<", "<<fromTrip<<") before deletion: "; showTripCus(fromVeh,fromTrip);
//							 //cout<<endl;cout<<endl;showTripCusCAP(fromVeh,fromTrip);
//							 //cout<<"Now delete: calling deleteCusC2CTrip"<<endl; 
//							 deleteCusC2CTrip(fromVeh, fromTrip, predArr[i], i, nextArr[i]); // OK 12/1/2014
//							 cout<<"Trip("<<toVeh<<", "<<toTrip<<") before insertion: ";showTripCus(toVeh,toTrip);
//							 insertCusC2CTrip(j,i, insertC2CDAfter[j][k],toVeh, toTrip,seg[toVeh].numTrips - 1); //OK 12/1/2014
//							 UpdateArray(fromVeh);
//							 UpdateArray(toVeh);
//					 }
//				 }//end dif vehicles
//
//			 }//end i ans j are in different trips*/
//			 //tabu[type][j][k] = ITTabuP + Rand(TABUP1, TABUP2);
//	 		 tabu[type][i][0] = ITTabuC2C + Rand(TABUC2C1, TABUC2C2);
//			 frequency[type][j][k]++;
//			 //cout<<"Setting tabu for moving cus "<<i<<" ater "<<j<<" = "<<tabu[type][j][k]<<endl;
//			 //showSegment(fromVeh);
//			 //if (sameVeh == 0) showSegment(toVeh);
//	 }
//	 else if (type == 1) //exchange 1-1: exchange customer idCus2 and idCus1 (CASE1: same vehicle / CASE2: 2 vehicles)
//	 {
//		 if (sameVeh) 
//		 {
//			 if (sameTrip)
//			 {
//				 cout<<"SAME TRIP: Exchange cus i = "<<i<<"(cusDi = "<<problem->node[i].delID<<") and j = "<<j<<"(cusDj = "<<problem->node[j].delID<<") same trip ("<<fromVeh<<", "<<fromTrip<<")"<<endl;
//				 exchangeCusC2CTrip_OneTrip(j,i,fromVeh,fromTrip);
//			 }
//			 else
//			 {
//				 /*cout<<"Exchange cus "<<j<<" on trip "<<toTrip<<" with cus "<<i<<" on trip "<<fromTrip<<" on the same vehicle "<<fromVeh<<endl;
//				 cout<<"exchangeCus["<<j<<"]["<<k<<"]->atIT = "<<exchangeCus[j][k]->atIT<<"; varcost = "<<exchangeCus[j][k]->var_cost<<endl;
//				 cout<<"varvioTWC = "<<exchangeCus[j][k]->var_vioTWC<<"; varvioTWCi = "<<exchangeCus[j][k]->var_vioTWCi<<"; varvioTWCj = "<<exchangeCus[j][k]->var_vioTWCj<<endl;
//				 cout<<"varvioTWSP = "<<exchangeCus[j][k]->var_vioTWSP<<"; varvioTWSPi = "<<exchangeCus[j][k]->var_vioTWSPi<<"; varvioTWSPj = "<<exchangeCus[j][k]->var_vioTWSPj<<endl;
//				 cout<<"varcosti = "<<exchangeCus[j][k]->var_costi<<"; varcostj = "<<exchangeCus[j][k]->var_costj<<endl;
//				 */
//				 cout<<"SAME VEHICLE "<<fromVeh<<": Exchange cus i = "<<i<<"(cusDi = "<<problem->node[i].delID<<", trip = "<<fromTrip<<") and j = "<<j<<"(cusDj = "<<problem->node[j].delID<<", trip = "<<toTrip<<")"<<endl;
//				 exchangeCusC2CTrip_OneVeh(j, toTrip, i, fromTrip, fromVeh);
//			 }
//			 UpdateArray(fromVeh);
//		 }
//		 else 
//		 {
//			 /*cout<<"Exchange cus "<<j<<" on veh ("<<toVeh<<", "<<toTrip<<") with cus "<<i<<" on veh ("<<fromVeh<<", "<<fromTrip<<")"<<endl;
//			 cout<<"exchangeCus["<<j<<"]["<<k<<"]->atIT = "<<exchangeCus[j][k]->atIT<<"; varcost = "<<exchangeCus[j][k]->var_cost<<endl;
//			 cout<<"varvioTWC = "<<exchangeCus[j][k]->var_vioTWC<<"; varvioTWCi = "<<exchangeCus[j][k]->var_vioTWCi<<"; varvioTWCj = "<<exchangeCus[j][k]->var_vioTWCj<<endl;
//			 cout<<"varvioTWSP = "<<exchangeCus[j][k]->var_vioTWSP<<"; varvioTWSPi = "<<exchangeCus[j][k]->var_vioTWSPi<<"; varvioTWSPj = "<<exchangeCus[j][k]->var_vioTWSPj<<endl;
//			 cout<<"varcosti = "<<exchangeCus[j][k]->var_costi<<"; varcostj = "<<exchangeCus[j][k]->var_costj<<endl;
//			 */
//			 cout<<"DIF VEHICLE "<<fromVeh<<": Exchange cus i = "<<i<<"(cusDi = "<<problem->node[i].delID<<", trip = ("<<fromVeh<<", "<<fromTrip<<") and j = "<<j<<"(cusDj = "<<problem->node[j].delID<<", trip = ("<<toVeh<<", "<<toTrip<<")"<<endl;
//			 replaceCusC2CTrip(i,fromVeh,fromTrip,j); //insert j at place of i, cusDj at place of cusDi at trip (fromVeh, fromTrip)
//			 replaceCusC2CTrip(j,toVeh,toTrip,i);
//			 UpdateArray(fromVeh);
//			 UpdateArray(toVeh);
//		 }
//	     //showSegment(fromVeh);
//		 //if (sameVeh == 0) showSegment(toVeh);
//		 tabu[type][i][k] = ITTabuC2C + Rand(TABUC2C1, TABUC2C2);
//		 frequency[type][j][k]++;
//
//
//	 }
//
//	 //UpdateSolutionAfterMove();
//
//	 UpdateCostFitnessFeasible();
//	 //cout<<"IT = "<<IT<<":Cus P Type = "<<type<<": varcost = "<<best_move.obj->var_cost<<"; varvioTWSP = "<<best_move.obj->var_vioTWSP<<"; varvioTWC = "<<best_move.obj->var_vioTWC<<"; varvioCAP = "<<best_move.obj->var_vioCAP<<"; vioCAPC = "<<vioCAPC<<"; vioTWCus = "<<vioTWCC<<"; vioTWSP = "<<vioTWSPC<<endl;
//	 buon +=cost; buon1 += vioTWSP; buon2 += vioTWC; buon3 += vioCAP;
//
//	 double chan = fabs(best_move.obj->var_cost - buon);
//	 //cout<<"correct = "<<buon<<" == ??? === "<<best_move.obj->var_cost<<endl;
//	 if (chan > eps1)
//	 {
//		 cout<<"MoveCusC2C of move = "<<best_move.type<<" at IT = "<<IT<<endl;
//		 cout<<"Solution::update_solutionCusC2C ERROR varcost: correct = "<<buon<<"; error = "<<best_move.obj->var_cost<<endl;
//		 showSegment(fromVeh);
//		 if (sameVeh == 0) showSegment(toVeh);
//		 exit(-1);//getch();
//	 }
//
//	 chan = fabs(best_move.obj->var_vioTWSP - buon1);
//	 if (chan > 0.002)
//	 {
//		 cout<<"MoveCusC2C of move = "<<best_move.type<<" at IT = "<<IT<<endl;
//		 cout<<"Solution::update_solutionCusC2C ERROR varvioTWSP: correct = "<<buon1<<"; error = "<<best_move.obj->var_vioTWSP<<endl;
//		 showSegment(fromVeh);
//		 if (sameVeh == 0) showSegment(toVeh);
//		 exit(-1);//getch();
//	 }
//	 chan = fabs(best_move.obj->var_vioTWC - buon2);
//	 if (chan > eps1)
//	 {
//		 cout<<"MoveCusC2C of move = "<<best_move.type<<" at IT = "<<IT<<endl;
//		 cout<<"Solution::update_solutionCusC2C ERROR varvioTWC: correct = "<<buon2<<"; error = "<<best_move.obj->var_vioTWC<<endl;
//		 showSegment(fromVeh);
//		 if (sameVeh == 0) showSegment(toVeh);
//		 exit(-1);//getch();
//	 }
//	 int chan2 = abs(best_move.obj->var_vioCAP - buon3);
//	 if (chan2 > eps1)
//	 {
//		 cout<<"MoveCusC2C of move = "<<best_move.type<<" at IT = "<<IT<<endl;
//		 cout<<"Solution::update_solutionCusC2C ERROR varvioCAP: correct = "<<buon3<<"; error = "<<best_move.obj->var_vioCAP<<endl;
//		 showSegment(fromVeh);
//		 if (sameVeh == 0) showSegment(toVeh);
//		 exit(-1);//getch();
//	 }
//	 /*if (buc)
//	 {
//		 if (vioCAPC >0 || vioTWCC > eps || vioTWSPC > eps) 
//		 {
//			 cout<<"ERRROR TABU............."<<endl;
//			 exit(-1);
//		 }
//		 else
//		 {
//		   if (PDSGREATER(fitness, FITBEST))
//		   {
//			   cout<<"NOT CREATE NEW BEST: fitnessOLD = "<<buon4<<"; fitnessNEW = "<<fitness<<" > "<<FITBEST<<"; but still do tabu ERRROR TABU............."<<endl;
//			   cout<<"cost sol = "<<cost<<endl;
//			   cout<<"varfit = "<<best_move.obj->var_fitness<<"; varcost = "<<best_move.obj->var_cost<<"; empty = "<<best_move.obj->empty<<endl;
//			   cout<<"numVeh = "<<numVeh<<"; numVehUsed = "<<numVehUsed<<endl;
//			   showSolution();
//			   cout<<"NOT CREATE NEW BEST: fitnessOLD = "<<buon4<<"; fitnessNEW = "<<fitness<<" > "<<FITBEST<<"; but still do tabu ERRROR TABU............."<<endl;
//			   exit(-1);
//		   }
//		 }
//	 }*/
//}
//
//void Solution::Update_deleteCusArrayD_FirstTrip_Empty(int idVeh) //update deleteCusD for first trip of vehicle idVeh with only 1 delivery customer
//{
//	//see on 2/12/2013
//	//Update 12/11/2013: First Trip is pickup
//	int assSP = seg[idVeh].Trip[0].assSP;
//	int	deletednode = seg[idVeh].Trip[0].firstCus;
//	
//	if (numTripDSP[assSP] == problem->minTripSP[assSP]) deleteCus[deletednode]->atIT = -100;
//	else
//	{
//			int curC, assSP1;
//			double varcost, varvioTWC, varvioTWSP, cStartS;
//		
//			deleteCus[deletednode]->empty = 0;
//			deleteCus[deletednode]->var_vioCAP = 0;
//			varvioTWC = -seg[idVeh].Trip[0].vioTWC;
//			varcost = -seg[idVeh].Trip[0].cost;
//			curC = seg[idVeh].Trip[1].firstCus;
//			if (seg[idVeh].Trip[1].Type == 1) 
//			{
//				assSP1 = seg[idVeh].Trip[1].assSP;
//				cStartS = problem->leaveSP[assSP1][4]; //load only at sTW2
//				varvioTWSP = -seg[idVeh].Trip[1].vioTWSP;
//				varcost += problem->c[0][assSP1];
//				GoThroughVehicle(idVeh, 1, varcost, varvioTWC, varvioTWSP, cStartS, assSP1, curC);
//			}
//			else if (seg[idVeh].Trip[1].Type == 0)
//			{
//			    varvioTWSP = 0;
//				varcost += problem->c[0][curC];
//				GoThroughVehicle_FirstPT(idVeh, 1, varcost, varvioTWC, varvioTWSP); //27/11/2013
//			}
//			else //C2C:
//			{
//			    varvioTWSP = 0;
//				varcost += problem->c[0][curC];
//				if (seg[idVeh].numTrips > 2)
//				{
//					if (seg[idVeh].Trip[1].nextSP > 0) //[?] - C2C-SP-d
//				        GoThroughVehicle_FirstC2C(idVeh, 1, varcost, varvioTWC, varvioTWSP);
//					else 
//						GoThroughVehicle(idVeh,1,varcost,varvioTWC,varvioTWSP,0,0,curC);
//				}
//				else
//					GoThroughVehicle(idVeh, 1, varcost, varvioTWC, varvioTWSP, 0, 0, curC);
//			}
//			deleteCus[deletednode]->var_cost = varcost;
//			deleteCus[deletednode]->var_vioTWC = varvioTWC;
//			deleteCus[deletednode]->var_vioTWSP = varvioTWSP;
//			deleteCus[deletednode]->atIT = IT;
//		}//end else: need to update
//}
//
//
//void Solution::Update_deleteCusArrayD_MiddleTrip_Empty(int idVeh, int idTrip) //update deleteCusD for middle trip (idVeh, idTrip) with only 1 delivery customer
//{
//	//see on 2/12/2013
//	int assSP = seg[idVeh].Trip[idTrip].assSP;
//	int	deletednode = seg[idVeh].Trip[idTrip].firstCus;
//
//	if (numTripDSP[assSP] == problem->minTripSP[assSP]) deleteCus[deletednode]->atIT = -100;
//	else
//	{
//		    deleteCus[deletednode]->empty = 0;
//			deleteCus[deletednode]->var_vioCAP = 0;
//			int curC, preC;
//			double varcost, varvioTWC, varvioTWSP, cStartS;
//			int preT = idTrip - 1; int nextT = idTrip + 1;
//			bool stop;
//
//			varvioTWC = -seg[idVeh].Trip[idTrip].vioTWC;
//			varvioTWSP = -seg[idVeh].Trip[idTrip].vioTWSP;
//			varcost = -(seg[idVeh].Trip[idTrip].cost + seg[idVeh].Trip[preT].connectCost);
//			if (seg[idVeh].Trip[preT].Type == 0)
//			{
//				cStartS = seg[idVeh].Trip[preT].leaveSP;
//				if (seg[idVeh].Trip[nextT].Type == 1) // p - assSP - [d] - d OR p - assSP1 - [assSP - d] - d
//				{
//					stop = calCONNECTCSPTOSPD_FORDELETE(seg[idVeh].Trip[preT].assSP, idVeh, nextT, cStartS, varvioTWSP, varcost);
//					if (stop) goto Update;
//					preC = seg[idVeh].Trip[nextT].assSP; curC = seg[idVeh].Trip[nextT].firstCus;
//				}
//				else //(p - assSP - [d] - p OR p - assSP1 - [assSP - d] - p) OR (p - assSP - [d] - C2C)
//				{
//					preC = seg[idVeh].Trip[preT].assSP;
//					curC = seg[idVeh].Trip[nextT].firstCus;
//					varcost += problem->c[preC][curC];
//				}//end p - assSP - [d] - p OR p - assSP - [d] - C2C
//			}
//			else //if (seg[idVeh].Trip[preT].Type == 1 || 2)
//			{
//				preC = seg[idVeh].Trip[preT].lastCus; cStartS = depart[preC];
//				if (seg[idVeh].Trip[nextT].Type == 1) // d - [ d ] - d OR C2C - [d] - d
//				{
//					stop = calCONNECTCSPTOSPD_FORDELETE(preC, idVeh, nextT, cStartS, varvioTWSP, varcost);
//					if (stop) goto Update;
//					preC = seg[idVeh].Trip[nextT].assSP; curC = seg[idVeh].Trip[nextT].firstCus;
//				} 
//				else //(d - [d] - p OR d - [d] - C2C) OR (c2c - [d] - p] OR (c2c-[d]-c2c)
//				{
//					curC = seg[idVeh].Trip[nextT].firstCus;
//					varcost += problem->c[preC][curC];
//				}//end d - [d] - p
//			}//end if (seg[idVeh].Trip[preT].Type == 1 || 2)
//
//			GoThroughVehicle(idVeh, nextT, varcost, varvioTWC, varvioTWSP, cStartS, preC, curC);
//			Update:
//				deleteCus[deletednode]->var_cost = varcost;
//				deleteCus[deletednode]->var_vioTWC = varvioTWC;
//				deleteCus[deletednode]->var_vioTWSP = varvioTWSP;
//				deleteCus[deletednode]->atIT = IT;
//		}//end else: need to update
//}
//
//void Solution::Update_deleteCusArrayD_FirstMiddleTrip(int idVeh, int idTrip) //only applied for the case where vehicle has >= 2 trips
//{
//	//see on 2/12/2013
//	int numC = seg[idVeh].Trip[idTrip].numCus;
//	int assSP = seg[idVeh].Trip[idTrip].assSP;
//	int assSP1, curC, preC;
//	double varcost, varvioTWC, varvioTWSP, cStartS, cArrTime, cArrTimeI, temp;
//	int vioCapNEW;
//	int lastTrip = seg[idVeh].numTrips-1;
//	int deletednode;
//
//	int preC1 = assSP;
//	deletednode = seg[idVeh].Trip[idTrip].firstCus;
//	cStartS = seg[idVeh].Trip[idTrip].leaveSP;
//	int capOLD = seg[idVeh].Trip[idTrip].capacity;
//	int vioCapOLD = seg[idVeh].Trip[idTrip].vioCAP;
//	int curC1 = nextArr[deletednode];
//
//	int nextT = idTrip + 1;
//	int firstC_nextT = seg[idVeh].Trip[nextT].firstCus;
//
//	if (seg[idVeh].Trip[nextT].Type == 1)
//	{
//			assSP1 = seg[idVeh].Trip[nextT].assSP;
//			//1. Delete the first and middle delivery customers:
//			while (curC1 > 0)
//			{
//				varvioTWC = -vioTWCus[deletednode]; varvioTWSP = 0;
//				varcost = problem->c[preC1][curC1] - (problem->c[preC1][deletednode] + problem->c[deletednode][curC1]);
//				preC = preC1; curC = curC1;
//				do
//				{
//					cArrTime = cStartS + problem->c[preC][curC];
//					cStartS = PDS_MAX(cArrTime, problem->node[curC].sTW);
//					temp = cStartS - problem->node[curC].eTW;
//					if (temp > eps) //Update 8/11/2013
//					{
//							varvioTWC += (temp - vioTWCus[curC]);
//							if (vioTWCus[curC] > eps) goto Update;
//							cStartS = problem->node[curC].depart;
//					}
//					else
//					{
//						varvioTWC -= vioTWCus[curC];
//						if (PDSDIF(cStartS, startS[curC] == 0)) goto Update;
//						cStartS += problem->node[curC].duration;
//					}
//					preC = curC; curC = nextArr[curC];
//				} while (curC > 0);
//
//				if (calChangeCONNECTCSPTOSPD_FORDELETE(preC, idVeh, nextT, cStartS, varvioTWSP, varcost) == 0)
//					GoThroughVehicle(idVeh, nextT, varcost, varvioTWC, varvioTWSP, cStartS, assSP1, firstC_nextT);
//				Update:
//					deleteCus[deletednode]->var_cost = varcost;
//					deleteCus[deletednode]->var_vioTWC = varvioTWC;
//					deleteCus[deletednode]->var_vioTWSP = varvioTWSP;
//					vioCapNEW = PDS_MAX(capOLD - problem->node[deletednode].capacity- problem->Q,0);
//					deleteCus[deletednode]->var_vioCAP = vioCapNEW - vioCapOLD;
//					deleteCus[deletednode]->atIT = IT;
//					deleteCus[deletednode]->empty = 0;
//
//				//New delete customer:
//				preC1 = deletednode; cStartS = depart[preC1];
//				deletednode = curC1; curC1 = nextArr[curC1];
//			}//end while (curC1 > 0)
//
//			//2. Delete the last delivery customer:
//			vioCapNEW = PDS_MAX(capOLD - problem->node[deletednode].capacity- problem->Q,0);
//			deleteCus[deletednode]->var_vioCAP = vioCapNEW - vioCapOLD;
//			varvioTWC = -vioTWCus[deletednode];
//
//			cArrTime = depart[preC1] + problem->c[preC1][assSP1];
//			if (PDSINRANGE(cArrTime, problem->nodeSP[assSP1].sTW2, problem->nodeSP[assSP1].eTW2))
//			{
//				varvioTWSP = -seg[idVeh].Trip[nextT].vioTWSP;
//				//before deletion has to go to sp directly: FEA OR INFEA NOT ALWAYS Update 7/11/2013
//				if (seg[idVeh].Trip[idTrip].waitingS == NO_WS)
//					varcost = problem->c[preC1][assSP1] - (problem->c[preC1][deletednode] + problem->c[deletednode][assSP1]);
//				else
//					varcost = problem->c[preC1][assSP1] - (problem->c[preC1][deletednode] + problem->disCWSSP[deletednode][assSP1]);
//				cStartS = cArrTime + problem->nodeSP[assSP1].load;
//			}
//			else
//			{
//					temp = cArrTime - problem->nodeSP[assSP1].eTW2;
//					if (temp > eps)
//					{
//						//before deletion has to go to sp directly: INFEA NOT ALWAYS Update 7/11/2013
//						if (seg[idVeh].Trip[idTrip].waitingS == NO_WS)
//							deleteCus[deletednode]->var_cost = problem->c[preC1][assSP1] - (problem->c[preC1][deletednode] + problem->c[deletednode][assSP1]);
//						else
//							varcost = problem->c[preC1][assSP1] - (problem->c[preC1][deletednode] + problem->disCWSSP[deletednode][assSP1]);
//						deleteCus[deletednode]->var_vioTWSP = temp - seg[idVeh].Trip[nextT].vioTWSP;
//						deleteCus[deletednode]->var_vioTWC = varvioTWC;
//						deleteCus[deletednode]->atIT = IT;
//						deleteCus[deletednode]->empty = 0;
//						return;
//					}
//					else
//					{
//						cArrTimeI = depart[preC1] + problem->disCWSSP[preC1][assSP1];
//						temp = cArrTimeI - problem->nodeSP[assSP1].eTW2;
//						if (temp > eps) //too soon to go sp directly, too late to go through WS:
//						{
//							varvioTWSP = problem->nodeSP[assSP1].sTW2 - cArrTime - seg[idVeh].Trip[nextT].vioTWSP;
//							//before deletion has to go to sp directly: FEA OR INFEA NOT ALWAYS: Update 7/11/2013
//							if (seg[idVeh].Trip[idTrip].waitingS == NO_WS)
//								deleteCus[deletednode]->var_cost = problem->c[preC1][assSP1] - (problem->c[preC1][deletednode] + problem->c[deletednode][assSP1]);
//							else
//								varcost = problem->c[preC1][assSP1] - (problem->c[preC1][deletednode] + problem->disCWSSP[deletednode][assSP1]);
//							cStartS = problem->leaveSP[assSP1][1]; //load only at eTW2
//						}
//						else //to go through WS
//						{
//							varvioTWSP = -seg[idVeh].Trip[nextT].vioTWSP;
//							//before deletion may go to sp directly or through WS:
//							if (seg[idVeh].Trip[idTrip].waitingS == NO_WS)
//								varcost = problem->disCWSSP[preC1][assSP1] - (problem->c[preC1][deletednode] + problem->c[deletednode][assSP1]);
//							else varcost = problem->disCWSSP[preC1][assSP1] - (problem->c[preC1][deletednode] + problem->disCWSSP[deletednode][assSP1]);
//							cStartS = PDS_MAX(cArrTimeI, problem->nodeSP[assSP1].sTW2) + problem->nodeSP[assSP1].load;
//						}
//					}
//				}
//				GoThroughVehicle(idVeh, 1, varcost, varvioTWC, varvioTWSP, cStartS, assSP1, firstC_nextT);
//				deleteCus[deletednode]->var_cost = varcost;
//				deleteCus[deletednode]->var_vioTWC = varvioTWC;
//				deleteCus[deletednode]->var_vioTWSP = varvioTWSP;
//				deleteCus[deletednode]->atIT = IT;
//				deleteCus[deletednode]->empty = 0;
//	}
//	else //if (seg[idVeh].Trip[nextT].Type == 0 || 2)
//	{
//			//1. Delete the first and middle delivery customers:
//			while (curC1 > 0)
//			{
//				varvioTWC = -vioTWCus[deletednode]; //Update 7/11/2013
//				varvioTWSP = 0;
//				varcost = problem->c[preC1][curC1] - (problem->c[preC1][deletednode] + problem->c[deletednode][curC1]);
//				preC = preC1; curC = curC1;
//				do
//				{
//					cArrTime = cStartS + problem->c[preC][curC];
//					cStartS = PDS_MAX(cArrTime, problem->node[curC].sTW);
//					temp = cStartS - problem->node[curC].eTW;
//					if (temp > eps) //Upadte 8/11/2013
//					{
//							varvioTWC += (temp - vioTWCus[curC]);
//							if (vioTWCus[curC] > eps) goto UpdateP_C2C;
//							cStartS = problem->node[curC].depart;
//					}
//					else 
//					{
//						varvioTWC -= vioTWCus[curC];
//						if (PDSDIF(cStartS, startS[curC])== 0) goto UpdateP_C2C;
//						cStartS += problem->node[curC].duration;
//					}
//					preC = curC; curC = nextArr[curC];
//				} while (curC > 0);
//				GoThroughVehicle(idVeh, nextT, varcost, varvioTWC, varvioTWSP, cStartS, preC, firstC_nextT);
//
//				UpdateP_C2C:
//					deleteCus[deletednode]->var_cost = varcost;
//					deleteCus[deletednode]->var_vioTWC = varvioTWC;
//					deleteCus[deletednode]->var_vioTWSP = varvioTWSP;
//					vioCapNEW = PDS_MAX(capOLD - problem->node[deletednode].capacity- problem->Q,0);
//					deleteCus[deletednode]->var_vioCAP = vioCapNEW - vioCapOLD;
//					deleteCus[deletednode]->atIT = IT;
//					deleteCus[deletednode]->empty = 0;
//
//				//New delete customer:
//				preC1 = deletednode; cStartS = depart[preC1];
//				deletednode = curC1; curC1 = nextArr[curC1];
//			}//end while (curC1 > 0)
//
//			//2. Delete the last delivery customer:
//			vioCapNEW = PDS_MAX(capOLD - problem->node[deletednode].capacity- problem->Q,0);
//			deleteCus[deletednode]->var_vioCAP = vioCapNEW - vioCapOLD;
//			varvioTWC = -vioTWCus[deletednode];
//			varcost = problem->c[preC1][firstC_nextT] - (problem->c[preC1][deletednode] + problem->c[deletednode][firstC_nextT]);
//			varvioTWSP = 0;
//			GoThroughVehicle(idVeh, nextT, varcost, varvioTWC, varvioTWSP, depart[preC1], preC1, firstC_nextT);
//			deleteCus[deletednode]->var_cost = varcost;
//			deleteCus[deletednode]->var_vioTWC = varvioTWC;
//			deleteCus[deletednode]->var_vioTWSP = varvioTWSP;
//			deleteCus[deletednode]->atIT = IT;
//			deleteCus[deletednode]->empty = 0;
//	}//end if (seg[idVeh].Trip[nextT].Type == 0 || 2)
//}
//
//void Solution::Update_deleteCusArrayD_LastTrip_Empty(int idVeh, int idTrip)
//{
//	//see on 2/12/2013
//	int assSP = seg[idVeh].Trip[idTrip].assSP;
//	int	deletednode = seg[idVeh].Trip[idTrip].firstCus;
//	
//	if (numTripDSP[assSP] == problem->minTripSP[assSP]) deleteCus[deletednode]->atIT = -100;
//	else
//	{
//		int preT = idTrip - 1;
//		deleteCus[deletednode]->empty = 0;
//		deleteCus[deletednode]->var_vioCAP = 0;
//		deleteCus[deletednode]->var_vioTWC = -seg[idVeh].Trip[idTrip].vioTWC;
//		deleteCus[deletednode]->var_vioTWSP = -seg[idVeh].Trip[idTrip].vioTWSP;
//
//		double varcost = -(seg[idVeh].Trip[preT].connectCost + seg[idVeh].Trip[idTrip].cost);
//		if (seg[idVeh].Trip[preT].Type == 0) 
//			varcost += problem->c[seg[idVeh].Trip[preT].assSP][0];
//		else
//			varcost += problem->c[seg[idVeh].Trip[preT].lastCus][0];
//		deleteCus[deletednode]->var_cost = varcost;
//		deleteCus[deletednode]->atIT = IT;
//	}//end else: need to update	
//}
//
//
//
//void Solution::Update_deleteCusArrayD_LastTrip(int idVeh, int idTrip) //only applied for the case where vehicle has >= 2 trips
//{
//	//see on 2/12/2013
//	int numC = seg[idVeh].Trip[idTrip].numCus;
//	int curC, preC;
//	double varcost, varvioTWC, varvioTWSP, cStartS, cArrTime, temp;
//	int vioCapNEW;
//	int deletednode;
//
//	int preC1 = seg[idVeh].Trip[idTrip].assSP;
//	deletednode = seg[idVeh].Trip[idTrip].firstCus;
//	cStartS = seg[idVeh].Trip[idTrip].leaveSP;
//	int capOLD = seg[idVeh].Trip[idTrip].capacity;
//	int vioCapOLD = seg[idVeh].Trip[idTrip].vioCAP;
//	int curC1 = nextArr[deletednode];
//
//	//1. Delete the first and middle delivery customers:
//	while (curC1 > 0)
//	{
//			varvioTWC = -vioTWCus[deletednode];  //Update 7/11/2013
//			varvioTWSP = 0;
//			varcost = problem->c[preC1][curC1] - (problem->c[preC1][deletednode] + problem->c[deletednode][curC1]);
//			preC = preC1; curC = curC1;
//			do
//			{
//				cArrTime = cStartS + problem->c[preC][curC];
//				cStartS = PDS_MAX(cArrTime, problem->node[curC].sTW);
//				temp = cStartS - problem->node[curC].eTW;
//				if (temp > eps) //Update 8/11/2013
//				{
//						varvioTWC += (temp - vioTWCus[curC]);
//						if (vioTWCus[curC] > eps) break;
//						cStartS = problem->node[curC].depart;
//				}
//				else 
//				{
//					varvioTWC -= vioTWCus[curC]; // MAY REMOVE? NOT
//					if (PDSDIF(cStartS, startS[curC])== 0) break;
//					cStartS += problem->node[curC].duration;
//				}
//				preC = curC; curC = nextArr[curC];
//			} while (curC > 0);
//			deleteCus[deletednode]->var_cost = varcost;
//			deleteCus[deletednode]->var_vioTWC = varvioTWC;
//			deleteCus[deletednode]->var_vioTWSP = varvioTWSP;
//			vioCapNEW = PDS_MAX(capOLD - problem->node[deletednode].capacity- problem->Q,0);
//			deleteCus[deletednode]->var_vioCAP = vioCapNEW - vioCapOLD;
//			deleteCus[deletednode]->atIT = IT;
//			deleteCus[deletednode]->empty = 0;
//
//			//New delete customer:
//			preC1 = deletednode; cStartS = depart[preC1];
//			deletednode = curC1; curC1 = nextArr[curC1];
//	}//end while (curC1 > 0)
//
//	//2. Delete the last delivery customer:
//	vioCapNEW = PDS_MAX(capOLD - problem->node[deletednode].capacity- problem->Q,0);
//	deleteCus[deletednode]->var_vioCAP = vioCapNEW - vioCapOLD;
//	deleteCus[deletednode]->var_vioTWC = -vioTWCus[deletednode];
//	deleteCus[deletednode]->var_vioTWSP = 0;
//	deleteCus[deletednode]->var_cost = problem->c[preC1][0] - (problem->c[preC1][deletednode] + problem->c[deletednode][0]);
//	deleteCus[deletednode]->atIT = IT;
//	deleteCus[deletednode]->empty = 0;
//}
//
//
//
//void Solution::Update_deleteCusArrayP_FirstTrip_Empty(int idVeh) //update deleteCusD for first trip of vehicle idVeh with only 1 delivery customer
//{
//	//See on 2/12/2013
//	int assSP1;
//	int	deletednode = seg[idVeh].Trip[0].firstCus;
//	
//	deleteCus[deletednode]->var_vioCAP = 0;
//	double varvioTWC = -seg[idVeh].Trip[0].vioTWC;
//	double varcost = -seg[idVeh].Trip[0].cost;
//	double varvioTWSP, cStartS;
//	int curC = seg[idVeh].Trip[1].firstCus;
//
//
//	if (seg[idVeh].Trip[1].Type == 1) 
//	{
//		assSP1 = seg[idVeh].Trip[1].assSP;
//		cStartS = problem->leaveSP[assSP1][4]; //load only at sTW2
//		varvioTWSP = -(seg[idVeh].Trip[0].vioTWSP + seg[idVeh].Trip[1].vioTWSP);
//		varcost += problem->c[0][assSP1];
//		GoThroughVehicle(idVeh,1, varcost, varvioTWC, varvioTWSP, cStartS, assSP1, curC);
//	}
//	else if (seg[idVeh].Trip[1].Type == 0)
//	{
//	    varvioTWSP = -seg[idVeh].Trip[0].vioTWSP;
//		varcost += problem->c[0][curC];
//		GoThroughVehicle_FirstPT(idVeh,1, varcost, varvioTWC, varvioTWSP);
//	}
//	else //if (seg[idVeh].Trip[1].Type == 2)
//	{
//		varvioTWSP = -seg[idVeh].Trip[0].vioTWSP;
//		varcost += problem->c[0][curC];
//		GoThroughVehicle_FirstC2C(idVeh,1,varcost,varvioTWC,varvioTWSP);
//	}
//	deleteCus[deletednode]->var_cost = varcost;
//	deleteCus[deletednode]->var_vioTWC = varvioTWC;
//	deleteCus[deletednode]->var_vioTWSP = varvioTWSP;
//	deleteCus[deletednode]->atIT = IT;
//	deleteCus[deletednode]->empty = 0;
//}
//
//
//
//bool Solution::cal_deleteCusArrayP_FirstTrip_Empty_TillTrip(int idVeh, double &varcost, double &varvioTWC, double &varvioTWSP, double &cStartS, int update_idTrip)
//{
//	//See on 2/12/2013
//	int assSP1;
//	varvioTWC  -= seg[idVeh].Trip[0].vioTWC;
//	varcost -= seg[idVeh].Trip[0].cost;
//
//	int curC = seg[idVeh].Trip[1].firstCus;
//
//	if (seg[idVeh].Trip[1].Type == 1) 
//	{
//		assSP1 = seg[idVeh].Trip[1].assSP;
//		cStartS = problem->leaveSP[assSP1][4]; //load only at sTW2
//		varvioTWSP -= (seg[idVeh].Trip[0].vioTWSP + seg[idVeh].Trip[1].vioTWSP);
//		varcost += problem->c[0][assSP1];
//		//Quangnn+-
//		return 0; //GoThroughVehicle(idVeh, 1, update_idTrip, varcost, varvioTWC, varvioTWSP, cStartS, assSP1, curC);
//	}
//	else if (seg[idVeh].Trip[1].Type == 0) 
//	{
//	    varvioTWSP -= seg[idVeh].Trip[0].vioTWSP;
//		varcost += problem->c[0][curC];
//		return GoThroughVehicle_FirstPT(idVeh, 1, update_idTrip, varcost, varvioTWC, varvioTWSP, cStartS); //ok 14/11/2013
//	}
//	else //if (seg[idVeh].Trip[1].Type == 2) 
//	{
//		varvioTWSP -= seg[idVeh].Trip[0].vioTWSP;
//		varcost += problem->c[0][curC];
//		if (seg[idVeh].Trip[1].nextSP > 0)
//			return GoThroughVehicle_FirstC2C(idVeh,1,update_idTrip,varcost,varvioTWC,varvioTWSP,cStartS);
//		else
//		{
//			cStartS = 0;
//			//Quangnn+-
//			return 0; //GoThroughVehicle(idVeh, 1, update_idTrip, varcost, varvioTWC, varvioTWSP, cStartS, 0,curC);
//		}
///*		if (seg[idVeh].numTrips > 2)
//		{
//			if (seg[idVeh].Trip[2].Type == 1)
//				GoThroughVehicle_FirstC2C(idVeh,1,update_idTrip,varcost,varvioTWC,varvioTWSP,cStartS);
//			else
//			{
//				cStartS = 0;
//				GoThroughVehicle(idVeh,1,update_idTrip,varcost,varvioTWC,varvioTWSP,cStartS);
//			}
//		}
//		else 
//		{
//			cStartS = 0;
//			GoThroughVehicle(idVeh,1,update_idTrip,varcost,varvioTWC,varvioTWSP,cStartS);
//		}*/
//	}
//}
//
//
//
//
//void Solution::cal_deleteCusArrayP_FirstTrip_Empty_insertNextTrip(int j, int i, int idVeh, double &varcosti, double &varvioTWCi, double &varvioTWSPi, double &varcostj, double &varvioTWCj, double &varvioTWSPj, int &varvioCAP)
//{
//	//See on 2/12/2013
//	varvioTWCi  -= seg[idVeh].Trip[0].vioTWC;
//	varcosti -= seg[idVeh].Trip[0].cost;
//
//	int nextID = seg[idVeh].Trip[1].firstCus;
//	varvioTWSPi -= seg[idVeh].Trip[0].vioTWSP;
//    varcostj += problem->c[0][nextID];
//
//	int vioCAPNEW = PDS_MAX(seg[idVeh].Trip[1].capacity + problem->node[i].capacity - Q, 0);
//	varvioCAP += (vioCAPNEW - seg[idVeh].Trip[1].vioCAP);
//
//	//Copy GoThroughVehicle_FirstPT:
//	int preID = 0;
//	double cStartS = 0, cArrTime, temp; 
//	int sucj = nextArr[j];
//	while (nextID != sucj)
//	{
//		cArrTime = cStartS + problem->c[preID][nextID];
//		cStartS = PDS_MAX(cArrTime, problem->node[nextID].sTW);
//		temp = cStartS - problem->node[nextID].eTW;
//		if (temp > eps)
//		{
//			varvioTWCj += (temp - vioTWCus[nextID]);
//			if (vioTWCus[nextID] > eps)
//			{
//				cStartS = depart[j];
//				break;
//			}
//			cStartS = problem->node[nextID].eTW;
//		}
//		else varvioTWCj -= vioTWCus[nextID];
//		if (PDSDIF(cStartS, startS[nextID]) == 0)
//		{
//			cStartS = depart[j];
//			break;
//		}
//		cStartS += problem->node[nextID].duration;
//		preID = nextID; nextID = nextArr[nextID];
//	}
//
//	//Insert i:
//	cArrTime = cStartS + problem->c[j][i];
//	cStartS = PDS_MAX(cArrTime, problem->node[i].sTW);
//	temp = cStartS - problem->node[i].eTW;
//	//cout<<"j = "<<j<<", i = "<<i<<"( ";
//	if (temp > eps) 
//	{
//		varvioTWCj += temp;
//		cStartS = problem->node[i].depart;
//		//cout<<temp<<", "<<cStartS<<");";
//	}
//	else 
//	{
//		cStartS += problem->node[i].duration;
//		//cout<<"0, "<<cStartS<<"); ";
//	}
//	int assSP = seg[idVeh].Trip[1].assSP;
//	bool stop, vioTWSPTRUE;
//	preID = i; nextID = sucj;
//	if (sucj > 0)
//	{
//        varcostj += (problem->c[j][i] + problem->c[i][sucj] - problem->c[j][sucj]); 
//		do
//		{
//			cArrTime = cStartS + problem->c[preID][nextID];
//			cStartS = PDS_MAX(cArrTime, problem->node[nextID].sTW);
//			temp = cStartS - problem->node[nextID].eTW;
//			if (temp > eps)
//			{
//				//cout<<"("<<nextID<<", "<<temp<<"); ";
//				varvioTWCj += (temp - vioTWCus[nextID]);
//				if (vioTWCus[nextID] > eps) return;
//				cStartS = problem->node[nextID].eTW;
//			}
//			else 
//			{
//				//cout<<"("<<nextID<<", 0); ";
//				varvioTWCj -= vioTWCus[nextID];
//			}
//			if (PDSDIF(cStartS, startS[nextID]) == 0) return;
//			cStartS += problem->node[nextID].duration;
//			preID = nextID; nextID = nextArr[nextID];
//		}while (nextID > 0);
//		//cout<<"varvioTWCj = "<<varvioTWCj<<endl;
//		stop = calChangeCONNECTAtSP_PickTrip(preID, idVeh, 1, cStartS, varvioTWSPj, varcostj, vioTWSPTRUE);
//	}
//	else  //lastC changed: j was the last cus; i is now the last cus
//	{
//		varcostj += problem->c[j][i];
//        if (seg[idVeh].Trip[1].waitingS == NO_WS)
//			varcostj -= problem->c[j][assSP];
//		else varcostj -= problem->disCWSSP[j][assSP];
//		stop = calChangeCONNECTAtSP_PickTrip_LastCChanged(i, idVeh, 1, cStartS, varvioTWSPj, varcostj, vioTWSPTRUE);
//	}
//	if (stop) return;
//
//	int lastT = seg[idVeh].numTrips - 1;
//	if (lastT > 1)
//	{
//		int preT = 1; int curT = 2;
//		if (seg[idVeh].Trip[curT].Type == 1) 
//		{
//			int assSP1 = seg[idVeh].Trip[curT].assSP;
//			if (assSP == assSP1) //p-d trip
//			{
//					//varvioTWSP += varvioTWSP1;
//					//cStartS += problem->nodeSP[assSP].load;
//				    //Update 16/11/2013
//					if (vioTWSPTRUE) cStartS = problem->leaveSP[assSP][1]; //load only at eTW2
//					else cStartS += problem->nodeSP[assSP].load;
//					preID = assSP1;
//					nextID = seg[idVeh].Trip[curT].firstCus;
//			}
//			else //p - assSP - assSP1 - d
//			{
//					stop = calChangeCONNECTAtSP_SPSP(idVeh, curT, preT, cStartS, varvioTWSPj, varcostj);
//					if (stop) return;
//					preID = assSP1; nextID = seg[idVeh].Trip[curT].firstCus;
//			}//end p - assSP - assSP1 - d
//		}
//		else //if (seg[idVeh].Trip[curT].Type == 0 || 2): p - p OR p-C2C
//		{
//				preID = assSP;
//				nextID = seg[idVeh].Trip[curT].firstCus;
//		}//end if (seg[idVeh].Trip[curT].Type == 0 || 2)
//	    GoThroughVehicle(idVeh, curT, varcostj, varvioTWCj, varvioTWSPj, cStartS, preID, nextID);
//	}
//}
//
//
//void Solution::Update_deleteCusArrayPORC2C_MiddleTrip_Empty(int idVeh, int idTrip) //update deleteCusD for middle trip (idVeh, idTrip) with only 1 delivery customer
//{
//	//5/12/2013
//	//int assSP = seg[idVeh].Trip[idTrip].assSP;
//	int	deletednode = seg[idVeh].Trip[idTrip].firstCus;
//
//	deleteCus[deletednode]->var_vioCAP = 0;
//	int curC, preC;
//	double varcost, varvioTWC, varvioTWSP, cStartS;
//	int preT = idTrip - 1; int nextT = idTrip + 1;
//	bool stop;
//
//	varvioTWC = -seg[idVeh].Trip[idTrip].vioTWC;
//	varvioTWSP = -seg[idVeh].Trip[idTrip].vioTWSP;
//	varcost = -(seg[idVeh].Trip[idTrip].cost + seg[idVeh].Trip[preT].connectCost);
//	if (seg[idVeh].Trip[preT].Type == 0)
//	{
//		cStartS = seg[idVeh].Trip[preT].leaveSP;
//		if (seg[idVeh].Trip[nextT].Type == 1) // p - assSP - [p - assSP1] - d OR p - assSP - [p - assSP1] - assSP2 - d 
//		{
//			stop = calCONNECTCSPTOSPD_FORDELETE(seg[idVeh].Trip[preT].assSP, idVeh, nextT, cStartS, varvioTWSP, varcost);
//			if (stop) goto Update;
//			preC = seg[idVeh].Trip[nextT].assSP; curC = seg[idVeh].Trip[nextT].firstCus;
//		}
//		else //p - assSP - [p - assSP1] - p - assSP2 OR p - [p] - C2C
//		{
//			preC = seg[idVeh].Trip[preT].assSP;
//			curC = seg[idVeh].Trip[nextT].firstCus;
//			varcost += problem->c[preC][curC];
//		}//end p - assSP - [p - assSP1] - p - assSP2 OR p - [p] - C2C
//	}
//	else //if (seg[idVeh].Trip[preT].Type == 1 || 2)
//	{
//		preC = seg[idVeh].Trip[preT].lastCus; cStartS = depart[preC];
//		if (seg[idVeh].Trip[nextT].Type == 1) // d - [ p ] - d OR C2C - [p] - d
//		{
//			stop = calCONNECTCSPTOSPD_FORDELETE(preC, idVeh, nextT, cStartS, varvioTWSP, varcost);
//			if (stop) goto Update;
//			preC = seg[idVeh].Trip[nextT].assSP; curC = seg[idVeh].Trip[nextT].firstCus;
//		} 
//		else //(d - [p] - p OR d - [p] - C2C) OR (C2C - [p] - p OR C2C-[p]-C2C)
//		{
//			curC = seg[idVeh].Trip[nextT].firstCus;
//			varcost += problem->c[preC][curC];
//		}//end d - [p] - p
//	}//end if (seg[idVeh].Trip[preT].Type == 1 || 2)
//
//	GoThroughVehicle(idVeh, nextT, varcost, varvioTWC, varvioTWSP, cStartS, preC, curC);
//	Update:
//		deleteCus[deletednode]->var_cost = varcost;
//		deleteCus[deletednode]->var_vioTWC = varvioTWC;
//		deleteCus[deletednode]->var_vioTWSP = varvioTWSP;
//		deleteCus[deletednode]->atIT = IT;
//		deleteCus[deletednode]->empty = 0;
//}
//
//bool Solution::cal_deleteCusArrayPORC2C_MiddleTrip_Empty_TillTrip(int idVeh, int idTrip, double &varcost, double &varvioTWC, double &varvioTWSP, double &cStartS, int update_idTrip)
//{
//	//See on 2/12/2013: (idVeh, idTrip) is PTrip OR C2C; 
//	//if PTrip --> trip has only 1 customers --> don't need to cal varvioCAP
//	//if C2CTrip --> trip has only 2 customers --> don't need to cal varvioCAP
// 
//	int curC, preC;
//	int preT = idTrip - 1; int nextT = idTrip + 1;
//	bool stop;
//
//	varvioTWC -= seg[idVeh].Trip[idTrip].vioTWC;
//	varvioTWSP -= seg[idVeh].Trip[idTrip].vioTWSP;
//	varcost -= (seg[idVeh].Trip[idTrip].cost + seg[idVeh].Trip[preT].connectCost);
//	
//	if (seg[idVeh].Trip[preT].Type == 1)
//	{
//		preC = seg[idVeh].Trip[preT].lastCus; cStartS = depart[preC];
//		if (seg[idVeh].Trip[nextT].Type == 1) // d - [ p ] - d OR d - [c2c] - d
//		{
//			stop = calCONNECTCSPTOSPD_FORDELETE(preC, idVeh, nextT, cStartS, varvioTWSP, varcost);
//			if (stop) return 1;
//			preC = seg[idVeh].Trip[nextT].assSP; curC = seg[idVeh].Trip[nextT].firstCus;
//		} 
//		else //d - [p] - p OR d - [p] - C2C       OR d - [c2c] - p OR d - [c2c] - C2C
//		{
//			curC = seg[idVeh].Trip[nextT].firstCus;
//			varcost += problem->c[preC][curC];
//		}//end d - [p] - p OR d - [p] - C2C       OR d - [c2c] - p OR d - [c2c] - C2C
//	}
//	else if (seg[idVeh].Trip[preT].Type == 0)
//	{
//		cStartS = seg[idVeh].Trip[preT].leaveSP;
//		if (seg[idVeh].Trip[nextT].Type == 1) // p - assSP - [p - assSP1] - d OR p - assSP - [p - assSP1] - assSP2 - d 
//		{
//			stop = calCONNECTCSPTOSPD_FORDELETE(seg[idVeh].Trip[preT].assSP, idVeh, nextT, cStartS, varvioTWSP, varcost);
//			if (stop) return 1;
//			preC = seg[idVeh].Trip[nextT].assSP; curC = seg[idVeh].Trip[nextT].firstCus;
//		}
//		else //p - assSP - [p - assSP1] - p - assSP2 OR p - assSP - [p - assSP1] - C2C
//		{
//			preC = seg[idVeh].Trip[preT].assSP;
//			curC = seg[idVeh].Trip[nextT].firstCus;
//			varcost += problem->c[preC][curC];
//		}//end p - assSP - [d] - p OR p - assSP - [p - assSP1] - C2C
//	}//end if (seg[idVeh].Trip[preT].Type==0)
//	else //if (seg[idVeh].Trip[preT].Type == 2)
//	{
//		preC = seg[idVeh].Trip[preT].lastCus;
//		cStartS = depart[preC];
//		if (seg[idVeh].Trip[nextT].Type == 1) // C2C - [p-assSP1] - d OR C2C - [p-assSP1] - assSP2 - d
//		{
//			stop = calCONNECTCSPTOSPD_FORDELETE(preC, idVeh, nextT, cStartS, varvioTWSP, varcost);
//			if (stop) return 1;
//			preC = seg[idVeh].Trip[nextT].assSP; curC = seg[idVeh].Trip[nextT].firstCus;
//		}
//		else //if (seg[idVeh].Trip[nextT].Type == 0 || 2) // C2C - [p-assSP1] - p - assSP OR C2C - [p-assSP1] - C2C
//		{
//			curC = seg[idVeh].Trip[nextT].firstCus;
//			varcost += problem->c[preC][curC];
//		}
//	}
//	//Quangnn+-
//	return 0; //GoThroughVehicle(idVeh, nextT, update_idTrip - nextT + 1, varcost, varvioTWC, varvioTWSP, cStartS, preC, curC);
//}
//
//void Solution::cal_deleteCusArrayPORC2C_MiddleTrip_Empty_FromBeginning(int idVeh, int idTrip, double &varcost, double &varvioTWC, double &varvioTWSP, double cStartS)
//{
//	//See on 2/12/2013
//	//Copy cal_deleteCusArrayP_MiddleTrip_Empty_TillTrip and Update_deleteCusArrayP_MiddleTrip_Empty
//	//Just use cStartS rather than depart[lastC of preT] or leaveSP of preT
//
//	int curC, preC;
//	int preT = idTrip - 1; int nextT = idTrip + 1;
//	bool stop;
//
//	varvioTWC -= seg[idVeh].Trip[idTrip].vioTWC;
//	varvioTWSP -= seg[idVeh].Trip[idTrip].vioTWSP;
//	varcost -= (seg[idVeh].Trip[idTrip].cost + seg[idVeh].Trip[preT].connectCost);
//	
//	if (seg[idVeh].Trip[preT].Type == 0)
//	{
//		//cStartS = seg[idVeh].Trip[preT].leaveSP;
//		if (seg[idVeh].Trip[nextT].Type == 1) // p - assSP - [p - assSP1] - d OR p - assSP - [p - assSP1] - assSP2 - d 
//		{
//			stop = calCONNECTCSPTOSPD_FORDELETE(seg[idVeh].Trip[preT].assSP, idVeh, nextT, cStartS, varvioTWSP, varcost);
//			if (stop) return;
//			preC = seg[idVeh].Trip[nextT].assSP; curC = seg[idVeh].Trip[nextT].firstCus;
//		}
//		else //p - assSP - [p - assSP1] - p - assSP2 OR p - assSP - [p - assSP1] - C2C
//		{
//			preC = seg[idVeh].Trip[preT].assSP;
//			curC = seg[idVeh].Trip[nextT].firstCus;
//			varcost += problem->c[preC][curC];
//		}//end p - assSP - [p - assSP1] - p - assSP2 OR p - assSP - [p - assSP1] - C2C
//	}
//	else //if (seg[idVeh].Trip[preT].Type == 1 || 2)
//	{
//		preC = seg[idVeh].Trip[preT].lastCus; //cStartS = depart[preC];
//		if (seg[idVeh].Trip[nextT].Type == 1) // (d OR C2C) - [ p ] - d
//		{
//			stop = calCONNECTCSPTOSPD_FORDELETE(preC, idVeh, nextT, cStartS, varvioTWSP, varcost);
//			if (stop) return;
//			preC = seg[idVeh].Trip[nextT].assSP; curC = seg[idVeh].Trip[nextT].firstCus;
//		} 
//		else //d - [p] - p OR d - [p] - C2C
//		{
//			curC = seg[idVeh].Trip[nextT].firstCus;
//			varcost += problem->c[preC][curC];
//		}//end d - [p] - p
//	}//end if (seg[idVeh].Trip[preT].Type == 1 || 2)
//	GoThroughVehicle(idVeh, nextT, varcost, varvioTWC, varvioTWSP, cStartS, preC, curC);
//}
//
//void Solution::cal_deleteCusArrayC2C_MiddleTrip_Empty_FromBeginning(int preC, int idVeh, int idTrip, double &varcost, double &varvioTWC, double &varvioTWSP, double cStartS)
//{
//    /*11/12/2013
//    DIFFER FROM cal_deleteCusArrayPORC2C_MiddleTrip_Empty_FromBeginning:
//	previous trip of idTrip is also the C2C trip; and last cus of it has been changed: 
//	--> need to varcost += connect(preC, first of trip (idTripi+1)*/
//	int curC;
//	int preT = idTrip - 1; int nextT = idTrip + 1;
//	bool stop;
//
//	varvioTWC -= seg[idVeh].Trip[idTrip].vioTWC;
//	//varvioTWSP -= seg[idVeh].Trip[idTrip].vioTWSP;
//	varcost -= seg[idVeh].Trip[idTrip].cost; //don't need seg[idVeh].Trip[preT].connectCost because it has been already substracted from previous procedure that call this procedure
//	//varcost -= (seg[idVeh].Trip[idTrip].cost + seg[idVeh].Trip[preT].connectCost);
//	
//	if (seg[idVeh].Trip[nextT].Type == 1) // (d OR C2C) - [ p ] - d
//	{
//		stop = calCONNECTCSPTOSPD_FORDELETE(preC, idVeh, nextT, cStartS, varvioTWSP, varcost);
//		if (stop) return;
//		preC = seg[idVeh].Trip[nextT].assSP; curC = seg[idVeh].Trip[nextT].firstCus;
//	} 
//	else //d - [p] - p OR d - [p] - C2C
//	{
//		curC = seg[idVeh].Trip[nextT].firstCus;
//		varcost += problem->c[preC][curC];
//	}//end d - [p] - p
//	GoThroughVehicle(idVeh, nextT, varcost, varvioTWC, varvioTWSP, cStartS, preC, curC);
//}
//
//
//
//
//void Solution::cal_deleteCusArrayP_LastTrip(int idVeh, int idTrip, int deletednode, double &varcost, double &varvioTWC, double &varvioTWSP, int &varvioCAP)
//{
//	//See on 2/12/2013
//        //COPY: Update_deleteCusArrayP_LastTrip
//		int vioCapNEW = PDS_MAX(seg[idVeh].Trip[idTrip].capacity - problem->node[deletednode].capacity- problem->Q,0);
//		varvioCAP += (vioCapNEW - seg[idVeh].Trip[idTrip].vioCAP);
//		int pre = predArr[deletednode]; int suc = nextArr[deletednode];
//		int preID, nextID;
//		double cStartS, cArrTime,temp, cArrTimeI;
//
//		int assSP = seg[idVeh].Trip[idTrip].assSP;
//		if (pre < 0)
//		{
//			int preT = idTrip - 1; 
//			if (seg[idVeh].Trip[preT].Type == 0) 
//			{
//				preID = seg[idVeh].Trip[preT].assSP;
//				cStartS = seg[idVeh].Trip[preT].leaveSP;
//			}
//			else //seg[idVeh].Trip[preT].Type == 1 || 2
//			{
//				preID = seg[idVeh].Trip[preT].lastCus;
//				cStartS = depart[preID];
//			}	
//		}
//		else
//		{
//			preID = pre;
//			cStartS = depart[preID];
//		}
//		nextID = suc;
//		varvioTWC -= vioTWCus[deletednode]; //Update 7/11/2013
//		if (deletednode != seg[idVeh].Trip[idTrip].lastCus)
//		{
//			//1. Delete the first and middle pickup customers of last trip:
//			varcost += (problem->c[preID][nextID] - (problem->c[preID][deletednode] + problem->c[deletednode][nextID]));
//			do
//			{
//				cArrTime = cStartS + problem->c[preID][nextID];
//				cStartS = PDS_MAX(cArrTime, problem->node[nextID].sTW);
//				temp = cStartS - problem->node[nextID].eTW;
//				if (temp > eps)
//				{
//					varvioTWC += (temp - vioTWCus[nextID]);
//					if (vioTWCus[nextID] > eps) return;
//					cStartS = problem->node[nextID].depart;
//				}
//				else 
//				{
//					varvioTWC -= vioTWCus[nextID];
//					if (PDSDIF(cStartS, startS[nextID])== 0) return;
//					cStartS += problem->node[nextID].duration;
//				}
//				preID = nextID; nextID = nextArr[nextID];
//			} while (nextID > 0);
//			calChangeCONNECTAtSP_PickTrip2(preID, idVeh, idTrip, cStartS, varvioTWSP, varcost); //dont need to check the case p-dSAMESP
//		}
//		else //delete the last cus of last trip
//		{
//			//2. Delete the last pickup customer:
//			varvioTWSP -= seg[idVeh].Trip[idTrip].vioTWSP;
//			cArrTime = depart[preID] + problem->c[preID][assSP];
//			if (PDSINRANGE(cArrTime, problem->nodeSP[assSP].sTW1, problem->nodeSP[assSP].eTW1))
//			{
//				//before deletion has to go to sp directly: FEA OR INFEA: NOT ALWAYS Update 7/11/2013
//				if (seg[idVeh].Trip[idTrip].waitingS == NO_WS)
//					varcost += (problem->c[preID][assSP] - (problem->c[preID][deletednode] + problem->c[deletednode][assSP]));
//				else 
//					varcost += (problem->c[preID][assSP] - (problem->c[preID][deletednode] + problem->disCWSSP[deletednode][assSP]));
//			}
//			else
//			{
//					temp = cArrTime - problem->nodeSP[assSP].eTW1;
//					if (temp > eps)
//					{
//						//before deletion has to go to sp directly: INFEA NOT ALWAYS: Update 7/11/2013
//						varvioTWSP += temp;
//						if (seg[idVeh].Trip[idTrip].waitingS == NO_WS)
//							varcost += (problem->c[preID][assSP] - (problem->c[preID][deletednode] + problem->c[deletednode][assSP]));
//						else 
//							varcost += (problem->c[preID][assSP] - (problem->c[preID][deletednode] + problem->disCWSSP[deletednode][assSP]));
//					}
//					else
//					{
//						cArrTimeI = depart[preID] + problem->disCWSSP[preID][assSP];
//						temp = cArrTimeI - problem->nodeSP[assSP].eTW1;
//						if (temp > eps) //too soon to go sp directly, too late to go through WS:
//						{
//							varvioTWSP += (problem->nodeSP[assSP].sTW1 - cArrTime);
//							//before deletion has to go to sp directly: FEA OR INFEA NOT ALWAYS Update 7/11/2013
//							if (seg[idVeh].Trip[idTrip].waitingS == NO_WS)
//								varcost += (problem->c[preID][assSP] - (problem->c[preID][deletednode] + problem->c[deletednode][assSP]));
//							else 
//								varcost += (problem->c[preID][assSP] - (problem->c[preID][deletednode] + problem->disCWSSP[deletednode][assSP]));
//						}
//						else //to go through WS
//						{
//							//before deletion may go to sp directly or through WS:
//							if (seg[idVeh].Trip[idTrip].waitingS == NO_WS)
//								varcost += (problem->disCWSSP[preID][assSP] - (problem->c[preID][deletednode] + problem->c[deletednode][assSP]));
//							else 
//								varcost += (problem->disCWSSP[preID][assSP] - (problem->c[preID][deletednode] + problem->disCWSSP[deletednode][assSP]));
//						}
//					}
//			}
//		}//end delete the last cus of last trip
//}
//
//
//
//
//void Solution::cal_deleteCusArrayP_LastTrip_FromBeginning(int idVeh, int idTrip, int deletednode, double &varcost, double &varvioTWC, double &varvioTWSP, int &varvioCAP, double cStartS)
//{
//	//see on 2/12/2013
//        //COPY: Update_deleteCusArrayP_LastTrip and cal_deleteCusArrayP_LastTrip
//		int vioCapNEW = PDS_MAX(seg[idVeh].Trip[idTrip].capacity - problem->node[deletednode].capacity- problem->Q,0);
//		varvioCAP += (vioCapNEW - seg[idVeh].Trip[idTrip].vioCAP);
//		int pre = predArr[deletednode]; int suc = nextArr[deletednode];
//		int preID, nextID, pre1;
//		double cArrTime,temp, cArrTimeI;
//
//		int assSP = seg[idVeh].Trip[idTrip].assSP;
//
//		int preT = idTrip - 1; 
//		if (seg[idVeh].Trip[preT].Type == 0) 
//			preID = seg[idVeh].Trip[preT].assSP;
//		else 
//			preID = seg[idVeh].Trip[preT].lastCus;
//
//		pre1 = preID;
//		nextID = seg[idVeh].Trip[idTrip].firstCus;
//
//		//checking from first cus to pre
//		while (nextID != deletednode)
//		{
//			  cArrTime = cStartS + problem->c[preID][nextID]; //Arrive Time to Customer nextID
//			  temp = cArrTime - problem->node[nextID].eTW;
//			  if (temp > eps)
//			  {
//				  if (vioTWCus[nextID] > eps)
//				  {
//					  varvioTWC += (temp - vioTWCus[nextID]);
//					  preID = pre;
//					  cStartS = depart[pre];
//					  break;
//				  }
//				  varvioTWC += temp;
//				  cStartS = problem->node[nextID].depart;
//			  }
//			  else
//			  {
//				  varvioTWC -= vioTWCus[nextID]; //Update 15/11/2013
//				  cStartS = PDS_MAX(cArrTime, problem->node[nextID].sTW) + problem->node[nextID].duration;
//			  }
//			  preID = nextID; nextID = nextArr[nextID];
//		}//end while (nextID != deletednode)
//
//		//preID now points to predArr[deletednode] and nextID points to deletednode
//		nextID = suc;
//		varvioTWC -= vioTWCus[deletednode]; //Update 7/11/2013
//		if (suc > 0)
//		{
//			if (pre > 0)
//			   varcost += (problem->c[pre][suc] - (problem->c[pre][deletednode] + problem->c[deletednode][suc]));
//			else
//			   varcost += (problem->c[pre1][suc] - (problem->c[pre1][deletednode] + problem->c[deletednode][suc]));
//			do
//			{
//				  cArrTime = cStartS + problem->c[preID][nextID]; //Arrive Time to Customer nextC
//				  temp = cArrTime - problem->node[nextID].eTW;
//				  if (temp > eps)
//				  {
//					  varvioTWC += (temp - vioTWCus[nextID]);
//					  if (vioTWCus[nextID] > eps) return;
//					  cStartS = problem->node[nextID].depart;
//				  }
//				  else
//				  {
//					  varvioTWC -= vioTWCus[nextID]; //Update 15/11/2013
//					  cStartS = PDS_MAX(cArrTime, problem->node[nextID].sTW) + problem->node[nextID].duration;
//				  }
//				  preID = nextID; nextID = nextArr[nextID];
//			}while (nextID > 0);
//			calChangeCONNECTAtSP_PickTrip2(preID, idVeh, idTrip, cStartS, varvioTWSP, varcost); //dont need to check the case p-d-samesp
//		}
//		else //delete the last cus of last trip
//		{
//			//2. Delete the last pickup customer:
//			varvioTWSP -= seg[idVeh].Trip[idTrip].vioTWSP;
//			cArrTime = cStartS + problem->c[preID][assSP];
//			if (PDSINRANGE(cArrTime, problem->nodeSP[assSP].sTW1, problem->nodeSP[assSP].eTW1))
//			{
//				//before deletion has to go to sp directly: FEA OR INFEA: NOT ALWAYS Update 7/11/2013
//				if (seg[idVeh].Trip[idTrip].waitingS == NO_WS)
//					varcost += (problem->c[preID][assSP] - (problem->c[preID][deletednode] + problem->c[deletednode][assSP]));
//				else 
//					varcost += (problem->c[preID][assSP] - (problem->c[preID][deletednode] + problem->disCWSSP[deletednode][assSP]));
//			}
//			else
//			{
//					temp = cArrTime - problem->nodeSP[assSP].eTW1;
//					if (temp > eps)
//					{
//						//before deletion has to go to sp directly: INFEA NOT ALWAYS: Update 7/11/2013
//						varvioTWSP += temp;
//						if (seg[idVeh].Trip[idTrip].waitingS == NO_WS)
//							varcost += (problem->c[preID][assSP] - (problem->c[preID][deletednode] + problem->c[deletednode][assSP]));
//						else 
//							varcost += (problem->c[preID][assSP] - (problem->c[preID][deletednode] + problem->disCWSSP[deletednode][assSP]));
//					}
//					else
//					{
//						cArrTimeI = cStartS + problem->disCWSSP[preID][assSP];
//						temp = cArrTimeI - problem->nodeSP[assSP].eTW1;
//						if (temp > eps) //too soon to go sp directly, too late to go through WS:
//						{
//							varvioTWSP += (problem->nodeSP[assSP].sTW1 - cArrTime);
//							//before deletion has to go to sp directly: FEA OR INFEA NOT ALWAYS Update 7/11/2013
//							if (seg[idVeh].Trip[idTrip].waitingS == NO_WS)
//								varcost += (problem->c[preID][assSP] - (problem->c[preID][deletednode] + problem->c[deletednode][assSP]));
//							else 
//								varcost += (problem->c[preID][assSP] - (problem->c[preID][deletednode] + problem->disCWSSP[deletednode][assSP]));
//						}
//						else //to go through WS
//						{
//							//before deletion may go to sp directly or through WS:
//							if (seg[idVeh].Trip[idTrip].waitingS == NO_WS)
//								varcost += (problem->disCWSSP[preID][assSP] - (problem->c[preID][deletednode] + problem->c[deletednode][assSP]));
//							else 
//								varcost += (problem->disCWSSP[preID][assSP] - (problem->c[preID][deletednode] + problem->disCWSSP[deletednode][assSP]));
//						}
//					}
//			}
//		}//end delete the last cus of last trip
//}
//
//void Solution::Update_deleteCusArrayP_LastTrip_Empty(int idVeh, int idTrip)
//{
//	//see on 2/12/2013
//	int	deletednode = seg[idVeh].Trip[idTrip].firstCus;
//	int preT = idTrip - 1;
//	deleteCus[deletednode]->var_vioCAP = 0;
//	deleteCus[deletednode]->var_vioTWC = -seg[idVeh].Trip[idTrip].vioTWC;
//	deleteCus[deletednode]->var_vioTWSP = -seg[idVeh].Trip[idTrip].vioTWSP;
//
//	double varcost = -(seg[idVeh].Trip[preT].connectCost + seg[idVeh].Trip[idTrip].cost);
//	if (seg[idVeh].Trip[preT].Type == 0) 
//		varcost += problem->c[seg[idVeh].Trip[preT].assSP][0];
//	else
//		varcost += problem->c[seg[idVeh].Trip[preT].lastCus][0];
//	deleteCus[deletednode]->var_cost = varcost;
//	deleteCus[deletednode]->atIT = IT;
//	deleteCus[deletednode]->empty = 0;
//}
//
//void Solution::cal_deleteCusArrayPORC2C_LastTrip_Empty(int idVeh, int idTrip, double &varcost, double &varvioTWC, double &varvioTWSP)
//{
//	//See on 2/12/2013
//	//COPY Update_deleteCusArrayP_LastTrip_Empty
//	int preT = idTrip - 1;
//	varvioTWC -= seg[idVeh].Trip[idTrip].vioTWC;
//	varvioTWSP -= seg[idVeh].Trip[idTrip].vioTWSP;
//
//	varcost -= (seg[idVeh].Trip[preT].connectCost + seg[idVeh].Trip[idTrip].cost);
//	if (seg[idVeh].Trip[preT].Type == 0) 
//		varcost += problem->c[seg[idVeh].Trip[preT].assSP][0];
//	else
//		varcost += problem->c[seg[idVeh].Trip[preT].lastCus][0];
//}
//
//
//void Solution::Update_deleteCusP_FirstTrip_2Cus(int idVeh) //first pickup cus with only 2 customers:
//{
//	//See on 2/12/2013
//	double varcost, varvioTWC, varvioTWSP, cStartS;
//	int vioCapNEW;
//
//	int deletednode;
//	int assSP = seg[idVeh].Trip[0].assSP;
//	deletednode = seg[idVeh].Trip[0].firstCus;
//    int lastC = nextArr[deletednode];
//
//	int capOLD = seg[idVeh].Trip[0].capacity;
//	int vioCapOLD = seg[idVeh].Trip[0].vioCAP;
//
//	int firstC_nextT = seg[idVeh].Trip[1].firstCus;
//
//	if (seg[idVeh].Trip[1].Type == 1)
//	{
//		int assSP1 = seg[idVeh].Trip[1].assSP;
//		if (assSP1 == assSP) // p -assSP - d
//		{
//			//1. Delete the first cus:
//			varvioTWC = -seg[idVeh].Trip[0].vioTWC;
//			varvioTWSP = -2*seg[idVeh].Trip[0].vioTWSP;
//			varcost = problem->c[0][lastC] - (problem->c[0][deletednode] + problem->c[deletednode][lastC]);
//			if (problem->waitingSOneP[lastC][assSP]) //now go to WS:
//			{
//                //cStartS = PDS_MAX(problem->startSOneP[lastC][assSP] + problem->node[lastC].duration + problem->disCWSSP[lastC][assSP], problem->nodeSP[assSP].sTW1);
//				if (seg[idVeh].Trip[0].waitingS == NO_WS)
//					varcost += (problem->disCWSSP[lastC][assSP] - problem->c[lastC][assSP]);
//			}
//			else
//			{
//                //cStartS = problem->startSOneP[lastC][assSP] + problem->node[lastC].duration + problem->c[lastC][assSP];
//				if (seg[idVeh].Trip[0].waitingS != NO_WS)
//					varcost += (problem->c[lastC][assSP] - problem->disCWSSP[lastC][assSP]);
//			}
//			//cStartS += (problem->nodeSP[assSP].unload + problem->nodeSP[assSP1].load);
//			cStartS = problem->leaveSPOneP[lastC][assSP] + problem->nodeSP[assSP1].load;
//			GoThroughVehicle(idVeh, 1, varcost, varvioTWC, varvioTWSP, cStartS, assSP1, firstC_nextT);
//
//			deleteCus[deletednode]->var_cost = varcost;
//			deleteCus[deletednode]->var_vioTWSP = varvioTWSP;
//			deleteCus[deletednode]->var_vioTWC = varvioTWC;
//			vioCapNEW = PDS_MAX(capOLD - problem->node[deletednode].capacity- problem->Q,0);
//			deleteCus[deletednode]->var_vioCAP = vioCapNEW - vioCapOLD;
//			deleteCus[deletednode]->atIT = IT;
//			deleteCus[deletednode]->empty = 0;
//
//			//2. Delete the last pickup customer:
//			deletednode = lastC;
//			lastC = seg[idVeh].Trip[0].firstCus;
//		
//			varvioTWC = -seg[idVeh].Trip[0].vioTWC;
//			varvioTWSP = -2*seg[idVeh].Trip[0].vioTWSP;
//			varcost = -problem->c[lastC][deletednode];
//			if (seg[idVeh].Trip[0].waitingS == NO_WS) varcost -= problem->c[deletednode][assSP];
//			else varcost -= problem->disCWSSP[deletednode][assSP];
//
//			if (problem->waitingSOneP[lastC][assSP]) //now go to WS:
//			{
//                //cStartS = PDS_MAX(problem->startSOneP[lastC][assSP] + problem->node[lastC].duration + problem->disCWSSP[lastC][assSP], problem->nodeSP[assSP].sTW1);
//			    varcost += problem->disCWSSP[lastC][assSP];
//			}
//			else
//			{
//                //cStartS = problem->startSOneP[lastC][assSP] + problem->node[lastC].duration + problem->c[lastC][assSP];
//			    varcost += problem->c[lastC][assSP];
//			}
//					
//			//cStartS += (problem->nodeSP[assSP].unload + problem->nodeSP[assSP].load);
//			cStartS = problem->leaveSPOneP[lastC][assSP] + problem->nodeSP[assSP].load;
//			GoThroughVehicle(idVeh, 1, varcost, varvioTWC, varvioTWSP, cStartS, assSP1, firstC_nextT);
//		
//			deleteCus[deletednode]->var_cost = varcost;
//			deleteCus[deletednode]->var_vioTWC = varvioTWC;
//			deleteCus[deletednode]->var_vioTWSP = varvioTWSP;
//			vioCapNEW = PDS_MAX(capOLD - problem->node[deletednode].capacity- problem->Q,0);
//			deleteCus[deletednode]->var_vioCAP = vioCapNEW - vioCapOLD;
//			deleteCus[deletednode]->atIT = IT;
//			deleteCus[deletednode]->empty = 0;
//		}
//		else // p - assSP - assSP1 - d
//		{
//			//1. Delete the first cus:
//			varvioTWC = -seg[idVeh].Trip[0].vioTWC;
//			varvioTWSP = -seg[idVeh].Trip[0].vioTWSP;
//			varcost = problem->c[0][lastC] - (problem->c[0][deletednode] + problem->c[deletednode][lastC]);
//			if (problem->waitingSOneP[lastC][assSP]) //now go to WS:
//			{
//                //cStartS = PDS_MAX(problem->startSOneP[lastC][assSP] + problem->node[lastC].duration + problem->disCWSSP[lastC][assSP], problem->nodeSP[assSP].sTW1);
//				if (seg[idVeh].Trip[0].waitingS == NO_WS)
//					varcost += (problem->disCWSSP[lastC][assSP] - problem->c[lastC][assSP]);
//			}
//			else
//			{
//                //cStartS = problem->startSOneP[lastC][assSP] + problem->node[lastC].duration + problem->c[lastC][assSP];
//				if (seg[idVeh].Trip[0].waitingS != NO_WS)
//					varcost += (problem->c[lastC][assSP] - problem->disCWSSP[lastC][assSP]);
//			}
//			//cStartS += problem->nodeSP[assSP].unload;
//			cStartS = problem->leaveSPOneP[lastC][assSP];
//			if (calChangeCONNECTAtSP_SPSP(idVeh, 1, 0, cStartS, varvioTWSP, varcost) == 0)
//			   GoThroughVehicle(idVeh, 1, varcost, varvioTWC, varvioTWSP, cStartS, assSP1, firstC_nextT);
//
//			deleteCus[deletednode]->var_cost = varcost;
//			deleteCus[deletednode]->var_vioTWSP = varvioTWSP;
//			deleteCus[deletednode]->var_vioTWC = varvioTWC;
//			vioCapNEW = PDS_MAX(capOLD - problem->node[deletednode].capacity- problem->Q,0);
//			deleteCus[deletednode]->var_vioCAP = vioCapNEW - vioCapOLD;
//			deleteCus[deletednode]->atIT = IT;
//			deleteCus[deletednode]->empty = 0;
//			
//			//2. Delete the last pickup customer:
//			deletednode = lastC;
//			lastC = seg[idVeh].Trip[0].firstCus;
//		
//			varvioTWC = -seg[idVeh].Trip[0].vioTWC;
//			varvioTWSP = -seg[idVeh].Trip[0].vioTWSP;
//			varcost = -problem->c[lastC][deletednode];
//			if (seg[idVeh].Trip[0].waitingS == NO_WS) varcost -= problem->c[deletednode][assSP];
//			else varcost -= problem->disCWSSP[deletednode][assSP];
//
//			if (problem->waitingSOneP[lastC][assSP]) //now go to WS:
//			{
//                //cStartS = PDS_MAX(problem->startSOneP[lastC][assSP] + problem->node[lastC].duration + problem->disCWSSP[lastC][assSP], problem->nodeSP[assSP].sTW1);
//			    varcost += problem->disCWSSP[lastC][assSP];
//			}
//			else
//			{
//                //cStartS = problem->startSOneP[lastC][assSP] + problem->node[lastC].duration + problem->c[lastC][assSP];
//			    varcost += problem->c[lastC][assSP];
//			}
//					
//			//cStartS += problem->nodeSP[assSP].unload;
//			cStartS = problem->leaveSPOneP[lastC][assSP];
//			if (calChangeCONNECTAtSP_SPSP(idVeh, 1, 0, cStartS, varvioTWSP, varcost) == 0)
//			    GoThroughVehicle(idVeh, 1, varcost, varvioTWC, varvioTWSP, cStartS, assSP1, firstC_nextT);
//			deleteCus[deletednode]->var_cost = varcost;
//			deleteCus[deletednode]->var_vioTWC = varvioTWC;
//			deleteCus[deletednode]->var_vioTWSP = varvioTWSP;
//			deleteCus[deletednode]->atIT = IT;
//			deleteCus[deletednode]->empty = 0;
//			vioCapNEW = PDS_MAX(capOLD - problem->node[deletednode].capacity- problem->Q,0);
//			deleteCus[deletednode]->var_vioCAP = vioCapNEW - vioCapOLD;
//		}//end p - assSP - assSP1 - d
//	}
//	else //if (seg[idVeh].Trip[nextT].Type == 0 || 2)
//	{
//			//1. Delete the first cus:
//			varvioTWC = -seg[idVeh].Trip[0].vioTWC;
//			varvioTWSP = -seg[idVeh].Trip[0].vioTWSP;
//			varcost = problem->c[0][lastC] - (problem->c[0][deletednode] + problem->c[deletednode][lastC]);
//			if (problem->waitingSOneP[lastC][assSP]) //now go to WS:
//			{
//                //cStartS = PDS_MAX(problem->startSOneP[lastC][assSP] + problem->node[lastC].duration + problem->disCWSSP[lastC][assSP], problem->nodeSP[assSP].sTW1);
//				if (seg[idVeh].Trip[0].waitingS == NO_WS)
//					varcost += (problem->disCWSSP[lastC][assSP] - problem->c[lastC][assSP]);
//			}
//			else
//			{
//                //cStartS = problem->startSOneP[lastC][assSP] + problem->node[lastC].duration + problem->c[lastC][assSP];
//				if (seg[idVeh].Trip[0].waitingS != NO_WS)
//					varcost += (problem->c[lastC][assSP] - problem->disCWSSP[lastC][assSP]);
//			}
//			//cStartS += problem->nodeSP[assSP].unload;
//			cStartS = problem->leaveSPOneP[lastC][assSP];
//			GoThroughVehicle(idVeh, 1, varcost, varvioTWC, varvioTWSP, cStartS, assSP, firstC_nextT);
//
//			deleteCus[deletednode]->var_cost = varcost;
//			deleteCus[deletednode]->var_vioTWSP = varvioTWSP;
//			deleteCus[deletednode]->var_vioTWC = varvioTWC;
//			vioCapNEW = PDS_MAX(capOLD - problem->node[deletednode].capacity- problem->Q,0);
//			deleteCus[deletednode]->var_vioCAP = vioCapNEW - vioCapOLD;
//			deleteCus[deletednode]->atIT = IT;
//			deleteCus[deletednode]->empty = 0;
//
//			//2. Delete the last pickup customer:
//			deletednode = lastC;
//			lastC = seg[idVeh].Trip[0].firstCus;
//		
//			varvioTWC = -seg[idVeh].Trip[0].vioTWC;
//			varvioTWSP = -seg[idVeh].Trip[0].vioTWSP;
//			varcost = -problem->c[lastC][deletednode];
//			if (seg[idVeh].Trip[0].waitingS == NO_WS) varcost -= problem->c[deletednode][assSP];
//			else varcost -= problem->disCWSSP[deletednode][assSP];
//
//			if (problem->waitingSOneP[lastC][assSP]) //now go to WS:
//			{
//                //cStartS = PDS_MAX(problem->startSOneP[lastC][assSP] + problem->node[lastC].duration + problem->disCWSSP[lastC][assSP], problem->nodeSP[assSP].sTW1);
//			    varcost += problem->disCWSSP[lastC][assSP];
//			}
//			else
//			{
//                //cStartS = problem->startSOneP[lastC][assSP] + problem->node[lastC].duration + problem->c[lastC][assSP];
//			    varcost += problem->c[lastC][assSP];
//			}
//					
//			//cStartS += problem->nodeSP[assSP].unload;
//		    cStartS = problem->leaveSPOneP[lastC][assSP];
//			GoThroughVehicle(idVeh, 1, varcost, varvioTWC, varvioTWSP, cStartS, assSP, firstC_nextT);
//
//			deleteCus[deletednode]->var_cost = varcost;
//			deleteCus[deletednode]->var_vioTWC = varvioTWC;
//			deleteCus[deletednode]->var_vioTWSP = varvioTWSP;
//			deleteCus[deletednode]->atIT = IT;
//			deleteCus[deletednode]->empty = 0;
//			vioCapNEW = PDS_MAX(capOLD - problem->node[deletednode].capacity- problem->Q,0);
//			deleteCus[deletednode]->var_vioCAP = vioCapNEW - vioCapOLD;
//	}//end if (seg[idVeh].Trip[nextT].Type == 0 || 2)
//}
//
//
//bool Solution::cal_deleteCusP_FirstTrip_2Cus_TillTrip(int idVeh, int deletednode, double &varcost, double &varvioTWC, double &varvioTWSP,int &varvioCAP, double &cStartS, int update_idTrip)
//{
//	//See on 2/12/2013
//	int assSP = seg[idVeh].Trip[0].assSP;
//
//	int vioCapNEW = PDS_MAX(seg[idVeh].Trip[0].capacity - problem->node[deletednode].capacity- problem->Q,0);
//	varvioCAP += (vioCapNEW - seg[idVeh].Trip[0].vioCAP);
//
//
//	int firstC_nextT = seg[idVeh].Trip[1].firstCus;
//
//	if (seg[idVeh].Trip[1].Type == 1)
//	{
//		int assSP1 = seg[idVeh].Trip[1].assSP;
//		if (assSP1 == assSP) // p -assSP - d
//		{
//			//1. Delete the first cus:
//			if (deletednode == seg[idVeh].Trip[0].firstCus)
//			{
//				int lastC = seg[idVeh].Trip[0].lastCus;
//				varcost += (problem->c[0][lastC] - (problem->c[0][deletednode] + problem->c[deletednode][lastC]));
//				if (problem->waitingSOneP[lastC][assSP]) //now go to WS:
//				{
//					//cStartS = PDS_MAX(problem->startSOneP[lastC][assSP] + problem->node[lastC].duration + problem->disCWSSP[lastC][assSP], problem->nodeSP[assSP].sTW1);
//					if (seg[idVeh].Trip[0].waitingS == NO_WS)
//						varcost += (problem->disCWSSP[lastC][assSP] - problem->c[lastC][assSP]);
//				}
//				else
//				{
//					//cStartS = problem->startSOneP[lastC][assSP] + problem->node[lastC].duration + problem->c[lastC][assSP];
//					if (seg[idVeh].Trip[0].waitingS != NO_WS)
//						varcost += (problem->c[lastC][assSP] - problem->disCWSSP[lastC][assSP]);
//				}
//				cStartS = problem->leaveSPOneP[lastC][assSP];
//			}
//			else //2. Delete the last pickup customer:
//			{
//				int lastC = seg[idVeh].Trip[0].firstCus;
//				varcost -= problem->c[lastC][deletednode];
//				if (seg[idVeh].Trip[0].waitingS == NO_WS) varcost -= problem->c[deletednode][assSP];
//				else varcost -= problem->disCWSSP[deletednode][assSP];
//
//				if (problem->waitingSOneP[lastC][assSP]) //now go to WS:
//				{
//					//cStartS = PDS_MAX(problem->startSOneP[lastC][assSP] + problem->node[lastC].duration + problem->disCWSSP[lastC][assSP], problem->nodeSP[assSP].sTW1);
//					varcost += problem->disCWSSP[lastC][assSP];
//				}
//				else
//				{
//					//cStartS = problem->startSOneP[lastC][assSP] + problem->node[lastC].duration + problem->c[lastC][assSP];
//					varcost += problem->c[lastC][assSP];
//				}
//				cStartS = problem->leaveSPOneP[lastC][assSP];
//			}
//			varvioTWC -= seg[idVeh].Trip[0].vioTWC;
//			varvioTWSP -= (2*seg[idVeh].Trip[0].vioTWSP);
//
//			//cStartS += (problem->nodeSP[assSP].unload + problem->nodeSP[assSP].load); //it's fine because first pickup trip after delete has only 1 customer --> don't vioTWSP
//			cStartS += problem->nodeSP[assSP].load;//it's fine because first pickup trip after delete has only 1 customer --> don't vioTWSP
//			//Quangnn+-
//			return 0;//GoThroughVehicle(idVeh, 1, update_idTrip, varcost, varvioTWC, varvioTWSP, cStartS, assSP1, firstC_nextT);
//		}
//		else // p - assSP - assSP1 - d
//		{
//			varvioTWC -= seg[idVeh].Trip[0].vioTWC;
//			varvioTWSP -= seg[idVeh].Trip[0].vioTWSP;
//			if (deletednode == seg[idVeh].Trip[0].firstCus)
//			{
//				//1. Delete the first cus:
//				int lastC = seg[idVeh].Trip[0].lastCus;
//				varcost += (problem->c[0][lastC] - (problem->c[0][deletednode] + problem->c[deletednode][lastC]));
//				if (problem->waitingSOneP[lastC][assSP]) //now go to WS:
//				{
//					//cStartS = PDS_MAX(problem->startSOneP[lastC][assSP] + problem->node[lastC].duration + problem->disCWSSP[lastC][assSP], problem->nodeSP[assSP].sTW1);
//					if (seg[idVeh].Trip[0].waitingS == NO_WS)
//						varcost += (problem->disCWSSP[lastC][assSP] - problem->c[lastC][assSP]);
//				}
//				else
//				{
//					//cStartS = problem->startSOneP[lastC][assSP] + problem->node[lastC].duration + problem->c[lastC][assSP];
//					if (seg[idVeh].Trip[0].waitingS != NO_WS)
//						varcost += (problem->c[lastC][assSP] - problem->disCWSSP[lastC][assSP]);
//				}
//				cStartS = problem->leaveSPOneP[lastC][assSP];
//			}
//			else
//			{
//				//2. Delete the last pickup customer:
//				int lastC = seg[idVeh].Trip[0].firstCus;
//				varcost -= problem->c[lastC][deletednode];
//				if (seg[idVeh].Trip[0].waitingS == NO_WS) varcost -= problem->c[deletednode][assSP];
//				else varcost -= problem->disCWSSP[deletednode][assSP];
//
//				if (problem->waitingSOneP[lastC][assSP]) //now go to WS:
//				{
//					//cStartS = PDS_MAX(problem->startSOneP[lastC][assSP] + problem->node[lastC].duration + problem->disCWSSP[lastC][assSP], problem->nodeSP[assSP].sTW1);
//					varcost += problem->disCWSSP[lastC][assSP];
//				}
//				else
//				{
//					//cStartS = problem->startSOneP[lastC][assSP] + problem->node[lastC].duration + problem->c[lastC][assSP];
//					varcost += problem->c[lastC][assSP];
//				}
//				cStartS = problem->leaveSPOneP[lastC][assSP];
//			}
//			//cStartS += problem->nodeSP[assSP].unload;
//			if (calChangeCONNECTAtSP_SPSP(idVeh, 1, 0, cStartS, varvioTWSP, varcost) == 0){
//				//Quangnn+-
//				return 0;//GoThroughVehicle(idVeh, 1, update_idTrip, varcost, varvioTWC, varvioTWSP, cStartS, assSP1, firstC_nextT);
//			}
//			else return 1;
//		}//end p - assSP - assSP1 - d
//	}
//	else //if (seg[idVeh].Trip[nextT].Type == 0 || 2)
//	{
//		  varvioTWC -= seg[idVeh].Trip[0].vioTWC;
//		  varvioTWSP -= seg[idVeh].Trip[0].vioTWSP;
//		  if (deletednode == seg[idVeh].Trip[0].firstCus)
//		  {
//				//1. Delete the first cus:
//  				int lastC = seg[idVeh].Trip[0].lastCus;
//				varcost += (problem->c[0][lastC] - (problem->c[0][deletednode] + problem->c[deletednode][lastC]));
//				if (problem->waitingSOneP[lastC][assSP]) //now go to WS:
//				{
//					//cStartS = PDS_MAX(problem->startSOneP[lastC][assSP] + problem->node[lastC].duration + problem->disCWSSP[lastC][assSP], problem->nodeSP[assSP].sTW1);
//					if (seg[idVeh].Trip[0].waitingS == NO_WS)
//						varcost += (problem->disCWSSP[lastC][assSP] - problem->c[lastC][assSP]);
//				}
//				else
//				{
//					//cStartS = problem->startSOneP[lastC][assSP] + problem->node[lastC].duration + problem->c[lastC][assSP];
//					if (seg[idVeh].Trip[0].waitingS != NO_WS)
//						varcost += (problem->c[lastC][assSP] - problem->disCWSSP[lastC][assSP]);
//				}
//				cStartS = problem->leaveSPOneP[lastC][assSP];
//		  }
//		  else
//		  {
//				//2. Delete the last pickup customer:
//				int lastC = seg[idVeh].Trip[0].firstCus;
//				varcost -= problem->c[lastC][deletednode];
//				if (seg[idVeh].Trip[0].waitingS == NO_WS) varcost -= problem->c[deletednode][assSP];
//				else varcost -= problem->disCWSSP[deletednode][assSP];
//
//				if (problem->waitingSOneP[lastC][assSP]) //now go to WS:
//				{
//					//cStartS = PDS_MAX(problem->startSOneP[lastC][assSP] + problem->node[lastC].duration + problem->disCWSSP[lastC][assSP], problem->nodeSP[assSP].sTW1);
//					varcost += problem->disCWSSP[lastC][assSP];
//				}
//				else
//				{
//					//cStartS = problem->startSOneP[lastC][assSP] + problem->node[lastC].duration + problem->c[lastC][assSP];
//					varcost += problem->c[lastC][assSP];
//				}
//				cStartS = problem->leaveSPOneP[lastC][assSP];
//		  }
//		  //cStartS += problem->nodeSP[assSP].unload;
//		  //Quangnn+-
//		  return 0;//GoThroughVehicle(idVeh, 1, update_idTrip, varcost, varvioTWC, varvioTWSP, cStartS, assSP, firstC_nextT);
//	}//end if (seg[idVeh].Trip[nextT].Type == 0 || 2)
//}
//
//
//
//void Solution::Update_deleteCusArrayP_FirstMiddleTrip(int idVeh, int idTrip) //only applied for the case where vehicle has >= 2 trips
//{
//	//See on 2/12/2013
//	int numC = seg[idVeh].Trip[idTrip].numCus;
//	int curC, preC, preC1;
//	double varcost, varvioTWC, varvioTWSP, cStartS, cArrTime, cArrTimeI, temp;
//	int vioCapNEW;
//	int lastTrip = seg[idVeh].numTrips-1;
//	int deletednode;
//
//	int assSP = seg[idVeh].Trip[idTrip].assSP;
//	deletednode = seg[idVeh].Trip[idTrip].firstCus;
//	if (idTrip == 0)
//	{
//		preC1 = 0;
//		cStartS = 0;
//	}
//	else
//	{
//		int preT = idTrip - 1; 
//		if (seg[idVeh].Trip[preT].Type == 0) 
//		{
//			preC1 = seg[idVeh].Trip[preT].assSP;
//			cStartS = seg[idVeh].Trip[preT].leaveSP;
//		}
//		else 
//		{
//			preC1 = seg[idVeh].Trip[preT].lastCus;
//			cStartS = depart[preC1];
//		}	
//	}
//
//	int capOLD = seg[idVeh].Trip[idTrip].capacity;
//	int vioCapOLD = seg[idVeh].Trip[idTrip].vioCAP;
//	int curC1 = nextArr[deletednode];
//
//	int nextT = idTrip + 1;
//	int firstC_nextT = seg[idVeh].Trip[nextT].firstCus;
//
//	if (seg[idVeh].Trip[nextT].Type == 1)
//	{
//		int assSP1 = seg[idVeh].Trip[nextT].assSP;
//		if (assSP1 == assSP) // p -assSP - d
//		{
//			//1. Delete the first and middle pickup customers:
//			while (curC1 > 0)
//			{
//				varvioTWC = -vioTWCus[deletednode]; varvioTWSP = 0;
//				varcost = problem->c[preC1][curC1] - (problem->c[preC1][deletednode] + problem->c[deletednode][curC1]);
//				preC = preC1; curC = curC1;
//				//cout<<"("<<deletednode<<", "<<varvioTWC<<", ";
//				do
//				{
//					cArrTime = cStartS + problem->c[preC][curC];
//					cStartS = PDS_MAX(cArrTime, problem->node[curC].sTW);
//					temp = cStartS - problem->node[curC].eTW;
//					if (temp > eps) //Update 8/11/2013
//					{
//							varvioTWC += (temp - vioTWCus[curC]);
//							if (vioTWCus[curC] > eps) goto Update;
//							cStartS = problem->node[curC].depart;
//					}
//					else 
//					{
//						varvioTWC -= vioTWCus[curC];
//						if (PDSDIF(cStartS, startS[curC])== 0) goto Update;
//						cStartS += problem->node[curC].duration;
//					}
//					preC = curC; curC = nextArr[curC];
//				} while (curC > 0);
//				//cout<<varvioTWC<<", ";
//				if (calChangeCONNECTAtSP_PickTrip_NextDSameSP(preC,idVeh,idTrip,cStartS,varvioTWSP,varcost) == 0)
//                    GoThroughVehicle(idVeh, nextT, varcost, varvioTWC, varvioTWSP, cStartS, assSP1, firstC_nextT);
//				Update:
//					deleteCus[deletednode]->var_cost = varcost;
//					deleteCus[deletednode]->var_vioTWC = varvioTWC;
//					deleteCus[deletednode]->var_vioTWSP = varvioTWSP;
//					vioCapNEW = PDS_MAX(capOLD - problem->node[deletednode].capacity- problem->Q,0);
//					deleteCus[deletednode]->var_vioCAP = vioCapNEW - vioCapOLD;
//					deleteCus[deletednode]->atIT = IT;
//					deleteCus[deletednode]->empty = 0;
//
//				//New delete customer:
//				preC1 = deletednode; cStartS = depart[preC1];
//				deletednode = curC1; curC1 = nextArr[curC1];
//			}//end while (curC1 > 0)
//			
//			//2. Delete the last pickup customer:
//			vioCapNEW = PDS_MAX(capOLD - problem->node[deletednode].capacity- problem->Q,0);
//			deleteCus[deletednode]->var_vioCAP = vioCapNEW - vioCapOLD;
//			varvioTWC = -vioTWCus[deletednode];
//
//			cArrTime = depart[preC1] + problem->c[preC1][assSP];
//			if (PDSINRANGE(cArrTime, problem->nodeSP[assSP].sTW1, problem->nodeSP[assSP].eTW1))
//			{
//				varvioTWSP = - (2 * seg[idVeh].Trip[idTrip].vioTWSP);
//				//before deletion has to go to sp directly: FEA OR INFEA: NOT ALWAYS Update 7/11/2013
//				if (seg[idVeh].Trip[idTrip].waitingS == NO_WS)
//				   varcost = problem->c[preC1][assSP] - (problem->c[preC1][deletednode] + problem->c[deletednode][assSP]);
//				else
//				   varcost = problem->c[preC1][assSP] - (problem->c[preC1][deletednode] + problem->disCWSSP[deletednode][assSP]);
//				cStartS = cArrTime + problem->nodeSP[assSP].unload + problem->nodeSP[assSP].load;
//			}
//			else
//			{
//					temp = cArrTime - problem->nodeSP[assSP].eTW1;
//					if (temp > eps)
//					{
//						//before deletion has to go to sp directly: INFEA; NOT ALWAYS Update 7/11/2013
//						if (seg[idVeh].Trip[idTrip].waitingS == NO_WS)
//						   varcost = problem->c[preC1][assSP] - (problem->c[preC1][deletednode] + problem->c[deletednode][assSP]);
//						else
//						   varcost = problem->c[preC1][assSP] - (problem->c[preC1][deletednode] + problem->disCWSSP[deletednode][assSP]);
//						varvioTWSP = 2 * (temp - seg[idVeh].Trip[idTrip].vioTWSP);
//						if (seg[idVeh].Trip[idTrip].vioTWSP > eps)
//						{
//							deleteCus[deletednode]->var_cost = varcost;
//							deleteCus[deletednode]->var_vioTWSP = varvioTWSP;
//							deleteCus[deletednode]->var_vioTWC = varvioTWC;
//							deleteCus[deletednode]->atIT = IT;
//							deleteCus[deletednode]->empty = 0;
//							return;
//						}
//						cStartS = problem->leaveSP[assSP][1]; //load only at eTW2
//					}
//					else
//					{
//						cArrTimeI = depart[preC1] + problem->disCWSSP[preC1][assSP];
//						temp = cArrTimeI - problem->nodeSP[assSP].eTW1;
//						if (temp > eps) //too soon to go sp directly, too late to go through WS:
//						{
//							varvioTWSP = 2 * (problem->nodeSP[assSP].sTW1 - cArrTime - seg[idVeh].Trip[idTrip].vioTWSP);
//							//before deletion has to go to sp directly: FEA OR INFEA NOT ALWAYS Update 7/11/2013
//							if (seg[idVeh].Trip[idTrip].waitingS == NO_WS)
//							   varcost = problem->c[preC1][assSP] - (problem->c[preC1][deletednode] + problem->c[deletednode][assSP]);
//							else
//							   varcost = problem->c[preC1][assSP] - (problem->c[preC1][deletednode] + problem->disCWSSP[deletednode][assSP]);
//
//							if (seg[idVeh].Trip[idTrip].vioTWSP > eps)
//							{
//								deleteCus[deletednode]->var_cost = varcost;
//								deleteCus[deletednode]->var_vioTWSP = varvioTWSP;
//								deleteCus[deletednode]->var_vioTWC = varvioTWC;
//								deleteCus[deletednode]->atIT = IT;
//								deleteCus[deletednode]->empty = 0;
//								return;
//							}
//							cStartS = problem->leaveSP[assSP][1]; //load only at eTW2
//						}
//						else //to go through WS
//						{
//							varvioTWSP = - (2 * seg[idVeh].Trip[idTrip].vioTWSP);
//							//before deletion may go to sp directly or through WS:
//							if (seg[idVeh].Trip[idTrip].waitingS == NO_WS)
//								varcost = problem->disCWSSP[preC1][assSP] - (problem->c[preC1][deletednode] + problem->c[deletednode][assSP]);
//							else varcost = problem->disCWSSP[preC1][assSP] - (problem->c[preC1][deletednode] + problem->disCWSSP[deletednode][assSP]);
//							cStartS = PDS_MAX(cArrTimeI, problem->nodeSP[assSP].sTW1) + problem->nodeSP[assSP].unload + problem->nodeSP[assSP].load;
//						}
//					}
//			}
//
//			GoThroughVehicle(idVeh, nextT, varcost, varvioTWC, varvioTWSP, cStartS, assSP1, firstC_nextT);
//			deleteCus[deletednode]->var_cost = varcost;
//			deleteCus[deletednode]->var_vioTWC = varvioTWC;
//			deleteCus[deletednode]->var_vioTWSP = varvioTWSP;
//			deleteCus[deletednode]->atIT = IT;
//			deleteCus[deletednode]->empty = 0;
//		}
//		else // p - assSP - assSP1 - d
//		{
//			//1. Delete the first and middle pickup customers:
//			while (curC1 > 0)
//			{
//				varvioTWC = -vioTWCus[deletednode]; varvioTWSP = 0;
//				varcost = problem->c[preC1][curC1] - (problem->c[preC1][deletednode] + problem->c[deletednode][curC1]);
//				preC = preC1; curC = curC1;
//				do
//				{
//					cArrTime = cStartS + problem->c[preC][curC];
//					cStartS = PDS_MAX(cArrTime, problem->node[curC].sTW);
//					temp = cStartS - problem->node[curC].eTW;
//					if (temp > eps) //Update 8/11/2013
//					{
//							varvioTWC += (temp - vioTWCus[curC]);
//							if (vioTWCus[curC] > eps) goto Update1;
//							cStartS = problem->node[curC].depart;
//					}
//					else 
//					{
//						varvioTWC -= vioTWCus[curC];
//						if (PDSDIF(cStartS, startS[curC])== 0) goto Update1;
//						cStartS += problem->node[curC].duration;
//					}
//					preC = curC; curC = nextArr[curC];
//				} while (curC > 0);
//				if (calChangeCONNECTAtSP_PickTrip2(preC, idVeh, idTrip, cStartS, varvioTWSP, varcost)==0)
//				{
//					if (calChangeCONNECTAtSP_SPSP(idVeh, nextT, idTrip, cStartS, varvioTWSP, varcost) == 0)
//						GoThroughVehicle(idVeh, nextT, varcost, varvioTWC, varvioTWSP, cStartS, assSP1, firstC_nextT);
//				}
//				Update1:
//					deleteCus[deletednode]->var_cost = varcost;
//					deleteCus[deletednode]->var_vioTWC = varvioTWC;
//					deleteCus[deletednode]->var_vioTWSP = varvioTWSP;
//					vioCapNEW = PDS_MAX(capOLD - problem->node[deletednode].capacity- problem->Q,0);
//					deleteCus[deletednode]->var_vioCAP = vioCapNEW - vioCapOLD;
//					deleteCus[deletednode]->atIT = IT;
//					deleteCus[deletednode]->empty = 0;
//
//				//New delete customer:
//				preC1 = deletednode; cStartS = depart[preC1];
//				deletednode = curC1; curC1 = nextArr[curC1];
//			}//end while (curC1 > 0)
//			
//			//2. Delete the last pickup customer:
//			vioCapNEW = PDS_MAX(capOLD - problem->node[deletednode].capacity- problem->Q,0);
//			deleteCus[deletednode]->var_vioCAP = vioCapNEW - vioCapOLD;
//			varvioTWC = -vioTWCus[deletednode];
//
//			cArrTime = depart[preC1] + problem->c[preC1][assSP];
//			if (PDSINRANGE(cArrTime, problem->nodeSP[assSP].sTW1, problem->nodeSP[assSP].eTW1))
//			{
//				varvioTWSP = -seg[idVeh].Trip[idTrip].vioTWSP;
//				//before deletion has to go to sp directly: FEA OR INFEA NOT ALWAYS Update 7/11/2013
//				if (seg[idVeh].Trip[idTrip].waitingS == NO_WS)
//					varcost = problem->c[preC1][assSP] - (problem->c[preC1][deletednode] + problem->c[deletednode][assSP]);
//				else
//					varcost = problem->c[preC1][assSP] - (problem->c[preC1][deletednode] + problem->disCWSSP[deletednode][assSP]);
//				cStartS = cArrTime + problem->nodeSP[assSP].unload;
//			}
//			else
//			{
//					temp = cArrTime - problem->nodeSP[assSP].eTW1;
//					if (temp > eps)
//					{
//						//before deletion has to go to sp directly: INFEA NOT ALWAYS Update 7/11/2013
//						if (seg[idVeh].Trip[idTrip].waitingS == NO_WS)
//							varcost = problem->c[preC1][assSP] - (problem->c[preC1][deletednode] + problem->c[deletednode][assSP]);
//						else
//							varcost = problem->c[preC1][assSP] - (problem->c[preC1][deletednode] + problem->disCWSSP[deletednode][assSP]);
//                        varvioTWSP = temp - seg[idVeh].Trip[idTrip].vioTWSP;
//						if (seg[idVeh].Trip[idTrip].vioTWSP > eps)
//						{
//							deleteCus[deletednode]->var_cost = varcost;
//							deleteCus[deletednode]->var_vioTWSP = varvioTWSP;
//							deleteCus[deletednode]->var_vioTWC = varvioTWC;
//							deleteCus[deletednode]->atIT = IT;
//							deleteCus[deletednode]->empty = 0;
//							return;
//						}
//						cStartS = problem->leaveSP[assSP][0]; //unload only at eTW1
//					}
//					else
//					{
//						cArrTimeI = depart[preC1] + problem->disCWSSP[preC1][assSP];
//						temp = cArrTimeI - problem->nodeSP[assSP].eTW1;
//						if (temp > eps) //too soon to go sp directly, too late to go through WS:
//						{
//							varvioTWSP = problem->nodeSP[assSP].sTW1 - cArrTime - seg[idVeh].Trip[idTrip].vioTWSP;
//							//before deletion has to go to sp directly: FEA OR INFEA NOT ALWAYS Update 7/11/2013
//							if (seg[idVeh].Trip[idTrip].waitingS == NO_WS)
//								varcost = problem->c[preC1][assSP] - (problem->c[preC1][deletednode] + problem->c[deletednode][assSP]);
//							else
//								varcost = problem->c[preC1][assSP] - (problem->c[preC1][deletednode] + problem->disCWSSP[deletednode][assSP]);
//
//							if (seg[idVeh].Trip[idTrip].vioTWSP > eps)
//							{
//								deleteCus[deletednode]->var_cost = varcost;
//								deleteCus[deletednode]->var_vioTWSP = varvioTWSP;
//								deleteCus[deletednode]->var_vioTWC = varvioTWC;
//								deleteCus[deletednode]->atIT = IT;
//								deleteCus[deletednode]->empty = 0;
//								return;
//							}
//							cStartS = problem->leaveSP[assSP][0]; //unload only at eTW1
//						}
//						else //to go through WS
//						{
//							varvioTWSP = -seg[idVeh].Trip[idTrip].vioTWSP;
//							//before deletion may go to sp directly or through WS:
//							if (seg[idVeh].Trip[idTrip].waitingS == NO_WS)
//								varcost = problem->disCWSSP[preC1][assSP] - (problem->c[preC1][deletednode] + problem->c[deletednode][assSP]);
//							else varcost = problem->disCWSSP[preC1][assSP] - (problem->c[preC1][deletednode] + problem->disCWSSP[deletednode][assSP]);
//							cStartS = PDS_MAX(cArrTimeI, problem->nodeSP[assSP].sTW1) + problem->nodeSP[assSP].unload;
//						}
//					}
//			}
//			
//			if (calChangeCONNECTAtSP_SPSP(idVeh, nextT, idTrip, cStartS, varvioTWSP, varcost) == 0)
//			{
//				GoThroughVehicle(idVeh, nextT, varcost, varvioTWC, varvioTWSP, cStartS, assSP1, firstC_nextT);
//			}
//			deleteCus[deletednode]->var_cost = varcost;
//			deleteCus[deletednode]->var_vioTWC = varvioTWC;
//			deleteCus[deletednode]->var_vioTWSP = varvioTWSP;
//			deleteCus[deletednode]->atIT = IT;
//			deleteCus[deletednode]->empty = 0;
//		}//end p - assSP - assSP1 - d
//	}
//	else //if (seg[idVeh].Trip[nextT].Type == 0 || 2)
//	{
//			//1. Delete the first and middle pickup customers:
//			while (curC1 > 0)
//			{
//				varvioTWC = -vioTWCus[deletednode]; varvioTWSP = 0;
//				varcost = problem->c[preC1][curC1] - (problem->c[preC1][deletednode] + problem->c[deletednode][curC1]);
//				preC = preC1; curC = curC1;
//				do
//				{
//					cArrTime = cStartS + problem->c[preC][curC];
//					cStartS = PDS_MAX(cArrTime, problem->node[curC].sTW);
//					temp = cStartS - problem->node[curC].eTW;
//					if (temp > eps) //Update 8/11/2013
//					{
//							varvioTWC += (temp - vioTWCus[curC]);
//							if (vioTWCus[curC] > eps) goto Update2;
//							cStartS = problem->node[curC].depart;
//					}
//					else 
//					{
//						varvioTWC -= vioTWCus[curC];
//						if (PDSDIF(cStartS, startS[curC])== 0) goto Update2;
//						cStartS += problem->node[curC].duration;
//					}
//					preC = curC; curC = nextArr[curC];
//				} while (curC > 0);
//				//cout<<"(E5: "<<deleted node<<", "<<preC<<", "<<cStartS<<", ";
//				if (calChangeCONNECTAtSP_PickTrip2(preC, idVeh, idTrip, cStartS, varvioTWSP, varcost)==0)
//				{
//					//cout<<"("<<varvioTWSP<<", ";
//					GoThroughVehicle(idVeh, nextT, varcost, varvioTWC, varvioTWSP, cStartS, assSP, firstC_nextT);
//					//cout<<varvioTWSP<<"); ";
//				}
//				Update2:
//					deleteCus[deletednode]->var_cost = varcost;
//					deleteCus[deletednode]->var_vioTWC = varvioTWC;
//					deleteCus[deletednode]->var_vioTWSP = varvioTWSP;
//					vioCapNEW = PDS_MAX(capOLD - problem->node[deletednode].capacity- problem->Q,0);
//					deleteCus[deletednode]->var_vioCAP = vioCapNEW - vioCapOLD;
//					deleteCus[deletednode]->atIT = IT;
//					deleteCus[deletednode]->empty = 0;
//
//				//New delete customer:
//				preC1 = deletednode; cStartS = depart[preC1];
//				deletednode = curC1; curC1 = nextArr[curC1];
//			}//end while (curC1 > 0)
//			
//			//2. Delete the last pickup customer:
//			vioCapNEW = PDS_MAX(capOLD - problem->node[deletednode].capacity- problem->Q,0);
//			deleteCus[deletednode]->var_vioCAP = vioCapNEW - vioCapOLD;
//			varvioTWC = -vioTWCus[deletednode];
//
//			cArrTime = depart[preC1] + problem->c[preC1][assSP];
//			//cout<<"("<<preC1<<", "<<deletednode<<", ";
//			if (PDSINRANGE(cArrTime, problem->nodeSP[assSP].sTW1, problem->nodeSP[assSP].eTW1))
//			{
//				varvioTWSP = -seg[idVeh].Trip[idTrip].vioTWSP;
//				//before deletion has to go to sp directly: FEA OR INFEA NOT ALWAYS Update 7/11/2013
//				if (seg[idVeh].Trip[idTrip].waitingS == NO_WS)
//				{
//					varcost = problem->c[preC1][assSP] - (problem->c[preC1][deletednode] + problem->c[deletednode][assSP]);
//					//cout<<"(1) "<<varcost<<"); ";
//				}
//				else
//				{
//					varcost = problem->c[preC1][assSP] - (problem->c[preC1][deletednode] + problem->disCWSSP[deletednode][assSP]);
//					//cout<<"(2) "<<varcost<<"); ";
//				}
//				cStartS = cArrTime + problem->nodeSP[assSP].unload;
//			}
//			else
//			{
//					temp = cArrTime - problem->nodeSP[assSP].eTW1;
//					if (temp > eps)
//					{
//						varvioTWSP = temp - seg[idVeh].Trip[idTrip].vioTWSP;
//						//before deletion has to go to sp directly: INFEA NOT ALWAYS Update 7/11/2013
//						if (seg[idVeh].Trip[idTrip].waitingS == NO_WS)
//						{
//							varcost = problem->c[preC1][assSP] - (problem->c[preC1][deletednode] + problem->c[deletednode][assSP]);
//							//cout<<"(3) "<<varcost<<"); ";
//						}
//						else
//						{
//							varcost = problem->c[preC1][assSP] - (problem->c[preC1][deletednode] + problem->disCWSSP[deletednode][assSP]);
//							//cout<<"(4) "<<varcost<<"); ";
//						}
//						if (seg[idVeh].Trip[idTrip].vioTWSP > eps)
//						{
//							deleteCus[deletednode]->var_cost = varcost;
//							deleteCus[deletednode]->var_vioTWSP = varvioTWSP;
//							deleteCus[deletednode]->var_vioTWC = varvioTWC;
//							deleteCus[deletednode]->atIT = IT;
//							deleteCus[deletednode]->empty = 0;
//							return;
//						}
//						cStartS = problem->leaveSP[assSP][0]; //unload only at eTW1
//					}
//					else
//					{
//						cArrTimeI = depart[preC1] + problem->disCWSSP[preC1][assSP];
//						temp = cArrTimeI - problem->nodeSP[assSP].eTW1;
//						if (temp > eps) //too soon to go sp directly, too late to go through WS:
//						{
//							varvioTWSP = problem->nodeSP[assSP].sTW1 - cArrTime - seg[idVeh].Trip[idTrip].vioTWSP;
//							//before deletion has to go to sp directly: FEA OR INFEA NOT ALWAYS Update 7/11/2013
//							if (seg[idVeh].Trip[idTrip].waitingS == NO_WS)
//							{
//								varcost = problem->c[preC1][assSP] - (problem->c[preC1][deletednode] + problem->c[deletednode][assSP]);
//								//cout<<"(5) "<<varcost<<"); ";
//							}
//							else
//							{
//								varcost = problem->c[preC1][assSP] - (problem->c[preC1][deletednode] + problem->disCWSSP[deletednode][assSP]);
//								//cout<<"(6) "<<varcost<<"); ";
//							}
//							if (seg[idVeh].Trip[idTrip].vioTWSP > eps)
//							{
//								deleteCus[deletednode]->var_cost = varcost;
//								deleteCus[deletednode]->var_vioTWSP = varvioTWSP;
//								deleteCus[deletednode]->var_vioTWC = varvioTWC;
//								deleteCus[deletednode]->atIT = IT;
//								deleteCus[deletednode]->empty = 0;
//								return;
//							}
//							cStartS = problem->leaveSP[assSP][0]; //unload only at eTW1
//						}
//						else //to go through WS
//						{
//							varvioTWSP = -seg[idVeh].Trip[idTrip].vioTWSP;
//							//before deletion may go to sp directly or through WS:
//							if (seg[idVeh].Trip[idTrip].waitingS == NO_WS)
//							{
//								varcost = problem->disCWSSP[preC1][assSP] - (problem->c[preC1][deletednode] + problem->c[deletednode][assSP]);
//								//cout<<"(7) "<<varcost<<"); ";
//							}
//							else 
//							{
//								varcost = problem->disCWSSP[preC1][assSP] - (problem->c[preC1][deletednode] + problem->disCWSSP[deletednode][assSP]);
//								//cout<<"(8) "<<varcost<<");";
//							}
//							cStartS = PDS_MAX(cArrTimeI, problem->nodeSP[assSP].sTW1) + problem->nodeSP[assSP].unload;
//						}
//					}
//			}
//
//		    GoThroughVehicle(idVeh, nextT, varcost, varvioTWC, varvioTWSP, cStartS, assSP, firstC_nextT);
//			//cout<<varcost<<"); ";
//			deleteCus[deletednode]->var_cost = varcost;
//			deleteCus[deletednode]->var_vioTWC = varvioTWC;
//			deleteCus[deletednode]->var_vioTWSP = varvioTWSP;
//			deleteCus[deletednode]->atIT = IT;
//			deleteCus[deletednode]->empty = 0;
//	}//end if (seg[idVeh].Trip[nextT].Type == 0 || 2)
//}
//
//bool Solution::cal_deleteCusArrayP_FirstMiddleTrip_TillTrip(int idVeh, int idTrip, int deletednode, double &varcost, double &varvioTWC, double &varvioTWSP, int &varvioCAP, double &cStartS,int update_idTrip)
//{
//	//See on 2/12/2013
//	//only applied for the case where vehicle has >= 2 trips
//	//First trip: > 2 customers; middle trip: >=2 customers
//	int pre, suc, preID, nextID;
//	double cArrTime, cArrTimeI, temp;
//	int lastTrip = seg[idVeh].numTrips-1;
//
//	int assSP = seg[idVeh].Trip[idTrip].assSP;
//
//	pre = predArr[deletednode]; suc = nextArr[deletednode];
//
//	if (pre < 0)
//	{
//		if (idTrip == 0)
//		{
//			pre = 0;
//			cStartS = 0;
//		}
//		else
//		{
//			int preT = idTrip - 1; 
//			if (seg[idVeh].Trip[preT].Type == 0) 
//			{
//				pre = seg[idVeh].Trip[preT].assSP;
//				cStartS = seg[idVeh].Trip[preT].leaveSP;
//			}
//			else 
//			{
//				pre = seg[idVeh].Trip[preT].lastCus;
//				cStartS = depart[pre];
//			}	
//		}
//	}
//	else cStartS = depart[pre];
//
//	int vioCapNEW = PDS_MAX(seg[idVeh].Trip[idTrip].capacity - problem->node[deletednode].capacity- problem->Q,0);
//	varvioCAP += (vioCapNEW - seg[idVeh].Trip[idTrip].vioCAP);
//	
//	int nextT = idTrip + 1;
//	int firstC_nextT = seg[idVeh].Trip[nextT].firstCus;
//
//	if (seg[idVeh].Trip[nextT].Type == 1)
//	{
//		int assSP1 = seg[idVeh].Trip[nextT].assSP;
//		if (assSP1 == assSP) // p -assSP - d
//		{
//			//1. Delete the first and middle pickup customers:
//			if (deletednode != seg[idVeh].Trip[idTrip].lastCus)
//			{
//				varvioTWC -= vioTWCus[deletednode]; 
//				varcost += (problem->c[pre][suc] - (problem->c[pre][deletednode] + problem->c[deletednode][suc]));
//				preID = pre; nextID = suc;
//				do
//				{
//					cArrTime = cStartS + problem->c[preID][nextID];
//					cStartS = PDS_MAX(cArrTime, problem->node[nextID].sTW);
//					temp = cStartS - problem->node[nextID].eTW;
//					if (temp > eps) //Update 8/11/2013
//					{
//						varvioTWC += (temp - vioTWCus[nextID]);
//						if (vioTWCus[nextID] > eps) return 1;
//						cStartS = problem->node[nextID].depart;
//					}
//					else 
//					{
//						varvioTWC -= vioTWCus[nextID];
//						if (PDSDIF(cStartS, startS[nextID])== 0) return 1;
//						cStartS += problem->node[nextID].duration;
//					}
//					preID = nextID; nextID = nextArr[nextID];
//				} while (nextID > 0);
//				if ( calChangeCONNECTAtSP_PickTrip_NextDSameSP(preID, idVeh,idTrip,cStartS,varvioTWSP,varcost) == 0){
//					//Quangnn+-
//					return 0;//
//						//GoThroughVehicle(idVeh, nextT, update_idTrip - nextT + 1, varcost, varvioTWC, varvioTWSP, cStartS, assSP1, firstC_nextT);
//				}
//				else return 1;
//			}
//			else //delete the last cus:
//			{
//				//2. Delete the last pickup customer:
//				varvioTWC -= vioTWCus[deletednode];
//				cArrTime = depart[pre] + problem->c[pre][assSP];
//				if (PDSINRANGE(cArrTime, problem->nodeSP[assSP].sTW1, problem->nodeSP[assSP].eTW1))
//				{
//					varvioTWSP -= (2 * seg[idVeh].Trip[idTrip].vioTWSP);
//					//before deletion has to go to sp directly: FEA OR INFEA: NOT ALWAYS Update 7/11/2013
//					if (seg[idVeh].Trip[idTrip].waitingS == NO_WS)
//					   varcost = problem->c[pre][assSP] - (problem->c[pre][deletednode] + problem->c[deletednode][assSP]);
//					else
//					   varcost = problem->c[pre][assSP] - (problem->c[pre][deletednode] + problem->disCWSSP[deletednode][assSP]);
//					cStartS = cArrTime + problem->nodeSP[assSP].unload + problem->nodeSP[assSP].load;
//				}
//				else
//				{
//						temp = cArrTime - problem->nodeSP[assSP].eTW1;
//						if (temp > eps)
//						{
//							//before deletion has to go to sp directly: INFEA; NOT ALWAYS Update 7/11/2013
//							if (seg[idVeh].Trip[idTrip].waitingS == NO_WS)
//							   varcost = problem->c[pre][assSP] - (problem->c[pre][deletednode] + problem->c[deletednode][assSP]);
//							else
//							   varcost = problem->c[pre][assSP] - (problem->c[pre][deletednode] + problem->disCWSSP[deletednode][assSP]);
//							varvioTWSP += (2 * (temp - seg[idVeh].Trip[idTrip].vioTWSP));
//							if (seg[idVeh].Trip[idTrip].vioTWSP > eps) return 1;
//							cStartS = problem->leaveSP[assSP][1]; //load only at eTW2
//						}
//						else
//						{
//							cArrTimeI = depart[pre] + problem->disCWSSP[pre][assSP];
//							temp = cArrTimeI - problem->nodeSP[assSP].eTW1;
//							if (temp > eps) //too soon to go sp directly, too late to go through WS:
//							{
//								varvioTWSP += (2 * (problem->nodeSP[assSP].sTW1 - cArrTime - seg[idVeh].Trip[idTrip].vioTWSP));
//								//before deletion has to go to sp directly: FEA OR INFEA NOT ALWAYS Update 7/11/2013
//								if (seg[idVeh].Trip[idTrip].waitingS == NO_WS)
//								   varcost = problem->c[pre][assSP] - (problem->c[pre][deletednode] + problem->c[deletednode][assSP]);
//								else
//								   varcost = problem->c[pre][assSP] - (problem->c[pre][deletednode] + problem->disCWSSP[deletednode][assSP]);
//
//								if (seg[idVeh].Trip[idTrip].vioTWSP > eps) return 1;
//								cStartS = problem->leaveSP[assSP][1]; //load only at eTW2
//							}
//							else //to go through WS
//							{
//								varvioTWSP -= (2 * seg[idVeh].Trip[idTrip].vioTWSP);
//								//before deletion may go to sp directly or through WS:
//								if (seg[idVeh].Trip[idTrip].waitingS == NO_WS)
//									varcost = problem->disCWSSP[pre][assSP] - (problem->c[pre][deletednode] + problem->c[deletednode][assSP]);
//								else varcost = problem->disCWSSP[pre][assSP] - (problem->c[pre][deletednode] + problem->disCWSSP[deletednode][assSP]);
//								cStartS = PDS_MAX(cArrTimeI, problem->nodeSP[assSP].sTW1) + problem->nodeSP[assSP].unload + problem->nodeSP[assSP].load;
//							}
//						}
//				}
//				//Quangnn+-
//				return 0; //GoThroughVehicle(idVeh, nextT, update_idTrip - nextT + 1, varcost, varvioTWC, varvioTWSP, cStartS, assSP1, firstC_nextT);
//			}//end delete the last cus
//		}
//		else // p - assSP - assSP1 - d
//		{
//			if (deletednode != seg[idVeh].Trip[idTrip].lastCus)
//			{
//					//1. Delete the first and middle pickup customers:
//					varvioTWC -= vioTWCus[deletednode]; 
//					varcost = problem->c[pre][suc] - (problem->c[pre][deletednode] + problem->c[deletednode][suc]);
//					preID = pre; nextID = suc;
//					do
//					{
//						cArrTime = cStartS + problem->c[preID][nextID];
//						cStartS = PDS_MAX(cArrTime, problem->node[nextID].sTW);
//						temp = cStartS - problem->node[nextID].eTW;
//						if (temp > eps) //Update 8/11/2013
//						{
//								varvioTWC += (temp - vioTWCus[nextID]);
//								if (vioTWCus[nextID] > eps) return 1;
//								cStartS = problem->node[nextID].depart;
//						}
//						else 
//						{
//							varvioTWC -= vioTWCus[nextID];
//							if (PDSDIF(cStartS, startS[nextID])== 0) return 1;
//							cStartS += problem->node[nextID].duration;
//						}
//						preID = nextID; nextID = nextArr[nextID];
//					} while (nextID > 0);
//					if (calChangeCONNECTAtSP_PickTrip2(preID, idVeh, idTrip, cStartS, varvioTWSP, varcost)==0) //dont need to check p-dSAMESP
//					{
//						if (calChangeCONNECTAtSP_SPSP(idVeh, nextT, idTrip, cStartS, varvioTWSP, varcost) == 0){
//							
//							//GoThroughVehicle(idVeh, nextT, update_idTrip - nextT + 1, varcost, varvioTWC, varvioTWSP, cStartS, assSP1, firstC_nextT);
//						}
//						else return 1;
//					}
//					else return 1;
//			}
//			else //delete the last cus:
//			{
//				//2. Delete the last pickup customer:
//				varvioTWC -= vioTWCus[deletednode];
//
//				cArrTime = depart[pre] + problem->c[pre][assSP];
//				if (PDSINRANGE(cArrTime, problem->nodeSP[assSP].sTW1, problem->nodeSP[assSP].eTW1))
//				{
//					varvioTWSP -= seg[idVeh].Trip[idTrip].vioTWSP;
//					//before deletion has to go to sp directly: FEA OR INFEA NOT ALWAYS Update 7/11/2013
//					if (seg[idVeh].Trip[idTrip].waitingS == NO_WS)
//						varcost = problem->c[pre][assSP] - (problem->c[pre][deletednode] + problem->c[deletednode][assSP]);
//					else
//						varcost = problem->c[pre][assSP] - (problem->c[pre][deletednode] + problem->disCWSSP[deletednode][assSP]);
//					cStartS = cArrTime + problem->nodeSP[assSP].unload;
//				}
//				else
//				{
//						temp = cArrTime - problem->nodeSP[assSP].eTW1;
//						if (temp > eps)
//						{
//							//before deletion has to go to sp directly: INFEA NOT ALWAYS Update 7/11/2013
//							if (seg[idVeh].Trip[idTrip].waitingS == NO_WS)
//								varcost = problem->c[pre][assSP] - (problem->c[pre][deletednode] + problem->c[deletednode][assSP]);
//							else
//								varcost = problem->c[pre][assSP] - (problem->c[pre][deletednode] + problem->disCWSSP[deletednode][assSP]);
//							varvioTWSP += (temp - seg[idVeh].Trip[idTrip].vioTWSP);
//							if (seg[idVeh].Trip[idTrip].vioTWSP > eps) return 1;
//							cStartS = problem->leaveSP[assSP][0]; //unload only at eTW1
//						}
//						else
//						{
//							cArrTimeI = depart[pre] + problem->disCWSSP[pre][assSP];
//							temp = cArrTimeI - problem->nodeSP[assSP].eTW1;
//							if (temp > eps) //too soon to go sp directly, too late to go through WS:
//							{
//								varvioTWSP += (problem->nodeSP[assSP].sTW1 - cArrTime - seg[idVeh].Trip[idTrip].vioTWSP);
//								//before deletion has to go to sp directly: FEA OR INFEA NOT ALWAYS Update 7/11/2013
//								if (seg[idVeh].Trip[idTrip].waitingS == NO_WS)
//									varcost = problem->c[pre][assSP] - (problem->c[pre][deletednode] + problem->c[deletednode][assSP]);
//								else
//									varcost = problem->c[pre][assSP] - (problem->c[pre][deletednode] + problem->disCWSSP[deletednode][assSP]);
//
//								if (seg[idVeh].Trip[idTrip].vioTWSP > eps) return 1;
//								cStartS = problem->leaveSP[assSP][0]; //unload only at eTW1
//							}
//							else //to go through WS
//							{
//								varvioTWSP -= seg[idVeh].Trip[idTrip].vioTWSP;
//								//before deletion may go to sp directly or through WS:
//								if (seg[idVeh].Trip[idTrip].waitingS == NO_WS)
//									varcost = problem->disCWSSP[pre][assSP] - (problem->c[pre][deletednode] + problem->c[deletednode][assSP]);
//								else varcost = problem->disCWSSP[pre][assSP] - (problem->c[pre][deletednode] + problem->disCWSSP[deletednode][assSP]);
//								cStartS = PDS_MAX(cArrTimeI, problem->nodeSP[assSP].sTW1) + problem->nodeSP[assSP].unload;
//							}
//						}
//				}
//				
//				if (calChangeCONNECTAtSP_SPSP(idVeh, nextT, idTrip, cStartS, varvioTWSP, varcost) == 0){
//					//Quangnn+-
//					//GoThroughVehicle(idVeh, nextT, update_idTrip - nextT + 1, varcost, varvioTWC, varvioTWSP, cStartS, assSP1, firstC_nextT);
//				}
//				return 1;
//			}//end delete the last cus
//		}//end p - assSP - assSP1 - d
//	}
//	else //if (seg[idVeh].Trip[nextT].Type == 0 || 2)
//	{
//			//1. Delete the first and middle pickup customers:
//		    if (deletednode != seg[idVeh].Trip[idTrip].lastCus)
//			{
//				varvioTWC -= vioTWCus[deletednode]; 
//				varcost += (problem->c[pre][suc] - (problem->c[pre][deletednode] + problem->c[deletednode][suc]));
//				preID = pre; nextID = suc;
//				do
//				{
//					cArrTime = cStartS + problem->c[preID][nextID];
//					cStartS = PDS_MAX(cArrTime, problem->node[nextID].sTW);
//					temp = cStartS - problem->node[nextID].eTW;
//					if (temp > eps) //Update 8/11/2013
//					{
//							varvioTWC += (temp - vioTWCus[nextID]);
//							if (vioTWCus[nextID] > eps) return 1;
//							cStartS = problem->node[nextID].depart;
//					}
//					else 
//					{
//						varvioTWC -= vioTWCus[nextID];
//						if (PDSDIF(cStartS, startS[nextID])== 0) return 1;
//						cStartS += problem->node[nextID].duration;
//					}
//					preID = nextID; nextID = nextArr[nextID];
//				} while (nextID > 0);
//				//cout<<"(E5: "<<deleted node<<", "<<preC<<", "<<cStartS<<", ";
//				if (calChangeCONNECTAtSP_PickTrip2(preID, idVeh, idTrip, cStartS, varvioTWSP, varcost)==0) //dont need to check p-d-SAMESP
//				{
//					//cout<<"("<<varvioTWSP<<", ";
//					//Quangnn+-
//					return 0; //GoThroughVehicle(idVeh, nextT, update_idTrip - nextT + 1, varcost, varvioTWC, varvioTWSP, cStartS, assSP, firstC_nextT);
//					//cout<<varvioTWSP<<"); ";
//				}
//				else return 1;
//			}
//			else //delete the last cus:
//			{
//				//2. Delete the last pickup customer:
//				varvioTWC -= vioTWCus[deletednode];
//				cArrTime = depart[pre] + problem->c[pre][assSP];
//				if (PDSINRANGE(cArrTime, problem->nodeSP[assSP].sTW1, problem->nodeSP[assSP].eTW1))
//				{
//					varvioTWSP -= seg[idVeh].Trip[idTrip].vioTWSP;
//					//before deletion has to go to sp directly: FEA OR INFEA NOT ALWAYS Update 7/11/2013
//					if (seg[idVeh].Trip[idTrip].waitingS == NO_WS)
//					{
//						varcost += (problem->c[pre][assSP] - (problem->c[pre][deletednode] + problem->c[deletednode][assSP]));
//						//cout<<"(1) "<<varcost<<"); ";
//					}
//					else
//					{
//						varcost += (problem->c[pre][assSP] - (problem->c[pre][deletednode] + problem->disCWSSP[deletednode][assSP]));
//						//cout<<"(2) "<<varcost<<"); ";
//					}
//					cStartS = cArrTime + problem->nodeSP[assSP].unload;
//				}
//				else
//				{
//						temp = cArrTime - problem->nodeSP[assSP].eTW1;
//						if (temp > eps)
//						{
//							varvioTWSP += (temp - seg[idVeh].Trip[idTrip].vioTWSP);
//							//before deletion has to go to sp directly: INFEA NOT ALWAYS Update 7/11/2013
//							if (seg[idVeh].Trip[idTrip].waitingS == NO_WS)
//							{
//								varcost += (problem->c[pre][assSP] - (problem->c[pre][deletednode] + problem->c[deletednode][assSP]));
//								//cout<<"(3) "<<varcost<<"); ";
//							}
//							else
//							{
//								varcost += (problem->c[pre][assSP] - (problem->c[pre][deletednode] + problem->disCWSSP[deletednode][assSP]));
//								//cout<<"(4) "<<varcost<<"); ";
//							}
//							if (seg[idVeh].Trip[idTrip].vioTWSP > eps) return 1;
//							cStartS = problem->leaveSP[assSP][0]; //unload only at eTW1
//						}
//						else
//						{
//							cArrTimeI = depart[pre] + problem->disCWSSP[pre][assSP];
//							temp = cArrTimeI - problem->nodeSP[assSP].eTW1;
//							if (temp > eps) //too soon to go sp directly, too late to go through WS:
//							{
//								varvioTWSP += (problem->nodeSP[assSP].sTW1 - cArrTime - seg[idVeh].Trip[idTrip].vioTWSP);
//								//before deletion has to go to sp directly: FEA OR INFEA NOT ALWAYS Update 7/11/2013
//								if (seg[idVeh].Trip[idTrip].waitingS == NO_WS)
//								{
//									varcost += (problem->c[pre][assSP] - (problem->c[pre][deletednode] + problem->c[deletednode][assSP]));
//									//cout<<"(5) "<<varcost<<"); ";
//								}
//								else
//								{
//									varcost += (problem->c[pre][assSP] - (problem->c[pre][deletednode] + problem->disCWSSP[deletednode][assSP]));
//									//cout<<"(6) "<<varcost<<"); ";
//								}
//								if (seg[idVeh].Trip[idTrip].vioTWSP > eps) return 1;
//								cStartS = problem->leaveSP[assSP][0]; //unload only at eTW1
//							}
//							else //to go through WS
//							{
//								varvioTWSP -= seg[idVeh].Trip[idTrip].vioTWSP;
//								//before deletion may go to sp directly or through WS:
//								if (seg[idVeh].Trip[idTrip].waitingS == NO_WS)
//								{
//									varcost += (problem->disCWSSP[pre][assSP] - (problem->c[pre][deletednode] + problem->c[deletednode][assSP]));
//									//cout<<"(7) "<<varcost<<"); ";
//								}
//								else 
//								{
//									varcost += (problem->disCWSSP[pre][assSP] - (problem->c[pre][deletednode] + problem->disCWSSP[deletednode][assSP]));
//									//cout<<"(8) "<<varcost<<");";
//								}
//								cStartS = PDS_MAX(cArrTimeI, problem->nodeSP[assSP].sTW1) + problem->nodeSP[assSP].unload;
//							}
//						}
//				}
//				//Quangnn+-
//				return 0; //GoThroughVehicle(idVeh, nextT, update_idTrip - nextT + 1, varcost, varvioTWC, varvioTWSP, cStartS, assSP, firstC_nextT);
//			}//end delete the last cus
//	}//end if (seg[idVeh].Trip[nextT].Type ==0 || 2)
//	return 0;
//}
//
//
//void Solution::cal_deleteCusArrayP_MiddleTrip_FromBeginning(int idVeh, int idTrip, int deletednode, double &varcost, double &varvioTWC, double &varvioTWSP, int &varvioCAP, double cStartS)
//{
//	//see on 2/12/2013
//	//middle trip: >=2 customers
//	int pre, pre1, suc, preID, nextID;
//	double cArrTime, cArrTimeI, temp;
//	int lastTrip = seg[idVeh].numTrips-1;
//
//	int assSP = seg[idVeh].Trip[idTrip].assSP;
//
//	pre = predArr[deletednode]; suc = nextArr[deletednode];
//
//	int preT = idTrip - 1; 
//	if (seg[idVeh].Trip[preT].Type == 0) 
//		preID = seg[idVeh].Trip[preT].assSP;
//	else //=1 or 2
//		preID = seg[idVeh].Trip[preT].lastCus;
//
//	if (pre < 0) pre1 = preID;
//	else pre1 = pre;
//
//	int vioCapNEW = PDS_MAX(seg[idVeh].Trip[idTrip].capacity - problem->node[deletednode].capacity- problem->Q,0);
//	varvioCAP += (vioCapNEW - seg[idVeh].Trip[idTrip].vioCAP);
//
//	if (suc > 0)
//		varcost += (problem->c[pre1][suc] - (problem->c[pre1][deletednode] + problem->c[deletednode][suc]));
//
//	nextID = seg[idVeh].Trip[idTrip].firstCus;
//	//checking from first cus to pre
//	while (nextID != deletednode)
//	{
//		  cArrTime = cStartS + problem->c[preID][nextID]; //Arrive Time to Customer nextID
//		  temp = cArrTime - problem->node[nextID].eTW;
//		  if (temp > eps)
//		  {
//			  if (vioTWCus[nextID] > eps)
//			  {
//				  varvioTWC += (temp - vioTWCus[nextID]);
//				  preID = pre;
//				  cStartS = depart[pre];
//				  break;
//			  }
//			  varvioTWC += temp;
//			  cStartS = problem->node[nextID].depart;
//		  }
//		  else
//		  {
//			  varvioTWC -= vioTWCus[nextID]; //Update 15/11/2013
//			  cStartS = PDS_MAX(cArrTime, problem->node[nextID].sTW) + problem->node[nextID].duration;
//		  }
//		  preID = nextID; nextID = nextArr[nextID];
//	}//end while (nextID != deletednode)
//
//	//preID now points to predArr[deletednode] and nextID points to deletednode
//	nextID = suc;
//	varvioTWC -= vioTWCus[deletednode]; //Update 7/11/2013
//	while (nextID > 0)
//	{
//		  cArrTime = cStartS + problem->c[preID][nextID]; //Arrive Time to Customer nextC
//		  temp = cArrTime - problem->node[nextID].eTW;
//		  if (temp > eps)
//		  {
//			  varvioTWC += (temp - vioTWCus[nextID]);
//			  if (vioTWCus[nextID] > eps) return;
//			  cStartS = problem->node[nextID].depart;
//		  }
//		  else
//		  {
//			  varvioTWC -= vioTWCus[nextID]; //Update 15/11/2013
//			  cStartS = PDS_MAX(cArrTime, problem->node[nextID].sTW) + problem->node[nextID].duration;
//		  }
//		  preID = nextID; nextID = nextArr[nextID];
//	}//end while (nextID > 0)
//
//	//preID now points to newLASTCUS
//	
//	int nextT = idTrip + 1;
//	int firstC_nextT = seg[idVeh].Trip[nextT].firstCus;
//    
//	//cout<<cStartS<<endl;
//	if (seg[idVeh].Trip[nextT].Type == 1)
//	{
//		int assSP1 = seg[idVeh].Trip[nextT].assSP;
//		if (assSP1 == assSP) // p -assSP - d
//		{
//			//1. Delete the first and middle pickup customers:
//			if (suc > 0)
//			{
//				if (calChangeCONNECTAtSP_PickTrip_NextDSameSP(preID,idVeh,idTrip,cStartS,varvioTWSP,varcost)==0)
//					GoThroughVehicle(idVeh, nextT, varcost, varvioTWC, varvioTWSP, cStartS, assSP1, firstC_nextT);
//			}
//			else //delete the last cus:
//			{
//				//2. Delete the last pickup customer:
//				cArrTime = cStartS + problem->c[pre][assSP];
//				if (PDSINRANGE(cArrTime, problem->nodeSP[assSP].sTW1, problem->nodeSP[assSP].eTW1))
//				{
//					varvioTWSP -= (2 * seg[idVeh].Trip[idTrip].vioTWSP);
//					//before deletion has to go to sp directly: FEA OR INFEA: NOT ALWAYS Update 7/11/2013
//					if (seg[idVeh].Trip[idTrip].waitingS == NO_WS)
//					   varcost = problem->c[pre][assSP] - (problem->c[pre][deletednode] + problem->c[deletednode][assSP]);
//					else
//					   varcost = problem->c[pre][assSP] - (problem->c[pre][deletednode] + problem->disCWSSP[deletednode][assSP]);
//					cStartS = cArrTime + problem->nodeSP[assSP].unload + problem->nodeSP[assSP].load;
//				}
//				else
//				{
//						temp = cArrTime - problem->nodeSP[assSP].eTW1;
//						if (temp > eps)
//						{
//							//before deletion has to go to sp directly: INFEA; NOT ALWAYS Update 7/11/2013
//							if (seg[idVeh].Trip[idTrip].waitingS == NO_WS)
//							   varcost = problem->c[pre][assSP] - (problem->c[pre][deletednode] + problem->c[deletednode][assSP]);
//							else
//							   varcost = problem->c[pre][assSP] - (problem->c[pre][deletednode] + problem->disCWSSP[deletednode][assSP]);
//							varvioTWSP += (2 * (temp - seg[idVeh].Trip[idTrip].vioTWSP));
//							if (seg[idVeh].Trip[idTrip].vioTWSP > eps) return;
//							cStartS = problem->leaveSP[assSP][1]; //load only at eTW2
//						}
//						else
//						{
//							cArrTimeI = cStartS + problem->disCWSSP[pre][assSP];
//							temp = cArrTimeI - problem->nodeSP[assSP].eTW1;
//							if (temp > eps) //too soon to go sp directly, too late to go through WS:
//							{
//								varvioTWSP += (2 * (problem->nodeSP[assSP].sTW1 - cArrTime - seg[idVeh].Trip[idTrip].vioTWSP));
//								//before deletion has to go to sp directly: FEA OR INFEA NOT ALWAYS Update 7/11/2013
//								if (seg[idVeh].Trip[idTrip].waitingS == NO_WS)
//								   varcost = problem->c[pre][assSP] - (problem->c[pre][deletednode] + problem->c[deletednode][assSP]);
//								else
//								   varcost = problem->c[pre][assSP] - (problem->c[pre][deletednode] + problem->disCWSSP[deletednode][assSP]);
//
//								if (seg[idVeh].Trip[idTrip].vioTWSP > eps) return;
//								cStartS = problem->leaveSP[assSP][1]; //load only at eTW2
//							}
//							else //to go through WS
//							{
//								varvioTWSP -= (2 * seg[idVeh].Trip[idTrip].vioTWSP);
//								//before deletion may go to sp directly or through WS:
//								if (seg[idVeh].Trip[idTrip].waitingS == NO_WS)
//									varcost = problem->disCWSSP[pre][assSP] - (problem->c[pre][deletednode] + problem->c[deletednode][assSP]);
//								else varcost = problem->disCWSSP[pre][assSP] - (problem->c[pre][deletednode] + problem->disCWSSP[deletednode][assSP]);
//								cStartS = PDS_MAX(cArrTimeI, problem->nodeSP[assSP].sTW1) + problem->nodeSP[assSP].unload + problem->nodeSP[assSP].load;
//							}
//						}
//				}
//				GoThroughVehicle(idVeh, nextT, varcost, varvioTWC, varvioTWSP, cStartS, assSP1, firstC_nextT);
//			}//end delete the last cus
//		}
//		else // p - assSP - assSP1 - d
//		{
//			if (suc > 0)
//			{
//				if (calChangeCONNECTAtSP_PickTrip2(preID, idVeh, idTrip, cStartS, varvioTWSP, varcost)==0)
//				{
//					if (calChangeCONNECTAtSP_SPSP(idVeh, nextT, idTrip, cStartS, varvioTWSP, varcost) == 0)
//						GoThroughVehicle(idVeh, nextT, varcost, varvioTWC, varvioTWSP, cStartS, assSP1, firstC_nextT);
//				}
//			}
//			else //delete the last cus:
//			{
//				//2. Delete the last pickup customer:
//				cArrTime = cStartS + problem->c[pre][assSP];
//				if (PDSINRANGE(cArrTime, problem->nodeSP[assSP].sTW1, problem->nodeSP[assSP].eTW1))
//				{
//					varvioTWSP -= seg[idVeh].Trip[idTrip].vioTWSP;
//					//before deletion has to go to sp directly: FEA OR INFEA NOT ALWAYS Update 7/11/2013
//					if (seg[idVeh].Trip[idTrip].waitingS == NO_WS)
//						varcost = problem->c[pre][assSP] - (problem->c[pre][deletednode] + problem->c[deletednode][assSP]);
//					else
//						varcost = problem->c[pre][assSP] - (problem->c[pre][deletednode] + problem->disCWSSP[deletednode][assSP]);
//					cStartS = cArrTime + problem->nodeSP[assSP].unload;
//				}
//				else
//				{
//						temp = cArrTime - problem->nodeSP[assSP].eTW1;
//						if (temp > eps)
//						{
//							//before deletion has to go to sp directly: INFEA NOT ALWAYS Update 7/11/2013
//							if (seg[idVeh].Trip[idTrip].waitingS == NO_WS)
//								varcost = problem->c[pre][assSP] - (problem->c[pre][deletednode] + problem->c[deletednode][assSP]);
//							else
//								varcost = problem->c[pre][assSP] - (problem->c[pre][deletednode] + problem->disCWSSP[deletednode][assSP]);
//							varvioTWSP -= (temp - seg[idVeh].Trip[idTrip].vioTWSP);
//							if (seg[idVeh].Trip[idTrip].vioTWSP > eps) return;
//							cStartS = problem->leaveSP[assSP][0]; //unload only at eTW1
//						}
//						else
//						{
//							cArrTimeI = cStartS + problem->disCWSSP[pre][assSP];
//							temp = cArrTimeI - problem->nodeSP[assSP].eTW1;
//							if (temp > eps) //too soon to go sp directly, too late to go through WS:
//							{
//								varvioTWSP += (problem->nodeSP[assSP].sTW1 - cArrTime - seg[idVeh].Trip[idTrip].vioTWSP);
//								//before deletion has to go to sp directly: FEA OR INFEA NOT ALWAYS Update 7/11/2013
//								if (seg[idVeh].Trip[idTrip].waitingS == NO_WS)
//									varcost = problem->c[pre][assSP] - (problem->c[pre][deletednode] + problem->c[deletednode][assSP]);
//								else
//									varcost = problem->c[pre][assSP] - (problem->c[pre][deletednode] + problem->disCWSSP[deletednode][assSP]);
//
//								if (seg[idVeh].Trip[idTrip].vioTWSP > eps) return;
//								cStartS = problem->leaveSP[assSP][0]; //unload only at eTW1
//							}
//							else //to go through WS
//							{
//								varvioTWSP -= seg[idVeh].Trip[idTrip].vioTWSP;
//								//before deletion may go to sp directly or through WS:
//								if (seg[idVeh].Trip[idTrip].waitingS == NO_WS)
//									varcost = problem->disCWSSP[pre][assSP] - (problem->c[pre][deletednode] + problem->c[deletednode][assSP]);
//								else varcost = problem->disCWSSP[pre][assSP] - (problem->c[pre][deletednode] + problem->disCWSSP[deletednode][assSP]);
//								cStartS = PDS_MAX(cArrTimeI, problem->nodeSP[assSP].sTW1) + problem->nodeSP[assSP].unload;
//							}
//						}
//				}
//				
//				if (calChangeCONNECTAtSP_SPSP(idVeh, nextT, idTrip, cStartS, varvioTWSP, varcost) == 0)
//					GoThroughVehicle(idVeh, nextT, varcost, varvioTWC, varvioTWSP, cStartS, assSP1, firstC_nextT);
//			}//end delete the last cus
//		}//end p - assSP - assSP1 - d
//	}
//	else //if (seg[idVeh].Trip[nextT].Type == 0 || 2)
//	{
//			//1. Delete the first and middle pickup customers:
//		    if (suc > 0)
//			{
//				if (calChangeCONNECTAtSP_PickTrip2(preID, idVeh, idTrip, cStartS, varvioTWSP, varcost)==0)
//					GoThroughVehicle(idVeh, nextT, varcost, varvioTWC, varvioTWSP, cStartS, assSP, firstC_nextT);
//			}
//			else //delete the last cus:
//			{
//				//2. Delete the last pickup customer:
//				cArrTime = cStartS + problem->c[pre][assSP];
//				if (PDSINRANGE(cArrTime, problem->nodeSP[assSP].sTW1, problem->nodeSP[assSP].eTW1))
//				{
//					varvioTWSP -= seg[idVeh].Trip[idTrip].vioTWSP;
//					//before deletion has to go to sp directly: FEA OR INFEA NOT ALWAYS Update 7/11/2013
//					if (seg[idVeh].Trip[idTrip].waitingS == NO_WS)
//					{
//						varcost += (problem->c[pre][assSP] - (problem->c[pre][deletednode] + problem->c[deletednode][assSP]));
//						//cout<<"(1) "<<varcost<<"); ";
//					}
//					else
//					{
//						varcost += (problem->c[pre][assSP] - (problem->c[pre][deletednode] + problem->disCWSSP[deletednode][assSP]));
//						//cout<<"(2) "<<varcost<<"); ";
//					}
//					cStartS = cArrTime + problem->nodeSP[assSP].unload;
//				}
//				else
//				{
//						temp = cArrTime - problem->nodeSP[assSP].eTW1;
//						if (temp > eps)
//						{
//							varvioTWSP += (temp - seg[idVeh].Trip[idTrip].vioTWSP);
//							//before deletion has to go to sp directly: INFEA NOT ALWAYS Update 7/11/2013
//							if (seg[idVeh].Trip[idTrip].waitingS == NO_WS)
//							{
//								varcost += (problem->c[pre][assSP] - (problem->c[pre][deletednode] + problem->c[deletednode][assSP]));
//								//cout<<"(3) "<<varcost<<"); ";
//							}
//							else
//							{
//								varcost += (problem->c[pre][assSP] - (problem->c[pre][deletednode] + problem->disCWSSP[deletednode][assSP]));
//								//cout<<"(4) "<<varcost<<"); ";
//							}
//							if (seg[idVeh].Trip[idTrip].vioTWSP > eps) return;
//							cStartS = problem->leaveSP[assSP][0]; //unload only at eTW1
//						}
//						else
//						{
//							cArrTimeI = cStartS + problem->disCWSSP[pre][assSP];
//							temp = cArrTimeI - problem->nodeSP[assSP].eTW1;
//							if (temp > eps) //too soon to go sp directly, too late to go through WS:
//							{
//								varvioTWSP += (problem->nodeSP[assSP].sTW1 - cArrTime - seg[idVeh].Trip[idTrip].vioTWSP);
//								//before deletion has to go to sp directly: FEA OR INFEA NOT ALWAYS Update 7/11/2013
//								if (seg[idVeh].Trip[idTrip].waitingS == NO_WS)
//								{
//									varcost += (problem->c[pre][assSP] - (problem->c[pre][deletednode] + problem->c[deletednode][assSP]));
//									//cout<<"(5) "<<varcost<<"); ";
//								}
//								else
//								{
//									varcost += (problem->c[pre][assSP] - (problem->c[pre][deletednode] + problem->disCWSSP[deletednode][assSP]));
//									//cout<<"(6) "<<varcost<<"); ";
//								}
//								if (seg[idVeh].Trip[idTrip].vioTWSP > eps) return;
//								cStartS = problem->leaveSP[assSP][0]; //unload only at eTW1
//							}
//							else //to go through WS
//							{
//								varvioTWSP -= seg[idVeh].Trip[idTrip].vioTWSP;
//								//before deletion may go to sp directly or through WS:
//								if (seg[idVeh].Trip[idTrip].waitingS == NO_WS)
//								{
//									varcost += (problem->disCWSSP[pre][assSP] - (problem->c[pre][deletednode] + problem->c[deletednode][assSP]));
//									//cout<<"(7) "<<varcost<<"); ";
//								}
//								else 
//								{
//									varcost += (problem->disCWSSP[pre][assSP] - (problem->c[pre][deletednode] + problem->disCWSSP[deletednode][assSP]));
//									//cout<<"(8) "<<varcost<<");";
//								}
//								cStartS = PDS_MAX(cArrTimeI, problem->nodeSP[assSP].sTW1) + problem->nodeSP[assSP].unload;
//							}
//						}
//				}
//				GoThroughVehicle(idVeh, nextT, varcost, varvioTWC, varvioTWSP, cStartS, assSP, firstC_nextT);
//			}//end delete the last cus
//	}//end if (seg[idVeh].Trip[nextT].Type == 0 || 2)
//}
//
//
//
//
//void Solution::Update_deleteCusArrayP_LastTrip(int idVeh, int idTrip) //only applied for the case where vehicle has >= 2 trips
//{
//	//see on 2/12/2013
//	int numC = seg[idVeh].Trip[idTrip].numCus;
//	int curC, preC, preC1;
//	double varcost, varvioTWC, varvioTWSP, cStartS, cArrTime, cArrTimeI, temp;
//	int vioCapNEW;
//	int lastTrip = seg[idVeh].numTrips-1;
//	int deletednode;
//
//	int assSP = seg[idVeh].Trip[idTrip].assSP;
//	deletednode = seg[idVeh].Trip[idTrip].firstCus;
//	
//	int preT = idTrip - 1; 
//	if (seg[idVeh].Trip[preT].Type == 0) 
//	{
//		preC1 = seg[idVeh].Trip[preT].assSP;
//		cStartS = seg[idVeh].Trip[preT].leaveSP;
//	}
//	else 
//	{
//		preC1 = seg[idVeh].Trip[preT].lastCus;
//		cStartS = depart[preC1];
//	}	
//
//	int capOLD = seg[idVeh].Trip[idTrip].capacity;
//	int vioCapOLD = seg[idVeh].Trip[idTrip].vioCAP;
//	int curC1 = nextArr[deletednode];
//
//	//1. Delete the first and middle pickup customers:
//	while (curC1 > 0)
//	{
//		varvioTWC = -vioTWCus[deletednode]; //Update 7/11/2013
//		varvioTWSP = 0;
//		varcost = problem->c[preC1][curC1] - (problem->c[preC1][deletednode] + problem->c[deletednode][curC1]);
//		preC = preC1; curC = curC1;
//		do
//		{
//			cArrTime = cStartS + problem->c[preC][curC];
//			cStartS = PDS_MAX(cArrTime, problem->node[curC].sTW);
//			temp = cStartS - problem->node[curC].eTW;
//			if (temp > eps)
//			{
//					varvioTWC += (temp - vioTWCus[curC]);
//					if (vioTWCus[curC] > eps) goto Update;
//					cStartS = problem->node[curC].depart;
//			}
//			else 
//			{
//				varvioTWC -= vioTWCus[curC];
//				if (PDSDIF(cStartS, startS[curC])== 0) goto Update;
//				cStartS += problem->node[curC].duration;
//			}
//			preC = curC; curC = nextArr[curC];
//		} while (curC > 0);
//		calChangeCONNECTAtSP_PickTrip(preC, idVeh, idTrip, cStartS, varvioTWSP, varcost);
//		Update:
//			deleteCus[deletednode]->var_cost = varcost;
//			deleteCus[deletednode]->var_vioTWC = varvioTWC;
//			deleteCus[deletednode]->var_vioTWSP = varvioTWSP;
//			vioCapNEW = PDS_MAX(capOLD - problem->node[deletednode].capacity- problem->Q,0);
//			deleteCus[deletednode]->var_vioCAP = vioCapNEW - vioCapOLD;
//			deleteCus[deletednode]->atIT = IT;
//			deleteCus[deletednode]->empty = 0;
//
//		//New delete customer:
//		preC1 = deletednode; cStartS = depart[preC1];
//		deletednode = curC1; curC1 = nextArr[curC1];
//	}//end while (curC1 > 0)
//	
//	//2. Delete the last pickup customer:
//	vioCapNEW = PDS_MAX(capOLD - problem->node[deletednode].capacity- problem->Q,0);
//	deleteCus[deletednode]->var_vioCAP = vioCapNEW - vioCapOLD;
//	deleteCus[deletednode]->var_vioTWC = -vioTWCus[deletednode];
//	deleteCus[deletednode]->atIT = IT;
//	deleteCus[deletednode]->empty = 0;
//
//	cArrTime = depart[preC1] + problem->c[preC1][assSP];
//	if (PDSINRANGE(cArrTime, problem->nodeSP[assSP].sTW1, problem->nodeSP[assSP].eTW1))
//	{
//		//before deletion has to go to sp directly: FEA OR INFEA: NOT ALWAYS Update 7/11/2013
//		deleteCus[deletednode]->var_vioTWSP = -seg[idVeh].Trip[idTrip].vioTWSP;
//		if (seg[idVeh].Trip[idTrip].waitingS == NO_WS)
//			deleteCus[deletednode]->var_cost = problem->c[preC1][assSP] - (problem->c[preC1][deletednode] + problem->c[deletednode][assSP]);
//		else 
//			deleteCus[deletednode]->var_cost = problem->c[preC1][assSP] - (problem->c[preC1][deletednode] + problem->disCWSSP[deletednode][assSP]);
//
//	}
//	else
//	{
//			temp = cArrTime - problem->nodeSP[assSP].eTW1;
//			if (temp > eps)
//			{
//				//before deletion has to go to sp directly: INFEA NOT ALWAYS: Update 7/11/2013
//				deleteCus[deletednode]->var_vioTWSP = temp - seg[idVeh].Trip[idTrip].vioTWSP;
//				if (seg[idVeh].Trip[idTrip].waitingS == NO_WS)
//					deleteCus[deletednode]->var_cost = problem->c[preC1][assSP] - (problem->c[preC1][deletednode] + problem->c[deletednode][assSP]);
//				else 
//					deleteCus[deletednode]->var_cost = problem->c[preC1][assSP] - (problem->c[preC1][deletednode] + problem->disCWSSP[deletednode][assSP]);
//			}
//			else
//			{
//				cArrTimeI = depart[preC1] + problem->disCWSSP[preC1][assSP];
//				temp = cArrTimeI - problem->nodeSP[assSP].eTW1;
//				if (temp > eps) //too soon to go sp directly, too late to go through WS:
//				{
//					deleteCus[deletednode]->var_vioTWSP = problem->nodeSP[assSP].sTW1 - cArrTime - seg[idVeh].Trip[idTrip].vioTWSP;
//					//before deletion has to go to sp directly: FEA OR INFEA NOT ALWAYS Update 7/11/2013
//					if (seg[idVeh].Trip[idTrip].waitingS == NO_WS)
//						deleteCus[deletednode]->var_cost = problem->c[preC1][assSP] - (problem->c[preC1][deletednode] + problem->c[deletednode][assSP]);
//					else 
//						deleteCus[deletednode]->var_cost = problem->c[preC1][assSP] - (problem->c[preC1][deletednode] + problem->disCWSSP[deletednode][assSP]);
//				}
//				else //to go through WS
//				{
//                    deleteCus[deletednode]->var_vioTWSP = -seg[idVeh].Trip[idTrip].vioTWSP;
//					//before deletion may go to sp directly or through WS:
//					if (seg[idVeh].Trip[idTrip].waitingS == NO_WS)
//						deleteCus[deletednode]->var_cost = problem->disCWSSP[preC1][assSP] - (problem->c[preC1][deletednode] + problem->c[deletednode][assSP]);
//					else 
//						deleteCus[deletednode]->var_cost = problem->disCWSSP[preC1][assSP] - (problem->c[preC1][deletednode] + problem->disCWSSP[deletednode][assSP]);
//				}
//			}
//	}
//}
//
//
//
//void Solution::GoThroughVehicle_FirstPT(int idVeh, int curT, double &varcost, double &varvioTWC, double &varvioTWSP)
//{
//	//see on 2/12/2013
//	int preC,preT, assSP;
//	double cArrTime, temp, cStartS;
//	int lastTrip = seg[idVeh].numTrips - 1;
//	bool stop;
//
//	//Update 11/11/2013
//
//	assSP = seg[idVeh].Trip[curT].assSP;
//
//	if (seg[idVeh].Trip[curT].numCus == 1) //curT is the first pickup trip and has 1 customers:
//	{
//	    int curC = seg[idVeh].Trip[curT].firstCus;
//		//cStartS = problem->startSOneP[id][assSP] + problem->node[id].duration;
//		if (problem->waitingSOneP[curC][assSP])
//		{
//				//cStartS = PDS_MAX(cStartS + problem->disCWSSP[id][assSP], problem->nodeSP[assSP].sTW1);
//				if (seg[idVeh].Trip[curT].waitingS == NO_WS)
//					varcost += (problem->disCWSSP[curC][assSP] - problem->c[curC][assSP]);
//		}
//		else
//		{
//				//cStartS += problem->c[id][assSP];
//				if (seg[idVeh].Trip[curT].waitingS != NO_WS)
//					varcost += (problem->c[curC][assSP] - problem->disCWSSP[curC][assSP]);
//		}
//		//cStartS += problem->nodeSP[assSP].unload;
//		cStartS = problem->leaveSPOneP[curC][assSP];
//		varvioTWSP -= seg[idVeh].Trip[curT].vioTWSP;
//		varvioTWC -= vioTWCus[curC];
//		if (lastTrip > curT) //not the last pickup trip yet:
//		{
//			preT = curT; curT += 1;
//			if (seg[idVeh].Trip[curT].Type == 1) 
//			{
//				int assSP1 = seg[idVeh].Trip[curT].assSP;
//				if (assSP == assSP1) //p-d trip
//				{
//					varvioTWSP -= seg[idVeh].Trip[curT].vioTWSP;
//					cStartS += problem->nodeSP[assSP].load; //it's fine because the first pickup trip doesn't have vioTWSP
//					preC = assSP1;
//				}
//				else //p - assSP - assSP1 - d
//				{
//					stop = calChangeCONNECTAtSP_SPSP(idVeh, curT, preT, cStartS, varvioTWSP, varcost);
//					if (stop) return;
//					preC = assSP1;
//				}//end p - assSP - assSP1 - d
//			}
//			else //if(seg[idVeh].Trip[curT].Type == 0 || 2): p - p OR p - C2C
//			{
//				preC = assSP;
//				//curC = seg[idVeh].Trip[curT].firstCus;
//			}//end if (seg[idVeh].Trip[curT].Type == 0)
//		}
//		else return;
//	}
//	else //curT is the first pickup trip and has >= 2 customers;
//	{
//		preC = 0; cStartS = 0;
//	}//end //curT is the first pickup trip and has >= 2 customers
//
//    int curC = seg[idVeh].Trip[curT].firstCus;
//	do
//	{
//		if (seg[idVeh].Trip[curT].Type == 1)
//		{
//			while (curC > 0)
//			{
//				cArrTime = cStartS + problem->c[preC][curC];
//				cStartS = PDS_MAX(cArrTime, problem->node[curC].sTW);
//				temp = cStartS - problem->node[curC].eTW;
//				if (temp > eps)
//				{
//					varvioTWC += (temp - vioTWCus[curC]);
//					if (vioTWCus[curC] > eps) return;
//					cStartS = problem->node[curC].eTW;
//				}
//				else varvioTWC -= vioTWCus[curC];
//				if (PDSDIF(cStartS, startS[curC])==0) return;
//				cStartS += problem->node[curC].duration;
//				preC = curC; curC = nextArr[curC];
//			}//end while (curC > 0)
//			if (curT < lastTrip) //not the last trip yet: 
//			{
//				preT = curT; curT++; //preC now points to the last delivery cus of trip preT
//				curC = seg[idVeh].Trip[curT].firstCus;
//				if (seg[idVeh].Trip[curT].Type == 1) // del trip - del trip
//				{
//				    stop = calChangeCONNECTAtSP_DD(preC, idVeh, curT, preT, cStartS, varvioTWSP, varcost);
//					if (stop) return;
//					preC = seg[idVeh].Trip[curT].assSP; 
//				}
//				/*else //del trip - pick trip OR deltrip - C2C
//				{
//					curC = seg[idVeh].Trip[curT].firstCus;
//				}*/
//			}//end if (curT < lastTrip) //not the last delivery trip yet
//			else break; //cont = 0; already the last trip
//		}
//		else if (seg[idVeh].Trip[curT].Type == 0)
//		{
//			while (curC > 0)
//			{
//				cArrTime = cStartS + problem->c[preC][curC];
//				cStartS = PDS_MAX(cArrTime, problem->node[curC].sTW);
//				temp = cStartS - problem->node[curC].eTW;
//				if (temp > eps)
//				{
//					varvioTWC += (temp - vioTWCus[curC]);
//					if (vioTWCus[curC] > eps) return;
//					cStartS = problem->node[curC].eTW;
//				}
//				else varvioTWC -= vioTWCus[curC];
//				if (PDSDIF(cStartS, startS[curC])==0) return;
//				cStartS += problem->node[curC].duration;
//				preC = curC; curC = nextArr[curC];
//			} //end while (curC > 0)
//			/*double varvioTWSP1 = 0;
//		    stop = calChangeCONNECTAtSP_PickTrip(preC, idVeh, curT, cStartS, varvioTWSP1, varcost);
//			varvioTWSP += varvioTWSP1;*/
//			bool vioTWSPTRUE;
//			stop = calChangeCONNECTAtSP_PickTrip(preC, idVeh, curT, cStartS, varvioTWSP, varcost, vioTWSPTRUE);
//			
//			if (stop) return;
//			if (curT < lastTrip) //not the last pickup trip yet:
//			{
//				preT = curT; curT++;
//				assSP = seg[idVeh].Trip[preT].assSP;
//				if (seg[idVeh].Trip[curT].Type == 1) 
//				{
//					int assSP1 = seg[idVeh].Trip[curT].assSP;
//					if (assSP == assSP1) //p-d trip
//					{
//						//varvioTWSP += varvioTWSP1;
//						//Update 16/11/2013
//						if (vioTWSPTRUE) cStartS = problem->leaveSP[assSP][1]; //load only at eTW2
//						else cStartS += problem->nodeSP[assSP].load;
//						preC = assSP1;
//						curC = seg[idVeh].Trip[curT].firstCus;
//					}
//					else //p - assSP - assSP1 - d
//					{
//						stop = calChangeCONNECTAtSP_SPSP(idVeh, curT, preT, cStartS, varvioTWSP, varcost);
//						if (stop) return;
//						preC = assSP1; curC = seg[idVeh].Trip[curT].firstCus;
//					}//end p - assSP - assSP1 - d
//				}
//				else //if(seg[idVeh].Trip[curT].Type == 0||2): p - p OR p - C2C
//				{
//					preC = assSP;
//					curC = seg[idVeh].Trip[curT].firstCus;
//				}//end if (seg[idVeh].Trip[curT].Type == 0)
//			}
//			else break; //cont = 0; curT is already the last pickup trip
//		}//end trip curT is pickup
//		else //curT is C2C
//		{
//			while (curC > 0)
//			{
//				cArrTime = cStartS + problem->c[preC][curC];
//				cStartS = PDS_MAX(cArrTime, problem->node[curC].sTW);
//				temp = cStartS - problem->node[curC].eTW;
//				if (temp > eps)
//				{
//					varvioTWC += (temp - vioTWCus[curC]);
//					if (vioTWCus[curC] > eps) return;
//					cStartS = problem->node[curC].eTW;
//				}
//				else varvioTWC -= vioTWCus[curC];
//				if (PDSDIF(cStartS, startS[curC])==0) return;
//				cStartS += problem->node[curC].duration;
//				preC = curC; curC = nextArr[curC];
//			} //end while (curC > 0)
//
//			if (curT < lastTrip) //not the last pickup trip yet:
//			{
//				preT = curT; curT++;
//				if (seg[idVeh].Trip[curT].Type == 1) 
//				{
//					stop = calChangeCONNECTAtSP_C2CTrip(preC,idVeh,preT,curT,cStartS,varvioTWSP,varcost);
//					if (stop) return;
//					preC = seg[idVeh].Trip[curT].assSP;
//					curC = seg[idVeh].Trip[curT].firstCus;
//				}
//				else //if(seg[idVeh].Trip[curT].Type == 0): p - p; CAN NOT p - C2C
//				{
//					curC = seg[idVeh].Trip[curT].firstCus;
//				}//end if (seg[idVeh].Trip[curT].Type == 0)
//			}
//			else break; //cont = 0; curT is already the last pickup trip
//		}//end curT is C2C
//	}while (1);
//}
//
//void Solution::GoThroughVehicle_FirstC2C(int idVeh, int curT, double &varcost, double &varvioTWC, double &varvioTWSP)
//{
//	//Updated 27/11/2013
//	int preC,preT, assSP;
//	double cArrTime, temp, cStartS;
//	int lastTrip = seg[idVeh].numTrips - 1;
//	bool stop;
//
//	assSP = seg[idVeh].Trip[curT].nextSP;
//
//	if (seg[idVeh].Trip[curT].numCus == 2 && seg[idVeh].Trip[curT].nextSP > 0) //curT is the first C2C trip and has 1 customer and nextT is Dtrip:
//	{
//	    int curC = seg[idVeh].Trip[curT].firstCus;
//		int nextC = nextArr[curC];
//		if (problem->waitingSOneP[curC][assSP])
//		{
//				if (seg[idVeh].Trip[curT].waitingS == NO_WS)
//					varcost += (problem->disCWSSP[nextC][assSP] - problem->c[nextC][assSP]);
//		}
//		else
//		{
//				if (seg[idVeh].Trip[curT].waitingS != NO_WS)
//					varcost += (problem->c[nextC][assSP] - problem->disCWSSP[nextC][assSP]);
//		}
//		cStartS = problem->leaveSPOneP[curC][assSP];
//		preT = curT; curT += 1; //for sure seg[idVeh].Trip[curT].Type==1 
//		varvioTWSP -= seg[idVeh].Trip[curT].vioTWSP;
//		varvioTWC -= vioTWCus[curC];
//	
//		varvioTWSP -= seg[idVeh].Trip[curT].vioTWSP;
//		//cStartS += problem->nodeSP[assSP].load; //it's ok because the first pickup trip doesn't vioTWSP
//		preC = assSP;
//	}
//	else //curT is the first pickup trip and has >= 2 customers;
//	{
//		preC = 0; cStartS = 0;
//	}//end //curT is the first pickup trip and has >= 2 customers
//
//    int curC = seg[idVeh].Trip[curT].firstCus;
//	do
//	{
//		if (seg[idVeh].Trip[curT].Type == 1)
//		{
//			while (curC > 0)
//			{
//				cArrTime = cStartS + problem->c[preC][curC];
//				cStartS = PDS_MAX(cArrTime, problem->node[curC].sTW);
//				temp = cStartS - problem->node[curC].eTW;
//				if (temp > eps)
//				{
//					varvioTWC += (temp - vioTWCus[curC]);
//					if (vioTWCus[curC] > eps) return;
//					cStartS = problem->node[curC].eTW;
//				}
//				else varvioTWC -= vioTWCus[curC];
//				if (PDSDIF(cStartS, startS[curC])==0) return;
//				cStartS += problem->node[curC].duration;
//				preC = curC; curC = nextArr[curC];
//			}//end while (curC > 0)
//			if (curT < lastTrip) //not the last trip yet: 
//			{
//				preT = curT; curT++; //preC now points to the last delivery cus of trip preT
//				curC = seg[idVeh].Trip[curT].firstCus;
//				if (seg[idVeh].Trip[curT].Type == 1) // del trip - del trip
//				{
//				    stop = calChangeCONNECTAtSP_DD(preC, idVeh, curT, preT, cStartS, varvioTWSP, varcost);
//					if (stop) return;
//					preC = seg[idVeh].Trip[curT].assSP; 
//				}
//				/*else //del trip - pick trip OR deltrip - C2C
//				{
//					curC = seg[idVeh].Trip[curT].firstCus;
//				}*/
//			}//end if (curT < lastTrip) //not the last delivery trip yet
//			else break; //cont = 0; already the last trip
//		}
//		else if (seg[idVeh].Trip[curT].Type == 0)
//		{
//			while (curC > 0)
//			{
//				cArrTime = cStartS + problem->c[preC][curC];
//				cStartS = PDS_MAX(cArrTime, problem->node[curC].sTW);
//				temp = cStartS - problem->node[curC].eTW;
//				if (temp > eps)
//				{
//					varvioTWC += (temp - vioTWCus[curC]);
//					if (vioTWCus[curC] > eps) return;
//					cStartS = problem->node[curC].eTW;
//				}
//				else varvioTWC -= vioTWCus[curC];
//				if (PDSDIF(cStartS, startS[curC])==0) return;
//				cStartS += problem->node[curC].duration;
//				preC = curC; curC = nextArr[curC];
//			} //end while (curC > 0)
//			bool vioTWSPTRUE;
//			stop = calChangeCONNECTAtSP_PickTrip(preC, idVeh, curT, cStartS, varvioTWSP, varcost, vioTWSPTRUE);
//			
//			if (stop) return;
//			if (curT < lastTrip) //not the last pickup trip yet:
//			{
//				preT = curT; curT++;
//				assSP = seg[idVeh].Trip[preT].assSP;
//				if (seg[idVeh].Trip[curT].Type == 1) 
//				{
//					int assSP1 = seg[idVeh].Trip[curT].assSP;
//					if (assSP == assSP1) //p-d trip
//					{
//						//varvioTWSP += varvioTWSP1;
//						//Update 16/11/2013
//						if (vioTWSPTRUE) cStartS = problem->leaveSP[assSP][1]; //load only at eTW2
//						else cStartS += problem->nodeSP[assSP].load;
//						preC = assSP1;
//						curC = seg[idVeh].Trip[curT].firstCus;
//					}
//					else //p - assSP - assSP1 - d
//					{
//						stop = calChangeCONNECTAtSP_SPSP(idVeh, curT, preT, cStartS, varvioTWSP, varcost);
//						if (stop) return;
//						preC = assSP1; curC = seg[idVeh].Trip[curT].firstCus;
//					}//end p - assSP - assSP1 - d
//				}
//				else //if(seg[idVeh].Trip[curT].Type == 0||2): p - p OR p - C2C
//				{
//					preC = assSP;
//					curC = seg[idVeh].Trip[curT].firstCus;
//				}//end if (seg[idVeh].Trip[curT].Type==0)
//			}
//			else break; //cont = 0; curT is already the last pickup trip
//		}//end trip curT is pickup
//		else //curT is C2C
//		{
//			while (curC > 0)
//			{
//				cArrTime = cStartS + problem->c[preC][curC];
//				cStartS = PDS_MAX(cArrTime, problem->node[curC].sTW);
//				temp = cStartS - problem->node[curC].eTW;
//				if (temp > eps)
//				{
//					varvioTWC += (temp - vioTWCus[curC]);
//					if (vioTWCus[curC] > eps) return;
//					cStartS = problem->node[curC].eTW;
//				}
//				else varvioTWC -= vioTWCus[curC];
//				if (PDSDIF(cStartS, startS[curC])==0) return;
//				cStartS += problem->node[curC].duration;
//				preC = curC; curC = nextArr[curC];
//			} //end while (curC > 0)
//
//			if (curT < lastTrip) //not the last pickup trip yet:
//			{
//				preT = curT; curT++;
//				if (seg[idVeh].Trip[curT].Type == 1) 
//				{
//					stop = calChangeCONNECTAtSP_C2CTrip(preC,idVeh,preT,curT,cStartS,varvioTWSP,varcost);
//					if (stop) return;
//					preC = seg[idVeh].Trip[curT].assSP;
//					curC = seg[idVeh].Trip[curT].firstCus;
//				}
//				else //if(seg[idVeh].Trip[curT].Type == 0): p - p; CAN NOT p - C2C
//				{
//					curC = seg[idVeh].Trip[curT].firstCus;
//				}//end if (seg[idVeh].Trip[curT].Type == 0)
//			}
//			else break; //cont = 0; curT is already the last pickup trip
//		}//end curT is C2C
//	}while (1);
//}




//void Solution::GoThroughVehicle(int idVeh, int curT, double &varcost, double &varvioTWC, double &varvioTWSP, double cStartS, int preC, int curC)
//{
//	//See on 2/12/2013
//	int preT, assSP;
//	double cArrTime, temp;
//	int lastTrip = seg[idVeh].numTrips - 1;
//	bool stop;
//
//	do
//	{
//		if (seg[idVeh].Trip[curT].Type == 1)
//		{
//			while (curC > 0)
//			{
//				cArrTime = cStartS + problem->c[preC][curC];
//				cStartS = PDS_MAX(cArrTime, problem->node[curC].sTW);
//				temp = cStartS - problem->node[curC].eTW;
//				if (temp > eps)
//				{
//					varvioTWC += (temp - vioTWCus[curC]);
//					if (vioTWCus[curC] > eps) return;
//					cStartS = problem->node[curC].eTW;
//				}
//				else varvioTWC -= vioTWCus[curC];
//				if (PDSDIF(cStartS, startS[curC])==0) return;
//				cStartS += problem->node[curC].duration;
//				preC = curC; curC = nextArr[curC];
//			}//end while (curC > 0)
//			if (curT < lastTrip) //not the last trip yet: 
//			{
//				preT = curT; curT++; //preC now points to the last delivery cus of trip preT
//				curC = seg[idVeh].Trip[curT].firstCus;
//				if (seg[idVeh].Trip[curT].Type == 1) // del trip - del trip
//				{
//					//cout<<"(a) vioTWSP = "<<vioTWSP<<"; ";
//				    stop = calChangeCONNECTAtSP_DD(preC, idVeh, curT, preT, cStartS, varvioTWSP, varcost);
//					//cout<<"(b) vioTWSP = "<<vioTWSP<<"; ";
//					if (stop) return;
//					preC = seg[idVeh].Trip[curT].assSP; 
//				}
//				/*else //del trip - pick trip
//				{
//					curC = seg[idVeh].Trip[curT].firstCus;
//				}*/
//			}//end if (curT < lastTrip) //not the last delivery trip yet
//			else break; //cont = 0; already the last trip
//		}
//		else if (seg[idVeh].Trip[curT].Type == 0)
//		{
//			while (curC > 0)
//			{
//				cArrTime = cStartS + problem->c[preC][curC];
//				cStartS = PDS_MAX(cArrTime, problem->node[curC].sTW);
//				temp = cStartS - problem->node[curC].eTW;
//				if (temp > eps)
//				{
//					varvioTWC += (temp - vioTWCus[curC]);
//					if (vioTWCus[curC] > eps) return;
//					cStartS = problem->node[curC].eTW;
//				}
//				else varvioTWC -= vioTWCus[curC];
//				if (PDSDIF(cStartS, startS[curC])==0) return;
//				cStartS += problem->node[curC].duration;
//				preC = curC; curC = nextArr[curC];
//			} //end while (curC > 0)
//			/*double varvioTWSP1 = 0;
//		    stop = calChangeCONNECTAtSP_PickTrip(preC, idVeh, curT, cStartS, varvioTWSP1, varcost);
//			varvioTWSP += varvioTWSP1;*/
//			bool vioTWSPTRUE;
//			//cout<<"(c) vioTWSP = "<<vioTWSP<<"; ";
//			stop = calChangeCONNECTAtSP_PickTrip(preC, idVeh, curT, cStartS, varvioTWSP, varcost, vioTWSPTRUE);
//			//cout<<"(d) vioTWSP = "<<vioTWSP<<"; ";
//			
//			if (stop) return;
//			if (curT < lastTrip) //not the last pickup trip yet:
//			{
//				preT = curT; curT++;
//				assSP = seg[idVeh].Trip[preT].assSP;
//				if (seg[idVeh].Trip[curT].Type == 1) 
//				{
//					int assSP1 = seg[idVeh].Trip[curT].assSP;
//					if (assSP == assSP1) //p-d trip
//					{
//						//varvioTWSP += varvioTWSP1;
//						//Update 16/11/2013
//						if (vioTWSPTRUE) cStartS = problem->leaveSP[assSP][1]; //load only at eTW2
//						else cStartS += problem->nodeSP[assSP].load;
//						preC = assSP1;
//						curC = seg[idVeh].Trip[curT].firstCus;
//					}
//					else //p - assSP - assSP1 - d
//					{
//						stop = calChangeCONNECTAtSP_SPSP(idVeh, curT, preT, cStartS, varvioTWSP, varcost);
//						//cout<<"(e) vioTWSP = "<<vioTWSP<<"; ";
//						if (stop) return;
//						preC = assSP1; curC = seg[idVeh].Trip[curT].firstCus;
//					}//end p - assSP - assSP1 - d
//				}
//				else //if(seg[idVeh].Trip[curT].Type == 0|| 2): p - p || p - C2C
//				{
//					preC = assSP;
//					curC = seg[idVeh].Trip[curT].firstCus;
//				}//end if (seg[idVeh].Trip[curT].Type==0)
//			}
//			else break; //cont = 0; curT is already the last pickup trip
//		}//end trip curT is pickup
//		else //curT is C2C
//		{
//			while (curC > 0)
//			{
//				cArrTime = cStartS + problem->c[preC][curC];
//				cStartS = PDS_MAX(cArrTime, problem->node[curC].sTW);
//				temp = cStartS - problem->node[curC].eTW;
//				if (temp > eps)
//				{
//					varvioTWC += (temp - vioTWCus[curC]);
//					if (vioTWCus[curC] > eps) return;
//					cStartS = problem->node[curC].eTW;
//				}
//				else varvioTWC -= vioTWCus[curC];
//				if (PDSDIF(cStartS, startS[curC])==0) return;
//				cStartS += problem->node[curC].duration;
//				preC = curC; curC = nextArr[curC];
//			} //end while (curC > 0)
//			if (curT < lastTrip) //not the last pickup trip yet:
//			{
//				preT = curT; curT++;
//				if (seg[idVeh].Trip[curT].Type == 1)
//				{
//					stop = calChangeCONNECTAtSP_C2CTrip(preC, idVeh,preT, curT, cStartS, varvioTWSP, varcost);
//					//cout<<"(f) vioTWSP = "<<vioTWSP<<"; ";
//					if (stop) return;
//					preC = seg[idVeh].Trip[curT].assSP;
//					curC = seg[idVeh].Trip[curT].firstCus;
//				}
//				else //if (seg[idVeh].Trip[curT].Type == 0 || 2)  CAN NOT C2C
//				{
//					curC = seg[idVeh].Trip[curT].firstCus;
//				}
//			}
//			else break; //cont = 0; curT is already the last C2C trip
//		}// end curT is C2C
//	}while (1);
//}
//
//bool Solution::GoThroughVehicle_FirstPT(int idVeh, int curT, int numTrips, double &varcost, double &varvioTWC, double &varvioTWSP, double &cStartS)
//{
//	//See on 2/12/2013
//	int preC, curC, preT, assSP;
//	double cArrTime, temp;
//	bool stop;
//
//	if (seg[idVeh].Trip[curT].numCus == 1)
//	{
//		assSP = seg[idVeh].Trip[curT].assSP;
//		int id = seg[idVeh].Trip[curT].firstCus;
//		//cStartS = problem->startSOneP[id][assSP] + problem->node[id].duration;
//		if (problem->waitingSOneP[id][assSP])
//		{
//			//cStartS = PDS_MAX(cStartS + problem->disCWSSP[id][assSP], problem->nodeSP[assSP].sTW1);
//			if (seg[idVeh].Trip[curT].waitingS == NO_WS)
//				varcost += (problem->disCWSSP[id][assSP] - problem->c[id][assSP]);
//		}
//		else
//		{
//			//cStartS += problem->c[id][assSP];
//			if (seg[idVeh].Trip[curT].waitingS != NO_WS)
//				varcost += (problem->c[id][assSP] - problem->disCWSSP[id][assSP]);
//		}
//		//cStartS += problem->nodeSP[assSP].unload;
//        cStartS = problem->leaveSPOneP[id][assSP];
//		varvioTWSP -= seg[idVeh].Trip[curT].vioTWSP;
//		varvioTWC -= vioTWCus[id];
//	
//		if (numTrips > curT) 
//		{
//				preT = curT; curT += 1;
//				if (seg[idVeh].Trip[curT].Type == 1) 
//				{
//					int assSP1 = seg[idVeh].Trip[curT].assSP;
//					if (assSP == assSP1) //p-d trip
//					{
//						varvioTWSP -= seg[idVeh].Trip[curT].vioTWSP;
//						cStartS += problem->nodeSP[assSP].load; //it's ok because the first pickup trip doesn't vioTWSP
//						preC = assSP1;
//					}
//					else //p - assSP - assSP1 - d
//					{
//						stop = calChangeCONNECTAtSP_SPSP(idVeh, curT, preT, cStartS, varvioTWSP, varcost);
//						if (stop) return 1;
//						preC = assSP1;
//					}//end p - assSP - assSP1 - d
//				}
//				else //if(seg[idVeh].Trip[curT].Type == 0||2): p - p OR p - C2C
//				{
//					preC = assSP;
//					//curC = seg[idVeh].Trip[curT].firstCus;
//				}//end if (seg[idVeh].Trip[curT].Type == 0)
//				numTrips -= 1;
//		}
//		else return 1;
//	}
//	else //curT is the first cus and has >= 2 customers
//	{
//		preC = 0; cStartS = 0;
//	}
//	
//	for (int i=1; i <= numTrips;i++)
//	{
//		curC = seg[idVeh].Trip[curT].firstCus;
//		if (seg[idVeh].Trip[curT].Type == 1)
//		{
//			while (curC > 0)
//			{
//				cArrTime = cStartS + problem->c[preC][curC];
//				cStartS = PDS_MAX(cArrTime, problem->node[curC].sTW);
//				temp = cStartS - problem->node[curC].eTW;
//				if (temp > eps)
//				{
//					varvioTWC += (temp - vioTWCus[curC]);
//					if (vioTWCus[curC] > eps) return 1;
//					cStartS = problem->node[curC].eTW;
//				}
//				else varvioTWC -= vioTWCus[curC];
//				if (PDSDIF(cStartS, startS[curC])==0) return 1;
//				cStartS += problem->node[curC].duration;
//				preC = curC; curC = nextArr[curC];
//			}//end while (curC > 0)
//			if (i < numTrips)
//			{
//				preT = curT; curT++; //preC now points to the last delivery cus of trip preT
//				curC = seg[idVeh].Trip[curT].firstCus;
//				if (seg[idVeh].Trip[curT].Type == 1) // del trip - del trip
//				{
//						stop = calChangeCONNECTAtSP_DD(preC, idVeh, curT, preT, cStartS, varvioTWSP, varcost);
//						if (stop) return 1;
//						preC = seg[idVeh].Trip[curT].assSP; 
//				}
//				/*else //del trip - pick trip OR del - C2C
//					{
//						curC = seg[idVeh].Trip[curT].firstCus;
//					}*/
//			}
//		}
//		else if (seg[idVeh].Trip[curT].Type == 0)
//		{
//			while (curC > 0)
//			{
//				cArrTime = cStartS + problem->c[preC][curC];
//				cStartS = PDS_MAX(cArrTime, problem->node[curC].sTW);
//				temp = cStartS - problem->node[curC].eTW;
//				if (temp > eps)
//				{
//					varvioTWC += (temp - vioTWCus[curC]);
//					if (vioTWCus[curC] > eps) return 1;
//					cStartS = problem->node[curC].eTW;
//				}
//				else varvioTWC -= vioTWCus[curC];
//				if (PDSDIF(cStartS, startS[curC]) == 0) return 1;
//				cStartS += problem->node[curC].duration;
//				preC = curC; curC = nextArr[curC];
//			} //end while (curC > 0)
//			/*double varvioTWSP1 = 0;
//		    stop = calChangeCONNECTAtSP_PickTrip(preC, idVeh, curT, cStartS, varvioTWSP1, varcost);
//			varvioTWSP += varvioTWSP1;*/
//			bool vioTWSPTRUE;
//		    stop = calChangeCONNECTAtSP_PickTrip(preC, idVeh, curT, cStartS, varvioTWSP, varcost, vioTWSPTRUE);
//			if (stop) return 1;
//
//			if (i < numTrips)
//			{
//				preT = curT; curT++;
//				assSP = seg[idVeh].Trip[preT].assSP;
//				if (seg[idVeh].Trip[curT].Type == 1) 
//				{
//					int assSP1 = seg[idVeh].Trip[curT].assSP;
//					if (assSP == assSP1) //p-d trip
//					{
//						//varvioTWSP += varvioTWSP1;
//						//Update 16/11/2013
//						if (vioTWSPTRUE) cStartS = problem->leaveSP[assSP][1]; //load only at eTW2
//						else cStartS += problem->nodeSP[assSP].load;
//						preC = assSP1;
//						curC = seg[idVeh].Trip[curT].firstCus;
//					}
//					else //p - assSP - assSP1 - d
//					{
//						stop = calChangeCONNECTAtSP_SPSP(idVeh, curT, preT, cStartS, varvioTWSP, varcost);
//						if (stop) return 1;
//						preC = assSP1; curC = seg[idVeh].Trip[curT].firstCus;
//					}//end p - assSP - assSP1 - d
//				}
//				else //if (seg[idVeh].Trip[curT].Type == 0 || 2): p - p OR p - C2C
//				{
//					preC = assSP;
//					curC = seg[idVeh].Trip[curT].firstCus;
//				}//end if (seg[idVeh].Trip[curT].Type == 0)
//			}
//		}//end trip curT is pickup
//		else //trip curT is C2C
//		{
//			while (curC > 0)
//			{
//				cArrTime = cStartS + problem->c[preC][curC];
//				cStartS = PDS_MAX(cArrTime, problem->node[curC].sTW);
//				temp = cStartS - problem->node[curC].eTW;
//				if (temp > eps)
//				{
//					varvioTWC += (temp - vioTWCus[curC]);
//					if (vioTWCus[curC] > eps) return 1;
//					cStartS = problem->node[curC].eTW;
//				}
//				else varvioTWC -= vioTWCus[curC];
//				if (PDSDIF(cStartS, startS[curC]) == 0) return 1;
//				cStartS += problem->node[curC].duration;
//				preC = curC; curC = nextArr[curC];
//			} //end while (curC > 0)
//
//			if (i < numTrips)
//			{
//				preT = curT; curT++;
//				if (seg[idVeh].Trip[curT].Type == 1)
//				{
//					stop = calChangeCONNECTAtSP_C2CTrip(preC,idVeh,preT,curT,cStartS,varvioTWSP,varcost);
//					if (stop) return 1;
//					preC = seg[idVeh].Trip[curT].assSP;
//					curC = seg[idVeh].Trip[curT].firstCus;
//				}
//				else //if (seg[idVeh].Trip[curT].Type == 0 || 2) //CAN NOT C2C
//				{
//					curC = seg[idVeh].Trip[curT].firstCus;
//				}
//			}
//		}//end trip curT is C2C
//	}
//	return 0;
//}
//
//
//bool Solution::GoThroughVehicle_FirstC2C(int idVeh, int curT, int numTrips, double &varcost, double &varvioTWC, double &varvioTWSP, double &cStartS)
//{
//	//Update 27/11/2013
//	//COPY GoThroughVehicle_FirstPT
//	int preC, curC, preT, assSP;
//	double cArrTime, temp;
//	bool stop;
//
//	if (seg[idVeh].Trip[curT].numCus == 2)
//	{
//		assSP = seg[idVeh].Trip[curT].nextSP;
//		int id = seg[idVeh].Trip[curT].firstCus;
//		int id1 = nextArr[id];
//		//cStartS = problem->startSOneP[id][assSP] + problem->node[id].duration;
//		if (problem->waitingSOneP[id][assSP])
//		{
//			//cStartS = PDS_MAX(cStartS + problem->disCWSSP[id][assSP], problem->nodeSP[assSP].sTW1);
//			if (seg[idVeh].Trip[curT].waitingS == NO_WS)
//				varcost += (problem->disCWSSP[id1][assSP] - problem->c[id1][assSP]);
//		}
//		else
//		{
//			//cStartS += problem->c[id][assSP];
//			if (seg[idVeh].Trip[curT].waitingS != NO_WS)
//				varcost += (problem->c[id1][assSP] - problem->disCWSSP[id1][assSP]);
//		}
//		//cStartS += problem->nodeSP[assSP].unload;
//        cStartS = problem->leaveSPOneP[id][assSP];
//		preT = curT; curT += 1; //for sure seg[idVeh].Trip[curT].Type==1 
//		varvioTWSP -= seg[idVeh].Trip[curT].vioTWSP;
//		varvioTWC -= (vioTWCus[id] + vioTWCus[id1]);
//	
//		varvioTWSP -= seg[idVeh].Trip[curT].vioTWSP;
//		//cStartS += problem->nodeSP[assSP].load; //it's ok because the first pickup trip doesn't vioTWSP
//		preC = assSP;
//		numTrips -= 1;
//	}
//	else //curT is the first cus and has >= 2 customers
//	{
//		preC = 0; cStartS = 0;
//	}
//	
//	for (int i=1; i <= numTrips;i++)
//	{
//		curC = seg[idVeh].Trip[curT].firstCus;
//		if (seg[idVeh].Trip[curT].Type == 1)
//		{
//			while (curC > 0)
//			{
//				cArrTime = cStartS + problem->c[preC][curC];
//				cStartS = PDS_MAX(cArrTime, problem->node[curC].sTW);
//				temp = cStartS - problem->node[curC].eTW;
//				if (temp > eps)
//				{
//					varvioTWC += (temp - vioTWCus[curC]);
//					if (vioTWCus[curC] > eps) return 1;
//					cStartS = problem->node[curC].eTW;
//				}
//				else varvioTWC -= vioTWCus[curC];
//				if (PDSDIF(cStartS, startS[curC])==0) return 1;
//				cStartS += problem->node[curC].duration;
//				preC = curC; curC = nextArr[curC];
//			}//end while (curC > 0)
//			if (i < numTrips)
//			{
//				preT = curT; curT++; //preC now points to the last delivery cus of trip preT
//				curC = seg[idVeh].Trip[curT].firstCus;
//				if (seg[idVeh].Trip[curT].Type == 1) // del trip - del trip
//				{
//						stop = calChangeCONNECTAtSP_DD(preC, idVeh, curT, preT, cStartS, varvioTWSP, varcost);
//						if (stop) return 1;
//						preC = seg[idVeh].Trip[curT].assSP; 
//				}
//				/*else //del trip - pick trip OR del - C2C
//					{
//						curC = seg[idVeh].Trip[curT].firstCus;
//					}*/
//			}
//		}
//		else if (seg[idVeh].Trip[curT].Type == 0)
//		{
//			while (curC > 0)
//			{
//				cArrTime = cStartS + problem->c[preC][curC];
//				cStartS = PDS_MAX(cArrTime, problem->node[curC].sTW);
//				temp = cStartS - problem->node[curC].eTW;
//				if (temp > eps)
//				{
//					varvioTWC += (temp - vioTWCus[curC]);
//					if (vioTWCus[curC] > eps) return 1;
//					cStartS = problem->node[curC].eTW;
//				}
//				else varvioTWC -= vioTWCus[curC];
//				if (PDSDIF(cStartS, startS[curC]) == 0) return 1;
//				cStartS += problem->node[curC].duration;
//				preC = curC; curC = nextArr[curC];
//			} //end while (curC > 0)
//			/*double varvioTWSP1 = 0;
//		    stop = calChangeCONNECTAtSP_PickTrip(preC, idVeh, curT, cStartS, varvioTWSP1, varcost);
//			varvioTWSP += varvioTWSP1;*/
//			bool vioTWSPTRUE;
//		    stop = calChangeCONNECTAtSP_PickTrip(preC, idVeh, curT, cStartS, varvioTWSP, varcost, vioTWSPTRUE);
//			if (stop) return 1;
//
//			if (i < numTrips)
//			{
//				preT = curT; curT++;
//				assSP = seg[idVeh].Trip[preT].assSP;
//				if (seg[idVeh].Trip[curT].Type == 1) 
//				{
//					int assSP1 = seg[idVeh].Trip[curT].assSP;
//					if (assSP == assSP1) //p-d trip
//					{
//						//varvioTWSP += varvioTWSP1;
//						//Update 16/11/2013
//						if (vioTWSPTRUE) cStartS = problem->leaveSP[assSP][1]; //load only at eTW2
//						else cStartS += problem->nodeSP[assSP].load;
//						preC = assSP1;
//						curC = seg[idVeh].Trip[curT].firstCus;
//					}
//					else //p - assSP - assSP1 - d
//					{
//						stop = calChangeCONNECTAtSP_SPSP(idVeh, curT, preT, cStartS, varvioTWSP, varcost);
//						if (stop) return 1;
//						preC = assSP1; curC = seg[idVeh].Trip[curT].firstCus;
//					}//end p - assSP - assSP1 - d
//				}
//				else //if (seg[idVeh].Trip[curT].Type == 0 || 2): p - p OR p - C2C
//				{
//					preC = assSP;
//					curC = seg[idVeh].Trip[curT].firstCus;
//				}//end if (seg[idVeh].Trip[curT].Type == 0)
//			}
//		}//end trip curT is pickup
//		else //trip curT is C2C
//		{
//			while (curC > 0)
//			{
//				cArrTime = cStartS + problem->c[preC][curC];
//				cStartS = PDS_MAX(cArrTime, problem->node[curC].sTW);
//				temp = cStartS - problem->node[curC].eTW;
//				if (temp > eps)
//				{
//					varvioTWC += (temp - vioTWCus[curC]);
//					if (vioTWCus[curC] > eps) return 1;
//					cStartS = problem->node[curC].eTW;
//				}
//				else varvioTWC -= vioTWCus[curC];
//				if (PDSDIF(cStartS, startS[curC]) == 0) return 1;
//				cStartS += problem->node[curC].duration;
//				preC = curC; curC = nextArr[curC];
//			} //end while (curC > 0)
//
//			if (i < numTrips)
//			{
//				preT = curT; curT++;
//				if (seg[idVeh].Trip[curT].Type == 1)
//				{
//					stop = calChangeCONNECTAtSP_C2CTrip(preC,idVeh,preT,curT,cStartS,varvioTWSP,varcost);
//					if (stop) return 1;
//					preC = seg[idVeh].Trip[curT].assSP;
//					curC = seg[idVeh].Trip[curT].firstCus;
//				}
//				else //if (seg[idVeh].Trip[curT].Type == 0 || 2) //CAN NOT C2C
//				{
//					curC = seg[idVeh].Trip[curT].firstCus;
//				}
//			}
//		}//end trip curT is C2C
//	}
//	return 0;
//}
//
//
//
//bool Solution::GoThroughVehicle(int idVeh, int curT, int numTrips, double &varcost, double &varvioTWC, double &varvioTWSP, double &cStartS, int preC, int curC)
//{
//	//See on 2/12/2013: return 1 if cStartS doesn't change; 0 otherwise
//	int preT, assSP;
//	double cArrTime, temp;
//	bool stop;
//	//int lastT = seg[idVeh].numTrips - 1;
//
//	for (int i=1; i <= numTrips;i++)
//	{
//		if (seg[idVeh].Trip[curT].Type == 1)
//		{
//			while (curC > 0)
//			{
//				cArrTime = cStartS + problem->c[preC][curC];
//				cStartS = PDS_MAX(cArrTime, problem->node[curC].sTW);
//				temp = cStartS - problem->node[curC].eTW;
//				if (temp > eps)
//				{
//					varvioTWC += (temp - vioTWCus[curC]);
//					if (vioTWCus[curC] > eps) return 1;
//					cStartS = problem->node[curC].eTW;
//				}
//				else varvioTWC -= vioTWCus[curC];
//				if (PDSDIF(cStartS, startS[curC])==0) return 1;
//				cStartS += problem->node[curC].duration;
//				preC = curC; curC = nextArr[curC];
//			}//end while (curC > 0)
//
//			if (i<numTrips)
//			{
//				preT = curT; curT++; //preC now points to the last delivery cus of trip preT
//				curC = seg[idVeh].Trip[curT].firstCus;
//				if (seg[idVeh].Trip[curT].Type == 1) // del trip - del trip
//				{
//					stop = calChangeCONNECTAtSP_DD(preC, idVeh, curT, preT, cStartS, varvioTWSP, varcost);
//					if (stop) return 1;
//					preC = seg[idVeh].Trip[curT].assSP; 
//				}
//				/*else //del trip - pick trip
//				{
//					curC = seg[idVeh].Trip[curT].firstCus;
//				}*/
//			}
//		}
//		else if (seg[idVeh].Trip[curT].Type == 0)
//		{
//			while (curC > 0)
//			{
//				cArrTime = cStartS + problem->c[preC][curC];
//				cStartS = PDS_MAX(cArrTime, problem->node[curC].sTW);
//				temp = cStartS - problem->node[curC].eTW;
//				if (temp > 0.000999999999999)
//				{
//					varvioTWC += (temp - vioTWCus[curC]);
//					if (vioTWCus[curC] > eps) return 1;
//					cStartS = problem->node[curC].eTW;
//				}
//				else varvioTWC -= vioTWCus[curC];
//				if (PDSDIF(cStartS, startS[curC]) == 0) return 1;
//				cStartS += problem->node[curC].duration;
//				preC = curC; curC = nextArr[curC];
//			} //end while (curC > 0)
//			/*double varvioTWSP1 = 0;
//		    stop = calChangeCONNECTAtSP_PickTrip(preC, idVeh, curT, cStartS, varvioTWSP1, varcost);
//			varvioTWSP += varvioTWSP1;*/
//			bool vioTWSPTRUE;
//		    stop = calChangeCONNECTAtSP_PickTrip(preC, idVeh, curT, cStartS, varvioTWSP, varcost, vioTWSPTRUE);
//			if (stop) return 1;
//
//			if (i < numTrips)
//			{
//				preT = curT; curT++;
//				assSP = seg[idVeh].Trip[preT].assSP;
//				if (seg[idVeh].Trip[curT].Type == 1) 
//				{
//					int assSP1 = seg[idVeh].Trip[curT].assSP;
//					if (assSP == assSP1) //p-d trip
//					{
//						//varvioTWSP += varvioTWSP1;
//						//Update at 16/11/2013
//						if (vioTWSPTRUE) cStartS = problem->leaveSP[assSP][1]; //load only at ETW2
//						else	cStartS += problem->nodeSP[assSP].load;
//						preC = assSP1;
//						curC = seg[idVeh].Trip[curT].firstCus;
//					}
//					else //p - assSP - assSP1 - d
//					{
//						stop = calChangeCONNECTAtSP_SPSP(idVeh, curT, preT, cStartS, varvioTWSP, varcost);
//						if (stop) return 1;
//						preC = assSP1; curC = seg[idVeh].Trip[curT].firstCus;
//					}//end p - assSP - assSP1 - d
//				}
//				else //if (seg[idVeh].Trip[curT].Type==0 || 2): p - p OR p - C2C
//				{
//					preC = assSP;
//					curC = seg[idVeh].Trip[curT].firstCus;
//				}//end if (seg[idVeh].Trip[curT].Type==0 || 2)
//			}
//		}//end trip curT is pickup
//		else //if (seg[idVeh].Trip[curT].Type == 2)
//		{
//			while (curC > 0)
//			{
//				cArrTime = cStartS + problem->c[preC][curC];
//				cStartS = PDS_MAX(cArrTime, problem->node[curC].sTW);
//				temp = cStartS - problem->node[curC].eTW;
//				if (temp > eps)
//				{
//					varvioTWC += (temp - vioTWCus[curC]);
//					if (vioTWCus[curC] > eps) return 1;
//					cStartS = problem->node[curC].eTW;
//				}
//				else varvioTWC -= vioTWCus[curC];
//				if (PDSDIF(cStartS, startS[curC]) == 0) return 1;
//				cStartS += problem->node[curC].duration;
//				preC = curC; curC = nextArr[curC];
//			} //end while (curC > 0)
//			if (i < numTrips)
//			{
//				preT = curT; curT++;
//				if (seg[idVeh].Trip[curT].Type == 1)
//				{
//					stop = calChangeCONNECTAtSP_C2CTrip(preC, idVeh,preT, curT, cStartS, varvioTWSP, varcost);
//					if (stop) return 1;
//					preC = seg[idVeh].Trip[curT].assSP;
//					curC = seg[idVeh].Trip[curT].firstCus;
//				}
//				else //if (seg[idVeh].Trip[curT].Type == 0 || 2) //CAN NOT C2C
//				{
//					curC = seg[idVeh].Trip[curT].firstCus;
//				}
//			}
//		}//end trip curT is C2C
//	}
//	return 0;
//}
//
//bool Solution::calCONNECTCSPTOSPD_FORDELETE(int id1, int idVeh, int idTrip, double &cStartS, double &varvioTWSP, double &varcost)
//{
//	//See 2/12/2013
//	//calCONNECTCSPTOSPD_FORDELETE: Customer or SP to SPofDeliveryTrip
//	//(idVeh, idTrip) is delivery trip 
//	//calculate new cost (stored in varcost), varvioTWSP, cStartS when connecting a customer or sp id1 to assSP of delivery trip (idVeh, idTrip)
//	int assSP = seg[idVeh].Trip[idTrip].assSP;
//	double cArrTime = cStartS + problem->c[id1][assSP];
//	
//	if (PDSINRANGE(cArrTime, problem->nodeSP[assSP].sTW2, problem->nodeSP[assSP].eTW2))
//	{
//		varvioTWSP -= seg[idVeh].Trip[idTrip].vioTWSP;
//		varcost += problem->c[id1][assSP];
//		cStartS = cArrTime + problem->nodeSP[assSP].load;
//	}
//	else
//	{
//		double temp = cArrTime - problem->nodeSP[assSP].eTW2;
//		if (temp > eps) //too late to go sp directly
//		{
//			varvioTWSP += (temp - seg[idVeh].Trip[idTrip].vioTWSP);
//			varcost += problem->c[id1][assSP];
//			if (seg[idVeh].Trip[idTrip].vioTWSP > eps) return 1;
//			cStartS = problem->leaveSP[assSP][1]; //load only at eTW2
//		}
//		else
//		{
//			double cArrTimeI = cStartS + problem->disCWSSP[id1][assSP];
//			temp = cArrTimeI - problem->nodeSP[assSP].eTW2;
//			if (temp > eps) //too soon to go sp directly, too late through WS:
//			{
//				varvioTWSP += (problem->nodeSP[assSP].sTW2 - cArrTime - seg[idVeh].Trip[idTrip].vioTWSP);
//				varcost += problem->c[id1][assSP];
//				//before deletion: go to sp directly: INF OR FEA NOT ALWAYS: Update 7/11/2013
//				if (seg[idVeh].Trip[idTrip].vioTWSP > eps) return 1;
//				cStartS = problem->leaveSP[assSP][1]; //load only at eTW2
//			}
//			else //go through WS:
//			{
//				varvioTWSP -= seg[idVeh].Trip[idTrip].vioTWSP;
//				varcost += problem->disCWSSP[id1][assSP];
//				cStartS = PDS_MAX(cArrTimeI, problem->nodeSP[assSP].sTW2) + problem->nodeSP[assSP].load;
//			}
//		}
//	}
//	return 0;
//}
//
//bool Solution::calChangeCONNECTCSPTOSPD_FORDELETE(int id1, int idVeh, int idTrip, double &cStartS, double &varvioTWSP, double &varcost)
//{
//	//see on 2/12/2013
//    //differ from calCONNECTCSPTOSPD_FORDELETE: 
//	//calChangeCONNECTCSPTOSPD_FORDELETE: calculate the difference in varcost before and after deletion
//	//calCONNECTCSPTOSPD_FORDELETE: calculate the new cost after deletion
//	//(idVeh, idTrip) is delivery trip
//
//	int assSP = seg[idVeh].Trip[idTrip].assSP;
//	double cArrTime = cStartS + problem->c[id1][assSP];
//	
//	if (PDSINRANGE(cArrTime, problem->nodeSP[assSP].sTW2, problem->nodeSP[assSP].eTW2))
//	{
//		varvioTWSP -= seg[idVeh].Trip[idTrip].vioTWSP;
//		//before deletion: go to sp directly FEA OR INFEA -->don't need to update varcost: NOT ALWAYS: update 7/11/2013
//		if (seg[idVeh].Trip[idTrip].waitingS != NO_WS)
//			varcost += (problem->c[id1][assSP] - problem->disCWSSP[id1][assSP]);
//		cStartS = cArrTime + problem->nodeSP[assSP].load;
//	}
//	else
//	{
//		double temp = cArrTime - problem->nodeSP[assSP].eTW2;
//		if (temp > eps) //too late to go sp directly
//		{
//			varvioTWSP += (temp - seg[idVeh].Trip[idTrip].vioTWSP);
//			if (seg[idVeh].Trip[idTrip].vioTWSP > eps) return 1;
//			//before deletion: too late to go to sp directly too --> don't need to update varcost: NOT ALWAYS Update 7/11/2013
//			if (seg[idVeh].Trip[idTrip].waitingS != NO_WS)
//				varcost += (problem->c[id1][assSP] - problem->disCWSSP[id1][assSP]);
//			cStartS = problem->leaveSP[assSP][1]; //load only at eTW2
//		}
//		else
//		{
//			double cArrTimeI = cStartS + problem->disCWSSP[id1][assSP];
//			temp = cArrTimeI - problem->nodeSP[assSP].eTW2;
//			if (temp > eps) //too soon to go sp directly, too late through WS:
//			{
//				varvioTWSP += (problem->nodeSP[assSP].sTW2 - cArrTime - seg[idVeh].Trip[idTrip].vioTWSP);
//				if (seg[idVeh].Trip[idTrip].vioTWSP > eps) return 1;
//				//before deletion: go to sp directly: FEA OR INFEA --> donot need update varcost: NOT ALWAYS Update 7/11/2013
//				if (seg[idVeh].Trip[idTrip].waitingS != NO_WS)
//					varcost += (problem->c[id1][assSP] - problem->disCWSSP[id1][assSP]);
//
//				cStartS = problem->leaveSP[assSP][1]; //load only at eTW2
//			}
//			else //go through WS:
//			{
//				varvioTWSP -= seg[idVeh].Trip[idTrip].vioTWSP;
//				if (seg[idVeh].Trip[idTrip].waitingS == NO_WS)
//					varcost += (problem->disCWSSP[id1][assSP]- problem->c[id1][assSP]);
//				cStartS = PDS_MAX(cArrTimeI, problem->nodeSP[assSP].sTW2) + problem->nodeSP[assSP].load;
//			}
//		}
//	}
//	return 0;
//}
//
//bool Solution::calChangeCONNECTAtSP_DD(int lastC, int idVeh, int idTrip, int preT, double &cStartS, double &varvioTWSP, double &varcost)
//{
//	//See on 2/12/2013
//	//calculte change in varcost, cStartS, varvioTWSP when connecting last delivery cus lastC of (idVeh, preT) with assSP of (idVeh, idTrip)
//	int	assSP = seg[idVeh].Trip[idTrip].assSP;
//	double cArrTime = cStartS + problem->c[lastC][assSP];
//	
//		if (PDSINRANGE(cArrTime, problem->nodeSP[assSP].sTW2, problem->nodeSP[assSP].eTW2))
//		{
//			varvioTWSP -= seg[idVeh].Trip[idTrip].vioTWSP;
//			if (seg[idVeh].Trip[preT].waitingS != NO_WS)
//				varcost += (problem->c[lastC][assSP] - problem->disCWSSP[lastC][assSP]);
//			cStartS = cArrTime + problem->nodeSP[assSP].load; //load only
//		}
//		else
//		{
//			double temp = cArrTime - problem->nodeSP[assSP].eTW2;
//			if (temp > eps)
//			{
//				varvioTWSP += (temp - seg[idVeh].Trip[idTrip].vioTWSP);
//				if (seg[idVeh].Trip[idTrip].vioTWSP > eps) return 1;
//				if (seg[idVeh].Trip[preT].waitingS != NO_WS)
//					varcost += (problem->c[lastC][assSP] - problem->disCWSSP[lastC][assSP]);
//				cStartS = problem->leaveSP[assSP][1]; //load only at eTW2
//			}
//			else
//			{
//				double cArrTimeI = cStartS + problem->disCWSSP[lastC][assSP];
//				temp = cArrTimeI - problem->nodeSP[assSP].eTW2;
//				if (temp > eps) //too soon to go to sp directly, too late to go through WS:
//				{
//					varvioTWSP += (problem->nodeSP[assSP].sTW2 - cArrTime - seg[idVeh].Trip[idTrip].vioTWSP);
//					if (seg[idVeh].Trip[idTrip].vioTWSP > eps) return 1;
//					if (seg[idVeh].Trip[preT].waitingS != NO_WS)
//						varcost += (problem->c[lastC][assSP] - problem->disCWSSP[lastC][assSP]);
//					cStartS = problem->leaveSP[assSP][1]; //load only at eTW2
//				}
//				else //now go through WS:
//				{
//					varvioTWSP -= seg[idVeh].Trip[idTrip].vioTWSP;
//					if (seg[idVeh].Trip[preT].waitingS == NO_WS)
//						varcost += (problem->disCWSSP[lastC][assSP] - problem->c[lastC][assSP]);
//					cStartS = PDS_MAX(cArrTimeI, problem->nodeSP[assSP].sTW2) + problem->nodeSP[assSP].load;
//				}
//			}
//		}
//		return 0;
//}
//
//bool Solution::updateChangeCONNECTAtSP_DDORC2CD(int lastC, int idVeh, int idTrip, int preT, double &cStartS) //for procedure UpdateVehicle
//{
//	//see on 2/12/2013
//	//calculte change in varcost, cStartS, varvioTWSP when connecting last delivery cus lastC of (idVeh, preT) with assSP of (idVeh, idTrip)
//	int	assSP = seg[idVeh].Trip[idTrip].assSP;
//	double varcost;
//	double cArrTime = cStartS + problem->c[lastC][assSP];
//	double varvioTWSP = -seg[idVeh].Trip[idTrip].vioTWSP;
//	
//		if (PDSINRANGE(cArrTime, problem->nodeSP[assSP].sTW2, problem->nodeSP[assSP].eTW2))
//		{
//			seg[idVeh].Trip[idTrip].vioTWSP = 0;
//			if (seg[idVeh].Trip[preT].waitingS != NO_WS)
//			{
//				varcost = (problem->c[lastC][assSP] - problem->disCWSSP[lastC][assSP]);
//				seg[idVeh].Trip[preT].waitingS = NO_WS;
//				seg[idVeh].Trip[preT].connectCost = problem->c[lastC][assSP];
//				seg[idVeh].Trip[preT].cost += varcost;
//				seg[idVeh].Trip[preT].fitness += varcost;
//			}
//			cStartS = cArrTime;// + problem->nodeSP[assSP].load; //load only
//		}
//		else
//		{
//			double temp = cArrTime - problem->nodeSP[assSP].eTW2;
//			if (temp > eps)
//			{
//				varvioTWSP += temp;
//				if (seg[idVeh].Trip[idTrip].vioTWSP > eps)
//				{
//					seg[idVeh].Trip[idTrip].feasible = 0;
//                    seg[idVeh].Trip[idTrip].vioTWSP = temp;				
//					seg[idVeh].Trip[idTrip].fitness += (VTWSP * varvioTWSP);
//					return 1;
//				}
//				seg[idVeh].Trip[idTrip].vioTWSP = temp;
//				if (seg[idVeh].Trip[preT].waitingS != NO_WS)
//				{
//					varcost = (problem->c[lastC][assSP] - problem->disCWSSP[lastC][assSP]);
//					seg[idVeh].Trip[preT].waitingS = NO_WS;
//					seg[idVeh].Trip[preT].cost += varcost;
//					seg[idVeh].Trip[preT].fitness += varcost;
//					seg[idVeh].Trip[preT].connectCost = problem->c[lastC][assSP];
//				}
//				cStartS = problem->nodeSP[assSP].eTW2; //problem->leaveSP[assSP][1]; //load only at eTW2
//			}
//			else
//			{
//				double cArrTimeI = cStartS + problem->disCWSSP[lastC][assSP];
//				temp = cArrTimeI - problem->nodeSP[assSP].eTW2;
//				if (temp > eps) //too soon to go to sp directly, too late to go through WS:
//				{
//					temp = problem->nodeSP[assSP].sTW2 - cArrTime;
//					varvioTWSP += temp;
//					if (seg[idVeh].Trip[idTrip].vioTWSP > eps) 
//					{
//						seg[idVeh].Trip[idTrip].feasible = 0;
//						seg[idVeh].Trip[idTrip].vioTWSP = temp;
//						seg[idVeh].Trip[idTrip].fitness += (VTWSP * varvioTWSP);
//						return 1;
//					}
//					seg[idVeh].Trip[idTrip].vioTWSP = temp;
//					if (seg[idVeh].Trip[preT].waitingS != NO_WS)
//					{
//						varcost = (problem->c[lastC][assSP] - problem->disCWSSP[lastC][assSP]);
//						seg[idVeh].Trip[preT].waitingS = NO_WS;
//						seg[idVeh].Trip[preT].cost += varcost;
//						seg[idVeh].Trip[preT].fitness += varcost;
//						seg[idVeh].Trip[preT].connectCost = problem->c[lastC][assSP];
//					}
//					cStartS = problem->nodeSP[assSP].eTW2; //problem->leaveSP[assSP][1]; //load only at eTW2
//				}
//				else //now go through WS:
//				{
//					seg[idVeh].Trip[idTrip].vioTWSP = 0;
//					
//					if (seg[idVeh].Trip[preT].waitingS == NO_WS)
//					{
//						varcost = (problem->disCWSSP[lastC][assSP] - problem->c[lastC][assSP]);
//						seg[idVeh].Trip[preT].cost += varcost;
//						seg[idVeh].Trip[preT].fitness += varcost;
//						seg[idVeh].Trip[preT].connectCost = problem->disCWSSP[lastC][assSP];
//						seg[idVeh].Trip[preT].waitingS = problem->CWSSP[lastC][assSP];
//					}
//					cStartS = PDS_MAX(cArrTimeI, problem->nodeSP[assSP].sTW2);// + problem->nodeSP[assSP].load;
//				}
//			}
//		}
//		seg[idVeh].Trip[idTrip].fitness += (VTWSP * varvioTWSP);
//		if (PDSDIF(cStartS, seg[idVeh].Trip[preT].arriveSP) == 0) 
//		{
//			if (seg[idVeh].Trip[idTrip].vioCAP > 0 || seg[idVeh].Trip[idTrip].vioTWC > eps || seg[idVeh].Trip[idTrip].vioTWSP > eps)
//					seg[idVeh].Trip[idTrip].feasible = 0;
//			else seg[idVeh].Trip[idTrip].feasible = 1;
//			return 1;
//		}
//		seg[idVeh].Trip[preT].arriveSP = cStartS;
//		seg[idVeh].Trip[idTrip].leaveSP = cStartS + problem->nodeSP[assSP].load;
//		return 0;
//}
//
//
//
//bool Solution::updateChangeCONNECTAtSP_DD(int lastC, int idVeh, int idTrip, int preT, int varvioCAP, double varvioTWC, double varcost) //for deleteCusD and insertCusD procedure
//{
//	//see on 2/12/2013
//	//calculte change in varcost, cStartS, varvioTWSP when connecting last delivery cus lastC of (idVeh, preT) with assSP of (idVeh, idTrip)
//	int	assSP = seg[idVeh].Trip[idTrip].assSP;
//	double cStartS;
//	double cArrTime = depart[lastC] + problem->c[lastC][assSP];
//	double varFIT = VCAP * varvioCAP + VTWCUS * varvioTWC;
//	double varvioTWSP = -seg[idVeh].Trip[idTrip].vioTWSP;
//	
//		if (PDSINRANGE(cArrTime, problem->nodeSP[assSP].sTW2, problem->nodeSP[assSP].eTW2))
//		{
//			seg[idVeh].Trip[idTrip].vioTWSP = 0;
//			if (seg[idVeh].Trip[preT].waitingS != NO_WS)
//			{
//				varcost += (problem->c[lastC][assSP] - problem->disCWSSP[lastC][assSP]);
//				seg[idVeh].Trip[preT].waitingS = NO_WS;
//				seg[idVeh].Trip[preT].connectCost = problem->c[lastC][assSP];
//			}
//			seg[idVeh].Trip[preT].cost += varcost;
//			varFIT += varcost;
//			seg[idVeh].Trip[preT].fitness += varFIT;
//			cStartS = cArrTime;// + problem->nodeSP[assSP].load; //load only
//		}
//		else
//		{
//			double temp = cArrTime - problem->nodeSP[assSP].eTW2;
//			if (temp > eps)
//			{
//				varvioTWSP += temp;
//				if (seg[idVeh].Trip[idTrip].vioTWSP > eps)
//				{
//					seg[idVeh].Trip[idTrip].feasible = 0;
//                    seg[idVeh].Trip[idTrip].vioTWSP = temp;				
//					seg[idVeh].Trip[idTrip].fitness += (VTWSP * varvioTWSP);
//
//					seg[idVeh].Trip[preT].cost += varcost;
//					varFIT += varcost;
//					seg[idVeh].Trip[preT].fitness += varFIT;
//
//					varFIT += (VTWSP * varvioTWSP);
//					seg[idVeh].cost += varcost; seg[idVeh].fitness += varFIT;
//					seg[idVeh].vioCAP += varvioCAP; seg[idVeh].vioTWC += varvioTWC; seg[idVeh].vioTWSP += varvioTWSP;
//					cost += varcost; fitness += varFIT;
//					vioCAP += varvioCAP; vioTWC += varvioTWC; vioTWSP += varvioTWSP;
//					return 1;
//				}
//				seg[idVeh].Trip[idTrip].vioTWSP = temp;
//				if (seg[idVeh].Trip[preT].waitingS != NO_WS)
//				{
//					varcost += (problem->c[lastC][assSP] - problem->disCWSSP[lastC][assSP]);
//					seg[idVeh].Trip[preT].waitingS = NO_WS;
//					seg[idVeh].Trip[preT].connectCost = problem->c[lastC][assSP];
//				}
//				seg[idVeh].Trip[preT].cost += varcost;
//				varFIT += varcost;
//				seg[idVeh].Trip[preT].fitness += varFIT;
//
//				cStartS = problem->nodeSP[assSP].eTW2; //problem->leaveSP[assSP][1]; //load only at eTW2
//			}
//			else
//			{
//				double cArrTimeI = depart[lastC] + problem->disCWSSP[lastC][assSP];
//				temp = cArrTimeI - problem->nodeSP[assSP].eTW2;
//				if (temp > eps) //too soon to go to sp directly, too late to go through WS:
//				{
//					temp = problem->nodeSP[assSP].sTW2 - cArrTime;
//					varvioTWSP += temp;
//					if (seg[idVeh].Trip[idTrip].vioTWSP > eps) 
//					{
//						seg[idVeh].Trip[idTrip].feasible = 0;
//						seg[idVeh].Trip[idTrip].vioTWSP = temp;
//						seg[idVeh].Trip[idTrip].fitness += (VTWSP * varvioTWSP);
//
//						seg[idVeh].Trip[preT].cost += varcost;
//						varFIT += varcost;
//						seg[idVeh].Trip[preT].fitness += varFIT;
//
//						varFIT += (VTWSP * varvioTWSP);
//						seg[idVeh].cost += varcost; seg[idVeh].fitness += varFIT;
//						seg[idVeh].vioCAP += varvioCAP; seg[idVeh].vioTWC += varvioTWC; seg[idVeh].vioTWSP += varvioTWSP;
//						cost += varcost; fitness += varFIT;
//						vioCAP += varvioCAP; vioTWC += varvioTWC; vioTWSP += varvioTWSP;
//						return 1;
//					}
//					seg[idVeh].Trip[idTrip].vioTWSP = temp;
//					if (seg[idVeh].Trip[preT].waitingS != NO_WS)
//					{
//						varcost += (problem->c[lastC][assSP] - problem->disCWSSP[lastC][assSP]);
//						seg[idVeh].Trip[preT].waitingS = NO_WS;
//						seg[idVeh].Trip[preT].connectCost = problem->c[lastC][assSP];
//					}
//					seg[idVeh].Trip[preT].cost += varcost;
//					varFIT += varcost;
//					seg[idVeh].Trip[preT].fitness += varFIT;
//
//					cStartS = problem->nodeSP[assSP].eTW2; // problem->leaveSP[assSP][1]; //load only at eTW2
//				}
//				else //now go through WS:
//				{
//					seg[idVeh].Trip[idTrip].vioTWSP = 0;
//					
//					if (seg[idVeh].Trip[preT].waitingS == NO_WS)
//					{
//						varcost += (problem->disCWSSP[lastC][assSP] - problem->c[lastC][assSP]);
//						seg[idVeh].Trip[preT].connectCost = problem->disCWSSP[lastC][assSP];
//						seg[idVeh].Trip[preT].waitingS = problem->CWSSP[lastC][assSP];
//					}
//					seg[idVeh].Trip[preT].cost += varcost;
//					varFIT += varcost;
//					seg[idVeh].Trip[preT].fitness += varFIT;
//
//					cStartS = PDS_MAX(cArrTimeI, problem->nodeSP[assSP].sTW2); // + problem->nodeSP[assSP].load;
//				}
//			}
//		}
//		seg[idVeh].Trip[idTrip].fitness += (VTWSP * varvioTWSP);
//		if (PDSDIF(cStartS, seg[idVeh].Trip[preT].arriveSP) == 0) 
//		{
//			if (seg[idVeh].Trip[idTrip].vioCAP > 0 || seg[idVeh].Trip[idTrip].vioTWC > eps || seg[idVeh].Trip[idTrip].vioTWSP > eps)
//					seg[idVeh].Trip[idTrip].feasible = 0;
//			else seg[idVeh].Trip[idTrip].feasible = 1;
//
//			varFIT += (VTWSP * varvioTWSP);
//			seg[idVeh].cost += varcost; seg[idVeh].fitness += varFIT;
//			seg[idVeh].vioCAP += varvioCAP; seg[idVeh].vioTWC += varvioTWC; seg[idVeh].vioTWSP += varvioTWSP;
//			cost += varcost; fitness += varFIT;
//			vioCAP += varvioCAP; vioTWC += varvioTWC; vioTWSP += varvioTWSP;
//			return 1;
//		}
//		seg[idVeh].Trip[preT].arriveSP = cStartS;
//		seg[idVeh].Trip[idTrip].leaveSP = cStartS + problem->nodeSP[assSP].load;
//		return 0;
//}
//
//
//
//bool Solution::updateChangeCONNECTAtSP_DD(int lastC, int idVeh, int idTrip, int preT, int varvioCAP, double varvioTWC, double costTrip, double costOLD) //for twoOPTstarCusDTrip
//{ 
//		//see on 2/12/2013
//		//calculte change in varcost, cStartS, varvioTWSP when connecting last delivery cus lastC of (idVeh, preT) with assSP of (idVeh, idTrip)
//		int	assSP = seg[idVeh].Trip[idTrip].assSP;
//		double cStartS, varFIT, varcost;
//		double cArrTime = depart[lastC] + problem->c[lastC][assSP];
//		double varvioTWSP = -seg[idVeh].Trip[idTrip].vioTWSP;
//	
//		if (PDSINRANGE(cArrTime, problem->nodeSP[assSP].sTW2, problem->nodeSP[assSP].eTW2))
//		{
//			seg[idVeh].Trip[idTrip].vioTWSP = 0;
//			seg[idVeh].Trip[preT].waitingS = NO_WS;
//			seg[idVeh].Trip[preT].connectCost = problem->c[lastC][assSP];
//			cStartS = cArrTime;// + problem->nodeSP[assSP].load; //load only
//		}
//		else
//		{
//			double temp = cArrTime - problem->nodeSP[assSP].eTW2;
//			if (temp > eps)
//			{
//				varvioTWSP += temp;
//				if (seg[idVeh].Trip[idTrip].vioTWSP > eps)
//				{
//					seg[idVeh].Trip[idTrip].feasible = 0;
//                    seg[idVeh].Trip[idTrip].vioTWSP = temp;				
//					seg[idVeh].Trip[idTrip].fitness += (VTWSP * varvioTWSP);
//
//					seg[idVeh].Trip[preT].waitingS = NO_WS;
//					seg[idVeh].Trip[preT].connectCost = problem->c[lastC][assSP];
//					seg[idVeh].Trip[preT].cost = costTrip + problem->c[lastC][assSP];
//					varcost = seg[idVeh].Trip[preT].cost - costOLD;
//					varFIT = varcost + VCAP * varvioCAP + VTWCUS * varvioTWC;
//					seg[idVeh].Trip[preT].fitness += varFIT;
//
//					varFIT += (VTWSP * varvioTWSP);
//					seg[idVeh].cost += varcost; seg[idVeh].fitness += varFIT;
//					seg[idVeh].vioCAP += varvioCAP; seg[idVeh].vioTWC += varvioTWC; seg[idVeh].vioTWSP += varvioTWSP;
//					cost += varcost; fitness += varFIT;
//					vioCAP += varvioCAP; vioTWC += varvioTWC; vioTWSP += varvioTWSP;
//					return 1;
//				}
//				seg[idVeh].Trip[idTrip].vioTWSP = temp;
//				seg[idVeh].Trip[preT].waitingS = NO_WS;
//				seg[idVeh].Trip[preT].connectCost = problem->c[lastC][assSP];
//				cStartS = problem->nodeSP[assSP].eTW2; //problem->leaveSP[assSP][1]; //load only at eTW2
//			}
//			else
//			{
//				double cArrTimeI = depart[lastC] + problem->disCWSSP[lastC][assSP];
//				temp = cArrTimeI - problem->nodeSP[assSP].eTW2;
//				if (temp > eps) //too soon to go to sp directly, too late to go through WS:
//				{
//					temp = problem->nodeSP[assSP].sTW2 - cArrTime;
//					varvioTWSP += temp;
//					if (seg[idVeh].Trip[idTrip].vioTWSP > eps) 
//					{
//						seg[idVeh].Trip[idTrip].feasible = 0;
//						seg[idVeh].Trip[idTrip].vioTWSP = temp;
//						seg[idVeh].Trip[idTrip].fitness += (VTWSP * varvioTWSP);
//
//						seg[idVeh].Trip[preT].waitingS = NO_WS;
//						seg[idVeh].Trip[preT].connectCost = problem->c[lastC][assSP];
//						seg[idVeh].Trip[preT].cost = costTrip + problem->c[lastC][assSP];
//						varcost = seg[idVeh].Trip[preT].cost - costOLD;
//						varFIT = varcost + VCAP * varvioCAP + VTWCUS * varvioTWC;
//						seg[idVeh].Trip[preT].fitness += varFIT;
//
//						varFIT += (VTWSP * varvioTWSP);
//						seg[idVeh].cost += varcost; seg[idVeh].fitness += varFIT;
//						seg[idVeh].vioCAP += varvioCAP; seg[idVeh].vioTWC += varvioTWC; seg[idVeh].vioTWSP += varvioTWSP;
//						cost += varcost; fitness += varFIT;
//						vioCAP += varvioCAP; vioTWC += varvioTWC; vioTWSP += varvioTWSP;
//						return 1;
//					}
//					seg[idVeh].Trip[idTrip].vioTWSP = temp;
//					seg[idVeh].Trip[preT].waitingS = NO_WS;
//					seg[idVeh].Trip[preT].connectCost = problem->c[lastC][assSP];
//					cStartS = problem->nodeSP[assSP].eTW2; // problem->leaveSP[assSP][1]; //load only at eTW2
//				}
//				else //now go through WS:
//				{
//					seg[idVeh].Trip[idTrip].vioTWSP = 0;
//					
//					seg[idVeh].Trip[preT].waitingS = problem->CWSSP[lastC][assSP];
//					seg[idVeh].Trip[preT].connectCost = problem->disCWSSP[lastC][assSP];
//					cStartS = PDS_MAX(cArrTimeI, problem->nodeSP[assSP].sTW2); // + problem->nodeSP[assSP].load;
//				}
//			}
//		}
//		
//		seg[idVeh].Trip[idTrip].fitness += (VTWSP * varvioTWSP);
//		seg[idVeh].Trip[preT].cost = costTrip + seg[idVeh].Trip[preT].connectCost;
//		varcost = seg[idVeh].Trip[preT].cost - costOLD;
//		varFIT = varcost + VCAP * varvioCAP + VTWCUS * varvioTWC;
//		seg[idVeh].Trip[preT].fitness += varFIT;
//
//		if (PDSDIF(cStartS, seg[idVeh].Trip[preT].arriveSP) == 0) 
//		{
//			if (seg[idVeh].Trip[idTrip].vioCAP > 0 || seg[idVeh].Trip[idTrip].vioTWC > eps || seg[idVeh].Trip[idTrip].vioTWSP > eps)
//					seg[idVeh].Trip[idTrip].feasible = 0;
//			else seg[idVeh].Trip[idTrip].feasible = 1;
//
//			varFIT += (VTWSP * varvioTWSP);
//			seg[idVeh].cost += varcost; seg[idVeh].fitness += varFIT;
//			seg[idVeh].vioCAP += varvioCAP; seg[idVeh].vioTWC += varvioTWC; seg[idVeh].vioTWSP += varvioTWSP;
//			cost += varcost; fitness += varFIT;
//			vioCAP += varvioCAP; vioTWC += varvioTWC; vioTWSP += varvioTWSP;
//			return 1;
//		}
//		seg[idVeh].Trip[preT].arriveSP = cStartS;
//		seg[idVeh].Trip[idTrip].leaveSP = cStartS + problem->nodeSP[assSP].load;
//		return 0;
//}
//
//
//
//
//void Solution::updateChangeCONNECTAtSP_DDORC2CD(int idVeh, int idTrip, int preT, int varvioCAP, int update_idTrip) //for Update_EmptyTripD and Update_EmptyTripP, delete_insertCusPTrip: connect deliverytrip(idVeh, preT) with delivery trip (idVeh, nextTrip) where (idVeh, idTrip) is already deleted 
//{
//	    //see on 2/12/2013
//	    //Dif from updateChangeCONNECTAtSP_DD(int idVeh, int idTrip, int preT, int varvioCAP) is: just update till trip update_idTrip rather than all remaining trips of idVeh
//		int lastCpreT = seg[idVeh].Trip[preT].lastCus;
//		int assSPnextT = seg[idVeh].Trip[idTrip].assSP;
//		double varvioTWSP = -seg[idVeh].Trip[idTrip].vioTWSP;
//        double varC = -seg[idVeh].Trip[preT].connectCost;
//
//		double cArrTime = seg[idVeh].Trip[preT].endS + problem->c[lastCpreT][assSPnextT];
//		if (PDSINRANGE(cArrTime, problem->nodeSP[assSPnextT].sTW2, problem->nodeSP[assSPnextT].eTW2))
//		{
//			cout<<"12/1/2014: Inrange"<<endl;
//			seg[idVeh].Trip[preT].connectCost = problem->c[lastCpreT][assSPnextT];
//			varC += problem->c[lastCpreT][assSPnextT];
//			seg[idVeh].Trip[preT].waitingS = NO_WS;
//			seg[idVeh].Trip[preT].cost += varC;
//			seg[idVeh].Trip[preT].fitness += varC;
//
//			seg[idVeh].Trip[idTrip].vioTWSP = 0;
//			seg[idVeh].Trip[idTrip].fitness += (VTWSP *varvioTWSP);
//			//before delete: go to sp directly or through WS:
//			seg[idVeh].Trip[preT].arriveSP = cArrTime;
//			seg[idVeh].Trip[idTrip].leaveSP = cArrTime + problem->nodeSP[assSPnextT].load;
//			UpdateVehicle(idVeh, idTrip, assSPnextT, seg[idVeh].Trip[idTrip].leaveSP, varvioCAP, update_idTrip);
//		}
//		else
//		{
//			double temp = cArrTime - problem->nodeSP[assSPnextT].eTW2;
//			if (temp > eps) 
//			{
//				cout<<"12/1/2014: Exceed eTW2"<<endl;
//				seg[idVeh].Trip[preT].connectCost = problem->c[lastCpreT][assSPnextT];
//				varC += problem->c[lastCpreT][assSPnextT];
//				seg[idVeh].Trip[preT].waitingS = NO_WS;
//				seg[idVeh].Trip[preT].cost += varC;
//				seg[idVeh].Trip[preT].fitness += varC;
//
//				varvioTWSP += temp;
//				if (seg[idVeh].Trip[idTrip].vioTWSP > eps) //before also vioTWSP --> don't need to update all remaining trips
//				{
//					seg[idVeh].Trip[idTrip].vioTWSP = temp;
//					seg[idVeh].Trip[idTrip].fitness += (VTWSP * varvioTWSP);
//				}
//				else //need to update all remaining trips:
//				{
//					seg[idVeh].Trip[idTrip].vioTWSP = temp;
//					seg[idVeh].Trip[idTrip].fitness += (VTWSP * varvioTWSP);
//					seg[idVeh].Trip[preT].arriveSP = problem->nodeSP[assSPnextT].eTW2;
//					seg[idVeh].Trip[idTrip].leaveSP = problem->leaveSP[assSPnextT][1]; //load only at eTW2
//					UpdateVehicle(idVeh, idTrip, assSPnextT, seg[idVeh].Trip[idTrip].leaveSP, varvioCAP,update_idTrip);
//				}
//			}
//			else
//			{
//				double cArrTimeI = seg[idVeh].Trip[preT].endS + problem->disCWSSP[lastCpreT][assSPnextT];
//				temp = cArrTimeI - problem->nodeSP[assSPnextT].eTW2;
//				if (temp > eps) //too soon to sp directly; too late through WS:
//				{
//					cout<<"12/1/2014: too soon too late"<<endl;
//					seg[idVeh].Trip[preT].connectCost = problem->c[lastCpreT][assSPnextT];
//					varC += problem->c[lastCpreT][assSPnextT];
//					seg[idVeh].Trip[preT].waitingS = NO_WS;
//					seg[idVeh].Trip[preT].cost += varC;
//					seg[idVeh].Trip[preT].fitness += varC;
//
//					//before delete: to sp directly FEA OR INF or through WS:
//					temp = problem->nodeSP[assSPnextT].sTW2 - cArrTime;
//					varvioTWSP += temp;
//					if (seg[idVeh].Trip[idTrip].vioTWSP > eps) //before also vioTWSP --> don't need to update all remaining trips
//					{
//						seg[idVeh].Trip[idTrip].vioTWSP = temp;
//						seg[idVeh].Trip[idTrip].fitness += (VTWSP * varvioTWSP);
//					}
//					else //need to update all remaining trips:
//					{
//						seg[idVeh].Trip[idTrip].vioTWSP = temp;
//						seg[idVeh].Trip[idTrip].fitness += (VTWSP * varvioTWSP);
//						seg[idVeh].Trip[preT].arriveSP = problem->nodeSP[assSPnextT].eTW2;
//						seg[idVeh].Trip[idTrip].leaveSP = problem->leaveSP[assSPnextT][1]; //load only at eTW2
//						UpdateVehicle(idVeh, idTrip, assSPnextT, seg[idVeh].Trip[idTrip].leaveSP, varvioCAP, update_idTrip);
//					}
//				}
//				else //through WS:
//				{
//					cout<<"12/1/2014: Through WS"<<endl;
//					seg[idVeh].Trip[preT].connectCost = problem->disCWSSP[lastCpreT][assSPnextT];
//					varC += problem->disCWSSP[lastCpreT][assSPnextT];
//					seg[idVeh].Trip[preT].waitingS = problem->CWSSP[lastCpreT][assSPnextT];
//					seg[idVeh].Trip[preT].cost += varC;
//					seg[idVeh].Trip[preT].fitness += varC;
//
//					//before delete: to sp directly FEA or INF or through WS:
//					seg[idVeh].Trip[idTrip].vioTWSP = 0;
//					seg[idVeh].Trip[idTrip].fitness += (VTWSP * varvioTWSP);
//					seg[idVeh].Trip[preT].arriveSP = PDS_MAX(cArrTimeI, problem->nodeSP[assSPnextT].sTW2);
//					seg[idVeh].Trip[idTrip].leaveSP =  seg[idVeh].Trip[preT].arriveSP + problem->nodeSP[assSPnextT].load;
//					UpdateVehicle(idVeh, idTrip, assSPnextT, seg[idVeh].Trip[idTrip].leaveSP, varvioCAP, update_idTrip);
//				}
//			}
//		}
//}
//
//
//
//bool Solution::calChangeCONNECTAtSP_DD_LastCChanged(int lastC, int idVeh, int idTrip, double &cStartS, double &varvioTWSP, double &varcost)
//{
//	//See on 2/12/2013
//	//lastC of (idVeh, idTrip) is changed
//	//calculte change in varcost, cStartS, varvioTWSP when connecting last delivery cus lastC of (idVeh, preT) with assSP of (idVeh, idTrip)
//	int	assSP = seg[idVeh].Trip[idTrip].assSP;
//	double cArrTime = cStartS + problem->c[lastC][assSP];
//	
//		if (PDSINRANGE(cArrTime, problem->nodeSP[assSP].sTW2, problem->nodeSP[assSP].eTW2))
//		{
//			varvioTWSP -= seg[idVeh].Trip[idTrip].vioTWSP;
//			varcost += problem->c[lastC][assSP];
//			cStartS = cArrTime + problem->nodeSP[assSP].load; //load only
//		}
//		else
//		{
//			double temp = cArrTime - problem->nodeSP[assSP].eTW2;
//			if (temp > eps)
//			{
//				varvioTWSP += (temp - seg[idVeh].Trip[idTrip].vioTWSP);
//				varcost += problem->c[lastC][assSP];
//				if (seg[idVeh].Trip[idTrip].vioTWSP > eps) return 1;
//				cStartS = problem->leaveSP[assSP][1]; //load only at eTW2
//			}
//			else
//			{
//				double cArrTimeI = cStartS + problem->disCWSSP[lastC][assSP];
//				temp = cArrTimeI - problem->nodeSP[assSP].eTW2;
//				if (temp > eps) //too soon to go to sp directly, too late to go through WS:
//				{
//					varvioTWSP += (problem->nodeSP[assSP].sTW2 - cArrTime - seg[idVeh].Trip[idTrip].vioTWSP);
//					varcost += problem->c[lastC][assSP];
//					if (seg[idVeh].Trip[idTrip].vioTWSP > eps) return 1;
//					cStartS = problem->leaveSP[assSP][1]; //load only at eTW2
//				}
//				else //now go through WS:
//				{
//					varvioTWSP -= seg[idVeh].Trip[idTrip].vioTWSP;
//					varcost += problem->disCWSSP[lastC][assSP];
//					cStartS = PDS_MAX(cArrTimeI, problem->nodeSP[assSP].sTW2) + problem->nodeSP[assSP].load;
//				}
//			}
//		}
//		return 0;
//}
//
//
//
//
//bool Solution::calChangeCONNECTAtSP_DD_LastCChanged(int lastCOLD, int lastC, int idVeh, int curT, int preT, int varvioCAP, double varvioTWC, double varcost) //for deleteCusD and insertCusD procedure
//{
//	//see on 2/12/2013
//	//lastC of (idVeh, preT) is changed
//	//calculte change in varcost, cStartS, varvioTWSP when connecting last delivery cus lastC of (idVeh, preT) with assSP of (idVeh, curT)
//	int	assSP = seg[idVeh].Trip[curT].assSP;
//	
//	if (seg[idVeh].Trip[preT].waitingS == NO_WS)
//		varcost -= problem->c[lastCOLD][assSP];
//	else varcost -= problem->disCWSSP[lastCOLD][assSP];
//
//	double cArrTime = depart[lastC] + problem->c[lastC][assSP];
//	double varFIT = VCAP * varvioCAP + VTWCUS * varvioTWC;
//	double varvioTWSP = -seg[idVeh].Trip[curT].vioTWSP;
//	double cStartS;
//
//		if (PDSINRANGE(cArrTime, problem->nodeSP[assSP].sTW2, problem->nodeSP[assSP].eTW2))
//		{
//			seg[idVeh].Trip[curT].vioTWSP = 0;
//			seg[idVeh].Trip[curT].fitness += (VTWSP * varvioTWSP);
//
//			seg[idVeh].Trip[preT].waitingS = NO_WS;
//			varcost += problem->c[lastC][assSP];
//			seg[idVeh].Trip[preT].connectCost = problem->c[lastC][assSP];
//			seg[idVeh].Trip[preT].cost += varcost;
//			varFIT += varcost;
//			seg[idVeh].Trip[preT].fitness += varFIT;
//			cStartS = cArrTime;// + problem->nodeSP[assSP].load; //load only
//		}
//		else
//		{
//			double temp = cArrTime - problem->nodeSP[assSP].eTW2;
//			if (temp > eps)
//			{
//				varvioTWSP += temp;
//				
//				seg[idVeh].Trip[preT].waitingS = NO_WS;
//				varcost += problem->c[lastC][assSP];
//				seg[idVeh].Trip[preT].connectCost = problem->c[lastC][assSP];
//				seg[idVeh].Trip[preT].cost += varcost;
//				varFIT += varcost;
//				seg[idVeh].Trip[preT].fitness += varFIT;
//
//				seg[idVeh].Trip[curT].fitness += (VTWSP * varvioTWSP);
//				if (seg[idVeh].Trip[curT].vioTWSP > eps)
//				{
//					seg[idVeh].Trip[curT].feasible = 0;
//					seg[idVeh].Trip[curT].vioTWSP = temp;
//					varFIT += (VTWSP * varvioTWSP);
//					seg[idVeh].vioTWC += varvioTWC; seg[idVeh].vioCAP += varvioCAP; seg[idVeh].vioTWSP += varvioTWSP;
//					seg[idVeh].cost += varcost; seg[idVeh].fitness += varFIT;
//					cost += varcost; fitness += varFIT; vioTWC += varvioTWC; vioCAP += varvioCAP; vioTWSP += varvioTWSP;
//					return 1;
//				}
//				seg[idVeh].Trip[curT].vioTWSP = temp;
//				cStartS = problem->nodeSP[assSP].eTW2; // problem->leaveSP[assSP][1]; //load only at eTW2
//			}
//			else
//			{
//				double cArrTimeI = depart[lastC] + problem->disCWSSP[lastC][assSP];
//				temp = cArrTimeI - problem->nodeSP[assSP].eTW2;
//				if (temp > eps) //too soon to go to sp directly, too late to go through WS:
//				{
//					temp = problem->nodeSP[assSP].sTW2 - cArrTime;
//					varvioTWSP += temp;
//					seg[idVeh].Trip[preT].waitingS = NO_WS;
//					varcost += problem->c[lastC][assSP];
//					seg[idVeh].Trip[preT].connectCost = problem->c[lastC][assSP];
//					seg[idVeh].Trip[preT].cost += varcost;
//					varFIT += varcost;
//					seg[idVeh].Trip[preT].fitness += varFIT;
//
//					seg[idVeh].Trip[curT].fitness += (VTWSP * varvioTWSP);
//					if (seg[idVeh].Trip[curT].vioTWSP > eps)
//					{
//						seg[idVeh].Trip[curT].feasible = 0;
//						seg[idVeh].Trip[curT].vioTWSP = temp;
//						varFIT += (VTWSP * varvioTWSP);
//						seg[idVeh].cost += varcost; seg[idVeh].fitness += varFIT; 
//						seg[idVeh].vioCAP += varvioCAP; seg[idVeh].vioTWC += varvioTWC; seg[idVeh].vioTWSP += varvioTWSP;
//						cost += varcost; fitness += varFIT;
//						vioCAP += varvioCAP; vioTWC += varvioTWC; vioTWSP += varvioTWSP;
//						return 1;
//					}
//					seg[idVeh].Trip[curT].vioTWSP = temp;
//					cStartS = problem->nodeSP[assSP].eTW2; //problem->leaveSP[assSP][1]; //load only at eTW2
//				}
//				else //now go through WS:
//				{
//					seg[idVeh].Trip[curT].vioTWSP = 0;
//					seg[idVeh].Trip[curT].fitness += (VTWSP * varvioTWSP);
//
//					seg[idVeh].Trip[preT].waitingS = problem->CWSSP[lastC][assSP];
//					varcost += problem->disCWSSP[lastC][assSP];
//					seg[idVeh].Trip[preT].connectCost = problem->disCWSSP[lastC][assSP];
//					seg[idVeh].Trip[preT].cost += varcost;
//					varFIT += varcost;
//					seg[idVeh].Trip[preT].fitness += varFIT;
//					cStartS = PDS_MAX(cArrTimeI, problem->nodeSP[assSP].sTW2);// + problem->nodeSP[assSP].load;
//				}
//			}
//		}
//		if (PDSDIF(cStartS, seg[idVeh].Trip[preT].arriveSP) == 0)
//		{
//			if (seg[idVeh].Trip[curT].vioTWSP > eps || seg[idVeh].Trip[curT].vioCAP > 0 || seg[idVeh].Trip[curT].vioTWC > eps)
//				seg[idVeh].Trip[curT].feasible = 0;
//			else seg[idVeh].Trip[curT].feasible = 1;
//
//			varFIT += (VTWSP * varvioTWSP);
//			seg[idVeh].vioTWC += varvioTWC; seg[idVeh].vioCAP += varvioCAP; seg[idVeh].vioTWSP += varvioTWSP;
//			seg[idVeh].cost += varcost; seg[idVeh].fitness += varFIT;
//			cost += varcost; fitness += varFIT; vioTWC += varvioTWC; vioCAP += varvioCAP; vioTWSP += varvioTWSP;
//			return 1;
//		}
//		seg[idVeh].Trip[preT].arriveSP = cStartS;
//		seg[idVeh].Trip[curT].leaveSP = cStartS + problem->nodeSP[assSP].load;
//		return 0;
//}
//
//
////This procedure will double the value of varvioTWSP in case nextTrip is delivery trip and sameSP:
//bool Solution::calChangeCONNECTAtSP_PickTrip(int lastC, int idVeh, int idTrip, double &cStartS, double &varvioTWSP, double &varcost)
//{
//	//see on 2/12/2013
//	//calculate variation of varcost, varvioTWSP, cStartS when connecting lastC of pickup trip (idVeh, idTrip) with its assSP
//	int	assSP = seg[idVeh].Trip[idTrip].assSP;
//	double	cArrTime = cStartS + problem->c[lastC][assSP];
//	bool shouldSTOP = 1;
//
//		if (PDSINRANGE(cArrTime, problem->nodeSP[assSP].sTW1, problem->nodeSP[assSP].eTW1))
//		{
//			varvioTWSP -= seg[idVeh].Trip[idTrip].vioTWSP;
//			int nextT = idTrip + 1;
//			if (nextT < seg[idVeh].numTrips)
//			{
//				if (seg[idVeh].Trip[nextT].Type == 1)
//					if (seg[idVeh].Trip[nextT].assSP == assSP) 
//					{
//						varvioTWSP -= seg[idVeh].Trip[idTrip].vioTWSP;
//						if (seg[idVeh].Trip[idTrip].vioTWSP > eps) shouldSTOP = 0; //before vio, now notVIO --> leaveSP of nextT is changed
//					}
//			}
//
//			if (seg[idVeh].Trip[idTrip].waitingS != NO_WS)
//				varcost += (problem->c[lastC][assSP] - problem->disCWSSP[lastC][assSP]);
//			cStartS = cArrTime + problem->nodeSP[assSP].unload;
//		}
//		else
//		{
//			double temp = cArrTime - problem->nodeSP[assSP].eTW1;
//			if (temp > eps)
//			{
//				temp = temp - seg[idVeh].Trip[idTrip].vioTWSP;
//				varvioTWSP += temp;
//				int nextT = idTrip + 1;
//				if (nextT < seg[idVeh].numTrips)
//				{
//					if (seg[idVeh].Trip[nextT].Type == 1)
//						if (seg[idVeh].Trip[nextT].assSP == assSP) varvioTWSP += temp;
//				}
//				if (seg[idVeh].Trip[idTrip].vioTWSP > eps) return 1;
//				if (seg[idVeh].Trip[idTrip].waitingS != NO_WS)
//					varcost += (problem->c[lastC][assSP] - problem->disCWSSP[lastC][assSP]);
//				cStartS = problem->leaveSP[assSP][0]; //unload at eTW1
//			}
//			else
//			{
//				double cArrTimeI = cStartS + problem->disCWSSP[lastC][assSP];
//				temp = cArrTimeI - problem->nodeSP[assSP].eTW1;
//				if (temp > eps) //too soon to go sp directly, too late through WS
//				{
//					temp = (problem->nodeSP[assSP].sTW1 - cArrTime - seg[idVeh].Trip[idTrip].vioTWSP);
//					varvioTWSP += temp;
//					int nextT = idTrip + 1;
//					if (nextT < seg[idVeh].numTrips)
//					{
//						if (seg[idVeh].Trip[nextT].Type == 1)
//							if (seg[idVeh].Trip[nextT].assSP == assSP) varvioTWSP += temp;
//					}
//
//					if (seg[idVeh].Trip[idTrip].vioTWSP > eps)
//						return 1;
//					if (seg[idVeh].Trip[idTrip].waitingS != NO_WS)
//						varcost += (problem->c[lastC][assSP] - problem->disCWSSP[lastC][assSP]);
//					cStartS = problem->leaveSP[assSP][0]; //unload only at eTW1
//				}
//				else //go through WS:
//				{
//					varvioTWSP -= seg[idVeh].Trip[idTrip].vioTWSP;
//					int nextT = idTrip + 1;
//					if (nextT < seg[idVeh].numTrips)
//					{
//						if (seg[idVeh].Trip[nextT].Type == 1)
//							if (seg[idVeh].Trip[nextT].assSP == assSP) 
//							{
//								varvioTWSP -= seg[idVeh].Trip[idTrip].vioTWSP;
//								if (seg[idVeh].Trip[idTrip].vioTWSP > eps) shouldSTOP = 0;
//							}
//					}
//					if (seg[idVeh].Trip[idTrip].waitingS == NO_WS)
//						varcost += (problem->disCWSSP[lastC][assSP] - problem->c[lastC][assSP]);
//					cStartS = PDS_MAX(cArrTimeI, problem->nodeSP[assSP].sTW1) + problem->nodeSP[assSP].unload;
//				}
//			}
//		}
//		if (PDSDIF(cStartS, seg[idVeh].Trip[idTrip].leaveSP) == 0 && shouldSTOP) return 1;
//		return 0;
//}
//
//
//bool Solution::calChangeCONNECTAtSP_PickTrip(int lastC, int idVeh, int idTrip, double &cStartS, double &varvioTWSP, double &varcost, bool &vioTWSPTRUE)
//{
//	//See on 2/12/2013
//	//this procedure copy the calChangeCONNECTAtSP_PickTrip by including a new para vioTWSPTRUE
//	//calculate variation of varcost, varvioTWSP, cStartS when connecting lastC of pickup trip (idVeh, idTrip) with its assSP
//	int	assSP = seg[idVeh].Trip[idTrip].assSP;
//	double	cArrTime = cStartS + problem->c[lastC][assSP];
//	bool shouldSTOP = 1;
//
//		if (PDSINRANGE(cArrTime, problem->nodeSP[assSP].sTW1, problem->nodeSP[assSP].eTW1))
//		{
//			vioTWSPTRUE = 0;
//			varvioTWSP -= seg[idVeh].Trip[idTrip].vioTWSP;
//			int nextT = idTrip + 1;
//			if (nextT < seg[idVeh].numTrips)
//			{
//				if (seg[idVeh].Trip[nextT].Type == 1)
//					if (seg[idVeh].Trip[nextT].assSP == assSP) 
//					{
//						varvioTWSP -= seg[idVeh].Trip[idTrip].vioTWSP;
//						if (seg[idVeh].Trip[idTrip].vioTWSP > eps) shouldSTOP = 0; //before vio, now notVIO --> leaveSP of nextT is changed
//					}
//			}
//
//			if (seg[idVeh].Trip[idTrip].waitingS != NO_WS)
//				varcost += (problem->c[lastC][assSP] - problem->disCWSSP[lastC][assSP]);
//			cStartS = cArrTime + problem->nodeSP[assSP].unload;
//		}
//		else
//		{
//			double temp = cArrTime - problem->nodeSP[assSP].eTW1;
//			if (temp > eps)
//			{
//				vioTWSPTRUE = 1;
//				temp = temp - seg[idVeh].Trip[idTrip].vioTWSP;
//				varvioTWSP += temp;
//				int nextT = idTrip + 1;
//				if (nextT < seg[idVeh].numTrips)
//				{
//					if (seg[idVeh].Trip[nextT].Type == 1)
//						if (seg[idVeh].Trip[nextT].assSP == assSP) varvioTWSP += temp;
//				}
//				if (seg[idVeh].Trip[idTrip].vioTWSP > eps) return 1;
//				if (seg[idVeh].Trip[idTrip].waitingS != NO_WS)
//					varcost += (problem->c[lastC][assSP] - problem->disCWSSP[lastC][assSP]);
//				cStartS = problem->leaveSP[assSP][0]; //unload at eTW1
//			}
//			else
//			{
//				double cArrTimeI = cStartS + problem->disCWSSP[lastC][assSP];
//				temp = cArrTimeI - problem->nodeSP[assSP].eTW1;
//				if (temp > eps) //too soon to go sp directly, too late through WS
//				{
//					vioTWSPTRUE = 1;
//					temp = (problem->nodeSP[assSP].sTW1 - cArrTime - seg[idVeh].Trip[idTrip].vioTWSP);
//					varvioTWSP += temp;
//					int nextT = idTrip + 1;
//					if (nextT < seg[idVeh].numTrips)
//					{
//						if (seg[idVeh].Trip[nextT].Type == 1)
//							if (seg[idVeh].Trip[nextT].assSP == assSP) varvioTWSP += temp;
//					}
//
//					if (seg[idVeh].Trip[idTrip].vioTWSP > eps)
//						return 1;
//					if (seg[idVeh].Trip[idTrip].waitingS != NO_WS)
//						varcost += (problem->c[lastC][assSP] - problem->disCWSSP[lastC][assSP]);
//					cStartS = problem->leaveSP[assSP][0]; //unload only at eTW1
//				}
//				else //go through WS:
//				{
//					vioTWSPTRUE = 0;
//					varvioTWSP -= seg[idVeh].Trip[idTrip].vioTWSP;
//					int nextT = idTrip + 1;
//					if (nextT < seg[idVeh].numTrips)
//					{
//						if (seg[idVeh].Trip[nextT].Type == 1)
//							if (seg[idVeh].Trip[nextT].assSP == assSP)
//							{
//								varvioTWSP -= seg[idVeh].Trip[idTrip].vioTWSP;
//								if (seg[idVeh].Trip[idTrip].vioTWSP > eps) shouldSTOP = 0; //before vio, now notVIO --> leaveSP of nextT is changed
//							}
//					}
//					if (seg[idVeh].Trip[idTrip].waitingS == NO_WS)
//						varcost += (problem->disCWSSP[lastC][assSP] - problem->c[lastC][assSP]);
//					cStartS = PDS_MAX(cArrTimeI, problem->nodeSP[assSP].sTW1) + problem->nodeSP[assSP].unload;
//				}
//			}
//		}
//		if (PDSDIF(cStartS, seg[idVeh].Trip[idTrip].leaveSP) == 0 && shouldSTOP) return 1;
//		return 0;
//}
//
//
//
//
//bool Solution::calChangeCONNECTAtSP_PickTrip_NextDSameSP(int lastC, int idVeh, int idTrip, double &cStartS, double &varvioTWSP, double &varcost)
//{
//	//Update 2/12/2013
//	//this procedure copy the calChangeCONNECTAtSP_PickTrip; nextTrip is Dtrip, sameSP
//	//calculate variation of varcost, varvioTWSP, cStartS when connecting lastC of pickup trip (idVeh, idTrip) with its assSP
//	//return cStartS is the time to leave assSP of nextDTrip sameSP 
//
//	int	assSP = seg[idVeh].Trip[idTrip].assSP;
//	double	cArrTime = cStartS + problem->c[lastC][assSP];
//	bool shouldSTOP = 1;
//
//		if (PDSINRANGE(cArrTime, problem->nodeSP[assSP].sTW1, problem->nodeSP[assSP].eTW1))
//		{
//			if (seg[idVeh].Trip[idTrip].vioTWSP > eps)
//			{
//			   varvioTWSP -= (2*seg[idVeh].Trip[idTrip].vioTWSP);
//			   shouldSTOP = 0; //before vio, now notVIO --> leaveSP of nextT is changed
//			}
//			cStartS = cArrTime + problem->nodeSP[assSP].unload + problem->nodeSP[assSP].load;
//			if (seg[idVeh].Trip[idTrip].waitingS != NO_WS)
//				varcost += (problem->c[lastC][assSP] - problem->disCWSSP[lastC][assSP]);
//		}
//		else
//		{
//			double temp = cArrTime - problem->nodeSP[assSP].eTW1;
//			if (temp > eps)
//			{
//				//vioTWSPTRUE = 1;
//				temp = temp - seg[idVeh].Trip[idTrip].vioTWSP;
//				varvioTWSP += (2*temp);
//				if (seg[idVeh].Trip[idTrip].vioTWSP > eps) return 1;
//				if (seg[idVeh].Trip[idTrip].waitingS != NO_WS)
//					varcost += (problem->c[lastC][assSP] - problem->disCWSSP[lastC][assSP]);
//				cStartS = problem->leaveSP[assSP][2]; //unload and load at eTW1
//			}
//			else
//			{
//				double cArrTimeI = cStartS + problem->disCWSSP[lastC][assSP];
//				temp = cArrTimeI - problem->nodeSP[assSP].eTW1;
//				if (temp > eps) //too soon to go sp directly, too late through WS
//				{
//					//vioTWSPTRUE = 1;
//					temp = (problem->nodeSP[assSP].sTW1 - cArrTime - seg[idVeh].Trip[idTrip].vioTWSP);
//					varvioTWSP += (2*temp);
//					if (seg[idVeh].Trip[idTrip].vioTWSP > eps) return 1;
//					if (seg[idVeh].Trip[idTrip].waitingS != NO_WS)
//						varcost += (problem->c[lastC][assSP] - problem->disCWSSP[lastC][assSP]);
//					cStartS = problem->leaveSP[assSP][2]; //unload and only at eTW1
//				}
//				else //go through WS:
//				{
//					//vioTWSPTRUE = 0;
//					if (seg[idVeh].Trip[idTrip].vioTWSP > eps)
//					{
//						varvioTWSP -= (2*seg[idVeh].Trip[idTrip].vioTWSP);
//						shouldSTOP = 0; //before vio, now notVIO --> leaveSP of nextT is changed
//					}
//					if (seg[idVeh].Trip[idTrip].waitingS == NO_WS)
//						varcost += (problem->disCWSSP[lastC][assSP] - problem->c[lastC][assSP]);
//					cStartS = PDS_MAX(cArrTimeI, problem->nodeSP[assSP].sTW1) + problem->nodeSP[assSP].unload + problem->nodeSP[assSP].load;
//				}
//			}
//		}
//		if (PDSDIF(cStartS, seg[idVeh].Trip[idTrip+1].leaveSP) == 0 && shouldSTOP) return 1;
//		return 0;
//}
//
//
//
//
//
//bool Solution::calChangeCONNECTAtSP_C2CTrip(int lastC, int idVeh, int idTrip, int nextT, double &cStartS, double &varvioTWSP, double &varcost)
//{
//	//Update 2/12/2013
//	//calculate variation of varcost, varvioTWSP, cStartS when connecting lastC of C2C trip (idVeh, idTrip) with its assSP where nextT is its next Dtrip
//	int	assSP = seg[idVeh].Trip[idTrip].nextSP;
//	double	cArrTime = cStartS + problem->c[lastC][assSP];
//	bool shouldSTOP = 1;
//
//		if (PDSINRANGE(cArrTime, problem->nodeSP[assSP].sTW2, problem->nodeSP[assSP].eTW2))
//		{
//			//vioTWSPTRUE = 0;
//			if (seg[idVeh].Trip[nextT].vioTWSP > eps)
//			{
//				varvioTWSP -= seg[idVeh].Trip[nextT].vioTWSP;
//				shouldSTOP = 0; //before vio, now notVIO --> leaveSP of nextT is changed
//			}
//			if (seg[idVeh].Trip[idTrip].waitingS != NO_WS)
//				varcost += (problem->c[lastC][assSP] - problem->disCWSSP[lastC][assSP]);
//			cStartS = cArrTime + problem->nodeSP[assSP].load;
//		}
//		else
//		{
//			double temp = cArrTime - problem->nodeSP[assSP].eTW2;
//			if (temp > eps)
//			{
//				//vioTWSPTRUE = 1;
//				varvioTWSP += (temp - seg[idVeh].Trip[nextT].vioTWSP);
//				
//				if (seg[idVeh].Trip[nextT].vioTWSP > eps) return 1;
//				if (seg[idVeh].Trip[idTrip].waitingS != NO_WS)
//					varcost += (problem->c[lastC][assSP] - problem->disCWSSP[lastC][assSP]);
//				cStartS = problem->leaveSP[assSP][1]; //load only at eTW2
//			}
//			else
//			{
//				double cArrTimeI = cStartS + problem->disCWSSP[lastC][assSP];
//				temp = cArrTimeI - problem->nodeSP[assSP].eTW2;
//				if (temp > eps) //too soon to go sp directly, too late through WS
//				{
//					//vioTWSPTRUE = 1;
//					temp = (problem->nodeSP[assSP].sTW2 - cArrTime - seg[idVeh].Trip[nextT].vioTWSP);
//					varvioTWSP += temp;
//					if (seg[idVeh].Trip[nextT].vioTWSP > eps) return 1;
//					if (seg[idVeh].Trip[idTrip].waitingS != NO_WS)
//						varcost += (problem->c[lastC][assSP] - problem->disCWSSP[lastC][assSP]);
//					cStartS = problem->leaveSP[assSP][1]; //load only at eTW2
//				}
//				else //go through WS:
//				{
//					//vioTWSPTRUE = 0;
//					if (seg[idVeh].Trip[nextT].vioTWSP > eps) 
//					{
//						varvioTWSP -= seg[idVeh].Trip[nextT].vioTWSP;
//						shouldSTOP = 0;  //before vio, now notVIO --> leaveSP of nextT is changed
//					}
//					if (seg[idVeh].Trip[idTrip].waitingS == NO_WS)
//						varcost += (problem->disCWSSP[lastC][assSP] - problem->c[lastC][assSP]);
//					cStartS = PDS_MAX(cArrTimeI, problem->nodeSP[assSP].sTW2) + problem->nodeSP[assSP].load;
//				}
//			}
//		}
//		if (PDSDIF(cStartS, seg[idVeh].Trip[nextT].leaveSP) == 0 && shouldSTOP) return 1;
//		return 0;
//}
//
//
//bool Solution::calChangeCONNECTAtSP_C2CTrip_LastCChanged(int lastC, int idVeh, int idTrip, int nextT, double &cStartS, double &varvioTWSP, double &varcost)
//{
//	//Update 5/12/2013
//	//calculate variation of varcost, varvioTWSP, cStartS when connecting lastC of C2C trip (idVeh, idTrip) with its assSP where nextT is its next Dtrip
//	int	assSP = seg[idVeh].Trip[idTrip].nextSP;
//	double	cArrTime = cStartS + problem->c[lastC][assSP];
//	bool shouldSTOP = 1;
//
//		if (PDSINRANGE(cArrTime, problem->nodeSP[assSP].sTW2, problem->nodeSP[assSP].eTW2) == 1)
//		{
//			//vioTWSPTRUE = 0;
//			if (seg[idVeh].Trip[nextT].vioTWSP > eps)
//			{
//				varvioTWSP -= seg[idVeh].Trip[nextT].vioTWSP;
//				shouldSTOP = 0; //before vio, now notVIO --> leaveSP of nextT is changed
//			}
//			varcost += problem->c[lastC][assSP];
//			cStartS = cArrTime + problem->nodeSP[assSP].load;
//		}
//		else
//		{
//			double temp = cArrTime - problem->nodeSP[assSP].eTW2;
//			if (temp > 0)
//			{
//				//vioTWSPTRUE = 1;
//				varvioTWSP += (temp - seg[idVeh].Trip[nextT].vioTWSP);
//				varcost += problem->c[lastC][assSP];
//				
//				if (seg[idVeh].Trip[nextT].vioTWSP > eps) return 1;
//				cStartS = problem->leaveSP[assSP][1]; //load only at eTW2
//			}
//			else
//			{
//				double cArrTimeI = cStartS + problem->disCWSSP[lastC][assSP];
//				temp = cArrTimeI - problem->nodeSP[assSP].eTW2;
//				if (temp > eps) //too soon to go sp directly, too late through WS
//				{
//					//vioTWSPTRUE = 1;
//					temp = (problem->nodeSP[assSP].sTW2 - cArrTime - seg[idVeh].Trip[nextT].vioTWSP);
//					varvioTWSP += temp;
//					varcost += problem->c[lastC][assSP];
//					if (seg[idVeh].Trip[nextT].vioTWSP > eps) return 1;
//					cStartS = problem->leaveSP[assSP][1]; //load only at eTW2
//				}
//				else //go through WS:
//				{
//					//vioTWSPTRUE = 0;
//					if (seg[idVeh].Trip[nextT].vioTWSP > eps) 
//					{
//						varvioTWSP -= seg[idVeh].Trip[nextT].vioTWSP;
//						shouldSTOP = 0;  //before vio, now notVIO --> leaveSP of nextT is changed
//					}
//					varcost += problem->disCWSSP[lastC][assSP];
//					cStartS = PDS_MAX(cArrTimeI, problem->nodeSP[assSP].sTW2) + problem->nodeSP[assSP].load;
//				}
//			}
//		}
//		if (PDSDIF(cStartS, seg[idVeh].Trip[nextT].leaveSP) == 0 && shouldSTOP) return 1;
//		return 0;
//}
//
//
//
//
//
//
//
//bool Solution::calChangeCONNECTAtSP_PickTrip2(int lastC, int idVeh, int idTrip, double &cStartS, double &varvioTWSP, double &varcost)
//{
//	//See on 2/12/2013
//	//Dif from calChangeCONNECTAtSP_PickTrip: not calculate vioTWSP for the case P_D_SAMESP
//
//	//calculate variation of varcost, varvioTWSP, cStartS when connecting lastC of pickup trip (idVeh, idTrip) with its assSP
//	int	assSP = seg[idVeh].Trip[idTrip].assSP;
//	double	cArrTime = cStartS + problem->c[lastC][assSP];
//
//		if (PDSINRANGE(cArrTime, problem->nodeSP[assSP].sTW1, problem->nodeSP[assSP].eTW1))
//		{
//			varvioTWSP -= seg[idVeh].Trip[idTrip].vioTWSP;
//			if (seg[idVeh].Trip[idTrip].waitingS != NO_WS)
//				varcost += (problem->c[lastC][assSP] - problem->disCWSSP[lastC][assSP]);
//			cStartS = cArrTime + problem->nodeSP[assSP].unload;
//		}
//		else
//		{
//			double temp = cArrTime - problem->nodeSP[assSP].eTW1;
//			if (temp > eps)
//			{
//				temp = temp - seg[idVeh].Trip[idTrip].vioTWSP;
//				varvioTWSP += temp;
//				if (seg[idVeh].Trip[idTrip].vioTWSP > eps) return 1;
//				if (seg[idVeh].Trip[idTrip].waitingS != NO_WS)
//					varcost += (problem->c[lastC][assSP] - problem->disCWSSP[lastC][assSP]);
//				cStartS = problem->leaveSP[assSP][0]; //unload only at eTW1
//			}
//			else
//			{
//				double cArrTimeI = cStartS + problem->disCWSSP[lastC][assSP];
//				temp = cArrTimeI - problem->nodeSP[assSP].eTW1;
//				if (temp > eps) //too soon to go sp directly, too late through WS
//				{
//					temp = (problem->nodeSP[assSP].sTW1 - cArrTime - seg[idVeh].Trip[idTrip].vioTWSP);
//					varvioTWSP += temp;
//					if (seg[idVeh].Trip[idTrip].vioTWSP > eps)
//						return 1;
//					if (seg[idVeh].Trip[idTrip].waitingS != NO_WS)
//						varcost += (problem->c[lastC][assSP] - problem->disCWSSP[lastC][assSP]);
//					cStartS = problem->leaveSP[assSP][0]; //unload only at eTW1
//				}
//				else //go through WS:
//				{
//					varvioTWSP -= seg[idVeh].Trip[idTrip].vioTWSP;
//					if (seg[idVeh].Trip[idTrip].waitingS == NO_WS)
//						varcost += (problem->disCWSSP[lastC][assSP] - problem->c[lastC][assSP]);
//					cStartS = PDS_MAX(cArrTimeI, problem->nodeSP[assSP].sTW1) + problem->nodeSP[assSP].unload;
//				}
//			}
//		}
//		if (PDSDIF(cStartS, seg[idVeh].Trip[idTrip].leaveSP) == 0) return 1;
//		return 0;
//}
//
//
//
//
//void Solution::calChangeCONNECTAtSP_PickTrip2_1(int lastC, int idVeh, int idTrip, double &cStartS, double &vioTWSPNEW, double &varcost)
//{
//	//Dif from calChangeCONNECTAtSP_PickTrip: not calculate vioTWSP for the case P_D_SAMESP
//
//	//calculate variation of varcost, varvioTWSP, cStartS when connecting lastC of pickup trip (idVeh, idTrip) with its assSP
//	int	assSP = seg[idVeh].Trip[idTrip].assSP;
//	double	cArrTime = cStartS + problem->c[lastC][assSP];
//
//		if (PDSINRANGE(cArrTime, problem->nodeSP[assSP].sTW1, problem->nodeSP[assSP].eTW1))
//		{
//			vioTWSPNEW = 0;
//			//varvioTWSP -= seg[idVeh].Trip[idTrip].vioTWSP;
//			if (seg[idVeh].Trip[idTrip].waitingS != NO_WS)
//				varcost += (problem->c[lastC][assSP] - problem->disCWSSP[lastC][assSP]);
//			cStartS = cArrTime + problem->nodeSP[assSP].unload;
//		}
//		else
//		{
//			double temp = cArrTime - problem->nodeSP[assSP].eTW1;
//			if (temp > eps)
//			{
//				vioTWSPNEW = temp;
//				cStartS = problem->leaveSP[assSP][0]; //unload only at eTW1
//				if (seg[idVeh].Trip[idTrip].vioTWSP > eps) return;
//				if (seg[idVeh].Trip[idTrip].waitingS != NO_WS)
//					varcost += (problem->c[lastC][assSP] - problem->disCWSSP[lastC][assSP]);
//			}
//			else
//			{
//				double cArrTimeI = cStartS + problem->disCWSSP[lastC][assSP];
//				temp = cArrTimeI - problem->nodeSP[assSP].eTW1;
//				if (temp > eps) //too soon to go sp directly, too late through WS
//				{
//					vioTWSPNEW = (problem->nodeSP[assSP].sTW1 - cArrTime);
//					cStartS = problem->leaveSP[assSP][0]; //unload only at eTW1
//					if (seg[idVeh].Trip[idTrip].vioTWSP > eps) return;
//					if (seg[idVeh].Trip[idTrip].waitingS != NO_WS)
//						varcost += (problem->c[lastC][assSP] - problem->disCWSSP[lastC][assSP]);
//				}
//				else //go through WS:
//				{
//					vioTWSPNEW = 0;
//					if (seg[idVeh].Trip[idTrip].waitingS == NO_WS)
//						varcost += (problem->disCWSSP[lastC][assSP] - problem->c[lastC][assSP]);
//					cStartS = PDS_MAX(cArrTimeI, problem->nodeSP[assSP].sTW1) + problem->nodeSP[assSP].unload;
//				}
//			}
//		}
//}
//
//
//
//
//
////This procedure will double the value of varvioTWSP in case nextTrip is delivery trip and sameSP:
//bool Solution::calChangeCONNECTAtSP_PickTrip_LastCChanged(int lastC, int idVeh, int idTrip, double &cStartS, double &varvioTWSP, double &varcost)
//{
//	//see on 2/12/2013
//	//lastC is new last cus
//	//ALMOST AS SAME AS Solution::calChangeCONNECTAtSP_PickTrip
//	//calculate variation of varcost, varvioTWSP, cStartS when connecting lastC of pickup trip (idVeh, idTrip) with its assSP
//	int	assSP = seg[idVeh].Trip[idTrip].assSP;
//	double	cArrTime = cStartS + problem->c[lastC][assSP];
//
//		if (PDSINRANGE(cArrTime, problem->nodeSP[assSP].sTW1, problem->nodeSP[assSP].eTW1))
//		{
//			varvioTWSP -= seg[idVeh].Trip[idTrip].vioTWSP;
//			int nextT = idTrip + 1;
//			if (nextT < seg[idVeh].numTrips)
//			{
//				if (seg[idVeh].Trip[nextT].Type == 1)
//					if (seg[idVeh].Trip[nextT].assSP == assSP) 
//						varvioTWSP -= seg[idVeh].Trip[idTrip].vioTWSP;
//			}
//
//			varcost += problem->c[lastC][assSP];
//			cStartS = cArrTime + problem->nodeSP[assSP].unload;
//		}
//		else
//		{
//			double temp = cArrTime - problem->nodeSP[assSP].eTW1;
//			if (temp > eps)
//			{
//				temp = temp - seg[idVeh].Trip[idTrip].vioTWSP;
//				varvioTWSP += temp;
//				int nextT = idTrip + 1;
//				if (nextT < seg[idVeh].numTrips)
//				{
//					if (seg[idVeh].Trip[nextT].Type == 1)
//						if (seg[idVeh].Trip[nextT].assSP == assSP) varvioTWSP += temp;
//				}
//
//				varcost += problem->c[lastC][assSP];
//				if (seg[idVeh].Trip[idTrip].vioTWSP > eps) return 1;
//				cStartS = problem->leaveSP[assSP][0]; //unload only at eTW1
//			}
//			else
//			{
//				double cArrTimeI = cStartS + problem->disCWSSP[lastC][assSP];
//				temp = cArrTimeI - problem->nodeSP[assSP].eTW1;
//				if (temp > eps) //too soon to go sp directly, too late through WS
//				{
//					temp = problem->nodeSP[assSP].sTW1 - cArrTime - seg[idVeh].Trip[idTrip].vioTWSP;
//					varvioTWSP += temp;
//					int nextT = idTrip + 1;
//					if (nextT < seg[idVeh].numTrips)
//					{
//						if (seg[idVeh].Trip[nextT].Type == 1)
//							if (seg[idVeh].Trip[nextT].assSP == assSP) varvioTWSP += temp;
//					}
//					
//					varcost += problem->c[lastC][assSP];
//
//					if (seg[idVeh].Trip[idTrip].vioTWSP > eps) return 1;
//					cStartS = problem->leaveSP[assSP][0]; //unload only at eTW1
//				}
//				else //go through WS:
//				{
//					varvioTWSP -= seg[idVeh].Trip[idTrip].vioTWSP;
//					int nextT = idTrip + 1;
//					if (nextT < seg[idVeh].numTrips)
//					{
//						if (seg[idVeh].Trip[nextT].Type == 1)
//							if (seg[idVeh].Trip[nextT].assSP == assSP)
//								varvioTWSP -= seg[idVeh].Trip[idTrip].vioTWSP;
//					}
//					varcost += problem->disCWSSP[lastC][assSP];
//					cStartS = PDS_MAX(cArrTimeI, problem->nodeSP[assSP].sTW1) + problem->nodeSP[assSP].unload;
//				}
//			}
//		}
//		return 0;
//}
//
//
//
//
//bool Solution::calChangeCONNECTAtSP_PickTrip_LastCChanged(int lastC, int idVeh, int idTrip, double &cStartS, double &varvioTWSP, double &varcost, bool &vioTWSPTRUE)
//{
//	//See on 2/12/2013
//	//DIF FROM calChangeCONNECTAtSP_PickTrip_LastCChanged: include a new para vioTWSPTRUE to indicate if there is vioTWSP after the move
//	//lastC is new last cus
//	//ALMOST AS SAME AS Solution::calChangeCONNECTAtSP_PickTrip
//	//calculate variation of varcost, varvioTWSP, cStartS when connecting lastC of pickup trip (idVeh, idTrip) with its assSP
//	int	assSP = seg[idVeh].Trip[idTrip].assSP;
//	double	cArrTime = cStartS + problem->c[lastC][assSP];
//
//		if (PDSINRANGE(cArrTime, problem->nodeSP[assSP].sTW1, problem->nodeSP[assSP].eTW1))
//		{
//			vioTWSPTRUE = 0;
//			varvioTWSP -= seg[idVeh].Trip[idTrip].vioTWSP;
//			int nextT = idTrip + 1;
//			if (nextT < seg[idVeh].numTrips)
//			{
//				if (seg[idVeh].Trip[nextT].Type == 1)
//					if (seg[idVeh].Trip[nextT].assSP == assSP) varvioTWSP -= seg[idVeh].Trip[idTrip].vioTWSP;
//			}
//			varcost += problem->c[lastC][assSP];
//			cStartS = cArrTime + problem->nodeSP[assSP].unload;
//		}
//		else
//		{
//			double temp = cArrTime - problem->nodeSP[assSP].eTW1;
//			if (temp > eps)
//			{
//				vioTWSPTRUE = 1;
//				temp = temp - seg[idVeh].Trip[idTrip].vioTWSP;
//				varvioTWSP += temp;
//				int nextT = idTrip + 1;
//				if (nextT < seg[idVeh].numTrips)
//				{
//					if (seg[idVeh].Trip[nextT].Type == 1)
//						if (seg[idVeh].Trip[nextT].assSP == assSP) varvioTWSP += temp;
//				}
//
//				varcost += problem->c[lastC][assSP];
//				if (seg[idVeh].Trip[idTrip].vioTWSP > eps) return 1;
//				cStartS = problem->leaveSP[assSP][0]; //unload at eTW1
//			}
//			else
//			{
//				double cArrTimeI = cStartS + problem->disCWSSP[lastC][assSP];
//				temp = cArrTimeI - problem->nodeSP[assSP].eTW1;
//				if (temp > eps) //too soon to go sp directly, too late through WS
//				{
//					vioTWSPTRUE = 1;
//					temp = problem->nodeSP[assSP].sTW1 - cArrTime - seg[idVeh].Trip[idTrip].vioTWSP;
//					varvioTWSP += temp;
//					int nextT = idTrip + 1;
//					if (nextT < seg[idVeh].numTrips)
//					{
//						if (seg[idVeh].Trip[nextT].Type == 1)
//							if (seg[idVeh].Trip[nextT].assSP == assSP) varvioTWSP += temp;
//					}
//					
//					varcost += problem->c[lastC][assSP];
//
//					if (seg[idVeh].Trip[idTrip].vioTWSP > eps) return 1;
//					cStartS = problem->leaveSP[assSP][0]; //unload only at eTW1
//				}
//				else //go through WS:
//				{
//					vioTWSPTRUE = 0;
//					varvioTWSP -= seg[idVeh].Trip[idTrip].vioTWSP;
//					int nextT = idTrip + 1;
//					if (nextT < seg[idVeh].numTrips)
//					{
//						if (seg[idVeh].Trip[nextT].Type == 1)
//							if (seg[idVeh].Trip[nextT].assSP == assSP) varvioTWSP -= seg[idVeh].Trip[idTrip].vioTWSP;
//					}
//					varcost += problem->disCWSSP[lastC][assSP];
//					cStartS = PDS_MAX(cArrTimeI, problem->nodeSP[assSP].sTW1) + problem->nodeSP[assSP].unload;
//				}
//			}
//		}
//		return 0;
//}
//
//
//
//
//bool Solution::calChangeCONNECTAtSP_PickTrip_LastCChanged2(int lastC, int idVeh, int idTrip, double &cStartS, double &varvioTWSP, double &varcost)
//{//See on 2/12/2013
//	//DIF FROM calChangeCONNECTAtSP_PickTrip_LastCChanged: don't check the case p-d-SAMESP
//	//lastC is new last cus
//	//ALMOST AS SAME AS Solution::calChangeCONNECTAtSP_PickTrip
//	//calculate variation of varcost, varvioTWSP, cStartS when connecting lastC of pickup trip (idVeh, idTrip) with its assSP
//	int	assSP = seg[idVeh].Trip[idTrip].assSP;
//	double	cArrTime = cStartS + problem->c[lastC][assSP];
//
//		if (PDSINRANGE(cArrTime, problem->nodeSP[assSP].sTW1, problem->nodeSP[assSP].eTW1))
//		{
//			varvioTWSP -= seg[idVeh].Trip[idTrip].vioTWSP;
//			varcost += problem->c[lastC][assSP];
//			cStartS = cArrTime + problem->nodeSP[assSP].unload;
//		}
//		else
//		{
//			double temp = cArrTime - problem->nodeSP[assSP].eTW1;
//			if (temp > eps)
//			{
//				temp = temp - seg[idVeh].Trip[idTrip].vioTWSP;
//				varvioTWSP += temp;
//				varcost += problem->c[lastC][assSP];
//				if (seg[idVeh].Trip[idTrip].vioTWSP > eps) return 1;
//				cStartS = problem->leaveSP[assSP][0]; //unload only at eTW1
//			}
//			else
//			{
//				double cArrTimeI = cStartS + problem->disCWSSP[lastC][assSP];
//				temp = cArrTimeI - problem->nodeSP[assSP].eTW1;
//				if (temp > eps) //too soon to go sp directly, too late through WS
//				{
//					temp = problem->nodeSP[assSP].sTW1 - cArrTime - seg[idVeh].Trip[idTrip].vioTWSP;
//					varvioTWSP += temp;
//			
//					varcost += problem->c[lastC][assSP];
//
//					if (seg[idVeh].Trip[idTrip].vioTWSP > eps) return 1;
//					cStartS = problem->leaveSP[assSP][0]; //unload only at eTW1
//				}
//				else //go through WS:
//				{
//					varvioTWSP -= seg[idVeh].Trip[idTrip].vioTWSP;
//					varcost += problem->disCWSSP[lastC][assSP];
//					cStartS = PDS_MAX(cArrTimeI, problem->nodeSP[assSP].sTW1) + problem->nodeSP[assSP].unload;
//				}
//			}
//		}
//		return 0;
//}
//
//bool Solution::calChangeCONNECTAtSP_PickTrip(int lastC, int idVeh, int idTrip, double &cStartS) //for procedure UpdateVehicle
//{ //see on 2/12/2013
//	//calculate variation of varcost, varvioTWSP, cStartS when connecting lastC of pickup trip (idVeh, idTrip) with its assSP
//	int	assSP = seg[idVeh].Trip[idTrip].assSP;
//	double	cArrTime = cStartS + problem->c[lastC][assSP];
//	double varcost;
//
//	double varvioTWSP = -seg[idVeh].Trip[idTrip].vioTWSP;
//
//		if (PDSINRANGE(cArrTime, problem->nodeSP[assSP].sTW1, problem->nodeSP[assSP].eTW1))
//		{
//			seg[idVeh].Trip[idTrip].vioTWSP = 0;
//			if (seg[idVeh].Trip[idTrip].vioCAP > 0 || seg[idVeh].Trip[idTrip].vioTWC > eps)
//				seg[idVeh].Trip[idTrip].feasible = 0;
//			else seg[idVeh].Trip[idTrip].feasible = 1;
//
//			if (seg[idVeh].Trip[idTrip].waitingS != NO_WS)
//			{
//				varcost = (problem->c[lastC][assSP] - problem->disCWSSP[lastC][assSP]);
//			    seg[idVeh].Trip[idTrip].waitingS = NO_WS;
//				seg[idVeh].Trip[idTrip].cost += varcost;
//				seg[idVeh].Trip[idTrip].fitness += varcost;
//			}
//			cStartS = cArrTime + problem->nodeSP[assSP].unload;
//		}
//		else
//		{
//			double temp = cArrTime - problem->nodeSP[assSP].eTW1;
//			if (temp > eps)
//			{
//				varvioTWSP += temp;
//				seg[idVeh].Trip[idTrip].feasible = 0;
//				if (seg[idVeh].Trip[idTrip].vioTWSP > eps)
//				{
//					seg[idVeh].Trip[idTrip].vioTWSP = temp;
//					seg[idVeh].Trip[idTrip].fitness += (VTWSP * varvioTWSP);
//					int nextT = idTrip + 1;
//					if (nextT < seg[idVeh].numTrips)
//					{
//						if (seg[idVeh].Trip[nextT].Type == 1)
//							if (seg[idVeh].Trip[nextT].assSP == assSP)
//							{
//								seg[idVeh].Trip[nextT].vioTWSP = temp;
//								seg[idVeh].Trip[nextT].fitness += (VTWSP * varvioTWSP);
//							}
//					}
//					return 1;
//				}
//				seg[idVeh].Trip[idTrip].vioTWSP = temp;
//				if (seg[idVeh].Trip[idTrip].waitingS != NO_WS)
//				{
//					varcost = (problem->c[lastC][assSP] - problem->disCWSSP[lastC][assSP]);
//					seg[idVeh].Trip[idTrip].cost += varcost;
//					seg[idVeh].Trip[idTrip].fitness += varcost;
//					seg[idVeh].Trip[idTrip].waitingS = NO_WS;
//				}
//				cStartS = problem->leaveSP[assSP][0]; //unload at eTW1
//			}
//			else
//			{
//				double cArrTimeI = cStartS + problem->disCWSSP[lastC][assSP];
//				temp = cArrTimeI - problem->nodeSP[assSP].eTW1;
//				if (temp > eps) //too soon to go sp directly, too late through WS
//				{
//					temp = problem->nodeSP[assSP].sTW1 - cArrTime;
//					varvioTWSP += temp;
//					seg[idVeh].Trip[idTrip].feasible = 0;
//					if (seg[idVeh].Trip[idTrip].vioTWSP > eps)
//					{
//						seg[idVeh].Trip[idTrip].vioTWSP = temp;
//						seg[idVeh].Trip[idTrip].fitness += (VTWSP * varvioTWSP);
//						int nextT = idTrip + 1;
//						if (nextT < seg[idVeh].numTrips)
//						{
//							if (seg[idVeh].Trip[nextT].Type == 1)
//								if (seg[idVeh].Trip[nextT].assSP == assSP)
//								{
//									seg[idVeh].Trip[nextT].vioTWSP = temp;
//									seg[idVeh].Trip[nextT].fitness += (VTWSP * varvioTWSP);
//								}
//						}
//						return 1;
//					}
//					seg[idVeh].Trip[idTrip].vioTWSP = temp;
//					if (seg[idVeh].Trip[idTrip].waitingS != NO_WS)
//					{
//						varcost = (problem->c[lastC][assSP] - problem->disCWSSP[lastC][assSP]);
//						seg[idVeh].Trip[idTrip].waitingS = NO_WS;
//						seg[idVeh].Trip[idTrip].cost += varcost;
//						seg[idVeh].Trip[idTrip].fitness += varcost;
//					}
//					cStartS = problem->leaveSP[assSP][0]; //unload only at eTW1
//				}
//				else //go through WS:
//				{
//					if (seg[idVeh].Trip[idTrip].waitingS == NO_WS)
//					{
//						varcost = (problem->disCWSSP[lastC][assSP] - problem->c[lastC][assSP]);
//						seg[idVeh].Trip[idTrip].waitingS = problem->CWSSP[lastC][assSP];
//						seg[idVeh].Trip[idTrip].cost += varcost;
//						seg[idVeh].Trip[idTrip].fitness += varcost;
//					}
//					seg[idVeh].Trip[idTrip].vioTWSP = 0;
//					if (seg[idVeh].Trip[idTrip].vioCAP > 0 || seg[idVeh].Trip[idTrip].vioTWC > eps)
//						seg[idVeh].Trip[idTrip].feasible = 0;
//					else seg[idVeh].Trip[idTrip].feasible = 1;
//
//					cStartS = PDS_MAX(cArrTimeI, problem->nodeSP[assSP].sTW1) + problem->nodeSP[assSP].unload;
//				}
//			}
//		}
//		seg[idVeh].Trip[idTrip].fitness += (VTWSP * varvioTWSP);
//		//if (PDSDIF(cStartS, seg[idVeh].Trip[idTrip].leaveSP)==0 && shouldSTOP) return 1;
//		seg[idVeh].Trip[idTrip].leaveSP = cStartS;
//		return 0;
//}
//
//
//
//void Solution::calChangeCONNECTAtSP_PickTrip2(int lastC, int idVeh, int idTrip, double cStartS) //for procedure subInsertPickupTrip
//{
//	//DIF FROM calChangeCONNECTAtSP_PickTrip(int lastC, int idVeh, int idTrip, double &cStartS): not calculate vioTWSP for the case P_D_SAMESP
//	//calculate variation of varcost, varvioTWSP, cStartS when connecting lastC of pickup trip (idVeh, idTrip) with its assSP
//	int	assSP = seg[idVeh].Trip[idTrip].assSP;
//	double	cArrTime = cStartS + problem->c[lastC][assSP];
//	double varcost;
//
//	double varvioTWSP = -seg[idVeh].Trip[idTrip].vioTWSP;
//
//		if (PDSINRANGE(cArrTime, problem->nodeSP[assSP].sTW1, problem->nodeSP[assSP].eTW1))
//		{
//			seg[idVeh].Trip[idTrip].vioTWSP = 0;
//			if (seg[idVeh].Trip[idTrip].vioCAP > 0 || seg[idVeh].Trip[idTrip].vioTWC > eps)
//				seg[idVeh].Trip[idTrip].feasible = 0;
//			else seg[idVeh].Trip[idTrip].feasible = 1;
//
//			if (seg[idVeh].Trip[idTrip].waitingS != NO_WS)
//			{
//				varcost = (problem->c[lastC][assSP] - problem->disCWSSP[lastC][assSP]);
//			    seg[idVeh].Trip[idTrip].waitingS = NO_WS;
//				seg[idVeh].Trip[idTrip].cost += varcost;
//				seg[idVeh].Trip[idTrip].fitness += varcost;
//			}
//			cStartS = cArrTime + problem->nodeSP[assSP].unload;
//		}
//		else
//		{
//			double temp = cArrTime - problem->nodeSP[assSP].eTW1;
//			if (temp > eps)
//			{
//				varvioTWSP += temp;
//				seg[idVeh].Trip[idTrip].feasible = 0;
//				if (seg[idVeh].Trip[idTrip].vioTWSP > eps)
//				{
//					seg[idVeh].Trip[idTrip].vioTWSP = temp;
//					seg[idVeh].Trip[idTrip].fitness += (VTWSP * varvioTWSP);
//					return;
//				}
//				seg[idVeh].Trip[idTrip].vioTWSP = temp;
//				if (seg[idVeh].Trip[idTrip].waitingS != NO_WS)
//				{
//					varcost = (problem->c[lastC][assSP] - problem->disCWSSP[lastC][assSP]);
//					seg[idVeh].Trip[idTrip].cost += varcost;
//					seg[idVeh].Trip[idTrip].fitness += varcost;
//					seg[idVeh].Trip[idTrip].waitingS = NO_WS;
//				}
//				cStartS = problem->leaveSP[assSP][0]; //unload at eTW1
//			}
//			else
//			{
//				double cArrTimeI = cStartS + problem->disCWSSP[lastC][assSP];
//				temp = cArrTimeI - problem->nodeSP[assSP].eTW1;
//				if (temp > eps) //too soon to go sp directly, too late through WS
//				{
//					temp = problem->nodeSP[assSP].sTW1 - cArrTime;
//					varvioTWSP += temp;
//					seg[idVeh].Trip[idTrip].feasible = 0;
//					if (seg[idVeh].Trip[idTrip].vioTWSP > eps)
//					{
//						seg[idVeh].Trip[idTrip].vioTWSP = temp;
//						seg[idVeh].Trip[idTrip].fitness += (VTWSP * varvioTWSP);
//						return;
//					}
//					seg[idVeh].Trip[idTrip].vioTWSP = temp;
//					if (seg[idVeh].Trip[idTrip].waitingS != NO_WS)
//					{
//						varcost = (problem->c[lastC][assSP] - problem->disCWSSP[lastC][assSP]);
//						seg[idVeh].Trip[idTrip].waitingS = NO_WS;
//						seg[idVeh].Trip[idTrip].cost += varcost;
//						seg[idVeh].Trip[idTrip].fitness += varcost;
//					}
//					cStartS = problem->leaveSP[assSP][0]; //unload only at eTW1
//				}
//				else //go through WS:
//				{
//					if (seg[idVeh].Trip[idTrip].waitingS == NO_WS)
//					{
//						varcost = (problem->disCWSSP[lastC][assSP] - problem->c[lastC][assSP]);
//						seg[idVeh].Trip[idTrip].waitingS = problem->CWSSP[lastC][assSP];
//						seg[idVeh].Trip[idTrip].cost += varcost;
//						seg[idVeh].Trip[idTrip].fitness += varcost;
//					}
//					seg[idVeh].Trip[idTrip].vioTWSP = 0;
//					if (seg[idVeh].Trip[idTrip].vioCAP > 0 || seg[idVeh].Trip[idTrip].vioTWC > eps)
//						seg[idVeh].Trip[idTrip].feasible = 0;
//					else seg[idVeh].Trip[idTrip].feasible = 1;
//					cStartS = PDS_MAX(cArrTimeI, problem->nodeSP[assSP].sTW1) + problem->nodeSP[assSP].unload;
//				}
//			}
//		}
//		seg[idVeh].Trip[idTrip].fitness += (VTWSP * varvioTWSP);
//		seg[idVeh].Trip[idTrip].leaveSP = cStartS;
//}
//
//
//
//
//bool Solution::calChangeCONNECTAtSP_SPSP(int idVeh, int idTrip, int preT, double &cStartS, double &varvioTWSP, double &varcost)
//{
//	//See on 2/12/2013
//	//calculate variation of varcost, varvioTWSP, cStartS when connecting assSP of pickup trip (idVeh, preT) with assSP1 of delivery trip (idVeh, idTrip)
//	int assSP = seg[idVeh].Trip[preT].assSP;
//	int assSP1 = seg[idVeh].Trip[idTrip].assSP;
//
//	double cArrTime = cStartS + problem->c[assSP][assSP1];
//	if (PDSINRANGE(cArrTime, problem->nodeSP[assSP1].sTW2, problem->nodeSP[assSP1].eTW2))
//	{
//		varvioTWSP -= seg[idVeh].Trip[idTrip].vioTWSP;
//		if (seg[idVeh].Trip[preT].waitingS1 != NO_WS)
//			varcost += (problem->c[assSP][assSP1] - problem->disCWSSP[assSP][assSP1]);
//		cStartS = cArrTime + problem->nodeSP[assSP1].load;
//	}
//	else
//	{
//		double temp = cArrTime - problem->nodeSP[assSP1].eTW2;
//		if (temp > eps)
//		{
//			varvioTWSP += (temp - seg[idVeh].Trip[idTrip].vioTWSP);
//			if (seg[idVeh].Trip[idTrip].vioTWSP > eps) return 1;
//			if (seg[idVeh].Trip[preT].waitingS1 != NO_WS)
//				varcost += (problem->c[assSP][assSP1] - problem->disCWSSP[assSP][assSP1]);
//			cStartS = problem->leaveSP[assSP1][1]; //load only at eTW2
//		}
//		else
//		{
//			double cArrTimeI = cStartS + problem->disCWSSP[assSP][assSP1];
//			temp = cArrTimeI - problem->nodeSP[assSP1].eTW2;
//			if (temp > eps) //too soon to go sp directly, too late to go through WS:
//			{
//				varvioTWSP += (problem->nodeSP[assSP1].sTW2 - cArrTime - seg[idVeh].Trip[idTrip].vioTWSP);
//				if (seg[idVeh].Trip[idTrip].vioTWSP > eps) return 1;
//				if (seg[idVeh].Trip[preT].waitingS1 != NO_WS)
//					varcost += (problem->c[assSP][assSP1] - problem->disCWSSP[assSP][assSP1]);
//				cStartS = problem->leaveSP[assSP1][1]; //load only at eTW2
//			}
//			else //go through WS:
//			{
//				varvioTWSP -= seg[idVeh].Trip[idTrip].vioTWSP;
//				if (seg[idVeh].Trip[preT].waitingS1 == NO_WS)
//					varcost += (problem->disCWSSP[assSP][assSP1] - problem->c[assSP][assSP1]);
//				cStartS = PDS_MAX(cArrTimeI, problem->nodeSP[assSP1].sTW2) + problem->nodeSP[assSP1].load;
//			}
//		}
//	}
//	return 0;
//}
//
//
//bool Solution::updateChangeCONNECTAtSP_SPSP(int idVeh, int idTrip, int preT, double &cStartS) //for procedure UpdateVehicle
//{
//	//see on 2/12/2013
//	//calculate variation of varcost, varvioTWSP, cStartS when connecting assSP of pickup trip (idVeh, preT) with assSP1 of delivery trip (idVeh, idTrip)
//	int assSP = seg[idVeh].Trip[preT].assSP;
//	int assSP1 = seg[idVeh].Trip[idTrip].assSP;
//
//	double cArrTime = cStartS + problem->c[assSP][assSP1];
//	double varvioTWSP = -seg[idVeh].Trip[idTrip].vioTWSP;
//    double varcost;
//
//	if (PDSINRANGE(cArrTime, problem->nodeSP[assSP1].sTW2, problem->nodeSP[assSP1].eTW2))
//	{
//		if (seg[idVeh].Trip[preT].waitingS1 != NO_WS)
//		{
//			varcost = (problem->c[assSP][assSP1] - problem->disCWSSP[assSP][assSP1]);
//			seg[idVeh].Trip[preT].waitingS1 = NO_WS;
//			seg[idVeh].Trip[preT].connectCost = problem->c[assSP][assSP1];
//			seg[idVeh].Trip[preT].cost += varcost;
//			seg[idVeh].Trip[preT].fitness += varcost;
//		}
//		seg[idVeh].Trip[idTrip].vioTWSP = 0;
//		cStartS = cArrTime + problem->nodeSP[assSP1].load;
//	}
//	else
//	{
//		double temp = cArrTime - problem->nodeSP[assSP1].eTW2;
//		if (temp > eps)
//		{
//			varvioTWSP += temp;
//			if (seg[idVeh].Trip[idTrip].vioTWSP > eps)
//			{
//				seg[idVeh].Trip[idTrip].vioTWSP = temp;
//				seg[idVeh].Trip[idTrip].fitness += (VTWSP * varvioTWSP);
//				seg[idVeh].Trip[idTrip].feasible = 0;
//				return 1;
//			}
//			seg[idVeh].Trip[idTrip].vioTWSP = temp;
//			if (seg[idVeh].Trip[preT].waitingS1 != NO_WS)
//			{
//				varcost = (problem->c[assSP][assSP1] - problem->disCWSSP[assSP][assSP1]);
//				seg[idVeh].Trip[preT].waitingS1 = NO_WS;
//				seg[idVeh].Trip[preT].connectCost = problem->c[assSP][assSP1];
//				seg[idVeh].Trip[preT].cost += varcost;
//				seg[idVeh].Trip[preT].fitness += varcost;
//			}
//			cStartS = problem->leaveSP[assSP1][1]; //load only at eTW2
//		}
//		else
//		{
//			double cArrTimeI = cStartS + problem->disCWSSP[assSP][assSP1];
//			temp = cArrTimeI - problem->nodeSP[assSP1].eTW2;
//			if (temp > eps) //too soon to go sp directly, too late to go through WS:
//			{
//				temp = problem->nodeSP[assSP1].sTW2 - cArrTime;
//				varvioTWSP += temp;
//				if (seg[idVeh].Trip[idTrip].vioTWSP > eps)
//				{
//					seg[idVeh].Trip[idTrip].vioTWSP = temp;
//					seg[idVeh].Trip[idTrip].fitness += (VTWSP * varvioTWSP);
//					seg[idVeh].Trip[idTrip].feasible = 0;
//					return 1;
//				}
//				seg[idVeh].Trip[idTrip].vioTWSP = temp;
//				if (seg[idVeh].Trip[preT].waitingS1 != NO_WS)
//				{
//					varcost = (problem->c[assSP][assSP1] - problem->disCWSSP[assSP][assSP1]);
//					seg[idVeh].Trip[preT].waitingS1 = NO_WS;
//					seg[idVeh].Trip[preT].connectCost = problem->c[assSP][assSP1];
//					seg[idVeh].Trip[preT].cost += varcost;
//					seg[idVeh].Trip[preT].fitness += varcost;
//				}
//				cStartS = problem->leaveSP[assSP1][1]; //load only at eTW2
//			}
//			else //go through WS:
//			{
//				seg[idVeh].Trip[idTrip].vioTWSP = 0;
//				if (seg[idVeh].Trip[preT].waitingS1 == NO_WS)
//				{
//					varcost = (problem->disCWSSP[assSP][assSP1] - problem->c[assSP][assSP1]);
//					seg[idVeh].Trip[preT].waitingS1 = problem->CWSSP[assSP][assSP1];
//					seg[idVeh].Trip[preT].connectCost = problem->disCWSSP[assSP][assSP1];
//					seg[idVeh].Trip[preT].cost += varcost;
//					seg[idVeh].Trip[preT].fitness += varcost;
//				}
//				cStartS = PDS_MAX(cArrTimeI, problem->nodeSP[assSP1].sTW2) + problem->nodeSP[assSP1].load;
//			}
//		}
//	}
//	seg[idVeh].Trip[idTrip].fitness += (VTWSP * varvioTWSP);
//	if (PDSDIF(seg[idVeh].Trip[idTrip].leaveSP, cStartS) == 0) 
//	{
//		if (seg[idVeh].Trip[idTrip].vioCAP > 0 || seg[idVeh].Trip[idTrip].vioTWC > eps || seg[idVeh].Trip[idTrip].vioTWSP > eps)
//			seg[idVeh].Trip[idTrip].feasible = 0;
//		else seg[idVeh].Trip[idTrip].feasible = 1;
//		return 1;
//	}
//	seg[idVeh].Trip[idTrip].leaveSP = cStartS;
//	return 0;
//}
//
//void Solution::updateChangeCONNECTAtSP_SPSP(int idVeh, int idTrip, int preT, int varvioCAP, int update_idTrip) //for Update_EmptyTripD and Update_EmptyTripP, delete_insertCusPTrip: connect pickuptrip(idVeh, preT) with delivery trip (idVeh, idTrip) 
//{
//	//Same as updateChangeCONNECTAtSP_SPSP(int idVeh, int idTrip, int preT, int varvioCAP); 
//	//except that: just update remaining trips till update_idTrip trip rather than all remaining trips of idVeh
//
//		int assSPnextT = seg[idVeh].Trip[idTrip].assSP;
//		int assSPpreT = seg[idVeh].Trip[preT].assSP;
//		double varC = -seg[idVeh].Trip[preT].connectCost;
//
//		double cArrTime = seg[idVeh].Trip[preT].leaveSP + problem->c[assSPpreT][assSPnextT];
//		double varvioTWSP = -seg[idVeh].Trip[idTrip].vioTWSP;
//		if (PDSINRANGE(cArrTime, problem->nodeSP[assSPnextT].sTW2, problem->nodeSP[assSPnextT].eTW2))
//		{
//			varC += problem->c[assSPpreT][assSPnextT];
//			seg[idVeh].Trip[preT].waitingS1 = NO_WS;
//			seg[idVeh].Trip[preT].connectCost = problem->c[assSPpreT][assSPnextT];
//			seg[idVeh].Trip[preT].cost += varC;
//			seg[idVeh].Trip[preT].fitness += varC;
//
//			//before delete: go to sp directly: FEA OR INFEASIBLE or through WS
//			seg[idVeh].Trip[idTrip].vioTWSP = 0;
//			seg[idVeh].Trip[idTrip].fitness += (VTWSP * varvioTWSP);
//			seg[idVeh].Trip[idTrip].leaveSP = cArrTime + problem->nodeSP[assSPnextT].load;
//			//cout<<"LEAVESP of ("<<idVeh<<", "<<idTrip<<" = "<<seg[idVeh].Trip[idTrip].leaveSP<<"; cArrTime = "<<cArrTime<<endl;
//			UpdateVehicle(idVeh, idTrip, assSPnextT, seg[idVeh].Trip[idTrip].leaveSP, varvioCAP, update_idTrip);
//		}
//		else
//		{
//			double temp = cArrTime - problem->nodeSP[assSPnextT].eTW2;
//			if (temp > eps) //too late to go sp directly
//			{
//				varC += problem->c[assSPpreT][assSPnextT];
//				seg[idVeh].Trip[preT].waitingS1 = NO_WS;
//				seg[idVeh].Trip[preT].connectCost = problem->c[assSPpreT][assSPnextT];
//				seg[idVeh].Trip[preT].cost += varC;
//				seg[idVeh].Trip[preT].fitness += varC;
//
//				varvioTWSP += temp; //Update 7/11/2013
//				if (seg[idVeh].Trip[idTrip].vioTWSP > eps) //don't need to update all remaining trips
//				{
//					seg[idVeh].Trip[idTrip].vioTWSP = temp;
//					seg[idVeh].Trip[idTrip].fitness += (VTWSP * varvioTWSP);
//				}
//				else //need to update all remaining trips:
//				{
//					seg[idVeh].Trip[idTrip].vioTWSP = temp;
//					seg[idVeh].Trip[idTrip].fitness += (VTWSP * varvioTWSP);
//					seg[idVeh].Trip[idTrip].leaveSP = problem->leaveSP[assSPnextT][1]; //load only at eTW2
//					//cout<<"LEAVESP of ("<<idVeh<<", "<<idTrip<<" = "<<seg[idVeh].Trip[idTrip].leaveSP<<": TOO LATE TO SP DIRECTLY"<<endl;
//					UpdateVehicle(idVeh, idTrip, assSPnextT, seg[idVeh].Trip[idTrip].leaveSP, varvioCAP, update_idTrip);
//				}
//			}
//			else
//			{
//				double cArrTimeI = seg[idVeh].Trip[preT].leaveSP + problem->disCWSSP[assSPpreT][assSPnextT];
//				temp = cArrTimeI - problem->nodeSP[assSPnextT].eTW2;
//				if (temp > eps)
//				{
//					varC += problem->c[assSPpreT][assSPnextT];
//					seg[idVeh].Trip[preT].waitingS1 = NO_WS;
//					seg[idVeh].Trip[preT].connectCost = problem->c[assSPpreT][assSPnextT];
//					seg[idVeh].Trip[preT].cost += varC;
//					seg[idVeh].Trip[preT].fitness += varC;
//
//					//before delete: go to sp directly FEA OR INFEA
//					temp = problem->nodeSP[assSPnextT].sTW2 - cArrTime;
//					varvioTWSP += temp;
//					if (seg[idVeh].Trip[idTrip].vioTWSP > eps) //don't need to update all remaining trips
//					{
//						seg[idVeh].Trip[idTrip].vioTWSP = temp;
//						seg[idVeh].Trip[idTrip].fitness += (VTWSP * varvioTWSP);
//					}
//					else //need to update all remaining trips:
//					{
//						seg[idVeh].Trip[idTrip].vioTWSP = temp;
//						seg[idVeh].Trip[idTrip].fitness += (VTWSP * varvioTWSP);
//						seg[idVeh].Trip[idTrip].leaveSP = problem->leaveSP[assSPnextT][1]; //load only at eTW2
//						//cout<<"LEAVESP of ("<<idVeh<<", "<<idTrip<<" = "<<seg[idVeh].Trip[idTrip].leaveSP<<"; TOO SOON SP DIRECTLY, TOO LATE THROUGH WS"<<endl;
//						UpdateVehicle(idVeh, idTrip, assSPnextT, seg[idVeh].Trip[idTrip].leaveSP, varvioCAP, update_idTrip);
//					}
//				}
//				else //go through WS:
//				{
//					varC += problem->disCWSSP[assSPpreT][assSPnextT];
//					seg[idVeh].Trip[preT].waitingS1 = problem->CWSSP[assSPpreT][assSPnextT];
//					seg[idVeh].Trip[preT].connectCost = problem->disCWSSP[assSPpreT][assSPnextT];
//					seg[idVeh].Trip[preT].cost += varC;
//					seg[idVeh].Trip[preT].fitness += varC;
//					
//					seg[idVeh].Trip[idTrip].vioTWSP = 0;
//					seg[idVeh].Trip[idTrip].fitness += (VTWSP * varvioTWSP);
//					seg[idVeh].Trip[idTrip].leaveSP = PDS_MAX(cArrTimeI, problem->nodeSP[assSPnextT].sTW2) + problem->nodeSP[assSPnextT].load;
//					//cout<<"LEAVESP of ("<<idVeh<<", "<<idTrip<<" = "<<seg[idVeh].Trip[idTrip].leaveSP<<"; cArrTimeI = "<<cArrTimeI<<"; PDS_MAX(cArrTimeI, sTW2) = "<<PDS_MAX(cArrTimeI, problem->nodeSP[assSPnextT].sTW2)<<endl;
//					UpdateVehicle(idVeh, idTrip, assSPnextT, seg[idVeh].Trip[idTrip].leaveSP, varvioCAP, update_idTrip);
//				}
//			}
//		}
//}
//
//
//
//
//void Solution::updateChangeCONNECTAtSP_SameSP(int idVeh, int idTrip, int preT, int varvioCAP, int update_idTrip) //for Update_EmptyTripC2C
//{
//	//15/12/2013
//	    //Create new PDTrip
//		int assSP = seg[idVeh].Trip[idTrip].assSP;
//		seg[idVeh].Trip[preT].waitingS1 = NO_WS;
//		seg[idVeh].Trip[preT].cost -= seg[idVeh].Trip[preT].connectCost;
//		seg[idVeh].Trip[preT].fitness -= seg[idVeh].Trip[preT].connectCost;
//		seg[idVeh].Trip[preT].connectCost = 0;
//
//		double varvioTWSP = seg[idVeh].Trip[preT].vioTWSP - seg[idVeh].Trip[idTrip].vioTWSP;
//		seg[idVeh].Trip[idTrip].vioTWSP = seg[idVeh].Trip[preT].vioTWSP;
//		seg[idVeh].Trip[idTrip].fitness += (VTWSP * varvioTWSP);
//		seg[idVeh].Trip[idTrip].leaveSP = seg[idVeh].Trip[preT].leaveSP + problem->nodeSP[assSP].load;
//		UpdateVehicle(idVeh, idTrip, assSP, seg[idVeh].Trip[idTrip].leaveSP, varvioCAP, update_idTrip);
//}
//
//void Solution::cal_InsertCusDIntoEmptyVeh(int idCus, int startSP) //once we call this, that mean the solution has an empty vehicle:
//{
//	//See on 2/12/2013
//	//don't need to check if there is an empty vehicle in the solution: numUsedVeh < numVeh
//	double cArrTime = problem->leaveSP[startSP][4] + problem->c[startSP][idCus];
//	double temp = cArrTime - problem->node[idCus].eTW;
//	if (temp > eps)
//		insertCusEmptyVeh[idCus]->var_vioTWC = temp;
//	else
//		insertCusEmptyVeh[idCus]->var_vioTWC=0;
//	insertCusEmptyVeh[idCus]->var_cost = problem->c[0][startSP] + problem->c[startSP][idCus] + problem->c[idCus][0];
//}
//
//
//
//void Solution::cal_InsertCusDIAfterJ_LastC_LastTrip(int j, int k,int idVeh, int idTrip)
//{
//	//See on 2/12/2013
//	int i = problem->node[j].neighborNode[k].id; //insert customer i after j
//    double cArrTime, temp;
//
//	cArrTime = depart[j] + problem->c[j][i];
//	temp = cArrTime - problem->node[i].eTW;
//	if (temp > eps) insertCus[j][k]->var_vioTWC = temp;
//	else insertCus[j][k]->var_vioTWC = 0;
//    insertCus[j][k]->var_cost = (problem->c[j][i] + problem->c[i][0]) - problem->c[j][0];
//    insertCus[j][k]->var_vioTWSP = 0;
//    insertCus[j][k]->var_vioCAP = PDS_MAX(seg[idVeh].Trip[idTrip].capacity + problem->node[i].capacity - problem->Q,0) - seg[idVeh].Trip[idTrip].vioCAP;
//    insertCus[j][k]->atIT = IT;
//}
//
//void Solution::cal_InsertCusDIAfterJ_NotLastC_LastTrip(int j, int k,int idVeh, int idTrip)
//{
//	//See on 2/12/2013
//	int i = problem->node[j].neighborNode[k].id; //insert customer i after j
//    double cArrTime, cStartS, temp;
//
//	cArrTime = depart[j] + problem->c[j][i];
//	temp = cArrTime - problem->node[i].eTW;
//	int nextC = nextArr[j];
//
//	    double vioTWCNEW = FvioTWCus[j];
//		if (temp > eps)
//		{
//			vioTWCNEW += temp;
//			cStartS = problem->node[i].depart;
//		}
//		else
//			cStartS = PDS_MAX(cArrTime, problem->node[i].sTW) + problem->node[i].duration;
//
//		int idcur = i; 
//		insertCus[j][k]->var_cost = (problem->c[j][i] + problem->c[i][nextC]) - problem->c[j][nextC];
//		insertCus[j][k]->var_vioCAP = PDS_MAX(seg[idVeh].Trip[idTrip].capacity + problem->node[i].capacity - problem->Q,0) - seg[idVeh].Trip[idTrip].vioCAP;
//		insertCus[j][k]->var_vioTWSP = 0;
//		insertCus[j][k]->atIT = IT;
//
//		do
//		{
//          cArrTime = cStartS + problem->c[idcur][nextC]; //Arrive Time to Customer nextC
//		  temp = cArrTime - problem->node[nextC].eTW;
//          if (temp > eps)
//		  {
//			  vioTWCNEW += temp;
//			  if (vioTWCus[nextC] > eps) 
//			  {
//					insertCus[j][k]->var_vioTWC = vioTWCNEW - FvioTWCus[nextC];
//				    return;
//			  }
//			  cStartS = problem->node[nextC].depart;
//		  }
//		  else
//		  {
//			  cStartS = PDS_MAX(cArrTime, problem->node[nextC].sTW) + problem->node[nextC].duration;
//		  }
//		  idcur=nextC; nextC= nextArr[nextC];
//		}while (nextC > 0);
//		insertCus[j][k]->var_vioTWC = vioTWCNEW - seg[idVeh].Trip[idTrip].vioTWC;
//}
//
//
//void Solution::cal_InsertCusDIAfterJ_LastC_NextTripP_OR_C2C(int j, int k, int idVeh, int idTrip)
//{
//	//See on 2/12/2013
//	int i = problem->node[j].neighborNode[k].id; //insert customer i after j
//    double varcost, varvioTWC, varvioTWSP; 
//    double cArrTime, cStartS, temp;
//
//	int nextT = idTrip + 1;
//	int firstC_nextT = seg[idVeh].Trip[nextT].firstCus;
//   
//	insertCus[j][k]->var_vioCAP = PDS_MAX(seg[idVeh].Trip[idTrip].capacity + problem->node[i].capacity - problem->Q,0) - seg[idVeh].Trip[idTrip].vioCAP;
//    
//	cArrTime = depart[j] + problem->c[j][i];
//	temp = cArrTime - problem->node[i].eTW;
//	if (temp > eps) 
//	{
//		varvioTWC = temp;
//		cStartS = problem->node[i].depart;
//	}
//	else 
//	{
//		varvioTWC = 0;
//		cStartS = PDS_MAX(cArrTime, problem->node[i].sTW) + problem->node[i].duration;
//	}
//	varcost = problem->c[j][i] + problem->c[i][firstC_nextT] - problem->c[j][firstC_nextT];
//	varvioTWSP = 0;
//	GoThroughVehicle(idVeh, nextT, varcost, varvioTWC, varvioTWSP, cStartS, i, firstC_nextT);
//    
//	insertCus[j][k]->var_vioTWC = varvioTWC;
//    insertCus[j][k]->var_vioTWSP = varvioTWSP;
//	insertCus[j][k]->var_cost = varcost;
//	insertCus[j][k]->atIT = IT;
//}
//
//
//
//void Solution::cal_InsertCusDIAfterJ_NotLastC_NextTripP_OR_C2C(int j, int k, int idVeh, int idTrip)
//{
//	//See on 2/12/2013
//	int i = problem->node[j].neighborNode[k].id; //insert customer i after j
//    double varcost, varvioTWC, varvioTWSP; 
//    double cArrTime, cStartS, temp;
//
//	int nextT = idTrip + 1;
//	int firstC_nextT = seg[idVeh].Trip[nextT].firstCus;
//   
//	insertCus[j][k]->var_vioCAP = PDS_MAX(seg[idVeh].Trip[idTrip].capacity + problem->node[i].capacity - problem->Q,0) - seg[idVeh].Trip[idTrip].vioCAP;
//    insertCus[j][k]->atIT = IT;
//
//	cArrTime = depart[j] + problem->c[j][i];
//	temp = cArrTime - problem->node[i].eTW;
//	varvioTWC = FvioTWCus[j];
//	if (temp > eps)
//	{
//		varvioTWC += temp;
//		cStartS = problem->node[i].depart;
//	}
//	else cStartS = PDS_MAX(cArrTime, problem->node[i].sTW) + problem->node[i].duration;
//	int nextC = nextArr[j];
//	varcost = problem->c[j][i] + problem->c[i][nextC] - problem->c[j][nextC];
//	int idcur = i;
//	do
//	{
//		cArrTime = cStartS + problem->c[idcur][nextC];
//		temp = cArrTime - problem->node[nextC].eTW;
//		if (temp > eps)
//		{
//			 varvioTWC += temp;
//			 if (vioTWCus[nextC] > eps)
//			 {
//				 insertCus[j][k]->var_vioTWC = varvioTWC - FvioTWCus[nextC];
//				 insertCus[j][k]->var_vioTWSP = 0;
//				 insertCus[j][k]->var_cost = varcost;
//				 return;
//			 }
//			 cStartS = problem->node[nextC].depart;
//		}
//		else cStartS = PDS_MAX(cArrTime, problem->node[nextC].sTW) + problem->node[nextC].duration;
//		idcur = nextC; nextC = nextArr[nextC];
//	}while (nextC > 0);
//	//idcur now points to the last delivery customer
//	varvioTWC -= seg[idVeh].Trip[idTrip].vioTWC;
//	varvioTWSP = 0;
//    GoThroughVehicle(idVeh, nextT, varcost, varvioTWC, varvioTWSP, cStartS, idcur, firstC_nextT);
//    insertCus[j][k]->var_vioTWC = varvioTWC;
//    insertCus[j][k]->var_vioTWSP = varvioTWSP;
//	insertCus[j][k]->var_cost = varcost;
//}
//
//
//
//void Solution::cal_InsertCusDIAfterJ_LastC_NextTripD(int j, int k, int idVeh, int idTrip)
//{
//	//See on 2/12/2013
//	int i = problem->node[j].neighborNode[k].id; //insert customer i after j
//    double varcost, varvioTWC, varvioTWSP; 
//    double cArrTime, cStartS, temp;
//
//	int nextT = idTrip + 1;
//	int firstC_nextT = seg[idVeh].Trip[nextT].firstCus;
//	int assSP1 = seg[idVeh].Trip[nextT].assSP;
//   
//	insertCus[j][k]->var_vioCAP = PDS_MAX(seg[idVeh].Trip[idTrip].capacity + problem->node[i].capacity - problem->Q,0) - seg[idVeh].Trip[idTrip].vioCAP;
//    insertCus[j][k]->atIT = IT;
//
//	cArrTime = depart[j] + problem->c[j][i];
//	temp = cArrTime - problem->node[i].eTW;
//	if (temp > eps) 
//	{
//		varvioTWC = temp;
//		cStartS = problem->node[i].depart;
//	}
//	else 
//	{
//		varvioTWC = 0;
//		cStartS = PDS_MAX(cArrTime, problem->node[i].sTW) + problem->node[i].duration;
//	}
//	varcost = problem->c[j][i];
//
//		cArrTime = cStartS + problem->c[i][assSP1];
//		if (PDSINRANGE(cArrTime, problem->nodeSP[assSP1].sTW2, problem->nodeSP[assSP1].eTW2))
//		{
//			varvioTWSP = -seg[idVeh].Trip[nextT].vioTWSP;
//			//before insertion may go to sp directly: FEA OR INFEA; OR go through WS:
//			varcost += problem->c[i][assSP1];
//			if (seg[idVeh].Trip[idTrip].waitingS == NO_WS)
//				varcost -= problem->c[j][assSP1];
//			else varcost -= problem->disCWSSP[j][assSP1];
//			cStartS = cArrTime + problem->nodeSP[assSP1].load;
//		}
//		else
//		{
//			temp = cArrTime - problem->nodeSP[assSP1].eTW2;
//			if (temp > eps)
//			{
//				varvioTWSP = temp - seg[idVeh].Trip[nextT].vioTWSP;
//				varcost += problem->c[i][assSP1];
//				//before insertion: may go to sp directly: FEA OR INFEA; OR go through WS
//				if (seg[idVeh].Trip[idTrip].waitingS == NO_WS)
//				{
//					varcost -= problem->c[j][assSP1];
//					if (seg[idVeh].Trip[nextT].vioTWSP > eps) goto Update;
//				}
//				else varcost -= problem->disCWSSP[j][assSP1];
//				cStartS = problem->leaveSP[assSP1][1];//load only at eTW2
//			}
//			else
//			{
//				double cArrTimeI = cStartS + problem->disCWSSP[i][assSP1];
//				temp = cArrTimeI - problem->nodeSP[assSP1].eTW2;
//				if (temp > eps) //too soon to go sp directly, too late to go through WS:
//				{
//					varvioTWSP = problem->nodeSP[assSP1].sTW2 - cArrTime - seg[idVeh].Trip[nextT].vioTWSP;
//					//before insertion has to go to sp directly: FEA OR INFEA; OR go through WS
//					varcost += problem->c[i][assSP1];
//					if (seg[idVeh].Trip[idTrip].waitingS == NO_WS)
//					{
//						varcost -= problem->c[j][assSP1];
//					    if (seg[idVeh].Trip[nextT].vioTWSP > eps) goto Update;
//					}
//					else varcost -= problem->disCWSSP[j][assSP1];
//					cStartS = problem->leaveSP[assSP1][1]; //load only at eTW2
//				}
//				else //to go through WS
//				{
//					varvioTWSP = -seg[idVeh].Trip[nextT].vioTWSP;
//					//before insertion: go through WS too: NOT ALWAYS: Update 7/11/2013
//					if (seg[idVeh].Trip[idTrip].waitingS == NO_WS)
//						varcost += (problem->disCWSSP[i][assSP1] - problem->c[j][assSP1]);
//					else
//						varcost += (problem->disCWSSP[i][assSP1] - problem->disCWSSP[j][assSP1]);
//					cStartS = PDS_MAX(cArrTimeI, problem->nodeSP[assSP1].sTW2) + problem->nodeSP[assSP1].load;
//				}
//			}
//		}
//		GoThroughVehicle(idVeh, nextT, varcost, varvioTWC, varvioTWSP, cStartS, assSP1, firstC_nextT);
//		Update:
//			insertCus[j][k]->var_vioTWC = varvioTWC;
//			insertCus[j][k]->var_vioTWSP = varvioTWSP;
//			insertCus[j][k]->var_cost = varcost;
//}
//
//
//
//
//
//
//void Solution::cal_InsertCusDIAfterJ_NotLastC_NextTripD(int j, int k, int idVeh, int idTrip)
//{
//	//See on 2/12/2013
//	int i = problem->node[j].neighborNode[k].id; //insert customer i after j
//    double varcost, varvioTWC, varvioTWSP; 
//    double cArrTime, cStartS, temp;
//
//	int nextT = idTrip + 1;
//	int firstC_nextT = seg[idVeh].Trip[nextT].firstCus;
//	int assSP1 = seg[idVeh].Trip[nextT].assSP;
//   
//	insertCus[j][k]->var_vioCAP = PDS_MAX(seg[idVeh].Trip[idTrip].capacity + problem->node[i].capacity - problem->Q,0) - seg[idVeh].Trip[idTrip].vioCAP;
//    insertCus[j][k]->atIT = IT;
//
//	cArrTime = depart[j] + problem->c[j][i];
//	temp = cArrTime - problem->node[i].eTW;
//
//	varvioTWC = FvioTWCus[j];
//		if (temp > eps)
//		{
//			varvioTWC += temp;
//			cStartS = problem->node[i].depart;
//		}
//		else cStartS = PDS_MAX(cArrTime, problem->node[i].sTW) + problem->node[i].duration;
//		int nextC = nextArr[j];
//		varcost = problem->c[j][i] + problem->c[i][nextC] - problem->c[j][nextC];
//		int idcur = i;
//		do
//		{
//			cArrTime = cStartS + problem->c[idcur][nextC];
//			temp = cArrTime - problem->node[nextC].eTW;
//			if (temp > eps)
//			{
//				 varvioTWC += temp;
//				 if (vioTWCus[nextC] > eps)
//				 {
//					 insertCus[j][k]->var_vioTWC = varvioTWC - FvioTWCus[nextC];
//					 insertCus[j][k]->var_vioTWSP = 0;
//					 insertCus[j][k]->var_cost = varcost;
//					 return;
//				 }
//				 cStartS = problem->node[nextC].depart;
//			}
//			else cStartS = PDS_MAX(cArrTime, problem->node[nextC].sTW) + problem->node[nextC].duration;
//			idcur = nextC; nextC = nextArr[nextC];
//		}while (nextC > 0);
//		
//		//idcur now points to the last delivery customer
//		varvioTWC -= seg[idVeh].Trip[idTrip].vioTWC;
//		cArrTime = cStartS + problem->c[idcur][assSP1];
//		if (PDSINRANGE(cArrTime, problem->nodeSP[assSP1].sTW2, problem->nodeSP[assSP1].eTW2))
//		{
//			varvioTWSP = -seg[idVeh].Trip[nextT].vioTWSP;
//			//before insertion may go to sp directly: FEA OR INFEA; OR go through WS:
//			if (seg[idVeh].Trip[idTrip].waitingS != NO_WS)
//				varcost += (problem->c[idcur][assSP1] - problem->disCWSSP[idcur][assSP1]);
//			cStartS = cArrTime + problem->nodeSP[assSP1].load;
//		}
//		else
//		{
//			temp = cArrTime - problem->nodeSP[assSP1].eTW2;
//			if (temp > eps)
//			{
//				varvioTWSP = temp - seg[idVeh].Trip[nextT].vioTWSP;
//				//before insertion: may go to sp directly: FEA OR INFEA; OR go through WS
//				if (seg[idVeh].Trip[idTrip].waitingS != NO_WS)
//					varcost += (problem->c[idcur][assSP1] - problem->disCWSSP[j][assSP1]);
//				else if (seg[idVeh].Trip[nextT].vioTWSP > eps) goto Update;
//				cStartS = problem->leaveSP[assSP1][1];//load only at eTW2
//			}
//			else
//			{
//				double cArrTimeI = cStartS + problem->disCWSSP[i][assSP1];
//				temp = cArrTimeI - problem->nodeSP[assSP1].eTW2;
//				if (temp > eps) //too soon to go sp directly, too late to go through WS:
//				{
//					varvioTWSP = problem->nodeSP[assSP1].sTW2 - cArrTime - seg[idVeh].Trip[nextT].vioTWSP;
//					//before insertion has to go to sp directly: FEA OR INFEA; OR go through WS
//					if (seg[idVeh].Trip[idTrip].waitingS != NO_WS)
//						varcost += (problem->c[idcur][assSP1] - problem->disCWSSP[j][assSP1]);
//					else if (seg[idVeh].Trip[nextT].vioTWSP > eps) goto Update;
//					cStartS = problem->leaveSP[assSP1][1]; //load only at eTW2
//				}
//				else //to go through WS
//				{
//					varvioTWSP = -seg[idVeh].Trip[nextT].vioTWSP;
//					//before insertion: go through WS too NOT ALWAYS: Update 7/11/2013
//					if (seg[idVeh].Trip[idTrip].waitingS == NO_WS)
//						varcost += (problem->disCWSSP[j][assSP1] - problem->c[idcur][assSP1]);
//					cStartS = PDS_MAX(cArrTimeI, problem->nodeSP[assSP1].sTW2) + problem->nodeSP[assSP1].load;
//				}
//			}
//		}
//		
//        GoThroughVehicle(idVeh, nextT, varcost, varvioTWC, varvioTWSP, cStartS, idcur, firstC_nextT);
//		Update:
//			insertCus[j][k]->var_vioTWC = varvioTWC;
//			insertCus[j][k]->var_vioTWSP = varvioTWSP;
//			insertCus[j][k]->var_cost = varcost;
//}


//bool Solution::SUBcal_InsertCusPIAfterJ_NotLastC(int j, int i, int idVeh, int idTrip, int &varvioCAP, double &varcost, double &varvioTWC, double &varvioTWSP, double &cStartS)
//{
//	See on 2/12/2013
//	varvioCAP = PDS_MAX(seg[idVeh].Trip[idTrip].capacity + problem->node[i].capacity - problem->Q, 0) - seg[idVeh].Trip[idTrip].vioCAP;
//
//	double cArrTime, temp;
//	
//	cArrTime = depart[j] + problem->c[j][i];
//	temp = cArrTime - problem->node[i].eTW;
//	double vioTWCNEW = FvioTWCus[j];
//	
//	if (temp > eps)
//	{
//		vioTWCNEW += temp;
//		cStartS = problem->node[i].depart;
//	}
//	else
//		cStartS = PDS_MAX(cArrTime, problem->node[i].sTW) + problem->node[i].duration;
//	
//	int nextC = nextArr[j];
//	varcost = problem->c[j][i] + problem->c[i][nextC] - problem->c[j][nextC];
//	int idcur = i; 
//	do
//	{
//          cArrTime = cStartS + problem->c[idcur][nextC]; //Arrive Time to Customer nextC
//		  temp = cArrTime - problem->node[nextC].eTW;
//          if (temp > eps)
//		  {
//			  vioTWCNEW += temp;
//			  if (vioTWCus[nextC] > eps) 
//			  {
//					varvioTWC = vioTWCNEW - FvioTWCus[nextC];
//					varvioTWSP = 0;
//				    return 1;
//			  }
//			  cStartS = problem->node[nextC].depart;
//		  }
//		  else
//			  cStartS = PDS_MAX(cArrTime, problem->node[nextC].sTW) + problem->node[nextC].duration;
//		  idcur=nextC; nextC= nextArr[nextC];
//	}while (nextC > 0);
//
//	varvioTWC = vioTWCNEW - seg[idVeh].Trip[idTrip].vioTWC;
//
//	int assSP = seg[idVeh].Trip[idTrip].assSP; 
//    idcur now points to the last customer
//	cArrTime = cStartS + problem->c[idcur][assSP];
//	varvioTWSP = -seg[idVeh].Trip[idTrip].vioTWSP;
//	if (PDSINRANGE(cArrTime, problem->nodeSP[assSP].sTW1, problem->nodeSP[assSP].eTW1))
//	{
//		before insertion: go sp directly FEA OR INF; OR go through WS
//		if (seg[idVeh].Trip[idTrip].waitingS != NO_WS)
//			varcost += (problem->c[idcur][assSP] - problem->disCWSSP[idcur][assSP]);
//		cStartS = cArrTime + problem->nodeSP[assSP].unload;
//	}
//	else
//	{
//		temp = cArrTime - problem->nodeSP[assSP].eTW1;
//		if (temp > eps) //too late to go sp directly
//		{
//			varvioTWSP += temp;
//			before insertion: go sp directly FEA OR INF; OR go through WS
//			if (seg[idVeh].Trip[idTrip].vioTWSP > eps) return 1;
//			if (seg[idVeh].Trip[idTrip].waitingS != NO_WS)
//				varcost += (problem->c[idcur][assSP] - problem->disCWSSP[idcur][assSP]);
//			cStartS = problem->leaveSP[assSP][0]; //unload only at eTW1
//		}
//		else
//		{
//			double cArrTimeI = cStartS + problem->disCWSSP[idcur][assSP];
//			temp = cArrTimeI - problem->nodeSP[assSP].eTW1;
//			if (temp > eps) //too soon to go sp directly, too late to go through WS:
//			{
//				varvioTWSP += (problem->nodeSP[assSP].sTW1 - cArrTime);
//				before insertion: go sp directly FEA OR INF; OR go through WS
//				if (seg[idVeh].Trip[idTrip].vioTWSP > eps) return 1;
//				if (seg[idVeh].Trip[idTrip].waitingS != NO_WS)
//					varcost += (problem->c[idcur][assSP] - problem->disCWSSP[idcur][assSP]);
//				cStartS = problem->leaveSP[assSP][0]; //unload only at eTW1
//			}
//			else //go through WS:
//			{
//				varvioTWSP = -seg[idVeh].Trip[idTrip].vioTWSP;
//				before insertion: go through WS too --> donnt need to update varcost NOT ALWAYS: Update 7/11/2013
//				if (seg[idVeh].Trip[idTrip].waitingS == NO_WS)
//					varcost += (problem->disCWSSP[idcur][assSP] - problem->c[idcur][assSP]);
//				cStartS = PDS_MAX(cArrTimeI, problem->nodeSP[assSP].sTW1) + problem->nodeSP[assSP].unload;
//			}
//		}
//	}
//	return 0;
//}
//
//bool Solution::SUBcal_InsertCusPIAfterJ_NotLastC1(int j, int i, int idVeh, int idTrip, int &varvioCAP, double &varcost, double &varvioTWC, double &varvioTWSP, double &cStartS)
//{
//	//See on 2/12/2013
//	varvioCAP += (PDS_MAX(seg[idVeh].Trip[idTrip].capacity + problem->node[i].capacity - problem->Q, 0) - seg[idVeh].Trip[idTrip].vioCAP);
//
//	double cArrTime, temp;
//	
//	cArrTime = depart[j] + problem->c[j][i];
//	temp = cArrTime - problem->node[i].eTW;
//	double vioTWCNEW = FvioTWCus[j];
//	
//	if (temp > eps)
//	{
//		vioTWCNEW += temp;
//		cStartS = problem->node[i].depart;
//	}
//	else
//		cStartS = PDS_MAX(cArrTime, problem->node[i].sTW) + problem->node[i].duration;
//	
//	int nextC = nextArr[j];
//	varcost += (problem->c[j][i] + problem->c[i][nextC] - problem->c[j][nextC]);
//
//	int idcur = i; 
//	do
//	{
//          cArrTime = cStartS + problem->c[idcur][nextC]; //Arrive Time to Customer nextC
//		  temp = cArrTime - problem->node[nextC].eTW;
//          if (temp > eps)
//		  {
//			  vioTWCNEW += temp;
//			  if (vioTWCus[nextC] > eps) 
//			  {
//					varvioTWC += (vioTWCNEW - FvioTWCus[nextC]);
//					varvioTWSP = 0;
//				    return 1;
//			  }
//			  cStartS = problem->node[nextC].depart;
//		  }
//		  else
//			  cStartS = PDS_MAX(cArrTime, problem->node[nextC].sTW) + problem->node[nextC].duration;
//		  
//		  idcur=nextC; nextC= nextArr[nextC];
//	}while (nextC > 0);
//
//	varvioTWC += (vioTWCNEW - seg[idVeh].Trip[idTrip].vioTWC);
//
//	int assSP = seg[idVeh].Trip[idTrip].assSP; 
//    //idcur now points to the last customer
//	cArrTime = cStartS + problem->c[idcur][assSP];
//	varvioTWSP = -seg[idVeh].Trip[idTrip].vioTWSP;
//	if (PDSINRANGE(cArrTime, problem->nodeSP[assSP].sTW1, problem->nodeSP[assSP].eTW1))
//	{
//		//before insertion: go sp directly FEA OR INF; OR go through WS
//		if (seg[idVeh].Trip[idTrip].waitingS != NO_WS)
//			varcost += (problem->c[idcur][assSP] - problem->disCWSSP[idcur][assSP]);
//		cStartS = cArrTime + problem->nodeSP[assSP].unload;
//	}
//	else
//	{
//		temp = cArrTime - problem->nodeSP[assSP].eTW1;
//		if (temp > eps) //too late to go sp directly
//		{
//			varvioTWSP += temp;
//			//before insertion: go sp directly FEA OR INF; OR go through WS
//			if (seg[idVeh].Trip[idTrip].vioTWSP > eps) return 1;
//			if (seg[idVeh].Trip[idTrip].waitingS != NO_WS)
//				varcost += (problem->c[idcur][assSP] - problem->disCWSSP[idcur][assSP]);
//			cStartS = problem->leaveSP[assSP][0]; //unload only at eTW1
//		}
//		else
//		{
//			double cArrTimeI = cStartS + problem->disCWSSP[idcur][assSP];
//			temp = cArrTimeI - problem->nodeSP[assSP].eTW1;
//			if (temp > eps) //too soon to go sp directly, too late to go through WS:
//			{
//				varvioTWSP += (problem->nodeSP[assSP].sTW1 - cArrTime);
//				//before insertion: go sp directly FEA OR INF; OR go through WS
//				if (seg[idVeh].Trip[idTrip].vioTWSP > eps) return 1;
//				if (seg[idVeh].Trip[idTrip].waitingS != NO_WS)
//					varcost += (problem->c[idcur][assSP] - problem->disCWSSP[idcur][assSP]);
//				cStartS = problem->leaveSP[assSP][0]; //unload only at eTW1
//			}
//			else //go through WS:
//			{
//				//varvioTWSP = -seg[idVeh].Trip[idTrip].vioTWSP;
//				//before insertion: go through WS too --> donnt need to update varcost NOT ALWAYS: Update 7/11/2013
//				if (seg[idVeh].Trip[idTrip].waitingS == NO_WS)
//					varcost += (problem->disCWSSP[idcur][assSP] - problem->c[idcur][assSP]);
//				cStartS = PDS_MAX(cArrTimeI, problem->nodeSP[assSP].sTW1) + problem->nodeSP[assSP].unload;
//			}
//		}
//	}
//	return 0;
//}
//
//
//bool Solution::SUBcal_InsertCusPIAfterJ_NotLastC1(int j, int i, int idVeh, int idTrip, int &varvioCAP, double &varcost, double &varvioTWC, double &varvioTWSP, double &cStartS, bool &vioTWSPTRUE)
//{
//	//See on 2/12/2013
//	varvioCAP += (PDS_MAX(seg[idVeh].Trip[idTrip].capacity + problem->node[i].capacity - problem->Q, 0) - seg[idVeh].Trip[idTrip].vioCAP);
//
//	double cArrTime, temp;
//	
//	cArrTime = depart[j] + problem->c[j][i];
//	temp = cArrTime - problem->node[i].eTW;
//	double vioTWCNEW = FvioTWCus[j];
//	
//	if (temp > eps)
//	{
//		vioTWCNEW += temp;
//		cStartS = problem->node[i].depart;
//	}
//	else
//		cStartS = PDS_MAX(cArrTime, problem->node[i].sTW) + problem->node[i].duration;
//	
//	int nextC = nextArr[j];
//	varcost += (problem->c[j][i] + problem->c[i][nextC] - problem->c[j][nextC]);
//
//	int idcur = i; 
//	do
//	{
//          cArrTime = cStartS + problem->c[idcur][nextC]; //Arrive Time to Customer nextC
//		  temp = cArrTime - problem->node[nextC].eTW;
//          if (temp > eps)
//		  {
//			  vioTWCNEW += temp;
//			  if (vioTWCus[nextC] > eps) 
//			  {
//					varvioTWC += (vioTWCNEW - FvioTWCus[nextC]);
//					varvioTWSP = 0;
//				    return 1;
//			  }
//			  cStartS = problem->node[nextC].depart;
//		  }
//		  else
//			  cStartS = PDS_MAX(cArrTime, problem->node[nextC].sTW) + problem->node[nextC].duration;
//		  
//		  idcur=nextC; nextC= nextArr[nextC];
//	}while (nextC > 0);
//
//	varvioTWC += (vioTWCNEW - seg[idVeh].Trip[idTrip].vioTWC);
//
//	int assSP = seg[idVeh].Trip[idTrip].assSP; 
//    //idcur now points to the last customer
//	cArrTime = cStartS + problem->c[idcur][assSP];
//	varvioTWSP = -seg[idVeh].Trip[idTrip].vioTWSP;
//	if (PDSINRANGE(cArrTime, problem->nodeSP[assSP].sTW1, problem->nodeSP[assSP].eTW1))
//	{
//		vioTWSPTRUE = 0;
//		//before insertion: go sp directly FEA OR INF; OR go through WS
//		if (seg[idVeh].Trip[idTrip].waitingS != NO_WS)
//			varcost += (problem->c[idcur][assSP] - problem->disCWSSP[idcur][assSP]);
//		cStartS = cArrTime + problem->nodeSP[assSP].unload;
//	}
//	else
//	{
//		temp = cArrTime - problem->nodeSP[assSP].eTW1;
//		if (temp > eps) //too late to go sp directly
//		{
//			vioTWSPTRUE = 1;
//			varvioTWSP += temp;
//			//before insertion: go sp directly FEA OR INF; OR go through WS
//			if (seg[idVeh].Trip[idTrip].vioTWSP > eps) return 1;
//			if (seg[idVeh].Trip[idTrip].waitingS != NO_WS)
//				varcost += (problem->c[idcur][assSP] - problem->disCWSSP[idcur][assSP]);
//			cStartS = problem->leaveSP[assSP][0]; //unload only at eTW1
//		}
//		else
//		{
//			double cArrTimeI = cStartS + problem->disCWSSP[idcur][assSP];
//			temp = cArrTimeI - problem->nodeSP[assSP].eTW1;
//			if (temp > eps) //too soon to go sp directly, too late to go through WS:
//			{
//				vioTWSPTRUE = 1;
//				varvioTWSP += (problem->nodeSP[assSP].sTW1 - cArrTime);
//				//before insertion: go sp directly FEA OR INF; OR go through WS
//				if (seg[idVeh].Trip[idTrip].vioTWSP > eps) return 1;
//				if (seg[idVeh].Trip[idTrip].waitingS != NO_WS)
//					varcost += (problem->c[idcur][assSP] - problem->disCWSSP[idcur][assSP]);
//				cStartS = problem->leaveSP[assSP][0]; //unload only at eTW1
//			}
//			else //go through WS:
//			{
//				vioTWSPTRUE = 0;
//				//varvioTWSP = -seg[idVeh].Trip[idTrip].vioTWSP;
//				//before insertion: go through WS too --> donnt need to update varcost NOT ALWAYS: Update 7/11/2013
//				if (seg[idVeh].Trip[idTrip].waitingS == NO_WS)
//					varcost += (problem->disCWSSP[idcur][assSP] - problem->c[idcur][assSP]);
//				cStartS = PDS_MAX(cArrTimeI, problem->nodeSP[assSP].sTW1) + problem->nodeSP[assSP].unload;
//			}
//		}
//	}
//	return 0;
//}
//
//
//bool Solution::SUBcal_InsertCusPIAfterJ_NotLastC1_Start(int j, int i, int idVeh, int idTrip, int &varvioCAP, double &varcost, double &varvioTWC, double &varvioTWSP, double &cStartS)
//{
//	//see on 2/12/2013
//	varvioCAP = (PDS_MAX(seg[idVeh].Trip[idTrip].capacity + problem->node[i].capacity - problem->Q, 0) - seg[idVeh].Trip[idTrip].vioCAP);
//
//	double cArrTime, temp;
//	
//	cArrTime = depart[j] + problem->c[j][i];
//	temp = cArrTime - problem->node[i].eTW;
//	double vioTWCNEW = FvioTWCus[j];
//	
//	if (temp > eps)
//	{
//		vioTWCNEW += temp;
//		cStartS = problem->node[i].depart;
//	}
//	else
//		cStartS = PDS_MAX(cArrTime, problem->node[i].sTW) + problem->node[i].duration;
//	
//	int nextC = nextArr[j];
//	varcost = (problem->c[j][i] + problem->c[i][nextC] - problem->c[j][nextC]);
//
//	int idcur = i; 
//	do
//	{
//          cArrTime = cStartS + problem->c[idcur][nextC]; //Arrive Time to Customer nextC
//		  temp = cArrTime - problem->node[nextC].eTW;
//          if (temp > eps)
//		  {
//			  vioTWCNEW += temp;
//			  if (vioTWCus[nextC] > eps) 
//			  {
//					varvioTWC = (vioTWCNEW - FvioTWCus[nextC]);
//					varvioTWSP = 0;
//				    return 1;
//			  }
//			  cStartS = problem->node[nextC].depart;
//		  }
//		  else
//			  cStartS = PDS_MAX(cArrTime, problem->node[nextC].sTW) + problem->node[nextC].duration;
//		  
//		  idcur=nextC; nextC= nextArr[nextC];
//	}while (nextC > 0);
//
//	varvioTWC = (vioTWCNEW - seg[idVeh].Trip[idTrip].vioTWC);
//
//	int assSP = seg[idVeh].Trip[idTrip].assSP; 
//    //idcur now points to the last customer
//	cArrTime = cStartS + problem->c[idcur][assSP];
//	varvioTWSP = -seg[idVeh].Trip[idTrip].vioTWSP;
//	if (PDSINRANGE(cArrTime, problem->nodeSP[assSP].sTW1, problem->nodeSP[assSP].eTW1))
//	{
//		//before insertion: go sp directly FEA OR INF; OR go through WS
//		if (seg[idVeh].Trip[idTrip].waitingS != NO_WS)
//			varcost += (problem->c[idcur][assSP] - problem->disCWSSP[idcur][assSP]);
//		cStartS = cArrTime + problem->nodeSP[assSP].unload;
//	}
//	else
//	{
//		temp = cArrTime - problem->nodeSP[assSP].eTW1;
//		if (temp > eps) //too late to go sp directly
//		{
//			varvioTWSP += temp;
//			//before insertion: go sp directly FEA OR INF; OR go through WS
//			if (seg[idVeh].Trip[idTrip].vioTWSP > eps) return 1;
//			if (seg[idVeh].Trip[idTrip].waitingS != NO_WS)
//				varcost += (problem->c[idcur][assSP] - problem->disCWSSP[idcur][assSP]);
//			cStartS = problem->leaveSP[assSP][0]; //unload only at eTW1
//		}
//		else
//		{
//			double cArrTimeI = cStartS + problem->disCWSSP[idcur][assSP];
//			temp = cArrTimeI - problem->nodeSP[assSP].eTW1;
//			if (temp > eps) //too soon to go sp directly, too late to go through WS:
//			{
//				varvioTWSP += (problem->nodeSP[assSP].sTW1 - cArrTime);
//				//before insertion: go sp directly FEA OR INF; OR go through WS
//				if (seg[idVeh].Trip[idTrip].vioTWSP > eps) return 1;
//				if (seg[idVeh].Trip[idTrip].waitingS != NO_WS)
//					varcost += (problem->c[idcur][assSP] - problem->disCWSSP[idcur][assSP]);
//				cStartS = problem->leaveSP[assSP][0]; //unload only at eTW1
//			}
//			else //go through WS:
//			{
//				//varvioTWSP = -seg[idVeh].Trip[idTrip].vioTWSP;
//				//before insertion: go through WS too --> donnt need to update varcost NOT ALWAYS: Update 7/11/2013
//				if (seg[idVeh].Trip[idTrip].waitingS == NO_WS)
//					varcost += (problem->disCWSSP[idcur][assSP] - problem->c[idcur][assSP]);
//				cStartS = PDS_MAX(cArrTimeI, problem->nodeSP[assSP].sTW1) + problem->nodeSP[assSP].unload;
//			}
//		}
//	}
//	return 0;
//}
//
//
//
//bool Solution::SUBcal_InsertCusPIAfterJ_NotLastC1_Start(int j, int i, int idVeh, int idTrip, int &varvioCAP, double &varcost, double &varvioTWC, double &varvioTWSP, double &cStartS, bool &vioTWSPTRUE)
//{
//	//see on 2/12/2013
//	//It's a copy of SUBcal_InsertCusPIAfterJ_NotLastC1_Start(int j, int i, int idVeh, int idTrip, int &varvioCAP, double &varcost, double &varvioTWC, double &varvioTWSP, double &cStartS)
//	//but include a new para vioTWSPTRUE to indicate if there is a vioTWSP after the move
//
//	varvioCAP = (PDS_MAX(seg[idVeh].Trip[idTrip].capacity + problem->node[i].capacity - problem->Q, 0) - seg[idVeh].Trip[idTrip].vioCAP);
//
//	double cArrTime, temp;
//	
//	cArrTime = depart[j] + problem->c[j][i];
//	temp = cArrTime - problem->node[i].eTW;
//	double vioTWCNEW = FvioTWCus[j];
//	
//	if (temp > eps)
//	{
//		vioTWCNEW += temp;
//		cStartS = problem->node[i].depart;
//	}
//	else
//		cStartS = PDS_MAX(cArrTime, problem->node[i].sTW) + problem->node[i].duration;
//	
//	int nextC = nextArr[j];
//	varcost = (problem->c[j][i] + problem->c[i][nextC] - problem->c[j][nextC]);
//
//	int idcur = i; 
//	do
//	{
//          cArrTime = cStartS + problem->c[idcur][nextC]; //Arrive Time to Customer nextC
//		  temp = cArrTime - problem->node[nextC].eTW;
//          if (temp > eps)
//		  {
//			  vioTWCNEW += temp;
//			  if (vioTWCus[nextC] > eps) 
//			  {
//					varvioTWC = (vioTWCNEW - FvioTWCus[nextC]);
//					varvioTWSP = 0;
//				    return 1;
//			  }
//			  cStartS = problem->node[nextC].depart;
//		  }
//		  else
//			  cStartS = PDS_MAX(cArrTime, problem->node[nextC].sTW) + problem->node[nextC].duration;
//		  
//		  idcur=nextC; nextC= nextArr[nextC];
//	}while (nextC > 0);
//
//	varvioTWC = (vioTWCNEW - seg[idVeh].Trip[idTrip].vioTWC);
//
//	int assSP = seg[idVeh].Trip[idTrip].assSP; 
//    //idcur now points to the last customer
//	cArrTime = cStartS + problem->c[idcur][assSP];
//	varvioTWSP = -seg[idVeh].Trip[idTrip].vioTWSP;
//	if (PDSINRANGE(cArrTime, problem->nodeSP[assSP].sTW1, problem->nodeSP[assSP].eTW1))
//	{
//		vioTWSPTRUE = 0;
//		//before insertion: go sp directly FEA OR INF; OR go through WS
//		if (seg[idVeh].Trip[idTrip].waitingS != NO_WS)
//			varcost += (problem->c[idcur][assSP] - problem->disCWSSP[idcur][assSP]);
//		cStartS = cArrTime + problem->nodeSP[assSP].unload;
//	}
//	else
//	{
//		temp = cArrTime - problem->nodeSP[assSP].eTW1;
//		if (temp > eps) //too late to go sp directly
//		{
//			vioTWSPTRUE = 1;
//			varvioTWSP += temp;
//			//before insertion: go sp directly FEA OR INF; OR go through WS
//			if (seg[idVeh].Trip[idTrip].vioTWSP > eps) return 1;
//			if (seg[idVeh].Trip[idTrip].waitingS != NO_WS)
//				varcost += (problem->c[idcur][assSP] - problem->disCWSSP[idcur][assSP]);
//			cStartS = problem->leaveSP[assSP][0]; //unload only at eTW1
//		}
//		else
//		{
//			double cArrTimeI = cStartS + problem->disCWSSP[idcur][assSP];
//			temp = cArrTimeI - problem->nodeSP[assSP].eTW1;
//			if (temp > eps) //too soon to go sp directly, too late to go through WS:
//			{
//				vioTWSPTRUE = 1;
//				varvioTWSP += (problem->nodeSP[assSP].sTW1 - cArrTime);
//				//before insertion: go sp directly FEA OR INF; OR go through WS
//				if (seg[idVeh].Trip[idTrip].vioTWSP > eps) return 1;
//				if (seg[idVeh].Trip[idTrip].waitingS != NO_WS)
//					varcost += (problem->c[idcur][assSP] - problem->disCWSSP[idcur][assSP]);
//				cStartS = problem->leaveSP[assSP][0]; //unload only at eTW1
//			}
//			else //go through WS:
//			{
//				 vioTWSPTRUE=0;
//				//varvioTWSP = -seg[idVeh].Trip[idTrip].vioTWSP;
//				//before insertion: go through WS too --> donnt need to update varcost NOT ALWAYS: Update 7/11/2013
//				if (seg[idVeh].Trip[idTrip].waitingS == NO_WS)
//					varcost += (problem->disCWSSP[idcur][assSP] - problem->c[idcur][assSP]);
//				cStartS = PDS_MAX(cArrTimeI, problem->nodeSP[assSP].sTW1) + problem->nodeSP[assSP].unload;
//			}
//		}
//	}
//	return 0;
//}



//bool Solution::SUBcal_InsertCusPIAfterJ_LastC(int j, int i, int idVeh, int idTrip, int &varvioCAP, double &varcost, double &varvioTWC, double &varvioTWSP, double &cStartS) 
//{
//	//See on 2/12/2013
//	varvioCAP = PDS_MAX(seg[idVeh].Trip[idTrip].capacity + problem->node[i].capacity - problem->Q, 0) - seg[idVeh].Trip[idTrip].vioCAP;
//	varcost = problem->c[j][i];
//	double cArrTime, temp;
//
//	cArrTime = depart[j] + problem->c[j][i];
//	temp = cArrTime - problem->node[i].eTW;
//	if (temp > eps)
//	{
//		varvioTWC = temp;
//		cStartS = problem->node[i].depart;
//	}
//	else
//	{
//		varvioTWC = 0;
//		cStartS = PDS_MAX(cArrTime, problem->node[i].sTW) + problem->node[i].duration;
//	}
//
//	int assSP = seg[idVeh].Trip[idTrip].assSP; 
//	cArrTime = cStartS + problem->c[i][assSP];
//	if (PDSINRANGE(cArrTime, problem->nodeSP[assSP].sTW1, problem->nodeSP[assSP].eTW1))
//	{
//		//before insertion: go sp directly FEA OR INF; OR go through WS
//		varvioTWSP = -seg[idVeh].Trip[idTrip].vioTWSP;
//		varcost += problem->c[i][assSP];
//		if (seg[idVeh].Trip[idTrip].waitingS == NO_WS)
//			varcost -= problem->c[j][assSP];
//		else varcost -= problem->disCWSSP[j][assSP];
//		cStartS = cArrTime + problem->nodeSP[assSP].unload;
//	}
//	else
//	{
//		temp = cArrTime - problem->nodeSP[assSP].eTW1;
//		if (temp > eps) //too late to go sp directly
//		{
//			varvioTWSP = temp - seg[idVeh].Trip[idTrip].vioTWSP;
//			varcost += problem->c[i][assSP];
//			//before insertion: go sp directly FEA OR INF; OR go through WS
//			if (seg[idVeh].Trip[idTrip].waitingS == NO_WS)
//			{
//				varcost -= problem->c[j][assSP];
//				if (seg[idVeh].Trip[idTrip].vioTWSP > eps) return 1;
//			}
//			else varcost -= problem->disCWSSP[j][assSP];			
//			cStartS = problem->leaveSP[assSP][0]; //unload only at eTW1
//		}
//		else
//		{
//			double cArrTimeI = cStartS + problem->disCWSSP[i][assSP];
//			temp = cArrTimeI - problem->nodeSP[assSP].eTW1;
//			if (temp > eps) //too soon to go sp directly, too late to go through WS:
//			{
//				varvioTWSP = problem->nodeSP[assSP].sTW1 - cArrTime - seg[idVeh].Trip[idTrip].vioTWSP;
//				varcost += problem->c[i][assSP];
//				//before insertion: go sp directly FEA OR INF; OR go through WS
//				if (seg[idVeh].Trip[idTrip].waitingS == NO_WS)
//				{
//					varcost -= problem->c[j][assSP];
//					if (seg[idVeh].Trip[idTrip].vioTWSP > eps) return 1;
//				}
//				else varcost -= problem->disCWSSP[j][assSP];
//				cStartS = problem->leaveSP[assSP][0]; //unload only at eTW1
//			}
//			else //go through WS:
//			{
//				varvioTWSP = -seg[idVeh].Trip[idTrip].vioTWSP;
//				//before insertion: go through WS too NOT ALWAYS Update 7/11/2013
//				if (seg[idVeh].Trip[idTrip].waitingS == NO_WS)
//					varcost += (problem->disCWSSP[i][assSP] - problem->c[j][assSP]);
//				else
//					varcost += (problem->disCWSSP[i][assSP] - problem->disCWSSP[j][assSP]);
//				cStartS = PDS_MAX(cArrTimeI, problem->nodeSP[assSP].sTW1) + problem->nodeSP[assSP].unload;
//			}
//		}
//	}
//	return 0;
//}
//
//bool Solution::SUBcal_InsertCusPIAfterJ_LastC1(int j, int i, int idVeh, int idTrip, int &varvioCAP, double &varcost, double &varvioTWC, double &varvioTWSP, double &cStartS) 
//{
//	//See on 2/12/2013
//	varvioCAP += (PDS_MAX(seg[idVeh].Trip[idTrip].capacity + problem->node[i].capacity - problem->Q, 0) - seg[idVeh].Trip[idTrip].vioCAP);
//	varcost += problem->c[j][i];
//	double cArrTime, temp;
//
//	cArrTime = depart[j] + problem->c[j][i];
//	temp = cArrTime - problem->node[i].eTW;
//	if (temp > eps)
//	{
//		varvioTWC += temp;
//		cStartS = problem->node[i].depart;
//	}
//	else
//	{
//		//varvioTWC = 0;
//		cStartS = PDS_MAX(cArrTime, problem->node[i].sTW) + problem->node[i].duration;
//	}
//
//	int assSP = seg[idVeh].Trip[idTrip].assSP; 
//	cArrTime = cStartS + problem->c[i][assSP];
//	varvioTWSP = -seg[idVeh].Trip[idTrip].vioTWSP;
//	if (PDSINRANGE(cArrTime, problem->nodeSP[assSP].sTW1, problem->nodeSP[assSP].eTW1))
//	{
//		//before insertion: go sp directly FEA OR INF; OR go through WS
//		varcost += problem->c[i][assSP];
//		if (seg[idVeh].Trip[idTrip].waitingS == NO_WS)
//			varcost -= problem->c[j][assSP];
//		else varcost -= problem->disCWSSP[j][assSP];
//		cStartS = cArrTime + problem->nodeSP[assSP].unload;
//	}
//	else
//	{
//		temp = cArrTime - problem->nodeSP[assSP].eTW1;
//		if (temp > eps) //too late to go sp directly
//		{
//			varvioTWSP += temp;
//			varcost += problem->c[i][assSP];
//			//before insertion: go sp directly FEA OR INF; OR go through WS
//			if (seg[idVeh].Trip[idTrip].waitingS == NO_WS)
//			{
//				varcost -= problem->c[j][assSP];
//				if (seg[idVeh].Trip[idTrip].vioTWSP > eps) return 1;
//			}
//			else varcost -= problem->disCWSSP[j][assSP];			
//			cStartS = problem->leaveSP[assSP][0]; //unload only at eTW1
//		}
//		else
//		{
//			double cArrTimeI = cStartS + problem->disCWSSP[i][assSP];
//			temp = cArrTimeI - problem->nodeSP[assSP].eTW1;
//			if (temp > eps) //too soon to go sp directly, too late to go through WS:
//			{
//				varvioTWSP += (problem->nodeSP[assSP].sTW1 - cArrTime);
//				varcost += problem->c[i][assSP];
//				//before insertion: go sp directly FEA OR INF; OR go through WS
//				if (seg[idVeh].Trip[idTrip].waitingS == NO_WS)
//				{
//					varcost -= problem->c[j][assSP];
//					if (seg[idVeh].Trip[idTrip].vioTWSP > eps) return 1;
//				}
//				else varcost -= problem->disCWSSP[j][assSP];
//				cStartS = problem->leaveSP[assSP][0]; //unload only at eTW1
//			}
//			else //go through WS:
//			{
//				//before insertion: go through WS too NOT ALWAYS Update 7/11/2013
//				if (seg[idVeh].Trip[idTrip].waitingS == NO_WS)
//					varcost += (problem->disCWSSP[i][assSP] - problem->c[j][assSP]);
//				else
//					varcost += (problem->disCWSSP[i][assSP] - problem->disCWSSP[j][assSP]);
//				cStartS = PDS_MAX(cArrTimeI, problem->nodeSP[assSP].sTW1) + problem->nodeSP[assSP].unload;
//			}
//		}
//	}
//	return 0;
//}
//
//
//bool Solution::SUBcal_InsertCusPIAfterJ_LastC1(int j, int i, int idVeh, int idTrip, int &varvioCAP, double &varcost, double &varvioTWC, double &varvioTWSP, double &cStartS, bool &vioTWSPTRUE) 
//{
//	//See on 2/12/2013
//	varvioCAP += (PDS_MAX(seg[idVeh].Trip[idTrip].capacity + problem->node[i].capacity - problem->Q, 0) - seg[idVeh].Trip[idTrip].vioCAP);
//	varcost += problem->c[j][i];
//	double cArrTime, temp;
//
//	cArrTime = depart[j] + problem->c[j][i];
//	temp = cArrTime - problem->node[i].eTW;
//	if (temp > eps)
//	{
//		varvioTWC += temp;
//		cStartS = problem->node[i].depart;
//	}
//	else
//	{
//		//varvioTWC = 0;
//		cStartS = PDS_MAX(cArrTime, problem->node[i].sTW) + problem->node[i].duration;
//	}
//
//	int assSP = seg[idVeh].Trip[idTrip].assSP; 
//	cArrTime = cStartS + problem->c[i][assSP];
//	varvioTWSP = -seg[idVeh].Trip[idTrip].vioTWSP;
//	if (PDSINRANGE(cArrTime, problem->nodeSP[assSP].sTW1, problem->nodeSP[assSP].eTW1))
//	{
//		vioTWSPTRUE = 0;
//		//before insertion: go sp directly FEA OR INF; OR go through WS
//		varcost += problem->c[i][assSP];
//		if (seg[idVeh].Trip[idTrip].waitingS == NO_WS)
//			varcost -= problem->c[j][assSP];
//		else varcost -= problem->disCWSSP[j][assSP];
//		cStartS = cArrTime + problem->nodeSP[assSP].unload;
//	}
//	else
//	{
//		temp = cArrTime - problem->nodeSP[assSP].eTW1;
//		if (temp > eps) //too late to go sp directly
//		{
//			varvioTWSP += temp; vioTWSPTRUE = 1;
//			varcost += problem->c[i][assSP];
//			//before insertion: go sp directly FEA OR INF; OR go through WS
//			if (seg[idVeh].Trip[idTrip].waitingS == NO_WS)
//			{
//				varcost -= problem->c[j][assSP];
//				if (seg[idVeh].Trip[idTrip].vioTWSP > eps) return 1;
//			}
//			else varcost -= problem->disCWSSP[j][assSP];			
//			cStartS = problem->leaveSP[assSP][0]; //unload only at eTW1
//		}
//		else
//		{
//			double cArrTimeI = cStartS + problem->disCWSSP[i][assSP];
//			temp = cArrTimeI - problem->nodeSP[assSP].eTW1;
//			if (temp > eps) //too soon to go sp directly, too late to go through WS:
//			{
//				vioTWSPTRUE = 1;
//				varvioTWSP += (problem->nodeSP[assSP].sTW1 - cArrTime);
//				varcost += problem->c[i][assSP];
//				//before insertion: go sp directly FEA OR INF; OR go through WS
//				if (seg[idVeh].Trip[idTrip].waitingS == NO_WS)
//				{
//					varcost -= problem->c[j][assSP];
//					if (seg[idVeh].Trip[idTrip].vioTWSP > eps) return 1;
//				}
//				else varcost -= problem->disCWSSP[j][assSP];
//				cStartS = problem->leaveSP[assSP][0]; //unload only at eTW1
//			}
//			else //go through WS:
//			{
//				vioTWSPTRUE = 0;
//				//before insertion: go through WS too NOT ALWAYS Update 7/11/2013
//				if (seg[idVeh].Trip[idTrip].waitingS == NO_WS)
//					varcost += (problem->disCWSSP[i][assSP] - problem->c[j][assSP]);
//				else
//					varcost += (problem->disCWSSP[i][assSP] - problem->disCWSSP[j][assSP]);
//				cStartS = PDS_MAX(cArrTimeI, problem->nodeSP[assSP].sTW1) + problem->nodeSP[assSP].unload;
//			}
//		}
//	}
//	return 0;
//}
//
//
//bool Solution::SUBcal_InsertCusPIAfterJ_LastC1_Start(int j, int i, int idVeh, int idTrip, int &varvioCAP, double &varcost, double &varvioTWC, double &varvioTWSP, double &cStartS) 
//{//see on 2/12/2013
//	varvioCAP = (PDS_MAX(seg[idVeh].Trip[idTrip].capacity + problem->node[i].capacity - problem->Q, 0) - seg[idVeh].Trip[idTrip].vioCAP);
//	varcost = problem->c[j][i];
//	double cArrTime, temp;
//
//	cArrTime = depart[j] + problem->c[j][i];
//	temp = cArrTime - problem->node[i].eTW;
//	if (temp > eps)
//	{
//		varvioTWC = temp;
//		cStartS = problem->node[i].depart;
//	}
//	else
//	{
//		varvioTWC = 0;
//		cStartS = PDS_MAX(cArrTime, problem->node[i].sTW) + problem->node[i].duration;
//	}
//
//	int assSP = seg[idVeh].Trip[idTrip].assSP; 
//	cArrTime = cStartS + problem->c[i][assSP];
//	varvioTWSP = -seg[idVeh].Trip[idTrip].vioTWSP;
//	if (PDSINRANGE(cArrTime, problem->nodeSP[assSP].sTW1, problem->nodeSP[assSP].eTW1))
//	{
//		//before insertion: go sp directly FEA OR INF; OR go through WS
//		varcost += problem->c[i][assSP];
//		if (seg[idVeh].Trip[idTrip].waitingS == NO_WS)
//			varcost -= problem->c[j][assSP];
//		else varcost -= problem->disCWSSP[j][assSP];
//		cStartS = cArrTime + problem->nodeSP[assSP].unload;
//	}
//	else
//	{
//		temp = cArrTime - problem->nodeSP[assSP].eTW1;
//		if (temp > eps) //too late to go sp directly
//		{
//			varvioTWSP += temp;
//			varcost += problem->c[i][assSP];
//			//before insertion: go sp directly FEA OR INF; OR go through WS
//			if (seg[idVeh].Trip[idTrip].waitingS == NO_WS)
//			{
//				varcost -= problem->c[j][assSP];
//				if (seg[idVeh].Trip[idTrip].vioTWSP > eps) return 1;
//			}
//			else varcost -= problem->disCWSSP[j][assSP];			
//			cStartS = problem->leaveSP[assSP][0]; //unload only at eTW1
//		}
//		else
//		{
//			double cArrTimeI = cStartS + problem->disCWSSP[i][assSP];
//			temp = cArrTimeI - problem->nodeSP[assSP].eTW1;
//			if (temp > eps) //too soon to go sp directly, too late to go through WS:
//			{
//				varvioTWSP += (problem->nodeSP[assSP].sTW1 - cArrTime);
//				varcost += problem->c[i][assSP];
//				//before insertion: go sp directly FEA OR INF; OR go through WS
//				if (seg[idVeh].Trip[idTrip].waitingS == NO_WS)
//				{
//					varcost -= problem->c[j][assSP];
//					if (seg[idVeh].Trip[idTrip].vioTWSP > eps) return 1;
//				}
//				else varcost -= problem->disCWSSP[j][assSP];
//				cStartS = problem->leaveSP[assSP][0]; //unload only at eTW1
//			}
//			else //go through WS:
//			{
//				//before insertion: go through WS too NOT ALWAYS Update 7/11/2013
//				if (seg[idVeh].Trip[idTrip].waitingS == NO_WS)
//					varcost += (problem->disCWSSP[i][assSP] - problem->c[j][assSP]);
//				else
//					varcost += (problem->disCWSSP[i][assSP] - problem->disCWSSP[j][assSP]);
//				cStartS = PDS_MAX(cArrTimeI, problem->nodeSP[assSP].sTW1) + problem->nodeSP[assSP].unload;
//			}
//		}
//	}
//	return 0;
//}
//
//
//
//bool Solution::SUBcal_InsertCusPIAfterJ_LastC1_Start(int j, int i, int idVeh, int idTrip, int &varvioCAP, double &varcost, double &varvioTWC, double &varvioTWSP, double &cStartS, bool &vioTWSPTRUE) 
//{//see on 2/12/2013
//	varvioCAP = (PDS_MAX(seg[idVeh].Trip[idTrip].capacity + problem->node[i].capacity - problem->Q, 0) - seg[idVeh].Trip[idTrip].vioCAP);
//	varcost = problem->c[j][i];
//	double cArrTime, temp;
//
//	cArrTime = depart[j] + problem->c[j][i];
//	temp = cArrTime - problem->node[i].eTW;
//	if (temp > eps)
//	{
//		varvioTWC = temp;
//		cStartS = problem->node[i].depart;
//	}
//	else
//	{
//		varvioTWC = 0;
//		cStartS = PDS_MAX(cArrTime, problem->node[i].sTW) + problem->node[i].duration;
//	}
//
//	int assSP = seg[idVeh].Trip[idTrip].assSP; 
//	cArrTime = cStartS + problem->c[i][assSP];
//	varvioTWSP = -seg[idVeh].Trip[idTrip].vioTWSP;
//	if (PDSINRANGE(cArrTime, problem->nodeSP[assSP].sTW1, problem->nodeSP[assSP].eTW1))
//	{
//		vioTWSPTRUE = 0;
//		//before insertion: go sp directly FEA OR INF; OR go through WS
//		varcost += problem->c[i][assSP];
//		if (seg[idVeh].Trip[idTrip].waitingS == NO_WS)
//			varcost -= problem->c[j][assSP];
//		else varcost -= problem->disCWSSP[j][assSP];
//		cStartS = cArrTime + problem->nodeSP[assSP].unload;
//	}
//	else
//	{
//		temp = cArrTime - problem->nodeSP[assSP].eTW1;
//		if (temp > eps) //too late to go sp directly
//		{
//			vioTWSPTRUE = 1;
//			varvioTWSP += temp;
//			varcost += problem->c[i][assSP];
//			//before insertion: go sp directly FEA OR INF; OR go through WS
//			if (seg[idVeh].Trip[idTrip].waitingS == NO_WS)
//			{
//				varcost -= problem->c[j][assSP];
//				if (seg[idVeh].Trip[idTrip].vioTWSP > eps) return 1;
//			}
//			else varcost -= problem->disCWSSP[j][assSP];			
//			cStartS = problem->leaveSP[assSP][0]; //unload only at eTW1
//		}
//		else
//		{
//			double cArrTimeI = cStartS + problem->disCWSSP[i][assSP];
//			temp = cArrTimeI - problem->nodeSP[assSP].eTW1;
//			if (temp > eps) //too soon to go sp directly, too late to go through WS:
//			{
//				vioTWSPTRUE = 1;
//				varvioTWSP += (problem->nodeSP[assSP].sTW1 - cArrTime);
//				varcost += problem->c[i][assSP];
//				//before insertion: go sp directly FEA OR INF; OR go through WS
//				if (seg[idVeh].Trip[idTrip].waitingS == NO_WS)
//				{
//					varcost -= problem->c[j][assSP];
//					if (seg[idVeh].Trip[idTrip].vioTWSP > eps) return 1;
//				}
//				else varcost -= problem->disCWSSP[j][assSP];
//				cStartS = problem->leaveSP[assSP][0]; //unload only at eTW1
//			}
//			else //go through WS:
//			{
//				vioTWSPTRUE = 0;
//				//before insertion: go through WS too NOT ALWAYS Update 7/11/2013
//				if (seg[idVeh].Trip[idTrip].waitingS == NO_WS)
//					varcost += (problem->disCWSSP[i][assSP] - problem->c[j][assSP]);
//				else
//					varcost += (problem->disCWSSP[i][assSP] - problem->disCWSSP[j][assSP]);
//				cStartS = PDS_MAX(cArrTimeI, problem->nodeSP[assSP].sTW1) + problem->nodeSP[assSP].unload;
//			}
//		}
//	}
//	return 0;
//}
//
//
//
//bool Solution::SUBcal_InsertCusPIAfterJ_LastC_1CusFirstTrip(int j, int i, int idVeh, int idTrip, int &varvioCAP, double &varcost, double &varvioTWC, double &varvioTWSP, double &cStartS) 
//{
//	//see 2/12/2013
//	//First pickup trip (idVeh, idTrip) has only 1 customer
//    //Same as Solution::SUBcal_InsertCusPIAfterJ_LastC
//	varvioCAP = PDS_MAX(seg[idVeh].Trip[idTrip].capacity + problem->node[i].capacity - problem->Q, 0) - seg[idVeh].Trip[idTrip].vioCAP;
//	varcost = problem->c[j][i];
//	double cArrTime, temp;
//
//	cArrTime = PDS_MAX(problem->c[0][j], problem->node[j].sTW);
//	temp = cArrTime - problem->node[j].eTW;
//	if (temp > eps)
//	{
//		varvioTWC = temp - vioTWCus[j];
//		cStartS = problem->node[j].depart;
//	}
//	else
//	{
//		varvioTWC = -vioTWCus[j];
//		cStartS = cArrTime + problem->node[j].duration;
//	}
//
//	cArrTime = cStartS + problem->c[j][i];
//	temp = cArrTime - problem->node[i].eTW;
//	if (temp > eps)
//	{
//		varvioTWC += temp;
//		cStartS = problem->node[i].depart;
//	}
//	else
//	{
//		//varvioTWC = 0;
//		cStartS = PDS_MAX(cArrTime, problem->node[i].sTW) + problem->node[i].duration;
//	}
//
//	int assSP = seg[idVeh].Trip[idTrip].assSP; 
//	cArrTime = cStartS + problem->c[i][assSP];
//	if (PDSINRANGE(cArrTime, problem->nodeSP[assSP].sTW1, problem->nodeSP[assSP].eTW1))
//	{
//		//before insertion: go sp directly FEA OR INF; OR go through WS
//		varvioTWSP = -seg[idVeh].Trip[idTrip].vioTWSP;
//		varcost += problem->c[i][assSP];
//		if (seg[idVeh].Trip[idTrip].waitingS == NO_WS)
//			varcost -= problem->c[j][assSP];
//		else varcost -= problem->disCWSSP[j][assSP];
//		cStartS = cArrTime + problem->nodeSP[assSP].unload;
//	}
//	else
//	{
//		temp = cArrTime - problem->nodeSP[assSP].eTW1;
//		if (temp > eps) //too late to go sp directly
//		{
//			varvioTWSP = temp - seg[idVeh].Trip[idTrip].vioTWSP;
//			varcost += problem->c[i][assSP];
//			//before insertion: go sp directly FEA OR INF; OR go through WS
//			if (seg[idVeh].Trip[idTrip].waitingS == NO_WS)
//			{
//				varcost -= problem->c[j][assSP];
//				if (seg[idVeh].Trip[idTrip].vioTWSP > eps) return 1;
//			}
//			else varcost -= problem->disCWSSP[j][assSP];			
//			cStartS = problem->leaveSP[assSP][0]; //unload only at eTW1
//		}
//		else
//		{
//			double cArrTimeI = cStartS + problem->disCWSSP[i][assSP];
//			temp = cArrTimeI - problem->nodeSP[assSP].eTW1;
//			if (temp > eps) //too soon to go sp directly, too late to go through WS:
//			{
//				varvioTWSP = problem->nodeSP[assSP].sTW1 - cArrTime - seg[idVeh].Trip[idTrip].vioTWSP;
//				varcost += problem->c[i][assSP];
//				//before insertion: go sp directly FEA OR INF; OR go through WS
//				if (seg[idVeh].Trip[idTrip].waitingS == NO_WS)
//				{
//					varcost -= problem->c[j][assSP];
//					if (seg[idVeh].Trip[idTrip].vioTWSP > eps) return 1;
//				}
//				else varcost -= problem->disCWSSP[j][assSP];
//				cStartS = problem->leaveSP[assSP][0]; //unload only at eTW1
//			}
//			else //go through WS:
//			{
//				varvioTWSP = -seg[idVeh].Trip[idTrip].vioTWSP;
//				//before insertion: go through WS too NOT ALWAYS Update 7/11/2013
//				if (seg[idVeh].Trip[idTrip].waitingS == NO_WS)
//					varcost += (problem->disCWSSP[i][assSP] - problem->c[j][assSP]);
//				else
//					varcost += (problem->disCWSSP[i][assSP] - problem->disCWSSP[j][assSP]);
//				cStartS = PDS_MAX(cArrTimeI, problem->nodeSP[assSP].sTW1) + problem->nodeSP[assSP].unload;
//			}
//		}
//	}
//	return 0;
//}
//
//
//bool Solution::SUBcal_InsertCusPIAfterJ_LastC_1CusFirstTrip(int j, int i, int idVeh, int idTrip, int &varvioCAP, double &varcost, double &varvioTWC, double &varvioTWSP, double &cStartS, bool &vioTWSPTRUE) 
//{//see on 2/12/2013
//	//First pickup trip (idVeh, idTrip) has only 1 customer
//    //Same as Solution::SUBcal_InsertCusPIAfterJ_LastC
//	varvioCAP = PDS_MAX(seg[idVeh].Trip[idTrip].capacity + problem->node[i].capacity - problem->Q, 0) - seg[idVeh].Trip[idTrip].vioCAP;
//	varcost = problem->c[j][i];
//	double cArrTime, temp;
//
//	cArrTime = PDS_MAX(problem->c[0][j], problem->node[j].sTW);
//	temp = cArrTime - problem->node[j].eTW;
//	if (temp > eps)
//	{
//		varvioTWC = temp - vioTWCus[j];
//		cStartS = problem->node[j].depart;
//	}
//	else
//	{
//		varvioTWC = -vioTWCus[j];
//		cStartS = cArrTime + problem->node[j].duration;
//	}
//
//	cArrTime = cStartS + problem->c[j][i];
//	temp = cArrTime - problem->node[i].eTW;
//	if (temp > eps)
//	{
//		varvioTWC += temp;
//		cStartS = problem->node[i].depart;
//	}
//	else
//	{
//		//varvioTWC = 0;
//		cStartS = PDS_MAX(cArrTime, problem->node[i].sTW) + problem->node[i].duration;
//	}
//
//	int assSP = seg[idVeh].Trip[idTrip].assSP; 
//	cArrTime = cStartS + problem->c[i][assSP];
//	if (PDSINRANGE(cArrTime, problem->nodeSP[assSP].sTW1, problem->nodeSP[assSP].eTW1))
//	{
//		vioTWSPTRUE = 0;
//		//before insertion: go sp directly FEA OR INF; OR go through WS
//		varvioTWSP = -seg[idVeh].Trip[idTrip].vioTWSP;
//		varcost += problem->c[i][assSP];
//		if (seg[idVeh].Trip[idTrip].waitingS == NO_WS)
//			varcost -= problem->c[j][assSP];
//		else varcost -= problem->disCWSSP[j][assSP];
//		cStartS = cArrTime + problem->nodeSP[assSP].unload;
//	}
//	else
//	{
//		temp = cArrTime - problem->nodeSP[assSP].eTW1;
//		if (temp > eps) //too late to go sp directly
//		{
//			vioTWSPTRUE = 1;
//			varvioTWSP = temp - seg[idVeh].Trip[idTrip].vioTWSP;
//			varcost += problem->c[i][assSP];
//			//before insertion: go sp directly FEA OR INF; OR go through WS
//			if (seg[idVeh].Trip[idTrip].waitingS == NO_WS)
//			{
//				varcost -= problem->c[j][assSP];
//				if (seg[idVeh].Trip[idTrip].vioTWSP > eps) return 1;
//			}
//			else varcost -= problem->disCWSSP[j][assSP];			
//			cStartS = problem->leaveSP[assSP][0]; //unload only at eTW1
//		}
//		else
//		{
//			double cArrTimeI = cStartS + problem->disCWSSP[i][assSP];
//			temp = cArrTimeI - problem->nodeSP[assSP].eTW1;
//			if (temp > eps) //too soon to go sp directly, too late to go through WS:
//			{
//				vioTWSPTRUE = 1;
//				varvioTWSP = problem->nodeSP[assSP].sTW1 - cArrTime - seg[idVeh].Trip[idTrip].vioTWSP;
//				varcost += problem->c[i][assSP];
//				//before insertion: go sp directly FEA OR INF; OR go through WS
//				if (seg[idVeh].Trip[idTrip].waitingS == NO_WS)
//				{
//					varcost -= problem->c[j][assSP];
//					if (seg[idVeh].Trip[idTrip].vioTWSP > eps) return 1;
//				}
//				else varcost -= problem->disCWSSP[j][assSP];
//				cStartS = problem->leaveSP[assSP][0]; //unload only at eTW1
//			}
//			else //go through WS:
//			{
//				vioTWSPTRUE = 0;
//				varvioTWSP = -seg[idVeh].Trip[idTrip].vioTWSP;
//				//before insertion: go through WS too NOT ALWAYS Update 7/11/2013
//				if (seg[idVeh].Trip[idTrip].waitingS == NO_WS)
//					varcost += (problem->disCWSSP[i][assSP] - problem->c[j][assSP]);
//				else
//					varcost += (problem->disCWSSP[i][assSP] - problem->disCWSSP[j][assSP]);
//				cStartS = PDS_MAX(cArrTimeI, problem->nodeSP[assSP].sTW1) + problem->nodeSP[assSP].unload;
//			}
//		}
//	}
//	return 0;
//}
//
//
//  //Copy SUBcal_InsertCusPIAfterJ_LastC_1CusFirstTrip:
//bool Solution::cal_InsertCusPIAfterJ_LastC_1CusFirstTrip_TillTrip(int j, int i, int idVeh, int &varvioCAP, double &varcost, double &varvioTWC, double &varvioTWSP, double &cStartS, int update_idTrip)
//{
//	//See on 2/12/2013
//	//idVeh has >= 2 trips; insert i after j on first trip of idVeh with only 1 customer j
//	//First pickup trip (idVeh, idTrip) has only 1 customer
//    //Same as Solution::SUBcal_InsertCusPIAfterJ_LastC
//	varvioCAP += PDS_MAX(seg[idVeh].Trip[0].capacity + problem->node[i].capacity - problem->Q, 0) - seg[idVeh].Trip[0].vioCAP;
//	varcost += problem->c[j][i];
//	
//	double cArrTime, temp;
//
//	cArrTime = PDS_MAX(problem->c[0][j], problem->node[j].sTW);
//	temp = cArrTime - problem->node[j].eTW;
//	if (temp > eps)
//	{
//		varvioTWC += (temp - vioTWCus[j]);
//		cStartS = problem->node[j].depart;
//	}
//	else
//	{
//		varvioTWC -= vioTWCus[j];
//		cStartS = cArrTime + problem->node[j].duration;
//	}
//
//	cArrTime = cStartS + problem->c[j][i];
//	temp = cArrTime - problem->node[i].eTW;
//	if (temp > eps)
//	{
//		varvioTWC += temp;
//		cStartS = problem->node[i].depart;
//	}
//	else
//	{
//		//varvioTWC = 0;
//		cStartS = PDS_MAX(cArrTime, problem->node[i].sTW) + problem->node[i].duration;
//	}
//
//	int assSP = seg[idVeh].Trip[0].assSP; 
//	cArrTime = cStartS + problem->c[i][assSP];
//	double varvioTWSPHERE = -seg[idVeh].Trip[0].vioTWSP;
//	bool vioTWSPTRUE;
//	if (PDSINRANGE(cArrTime, problem->nodeSP[assSP].sTW1, problem->nodeSP[assSP].eTW1))
//	{
//		vioTWSPTRUE = 0;
//		//before insertion: go sp directly FEA OR INF; OR go through WS
//		varcost += problem->c[i][assSP];
//		if (seg[idVeh].Trip[0].waitingS == NO_WS)
//			varcost -= problem->c[j][assSP];
//		else varcost -= problem->disCWSSP[j][assSP];
//		cStartS = cArrTime + problem->nodeSP[assSP].unload;
//	}
//	else
//	{
//		temp = cArrTime - problem->nodeSP[assSP].eTW1;
//		if (temp > eps) //too late to go sp directly
//		{
//			vioTWSPTRUE = 1;
//			varvioTWSPHERE += temp;
//			varcost += problem->c[i][assSP];
//			//before insertion: go sp directly FEA OR INF; OR go through WS
//			if (seg[idVeh].Trip[0].waitingS == NO_WS)
//			{
//				varcost -= problem->c[j][assSP];
//				if (seg[idVeh].Trip[0].vioTWSP > eps)
//				{
//					if (seg[idVeh].Trip[1].Type == 1)
//						if (seg[idVeh].Trip[1].assSP == assSP)
//								varvioTWSPHERE *= 2;
//					varvioTWSP += varvioTWSPHERE;
//					return 1;
//				}
//			}
//			else varcost -= problem->disCWSSP[j][assSP];			
//			cStartS = problem->leaveSP[assSP][0]; //unload only at eTW1
//		}
//		else
//		{
//			double cArrTimeI = cStartS + problem->disCWSSP[i][assSP];
//			temp = cArrTimeI - problem->nodeSP[assSP].eTW1;
//			if (temp > eps) //too soon to go sp directly, too late to go through WS:
//			{
//				vioTWSPTRUE = 1;
//				varvioTWSPHERE += (problem->nodeSP[assSP].sTW1 - cArrTime);
//				varcost += problem->c[i][assSP];
//				//before insertion: go sp directly FEA OR INF; OR go through WS
//				if (seg[idVeh].Trip[0].waitingS == NO_WS)
//				{
//					varcost -= problem->c[j][assSP];
//					if (seg[idVeh].Trip[0].vioTWSP > eps)
//					{
//						if (seg[idVeh].Trip[1].Type == 1)
//							if (seg[idVeh].Trip[1].assSP == assSP)
//									varvioTWSPHERE *= 2;
//						varvioTWSP += varvioTWSPHERE;
//						return 1;
//					}
//				}
//				else varcost -= problem->disCWSSP[j][assSP];
//				cStartS = problem->leaveSP[assSP][0]; //unload only at eTW1
//			}
//			else //go through WS:
//			{
//				vioTWSPTRUE = 0;
//				//before insertion: go through WS too NOT ALWAYS Update 7/11/2013
//				if (seg[idVeh].Trip[0].waitingS == NO_WS)
//					varcost += (problem->disCWSSP[i][assSP] - problem->c[j][assSP]);
//				else
//					varcost += (problem->disCWSSP[i][assSP] - problem->disCWSSP[j][assSP]);
//				cStartS = PDS_MAX(cArrTimeI, problem->nodeSP[assSP].sTW1) + problem->nodeSP[assSP].unload;
//			}
//		}
//	}
//
//	varvioTWSP += varvioTWSPHERE;
//	if (update_idTrip > 0)
//	{
//		int firstC_nextT = seg[idVeh].Trip[1].firstCus;
//		if (seg[idVeh].Trip[1].Type == 1)
//		{
//			if (seg[idVeh].Trip[1].assSP == assSP)
//			{
//				varvioTWSP += varvioTWSPHERE;
//				//Update 16/11/2013
//				if (vioTWSPTRUE) cStartS = problem->leaveSP[assSP][1]; //unload only at eTW2
//				else cStartS += problem->nodeSP[assSP].load;
//				//Quangnn+-
//				return 0 ;//GoThroughVehicle(idVeh, 1, update_idTrip, varcost, varvioTWC, varvioTWSP, cStartS, assSP, firstC_nextT);
//			}
//			else
//			{
//				if (calChangeCONNECTAtSP_SPSP(idVeh, 1, 0, cStartS, varvioTWSP, varcost) == 0){
//					//Quangnn+-
//					return 0;//GoThroughVehicle(idVeh, 1, update_idTrip, varcost, varvioTWC, varvioTWSP, cStartS, seg[idVeh].Trip[1].assSP, firstC_nextT);
//				}
//				else return 1;	
//			}
//		}
//		else {//seg[idVeh].Trip[1].Type == 0 || 2
//		   //Quangnn+-
//			return 0;//GoThroughVehicle(idVeh, 1, update_idTrip, varcost, varvioTWC, varvioTWSP, cStartS, assSP, firstC_nextT);
//		}
//	}
//	return 0;
//}
//
//bool Solution::cal_InsertCusPIAfterJ_OneVeh_TillTrip(int j, int i, int idVeh, int idTrip, int &varvioCAP, double &varcost, double &varvioTWC, double &varvioTWSP, double &cStartS, int update_idTrip)
//{ //see on 2/12/2013
//  //Insert j after i on (idVeh, idTripj) where idTripj may first/middle/lastTrip; then update remaining trips till update_idTrip
//  //If idTrip is the first trip, then it has >= 2 customers
//  //COPY SUBcal_InsertCusPIAfterJ_LastC and SUBcal_InsertCusPIAfterJ_NotLastC
//
//	varvioCAP += (PDS_MAX(seg[idVeh].Trip[idTrip].capacity + problem->node[i].capacity - problem->Q, 0) - seg[idVeh].Trip[idTrip].vioCAP);
//	double cArrTime, temp;
//	double varvioTWSPHERE = -seg[idVeh].Trip[idTrip].vioTWSP;
//	int assSP = seg[idVeh].Trip[idTrip].assSP;
//	bool vioTWSPTRUE;
//
//	if (seg[idVeh].Trip[idTrip].lastCus != j) //j is not the last cus
//	{
//			cArrTime = depart[j] + problem->c[j][i];
//			temp = cArrTime - problem->node[i].eTW;
//			double vioTWCNEW = FvioTWCus[j];
//			
//			if (temp > eps)
//			{
//				vioTWCNEW += temp;
//				cStartS = problem->node[i].depart;
//			}
//			else
//				cStartS = PDS_MAX(cArrTime, problem->node[i].sTW) + problem->node[i].duration;
//			
//			int nextID = nextArr[j];
//			varcost += (problem->c[j][i] + problem->c[i][nextID] - problem->c[j][nextID]);
//			int preID = i; 
//			
//			do
//			{
//				  cArrTime = cStartS + problem->c[preID][nextID]; //Arrive Time to Customer nextID
//				  temp = cArrTime - problem->node[nextID].eTW;
//				  if (temp > eps)
//				  {
//					  vioTWCNEW += temp;
//					  if (vioTWCus[nextID] > eps) 
//					  {
//							varvioTWC += (vioTWCNEW - FvioTWCus[nextID]);
//							return 1;
//					  }
//					  cStartS = problem->node[nextID].depart;
//				  }
//				  else
//					  cStartS = PDS_MAX(cArrTime, problem->node[nextID].sTW) + problem->node[nextID].duration;
//				  preID = nextID; nextID = nextArr[nextID];
//			}while (nextID > 0);
//
//			varvioTWC += (vioTWCNEW - seg[idVeh].Trip[idTrip].vioTWC);
//
//			//preID now points to the last customer
//			cArrTime = cStartS + problem->c[preID][assSP];
//			if (PDSINRANGE(cArrTime, problem->nodeSP[assSP].sTW1, problem->nodeSP[assSP].eTW1))
//			{
//				vioTWSPTRUE = 0;
//				//before insertion: go sp directly FEA OR INF; OR go through WS
//				if (seg[idVeh].Trip[idTrip].waitingS != NO_WS)
//					varcost += (problem->c[preID][assSP] - problem->disCWSSP[preID][assSP]);
//				cStartS = cArrTime + problem->nodeSP[assSP].unload;
//			}
//			else
//			{
//				temp = cArrTime - problem->nodeSP[assSP].eTW1;
//				if (temp > eps) //too late to go sp directly
//				{
//					vioTWSPTRUE = 1;
//					varvioTWSPHERE += temp;
//					//before insertion: go sp directly FEA OR INF; OR go through WS
//					if (seg[idVeh].Trip[idTrip].vioTWSP > eps)
//					{
//						int nextT = idTrip + 1;
//						if (nextT < seg[idVeh].numTrips)
//						{
//							if (seg[idVeh].Trip[nextT].Type == 1)
//								if (seg[idVeh].Trip[nextT].assSP == assSP)
//									varvioTWSPHERE *= 2;
//						}
//						varvioTWSP += varvioTWSPHERE;
//						return 1;
//					}
//					if (seg[idVeh].Trip[idTrip].waitingS != NO_WS)
//						varcost += (problem->c[preID][assSP] - problem->disCWSSP[preID][assSP]);
//					cStartS = problem->leaveSP[assSP][0]; //unload only at eTW1
//				}
//				else
//				{
//					double cArrTimeI = cStartS + problem->disCWSSP[preID][assSP];
//					temp = cArrTimeI - problem->nodeSP[assSP].eTW1;
//					if (temp > eps) //too soon to go sp directly, too late to go through WS:
//					{
//						vioTWSPTRUE = 1;
//						varvioTWSPHERE += (problem->nodeSP[assSP].sTW1 - cArrTime);
//						//before insertion: go sp directly FEA OR INF; OR go through WS
//						if (seg[idVeh].Trip[idTrip].vioTWSP > eps) 
//						{
//							int nextT = idTrip + 1;
//							if (nextT < seg[idVeh].numTrips)
//							{
//								if (seg[idVeh].Trip[nextT].Type == 1)
//									if (seg[idVeh].Trip[nextT].assSP == assSP)
//										varvioTWSPHERE *= 2;
//							}
//							varvioTWSP += varvioTWSPHERE;
//							return 1;
//						}
//						if (seg[idVeh].Trip[idTrip].waitingS != NO_WS)
//							varcost += (problem->c[preID][assSP] - problem->disCWSSP[preID][assSP]);
//						cStartS = problem->leaveSP[assSP][0]; //unload only at eTW1
//					}
//					else //go through WS:
//					{
//						vioTWSPTRUE = 0;
//						//varvioTWSP = -seg[idVeh].Trip[idTrip].vioTWSP;
//						//before insertion: go through WS too --> donnt need to update varcost NOT ALWAYS: Update 7/11/2013
//						if (seg[idVeh].Trip[idTrip].waitingS == NO_WS)
//							varcost += (problem->disCWSSP[preID][assSP] - problem->c[preID][assSP]);
//						cStartS = PDS_MAX(cArrTimeI, problem->nodeSP[assSP].sTW1) + problem->nodeSP[assSP].unload;
//					}
//				}
//			}
//	}
//	else //j is the last cus:
//	{
//		varcost += problem->c[j][i];
//
//		double cArrTime, temp;
//		cArrTime = depart[j] + problem->c[j][i];
//		temp = cArrTime - problem->node[i].eTW;
//		if (temp > eps)
//		{
//			varvioTWC += temp;
//			cStartS = problem->node[i].depart;
//		}
//		else
//		{
//			cStartS = PDS_MAX(cArrTime, problem->node[i].sTW) + problem->node[i].duration;
//		}
//	
//		cArrTime = cStartS + problem->c[i][assSP];
//		if (PDSINRANGE(cArrTime, problem->nodeSP[assSP].sTW1, problem->nodeSP[assSP].eTW1))
//		{
//			vioTWSPTRUE = 0;
//			//before insertion: go sp directly FEA OR INF; OR go through WS
//			varcost += problem->c[i][assSP];
//			if (seg[idVeh].Trip[idTrip].waitingS == NO_WS)
//				varcost -= problem->c[j][assSP];
//			else varcost -= problem->disCWSSP[j][assSP];
//			cStartS = cArrTime + problem->nodeSP[assSP].unload;
//		}
//		else
//		{
//			temp = cArrTime - problem->nodeSP[assSP].eTW1;
//			if (temp > eps) //too late to go sp directly
//			{
//				vioTWSPTRUE = 1;
//				varvioTWSPHERE += temp;
//				varcost += problem->c[i][assSP];
//				//before insertion: go sp directly FEA OR INF; OR go through WS
//				if (seg[idVeh].Trip[idTrip].waitingS == NO_WS)
//				{
//					varcost -= problem->c[j][assSP];
//					if (seg[idVeh].Trip[idTrip].vioTWSP > eps)
//					{
//						int nextT = idTrip + 1;
//						if (nextT < seg[idVeh].numTrips)
//						{
//							if (seg[idVeh].Trip[nextT].Type == 1)
//								if (seg[idVeh].Trip[nextT].assSP == assSP)
//									varvioTWSPHERE *= 2;
//						}
//						varvioTWSP += varvioTWSPHERE;
//						return 1;
//					}
//				}
//				else varcost -= problem->disCWSSP[j][assSP];			
//				cStartS = problem->leaveSP[assSP][0]; //unload only at eTW1
//			}
//			else
//			{
//				double cArrTimeI = cStartS + problem->disCWSSP[i][assSP];
//				temp = cArrTimeI - problem->nodeSP[assSP].eTW1;
//				if (temp > eps) //too soon to go sp directly, too late to go through WS:
//				{
//					vioTWSPTRUE = 1;
//					varvioTWSPHERE += (problem->nodeSP[assSP].sTW1 - cArrTime);
//					varcost += problem->c[i][assSP];
//					//before insertion: go sp directly FEA OR INF; OR go through WS
//					if (seg[idVeh].Trip[idTrip].waitingS == NO_WS)
//					{
//						varcost -= problem->c[j][assSP];
//						if (seg[idVeh].Trip[idTrip].vioTWSP > eps)
//						{
//							int nextT = idTrip + 1;
//							if (nextT < seg[idVeh].numTrips)
//							{
//								if (seg[idVeh].Trip[nextT].Type == 1)
//									if (seg[idVeh].Trip[nextT].assSP == assSP)
//										varvioTWSPHERE *= 2;
//							}
//							varvioTWSP += varvioTWSPHERE;
//							return 1;
//						}
//					}
//					else varcost -= problem->disCWSSP[j][assSP];
//					cStartS = problem->leaveSP[assSP][0]; //unload only at eTW1
//				}
//				else //go through WS:
//				{
//					vioTWSPTRUE = 0;
//					//before insertion: go through WS too NOT ALWAYS Update 7/11/2013
//					if (seg[idVeh].Trip[idTrip].waitingS == NO_WS)
//						varcost += (problem->disCWSSP[i][assSP] - problem->c[j][assSP]);
//					else
//						varcost += (problem->disCWSSP[i][assSP] - problem->disCWSSP[j][assSP]);
//					cStartS = PDS_MAX(cArrTimeI, problem->nodeSP[assSP].sTW1) + problem->nodeSP[assSP].unload;
//				}
//			}
//		}
//	}//end j is the last cus
//
//	varvioTWSP += varvioTWSPHERE;
//	if (update_idTrip > idTrip)
//	{
//		//Update 6/12/2013:
//		int numTripUpdate = update_idTrip - idTrip;
//		int nextT = idTrip + 1;
//		int firstC_nextT = seg[idVeh].Trip[nextT].firstCus;
//		if (seg[idVeh].Trip[nextT].Type == 1)
//		{
//			if (seg[idVeh].Trip[nextT].assSP == assSP)
//			{
//				varvioTWSP += varvioTWSPHERE;
//				//Update 16/11/2013
//				if (vioTWSPTRUE) cStartS = problem->leaveSP[assSP][1]; //unload only at eTW2
//				else  cStartS += problem->nodeSP[assSP].load;
//				//Quangnn+-
//				return 0;//GoThroughVehicle(idVeh, nextT, numTripUpdate, varcost, varvioTWC, varvioTWSP, cStartS, assSP, firstC_nextT);
//			}
//			else
//			{
//				if (calChangeCONNECTAtSP_SPSP(idVeh, nextT, idTrip, cStartS, varvioTWSP, varcost) == 0){
//					//Quangnn+-
//					return 0;//GoThroughVehicle(idVeh, nextT, numTripUpdate, varcost, varvioTWC, varvioTWSP, cStartS, seg[idVeh].Trip[nextT].assSP, firstC_nextT);
//				}
//				else return 1;	
//			}
//		}
//		else{ //seg[idVeh].Trip[nextT].Type == 0 || 2
//			//Quangnn+-
//			return 0;//GoThroughVehicle(idVeh, nextT, numTripUpdate, varcost, varvioTWC, varvioTWSP, cStartS, assSP, firstC_nextT);
//		}
//	}
//	return 0;
//}
//
//
//void Solution::cal_InsertCusPIAfterJ_FromBeginning(int j, int i, int idVeh, int idTrip, int preT, int &varvioCAP, double &varcost, double &varvioTWC, double &varvioTWSP, double cStartS)
//{
//	//See on 2/12/2013
//	//idTrip > 0; insert i after j on (idVeh, idTrip)
//	varvioCAP += (PDS_MAX(seg[idVeh].Trip[idTrip].capacity + problem->node[i].capacity - problem->Q, 0) - seg[idVeh].Trip[idTrip].vioCAP);
//	varcost += problem->c[j][i];
//
//	int preID, nextID;
//
//	if (seg[idVeh].Trip[preT].Type == 0) preID = seg[idVeh].Trip[preT].assSP;
//	else preID = seg[idVeh].Trip[preT].lastCus;
//	
//
//	int sucj = nextArr[j];
//	nextID = seg[idVeh].Trip[idTrip].firstCus;
//	double cArrTime, temp;
//
//	while (nextID != sucj)
//	{
//          cArrTime = cStartS + problem->c[preID][nextID]; //Arrive Time to Customer nextID
//		  temp = cArrTime - problem->node[nextID].eTW;
//          if (temp > eps)
//		  {
//			  if (vioTWCus[nextID] > eps)
//			  {
//				  varvioTWC += (temp - vioTWCus[nextID]);
//				  cStartS = depart[j];
//				  break;
//			  }
//			  varvioTWC += temp;
//			  cStartS = problem->node[nextID].depart;
//		  }
//		  else
//		  {
//			  varvioTWC -= vioTWCus[nextID]; //Update 15/11/2013
//			  cStartS = PDS_MAX(cArrTime, problem->node[nextID].sTW) + problem->node[nextID].duration;
//		  }
//		  preID = nextID; nextID = nextArr[nextID];
//	}//end while (nextID != sucj)
//
//	//Calculate at i:
//	cArrTime = cStartS + problem->c[j][i];
//	temp = cArrTime - problem->node[i].eTW;
//	if (temp > eps)
//	{
//		varvioTWC += temp;
//		cStartS = problem->node[i].depart;
//	}
//	else
//		cStartS = PDS_MAX(cArrTime, problem->node[i].sTW) + problem->node[i].duration;
//
//    //Check from sucj till the end of the trip:
//	preID = i; nextID = sucj;
//	if (sucj > 0)
//	{
//		varcost += (problem->c[i][sucj] - problem->c[j][sucj]);
//		do
//		{
//			  cArrTime = cStartS + problem->c[preID][nextID]; //Arrive Time to Customer nextC
//			  temp = cArrTime - problem->node[nextID].eTW;
//			  if (temp > eps)
//			  {
//				  varvioTWC += (temp - vioTWCus[nextID]);
//				  if (vioTWCus[nextID] > eps) return;
//				  cStartS = problem->node[nextID].depart;
//			  }
//			  else
//			  {
//				  varvioTWC -= vioTWCus[nextID]; //Update 15/11/2013
//				  cStartS = PDS_MAX(cArrTime, problem->node[nextID].sTW) + problem->node[nextID].duration;
//			  }
//			  preID = nextID; nextID = nextArr[nextID];
//		} while (nextID > 0);
//	}
//    
//	//now preID points to NEWlastcus:
//	int assSP = seg[idVeh].Trip[idTrip].assSP; 
//	cArrTime = cStartS + problem->c[preID][assSP];
//	double varvioTWSPHERE = -seg[idVeh].Trip[idTrip].vioTWSP;
//	bool vioTWSPTRUE;
//	int lastCOLD = seg[idVeh].Trip[idTrip].lastCus;
//
//	if (lastCOLD == preID) //not change lastC
//	{
//		if (PDSINRANGE(cArrTime, problem->nodeSP[assSP].sTW1, problem->nodeSP[assSP].eTW1))
//		{
//			vioTWSPTRUE = 0;
//			//before insertion: go sp directly FEA OR INF; OR go through WS
//			if (seg[idVeh].Trip[idTrip].waitingS != NO_WS)
//				varcost += (problem->c[preID][assSP] - problem->disCWSSP[preID][assSP]);
//			cStartS = cArrTime + problem->nodeSP[assSP].unload;
//		}
//		else
//		{
//			temp = cArrTime - problem->nodeSP[assSP].eTW1;
//			if (temp > eps) //too late to go sp directly
//			{
//				vioTWSPTRUE = 1;
//				varvioTWSPHERE += temp;
//				//before insertion: go sp directly FEA OR INF; OR go through WS
//				if (seg[idVeh].Trip[idTrip].vioTWSP > eps) 
//				{
//					int nextT = idTrip + 1;
//					if (nextT < seg[idVeh].numTrips)
//					  if (seg[idVeh].Trip[nextT].Type == 1)
//						if (seg[idVeh].Trip[nextT].assSP == assSP)
//							varvioTWSPHERE *= 2;
//					varvioTWSP += varvioTWSPHERE;
//					return;
//				}
//				if (seg[idVeh].Trip[idTrip].waitingS != NO_WS)
//					varcost += (problem->c[preID][assSP] - problem->disCWSSP[preID][assSP]);
//				cStartS = problem->leaveSP[assSP][0]; //unload only at eTW1
//			}
//			else
//			{
//				double cArrTimeI = cStartS + problem->disCWSSP[preID][assSP];
//				temp = cArrTimeI - problem->nodeSP[assSP].eTW1;
//				if (temp > eps) //too soon to go sp directly, too late to go through WS:
//				{
//					vioTWSPTRUE = 1;
//					varvioTWSPHERE += (problem->nodeSP[assSP].sTW1 - cArrTime);
//					//before insertion: go sp directly FEA OR INF; OR go through WS
//					if (seg[idVeh].Trip[idTrip].vioTWSP > eps)
//					{
//						int nextT = idTrip + 1;
//						if (nextT < seg[idVeh].numTrips)
//							if (seg[idVeh].Trip[nextT].Type == 1)
//								if (seg[idVeh].Trip[nextT].assSP == assSP)
//									varvioTWSPHERE *= 2;
//						varvioTWSP += varvioTWSPHERE;
//						return;
//					}
//					if (seg[idVeh].Trip[idTrip].waitingS != NO_WS)
//						varcost += (problem->c[preID][assSP] - problem->disCWSSP[preID][assSP]);
//					cStartS = problem->leaveSP[assSP][0]; //unload only at eTW1
//				}
//				else //go through WS:
//				{
//					vioTWSPTRUE = 0;
//					//varvioTWSP = -seg[idVeh].Trip[idTrip].vioTWSP;
//					//before insertion: go through WS too --> donnt need to update varcost NOT ALWAYS: Update 7/11/2013
//					if (seg[idVeh].Trip[idTrip].waitingS == NO_WS)
//						varcost += (problem->disCWSSP[preID][assSP] - problem->c[preID][assSP]);
//					cStartS = PDS_MAX(cArrTimeI, problem->nodeSP[assSP].sTW1) + problem->nodeSP[assSP].unload;
//				}
//			}
//		}
//	}
//	else //lastC changed
//	{
//		if (PDSINRANGE(cArrTime, problem->nodeSP[assSP].sTW1, problem->nodeSP[assSP].eTW1))
//		{
//			vioTWSPTRUE = 0;
//			//before insertion: go sp directly FEA OR INF; OR go through WS
//			varcost += problem->c[i][assSP];
//			if (seg[idVeh].Trip[idTrip].waitingS == NO_WS)
//				varcost -= problem->c[j][assSP];
//			else varcost -= problem->disCWSSP[j][assSP];
//			cStartS = cArrTime + problem->nodeSP[assSP].unload;
//		}
//		else
//		{
//			temp = cArrTime - problem->nodeSP[assSP].eTW1;
//			if (temp > eps) //too late to go sp directly
//			{
//				vioTWSPTRUE = 1;
//				varvioTWSPHERE += temp;
//				varcost += problem->c[i][assSP];
//				//before insertion: go sp directly FEA OR INF; OR go through WS
//				if (seg[idVeh].Trip[idTrip].waitingS == NO_WS)
//				{
//					varcost -= problem->c[j][assSP];
//					if (seg[idVeh].Trip[idTrip].vioTWSP > eps)
//					{
//						int nextT = idTrip + 1;
//						if (nextT < seg[idVeh].numTrips)
//						if (seg[idVeh].Trip[nextT].Type == 1)
//							if (seg[idVeh].Trip[nextT].assSP == assSP)
//								varvioTWSPHERE *= 2;
//						varvioTWSP += varvioTWSPHERE;
//						return;
//					}
//				}
//				else varcost -= problem->disCWSSP[j][assSP];			
//				cStartS = problem->leaveSP[assSP][0]; //unload only at eTW1
//			}
//			else
//			{
//				double cArrTimeI = cStartS + problem->disCWSSP[i][assSP];
//				temp = cArrTimeI - problem->nodeSP[assSP].eTW1;
//				if (temp > eps) //too soon to go sp directly, too late to go through WS:
//				{
//					vioTWSPTRUE = 1;
//					varvioTWSPHERE += (problem->nodeSP[assSP].sTW1 - cArrTime);
//					varcost += problem->c[i][assSP];
//					//before insertion: go sp directly FEA OR INF; OR go through WS
//					if (seg[idVeh].Trip[idTrip].waitingS == NO_WS)
//					{
//						varcost -= problem->c[j][assSP];
//						if (seg[idVeh].Trip[idTrip].vioTWSP > eps) 
//						{
//							int nextT = idTrip + 1;
//							if (nextT < seg[idVeh].numTrips)
//							if (seg[idVeh].Trip[nextT].Type == 1)
//								if (seg[idVeh].Trip[nextT].assSP == assSP)
//									varvioTWSPHERE *= 2;
//							varvioTWSP += varvioTWSPHERE;
//							return;
//						}
//					}
//					else varcost -= problem->disCWSSP[j][assSP];
//					cStartS = problem->leaveSP[assSP][0]; //unload only at eTW1
//				}
//				else //go through WS:
//				{
//					vioTWSPTRUE = 0;
//					//before insertion: go through WS too NOT ALWAYS Update 7/11/2013
//					if (seg[idVeh].Trip[idTrip].waitingS == NO_WS)
//						varcost += (problem->disCWSSP[i][assSP] - problem->c[j][assSP]);
//					else
//						varcost += (problem->disCWSSP[i][assSP] - problem->disCWSSP[j][assSP]);
//					cStartS = PDS_MAX(cArrTimeI, problem->nodeSP[assSP].sTW1) + problem->nodeSP[assSP].unload;
//				}
//			}
//		}
//	}//lastC changed
//
//	//GOTHROUGH VEHICLE:
//	varvioTWSP += varvioTWSPHERE;
//	int nextT = idTrip + 1;
//	if (nextT < seg[idVeh].numTrips)
//	{
//	 	int firstC_nextT = seg[idVeh].Trip[nextT].firstCus;
//		if (seg[idVeh].Trip[nextT].Type == 1)
//		{
//			if (seg[idVeh].Trip[nextT].assSP == assSP)
//			{
//                varvioTWSP += varvioTWSPHERE;  
//				//Update 16/11/2013
//				if (vioTWSPTRUE) cStartS = problem->leaveSP[assSP][1];//load only at eTW2
//				else  cStartS += problem->nodeSP[assSP].load;
//				GoThroughVehicle(idVeh, nextT, varcost, varvioTWC, varvioTWSP, cStartS, assSP, firstC_nextT);
//			}
//			else
//			{
//				if (calChangeCONNECTAtSP_SPSP(idVeh, nextT, idTrip, cStartS, varvioTWSP, varcost) == 0)
//					GoThroughVehicle(idVeh, nextT, varcost, varvioTWC, varvioTWSP, cStartS, seg[idVeh].Trip[nextT].assSP, firstC_nextT);
//			}
//		}
//		else //if (seg[idVeh].Trip[nextT].Type == 0 || 2)
//		   GoThroughVehicle(idVeh, nextT, varcost, varvioTWC, varvioTWSP, cStartS, assSP, firstC_nextT);
//	}
//}
//
//
//void Solution::cal_InsertCusPIAfterJ_LastC_NextTripPORC2C(int j, int i, int idVeh, int idTrip, int &varvioCAP, double &varcost, double &varvioTWC, double &varvioTWSP)
//{
//	//see on 8/12/2013
//   double cStartS; 
//
//   double varvioTWSP1 = 0;
//   if (SUBcal_InsertCusPIAfterJ_LastC1(j, i, idVeh, idTrip, varvioCAP, varcost, varvioTWC, varvioTWSP1, cStartS)== 0)
//   {
//	   varvioTWSP += varvioTWSP1;
//       int nextT = idTrip + 1;
//       int firstC_nextT = seg[idVeh].Trip[nextT].firstCus;
//       GoThroughVehicle(idVeh, nextT, varcost, varvioTWC, varvioTWSP, cStartS, seg[idVeh].Trip[idTrip].assSP, firstC_nextT);
//   }
//   else varvioTWSP += varvioTWSP1;
//}
//
//
//void Solution::cal_InsertCusPIAfterJ_LastC_NextTripPORC2C_Start(int j, int i, int idVeh, int idTrip, int &varvioCAP, double &varcost, double &varvioTWC, double &varvioTWSP)
//{
//	//see on 2/12/2013
//   double cStartS; 
//   if (SUBcal_InsertCusPIAfterJ_LastC1_Start(j, i, idVeh, idTrip, varvioCAP, varcost, varvioTWC, varvioTWSP, cStartS)== 0)
//   {
//       int nextT = idTrip + 1;
//       int firstC_nextT = seg[idVeh].Trip[nextT].firstCus;
//       GoThroughVehicle(idVeh, nextT, varcost, varvioTWC, varvioTWSP, cStartS, seg[idVeh].Trip[idTrip].assSP, firstC_nextT);
//   }
//}
//
//
//void Solution::cal_InsertCusPIAfterJ_LastC_NextTripPORC2C_1CusFirstTrip(int j, int i, int idVeh, int idTrip, int &varvioCAP, double &varcost, double &varvioTWC, double &varvioTWSP)
//{
//   //See on 2/12/2013
//   double cStartS; 
//
//   if (SUBcal_InsertCusPIAfterJ_LastC_1CusFirstTrip(j, i, idVeh, idTrip, varvioCAP, varcost, varvioTWC, varvioTWSP, cStartS)== 0)
//   {
//       int nextT = idTrip + 1;
//       int firstC_nextT = seg[idVeh].Trip[nextT].firstCus;
//       GoThroughVehicle(idVeh, nextT, varcost, varvioTWC, varvioTWSP, cStartS, seg[idVeh].Trip[idTrip].assSP, firstC_nextT);
//   }
//}
//
//
//void Solution::cal_InsertCusPIAfterJ_LastC_NextTripD_SameSP(int j, int i, int idVeh, int idTrip, int &varvioCAP, double &varcost, double &varvioTWC, double &varvioTWSP)
//{
//	//See on 2/12/2013
//   double cStartS; 
// 
//   double varvioTWSP1 = 0;
//   bool vioTWSPTRUE;
//   if (SUBcal_InsertCusPIAfterJ_LastC1(j, i, idVeh, idTrip, varvioCAP, varcost, varvioTWC, varvioTWSP1, cStartS, vioTWSPTRUE)== 0)
//   {
//		varvioTWSP += (2 * varvioTWSP1); //not calculated at SUBcal_InsertCusPIAfterJ_LastC1
//		int assSP = seg[idVeh].Trip[idTrip].assSP;
//		if (vioTWSPTRUE) cStartS = problem->leaveSP[assSP][1];
//		else cStartS += problem->nodeSP[assSP].load;
//	 
//		int nextT = idTrip + 1;
// 	    int firstC_nextT = seg[idVeh].Trip[nextT].firstCus;
//		GoThroughVehicle(idVeh, nextT, varcost, varvioTWC, varvioTWSP, cStartS, assSP, firstC_nextT);
//   }
//   else varvioTWSP += (2 * varvioTWSP1);
//}
//
//void Solution::cal_InsertCusPIAfterJ_LastC_NextTripD_SameSP_Start(int j, int i, int idVeh, int idTrip, int &varvioCAP, double &varcost, double &varvioTWC, double &varvioTWSP)
//{
//	//see on 2/12/2013
//   double cStartS; 
//   bool vioTWSPTRUE;
// 
//   if (SUBcal_InsertCusPIAfterJ_LastC1_Start(j, i, idVeh, idTrip, varvioCAP, varcost, varvioTWC, varvioTWSP, cStartS, vioTWSPTRUE)== 0)
//   {
//		varvioTWSP *= 2; //not calculated at SUBcal_InsertCusPIAfterJ_LastC1
//		int assSP = seg[idVeh].Trip[idTrip].assSP;
//		//Update 16/11/2013
//		if (vioTWSPTRUE) cStartS = problem->leaveSP[assSP][1];
//		else cStartS += problem->nodeSP[assSP].load;
//	 
//		int nextT = idTrip + 1;
// 	    int firstC_nextT = seg[idVeh].Trip[nextT].firstCus;
//		GoThroughVehicle(idVeh, nextT, varcost, varvioTWC, varvioTWSP, cStartS, assSP, firstC_nextT);
//   }
//   else varvioTWSP *= 2;
//}
//
//
//
//
//void Solution::cal_InsertCusPIAfterJ_LastC_NextTripD_SameSP_1CusFirstTrip(int j, int i, int idVeh, int idTrip, int &varvioCAP, double &varcost, double &varvioTWC, double &varvioTWSP)
//{
//	//See on 2/12/2013
//   double cStartS; 
//   bool vioTWSPTRUE;
// 
//   if (SUBcal_InsertCusPIAfterJ_LastC_1CusFirstTrip(j, i, idVeh, idTrip, varvioCAP, varcost, varvioTWC, varvioTWSP, cStartS, vioTWSPTRUE)== 0)
//   {
//		varvioTWSP *= 2; //not calculated at SUBcal_InsertCusPIAfterJ_LastC
//		int assSP = seg[idVeh].Trip[idTrip].assSP;
//		//Update 16/11/2013
//		if (vioTWSPTRUE) cStartS = problem->leaveSP[assSP][1];
//		else cStartS += problem->nodeSP[assSP].load;
//	 
//		int nextT = idTrip + 1;
// 	    int firstC_nextT = seg[idVeh].Trip[nextT].firstCus;
//		GoThroughVehicle(idVeh, nextT, varcost, varvioTWC, varvioTWSP, cStartS, assSP, firstC_nextT);
//   }
//   else varvioTWSP *= 2;
//}
//
//
//
//void Solution::cal_InsertCusPIAfterJ_LastC_NextTripD_DifSP(int j, int i, int idVeh, int idTrip, int &varvioCAP, double &varcost, double &varvioTWC, double &varvioTWSP)
//{
//	//See on 2/12/2013
//   double cStartS;
//   double varvioTWSP1 = 0;
//   if (SUBcal_InsertCusPIAfterJ_LastC1(j, i, idVeh, idTrip, varvioCAP, varcost, varvioTWC, varvioTWSP1, cStartS)== 0)
//   {
//	    varvioTWSP += varvioTWSP1;
//		int nextT = idTrip + 1;
// 	    int firstC_nextT = seg[idVeh].Trip[nextT].firstCus;
//		if (calChangeCONNECTAtSP_SPSP(idVeh, nextT, idTrip, cStartS, varvioTWSP, varcost) == 0)
//			GoThroughVehicle(idVeh, nextT, varcost, varvioTWC, varvioTWSP, cStartS, seg[idVeh].Trip[nextT].assSP, firstC_nextT);
//   }
//   else varvioTWSP += varvioTWSP1;
//}
//
//void Solution::cal_InsertCusPIAfterJ_LastC_NextTripD_DifSP_Start(int j, int i, int idVeh, int idTrip, int &varvioCAP, double &varcost, double &varvioTWC, double &varvioTWSP)
//{
//	//see on 2/12/2013
//   double cStartS;
//   if (SUBcal_InsertCusPIAfterJ_LastC1_Start(j, i, idVeh, idTrip, varvioCAP, varcost, varvioTWC, varvioTWSP, cStartS)== 0)
//   {
//		int nextT = idTrip + 1;
// 	    int firstC_nextT = seg[idVeh].Trip[nextT].firstCus;
//		if (calChangeCONNECTAtSP_SPSP(idVeh, nextT, idTrip, cStartS, varvioTWSP, varcost) == 0)
//			GoThroughVehicle(idVeh, nextT, varcost, varvioTWC, varvioTWSP, cStartS, seg[idVeh].Trip[nextT].assSP, firstC_nextT);
//   }
//}
//
//
//
//
//
//void Solution::cal_InsertCusPIAfterJ_LastC_NextTripD_DifSP_1CusFirstTrip(int j, int i, int idVeh, int idTrip, int &varvioCAP, double &varcost, double &varvioTWC, double &varvioTWSP)
//{
//   //See on 2/12/2013
//   double cStartS;
//   if (SUBcal_InsertCusPIAfterJ_LastC_1CusFirstTrip(j, i, idVeh, idTrip, varvioCAP, varcost, varvioTWC, varvioTWSP, cStartS) == 0)
//   {
//		int nextT = idTrip + 1;
// 	    int firstC_nextT = seg[idVeh].Trip[nextT].firstCus;
//		if (calChangeCONNECTAtSP_SPSP(idVeh, nextT, idTrip, cStartS, varvioTWSP, varcost) == 0)
//			GoThroughVehicle(idVeh, nextT, varcost, varvioTWC, varvioTWSP, cStartS, seg[idVeh].Trip[nextT].assSP, firstC_nextT);
//   }
//}
//
//
//void Solution::cal_InsertCusPIAfterJ_NotLastC_NextTripPORC2C(int j, int i, int idVeh, int idTrip, int &varvioCAP, double &varcost, double &varvioTWC, double &varvioTWSP)
//{
//	//See on 2/12/2013
//   double cStartS; 
//   double varvioTWSP1 = 0;
//   if (SUBcal_InsertCusPIAfterJ_NotLastC1(j, i, idVeh, idTrip, varvioCAP, varcost, varvioTWC, varvioTWSP1, cStartS)== 0)
//   {
//	   varvioTWSP += varvioTWSP1;
//       int nextT = idTrip + 1;
//       int firstC_nextT = seg[idVeh].Trip[nextT].firstCus;
//       GoThroughVehicle(idVeh, nextT, varcost, varvioTWC, varvioTWSP, cStartS, seg[idVeh].Trip[idTrip].assSP, firstC_nextT);
//   }
//   else varvioTWSP += varvioTWSP1;
//}
//
//
//void Solution::cal_InsertCusPIAfterJ_NotLastC_NextTripPORC2C_Start(int j, int i, int idVeh, int idTrip, int &varvioCAP, double &varcost, double &varvioTWC, double &varvioTWSP)
//{
//	//see on 2/12/2013
//   double cStartS; 
//   if (SUBcal_InsertCusPIAfterJ_NotLastC1_Start(j, i, idVeh, idTrip, varvioCAP, varcost, varvioTWC, varvioTWSP, cStartS)== 0)
//   {
//       int nextT = idTrip + 1;
//       int firstC_nextT = seg[idVeh].Trip[nextT].firstCus;
//       GoThroughVehicle(idVeh, nextT, varcost, varvioTWC, varvioTWSP, cStartS, seg[idVeh].Trip[idTrip].assSP, firstC_nextT);
//   }
//}
//
//
//void Solution::cal_InsertCusPIAfterJ_NotLastC_NextTripD_SameSP(int j, int i, int idVeh, int idTrip, int &varvioCAP, double &varcost, double &varvioTWC, double &varvioTWSP)
//{
//	//See on 2/12/2013
//   double cStartS; 
//   double varvioTWSP1 = 0;
//   bool vioTWSPTRUE;
//   if (SUBcal_InsertCusPIAfterJ_NotLastC1(j, i, idVeh, idTrip, varvioCAP, varcost, varvioTWC, varvioTWSP1, cStartS, vioTWSPTRUE)== 0)
//   {
//		varvioTWSP +=  (varvioTWSP1 *2); //not calculated at SUBcal_InsertCusPIAfterJ_NotLastC1
//		int assSP = seg[idVeh].Trip[idTrip].assSP;
//		//Update 16/11/2013
//		if (vioTWSPTRUE) cStartS = problem->leaveSP[assSP][1];
//		else  cStartS += problem->nodeSP[assSP].load;
//	 
//		int nextT = idTrip + 1;
// 	    int firstC_nextT = seg[idVeh].Trip[nextT].firstCus;
//		GoThroughVehicle(idVeh, nextT, varcost, varvioTWC, varvioTWSP, cStartS, assSP, firstC_nextT);
//   }
//   else varvioTWSP +=  (varvioTWSP1 *2);
//}
//
//void Solution::cal_InsertCusPIAfterJ_NotLastC_NextTripD_SameSP_Start(int j, int i, int idVeh, int idTrip, int &varvioCAP, double &varcost, double &varvioTWC, double &varvioTWSP)
//{
//	//see on 2/12/2013
//   double cStartS; 
//   bool vioTWSPTRUE;
//   if (SUBcal_InsertCusPIAfterJ_NotLastC1_Start(j, i, idVeh, idTrip, varvioCAP, varcost, varvioTWC, varvioTWSP, cStartS, vioTWSPTRUE)== 0)
//   {
//		varvioTWSP *= 2; //not calculated at SUBcal_InsertCusPIAfterJ_NotLastC1
//		int assSP = seg[idVeh].Trip[idTrip].assSP;
//		//Update 16/11/2013
//		if (vioTWSPTRUE) cStartS = problem->leaveSP[assSP][1];
//		else cStartS += problem->nodeSP[assSP].load;
//	 
//		int nextT = idTrip + 1;
// 	    int firstC_nextT = seg[idVeh].Trip[nextT].firstCus;
//		GoThroughVehicle(idVeh, nextT, varcost, varvioTWC, varvioTWSP, cStartS, assSP, firstC_nextT);
//   }
//   else varvioTWSP *= 2;
//}
//
//void Solution::cal_InsertCusPIAfterJ_NotLastC_NextTripD_DifSP(int j, int i, int idVeh, int idTrip, int &varvioCAP, double &varcost, double &varvioTWC, double &varvioTWSP)
//{
//	//See 2/12/2013
//   double cStartS; 
//   double varvioTWSP1 = 0;
//
//   if (SUBcal_InsertCusPIAfterJ_NotLastC1(j, i, idVeh, idTrip, varvioCAP, varcost, varvioTWC, varvioTWSP1, cStartS)== 0)
//   {
//	    varvioTWSP += varvioTWSP1;
//		int nextT = idTrip + 1;
// 	    int firstC_nextT = seg[idVeh].Trip[nextT].firstCus;
//		if (calChangeCONNECTAtSP_SPSP(idVeh, nextT, idTrip, cStartS, varvioTWSP, varcost) == 0)
//			GoThroughVehicle(idVeh, nextT, varcost, varvioTWC, varvioTWSP, cStartS, seg[idVeh].Trip[nextT].assSP, firstC_nextT);
//   }
//   else varvioTWSP += varvioTWSP1;
//}
//
//
//void Solution::cal_InsertCusPIAfterJ_NotLastC_NextTripD_DifSP_Start(int j, int i, int idVeh, int idTrip, int &varvioCAP, double &varcost, double &varvioTWC, double &varvioTWSP)
//{
//	//see on 2/12/2013
//   double cStartS; 
//
//   if (SUBcal_InsertCusPIAfterJ_NotLastC1_Start(j, i, idVeh, idTrip, varvioCAP, varcost, varvioTWC, varvioTWSP, cStartS)== 0)
//   {
//		int nextT = idTrip + 1;
// 	    int firstC_nextT = seg[idVeh].Trip[nextT].firstCus;
//		if (calChangeCONNECTAtSP_SPSP(idVeh, nextT, idTrip, cStartS, varvioTWSP, varcost) == 0)
//			GoThroughVehicle(idVeh, nextT, varcost, varvioTWC, varvioTWSP, cStartS, seg[idVeh].Trip[nextT].assSP, firstC_nextT);
//   }
//}
//
//
//bool Solution::SUBcal_InsertCusC2CIAfterJ_2CusFirstTrip_nextD(int j, int i, int idVeh, int nextSP, int update_idTrip, double &varcost, double &varvioTWC, double &varvioTWSP, int &varvioCAP, int &insertAfter, double &cStartS)
//{
//	//8/12/2013: Insert C2CP i after cus C2C j of the first C2CTrip (idVeh,idTrip) where (idTrip+1) is DTrip
//	// (idVeh,0) has only 2 customers (1 order)
//	int cusP1 = seg[idVeh].Trip[0].firstCus;
//	int cusD1 = problem->node[cusP1].delID;
//	int cusDi = problem->node[i].delID;
//	double temp;
//
//	if (j == cusP1) // C2CTrip from (cusP1, cusD1) --> (cusP1 - i - delID of i - cusD1)
//	{
//		insertAfter = i; //insertC2CDAfter[j][k] = i;
//		varcost += (problem->c[cusP1][i] + problem->c[i][cusDi] + problem->c[cusDi][cusD1] - problem->c[cusP1][cusD1]);
//		cStartS = problem->node[cusP1].depart_depot + problem->c[cusP1][i];
//		temp = cStartS - problem->node[i].eTW;
//		if (temp > eps) 
//		{
//			varvioTWC += temp;
//			cStartS = problem->node[i].depart;
//		}
//		else
//			cStartS = PDS_MAX(cStartS, problem->node[i].sTW) + problem->node[i].duration;
//		int CapVehCus = problem->node[cusP1].capacity + problem->node[i].capacity;
//		int cQ = CapVehCus - Q;
//		if (cQ > 0) varvioCAP += cQ; //insertCus[j][k]->var_vioCAP = cQ;
//		//else insertCus[j][k]->var_vioCAP = 0;
//		//Now checking delID of i:
//		cStartS += problem->c[i][cusDi];
//		temp = cStartS - problem->node[cusDi].eTW;
//		if (temp > eps)
//		{
//			varvioTWC += temp;
//			cStartS = problem->node[cusDi].depart;
//		}
//		else cStartS = PDS_MAX(cStartS, problem->node[cusDi].sTW) + problem->node[cusDi].duration;
//		//Now Checking D1:
//		cStartS += problem->c[cusDi][cusD1];
//		temp = cStartS - problem->node[cusD1].eTW;
//		if (temp > eps)
//		{
//			varvioTWC += temp;
//			cStartS = problem->node[cusD1].depart;
//		}
//		else cStartS = PDS_MAX(cStartS, problem->node[cusD1].sTW) + problem->node[cusD1].duration;
//		//varvioTWC -= vioTWCus[cusD1]; don't need because first trip C2C has only 2 customers
//		//Now connect to nextSP: 
//		if (calChangeCONNECTAtSP_C2CTrip(cusD1,idVeh,0,1,cStartS,varvioTWSP,varcost) == 0){
//		//Quangnn+-
//			return 0;//GoThroughVehicle(idVeh,1, update_idTrip,varcost,varvioTWC,varvioTWSP,cStartS,nextSP,seg[idVeh].Trip[1].firstCus);
//		}
//		else return 1;
//	}
//	else  //j is cusD1: C2CTrip from (cusP1, cusD1) --> (cusP1 - cusD1 -  i - (delID of i))
//	{
//		insertAfter = i; //insertC2CDAfter[j][k] = i; 	insertCus[j][k]->var_vioCAP = 0;
//		varcost = (problem->c[cusD1][i] + problem->c[i][cusDi]);
//		cStartS = problem->node[cusP1].depart_depot + problem->c[cusP1][cusD1];
//		temp = cStartS - problem->node[cusD1].eTW;
//		if (temp > eps) 
//		{
//			varvioTWC += temp;
//			cStartS = problem->node[cusD1].depart;
//		}
//		else
//			cStartS = PDS_MAX(cStartS, problem->node[cusD1].sTW) + problem->node[cusD1].duration;
//		//Now Checking i:
//		cStartS += problem->c[cusD1][i];
//		temp = cStartS - problem->node[i].eTW;
//		if (temp > eps)
//		{
//			varvioTWC += temp;
//			cStartS = problem->node[i].depart;
//		}
//		else cStartS = PDS_MAX(cStartS, problem->node[i].sTW) + problem->node[i].duration;
//		//Now Checking CusDi:
//		cStartS += problem->c[i][cusDi];
//		temp = cStartS - problem->node[cusDi].eTW;
//		if (temp > eps)
//		{
//			varvioTWC += temp;
//			cStartS = problem->node[cusDi].depart;
//		}
//		else cStartS = PDS_MAX(cStartS, problem->node[cusDi].sTW) + problem->node[cusDi].duration;
//		//Now connect to nextSP: 
//		varcost -= seg[idVeh].Trip[0].connectCost;
//		/*if (seg[idVeh].Trip[0].waitingS == NO_WS) varcost -= problem->c[cusD1][nextSP];
//		else varcost -= problem->disCWSSP[cusD1][nextSP];*/
//		if (calChangeCONNECTAtSP_C2CTrip_LastCChanged(cusDi,idVeh,0,1,cStartS,varvioTWSP,varcost) == 0){
//		//Quangnn+-
//			return 0;//GoThroughVehicle(idVeh,1,update_idTrip,varcost,varvioTWC,varvioTWSP,cStartS,nextSP,seg[idVeh].Trip[1].firstCus);
//		}
//		else return 1;
//	}
//}
//
//void Solution::SUBcal_InsertCusC2CIAfterJ_LastC(double depart_j, int j, int i, int cusDi, int idVeh, int idTrip, double &varcost, double &varvioTWC, double &cStartS)
//{
//	//9/12/2013: j was the last cus of the trip, INSESRT (i and delID of i) after j
//	//-> don't need to calculate varvioCAP
//	double cArrTime = depart_j + problem->c[j][i];
//	double temp = cArrTime - problem->node[i].eTW;
//	if (temp > eps)
//	{
//		varvioTWC += temp;
//		cStartS = problem->node[i].depart;
//	}
//	else
//	{
//		cStartS = PDS_MAX(cArrTime, problem->node[i].sTW) + problem->node[i].duration;
//	}
//	//Checking cusDi:
//	cArrTime = cStartS + problem->c[i][cusDi];
//	temp = cArrTime - problem->node[cusDi].eTW;
//	if (temp > eps)
//	{
//		varvioTWC += temp;
//		cStartS = problem->node[i].depart;
//	}
//	else cStartS = PDS_MAX(cArrTime, problem->node[i].sTW) + problem->node[i].duration;
//	varcost += (problem->c[j][i] + problem->c[i][cusDi] - seg[idVeh].Trip[idTrip].connectCost);
//}
//
//void Solution::cal_InsertCusC2CIAfterJ_LastC_LastTrip(double depart_j, int j, int i, int idVeh, int idTrip, double &varcost, double &varvioTWC)
//{
//	//9/12/2013: j was the last cus of the trip, INSESRT (i and delID of i) after j
//	//-> don't need to calculate varvioCAP
//	int cusDi = problem->node[i].delID; double cStartS;
//    SUBcal_InsertCusC2CIAfterJ_LastC(depart_j, j, i,cusDi, idVeh, idTrip, varcost, varvioTWC,cStartS);
//	varcost += problem->c[cusDi][0];
//}
//
//void Solution::cal_InsertCusC2CIAfterJ_LastC_NextD(double depart_j,int j, int i, int idVeh, int idTrip, int nextSP, double &varcost, double &varvioTWC, double &varvioTWSP)
//{
//	//9/12/2013: j was the last cus of the trip, INSESRT (i and delID of i) after j; nextT is DTrip
//	//-> don't need to calculate varvioCAP
//	int cusDi = problem->node[i].delID; double cStartS;
//	SUBcal_InsertCusC2CIAfterJ_LastC(depart_j,j,i, cusDi, idVeh,idTrip,varcost,varvioTWC,cStartS);
//	int nextT = idTrip + 1;
//	if (calChangeCONNECTAtSP_C2CTrip_LastCChanged(cusDi,idVeh,idTrip,nextT,cStartS,varvioTWSP,varcost) == 0)
//		GoThroughVehicle(idVeh,nextT,varcost,varvioTWC,varvioTWSP,cStartS,nextSP,seg[idVeh].Trip[nextT].firstCus);
//}
//
//
//bool Solution::cal_InsertCusC2CIAfterJ_LastC_NextD_TillTrip(double depart_j, int j, int i, int idVeh, int idTrip, int nextSP, double &varcost, double &varvioTWC, double &varvioTWSP, double &cStartS, int numTrips_update)
//{
//	//11/12/2013: j was the last cus of the trip, INSESRT (i and delID of i) after j; nextT is DTrip
//	//-> don't need to calculate varvioCAP
//	//return 1 if cStartS has not been changed; 0 otherwise
//
//	int cusDi = problem->node[i].delID;
//	SUBcal_InsertCusC2CIAfterJ_LastC(depart_j,j,i, cusDi, idVeh,idTrip,varcost,varvioTWC,cStartS);
//
//	int nextT = idTrip + 1;
//	if (calChangeCONNECTAtSP_C2CTrip_LastCChanged(cusDi,idVeh,idTrip,nextT,cStartS,varvioTWSP,varcost) == 0){
//	//Quangnn+-
//		return 0;//GoThroughVehicle(idVeh,nextT,numTrips_update,varcost,varvioTWC,varvioTWSP,cStartS,nextSP,seg[idVeh].Trip[nextT].firstCus);
//	}
//	else return 1;
//}
//
//
//
//
//
//
//void Solution::cal_InsertCusC2CIAfterJ_LastC_NextTripPORC2C(double depart_j, int j, int i, int idVeh, int idTrip, double &varcost, double &varvioTWC, double &varvioTWSP)
//{
//    //9/12/2013: insert (i and delID of i) after j which is the last cus of C2C; nextT is C2C OR P
//	//-> don't need to calculate varvioCAP
//	int cusDi = problem->node[i].delID;
//	double cStartS;
//    SUBcal_InsertCusC2CIAfterJ_LastC(depart_j,j,i,cusDi,idVeh,idTrip,varcost,varvioTWC,cStartS);	
//   	
//	//Now connect to nextT which is C2C OR P trip
//	int nextT = idTrip + 1;
//	int firstC_nextT = seg[idVeh].Trip[nextT].firstCus;
//	varcost += problem->c[cusDi][firstC_nextT];
//	GoThroughVehicle(idVeh,nextT,varcost,varvioTWC,varvioTWSP,cStartS,cusDi, firstC_nextT);
//}
//
//
//bool Solution::cal_InsertCusC2CIAfterJ_LastC_NextTripPORC2C_TillTrip(double depart_j, int j, int i, int idVeh, int idTripj,double &varcost, double &varvioTWC, double &varvioTWSP, double &cStartS, int numTrips_update)
//{
//	//11/12/2013: insert (i and delID of i) after j which is the last cus of C2C; nextT is C2C OR P
//	//-> don't need to calculate varvioCAP
//	//return 1 if cStartS has not been changed; 0 otherwise
//
//	int cusDi = problem->node[i].delID;
//    SUBcal_InsertCusC2CIAfterJ_LastC(depart_j,j,i,cusDi,idVeh,idTripj,varcost,varvioTWC,cStartS);	
//   	
//	//Now connect to nextT which is C2C OR P trip
//	if (numTrips_update == 0) //it means nextTrip is C2C
//	{
//		//varcost ???
//		return 0;
//	}
//	else
//	{
//		int nextT = idTripj + 1;
//		int firstC_nextT = seg[idVeh].Trip[nextT].firstCus;
//		varcost += problem->c[cusDi][firstC_nextT];
//		//Quangnn+-
//		return 0;//GoThroughVehicle(idVeh,nextT,numTrips_update,varcost,varvioTWC,varvioTWSP,cStartS,cusDi, firstC_nextT);
//	}
//}
//
//
//void Solution::GoThroughLegC2C(int preC, int curC, int tillC, double &cStartS, int &CapVehCus, int &varvioCAP, double &varvioTWC, bool &contCAP, bool &contTW)
//{
//	//13/12/2013: Calculate from curC till tillC
//	int tQ;
//	double temp;
//	do {
//		if (contCAP)
//		{
//			CapVehCus += problem->node[curC].capacity;
//			tQ = CapVehCus - Q;
//			if (tQ > 0)
//			{
//				if (vioCAPCus[curC] > 0) 
//				{
//					CapVehCus = CAPCus[tillC];
//					varvioCAP += (tQ - vioCAPCus[curC]);
//					contCAP = 0;
//				}
//				else
//				{
//					varvioCAP += tQ;
//					CapVehCus = Q;
//				}
//			}else varvioCAP -= vioCAPCus[curC];
//		}
//		if (contTW)
//		{
//			cStartS += problem->c[preC][curC];
//			temp = cStartS - problem->node[curC].eTW;
//			if (temp > 0.000999999999999) 
//			{
//				if (vioTWCus[curC] > 0.000999999999999)
//				{
//					contTW = 0;
//					cStartS = depart[tillC];
//					varvioTWC += (temp - vioTWCus[curC]); 
//				}
//				else 
//				{
//					varvioTWC += temp; 
//					cStartS = problem->node[curC].depart;
//				}
//			}
//			else 
//			{
//				varvioTWC -= vioTWCus[curC];
//				cStartS = PDS_MAX(cStartS, problem->node[curC].sTW);
//				if (PDSDIF(cStartS, startS[curC]) == 0) 
//				{
//					contTW = 0;
//					cStartS = depart[tillC];
//				}
//				else cStartS += problem->node[curC].duration;
//			}
//		}
//		preC = curC; curC = nextArr[curC];
//	}while (preC != tillC && contTW && contCAP);
//	if (preC != tillC)
//	{
//		if (contTW)
//		{
//			do
//			{
//				cStartS += problem->c[preC][curC];
//				temp = cStartS - problem->node[curC].eTW;
//				if (temp > eps) 
//				{
//					if (vioTWCus[curC] > eps)
//					{
//						cStartS = depart[tillC];
//						contTW = 0;
//						varvioTWC += (temp - vioTWCus[curC]); 
//						return;
//					}
//					else 
//					{
//						varvioTWC += temp; 
//						cStartS = problem->node[curC].depart;
//					}
//				}
//				else
//				{
//					varvioTWC -= vioTWCus[curC];
//					cStartS = PDS_MAX(cStartS, problem->node[curC].sTW);
//					if (PDSDIF(cStartS, startS[curC]) == 0)
//					{
//						cStartS = depart[tillC];
//						contTW = 0;
//						return;
//					}
//					else cStartS += problem->node[curC].duration;
//				}
//				preC = curC; curC = nextArr[curC];
//			}while (preC != tillC);
//		}
//		else if (contCAP)
//		{
//			int next_tillC = nextArr[tillC];
//			//cout<<"tillC = "<<tillC<<"; next_tillC = "<<next_tillC<<"; ";
//			do
//			{
//				//cout<<curC<<";  ";
//				CapVehCus += problem->node[curC].capacity;
//				tQ = CapVehCus - Q;
//				if (tQ > 0)
//				{
//					if (vioCAPCus[curC] > 0) 
//					{
//						CapVehCus = CAPCus[tillC];
//						contCAP = 0;
//						varvioCAP += (tQ - vioCAPCus[curC]);
//						return;
//					}
//					else
//					{
//						varvioCAP += tQ;
//						CapVehCus = Q;
//					}
//				}
//				else varvioCAP -= vioCAPCus[curC];
//				curC = nextArr[curC];
//			}while (curC != next_tillC);
//		}
//	}//end if (preC != tillC)
//}
//
//void Solution::GoThroughLegC2C_CAP(int curC, int tillC, int &CapVehCus, int &varvioCAP)
//{
//	int preC; int tQ;
//	do
//	{
//			CapVehCus += problem->node[curC].capacity;
//			tQ = CapVehCus - Q;
//			if (tQ > 0)
//			{
//				if (vioCAPCus[curC] > 0) 
//				{
//					varvioCAP += (tQ - vioCAPCus[curC]);
//					break;
//				}
//				else
//				{
//					varvioCAP += tQ;
//					CapVehCus = Q;
//				}
//			}else varvioCAP -= vioCAPCus[curC];
//			preC = curC; curC = nextArr[curC];
//	}while (preC != tillC);
//}
//
//
//
//bool Solution::GoThroughLegC2C(int preC, int curC, double &cStartS, double &varvioTWC, int CapVehCus, int &varvioCAP)
//{
//	//9/12/2013: Go through TripC2C from curC till the end of the trip, calculate cStartS, varvioTWC
//	//return 1 if depart[lastC] doesn't change; 0 otherwise
//	//DONT CHECK vioCAP: 13/1/2014: NEED TO CHECK vioCAP huhu
//	double temp;
//	int curC1 = curC; int tQ;
//	do
//	{
//			CapVehCus += problem->node[curC1].capacity;
//			tQ = CapVehCus - Q;
//			if (tQ > 0)
//			{
//				if (vioCAPCus[curC1] > 0) 
//				{
//					varvioCAP += (tQ - vioCAPCus[curC1]);
//					break;
//				}
//				else
//				{
//					varvioCAP += tQ;
//					CapVehCus = Q;
//				}
//			}else varvioCAP -= vioCAPCus[curC1];
//			curC1 = nextArr[curC1];
//	}while (curC1 > 0);
//
//	do
//	{
//		cStartS += problem->c[preC][curC];
//		temp = cStartS - problem->node[curC].eTW;
//		if (temp > eps)
//		{
//			if (vioTWCus[curC] > eps)
//			{
//				varvioTWC += (temp - vioTWCus[curC]);
//				return 1;
//				break;
//			}
//			else
//			{
//				varvioTWC += temp;
//				cStartS = problem->node[curC].depart;
//			}
//		}
//		else
//		{
//			varvioTWC -= vioTWCus[curC];
//			cStartS = PDS_MAX(cStartS, problem->node[curC].sTW);
//			if (PDSDIF(cStartS, startS[curC]) == 0) return 1;
//			cStartS += problem->node[curC].duration;
//		}
//		preC = curC; curC = nextArr[curC];
//	}while (curC > 0);
//	if (PDSDIF(cStartS, depart[preC])) return 0;
//	else return 1;
//}
//
//
//void Solution::UpdateLegC2C_Cus(int preC, int curC, int tillC, int CapVehCus, double cStartS, bool firstC)
//{
//	/*Update all information needed for customers in the leg from curC... tillC: vioCAPCus,FvioCAPCus,CAPCus, pos
//	                                                                             vioTWCus,FvioTWCus*/
//	int tQ,FvioCAPCusT, posT, curCCAP_STOP = tillC;
//	double temp, FvioTWCusT;
//	//cout<<"UpdateLegC2C_Cus: preC = "<<preC<<"; curC = "<<curC<<"(veh = "<<route_num[curC]<<", trip = "<<trip_num[curC]<<"); tillC = "<<tillC<<" (veh = "<<route_num[tillC]<<", trip = "<<trip_num[tillC]<<"); firstC = "<<firstC<<endl;
//	if (firstC) //curC is firstCus
//	{
//		FvioCAPCusT = 0;
//		FvioTWCusT = 0;
//		posT = 0;
//	}
//	else
//	{
//		FvioCAPCusT = FCAP[preC];
//		/*FvioCAPCusT = FvioCAPCus[preC];*/
//		FvioTWCusT = FvioTWCus[preC];
//		posT = pos[preC];
//	}
//	
//	bool contCAP = 1, contTW = 1;
//	do
//	{
//		if (contCAP)
//		{
//			//cout<<"preC = "<<preC<<"(CAP = "<<CapVehCus<<"); curC = "<<curC<<"(CAP = ";
//			posT ++;
//			pos[curC] = posT; //cout<<"pos["<<curC<<"] = "<<pos[curC]<<"; ";
//			CapVehCus += problem->node[curC].capacity;
//			//cout<<CapVehCus<<")"<<endl;
//			tQ = CapVehCus - Q;
//			if (tQ > 0)
//			{
//				if (vioCAPCus[curC] > 0) 
//				{
//					//cout<<"before vio = "<<vioCAPCus[curC]<<"; nowvio = "<<tQ<<endl;
//					contCAP = 0; curCCAP_STOP = curC;
//					vioCAPCus[curC] = tQ;
//					FvioCAPCusT += tQ;
//					FCAP[curC] = FvioCAPCusT; //FvioCAPCus[curC] = FvioCAPCusT;
//					//dont need CAPCus
//					//Update FCAP till tillC:
//					if (curC != tillC)
//					{
//						int nextCC = nextArr[curC];
//						while (nextCC != tillC)
//						{
//							FvioCAPCusT += vioCAPCus[nextCC];
//							FCAP[nextCC] = FvioCAPCusT;
//							nextCC = nextArr[nextCC];
//						}
//						if (nextCC == tillC)
//						{
//							FvioCAPCusT += vioCAPCus[nextCC];
//							FCAP[nextCC] = FvioCAPCusT;
//						}
//					}
//				}
//				else //before not vioCAP, now vioCAP
//				{
//					vioCAPCus[curC] = tQ;
//					CAPCus[curC] = Q;
//					CapVehCus = Q;
//					FvioCAPCusT += tQ;
//					FCAP[curC] = FvioCAPCusT; //FvioCAPCus[curC] = FvioCAPCusT;
//					//cout<<"before NOTvio; nowvio = "<<tQ<<"; CAPVehCus = "<<CapVehCus<<endl;
//				}
//			}
//			else //now not vioCAP:
//			{
//				vioCAPCus[curC] = 0;
//				CAPCus[curC] = CapVehCus;
//				FCAP[curC] = FvioCAPCusT; //FvioCAPCus[curC] = FvioCAPCusT;
//				//cout<<"now not vioCAP; CapVehCus = "<<CapVehCus<<endl;
//			}
//		}
//		if (contTW)
//		{
//			//cout<<"preC = "<<preC<<"; curC = "<<curC<<endl;
//			cStartS += problem->c[preC][curC];
//			temp = cStartS - problem->node[curC].eTW;
//			if (temp > eps) 
//			{
//				if (vioTWCus[curC] > eps)
//				{
//					contTW = 0;
//					vioTWCus[curC] = temp; //startS,depart[curC] const
//					FvioTWCusT += temp;
//					FvioTWCus[curC] = FvioTWCusT;
//					//Update FvioTWCus till tillC:
//					if (curC != tillC)
//					{
//						int nextCC = nextArr[curC];
//						while (nextCC != tillC)
//						{
//							FvioTWCusT += vioTWCus[nextCC];
//							FvioTWCus[nextCC] = FvioTWCusT;
//							nextCC = nextArr[nextCC];
//						}
//						if (nextCC == tillC)
//						{
//							FvioTWCusT += vioTWCus[nextCC];
//							FvioTWCus[nextCC] = FvioTWCusT;
//						}
//					}
//				}
//				else //now vio; before not vio
//				{
//					vioTWCus[curC] = temp;
//					startS[curC] = problem->node[curC].eTW;
//					cStartS = problem->node[curC].depart;
//					depart[curC] = cStartS;
//					FvioTWCusT += temp;
//					FvioTWCus[curC] = FvioTWCusT;
//				}
//			}
//			else//now not vioTW 
//			{
//				vioTWCus[curC] = 0; FvioTWCus[curC] = FvioTWCusT;
//				cStartS = PDS_MAX(cStartS, problem->node[curC].sTW);
//				if (PDSDIF(cStartS, startS[curC]) == 0) //startS of curC const
//				{
//					contTW = 0;
//					//Update FvioTWCus till tillC:
//					if (curC != tillC)
//					{
//						int nextCC = nextArr[curC];
//						while (nextCC != tillC)
//						{
//							FvioTWCusT += vioTWCus[nextCC];
//							FvioTWCus[nextCC] = FvioTWCusT;
//							nextCC = nextArr[nextCC];
//						}
//						if (nextCC == tillC)
//						{
//							FvioTWCusT += vioTWCus[nextCC];
//							FvioTWCus[nextCC] = FvioTWCusT;
//						}
//					}
//
//				}
//				else
//				{
//					startS[curC] = cStartS;
//					cStartS += problem->node[curC].duration;
//					depart[curC] = cStartS;
//				}
//			}
//		}
//		preC = curC; curC = nextArr[curC];
//	}while (preC != tillC && contTW && contCAP);
//
//	//cout<<"contTW = "<<contTW<<"; contCAP = "<<contCAP<<"; preC = "<<preC<<"; tillC = "<<tillC<<endl;
//	if (preC != tillC)
//	{
//		if (contTW)
//		{
//			do
//			{
//				cStartS += problem->c[preC][curC];
//				temp = cStartS - problem->node[curC].eTW;
//				if (temp > eps) 
//				{
//					if (vioTWCus[curC] > eps)
//					{
//						vioTWCus[curC] = temp; //startS,depart[curC] const
//						FvioTWCusT += temp;
//						FvioTWCus[curC] = FvioTWCusT;
//						//Update FvioTWCus till tillC:
//						if (curC != tillC)
//						{
//							int nextCC = nextArr[curC];
//							while (nextCC != tillC)
//							{
//								FvioTWCusT += vioTWCus[nextCC];
//								FvioTWCus[nextCC] = FvioTWCusT;
//								nextCC = nextArr[nextCC];
//							}
//							if (nextCC == tillC)
//							{
//								FvioTWCusT += vioTWCus[nextCC];
//								FvioTWCus[nextCC] = FvioTWCusT;
//							}						
//						}
//						break;
//					}
//					else //now vio; before not vio
//					{
//						vioTWCus[curC] = temp;
//						startS[curC] = problem->node[curC].eTW;
//						cStartS = problem->node[curC].depart;
//						depart[curC] = cStartS;
//						FvioTWCusT += temp;
//						FvioTWCus[curC] = FvioTWCusT;
//					}
//				}
//				else//now not vioTW 
//				{
//					vioTWCus[curC] = 0; FvioTWCus[curC] = FvioTWCusT;
//					cStartS = PDS_MAX(cStartS, problem->node[curC].sTW);
//					if (PDSDIF(cStartS, startS[curC]) == 0) //startS of curC const
//					{
//						//Update FvioTWCus till tillC:
//						if (curC != tillC)
//						{
//							int nextCC = nextArr[curC];
//							while (nextCC != tillC)
//							{
//								FvioTWCusT += vioTWCus[nextCC];
//								FvioTWCus[nextCC] = FvioTWCusT;
//								nextCC = nextArr[nextCC];
//							}
//							if (nextCC == tillC)
//							{
//								FvioTWCusT += vioTWCus[nextCC];
//								FvioTWCus[nextCC] = FvioTWCusT;
//							}
//						}
//						break;
//					}
//					else
//					{
//						startS[curC] = cStartS;
//						cStartS += problem->node[curC].duration;
//						depart[curC] = cStartS;
//					}
//				}
//				preC = curC; curC = nextArr[curC];
//			}while (preC != tillC);
//		}
//		else if (contCAP)
//		{
//			//cout<<"contCAP = "<<contCAP<<endl;
//			do
//			{
//				posT ++; pos[curC] = posT;
//				//cout<<"..pos["<<curC<<"] = "<<pos[curC]<<"; ";
//				//cout<<"-- preC = "<<preC<<"(CAP = "<<CapVehCus<<"); curC = "<<curC<<"(CAP = ";
//				CapVehCus += problem->node[curC].capacity;
//				//cout<<CapVehCus<<")"<<endl;
//				tQ = CapVehCus - Q;
//				if (tQ > 0)
//				{
//					if (vioCAPCus[curC] > 0) 
//					{
//						vioCAPCus[curC] = tQ;
//						curCCAP_STOP = curC;
//						//dont need CAPCus
//						FvioCAPCusT += tQ;
//						FCAP[curC] = FvioCAPCusT;
//
//						//Update FCAP till tillC:
//						if (curC != tillC)
//						{
//							int nextCC = nextArr[curC];
//							while (nextCC != tillC)
//							{
//								FvioCAPCusT += vioCAPCus[nextCC];
//								FCAP[nextCC] = FvioCAPCusT;
//								nextCC = nextArr[nextCC];
//							}
//							if (nextCC == tillC)
//							{
//								FvioCAPCusT += vioCAPCus[nextCC];
//								FCAP[nextCC] = FvioCAPCusT;
//							}
//						}
//
//						break;
//					}
//					else //before not vioCAP, now vioCAP
//					{
//						vioCAPCus[curC] = tQ;
//						CAPCus[curC] = Q;
//						CapVehCus = Q;
//						FvioCAPCusT += tQ;
//						FCAP[curC] = FvioCAPCusT;
//					}
//					//FvioCAPCus[curC] = FvioCAPCusT;
//				}
//				else //now not vioCAP:
//				{
//					vioCAPCus[curC] = 0;
//					CAPCus[curC] = CapVehCus;
//					FCAP[curC] = FvioCAPCusT;
//					//FvioCAPCus[curC] = FvioCAPCusT;
//				}
//				preC = curC; curC = nextArr[curC];
//			}while (preC != tillC);
//		}//end if (contCAP)
//	}
//	if (curCCAP_STOP != tillC)
//	{
//		curC = nextArr[curCCAP_STOP];
//		while (curC != tillC)
//		{
//			posT++; pos[curC] = posT;
//			//cout<<"pos["<<curC<<"] = "<<pos[curC]<<"; ";
//			curC = nextArr[curC];
//		}
//		if (curC == tillC) 
//		{
//			pos[curC] = posT + 1;
//			//cout<<"pos[tillC= "<<tillC<<"] = "<<pos[curC];
//		}
//	}
//	//cout<<endl;
//}
//
//void Solution::UpdateLegC2C_Cus_Time(int preC, int curC, int tillC, int CapVehCus, double cStartS, bool firstC)
//{
//	/*Update all information related to Time for customers in the leg from curC... tillC:   vioTWCus,FvioTWCus*/
//	double temp, FvioTWCusT;
//	if (firstC) //curC is firstCus
//		 FvioTWCusT = 0;
//	else FvioTWCusT = FvioTWCus[preC];
//	
//	do
//	{
//		cStartS += problem->c[preC][curC];
//		temp = cStartS - problem->node[curC].eTW;
//		if (temp > eps) 
//		{
//			if (vioTWCus[curC] > eps)
//			{
//				vioTWCus[curC] = temp; //startS,depart[curC] const
//				FvioTWCusT += temp;
//				FvioTWCus[curC] = FvioTWCusT;
//				//Update FvioTWCus till tillC:
//				if (curC != tillC)
//				{
//					int nextCC = nextArr[curC];
//					while (nextCC != tillC)
//					{
//						FvioTWCusT += vioTWCus[nextCC];
//						FvioTWCus[nextCC] = FvioTWCusT;
//						nextCC = nextArr[nextCC];
//					}
//					if (nextCC == tillC)
//					{
//						FvioTWCusT += vioTWCus[nextCC];
//						FvioTWCus[nextCC] = FvioTWCusT;
//					}				
//				}
//				break;
//			}
//			else //now vio; before not vio
//			{
//				vioTWCus[curC] = temp;
//				startS[curC] = problem->node[curC].eTW;
//				cStartS = problem->node[curC].depart;
//				depart[curC] = cStartS;
//				FvioTWCusT += temp;
//				FvioTWCus[curC] = FvioTWCusT;
//			}
//		}
//		else//now not vioTW 
//		{
//			vioTWCus[curC] = 0; FvioTWCus[curC] = FvioTWCusT;
//			cStartS = PDS_MAX(cStartS, problem->node[curC].sTW);
//			if (PDSDIF(cStartS, startS[curC]) == 0) //startS of curC const
//			{
//				//Update FvioTWCus till tillC:
//				if (curC != tillC)
//				{
//					int nextCC = nextArr[curC];
//					while (nextCC != tillC)
//					{
//						FvioTWCusT += vioTWCus[nextCC];
//						FvioTWCus[nextCC] = FvioTWCusT;
//						nextCC = nextArr[nextCC];
//					}
//					if (nextCC == tillC)
//					{
//						FvioTWCusT += vioTWCus[nextCC];
//						FvioTWCus[nextCC] = FvioTWCusT;
//					}				
//				}
//				break;
//			}
//			else
//			{
//				startS[curC] = cStartS;
//				cStartS += problem->node[curC].duration;
//				depart[curC] = cStartS;
//			}
//		}
//		preC = curC; curC = nextArr[curC];
//	}while (preC != tillC);
//}
//
//
///*----------------------------------------------------------- 13/1/2014 ----------------------------------------------*/
//void Solution::SUBcal_InsertCusC2CIAfterJ_NotLastC_LastTrip(double depart_j, int CAPCusj, int j, int i, int idVeh, int idTrip, double &varcostMIN, double &varvioTWCMIN,  int &varvioCAPMIN, int &insertAfter)
//{
//	//9/12/2013: insert C2CP i after j; then find place to insert delID of i such that minimize obj fitness
//    //Same as cal_InsertCusC2CIAfterJ_NotLastC_NextTripPORC2C, cal_InsertCusC2CIAfterJ_NotLastC_nextD
//
//	int cusDi = problem->node[i].delID;
//	int nextj = nextArr[j];
//	int CapVehCusi = CAPCusj + problem->node[i].capacity;
//	int vioCapNEWi = 0; 
//	double vioTWCNEWi, temp, cStartS, obj, objMIN = PDS_INFINITY;
//    //Checking at i:
//	int tQ = CapVehCusi - Q;
//	if (tQ > 0) {vioCapNEWi = tQ; CapVehCusi = Q;}
//	double varcosti = problem->c[j][i] + problem->c[i][nextj] - problem->c[j][nextj];
//	double departi = depart_j + problem->c[j][i];
//	temp = departi - problem->node[i].eTW;
//	if (temp > eps)
//	{
//		vioTWCNEWi = temp;
//		departi = problem->node[i].depart;
//	}
//	else {vioTWCNEWi = 0; departi = PDS_MAX(departi, problem->node[i].sTW) + problem->node[i].duration;}
//  
//	//1. Insert CusDi right after i
//	int varvioCAP = vioCapNEWi; double varvioTWC = vioTWCNEWi;
//	int CapVehCus = CapVehCusi + problem->node[cusDi].capacity;
//	tQ = CapVehCus - Q;
//	if (tQ > 0) {varvioCAP += tQ; CapVehCus = Q;}
//	
//	cStartS = departi + problem->c[i][cusDi];
//	temp = cStartS - problem->node[cusDi].eTW;
//	if (temp > eps) {varvioTWC += temp; cStartS = problem->node[cusDi].depart;}
//	else cStartS = PDS_MAX(cStartS, problem->node[cusDi].sTW) + problem->node[cusDi].duration;
//    double varcost = varcosti + problem->c[i][cusDi] + problem->c[cusDi][nextj] - problem->c[i][nextj];
//	GoThroughLegC2C(cusDi,nextj,cStartS,varvioTWC,CapVehCus,varvioCAP);
//	obj = varcost + VCAP * varvioCAP + VTWCUS * varvioTWC;
//	if (obj < objMIN)
//	{
//		varcostMIN = varcost; varvioCAPMIN = varvioCAP; varvioTWCMIN = varvioTWC; 
//		objMIN = obj;
//		insertAfter = i;
//	}
//
//	//cout<<"-------------- ("<<idVeh<<", "<<idTrip<<") j = "<<j<<"; i = "<<i<<"----------------------------"<<endl;
//	//2. Find place to insert cusDi starting from position after nextj:
//	int posi = pos[j];
//	int nextC = nextj; 
//	int cal_tillC = i; int pos_cal_tillC = posi; int cal_startC = nextC; 
//	int varvioCAP_tillC = vioCapNEWi; double varvioTWC_tillC = vioTWCNEWi;
//	int CapVehCus_tillC = CapVehCusi; double cStartS_tillC = departi;
//	int pickID;
//	bool contCAP = 1; bool contTW = 1;
//	do
//	{
//		if (nextC < problem->startidC2CD) //nextC is C2CP
//			nextC = problem->node[nextC].delID; //jump to delID of nextC
//		else //nextC is C2CD
//		{
//			pickID = problem->node[nextC].pickID;
//			if (pos[pickID] > posi)
//			{
//				//Insert cusDi after nextC:
//				int nextC_T = nextArr[nextC];
//				if (pos_cal_tillC < pos[nextC]) //need to calculate vioTWC and vioCAP till nextC:
//				{
//					//Calculate from cal_startC to nextC after i already inserted into the trip after j:
//					if (contCAP == 0) {/*varvioCAP = varvioCAP_tillC;*/ CapVehCus_tillC = CAPCus[nextC];}
//					if (contTW == 0) {/*varvioTWC = varvioTWC_tillC;*/ cStartS_tillC = depart[nextC];}
//					GoThroughLegC2C(cal_tillC,cal_startC,nextC,cStartS_tillC,CapVehCus_tillC,varvioCAP_tillC,varvioTWC_tillC,contCAP,contTW);
//					cal_tillC = nextC; pos_cal_tillC = pos[nextC];
//					cal_startC = nextC_T;
//				}//end if (pos_cal_tillC < pos[nextC])
//				//Now insert cusDi after nextC:
//				if (nextC_T > 0) //insert cusDi after nextC which is not the last cus of the trip
//				{
//					cStartS = cStartS_tillC + problem->c[nextC][cusDi];
//					temp = cStartS - problem->node[cusDi].eTW;
//					//cout<<"("<<i<<", "<<cusDi<<", "<<j<<", "<<nextC<<", "<<idVeh<<", "<<idTrip<<"): cStartS_tillC = "<<cStartS_tillC<<"; cStartS = "<<cStartS<<"; eTW = "<<problem->node[cusDi].eTW<<endl;
//					if (temp > eps) {varvioTWC = varvioTWC_tillC + temp; cStartS = problem->node[cusDi].depart;}
//					else 
//					{
//						varvioTWC = varvioTWC_tillC;
//						cStartS = PDS_MAX(cStartS, problem->node[cusDi].sTW) + problem->node[cusDi].duration;
//					}
//					CapVehCus = CapVehCus_tillC + problem->node[cusDi].capacity;
//					tQ = CapVehCus - Q;
//					if (tQ > 0)
//					{
//						varvioCAP = varvioCAP_tillC + tQ; 
//						CapVehCus = Q;
//					}
//					else varvioCAP = varvioCAP_tillC;
//
//					varcost = varcosti + problem->c[nextC][cusDi] + problem->c[cusDi][nextC_T] - problem->c[nextC][nextC_T];
//					//Cal from cusDi till the end of the trip:
//                   	GoThroughLegC2C(cusDi,nextC_T,cStartS,varvioTWC,CapVehCus,varvioCAP);
//					obj = varcost + VCAP * varvioCAP + VTWCUS * varvioTWC;
//					if (obj < objMIN)
//					{
//						varcostMIN = varcost; varvioCAPMIN = varvioCAP; varvioTWCMIN = varvioTWC; 
//						objMIN = obj;
//						insertAfter = nextC;
//					}
//				}
//				else //insert cusDi at the end of the trip:
//				{
//					cStartS = cStartS_tillC + problem->c[nextC][cusDi];
//					temp = cStartS - problem->node[cusDi].eTW;
//					if (temp > eps) varvioTWC = varvioTWC_tillC + temp;
//					else varvioTWC = varvioTWC_tillC;
//					//don't need varvioCAP because insert cusDi at the end of the trip
//					varcost = varcosti + problem->c[nextC][cusDi] + problem->c[cusDi][0] - problem->c[nextC][0];
//					obj = varcost + VCAP * varvioCAP_tillC + VTWCUS * varvioTWC;
//					if (obj < objMIN)
//					{
//						varcostMIN = varcost; varvioCAPMIN = varvioCAP_tillC; varvioTWCMIN = varvioTWC; 
//						objMIN = obj;
//						insertAfter = nextC;
//					}
//					break; //finish the trip
//				}//end insert cusDi after nextC which is the last cus of the trip
//				nextC = nextC_T; //find another position to insert delID
//			}
//			else // (pos[pickID] <= posi)
//				break; //doesn't exist any place to insert cusDi anymore
//		}//end nextC is C2CD
//	}while (nextC > 0);
//}
//
//
//
//void Solution::SUBcal_InsertCusC2CIAfterJ_NotLastC_LastTrip_delIDIN(double depart_j, int CAPCusj, int j, int i, int idVeh, int idTrip, double &varcostMIN, double &varvioTWCMIN,  int &varvioCAPMIN, int &insertAfter)
//{
//	//12/12/2013: different from SUBcal_InsertCusC2CIAfterJ_NotLastC_LastTrip: 
//	//in this procedure cusDi belongs to the segment [j..lastC]; while in procedure SUBcal_InsertCusC2CIAfterJ_NotLastC_LastTrip, cusDi doesn't belong to this segment
//	//COPY SUBcal_InsertCusC2CIAfterJ_NotLastC_delIDIN_nextD, SUBcal_InsertCusC2CIAfterJ_NotLastC_iANDdelIDIN_NextTripPORC2C
//
//
//	int cusDi = problem->node[i].delID;
//	int posCusDi = pos[cusDi]; int pre_cusDi = predArr[cusDi]; int next_cusDi = nextArr[cusDi];
//	int nextj = nextArr[j];
//	int lastC = seg[idVeh].Trip[idTrip].lastCus;
//	int CapVehCusi = CAPCusj + problem->node[i].capacity;
//	int vioCapNEWi = 0; 
//	double vioTWCNEWi, temp, cStartS, obj, objMIN = PDS_INFINITY;
//    //Checking at i:
//	int tQ = CapVehCusi - Q;
//	if (tQ > 0) {vioCapNEWi = tQ; CapVehCusi = Q;}
//	double varcostii = problem->c[j][i] + problem->c[i][nextj] - problem->c[j][nextj];
//	//when calling this procedure for sure nexti != cusDi: cusDi is NOT direct successor of i
//	double varcosti;
//	if (next_cusDi > 0)
//		varcosti = varcostii + (problem->c[pre_cusDi][next_cusDi] - problem->c[pre_cusDi][cusDi] - problem->c[cusDi][next_cusDi]);
//	else
//		varcosti = varcostii + (problem->c[pre_cusDi][0] - problem->c[pre_cusDi][cusDi] - problem->c[cusDi][0]);
//
//	double departi = depart_j + problem->c[j][i];
//	temp = departi - problem->node[i].eTW;
//	if (temp > eps)
//	{
//		vioTWCNEWi = temp;
//		departi = problem->node[i].depart;
//	}
//	else {vioTWCNEWi = 0; departi = PDS_MAX(departi, problem->node[i].sTW) + problem->node[i].duration;}
//  
//	//1. Insert CusDi right after i
//	int varvioCAP = vioCapNEWi; double varvioTWC = vioTWCNEWi;
//	int CapVehCus = CapVehCusi + problem->node[cusDi].capacity;
//	tQ = CapVehCus - Q;
//	if (tQ > 0) {varvioCAP += tQ; CapVehCus = Q;}
//	
//	cStartS = departi + problem->c[i][cusDi];
//	temp = cStartS - problem->node[cusDi].eTW;
//	if (temp > eps) {varvioTWC += temp; cStartS = problem->node[cusDi].depart;}
//	else cStartS = PDS_MAX(cStartS, problem->node[cusDi].sTW) + problem->node[cusDi].duration;
//	double varcost;
//	int wherecusDi = 1;
//	bool contCAP, contTW, STOP = 0;
//
//	if (cusDi == nextj) //cusDi is already after i
//	{
//		varcost = varcostii;
//		nextj = nextArr[nextj];
//		if (nextj > 0) GoThroughLegC2C(cusDi,nextj, cStartS,varvioTWC,CapVehCus,varvioCAP); //fore sure nextj > 0
//		else STOP = 1; //cusDi is the last cus of the trip
//		wherecusDi = 0;
//	}
//	else
//	{
//		varcost = varcosti + problem->c[i][cusDi] + problem->c[cusDi][nextj] - problem->c[i][nextj];
//		//cusDi belongs to nextArr[nextj]...lastC:
//		contCAP = 1; contTW = 1;
//		GoThroughLegC2C(cusDi,nextj,pre_cusDi,cStartS,CapVehCus,varvioCAP,varvioTWC,contCAP,contTW);
//		if (next_cusDi > 0)
//		{
//		    contCAP = 1; contTW = 1;
//		    GoThroughLegC2C(pre_cusDi,next_cusDi,lastC,cStartS,CapVehCus,varvioCAP,varvioTWC,contCAP,contTW);
//		}
//	}
//
//	obj = varcost + VCAP * varvioCAP + VTWCUS * varvioTWC;
//	if (obj < objMIN)
//	{
//		varcostMIN = varcost; varvioCAPMIN = varvioCAP; varvioTWCMIN = varvioTWC; 
//		objMIN = obj;
//		insertAfter = i;
//	}
//
//	//2. Find place to insert cusDi starting from position after nextj: NOTE that cusDi may already exist somewhere else in the leg
//	if (STOP) return; //this case: Trip before move: [...i.....j,cusDi] where cusDi is the last cus of the trip --> don't exist any other place to insert cusDi
//
//	int posi = pos[j];
//	int nextC = nextj; 
//	int cal_tillC = i; int pos_cal_tillC = posi; int cal_startC = nextC; 
//	int varvioCAP_tillC = vioCapNEWi; double varvioTWC_tillC = vioTWCNEWi;
//	int CapVehCus_tillC = CapVehCusi; double cStartS_tillC = departi;
//	int pickID;
//	contCAP = 1; contTW = 1;
//	do
//	{
//		if (nextC < problem->startidC2CD) //nextC is C2CP
//			nextC = problem->node[nextC].delID; //jump to delID of nextC
//		else //nextC is C2CD
//		{
//				pickID = problem->node[nextC].pickID;
//			    if (i == pickID) //nextC is cusDi
//				{
//					//if it is here it means:  ...i(P+....P-=j)cusDi... --> ...(P+....P-)i cusDi...
//					//--?already calculate before in //1. Insert CusDi right after i
//					/*int preCT = predArr[nextC];
//					if (preCT != j)
//					{
//						cout<<"There is the case of C2Ctrip for moveCusC2C that I don't know it could happen: ";
//						showTripCus(idVeh,idTrip);
//						cout<<"Insert C2CP = "<<i<<" and its C2CD = "<<cusDi<<" after j = "<<j<<endl;
//						cout<<"It is now trying to insert C2CD("<<cusDi<<") after C2CD = "<<nextC<<endl;
//						exit(-1);
//					}*/
//					nextC = nextArr[nextC];
//					cal_startC = nextC;
//				}
//				else if (pos[pickID] > posi)
//				{
//					//Insert cusDi after nextC:
//					int nextC_T = nextArr[nextC];
//					if (wherecusDi != 0)
//					{
//						if (posCusDi < pos_cal_tillC) wherecusDi = 1;
//						else if (posCusDi > pos[nextC]) wherecusDi = 2;
//						else wherecusDi = 3;
//					}
//					if (pos_cal_tillC < pos[nextC]) //need to calculate vioTWC and vioCAP till nextC:
//					{
//						//Calculate from cal_startC to nextC after i already inserted into the trip after j:
//						if (wherecusDi < 3) //(posCusDi < pos_cal_tillC || posCusDi > pos[nextC])
//						{
//							if (contCAP == 0) {/*varvioCAP = varvioCAP_tillC;*/ CapVehCus_tillC = CAPCus[nextC];}
//							if (contTW == 0) {/*varvioTWC = varvioTWC_tillC;*/ cStartS_tillC = depart[nextC];}
//							GoThroughLegC2C(cal_tillC,cal_startC,nextC,cStartS_tillC,CapVehCus_tillC,varvioCAP_tillC,varvioTWC_tillC,contCAP,contTW);
//						}
//						else //cusDi belongs to cal_startC ... nextC
//						{
//							if (pre_cusDi == cal_tillC)
//							{
//								//...cal_tillC, cusDi, cal_startC.... nextC
//								GoThroughLegC2C(cal_tillC,cal_startC,nextC,cStartS_tillC,CapVehCus_tillC,varvioCAP_tillC,varvioTWC_tillC,contCAP,contTW);
//							}
//							else
//							{
//								if (contCAP == 0) {/*varvioCAP = varvioCAP_tillC;*/ CapVehCus_tillC = CAPCus[pre_cusDi]; contCAP = 1;}
//								if (contTW == 0) {/*varvioTWC = varvioTWC_tillC;*/ cStartS_tillC = depart[pre_cusDi]; contTW = 1;}
//								GoThroughLegC2C(cal_tillC,cal_startC,pre_cusDi,cStartS_tillC,CapVehCus_tillC,varvioCAP_tillC,varvioTWC_tillC,contCAP,contTW);
//								GoThroughLegC2C(pre_cusDi,next_cusDi,nextC,cStartS_tillC,CapVehCus_tillC,varvioCAP_tillC,varvioTWC_tillC,contCAP,contTW);
//							}
//						}//end cusDi belongs to start_tillC ... nextC
//						cal_tillC = nextC;	
//						pos_cal_tillC = pos[nextC];
//						cal_startC = nextC_T;
//					}//end if (pos_cal_tillC < pos[nextC])
//					//Now insert cusDi after nextC:
//					if (nextC_T > 0) //insert cusDi after nextC which is not the last cus of the trip
//					{
//						cStartS = cStartS_tillC + problem->c[nextC][cusDi];
//						temp = cStartS - problem->node[cusDi].eTW;
//						if (temp > eps) {varvioTWC = varvioTWC_tillC + temp; cStartS = problem->node[cusDi].depart;}
//						else 
//						{
//							varvioTWC = varvioTWC_tillC;
//							cStartS = PDS_MAX(cStartS, problem->node[cusDi].sTW) + problem->node[cusDi].duration;
//						}
//						CapVehCus = CapVehCus_tillC + problem->node[cusDi].capacity;
//						tQ = CapVehCus - Q;
//						if (tQ > 0)
//						{
//							varvioCAP = varvioCAP_tillC + tQ; 
//							CapVehCus = Q;
//						}
//						else varvioCAP = varvioCAP_tillC;
//
//						if (cusDi == nextC_T)
//						{
//						    if (next_cusDi > 0)
//								varcost = varcosti + problem->c[nextC][cusDi] + problem->c[cusDi][next_cusDi] - problem->c[nextC][next_cusDi];
//							else
//								varcost = varcosti + problem->c[nextC][cusDi] + seg[idVeh].Trip[idTrip].connectCost - problem->c[nextC][0];
//						}
//						else
//						   varcost = varcosti + problem->c[nextC][cusDi] + problem->c[cusDi][nextC_T] - problem->c[nextC][nextC_T];
//						//Cal from cusDi till the end of the trip:
//						if (wherecusDi == 2) //posCusDi > pos[nextC]: cusDi belongs to nextC_T ... lastcus
//						{
//							if (cusDi == nextC_T)
//							{
//								nextC_T = next_cusDi;
//							    cal_startC = nextC_T; contCAP = 1; contTW = 1; //pos_call_tillC++;
//								if (nextC_T > 0) GoThroughLegC2C(cusDi,nextC_T,cStartS,varvioTWC,CapVehCus,varvioCAP);
//							}
//							else //cusDi belongs to nextC_T+1 ... lastCus
//							{
//								//Cal from nextC_T ... predArr[cusDi]:
//								bool contCAP1 = 1; bool contTW1 = 1; 
//								GoThroughLegC2C(cusDi,nextC_T,pre_cusDi,cStartS,CapVehCus,varvioCAP,varvioTWC,contCAP1,contTW1);
//								//Cal from nextArr[cusDi] ... lastCus
//								if (next_cusDi > 0) GoThroughLegC2C(pre_cusDi,next_cusDi,cStartS,varvioTWC,CapVehCus,varvioCAP);
//								/*{
//									contCAP1 = 1; contTW1 = 1;
//									GoThroughLegC2C(pre_cusDi,next_cusDi,lastC,cStartS,CapVehCus,varvioCAP,varvioTWC,contCAP1,contTW1);
//								}*/
//							}
//						}
//						else //cusDi doesn't belong to the nextC
//               			   GoThroughLegC2C(cusDi,nextC_T,cStartS,varvioTWC,CapVehCus,varvioCAP);
//						obj = varcost + VCAP * varvioCAP + VTWCUS * varvioTWC;
//						if (obj < objMIN)
//						{
//							varcostMIN = varcost; varvioCAPMIN = varvioCAP; varvioTWCMIN = varvioTWC; 
//							objMIN = obj;
//							insertAfter = nextC;
//						}
//					}
//					else //insert cusDi at the end of the trip:
//					{
//						cStartS = cStartS_tillC + problem->c[nextC][cusDi];
//						temp = cStartS - problem->node[cusDi].eTW;
//						if (temp > eps) varvioTWC = varvioTWC_tillC + temp;
//						else varvioTWC = varvioTWC_tillC;
//						//don't need varvioCAP because insert cusDi at the end of the trip
//						varcost = varcosti + problem->c[nextC][cusDi] + problem->c[cusDi][0] - problem->c[nextC][0];
//						obj = varcost + VCAP * varvioCAP_tillC + VTWCUS * varvioTWC;
//						if (obj < objMIN)
//						{
//							varcostMIN = varcost; varvioCAPMIN = varvioCAP_tillC; varvioTWCMIN = varvioTWC; 
//							objMIN = obj;
//							insertAfter = nextC;
//						}
//						return; //finish the trip
//					}//end insert cusDi after nextC which is the last cus of the trip
//					nextC = nextC_T; //find another position to insert delID
//				}
//				else // (pos[pickID] <= posi)
//					return; //break; //doesn't exist any place to insert cusDi anymore
//		}//end nextC is C2CD
//	}while (nextC > 0);
//}
//
//void Solution::SUBcal_InsertCusC2CIAfterJ_NotLastC_LastTrip_iANDdelIDIN(double depart_j, int CAPCusj, int j, int i, int idVeh, int idTrip, double &varcostMIN, double &varvioTWCMIN,  int &varvioCAPMIN, int &insertAfter)
//{
//	//13/12/2013: different from SUBcal_InsertCusC2CIAfterJ_NotLastC_LastTrip: 
//	//in this procedure i and cusDi belongs to the segment [j..lastC]; while in procedure SUBcal_InsertCusC2CIAfterJ_NotLastC_LastTrip, they dont belong to this segment
//    //for sure: next[j] != i
//	//COPY SUBcal_InsertCusC2CIAfterJ_NotLastC_iANDdelIDIN_NextD, SUBcal_InsertCusC2CIAfterJ_NotLastC_iANDdelIDIN_NextTripPORD
//
//
//	int prei = predArr[i]; int nexti = nextArr[i];
//	int cusDi = problem->node[i].delID;
//	int posCusDi = pos[cusDi]; int pre_cusDi = predArr[cusDi]; int next_cusDi = nextArr[cusDi];
//	int nextj = nextArr[j];
//	int lastC = seg[idVeh].Trip[idTrip].lastCus;
//	int CapVehCusi = CAPCusj + problem->node[i].capacity;
//	int vioCapNEWi = 0; 
//	double vioTWCNEWi, temp, cStartS, obj, objMIN = PDS_INFINITY;
//    //Checking at i:
//	int tQ = CapVehCusi - Q;
//	if (tQ > 0) {vioCapNEWi = tQ; CapVehCusi = Q;}
//	double varcosti = problem->c[j][i] + problem->c[i][nextj] - problem->c[j][nextj];
//	double varBUC = varcosti;
//	if (nexti == cusDi)
//	{
//		if (next_cusDi > 0)
//			varcosti += (problem->c[prei][next_cusDi] - problem->c[prei][i] - problem->c[i][cusDi] - problem->c[cusDi][next_cusDi]);
//		else
//			varcosti += (problem->c[prei][0] - problem->c[prei][i] - problem->c[i][cusDi] - problem->c[cusDi][0]);
//	}
//	else
//	{
//		varcosti += (problem->c[prei][nexti] - problem->c[prei][i] - problem->c[i][nexti]);
//		if (next_cusDi > 0)
//			varcosti += (problem->c[pre_cusDi][next_cusDi] - problem->c[pre_cusDi][cusDi] - problem->c[cusDi][next_cusDi]);
//		else
//			varcosti += (problem->c[pre_cusDi][0] - problem->c[pre_cusDi][cusDi] - problem->c[cusDi][0]);
//	}
//
//	double departi = depart_j + problem->c[j][i];
//	temp = departi - problem->node[i].eTW;
//	if (temp > eps)
//	{
//		vioTWCNEWi = temp;
//		departi = problem->node[i].depart;
//	}
//	else {vioTWCNEWi = 0; departi = PDS_MAX(departi, problem->node[i].sTW) + problem->node[i].duration;}
//  
//	//1. Insert CusDi right after i
//	int varvioCAP = vioCapNEWi; double varvioTWC = vioTWCNEWi;
//	int CapVehCus = CapVehCusi + problem->node[cusDi].capacity;
//	tQ = CapVehCus - Q;
//	if (tQ > 0) {varvioCAP += tQ; CapVehCus = Q;}
//	
//	cStartS = departi + problem->c[i][cusDi];
//	temp = cStartS - problem->node[cusDi].eTW;
//	if (temp > eps) {varvioTWC += temp; cStartS = problem->node[cusDi].depart;}
//	else cStartS = PDS_MAX(cStartS, problem->node[cusDi].sTW) + problem->node[cusDi].duration;
//	double varcost;
//
//    varcost = varcosti + problem->c[i][cusDi] + problem->c[cusDi][nextj] - problem->c[i][nextj];
//	//i and cusDi belong to nextArr[nextj]...lastC:
//	bool contCAP = 1; bool contTW = 1;
//	GoThroughLegC2C(cusDi,nextj,prei,cStartS,CapVehCus,varvioCAP,varvioTWC,contCAP,contTW); //from nextj .. pre_i
//	contCAP = 1; contTW = 1;
//	if (nexti == cusDi)
//	{
//		if (next_cusDi > 0)
//			GoThroughLegC2C(prei,next_cusDi,cStartS,varvioTWC,CapVehCus,varvioCAP);
//	}
//	else
//	{
//		contCAP = 1; contTW = 1;
//		GoThroughLegC2C(prei,nexti,pre_cusDi,cStartS,CapVehCus,varvioCAP,varvioTWC,contCAP,contTW); //from prei,nexti...pre_CusDi
//		if (next_cusDi > 0)
//			GoThroughLegC2C(pre_cusDi,next_cusDi,cStartS,varvioTWC,CapVehCus,varvioCAP);
//	}
//
//	obj = varcost + VCAP * varvioCAP + VTWCUS * varvioTWC;
//	if (obj < objMIN)
//	{
//		varcostMIN = varcost; varvioCAPMIN = varvioCAP; varvioTWCMIN = varvioTWC; 
//		objMIN = obj;
//		insertAfter = i;
//		/*if (nexti == cusDi)
//		{
//			cout<<"("<<j<<", "<<i<<") = "<<problem->c[j][i]<<" + "<<problem->c[i][nextj]<<"- "<<problem->c[j][nextj]<<" ==?? =="<<varBUC;
//			if (next_cusDi > 0)
//			 cout<<"--> + "<<problem->c[prei][next_cusDi]<<" - "<<problem->c[prei][i]<<" - "<<problem->c[i][cusDi]<<" - "<<problem->c[cusDi][next_cusDi]<<"; ";
//			else
//			 cout<<"-? + "<<problem->c[prei][0]<<" - "<<problem->c[prei][i]<<" - "<<problem->c[i][cusDi]<<" - "<<problem->c[cusDi][0]<<" ; ";
//		    cout<<" == ?? == "<<varcosti<<"; ";
//			cout<<" + "<<problem->c[i][cusDi]<<" + "<<problem->c[cusDi][nextj]<<"- "<<problem->c[i][nextj]<<"; ";
//			varBUC = problem->c[j][i] + problem->c[cusDi][nextj] - problem->c[j][nextj] + problem->c[prei][next_cusDi] - problem->c[prei][i] - problem->c[cusDi][next_cusDi];
//			cout<<"--> RESULT = "<<varBUC<<" ?? == "<<varcost<<endl;		
//		}*/
//	}
//
//	//2. Find place to insert cusDi starting from position after nextj: NOTE that i and cusDi may already exist somewhere else in the leg
//	int posiOLD = pos[i];
//	int posi = pos[j];
//	int nextC = nextj; 
//	int cal_tillC = i; int pos_cal_tillC = posi; int cal_startC = nextC; 
//	int varvioCAP_tillC = vioCapNEWi; double varvioTWC_tillC = vioTWCNEWi;
//	int CapVehCus_tillC = CapVehCusi; double cStartS_tillC = departi;
//	int pickID;
//	contCAP = 1; contTW = 1;
//	bool contCAP1 = 1; bool contTW1 = 1;
//	do
//	{
//		if (nextC < problem->startidC2CD) //nextC is C2CP
//		{
//			if (nextC == i) {nextC = nextArr[i]; cal_startC = nextC;contCAP = 1; contTW = 1;}
//			else nextC = problem->node[nextC].delID; //jump to delID of nextC
//		}
//		else //nextC is C2CD
//		{
//			if (nextC == cusDi) {nextC = nextArr[cusDi];cal_startC = nextC; contCAP = 1; contTW = 1;}
//			else //nextC is not cusDi
//			{
//				pickID = problem->node[nextC].pickID;
// 				if (pos[pickID] > posi)
//				{
//					int nextC_T = nextArr[nextC];
//					if (pos[pickID] > posCusDi) //1) [iOLD...cusDiOLD]...[pickID...nextC]
//					{
//						//cout<<"Case 1: Insert "<<cusDi<<" after "<<nextC<<endl;
//
//						if (pos_cal_tillC < pos[nextC]) //need to calculate vioTWC and vioCAP till nextC:
//						{
//							//cout<<"Inside 1.1"<<endl;
//							//for sure [i..cusDi] < pos_cal_tillC ????
//							if (contCAP == 0) {/*varvioCAP = varvioCAP_tillC;*/ CapVehCus_tillC = CAPCus[nextC];}
//							if (contTW == 0) {/*varvioTWC = varvioTWC_tillC;*/ cStartS_tillC = depart[nextC];}
//							GoThroughLegC2C(cal_tillC,cal_startC,nextC,cStartS_tillC,CapVehCus_tillC,varvioCAP_tillC,varvioTWC_tillC,contCAP,contTW);
//							cal_tillC = nextC; pos_cal_tillC = pos[nextC];
//							cal_startC = nextC_T;
//						}
//						//insert cusDi after nextC
//						if (nextC_T > 0) //insert cusDi after nextC which is not the last cus
//						{
//							cStartS = cStartS_tillC + problem->c[nextC][cusDi];
//							temp = cStartS - problem->node[cusDi].eTW;
//							if (temp > eps) {varvioTWC = varvioTWC_tillC + temp; cStartS = problem->node[cusDi].depart;}
//							else 
//							{
//								varvioTWC = varvioTWC_tillC;
//								cStartS = PDS_MAX(cStartS, problem->node[cusDi].sTW) + problem->node[cusDi].duration;
//							}
//							CapVehCus = CapVehCus_tillC + problem->node[cusDi].capacity;
//							tQ = CapVehCus - Q;
//							if (tQ > 0)
//							{
//								varvioCAP = varvioCAP_tillC + tQ; 
//								CapVehCus = Q;
//							}
//							else varvioCAP = varvioCAP_tillC;
//							varcost = varcosti + problem->c[nextC][cusDi] + problem->c[cusDi][nextC_T] - problem->c[nextC][nextC_T];
//							//Cal from cusDi till the end of the trip: i and cusDi doesn't belong to this segment:
//                            GoThroughLegC2C(cusDi,nextC_T,cStartS,varvioTWC,CapVehCus,varvioCAP);
//							obj = varcost + VCAP * varvioCAP + VTWCUS * varvioTWC;
//							if (obj < objMIN)
//							{
//								varcostMIN = varcost; varvioCAPMIN = varvioCAP; varvioTWCMIN = varvioTWC; 
//								objMIN = obj;
//								insertAfter = nextC;
//							}
//						}
//						else //insert cusDi at the end of the trip:
//						{
//							cStartS = cStartS_tillC + problem->c[nextC][cusDi];
//							temp = cStartS - problem->node[cusDi].eTW;
//							if (temp > eps) varvioTWC = varvioTWC_tillC + temp;
//							else varvioTWC = varvioTWC_tillC;
//							//don't need varvioCAP because insert cusDi at the end of the trip
//							varcost = varcosti + problem->c[nextC][cusDi] + problem->c[cusDi][0] - problem->c[nextC][0];
//							obj = varcost + VCAP * varvioCAP_tillC + VTWCUS * varvioTWC;
//							if (obj < objMIN)
//							{
//								varcostMIN = varcost; varvioCAPMIN = varvioCAP_tillC; varvioTWCMIN = varvioTWC; 
//								objMIN = obj;
//								insertAfter = nextC;
//							}
//							return; //finish the trip
//						}//end insert cusDi at the end of the trip
//					}
//					else if (pos[nextC] < posi) //3)[pickID...nextC].... [i...cusDi]
//					{
//						//cout<<"Case 3: Insert "<<cusDi<<" after "<<nextC<<endl;
//						if (pos_cal_tillC < pos[nextC]) //need to calculate vioTWC and vioCAP till nextC:
//						{
//							//cout<<"Inside 3.1"<<endl;
//							//for sure [i..cusDi] < pos_cal_tillC ????
//							if (contCAP == 0) {/*varvioCAP = varvioCAP_tillC;*/ CapVehCus_tillC = CAPCus[nextC];}
//							if (contTW == 0) {/*varvioTWC = varvioTWC_tillC;*/ cStartS_tillC = depart[nextC];}
//							GoThroughLegC2C(cal_tillC,cal_startC,nextC,cStartS_tillC,CapVehCus_tillC,varvioCAP_tillC,varvioTWC_tillC,contCAP,contTW);
//							cal_tillC = nextC; pos_cal_tillC = pos[nextC];
//							cal_startC = nextC_T;
//						}
//						//insert cusDi after nextC: i and cusDi both belong to the segment nextC..lastC
//						cStartS = cStartS_tillC + problem->c[nextC][cusDi];
//						temp = cStartS - problem->node[cusDi].eTW;
//						if (temp > eps) {varvioTWC = varvioTWC_tillC + temp; cStartS = problem->node[cusDi].depart;}
//						else 
//						{
//							varvioTWC = varvioTWC_tillC;
//							cStartS = PDS_MAX(cStartS, problem->node[cusDi].sTW) + problem->node[cusDi].duration;
//						}
//						CapVehCus = CapVehCus_tillC + problem->node[cusDi].capacity;
//						tQ = CapVehCus - Q;
//						if (tQ > 0)
//						{
//							varvioCAP = varvioCAP_tillC + tQ; 
//							CapVehCus = Q;
//						}
//						else varvioCAP = varvioCAP_tillC;
//						if (nextC_T == i)
//						{
//							if (nexti == cusDi) 
//							{
//								nextC_T = next_cusDi;cal_startC = next_cusDi; contCAP = 1; contTW = 1;
//								if (next_cusDi > 0) 
//								{
//									varcost = varcosti + problem->c[nextC][cusDi] + problem->c[cusDi][next_cusDi] - problem->c[nextC][next_cusDi];
//									//Cal nextC_T till the end of the trip: i and cusDi doesn't belong to this segment
//									GoThroughLegC2C(cusDi,nextC_T,cStartS,varvioTWC,CapVehCus,varvioCAP);
//								}
//								else
//									varcost = varcosti + problem->c[nextC][cusDi] + problem->c[cusDi][0] - problem->c[nextC][0];
//							}
//							else //[pickID...nextC- i...cusDi]
//							{
//								nextC_T = nexti; cal_startC = nexti; contCAP = 1; contTW = 1;
//								varcost = varcosti + problem->c[nextC][cusDi] + problem->c[cusDi][nexti] - problem->c[nextC][nexti];
//								//from cusDi(after insertion)...pre_cusDi
//								contCAP1 = 1; contTW1 = 1;
//								GoThroughLegC2C(cusDi,nexti,pre_cusDi,cStartS,CapVehCus,varvioCAP,varvioTWC,contCAP1,contTW1);
//								if (next_cusDi > 0)
//								   GoThroughLegC2C(pre_cusDi,next_cusDi,cStartS,varvioTWC,CapVehCus,varvioCAP);
//							}
//						}
//						else //nextC_T != i: [pickID...nextC]....[i...cusDi]
//						{
//							varcost = varcosti + problem->c[nextC][cusDi] + problem->c[cusDi][nextC_T] - problem->c[nextC][nextC_T];
//							contCAP1 = 1; contTW1 = 1;
//							GoThroughLegC2C(cusDi,nextC_T,prei,cStartS,CapVehCus,varvioCAP,varvioTWC,contCAP1,contTW1);
//							if (nexti == cusDi)
//							{
//								if (next_cusDi > 0)
//								   GoThroughLegC2C(prei,next_cusDi,cStartS,varvioTWC,CapVehCus,varvioCAP);
//							}
//							else //nexti != cusDi: nextC_T != i: [pickID...nextC]....[i...cusDi]
//							{
//								contCAP1 = 1; contTW1 = 1;
//								GoThroughLegC2C(prei,nexti,pre_cusDi,cStartS,CapVehCus,varvioCAP,varvioTWC,contCAP1,contTW1);
//								if (next_cusDi > 0)
//									GoThroughLegC2C(pre_cusDi,next_cusDi,cStartS,varvioTWC,CapVehCus,varvioCAP);
//							}//end nexti != cusDi: nextC_T != i: [pickID...nextC]....[i...cusDi]
//						}//end nextC_T != i: [pickID...nextC]....[i...cusDi]
//						obj = varcost + VCAP * varvioCAP + VTWCUS * varvioTWC;
//						if (obj < objMIN)
//						{
//							varcostMIN = varcost; varvioCAPMIN = varvioCAP; varvioTWCMIN = varvioTWC; 
//							objMIN = obj;
//							insertAfter = nextC;
//						}
//					}
// 					else if (pos[nextC] > posCusDi) //4) before move: pickID....[i...cusDi]....nextC
//					{
//						//cout<<"Case 4: Insert "<<cusDi<<" after "<<nextC<<endl;
//						if (pos_cal_tillC < pos[nextC]) //need to calculate vioTWC and vioCAP till nextC:
//						{
//							//cout<<"Inside 4"<<endl;
//							//for sure [i..cusDi] < pos_cal_tillC ???? NO ANSWER ON 13/1/2014 e.g. j is the first cus: j,nextj=pickID,...,(i,cusDi),..nextC,...
//							if (contCAP == 0) {/*varvioCAP = varvioCAP_tillC;*/ CapVehCus_tillC = CAPCus[prei];}
//							if (contTW == 0) {/*varvioTWC = varvioTWC_tillC;*/ cStartS_tillC = depart[prei];}
//							GoThroughLegC2C(cal_tillC,cal_startC,prei,cStartS_tillC,CapVehCus_tillC,varvioCAP_tillC,varvioTWC_tillC,contCAP,contTW);
//							if (nexti == cusDi)
//							{
//								//if (contCAP == 0) CapVehCus_tillC = CAPCus[nextC];
//								//if (contTW == 0) cStartS_tillC = depart[nextC];
//								contCAP = 1; contTW = 1;
//								GoThroughLegC2C(prei,next_cusDi,nextC,cStartS_tillC, CapVehCus_tillC,varvioCAP_tillC,varvioTWC_tillC,contCAP,contTW);
//							}
//							else
//							{
//								//if (contCAP == 0) CapVehCus_tillC = CAPCus[nextC];
//								//if (contTW == 0) cStartS_tillC = depart[nextC];
//								contCAP1 = 1; contTW1 = 1;
//								GoThroughLegC2C(prei,nexti,pre_cusDi,cStartS_tillC,CapVehCus_tillC,varvioCAP_tillC,varvioTWC_tillC,contCAP1,contTW1);
//								contCAP = 1; contTW = 1;
//								GoThroughLegC2C(pre_cusDi,next_cusDi,nextC,cStartS_tillC,CapVehCus_tillC,varvioCAP_tillC,varvioTWC_tillC,contCAP,contTW);
//							}						
//							cal_tillC = nextC; pos_cal_tillC = pos[nextC];
//							cal_startC = nextC_T;
//						}
//						//insert cusDi after nextC:
//						if (nextC_T > 0) //insert cusDi after nextC which is not the last cus
//						{
//							cStartS = cStartS_tillC + problem->c[nextC][cusDi];
//							temp = cStartS - problem->node[cusDi].eTW;
//							if (temp > eps) {varvioTWC = varvioTWC_tillC + temp; cStartS = problem->node[cusDi].depart;}
//							else 
//							{
//								varvioTWC = varvioTWC_tillC;
//								cStartS = PDS_MAX(cStartS, problem->node[cusDi].sTW) + problem->node[cusDi].duration;
//							}
//							CapVehCus = CapVehCus_tillC + problem->node[cusDi].capacity;
//							tQ = CapVehCus - Q;
//							if (tQ > 0)
//							{
//								varvioCAP = varvioCAP_tillC + tQ; 
//								CapVehCus = Q;
//							}
//							else varvioCAP = varvioCAP_tillC;
//							varcost = varcosti + problem->c[nextC][cusDi] + problem->c[cusDi][nextC_T] - problem->c[nextC][nextC_T];
//							//Cal from cusDi till the end of the trip: i and cusDi doesn't belong to this segment:
//                            GoThroughLegC2C(cusDi,nextC_T,cStartS,varvioTWC,CapVehCus,varvioCAP);
//							obj = varcost + VCAP * varvioCAP + VTWCUS * varvioTWC;
//							if (obj < objMIN)
//							{
//								varcostMIN = varcost; varvioCAPMIN = varvioCAP; varvioTWCMIN = varvioTWC; 
//								objMIN = obj;
//								insertAfter = nextC;
//							}
//						}
//						else //insert cusDi at the end of the trip:
//						{
//							cStartS = cStartS_tillC + problem->c[nextC][cusDi];
//							temp = cStartS - problem->node[cusDi].eTW;
//							if (temp > eps) varvioTWC = varvioTWC_tillC + temp;
//							else varvioTWC = varvioTWC_tillC;
//							//don't need varvioCAP because insert cusDi at the end of the trip
//							varcost = varcosti + problem->c[nextC][cusDi] + problem->c[cusDi][0] - problem->c[nextC][0];
//							obj = varcost + VCAP * varvioCAP_tillC + VTWCUS * varvioTWC;
//							if (obj < objMIN)
//							{
//								varcostMIN = varcost; varvioCAPMIN = varvioCAP_tillC; varvioTWCMIN = varvioTWC; 
//								objMIN = obj;
//								insertAfter = nextC;
//							}
//							return; //finish the trip
//						}//end insert cusDi at the end of the trip
//					}
//					else //2) pos[nextC] belongs to [posi,poscusDi]: iNEW...pickID...nextC...cusDi 		BEFORE MOVE: ....nextC...i..cusDi... OR ....i...[pickID...nextC]...cusDi
//					{
//						//cout<<"Case 2: Insert "<<cusDi<<" after "<<nextC<<endl;
//						if (pos_cal_tillC < pos[nextC]) //need to calculate vioTWC and vioCAP till nextC:
//						{
//							//cout<<"Inside 2.1"<<endl;
//							//for sure [i..cusDi] < pos_cal_tillC ????
//							if (contCAP == 0) {/*varvioCAP = varvioCAP_tillC;*/ CapVehCus_tillC = CAPCus[nextC];}
//							if (contTW == 0) {/*varvioTWC = varvioTWC_tillC;*/ cStartS_tillC = depart[nextC];}
//							//for sure old place of i is not before nextC: 13/1/2014???
//							//cout<<"cal_tillC = "<<cal_tillC<<"; cal_startS = "<<cal_startC<<"; nextC = "<<nextC<<endl;
//
//							GoThroughLegC2C(cal_tillC,cal_startC,nextC,cStartS_tillC,CapVehCus_tillC,varvioCAP_tillC,varvioTWC_tillC,contCAP,contTW);
//							cal_tillC = nextC; pos_cal_tillC = pos[nextC];
//							cal_startC = nextC_T;
//						}
//						//insert cusDi after nextC: for sure nextC_T > 0
//						cStartS = cStartS_tillC + problem->c[nextC][cusDi];
//						temp = cStartS - problem->node[cusDi].eTW;
//						if (temp > eps) {varvioTWC = varvioTWC_tillC + temp; cStartS = problem->node[cusDi].depart;}
//						else 
//						{
//							varvioTWC = varvioTWC_tillC;
//							cStartS = PDS_MAX(cStartS, problem->node[cusDi].sTW) + problem->node[cusDi].duration;
//						}
//						CapVehCus = CapVehCus_tillC + problem->node[cusDi].capacity;
//						tQ = CapVehCus - Q;
//						if (tQ > 0)
//						{
//							varvioCAP = varvioCAP_tillC + tQ; 
//							CapVehCus = Q;
//						}
//						else varvioCAP = varvioCAP_tillC;
//						if (cusDi == nextC_T)
//						{
//							//e.g. ...j,[1+,(2+,2-),1-], i,[3+,(4+,4-)3-] cusDi,cusDj,.... where pickID = 4+; nextC = 3-; 
//							//cout<<"TRUONG HOP NAY XAY RA ?????????????????????????????????????????????? "<<endl;
//							//Cal from cusDi till the end of the trip: i and cusDi doesn't belong to this segment:
//							nextC_T = next_cusDi; cal_startC = nextC_T; contCAP = 1; contTW = 1;
//							if (nextC_T > 0)
//							{
//								varcost = varcosti + problem->c[nextC][cusDi] + problem->c[cusDi][next_cusDi] - problem->c[nextC][next_cusDi]; //cusDi is already after nextC
//                                GoThroughLegC2C(cusDi,nextC_T,cStartS,varvioTWC,CapVehCus,varvioCAP);	
//							}
//							else
//								varcost = varcosti + problem->c[nextC][cusDi] + problem->c[cusDi][0] - problem->c[nextC][0]; //cusDi is already after nextC
//						}
//						else //cusDi != nextC_T
//						{
//							varcost = varcosti + problem->c[nextC][cusDi] + problem->c[cusDi][nextC_T] - problem->c[nextC][nextC_T];
//						    //i...pickID...nextC...cusDi
//							//cusDi belongs to the segment nextC...lastC: cusDi != nextArr[nextC]
//							//Update 15/1/2014:
//							//BEFORE MOVE: ....nextC...i..cusDi... OR ....i...[pickID...nextC]...cusDi
//							if (posiOLD < pos[nextC]) //before move: ....i...[pickID...nextC]...cusDi
//							{
//								/*cout<<"j = "<<j<<"; i = "<<i<<"; cusDi = "<<cusDi<<"; pickID = "<<pickID<<"; nextC = "<<nextC<<endl;
//								cout<<"TRIP is : "; showTripCus(idVeh,idTrip);
//								exit(-1);*/
//								contCAP1 = 1; contTW1 = 1;
//								GoThroughLegC2C(cusDi,nextC_T,pre_cusDi,cStartS,CapVehCus,varvioCAP,varvioTWC,contCAP1,contTW1);
//								if (next_cusDi > 0)
//									GoThroughLegC2C(pre_cusDi,next_cusDi,cStartS,varvioTWC,CapVehCus,varvioCAP);
//								//else //pre_cusDi is now the last cus:
//							}
//							else //before move: ....nextC...i..cusDi...
//							{
//								//cout<<"cusDi = "<<cusDi<<"; nextC_T = "<<nextC_T<<"; prei = "<<prei<<endl;
//								if (nextC_T == i)
//								{
//									//...j....[pickID,...,nextID],[iOLD,......,cusDi]...
//									if (nexti == cusDi)
//									{
//										if (next_cusDi > 0) GoThroughLegC2C(cusDi,next_cusDi,cStartS,varvioTWC,CapVehCus,varvioCAP);
//									}
//									else
//									{
//										contCAP1 = 1; contTW1 = 1;
//										GoThroughLegC2C(cusDi,nexti,pre_cusDi,cStartS,CapVehCus,varvioCAP,varvioTWC,contCAP1,contTW1);
//										if (next_cusDi > 0)
//											GoThroughLegC2C(pre_cusDi,next_cusDi,cStartS,varvioTWC,CapVehCus,varvioCAP);
//									}
//								}
//								else //...j....[pickID,...,nextID],nextC_T,.....,[iOLD,......,cusDi]...
//								{
//									contCAP1 = 1; contTW1 = 1;
//									GoThroughLegC2C(cusDi,nextC_T,prei,cStartS,CapVehCus,varvioCAP,varvioTWC,contCAP1,contTW1);
//									//cout<<"prei = "<<prei<<"; nexti = "<<nexti<<"; pre_cusDi = "<<pre_cusDi<<endl;
//									if (nexti == cusDi)
//									{
//										if (next_cusDi > 0) GoThroughLegC2C(prei,next_cusDi,cStartS,varvioTWC,CapVehCus,varvioCAP);
//									}
//									else
//									{
//										contCAP1 = 1; contTW1 = 1;
//										GoThroughLegC2C(prei,nexti,pre_cusDi,cStartS,CapVehCus,varvioCAP,varvioTWC,contCAP1,contTW1);
//										//Cal from nextArr[cusDi] ... lastCus
//										if (next_cusDi > 0) GoThroughLegC2C(pre_cusDi,next_cusDi,cStartS,varvioTWC,CapVehCus,varvioCAP);
//									}
//								}
//
//							}
//						}
//						obj = varcost + VCAP * varvioCAP + VTWCUS * varvioTWC;
//						if (obj < objMIN)
//						{
//							varcostMIN = varcost; varvioCAPMIN = varvioCAP; varvioTWCMIN = varvioTWC; 
//							objMIN = obj;
//							insertAfter = nextC;
//						}
//					}//end 2) pos[nextC] belongs to [posi,poscusDi]: i...pickID...nextC...cusDi
//					nextC = nextC_T; //find another position to insert delID
//				}
//				else return; //pos[pickID] <= posi: doesn't exist any place to insert cusDi anymore
//			}//end nextC is not cusDi
//		}//end nextC is C2CD
//	}while (nextC > 0);
//}
//
//
//void Solution::SUBcal_InsertCusC2CIAfterJ_NotLastC_NextD(double depart_j, int CapCusj, int j, int i, int idVeh, int idTrip, int nextSP,double &varcostMIN, double &varvioTWCMIN, double &varvioTWSPMIN, int &varvioCAPMIN, int &insertAfter)
//{
//	//9/12/2013: insert C2CP i after j; then find place to insert delID of i such that minimize obj fitness: nextT is Dtrip
//    //Same as cal_InsertCusC2CIAfterJ_NotLastC_NextTripPORC2C, cal_InsertCusC2CIAfterJ_NotLastC_LastTrip
//    //return 1 if cStartS has not changed; 0 otherwise
//	//COPY SUBcal_InsertCusC2CIAfterJ_NotLastC_NextD_COPY
//
//	int cusDi = problem->node[i].delID;
//	int nextj = nextArr[j]; int nextT = idTrip + 1;
//	int lastC = seg[idVeh].Trip[idTrip].lastCus;
//	int CapVehCusi = CapCusj + problem->node[i].capacity;
//	int vioCapNEWi = 0; 
//	double vioTWCNEWi, temp, cStartS, obj, objMIN = PDS_INFINITY;
//    //Checking at i:
//	int tQ = CapVehCusi - Q;
//	if (tQ > 0) {vioCapNEWi = tQ; CapVehCusi = Q;}
//	double varcosti = problem->c[j][i] + problem->c[i][nextj] - problem->c[j][nextj];
//	double departi = depart_j + problem->c[j][i];
//	temp = departi - problem->node[i].eTW;
//	if (temp > eps)
//	{
//		vioTWCNEWi = temp;
//		departi = problem->node[i].depart;
//	}
//	else {vioTWCNEWi = 0; departi = PDS_MAX(departi, problem->node[i].sTW) + problem->node[i].duration;}
//  
//	//1. Insert CusDi right after i
//	int varvioCAP = vioCapNEWi; double varvioTWC = vioTWCNEWi; double varvioTWSP = 0;
//	int CapVehCus = CapVehCusi + problem->node[cusDi].capacity;
//	tQ = CapVehCus - Q;
//	if (tQ > 0) {varvioCAP += tQ; CapVehCus = Q;}
//	
//	cStartS = departi + problem->c[i][cusDi];
//	temp = cStartS - problem->node[cusDi].eTW;
//	if (temp > eps) {varvioTWC += temp; cStartS = problem->node[cusDi].depart;}
//	else cStartS = PDS_MAX(cStartS, problem->node[cusDi].sTW) + problem->node[cusDi].duration;
//    double varcost = varcosti + problem->c[i][cusDi] + problem->c[cusDi][nextj] - problem->c[i][nextj];
//	if (GoThroughLegC2C(cusDi,nextj,cStartS,varvioTWC,CapVehCus,varvioCAP) == 0) //depart[lastC of the trip] has changed 
//	{
//		if (calChangeCONNECTAtSP_C2CTrip(lastC,idVeh,idTrip,nextT,cStartS,varvioTWSP,varcost) == 0) //seg[idVeh].Trip[nextT].leaveSP has changed
//			GoThroughVehicle(idVeh,nextT,varcost,varvioTWC,varvioTWSP,cStartS,nextSP,seg[idVeh].Trip[nextT].firstCus);
//	}
//
//	obj = varcost + VCAP * varvioCAP + VTWCUS * varvioTWC + VTWSP * varvioTWSP;
//	if (obj < objMIN)
//	{
//		varcostMIN = varcost; varvioCAPMIN = varvioCAP; varvioTWCMIN = varvioTWC; varvioTWSPMIN = varvioTWSP;
//		objMIN = obj; 
//		insertAfter = i;
//	}
//
//	//2. Find place to insert cusDi starting from position after nextj:
//	int posi = pos[j];
//	int nextC = nextj; 
//	int cal_tillC = i; int pos_cal_tillC = posi; int cal_startC = nextC; 
//	int varvioCAP_tillC = vioCapNEWi; double varvioTWC_tillC = vioTWCNEWi;
//	int CapVehCus_tillC = CapVehCusi; double cStartS_tillC = departi;
//	int pickID;
//	bool contCAP = 1; bool contTW = 1;
//	do
//	{
//		if (nextC < problem->startidC2CD) //nextC is C2CP
//			nextC = problem->node[nextC].delID; //jump to delID of nextC
//		else //nextC is C2CD
//		{
//			pickID = problem->node[nextC].pickID;
//			if (pos[pickID] > posi)
//			{
//				//Insert cusDi after nextC:
//				int nextC_T = nextArr[nextC]; varvioTWSP = 0;
//				if (pos_cal_tillC < pos[nextC]) //need to calculate vioTWC and vioCAP till nextC:
//				{
//					//Calculate from cal_startC to nextC after i already inserted into the trip after j:
//					if (contCAP == 0) {/*varvioCAP = varvioCAP_tillC;*/ CapVehCus_tillC = CAPCus[nextC];}
//					if (contTW == 0) {/*varvioTWC = varvioTWC_tillC;*/ cStartS_tillC = depart[nextC];}
//					GoThroughLegC2C(cal_tillC,cal_startC,nextC,cStartS_tillC,CapVehCus_tillC,varvioCAP_tillC,varvioTWC_tillC,contCAP,contTW);
//					cal_tillC = nextC; pos_cal_tillC = pos[nextC];
//					cal_startC = nextC_T;
//				}//end if (pos_cal_tillC < pos[nextC])
//				//Now insert cusDi after nextC:
//				if (nextC_T > 0) //insert cusDi after nextC which is not the last cus of the trip
//				{
//					cStartS = cStartS_tillC + problem->c[nextC][cusDi];
//					temp = cStartS - problem->node[cusDi].eTW;
//					if (temp > eps) {varvioTWC = varvioTWC_tillC + temp; cStartS = problem->node[cusDi].depart;}
//					else 
//					{
//						varvioTWC = varvioTWC_tillC;
//						cStartS = PDS_MAX(cStartS, problem->node[cusDi].sTW) + problem->node[cusDi].duration;
//					}
//					CapVehCus = CapVehCus_tillC + problem->node[cusDi].capacity;
//					tQ = CapVehCus - Q;
//					if (tQ > 0)
//					{
//						varvioCAP = varvioCAP_tillC + tQ; 
//						CapVehCus = Q;
//					}
//					else varvioCAP = varvioCAP_tillC;
//
//					varcost = varcosti + problem->c[nextC][cusDi] + problem->c[cusDi][nextC_T] - problem->c[nextC][nextC_T];
//					//Cal from cusDi till the end of the trip:
//					if (GoThroughLegC2C(cusDi,nextC_T,cStartS,varvioTWC,CapVehCus,varvioCAP) == 0) //depart[lastC of the trip] has changed 
//					{
//						if (calChangeCONNECTAtSP_C2CTrip(lastC,idVeh,idTrip,nextT,cStartS,varvioTWSP,varcost) == 0) //seg[idVeh].Trip[nextT].leaveSP has changed
//							GoThroughVehicle(idVeh,nextT,varcost,varvioTWC,varvioTWSP,cStartS,nextSP,seg[idVeh].Trip[nextT].firstCus);
//					}
//					obj = varcost + VCAP * varvioCAP + VTWCUS * varvioTWC + VTWSP * varvioTWSP;
//					if (obj < objMIN)
//					{
//						varcostMIN = varcost; varvioCAPMIN = varvioCAP; varvioTWCMIN = varvioTWC; varvioTWSPMIN = varvioTWSP; 
//						objMIN = obj; 
//						insertAfter = nextC;
//					}
//				}
//				else //insert cusDi at the end of the trip:
//				{
//					cStartS = cStartS_tillC + problem->c[nextC][cusDi];
//					temp = cStartS - problem->node[cusDi].eTW;
//					if (temp > eps) varvioTWC = varvioTWC_tillC + temp;
//					else varvioTWC = varvioTWC_tillC;
//					//don't need varvioCAP because insert cusDi at the end of the trip
//					varcost = varcosti + problem->c[nextC][cusDi] + problem->c[cusDi][0] - problem->c[nextC][0];
//                    /*if (seg[idVeh].Trip[idTrip].waitingS == NO_WS) varcost -= problem->c[lastC][nextSP];
//					else varcost -= problem->disCWSSP[lastC][nextSP];*/
//					varcost -= seg[idVeh].Trip[idTrip].connectCost;
//					if (calChangeCONNECTAtSP_C2CTrip_LastCChanged(cusDi,idVeh,idTrip,nextT,cStartS,varvioTWSP,varcost)== 0) //seg[idVeh].Trip[nextT].leaveSP has changed
//						GoThroughVehicle(idVeh,nextT,varcost,varvioTWC,varvioTWSP,cStartS,nextSP,seg[idVeh].Trip[nextT].firstCus);
//					obj = varcost + VCAP * varvioCAP_tillC + VTWCUS * varvioTWC + VTWSP * varvioTWSP;
//					if (obj < objMIN)
//					{
//						varcostMIN = varcost; varvioCAPMIN = varvioCAP_tillC; varvioTWCMIN = varvioTWC; varvioTWSPMIN = varvioTWSP; 
//						objMIN = obj; 
//						insertAfter = nextC;
//					}
//					break; //finish the trip
//				}//end insert cusDi after nextC which is the last cus of the trip
//				nextC = nextC_T; //find another position to insert delID
//			}
//			else // (pos[pickID] <= posi)
//				break; //doesn't exist any place to insert cusDi anymore
//		}//end nextC is C2CD
//	}while (nextC > 0);
//}
//
//void Solution::SUBcal_InsertCusC2CIAfterJ_NotLastC_NextD_COPY(double depart_j, int CAPCusj, int j, int i, int idVeh, int idTrip, int nextSP,double &varcostMIN, double &varvioTWCMIN, double &varvioTWSPMIN, int &varvioCAPMIN, bool &stopMIN, double &cStartS, int &insertAfter, int update_idTrip)
//{
//	//15/12/2013: insert C2CP i after j; then find place to insert delID of i such that minimize obj fitness: nextT is Dtrip
//    //Same as cal_InsertCusC2CIAfterJ_NotLastC_NextTripPORC2C, cal_InsertCusC2CIAfterJ_NotLastC_LastTrip
//    //return 1 if cStartS has not changed; 0 otherwise
//	//COPY SUBcal_InsertCusC2CIAfterJ_NotLastC_NextD
//
//	bool stop;
//	int numTrips_update = update_idTrip - idTrip;
//	int cusDi = problem->node[i].delID;
//	int nextj = nextArr[j]; int nextT = idTrip + 1;
//	int lastC = seg[idVeh].Trip[idTrip].lastCus;
//	int CapVehCusi = CAPCusj + problem->node[i].capacity;
//	int vioCapNEWi = 0; 
//	double vioTWCNEWi, temp, obj, objMIN = PDS_INFINITY;
//    //Checking at i:
//	int tQ = CapVehCusi - Q;
//	if (tQ > 0) {vioCapNEWi = tQ; CapVehCusi = Q;}
//	double varcosti = problem->c[j][i] + problem->c[i][nextj] - problem->c[j][nextj];
//	double departi = depart_j + problem->c[j][i];
//	temp = departi - problem->node[i].eTW;
//	if (temp > eps)
//	{
//		vioTWCNEWi = temp;
//		departi = problem->node[i].depart;
//	}
//	else {vioTWCNEWi = 0; departi = PDS_MAX(departi, problem->node[i].sTW) + problem->node[i].duration;}
//  
//	//1. Insert CusDi right after i
//	int varvioCAP = vioCapNEWi; double varvioTWC = vioTWCNEWi; double varvioTWSP = 0;
//	int CapVehCus = CapVehCusi + problem->node[cusDi].capacity;
//	tQ = CapVehCus - Q;
//	if (tQ > 0) {varvioCAP += tQ; CapVehCus = Q;}
//	
//	cStartS = departi + problem->c[i][cusDi];
//	temp = cStartS - problem->node[cusDi].eTW;
//	if (temp > eps) {varvioTWC += temp; cStartS = problem->node[cusDi].depart;}
//	else cStartS = PDS_MAX(cStartS, problem->node[cusDi].sTW) + problem->node[cusDi].duration;
//    double varcost = varcosti + problem->c[i][cusDi] + problem->c[cusDi][nextj] - problem->c[i][nextj];
//	stop = 1;
//	if (GoThroughLegC2C(cusDi,nextj,cStartS,varvioTWC,CapVehCus,varvioCAP) == 0) //depart[lastC of the trip] has changed 
//	{
//		if (calChangeCONNECTAtSP_C2CTrip(lastC,idVeh,idTrip,nextT,cStartS,varvioTWSP,varcost) == 0){ //seg[idVeh].Trip[nextT].leaveSP has changed
//		//Quangnn--
//			//stop = GoThroughVehicle(idVeh,nextT,numTrips_update,varcost,varvioTWC,varvioTWSP,cStartS,nextSP,seg[idVeh].Trip[nextT].firstCus);
//		}
//	}
//
//	obj = varcost + VCAP * varvioCAP + VTWCUS * varvioTWC + VTWSP * varvioTWSP;
//	if (obj < objMIN)
//	{
//		varcostMIN = varcost; varvioCAPMIN = varvioCAP; varvioTWCMIN = varvioTWC; varvioTWSPMIN = varvioTWSP;
//		objMIN = obj; stopMIN = stop;
//		insertAfter = i;
//	}
//
//	//2. Find place to insert cusDi starting from position after nextj:
//	int posi = pos[j];
//	int nextC = nextj; 
//	int cal_tillC = i; int pos_cal_tillC = posi; int cal_startC = nextC; 
//	int varvioCAP_tillC = vioCapNEWi; double varvioTWC_tillC = vioTWCNEWi;
//	int CapVehCus_tillC = CapVehCusi; double cStartS_tillC = departi;
//	int pickID;
//	bool contCAP = 1; bool contTW = 1;
//	do
//	{
//		if (nextC < problem->startidC2CD) //nextC is C2CP
//			nextC = problem->node[nextC].delID; //jump to delID of nextC
//		else //nextC is C2CD
//		{
//			pickID = problem->node[nextC].pickID;
//			if (pos[pickID] > posi)
//			{
//				//Insert cusDi after nextC:
//				int nextC_T = nextArr[nextC]; varvioTWSP = 0;
//				if (pos_cal_tillC < pos[nextC]) //need to calculate vioTWC and vioCAP till nextC:
//				{
//					//Calculate from cal_startC to nextC after i already inserted into the trip after j:
//					if (contCAP == 0) {/*varvioCAP = varvioCAP_tillC;*/ CapVehCus_tillC = CAPCus[nextC];}
//					if (contTW == 0) {/*varvioTWC = varvioTWC_tillC;*/ cStartS_tillC = depart[nextC];}
//					GoThroughLegC2C(cal_tillC,cal_startC,nextC,cStartS_tillC,CapVehCus_tillC,varvioCAP_tillC,varvioTWC_tillC,contCAP,contTW);
//					cal_tillC = nextC; pos_cal_tillC = pos[nextC];
//					cal_startC = nextC_T;
//				}//end if (pos_cal_tillC < pos[nextC])
//				//Now insert cusDi after nextC:
//				if (nextC_T > 0) //insert cusDi after nextC which is not the last cus of the trip
//				{
//					cStartS = cStartS_tillC + problem->c[nextC][cusDi];
//					temp = cStartS - problem->node[cusDi].eTW;
//					if (temp > eps) {varvioTWC = varvioTWC_tillC + temp; cStartS = problem->node[cusDi].depart;}
//					else 
//					{
//						varvioTWC = varvioTWC_tillC;
//						cStartS = PDS_MAX(cStartS, problem->node[cusDi].sTW) + problem->node[cusDi].duration;
//					}
//					CapVehCus = CapVehCus_tillC + problem->node[cusDi].capacity;
//					tQ = CapVehCus - Q;
//					if (tQ > 0)
//					{
//						varvioCAP = varvioCAP_tillC + tQ; 
//						CapVehCus = Q;
//					}
//					else varvioCAP = varvioCAP_tillC;
//
//					varcost = varcosti + problem->c[nextC][cusDi] + problem->c[cusDi][nextC_T] - problem->c[nextC][nextC_T];
//					//Cal from cusDi till the end of the trip:
//					stop = 1;
//					if (GoThroughLegC2C(cusDi,nextC_T,cStartS,varvioTWC,CapVehCus,varvioCAP) == 0) //depart[lastC of the trip] has changed 
//					{
//						if (calChangeCONNECTAtSP_C2CTrip(lastC,idVeh,idTrip,nextT,cStartS,varvioTWSP,varcost) == 0){ //seg[idVeh].Trip[nextT].leaveSP has changed
//							//Quangnn+-
//							//stop = GoThroughVehicle(idVeh,nextT,numTrips_update,varcost,varvioTWC,varvioTWSP,cStartS,nextSP,seg[idVeh].Trip[nextT].firstCus);
//						}
//					}
//					obj = varcost + VCAP * varvioCAP + VTWCUS * varvioTWC + VTWSP * varvioTWSP;
//					if (obj < objMIN)
//					{
//						varcostMIN = varcost; varvioCAPMIN = varvioCAP; varvioTWCMIN = varvioTWC; varvioTWSPMIN = varvioTWSP; 
//						objMIN = obj; stopMIN = stop;
//						insertAfter = nextC;
//					}
//				}
//				else //insert cusDi at the end of the trip:
//				{
//					cStartS = cStartS_tillC + problem->c[nextC][cusDi];
//					temp = cStartS - problem->node[cusDi].eTW;
//					if (temp > eps) varvioTWC = varvioTWC_tillC + temp;
//					else varvioTWC = varvioTWC_tillC;
//					//don't need varvioCAP because insert cusDi at the end of the trip
//					varcost = varcosti + problem->c[nextC][cusDi] + problem->c[cusDi][0] - problem->c[nextC][0];
//                    /*if (seg[idVeh].Trip[idTrip].waitingS == NO_WS) varcost -= problem->c[lastC][nextSP];
//					else varcost -= problem->disCWSSP[lastC][nextSP];*/
//					varcost -= seg[idVeh].Trip[idTrip].connectCost;
//					stop = 1;
//					if (calChangeCONNECTAtSP_C2CTrip_LastCChanged(cusDi,idVeh,idTrip,nextT,cStartS,varvioTWSP,varcost)== 0){ //seg[idVeh].Trip[nextT].leaveSP has changed
//						//Quangnn+-
//						//stop = GoThroughVehicle(idVeh,nextT,numTrips_update,varcost,varvioTWC,varvioTWSP,cStartS,nextSP,seg[idVeh].Trip[nextT].firstCus);
//					}
//					obj = varcost + VCAP * varvioCAP_tillC + VTWCUS * varvioTWC + VTWSP * varvioTWSP;
//					if (obj < objMIN)
//					{
//						varcostMIN = varcost; varvioCAPMIN = varvioCAP_tillC; varvioTWCMIN = varvioTWC; varvioTWSPMIN = varvioTWSP; 
//						objMIN = obj; stopMIN = stop;
//						insertAfter = nextC;
//					}
//					break; //finish the trip
//				}//end insert cusDi after nextC which is the last cus of the trip
//				nextC = nextC_T; //find another position to insert delID
//			}
//			else // (pos[pickID] <= posi)
//				break; //doesn't exist any place to insert cusDi anymore
//		}//end nextC is C2CD
//	}while (nextC > 0);
//}
//
//
//
//
//
//void Solution::SUBcal_InsertCusC2CIAfterJ_NotLastC_delIDIN_nextD(double depart_j, int CAPCusj, int j, int i, int idVeh, int idTrip, int nextSP, double &varcostMIN, double &varvioTWCMIN, double &varvioTWSPMIN,  int &varvioCAPMIN, int &insertAfter)
//{
//	//COPY SUBcal_InsertCusC2CIAfterJ_NotLastC_LastTrip_delIDIN, SUBcal_InsertCusC2CIAfterJ_NotLastC_iANDdelIDIN_NextTripPORC2C
//	//15/12/2013: different from SUBcal_InsertCusC2CIAfterJ_NotLastC_nextD: 
//	//in this procedure cusDi belongs to the segment [j..lastC]; while in procedure SUBcal_InsertCusC2CIAfterJ_NotLastC_nextD, cusDi doesn't belong to this segment
//	int cusDi = problem->node[i].delID;
//	int posCusDi = pos[cusDi]; int pre_cusDi = predArr[cusDi]; int next_cusDi = nextArr[cusDi];
//	int nextj = nextArr[j]; int nextT = idTrip + 1;
//	int lastC = seg[idVeh].Trip[idTrip].lastCus;
//	int CapVehCusi = CAPCusj + problem->node[i].capacity;
//	int vioCapNEWi = 0; 
//	double vioTWCNEWi, temp, cStartS, obj;
//	double objMIN = PDS_INFINITY;
//    //Checking at i:
//	int tQ = CapVehCusi - Q;
//	if (tQ > 0) {vioCapNEWi = tQ; CapVehCusi = Q;}
//	double varcostii = problem->c[j][i] + problem->c[i][nextj] - problem->c[j][nextj];	//when calling this procedure for sure nexti != cusDi: cusDi is NOT direct successor of i
//	double varcosti;
//	if (next_cusDi > 0)
//		varcosti = varcostii + (problem->c[pre_cusDi][next_cusDi] - problem->c[pre_cusDi][cusDi] - problem->c[cusDi][next_cusDi]);
//	else
//		varcosti = varcostii - (problem->c[pre_cusDi][cusDi] + seg[idVeh].Trip[idTrip].connectCost);
//
//	double departi = depart_j + problem->c[j][i];
//	temp = departi - problem->node[i].eTW;
//	if (temp > eps)
//	{
//		vioTWCNEWi = temp;
//		departi = problem->node[i].depart;
//	}
//	else {vioTWCNEWi = 0; departi = PDS_MAX(departi, problem->node[i].sTW) + problem->node[i].duration;}
//  
//	//1. Insert CusDi right after i
//	int varvioCAP = vioCapNEWi; double varvioTWC = vioTWCNEWi; double varvioTWSP = 0;
//	int CapVehCus = CapVehCusi + problem->node[cusDi].capacity;
//	tQ = CapVehCus - Q;
//	if (tQ > 0) {varvioCAP += tQ; CapVehCus = Q;}
//	
//	cStartS = departi + problem->c[i][cusDi];
//	temp = cStartS - problem->node[cusDi].eTW;
//	if (temp > eps) {varvioTWC += temp; cStartS = problem->node[cusDi].depart;}
//	else cStartS = PDS_MAX(cStartS, problem->node[cusDi].sTW) + problem->node[cusDi].duration;
//	double varcost;
//	int wherecusDi = 1;
//	bool contCAP, contTW, STOP = 0;
//
//	if (cusDi == nextj) //cusDi is already after i
//	{
//		varcost = varcostii;
//		nextj = nextArr[nextj];
//		if (nextj > 0) 
//		{
//			if (GoThroughLegC2C(cusDi,nextj, cStartS,varvioTWC,CapVehCus,varvioCAP) == 0) //fore sure nextj > 0; depart lastC has changed
//			{
//				if (calChangeCONNECTAtSP_C2CTrip(lastC,idVeh,idTrip,nextT,cStartS,varvioTWSP,varcost) == 0) //seg[idVeh].Trip[nextT].leaveSP has changed
//					GoThroughVehicle(idVeh,nextT,varcost,varvioTWC,varvioTWSP,cStartS,nextSP,seg[idVeh].Trip[nextT].firstCus);
//			}
//		}
//		else //cusDi was the last cus
//		{
//			if (PDSDIF(cStartS,depart[cusDi]) == 0) varcost += seg[idVeh].Trip[idTrip].cost;
//			else //depart lastC has changed
//			{
//				if (calChangeCONNECTAtSP_C2CTrip(cusDi,idVeh,idTrip,nextT,cStartS,varvioTWSP,varcost) == 0) //seg[idVeh].Trip[nextT].leaveSP has changed
//					GoThroughVehicle(idVeh,nextT,varcost,varvioTWC,varvioTWSP,cStartS,nextSP,seg[idVeh].Trip[nextT].firstCus);
//			}
//			STOP = 1;
//		}
//		wherecusDi = 0;
//	}
//	else //cusDi != nextj
//	{
//		varcost = varcosti + problem->c[i][cusDi] + problem->c[cusDi][nextj] - problem->c[i][nextj];
//		//cusDi belongs to nextArr[nextj]...lastC:
//		contCAP = 1; contTW = 1;
//		GoThroughLegC2C(cusDi,nextj,pre_cusDi,cStartS,CapVehCus,varvioCAP,varvioTWC,contCAP,contTW);
//		contCAP = 1; contTW = 1;
//		if (next_cusDi > 0)
//		{
//			if (GoThroughLegC2C(pre_cusDi,next_cusDi, cStartS,varvioTWC,CapVehCus,varvioCAP) == 0) //fore sure nextj > 0; depart lastC has changed
//			{
//				if (calChangeCONNECTAtSP_C2CTrip(lastC,idVeh,idTrip,nextT,cStartS,varvioTWSP,varcost) == 0) //seg[idVeh].Trip[nextT].leaveSP has changed
//					GoThroughVehicle(idVeh,nextT,varcost,varvioTWC,varvioTWSP,cStartS,nextSP,seg[idVeh].Trip[nextT].firstCus);
//			}
//		}
//		else //cusDi was the last cus --> now pre_cusDi is the last cus
//		{
//		    if (calChangeCONNECTAtSP_C2CTrip_LastCChanged(pre_cusDi,idVeh,idTrip,nextT,cStartS,varvioTWSP,varcost) == 0)
//					GoThroughVehicle(idVeh,nextT,varcost,varvioTWC,varvioTWSP,cStartS,nextSP,seg[idVeh].Trip[nextT].firstCus);
//		}
//	}
//
//	obj = varcost + VCAP * varvioCAP + VTWCUS * varvioTWC + VTWSP * varvioTWSP;
//	if (obj < objMIN)
//	{
//		varcostMIN = varcost; varvioCAPMIN = varvioCAP; varvioTWCMIN = varvioTWC; varvioTWSPMIN = varvioTWSP;
//		objMIN = obj;
//		insertAfter = i;
//	}
//
//	//2. Find place to insert cusDi starting from position after nextj: NOTE that cusDi may already exist somewhere else in the segment from nextj ... lastC
//	if (STOP) return; //this case: Trip before move: [...i.....j,cusDi] where cusDi is the last cus of the trip --> don't exist any other place to insert cusDi
//
//	int posi = pos[j];
//	int nextC = nextj; 
//	int cal_tillC = i; int pos_cal_tillC = posi; int cal_startC = nextC; 
//	int varvioCAP_tillC = vioCapNEWi; double varvioTWC_tillC = vioTWCNEWi;
//	int CapVehCus_tillC = CapVehCusi; double cStartS_tillC = departi;
//	int pickID;
//	contCAP = 1; contTW = 1;
//
//	do
//	{
//		if (nextC < problem->startidC2CD) //nextC is C2CP
//			nextC = problem->node[nextC].delID; //jump to delID of nextC
//		else //nextC is C2CD
//		{
//				pickID = problem->node[nextC].pickID;
//			    if (i == pickID) //nextC is cusDi
//				{
//					//if it is here it means:  ...i(P+....P-=j)cusDi... --> ...(P+....P-)i cusDi...
//					//--?already calculate before in //1. Insert CusDi right after i
//					/*int preCT = predArr[nextC];
//					if (preCT != j)
//					{
//						cout<<"There is the case of C2Ctrip for moveCusC2C that I don't know it could happen: ";
//						showTripCus(idVeh,idTrip);
//						cout<<"Insert C2CP = "<<i<<" and its C2CD = "<<cusDi<<" after j = "<<j<<endl;
//						cout<<"It is now trying to insert C2CD("<<cusDi<<") after C2CD = "<<nextC<<endl;
//						exit(-1);
//					}*/
//					nextC = nextArr[nextC];
//					cal_startC = nextC;
//				}
//				else if (pos[pickID] > posi)
//				{
//					//Insert cusDi after nextC:
//					int nextC_T = nextArr[nextC];
//					if (wherecusDi != 0)
//					{
//						if (posCusDi < pos_cal_tillC) wherecusDi = 1;
//						else if (posCusDi > pos[nextC]) wherecusDi = 2;
//						else wherecusDi = 3;
//					}
//					if (pos_cal_tillC < pos[nextC]) //need to calculate vioTWC and vioCAP till nextC:
//					{
//						//Calculate from cal_startC to nextC after i already inserted into the trip after j:
//						if (wherecusDi < 3) //(posCusDi < pos_cal_tillC || posCusDi > pos[nextC])
//						{
//							if (contCAP == 0) {/*varvioCAP = varvioCAP_tillC;*/ CapVehCus_tillC = CAPCus[nextC];}
//							if (contTW == 0) {/*varvioTWC = varvioTWC_tillC;*/ cStartS_tillC = depart[nextC];}
//							GoThroughLegC2C(cal_tillC,cal_startC,nextC,cStartS_tillC,CapVehCus_tillC,varvioCAP_tillC,varvioTWC_tillC,contCAP,contTW);
//						}
//						else //cusDi belongs to cal_startC ... nextC
//						{
//							if (pre_cusDi == cal_tillC)
//							{
//								//...cal_tillC, cusDi, cal_startC.... nextC
//								GoThroughLegC2C(cal_tillC,cal_startC,nextC,cStartS_tillC,CapVehCus_tillC,varvioCAP_tillC,varvioTWC_tillC,contCAP,contTW);
//							}
//							else
//							{
//								if (contCAP == 0) {/*varvioCAP = varvioCAP_tillC;*/ CapVehCus_tillC = CAPCus[pre_cusDi]; contCAP = 1;}
//								if (contTW == 0) {/*varvioTWC = varvioTWC_tillC;*/ cStartS_tillC = depart[pre_cusDi]; contTW = 1;}
//								GoThroughLegC2C(cal_tillC,cal_startC,pre_cusDi,cStartS_tillC,CapVehCus_tillC,varvioCAP_tillC,varvioTWC_tillC,contCAP,contTW);
//								/*?? 15/1/2014: co can bo sung 
//								if (contCAP == 0) {CapVehCus_tillC = CAPCus[nextC]; contCAP = 1;}
//								if (contTW == 0) {cStartS_tillC = depart[nextC]; contTW = 1;}
//								*/
//								GoThroughLegC2C(pre_cusDi,next_cusDi,nextC,cStartS_tillC,CapVehCus_tillC,varvioCAP_tillC,varvioTWC_tillC,contCAP,contTW);
//							}
//						}//end cusDi belongs to start_tillC ... nextC
//						cal_tillC = nextC;	
//						pos_cal_tillC = pos[nextC];
//						cal_startC = nextC_T;
//					}//end if (pos_cal_tillC < pos[nextC])
//					//Now insert cusDi after nextC:
//					varvioTWSP = 0;
//					if (nextC_T > 0) //insert cusDi after nextC which is not the last cus of the trip
//					{
//						cStartS = cStartS_tillC + problem->c[nextC][cusDi];
//						temp = cStartS - problem->node[cusDi].eTW;
//						if (temp > eps) {varvioTWC = varvioTWC_tillC + temp; cStartS = problem->node[cusDi].depart;}
//						else 
//						{
//							varvioTWC = varvioTWC_tillC;
//							cStartS = PDS_MAX(cStartS, problem->node[cusDi].sTW) + problem->node[cusDi].duration;
//						}
//						CapVehCus = CapVehCus_tillC + problem->node[cusDi].capacity;
//						tQ = CapVehCus - Q;
//						if (tQ > 0)
//						{
//							varvioCAP = varvioCAP_tillC + tQ; 
//							CapVehCus = Q;
//						}
//						else varvioCAP = varvioCAP_tillC;
//
//						if (cusDi == nextC_T)
//						{
//							if (next_cusDi > 0)
//							    varcost = varcosti + problem->c[nextC][cusDi] + problem->c[cusDi][next_cusDi] - problem->c[nextC][next_cusDi];
//							else
//								varcost = varcosti + problem->c[nextC][cusDi] + seg[idVeh].Trip[idTrip].cost;
//						}
//						else
//						   varcost = varcosti + problem->c[nextC][cusDi] + problem->c[cusDi][nextC_T] - problem->c[nextC][nextC_T];
//						//Cal from cusDi till the end of the trip:
//						if (wherecusDi == 2) //posCusDi > pos[nextC]: cusDi belongs to nextC_T ... lastcus
//						{
//							if (cusDi == nextC_T)
//							{
//								nextC_T = next_cusDi;
//							    cal_startC = nextC_T; contCAP = 1; contTW = 1;//pos_call_tillC++;
//								if (nextC_T > 0)
//								{
//									if (GoThroughLegC2C(cusDi,nextC_T,cStartS,varvioTWC,CapVehCus,varvioCAP) == 0) //depart lastC has changed
//									{
//										if (calChangeCONNECTAtSP_C2CTrip(lastC,idVeh,idTrip,nextT,cStartS,varvioTWSP,varcost) == 0) //seg[idVeh].Trip[nextT].leaveSP has changed
//											GoThroughVehicle(idVeh,nextT,varcost,varvioTWC,varvioTWSP,cStartS,nextSP,seg[idVeh].Trip[nextT].firstCus);
//									}
//								}
//								else //cusDi was the last cus; now still the last cus
//								{
//									if (PDSDIF(cStartS,depart[cusDi])) //depart lastC has changed
//									{
//										if (calChangeCONNECTAtSP_C2CTrip(cusDi,idVeh,idTrip,nextT,cStartS,varvioTWSP,varcost) == 0) //seg[idVeh].Trip[nextT].leaveSP has changed
//											GoThroughVehicle(idVeh,nextT,varcost,varvioTWC,varvioTWSP,cStartS,nextSP,seg[idVeh].Trip[nextT].firstCus);
//									}
//								}
//							}
//							else //cusDi belongs to nextC_T+1 ... lastCus
//							{
//								//Cal from nextC_T ... predArr[cusDi]:
//								bool contCAP1 = 1; bool contTW1 = 1; 
//								GoThroughLegC2C(cusDi,nextC_T,pre_cusDi,cStartS,CapVehCus,varvioCAP,varvioTWC,contCAP1,contTW1);
//								//Cal from nextArr[cusDi] ... lastCus
//								if (next_cusDi > 0)
//								{
//									if (GoThroughLegC2C(pre_cusDi, next_cusDi,cStartS,varvioTWC,CapVehCus,varvioCAP) == 0) //depart lastC has changed
//									{
//										if (calChangeCONNECTAtSP_C2CTrip(lastC,idVeh,idTrip,nextT,cStartS,varvioTWSP,varcost) == 0) //seg[idVeh].Trip[nextT].leaveSP has changed
//											GoThroughVehicle(idVeh,nextT,varcost,varvioTWC,varvioTWSP,cStartS,nextSP,seg[idVeh].Trip[nextT].firstCus);
//									}
//								}
//								else //cusDi was the last cus, now pre_cusDi is the last cus
//								{
//									if (calChangeCONNECTAtSP_C2CTrip_LastCChanged(pre_cusDi,idVeh,idTrip,nextT,cStartS,varvioTWSP,varcost) == 0)
//											GoThroughVehicle(idVeh,nextT,varcost,varvioTWC,varvioTWSP,cStartS,nextSP,seg[idVeh].Trip[nextT].firstCus);
//								}
//							}
//						}
//						else //cusDi doesn't belong to the nextC
//						{
//							if (GoThroughLegC2C(cusDi,nextC_T,cStartS,varvioTWC,CapVehCus,varvioCAP) == 0)
//							{
//								if (calChangeCONNECTAtSP_C2CTrip(lastC,idVeh,idTrip,nextT,cStartS,varvioTWSP,varcost) == 0) //seg[idVeh].Trip[nextT].leaveSP has changed
//									GoThroughVehicle(idVeh,nextT,varcost,varvioTWC,varvioTWSP,cStartS,nextSP,seg[idVeh].Trip[nextT].firstCus);
//							}
//						}
//						obj = varcost + VCAP * varvioCAP + VTWCUS * varvioTWC + VTWSP * varvioTWSP;
//						if (obj < objMIN)
//						{
//							varcostMIN = varcost; varvioCAPMIN = varvioCAP; varvioTWCMIN = varvioTWC; varvioTWSPMIN = varvioTWSP; 
//							objMIN = obj;
//							insertAfter = nextC;
//						}
//					}
//					else //insert cusDi at the end of the trip:
//					{
//						cStartS = cStartS_tillC + problem->c[nextC][cusDi];
//						temp = cStartS - problem->node[cusDi].eTW;
//						if (temp > eps)
//						{
//							varvioTWC = varvioTWC_tillC + temp;
//							cStartS = problem->node[cusDi].depart;
//						}
//						else
//						{
//							varvioTWC = varvioTWC_tillC;
//							cStartS = PDS_MAX(cStartS, problem->node[cusDi].sTW) + problem->node[cusDi].duration;
//						}
//						//don't need varvioCAP because insert cusDi at the end of the trip
//						varcost = varcosti + problem->c[nextC][cusDi] - seg[idVeh].Trip[idTrip].connectCost;
//						if (calChangeCONNECTAtSP_C2CTrip_LastCChanged(cusDi,idVeh,idTrip,nextT,cStartS,varvioTWSP,varcost)== 0) //seg[idVeh].Trip[nextT].leaveSP has changed
//							GoThroughVehicle(idVeh,nextT,varcost,varvioTWC,varvioTWSP,cStartS,nextSP,seg[idVeh].Trip[nextT].firstCus);
//
//						obj = varcost + VCAP * varvioCAP_tillC + VTWCUS * varvioTWC + VTWSP * varvioTWSP;
//						if (obj < objMIN)
//						{
//							varcostMIN = varcost; varvioCAPMIN = varvioCAP_tillC; varvioTWCMIN = varvioTWC; 
//							objMIN = obj; varvioTWSPMIN = varvioTWSP;
//							insertAfter = nextC;
//						}
//						return; //finish the trip
//					}//end insert cusDi after nextC which is the last cus of the trip
//					nextC = nextC_T; //find another position to insert delID
//				}
//				else // (pos[pickID] <= posi)
//					return; //break; //doesn't exist any place to insert cusDi anymore
//		}//end nextC is C2CD
//	}while (nextC > 0);
//
//
//}
//
//
//void Solution::SUBcal_InsertCusC2CIAfterJ_NotLastC_iANDdelIDIN_NextD(double depart_j, int CAPCusj, int j, int i, int idVeh, int idTrip, int nextSP, double &varcostMIN, double &varvioTWCMIN, double &varvioTWSPMIN, int &varvioCAPMIN, int &insertAfter)
//{
//	//14/12/2013: different from SUBcal_InsertCusC2CIAfterJ_NotLastC_nextD: 
//	//in this procedure i and cusDi belongs to the segment [j..lastC]; while in procedure SUBcal_InsertCusC2CIAfterJ_NotLastC_nextD, they dont belong to this segment
//    //for sure: next[j] != i
//	//COPY SUBcal_InsertCusC2CIAfterJ_NotLastC_lastTrip_iANDdelIDIN, SUBcal_InsertCusC2CIAfterJ_NotLastC_iANDdelIDIN_NextTripPORD
//
//	int prei = predArr[i]; int nexti = nextArr[i];
//	int cusDi = problem->node[i].delID; int nextT = idTrip + 1;
//	int posCusDi = pos[cusDi]; int pre_cusDi = predArr[cusDi]; int next_cusDi = nextArr[cusDi];
//	int nextj = nextArr[j];
//	int lastC = seg[idVeh].Trip[idTrip].lastCus;
//	int CapVehCusi = CAPCusj + problem->node[i].capacity;
//	int vioCapNEWi = 0; 
//	double vioTWCNEWi, temp, cStartS, obj, objMIN = PDS_INFINITY;
//    //Checking at i:
//	int tQ = CapVehCusi - Q;
//	if (tQ > 0) {vioCapNEWi = tQ; CapVehCusi = Q;}
//	double varcosti = problem->c[j][i] + problem->c[i][nextj] - problem->c[j][nextj];
//	if (nexti == cusDi)
//	{
//		if (next_cusDi > 0)
//			varcosti += (problem->c[prei][next_cusDi] - problem->c[prei][i] - problem->c[i][cusDi] - problem->c[cusDi][next_cusDi]);
//		else
//			varcosti -= (problem->c[prei][i] + problem->c[i][cusDi] + seg[idVeh].Trip[idTrip].connectCost);
//	}
//	else
//	{
//		varcosti += (problem->c[prei][nexti] - problem->c[prei][i] - problem->c[i][nexti]);
//		if (next_cusDi > 0)
//			varcosti += (problem->c[pre_cusDi][next_cusDi] - problem->c[pre_cusDi][cusDi] - problem->c[cusDi][next_cusDi]);
//		else
//			varcosti -= (problem->c[pre_cusDi][cusDi] + seg[idVeh].Trip[idTrip].connectCost);
//	}
//
//	double departi = depart_j + problem->c[j][i];
//	temp = departi - problem->node[i].eTW;
//	if (temp > eps)
//	{
//		vioTWCNEWi = temp;
//		departi = problem->node[i].depart;
//	}
//	else {vioTWCNEWi = 0; departi = PDS_MAX(departi, problem->node[i].sTW) + problem->node[i].duration;}
//  
//	double varvioTWSP = 0;
//	//1. Insert CusDi right after i
//	int varvioCAP = vioCapNEWi; double varvioTWC = vioTWCNEWi;
//	int CapVehCus = CapVehCusi + problem->node[cusDi].capacity;
//	tQ = CapVehCus - Q;
//	if (tQ > 0) {varvioCAP += tQ; CapVehCus = Q;}
//	
//	cStartS = departi + problem->c[i][cusDi];
//	temp = cStartS - problem->node[cusDi].eTW;
//	if (temp > eps) {varvioTWC += temp; cStartS = problem->node[cusDi].depart;}
//	else cStartS = PDS_MAX(cStartS, problem->node[cusDi].sTW) + problem->node[cusDi].duration;
//	double varcost;
//
//	varcost = varcosti + problem->c[i][cusDi] + problem->c[cusDi][nextj] - problem->c[i][nextj];
//	//i and cusDi belong to nextArr[nextj]...lastC:
//	bool contCAP = 1; bool contTW = 1;
//	GoThroughLegC2C(cusDi,nextj,prei,cStartS,CapVehCus,varvioCAP,varvioTWC,contCAP,contTW); //from nextj .. pre_i
//	contCAP = 1; contTW = 1;
//	if (nexti == cusDi)
//	{
//		if (next_cusDi > 0)
//		{
//			if (GoThroughLegC2C(prei,next_cusDi,cStartS,varvioTWC,CapVehCus,varvioCAP) == 0) //depart[lastC] has changed
//			{
//				if (calChangeCONNECTAtSP_C2CTrip(lastC,idVeh,idTrip,nextT,cStartS,varvioTWSP,varcost) == 0) //seg[idVeh].Trip[nextT].leaveSP has changed
//					GoThroughVehicle(idVeh,nextT,varcost,varvioTWC,varvioTWSP,cStartS,nextSP,seg[idVeh].Trip[nextT].firstCus);
//			}
//		}
//		else //cusDi was the last cus; prei is now the last cus
//		{
//			if (calChangeCONNECTAtSP_C2CTrip_LastCChanged(prei,idVeh,idTrip,nextT,cStartS,varvioTWSP,varcost)== 0) //seg[idVeh].Trip[nextT].leaveSP has changed
//				GoThroughVehicle(idVeh,nextT,varcost,varvioTWC,varvioTWSP,cStartS,nextSP,seg[idVeh].Trip[nextT].firstCus);
//		}
//	}
//	else
//	{
//		contCAP = 1; contTW = 1;
//		GoThroughLegC2C(prei,nexti,pre_cusDi,cStartS,CapVehCus,varvioCAP,varvioTWC,contCAP,contTW); //from prei,nexti...pre_CusDi
//		if (next_cusDi > 0)
//		{
//			if (GoThroughLegC2C(pre_cusDi,next_cusDi,cStartS,varvioTWC,CapVehCus,varvioCAP) == 0)
//			{
//				if (calChangeCONNECTAtSP_C2CTrip(lastC,idVeh,idTrip,nextT,cStartS,varvioTWSP,varcost) == 0) //seg[idVeh].Trip[nextT].leaveSP has changed
//					GoThroughVehicle(idVeh,nextT,varcost,varvioTWC,varvioTWSP,cStartS,nextSP,seg[idVeh].Trip[nextT].firstCus);
//			}
//		}
//		else //cusDi was the last cus --> pre_cusDi is now the last cus:
//		{
//			if (calChangeCONNECTAtSP_C2CTrip_LastCChanged(pre_cusDi,idVeh,idTrip,nextT,cStartS,varvioTWSP,varcost)== 0) //seg[idVeh].Trip[nextT].leaveSP has changed
//				GoThroughVehicle(idVeh,nextT,varcost,varvioTWC,varvioTWSP,cStartS,nextSP,seg[idVeh].Trip[nextT].firstCus);
//		}
//	}
//
//	obj = varcost + VCAP * varvioCAP + VTWCUS * varvioTWC + VTWSP * varvioTWSP;
//	if (obj < objMIN)
//	{
//		varcostMIN = varcost; varvioCAPMIN = varvioCAP; varvioTWCMIN = varvioTWC; 
//		objMIN = obj; varvioTWSPMIN = varvioTWSP;
//		insertAfter = i;
//	}
//
//	//2. Find place to insert cusDi starting from position after nextj: NOTE that i and cusDi may already exist somewhere else in the leg
//	int posiOLD = pos[i];
//	int posi = pos[j];
//	int nextC = nextj; 
//	int cal_tillC = i; int pos_cal_tillC = posi; int cal_startC = nextC; 
//	int varvioCAP_tillC = vioCapNEWi; double varvioTWC_tillC = vioTWCNEWi;
//	int CapVehCus_tillC = CapVehCusi; double cStartS_tillC = departi;
//	int pickID;
//	contCAP = 1; contTW = 1;
//	bool contCAP1 = 1; bool contTW1 = 1;
//	do
//	{
//		if (nextC < problem->startidC2CD) //nextC is C2CP
//		{
//			if (nextC == i) {nextC = nextArr[i]; cal_startC = nextC; contCAP = 1; contTW = 1;}
//			else nextC = problem->node[nextC].delID; //jump to delID of nextC
//		}
//		else //nextC is C2CD
//		{
//			if (nextC == cusDi) {nextC = nextArr[cusDi];cal_startC = nextC; contCAP = 1; contTW = 1;}
//			else //nextC is not cusDi
//			{
//				pickID = problem->node[nextC].pickID;
//				if (pos[pickID] > posi)
//				{
//					varvioTWSP = 0;
//					int nextC_T = nextArr[nextC];
//					if (pos[pickID] > posCusDi) //1) [i...cusDi]...[pickID...nextC]
//					{
//						if (pos_cal_tillC < pos[nextC]) //need to calculate vioTWC and vioCAP till nextC:
//						{
//							//for sure [i..cusDi] < pos_cal_tillC ????
//							if (contCAP == 0) {/*varvioCAP = varvioCAP_tillC;*/ CapVehCus_tillC = CAPCus[nextC];}
//							if (contTW == 0) {/*varvioTWC = varvioTWC_tillC;*/ cStartS_tillC = depart[nextC];}
//							GoThroughLegC2C(cal_tillC,cal_startC,nextC,cStartS_tillC,CapVehCus_tillC,varvioCAP_tillC,varvioTWC_tillC,contCAP,contTW);
//							cal_tillC = nextC; pos_cal_tillC = pos[nextC];
//							cal_startC = nextC_T;
//						}
//						//insert cusDi after nextC
//						if (nextC_T > 0) //insert cusDi after nextC which is not the last cus
//						{
//							cStartS = cStartS_tillC + problem->c[nextC][cusDi];
//							temp = cStartS - problem->node[cusDi].eTW;
//							if (temp > eps) {varvioTWC = varvioTWC_tillC + temp; cStartS = problem->node[cusDi].depart;}
//							else 
//							{
//								varvioTWC = varvioTWC_tillC;
//								cStartS = PDS_MAX(cStartS, problem->node[cusDi].sTW) + problem->node[cusDi].duration;
//							}
//							CapVehCus = CapVehCus_tillC + problem->node[cusDi].capacity;
//							tQ = CapVehCus - Q;
//							if (tQ > 0)
//							{
//								varvioCAP = varvioCAP_tillC + tQ; 
//								CapVehCus = Q;
//							}
//							else varvioCAP = varvioCAP_tillC;
//							varcost = varcosti + problem->c[nextC][cusDi] + problem->c[cusDi][nextC_T] - problem->c[nextC][nextC_T];
//							//Cal from cusDi till the end of the trip: i and cusDi doesn't belong to this segment:
//                            if (GoThroughLegC2C(cusDi,nextC_T,cStartS,varvioTWC,CapVehCus,varvioCAP) == 0) //depart[lastC] has changed
//							{
//								if (calChangeCONNECTAtSP_C2CTrip(lastC,idVeh,idTrip,nextT,cStartS,varvioTWSP,varcost) == 0) //seg[idVeh].Trip[nextT].leaveSP has changed
//									GoThroughVehicle(idVeh,nextT,varcost,varvioTWC,varvioTWSP,cStartS,nextSP,seg[idVeh].Trip[nextT].firstCus);
//							}
//							obj = varcost + VCAP * varvioCAP + VTWCUS * varvioTWC + VTWSP * varvioTWSP;
//							if (obj < objMIN)
//							{
//								varcostMIN = varcost; varvioCAPMIN = varvioCAP; varvioTWCMIN = varvioTWC; 
//								objMIN = obj; varvioTWSPMIN = varvioTWSP;
//								insertAfter = nextC;
//							}
//						}
//						else //insert cusDi at the end of the trip:
//						{
//							cStartS = cStartS_tillC + problem->c[nextC][cusDi];
//							temp = cStartS - problem->node[cusDi].eTW;
//							if (temp > eps) varvioTWC = varvioTWC_tillC + temp;
//							else varvioTWC = varvioTWC_tillC;
//							//don't need varvioCAP because insert cusDi at the end of the trip
//							varcost = varcosti + problem->c[nextC][cusDi] - seg[idVeh].Trip[idTrip].connectCost;
//							//cusDi is now the last cus
//							if (calChangeCONNECTAtSP_C2CTrip_LastCChanged(cusDi,idVeh,idTrip,nextT,cStartS,varvioTWSP,varcost)== 0) //seg[idVeh].Trip[nextT].leaveSP has changed
//								GoThroughVehicle(idVeh,nextT,varcost,varvioTWC,varvioTWSP,cStartS,nextSP,seg[idVeh].Trip[nextT].firstCus);
//
//							obj = varcost + VCAP * varvioCAP_tillC + VTWCUS * varvioTWC + VTWSP * varvioTWSP;
//							if (obj < objMIN)
//							{
//								varcostMIN = varcost; varvioCAPMIN = varvioCAP_tillC; varvioTWCMIN = varvioTWC; 
//								objMIN = obj; varvioTWSPMIN = varvioTWSP;
//								insertAfter = nextC;
//							}
//							return; //finish the trip
//						}//end insert cusDi at the end of the trip
//					}
//					else if (pos[nextC] < posi) //3)[pickID...nextC]....[i...cusDi]
//					{
//						if (pos_cal_tillC < pos[nextC]) //need to calculate vioTWC and vioCAP till nextC:
//						{
//							//for sure [i..cusDi] < pos_cal_tillC ????
//							if (contCAP == 0) {/*varvioCAP = varvioCAP_tillC;*/ CapVehCus_tillC = CAPCus[nextC];}
//							if (contTW == 0) {/*varvioTWC = varvioTWC_tillC;*/ cStartS_tillC = depart[nextC];}
//							GoThroughLegC2C(cal_tillC,cal_startC,nextC,cStartS_tillC,CapVehCus_tillC,varvioCAP_tillC,varvioTWC_tillC,contCAP,contTW);
//							cal_tillC = nextC; pos_cal_tillC = pos[nextC];
//							cal_startC = nextC_T;
//						}
//						//insert cusDi after nextC: i and cusDi both belong to the segment nextC..lastC
//						cStartS = cStartS_tillC + problem->c[nextC][cusDi];
//						temp = cStartS - problem->node[cusDi].eTW;
//						if (temp > eps) {varvioTWC = varvioTWC_tillC + temp; cStartS = problem->node[cusDi].depart;}
//						else 
//						{
//							varvioTWC = varvioTWC_tillC;
//							cStartS = PDS_MAX(cStartS, problem->node[cusDi].sTW) + problem->node[cusDi].duration;
//						}
//						CapVehCus = CapVehCus_tillC + problem->node[cusDi].capacity;
//						tQ = CapVehCus - Q;
//						if (tQ > 0)
//						{
//							varvioCAP = varvioCAP_tillC + tQ; 
//							CapVehCus = Q;
//						}
//						else varvioCAP = varvioCAP_tillC;
//						if (nextC_T == i)
//						{
//							if (nexti == cusDi) 
//							{
//								nextC_T = next_cusDi;cal_startC = next_cusDi; contCAP = 1; contTW = 1;
//								if (next_cusDi > 0) 
//								{
//									varcost = varcosti + problem->c[nextC][cusDi] + problem->c[cusDi][next_cusDi] - problem->c[nextC][next_cusDi];
//									//Cal nextC_T till the end of the trip: i and cusDi doesn't belong to this segment
//									if (GoThroughLegC2C(cusDi,nextC_T,cStartS,varvioTWC,CapVehCus,varvioCAP) == 0)
//									{
//										if (calChangeCONNECTAtSP_C2CTrip(lastC,idVeh,idTrip,nextT,cStartS,varvioTWSP,varcost) == 0) //seg[idVeh].Trip[nextT].leaveSP has changed
//											GoThroughVehicle(idVeh,nextT,varcost,varvioTWC,varvioTWSP,cStartS,nextSP,seg[idVeh].Trip[nextT].firstCus);
//									}
//								}
//								else //nextC was the last cus --> cusDi is now the last cus
//								{
//									varcost = varcosti + problem->c[nextC][cusDi];
//									if (calChangeCONNECTAtSP_C2CTrip_LastCChanged(cusDi,idVeh,idTrip,nextT,cStartS,varvioTWSP,varcost)== 0) //seg[idVeh].Trip[nextT].leaveSP has changed
//										GoThroughVehicle(idVeh,nextT,varcost,varvioTWC,varvioTWSP,cStartS,nextSP,seg[idVeh].Trip[nextT].firstCus);
//								}
//							}
//							else //[pickID...nextC- i...cusDi]
//							{
//								nextC_T = nexti; cal_startC = nexti; contCAP = 1; contTW = 1;
//								varcost = varcosti + problem->c[nextC][cusDi] + problem->c[cusDi][nexti] - problem->c[nextC][nexti];
//								//from cusDi(after insertion)...pre_cusDi
//								contCAP1 = 1; contTW1 = 1;
//								GoThroughLegC2C(cusDi,nexti,pre_cusDi,cStartS,CapVehCus,varvioCAP,varvioTWC,contCAP1,contTW1);
//								if (next_cusDi > 0)
//								{
//									if (GoThroughLegC2C(pre_cusDi,next_cusDi,cStartS,varvioTWC,CapVehCus,varvioCAP) == 0)
//									{
//										if (calChangeCONNECTAtSP_C2CTrip(lastC,idVeh,idTrip,nextT,cStartS,varvioTWSP,varcost) == 0) //seg[idVeh].Trip[nextT].leaveSP has changed
//											GoThroughVehicle(idVeh,nextT,varcost,varvioTWC,varvioTWSP,cStartS,nextSP,seg[idVeh].Trip[nextT].firstCus);
//									}
//								}
//								else //cusDi was the last cus --> pre_cusDi is now the last cus:
//								{
//									if (calChangeCONNECTAtSP_C2CTrip_LastCChanged(pre_cusDi,idVeh,idTrip,nextT,cStartS,varvioTWSP,varcost)== 0) //seg[idVeh].Trip[nextT].leaveSP has changed
//										GoThroughVehicle(idVeh,nextT,varcost,varvioTWC,varvioTWSP,cStartS,nextSP,seg[idVeh].Trip[nextT].firstCus);
//								}
//							}
//						}
//						else //nextC_T != i: [pickID...nextC]....[i...cusDi]
//						{
//							varcost = varcosti + problem->c[nextC][cusDi] + problem->c[cusDi][nextC_T] - problem->c[nextC][nextC_T];
//							contCAP1 = 1; contTW1 = 1;
//							GoThroughLegC2C(cusDi,nextC_T,prei,cStartS,CapVehCus,varvioCAP,varvioTWC,contCAP1,contTW1);
//							if (nexti == cusDi)
//							{
//								if (next_cusDi > 0)
//								{
//								   if (GoThroughLegC2C(prei,next_cusDi,cStartS,varvioTWC,CapVehCus,varvioCAP) == 0)
//								   {
//										if (calChangeCONNECTAtSP_C2CTrip(lastC,idVeh,idTrip,nextT,cStartS,varvioTWSP,varcost) == 0) //seg[idVeh].Trip[nextT].leaveSP has changed
//											GoThroughVehicle(idVeh,nextT,varcost,varvioTWC,varvioTWSP,cStartS,nextSP,seg[idVeh].Trip[nextT].firstCus);
//								   }
//								}
//								else //cusDi was the last cus --> prei is now the last cus
//								{
//									if (calChangeCONNECTAtSP_C2CTrip_LastCChanged(prei,idVeh,idTrip,nextT,cStartS,varvioTWSP,varcost)== 0) //seg[idVeh].Trip[nextT].leaveSP has changed
//										GoThroughVehicle(idVeh,nextT,varcost,varvioTWC,varvioTWSP,cStartS,nextSP,seg[idVeh].Trip[nextT].firstCus);
//								}
//							}
//							else //nexti != cusDi: nextC_T != i: [pickID...nextC]....[i...cusDi]
//							{
//								contCAP1 = 1; contTW1 = 1;
//								GoThroughLegC2C(prei,nexti,pre_cusDi,cStartS,CapVehCus,varvioCAP,varvioTWC,contCAP1,contTW1);
//								if (next_cusDi > 0)
//								{
//									if (GoThroughLegC2C(pre_cusDi,next_cusDi,cStartS,varvioTWC,CapVehCus,varvioCAP)  == 0)
//									{
//										if (calChangeCONNECTAtSP_C2CTrip(lastC,idVeh,idTrip,nextT,cStartS,varvioTWSP,varcost) == 0) //seg[idVeh].Trip[nextT].leaveSP has changed
//											GoThroughVehicle(idVeh,nextT,varcost,varvioTWC,varvioTWSP,cStartS,nextSP,seg[idVeh].Trip[nextT].firstCus);
//									}
//								}
//								else //cusDi was the last cus --> pre_cusDi is now the last cus
//								{
//									if (calChangeCONNECTAtSP_C2CTrip_LastCChanged(pre_cusDi,idVeh,idTrip,nextT,cStartS,varvioTWSP,varcost)== 0) //seg[idVeh].Trip[nextT].leaveSP has changed
//										GoThroughVehicle(idVeh,nextT,varcost,varvioTWC,varvioTWSP,cStartS,nextSP,seg[idVeh].Trip[nextT].firstCus);
//								}
//							}//end nexti != cusDi: nextC_T != i: [pickID...nextC]....[i...cusDi]
//						}//end nextC_T != i: [pickID...nextC]....[i...cusDi]
//						obj = varcost + VCAP * varvioCAP + VTWCUS * varvioTWC + VTWSP * varvioTWSP;
//						if (obj < objMIN)
//						{
//							varcostMIN = varcost; varvioCAPMIN = varvioCAP; varvioTWCMIN = varvioTWC; 
//							objMIN = obj; varvioTWSPMIN = varvioTWSP;
//							insertAfter = nextC;
//						}
//					}
//					else if (pos[nextC] > posCusDi) //4) pickID....[i...cusDi]....nextC
//					{
//						if (pos_cal_tillC < pos[nextC]) //need to calculate vioTWC and vioCAP till nextC:
//						{
//							//for sure [i..cusDi] < pos_cal_tillC ????
//							if (contCAP == 0) {/*varvioCAP = varvioCAP_tillC;*/ CapVehCus_tillC = CAPCus[prei];}
//							if (contTW == 0) {/*varvioTWC = varvioTWC_tillC;*/ cStartS_tillC = depart[prei];}
//							GoThroughLegC2C(cal_tillC,cal_startC,prei,cStartS_tillC,CapVehCus_tillC,varvioCAP_tillC,varvioTWC_tillC,contCAP,contTW);
//							if (nexti == cusDi)
//							{
//								//if (contCAP == 0) CapVehCus_tillC = CAPCus[nextC];
//								//if (contTW == 0) cStartS_tillC = depart[nextC];
//								contCAP = 1; contTW = 1;
//								GoThroughLegC2C(prei,next_cusDi,nextC,cStartS_tillC, CapVehCus_tillC,varvioCAP_tillC,varvioTWC_tillC,contCAP,contTW);
//							}
//							else
//							{
//								//if (contCAP == 0) CapVehCus_tillC = CAPCus[nextC];
//								//if (contTW == 0) cStartS_tillC = depart[nextC];
//								contCAP1 = 1; contTW1 = 1;
//								GoThroughLegC2C(prei,nexti,pre_cusDi,cStartS_tillC,CapVehCus_tillC,varvioCAP_tillC,varvioTWC_tillC,contCAP1,contTW1);
//								contCAP = 1; contTW = 1;
//								GoThroughLegC2C(pre_cusDi,next_cusDi,nextC,cStartS_tillC,CapVehCus_tillC,varvioCAP_tillC,varvioTWC_tillC,contCAP,contTW);
//							}						
//							cal_tillC = nextC; pos_cal_tillC = pos[nextC];
//							cal_startC = nextC_T;
//						}
//						//insert cusDi after nextC:
//						if (nextC_T > 0) //insert cusDi after nextC which is not the last cus
//						{
//							cStartS = cStartS_tillC + problem->c[nextC][cusDi];
//							temp = cStartS - problem->node[cusDi].eTW;
//							if (temp > eps) {varvioTWC = varvioTWC_tillC + temp; cStartS = problem->node[cusDi].depart;}
//							else 
//							{
//								varvioTWC = varvioTWC_tillC;
//								cStartS = PDS_MAX(cStartS, problem->node[cusDi].sTW) + problem->node[cusDi].duration;
//							}
//							CapVehCus = CapVehCus_tillC + problem->node[cusDi].capacity;
//							tQ = CapVehCus - Q;
//							if (tQ > 0)
//							{
//								varvioCAP = varvioCAP_tillC + tQ; 
//								CapVehCus = Q;
//							}
//							else varvioCAP = varvioCAP_tillC;
//							varcost = varcosti + problem->c[nextC][cusDi] + problem->c[cusDi][nextC_T] - problem->c[nextC][nextC_T];
//							//Cal from cusDi till the end of the trip: i and cusDi doesn't belong to this segment:
//                            if (GoThroughLegC2C(cusDi,nextC_T,cStartS,varvioTWC,CapVehCus,varvioCAP) == 0)
//							{
//								if (calChangeCONNECTAtSP_C2CTrip(lastC,idVeh,idTrip,nextT,cStartS,varvioTWSP,varcost) == 0) //seg[idVeh].Trip[nextT].leaveSP has changed
//									GoThroughVehicle(idVeh,nextT,varcost,varvioTWC,varvioTWSP,cStartS,nextSP,seg[idVeh].Trip[nextT].firstCus);
//							}
//							obj = varcost + VCAP * varvioCAP + VTWCUS * varvioTWC + VTWSP * varvioTWSP;
//							if (obj < objMIN)
//							{
//								varcostMIN = varcost; varvioCAPMIN = varvioCAP; varvioTWCMIN = varvioTWC; 
//								objMIN = obj; varvioTWSPMIN = varvioTWSP;
//								insertAfter = nextC;
//							}
//						}
//						else //insert cusDi at the end of the trip:
//						{
//							cStartS = cStartS_tillC + problem->c[nextC][cusDi];
//							temp =  cStartS - problem->node[cusDi].eTW;
//							if (temp > eps) varvioTWC = varvioTWC_tillC + temp;
//							else varvioTWC = varvioTWC_tillC;
//							//don't need varvioCAP because insert cusDi at the end of the trip
//							varcost = varcosti + problem->c[nextC][cusDi] - seg[idVeh].Trip[idTrip].connectCost;
//							//nextC was the last cus --> cusDi is now the last cus:
//							if (calChangeCONNECTAtSP_C2CTrip_LastCChanged(cusDi,idVeh,idTrip,nextT,cStartS,varvioTWSP,varcost)== 0) //seg[idVeh].Trip[nextT].leaveSP has changed
//								GoThroughVehicle(idVeh,nextT,varcost,varvioTWC,varvioTWSP,cStartS,nextSP,seg[idVeh].Trip[nextT].firstCus);
//
//							obj = varcost + VCAP * varvioCAP_tillC + VTWCUS * varvioTWC + VTWSP * varvioTWSP;
//							if (obj < objMIN)
//							{
//								varcostMIN = varcost; varvioCAPMIN = varvioCAP_tillC; varvioTWCMIN = varvioTWC; 
//								objMIN = obj; varvioTWSPMIN = varvioTWSP;
//								insertAfter = nextC;
//							}
//							return; //finish the trip
//						}//end insert cusDi at the end of the trip
//					}
//					else //2) pos[nextC] belongs to [posi,poscusDi]: i...pickID...nextC...cusDi [BEFORE MOVE: ....nextC...i..cusDi... OR ....i...[pickID...nextC]...cusDi] 15/1/2014
//					{
//						if (pos_cal_tillC < pos[nextC]) //need to calculate vioTWC and vioCAP till nextC:
//						{
//							//for sure [i..cusDi] < pos_cal_tillC ????
//							if (contCAP == 0) {/*varvioCAP = varvioCAP_tillC;*/ CapVehCus_tillC = CAPCus[nextC];}
//							if (contTW == 0) {/*varvioTWC = varvioTWC_tillC;*/ cStartS_tillC = depart[nextC];}
//							GoThroughLegC2C(cal_tillC,cal_startC,nextC,cStartS_tillC,CapVehCus_tillC,varvioCAP_tillC,varvioTWC_tillC,contCAP,contTW);
//							cal_tillC = nextC; pos_cal_tillC = pos[nextC];
//							cal_startC = nextC_T;
//						}
//						//insert cusDi after nextC: for sure nextC_T > 0
//						cStartS = cStartS_tillC + problem->c[nextC][cusDi];
//						temp = cStartS - problem->node[cusDi].eTW;
//						if (temp > eps) {varvioTWC = varvioTWC_tillC + temp; cStartS = problem->node[cusDi].depart;}
//						else 
//						{
//							varvioTWC = varvioTWC_tillC;
//							cStartS = PDS_MAX(cStartS, problem->node[cusDi].sTW) + problem->node[cusDi].duration;
//						}
//						CapVehCus = CapVehCus_tillC + problem->node[cusDi].capacity;
//						tQ = CapVehCus - Q;
//						if (tQ > 0)
//						{
//							varvioCAP = varvioCAP_tillC + tQ; 
//							CapVehCus = Q;
//						}
//						else varvioCAP = varvioCAP_tillC;
//						if (cusDi == nextC_T)
//						{
//							//e.g. ...j,[1+,(2+,2-),1-], i,[3+,(4+,4-)3-] cusDi,cusDj,.... where pickID = 4+; nextC = 3-; 
//							//cout<<"TRUONG HOP NAY XAY RA ?????????????????????????????????????????????? "<<endl;
//							//Cal from cusDi till the end of the trip: i and cusDi doesn't belong to this segment:
//							nextC_T = next_cusDi; cal_startC = nextC_T; contCAP = 1; contTW = 1;
//							if (nextC_T > 0)
//							{
//								varcost = varcosti + problem->c[nextC][cusDi] + problem->c[cusDi][next_cusDi] - problem->c[nextC][next_cusDi];
//								if (GoThroughLegC2C(cusDi,nextC_T,cStartS,varvioTWC,CapVehCus,varvioCAP) == 0)
//								{
//									if (calChangeCONNECTAtSP_C2CTrip(lastC,idVeh,idTrip,nextT,cStartS,varvioTWSP,varcost) == 0) //seg[idVeh].Trip[nextT].leaveSP has changed
//										GoThroughVehicle(idVeh,nextT,varcost,varvioTWC,varvioTWSP,cStartS,nextSP,seg[idVeh].Trip[nextT].firstCus);
//								}
//							}
//							else //cusDi is still the last cus:
//							{
//								varcost = varcosti + problem->c[nextC][cusDi] + seg[idVeh].Trip[idTrip].connectCost;
//								if (calChangeCONNECTAtSP_C2CTrip(lastC,idVeh,idTrip,nextT,cStartS,varvioTWSP,varcost) == 0) //seg[idVeh].Trip[nextT].leaveSP has changed
//									GoThroughVehicle(idVeh,nextT,varcost,varvioTWC,varvioTWSP,cStartS,nextSP,seg[idVeh].Trip[nextT].firstCus);
//							}
//						}
//						else //cusDi != nextArr[nextC]
//						{
//							varcost = varcosti + problem->c[nextC][cusDi] + problem->c[cusDi][nextC_T] - problem->c[nextC][nextC_T];
//						    //i...pickID...nextC...cusDi
//							//cusDi belongs to the segment nextC...lastC: cusDi != nextArr[nextC]
//							//BEFORE MOVE: ....nextC...i..cusDi... OR ....i...[pickID...nextC]...cusDi
//							if (posiOLD < pos[nextC]) //before move: ....i...[pickID...nextC]...cusDi
//							{
//								/*cout<<"j = "<<j<<"; i = "<<i<<"; cusDi = "<<cusDi<<"; pickID = "<<pickID<<"; nextC = "<<nextC<<endl;
//								cout<<"TRIP is : "; showTripCus(idVeh,idTrip);
//								exit(-1);*/
//								//e.g.[1+.....1-=j], [pickID1.....nextC1], i, [pickID...nextC],[pickID2...nextC2],cusDi.....
//								contCAP1 = 1; contTW1 = 1;
//								GoThroughLegC2C(cusDi,nextC_T,pre_cusDi,cStartS,CapVehCus,varvioCAP,varvioTWC,contCAP1,contTW1);
//								if (next_cusDi > 0)
//								{
//									if (GoThroughLegC2C(pre_cusDi,next_cusDi,cStartS,varvioTWC,CapVehCus,varvioCAP) == 0) //GoThroughLegC2C(pre_cusDi,next_cusDi,lastC,cStartS,CapVehCus,varvioCAP,varvioTWC,contCAP1,contTW1);
//									{
//										if (calChangeCONNECTAtSP_C2CTrip(lastC,idVeh,idTrip,nextT,cStartS,varvioTWSP,varcost) == 0) //seg[idVeh].Trip[nextT].leaveSP has changed
//											GoThroughVehicle(idVeh,nextT,varcost,varvioTWC,varvioTWSP,cStartS,nextSP,seg[idVeh].Trip[nextT].firstCus);
//									}
//								}
//								else //pre_cusDi is now the last cus
//								{
//									if (calChangeCONNECTAtSP_C2CTrip_LastCChanged(pre_cusDi,idVeh,idTrip,nextT,cStartS,varvioTWSP,varcost)== 0) //seg[idVeh].Trip[nextT].leaveSP has changed
//										GoThroughVehicle(idVeh,nextT,varcost,varvioTWC,varvioTWSP,cStartS,nextSP,seg[idVeh].Trip[nextT].firstCus);
//								}
//							}
//							else // before move: ....nextC...i..cusDi...
//							{
//								if (nextC_T == i)	//...j....[pickID,...,nextID],[iOLD,......,cusDi]...
//								{
//									if (nexti == cusDi)
//									{
//										if (next_cusDi > 0)
//										{
//											//contCAP1 = 1; contTW1 = 1;
//											if (GoThroughLegC2C(cusDi,next_cusDi,cStartS,varvioTWC,CapVehCus,varvioCAP) == 0) //GoThroughLegC2C(pre_cusDi,next_cusDi,lastC,cStartS,CapVehCus,varvioCAP,varvioTWC,contCAP1,contTW1);
//											{
//												if (calChangeCONNECTAtSP_C2CTrip(lastC,idVeh,idTrip,nextT,cStartS,varvioTWSP,varcost) == 0) //seg[idVeh].Trip[nextT].leaveSP has changed
//													GoThroughVehicle(idVeh,nextT,varcost,varvioTWC,varvioTWSP,cStartS,nextSP,seg[idVeh].Trip[nextT].firstCus);
//											}
//										}
//										else //cusDi is still the last cus:????
//										{
//											if (calChangeCONNECTAtSP_C2CTrip(lastC,idVeh,idTrip,nextT,cStartS,varvioTWSP,varcost) == 0) //seg[idVeh].Trip[nextT].leaveSP has changed
//												GoThroughVehicle(idVeh,nextT,varcost,varvioTWC,varvioTWSP,cStartS,nextSP,seg[idVeh].Trip[nextT].firstCus);
//										}
//									}
//									else
//									{
//										contCAP1 = 1; contTW1 = 1;
//										GoThroughLegC2C(cusDi,nexti,pre_cusDi,cStartS,CapVehCus,varvioCAP,varvioTWC,contCAP1,contTW1);
//										if (next_cusDi > 0)
//										{	
//											if (GoThroughLegC2C(pre_cusDi,next_cusDi,cStartS,varvioTWC,CapVehCus,varvioCAP) == 0)
//											{
//												if (calChangeCONNECTAtSP_C2CTrip(lastC,idVeh,idTrip,nextT,cStartS,varvioTWSP,varcost) == 0) //seg[idVeh].Trip[nextT].leaveSP has changed
//													GoThroughVehicle(idVeh,nextT,varcost,varvioTWC,varvioTWSP,cStartS,nextSP,seg[idVeh].Trip[nextT].firstCus);
//											}
//										}
//										else //cusDi is still the last cus:
//										{
//											if (calChangeCONNECTAtSP_C2CTrip(lastC,idVeh,idTrip,nextT,cStartS,varvioTWSP,varcost) == 0) //seg[idVeh].Trip[nextT].leaveSP has changed
//												GoThroughVehicle(idVeh,nextT,varcost,varvioTWC,varvioTWSP,cStartS,nextSP,seg[idVeh].Trip[nextT].firstCus);
//										}
//									}
//								}
//								else //...j....[pickID,...,nextID],nextC_T,.....,[iOLD,......,cusDi]...
//								{
//									contCAP1 = 1; contTW1 = 1;
//									GoThroughLegC2C(cusDi,nextC_T,prei,cStartS,CapVehCus,varvioCAP,varvioTWC,contCAP1,contTW1);
//									if (nexti == cusDi)
//									{
//										if (next_cusDi > 0)
//										{
//											if (GoThroughLegC2C(prei,next_cusDi,cStartS,varvioTWC,CapVehCus,varvioCAP) == 0) //GoThroughLegC2C(pre_cusDi,next_cusDi,lastC,cStartS,CapVehCus,varvioCAP,varvioTWC,contCAP1,contTW1);
//											{
//												if (calChangeCONNECTAtSP_C2CTrip(lastC,idVeh,idTrip,nextT,cStartS,varvioTWSP,varcost) == 0) //seg[idVeh].Trip[nextT].leaveSP has changed
//													GoThroughVehicle(idVeh,nextT,varcost,varvioTWC,varvioTWSP,cStartS,nextSP,seg[idVeh].Trip[nextT].firstCus);
//											}
//										}
//										else //prei is now the last cus:
//										{
//											if (calChangeCONNECTAtSP_C2CTrip_LastCChanged(prei,idVeh,idTrip,nextT,cStartS,varvioTWSP,varcost)== 0) //seg[idVeh].Trip[nextT].leaveSP has changed
//												GoThroughVehicle(idVeh,nextT,varcost,varvioTWC,varvioTWSP,cStartS,nextSP,seg[idVeh].Trip[nextT].firstCus);
//										}
//									}
//									else
//									{
//										contCAP1 = 1; contTW1 = 1;
//										GoThroughLegC2C(prei,nexti,pre_cusDi,cStartS,CapVehCus,varvioCAP,varvioTWC,contCAP1,contTW1);
//										//Cal from nextArr[cusDi] ... lastCus
//										if (next_cusDi > 0)
//										{
//											//contCAP1 = 1; contTW1 = 1;
//											if (GoThroughLegC2C(pre_cusDi,next_cusDi,cStartS,varvioTWC,CapVehCus,varvioCAP) == 0) //GoThroughLegC2C(pre_cusDi,next_cusDi,lastC,cStartS,CapVehCus,varvioCAP,varvioTWC,contCAP1,contTW1);
//											{
//												if (calChangeCONNECTAtSP_C2CTrip(lastC,idVeh,idTrip,nextT,cStartS,varvioTWSP,varcost) == 0) //seg[idVeh].Trip[nextT].leaveSP has changed
//													GoThroughVehicle(idVeh,nextT,varcost,varvioTWC,varvioTWSP,cStartS,nextSP,seg[idVeh].Trip[nextT].firstCus);
//											}
//										}
//										else //pre_cusDi is now the last cus:
//										{
//											if (calChangeCONNECTAtSP_C2CTrip_LastCChanged(pre_cusDi,idVeh,idTrip,nextT,cStartS,varvioTWSP,varcost)== 0) //seg[idVeh].Trip[nextT].leaveSP has changed
//												GoThroughVehicle(idVeh,nextT,varcost,varvioTWC,varvioTWSP,cStartS,nextSP,seg[idVeh].Trip[nextT].firstCus);
//										}
//									}
//								}
//
//							}
//						}
//						obj = varcost + VCAP * varvioCAP + VTWCUS * varvioTWC + VTWSP * varvioTWSP;
//						if (obj < objMIN)
//						{
//							varcostMIN = varcost; varvioCAPMIN = varvioCAP; varvioTWCMIN = varvioTWC; 
//							objMIN = obj; varvioTWSPMIN = varvioTWSP;
//							insertAfter = nextC;
//						}
//					}//end 2) pos[nextC] belongs to [posi,poscusDi]: i...pickID...nextC...cusDi
//					nextC = nextC_T; //find another position to insert delID
//				}
//				else return; //pos[pickID] <= posi: doesn't exist any place to insert cusDi anymore
//			}//end nextC is not cusDi
//		}//end nextC is C2CD
//	}while (nextC > 0);
//
//
//}
//
//
//void Solution::SUBcal_InsertCusC2CIAfterJ_NotLastC_NextTripPORC2C(double depart_j, int CapCusj, int j, int i, int idVeh, int idTrip,double &varcostMIN, double &varvioTWCMIN, double &varvioTWSPMIN, int &varvioCAPMIN, int &insertAfter)
//{
//	//9/12/2013: insert C2CP i after j; then find place to insert delID of i such that minimize obj fitness: nextT is Ptrip OR C2C
//    //Same as cal_InsertCusC2CIAfterJ_NotLastC_NextD, cal_InsertCusC2CIAfterJ_NotLastC_LastTrip
//	//COPY SUBcal_InsertCusC2CIAfterJ_NotLastC_NextTripPORC2C_COPY
//
//	int cusDi = problem->node[i].delID;
//	int nextj = nextArr[j]; int nextT = idTrip + 1;
//	int lastC = seg[idVeh].Trip[idTrip].lastCus;
//	int CapVehCusi = CapCusj + problem->node[i].capacity;
//	int vioCapNEWi = 0; 
//	double vioTWCNEWi, temp, cStartS, obj, objMIN = PDS_INFINITY, varvioTWSP;
//    //Checking at i:
//	int tQ = CapVehCusi - Q;
//	if (tQ > 0) {vioCapNEWi = tQ; CapVehCusi = Q;}
//	double varcosti = problem->c[j][i] + problem->c[i][nextj] - problem->c[j][nextj];
//	double departi = depart_j + problem->c[j][i];
//	temp = departi - problem->node[i].eTW;
//	if (temp > eps)
//	{
//		vioTWCNEWi = temp;
//		departi = problem->node[i].depart;
//	}
//	else {vioTWCNEWi = 0; departi = PDS_MAX(departi, problem->node[i].sTW) + problem->node[i].duration;}
//  
//	//1. Insert CusDi right after i
//	int varvioCAP = vioCapNEWi; double varvioTWC = vioTWCNEWi;varvioTWSP = 0;
//	int CapVehCus = CapVehCusi + problem->node[cusDi].capacity;
//	tQ = CapVehCus - Q;
//	if (tQ > 0) {varvioCAP += tQ; CapVehCus = Q;}
//	
//	cStartS = departi + problem->c[i][cusDi];
//	temp = cStartS - problem->node[cusDi].eTW;
//	if (temp > eps) {varvioTWC += temp; cStartS = problem->node[cusDi].depart;}
//	else cStartS = PDS_MAX(cStartS, problem->node[cusDi].sTW) + problem->node[cusDi].duration;
//    double varcost = varcosti + problem->c[i][cusDi] + problem->c[cusDi][nextj] - problem->c[i][nextj];
//	if (GoThroughLegC2C(cusDi,nextj,cStartS,varvioTWC,CapVehCus,varvioCAP) == 0) //depart[lastC of the trip] has changed 
//	{
//		GoThroughVehicle(idVeh,nextT,varcost,varvioTWC,varvioTWSP,cStartS,lastC,seg[idVeh].Trip[nextT].firstCus);
//	}
//	obj = varcost + VCAP * varvioCAP + VTWCUS * varvioTWC + VTWSP * varvioTWSP;
//	if (obj < objMIN)
//	{
//		varcostMIN = varcost; varvioCAPMIN = varvioCAP; varvioTWCMIN = varvioTWC; varvioTWSPMIN = varvioTWSP;
//		objMIN = obj; 
//		insertAfter = i;
//	}
//
//	//2. Find place to insert cusDi starting from position after nextj:
//	int posi = pos[j];
//	int nextC = nextj; 
//	int cal_tillC = i; int pos_cal_tillC = posi; int cal_startC = nextC; 
//	int varvioCAP_tillC = vioCapNEWi; double varvioTWC_tillC = vioTWCNEWi;
//	int CapVehCus_tillC = CapVehCusi; double cStartS_tillC = departi;
//	int pickID;
//	bool contCAP = 1; bool contTW = 1;
//	do
//	{
//		if (nextC < problem->startidC2CD) //nextC is C2CP
//			nextC = problem->node[nextC].delID; //jump to delID of nextC
//		else //nextC is C2CD
//		{
//			pickID = problem->node[nextC].pickID;
//			if (pos[pickID] > posi)
//			{
//				//Insert cusDi after nextC:
//				int nextC_T = nextArr[nextC]; varvioTWSP = 0;
//				if (pos_cal_tillC < pos[nextC]) //need to calculate vioTWC and vioCAP till nextC:
//				{
//					//Calculate from cal_startC to nextC after i already inserted into the trip after j:
//					if (contCAP == 0) {/*varvioCAP = varvioCAP_tillC;*/ CapVehCus_tillC = CAPCus[nextC];}
//					if (contTW == 0) {/*varvioTWC = varvioTWC_tillC;*/ cStartS_tillC = depart[nextC];}
//					GoThroughLegC2C(cal_tillC,cal_startC,nextC,cStartS_tillC,CapVehCus_tillC,varvioCAP_tillC,varvioTWC_tillC,contCAP,contTW);
//					cal_tillC = nextC; pos_cal_tillC = pos[nextC];
//					cal_startC = nextC_T;
//				}//end if (pos_cal_tillC < pos[nextC])
//				//Now insert cusDi after nextC:
//				if (nextC_T > 0) //insert cusDi after nextC which is not the last cus of the trip
//				{
//					cStartS = cStartS_tillC + problem->c[nextC][cusDi];
//					temp = cStartS - problem->node[cusDi].eTW;
//					if (temp > eps) {varvioTWC = varvioTWC_tillC + temp; cStartS = problem->node[cusDi].depart;}
//					else 
//					{
//						varvioTWC = varvioTWC_tillC;
//						cStartS = PDS_MAX(cStartS, problem->node[cusDi].sTW) + problem->node[cusDi].duration;
//					}
//					CapVehCus = CapVehCus_tillC + problem->node[cusDi].capacity;
//					tQ = CapVehCus - Q;
//					if (tQ > 0)
//					{
//						varvioCAP = varvioCAP_tillC + tQ; 
//						CapVehCus = Q;
//					}
//					else varvioCAP = varvioCAP_tillC;
//
//					varcost = varcosti + problem->c[nextC][cusDi] + problem->c[cusDi][nextC_T] - problem->c[nextC][nextC_T];
//					//Cal from cusDi till the end of the trip:
//					if (GoThroughLegC2C(cusDi,nextC_T,cStartS,varvioTWC,CapVehCus,varvioCAP) == 0) //depart[lastC of the trip] has changed 
//					{
//						GoThroughVehicle(idVeh,nextT,varcost,varvioTWC,varvioTWSP,cStartS,lastC,seg[idVeh].Trip[nextT].firstCus);
//					}
//					obj = varcost + VCAP * varvioCAP + VTWCUS * varvioTWC + VTWSP * varvioTWSP;
//					if (obj < objMIN)
//					{
//						varcostMIN = varcost; varvioCAPMIN = varvioCAP; varvioTWCMIN = varvioTWC; varvioTWSPMIN = varvioTWSP; 
//						objMIN = obj; 
//						insertAfter = nextC;
//					}
//				}
//				else //insert cusDi at the end of the trip:
//				{
//					cStartS = cStartS_tillC + problem->c[nextC][cusDi];
//					temp = cStartS - problem->node[cusDi].eTW;
//					if (temp > eps) varvioTWC = varvioTWC_tillC + temp;
//					else varvioTWC = varvioTWC_tillC;
//					//don't need varvioCAP because insert cusDi at the end of the trip
//					varcost = varcosti + problem->c[nextC][cusDi] + problem->c[cusDi][0] - problem->c[nextC][0];
//                    /*if (seg[idVeh].Trip[idTrip].waitingS == NO_WS) varcost -= problem->c[lastC][nextSP];
//					else varcost -= problem->disCWSSP[lastC][nextSP];*/
//					varcost -= seg[idVeh].Trip[idTrip].connectCost;
//					GoThroughVehicle(idVeh,nextT,varcost,varvioTWC,varvioTWSP,cStartS,cusDi,seg[idVeh].Trip[nextT].firstCus);
//					obj = varcost + VCAP * varvioCAP_tillC + VTWCUS * varvioTWC + VTWSP * varvioTWSP;
//					if (obj < objMIN)
//					{
//						varcostMIN = varcost; varvioCAPMIN = varvioCAP_tillC; varvioTWCMIN = varvioTWC; varvioTWSPMIN = varvioTWSP; 
//						objMIN = obj; 
//						insertAfter = nextC;
//					}
//					break; //finish the trip
//				}//end insert cusDi after nextC which is the last cus of the trip
//				nextC = nextC_T; //find another position to insert delID
//			}
//			else // (pos[pickID] <= posi)
//				break; //doesn't exist any place to insert cusDi anymore
//		}//end nextC is C2CD
//	}while (nextC > 0);
//}
//
//void Solution::SUBcal_InsertCusC2CIAfterJ_NotLastC_NextTripPORC2C_COPY(double depart_j, int CapCusj, int j, int i, int idVeh, int idTrip,double &varcostMIN, double &varvioTWCMIN, double &varvioTWSPMIN, int &varvioCAPMIN, bool &stopMIN, double &cStartS, int &insertAfter, int update_idTrip)
//{
//	//9/12/2013: insert C2CP i after j; then find place to insert delID of i such that minimize obj fitness: nextT is Ptrip OR C2C
//    //Same as cal_InsertCusC2CIAfterJ_NotLastC_NextD, cal_InsertCusC2CIAfterJ_NotLastC_LastTrip
//	//COPY SUBcal_InsertCusC2CIAfterJ_NotLastC_NextTripPORC2C
//	int numTrips_update = update_idTrip - idTrip;
//
//	int cusDi = problem->node[i].delID; bool stop;
//	int nextj = nextArr[j]; int nextT = idTrip + 1;
//	int lastC = seg[idVeh].Trip[idTrip].lastCus;
//	int CapVehCusi = CapCusj + problem->node[i].capacity;
//	int vioCapNEWi = 0; 
//	double vioTWCNEWi, temp, obj, objMIN = PDS_INFINITY, varvioTWSP;
//    //Checking at i:
//	int tQ = CapVehCusi - Q;
//	if (tQ > 0) {vioCapNEWi = tQ; CapVehCusi = Q;}
//	double varcosti = problem->c[j][i] + problem->c[i][nextj] - problem->c[j][nextj];
//	double departi = depart_j + problem->c[j][i];
//	temp = departi - problem->node[i].eTW;
//	if (temp > eps)
//	{
//		vioTWCNEWi = temp;
//		departi = problem->node[i].depart;
//	}
//	else {vioTWCNEWi = 0; departi = PDS_MAX(departi, problem->node[i].sTW) + problem->node[i].duration;}
//  
//	//1. Insert CusDi right after i
//	int varvioCAP = vioCapNEWi; double varvioTWC = vioTWCNEWi;varvioTWSP = 0;
//	int CapVehCus = CapVehCusi + problem->node[cusDi].capacity;
//	tQ = CapVehCus - Q;
//	if (tQ > 0) {varvioCAP += tQ; CapVehCus = Q;}
//	
//	cStartS = departi + problem->c[i][cusDi];
//	temp = cStartS - problem->node[cusDi].eTW;
//	if (temp > eps) {varvioTWC += temp; cStartS = problem->node[cusDi].depart;}
//	else cStartS = PDS_MAX(cStartS, problem->node[cusDi].sTW) + problem->node[cusDi].duration;
//    double varcost = varcosti + problem->c[i][cusDi] + problem->c[cusDi][nextj] - problem->c[i][nextj];
//	stop = 1;
//	if (GoThroughLegC2C(cusDi,nextj,cStartS,varvioTWC,CapVehCus,varvioCAP) == 0) //depart[lastC of the trip] has changed 
//	{
//		//Quangnn+-
//		//stop = GoThroughVehicle(idVeh,nextT,numTrips_update,varcost,varvioTWC,varvioTWSP,cStartS,lastC,seg[idVeh].Trip[nextT].firstCus);
//	}
//	obj = varcost + VCAP * varvioCAP + VTWCUS * varvioTWC + VTWSP * varvioTWSP;
//	if (obj < objMIN)
//	{
//		varcostMIN = varcost; varvioCAPMIN = varvioCAP; varvioTWCMIN = varvioTWC; varvioTWSPMIN = varvioTWSP;
//		objMIN = obj; stopMIN = stop;
//		insertAfter = i;
//	}
//
//	//2. Find place to insert cusDi starting from position after nextj:
//	int posi = pos[j];
//	int nextC = nextj; 
//	int cal_tillC = i; int pos_cal_tillC = posi; int cal_startC = nextC; 
//	int varvioCAP_tillC = vioCapNEWi; double varvioTWC_tillC = vioTWCNEWi;
//	int CapVehCus_tillC = CapVehCusi; double cStartS_tillC = departi;
//	int pickID;
//	bool contCAP = 1; bool contTW = 1;
//	do
//	{
//		if (nextC < problem->startidC2CD) //nextC is C2CP
//			nextC = problem->node[nextC].delID; //jump to delID of nextC
//		else //nextC is C2CD
//		{
//			pickID = problem->node[nextC].pickID;
//			if (pos[pickID] > posi)
//			{
//				//Insert cusDi after nextC:
//				int nextC_T = nextArr[nextC]; varvioTWSP = 0;
//				if (pos_cal_tillC < pos[nextC]) //need to calculate vioTWC and vioCAP till nextC:
//				{
//					//Calculate from cal_startC to nextC after i already inserted into the trip after j:
//					if (contCAP == 0) {/*varvioCAP = varvioCAP_tillC;*/ CapVehCus_tillC = CAPCus[nextC];}
//					if (contTW == 0) {/*varvioTWC = varvioTWC_tillC;*/ cStartS_tillC = depart[nextC];}
//					GoThroughLegC2C(cal_tillC,cal_startC,nextC,cStartS_tillC,CapVehCus_tillC,varvioCAP_tillC,varvioTWC_tillC,contCAP,contTW);
//					cal_tillC = nextC; pos_cal_tillC = pos[nextC];
//					cal_startC = nextC_T;
//				}//end if (pos_cal_tillC < pos[nextC])
//				//Now insert cusDi after nextC:
//				if (nextC_T > 0) //insert cusDi after nextC which is not the last cus of the trip
//				{
//					cStartS = cStartS_tillC + problem->c[nextC][cusDi];
//					temp = cStartS - problem->node[cusDi].eTW;
//					if (temp > eps) {varvioTWC = varvioTWC_tillC + temp; cStartS = problem->node[cusDi].depart;}
//					else 
//					{
//						varvioTWC = varvioTWC_tillC;
//						cStartS = PDS_MAX(cStartS, problem->node[cusDi].sTW) + problem->node[cusDi].duration;
//					}
//					CapVehCus = CapVehCus_tillC + problem->node[cusDi].capacity;
//					tQ = CapVehCus - Q;
//					if (tQ > 0)
//					{
//						varvioCAP = varvioCAP_tillC + tQ; 
//						CapVehCus = Q;
//					}
//					else varvioCAP = varvioCAP_tillC;
//
//					varcost = varcosti + problem->c[nextC][cusDi] + problem->c[cusDi][nextC_T] - problem->c[nextC][nextC_T];
//					//Cal from cusDi till the end of the trip:
//					stop = 1;
//					if (GoThroughLegC2C(cusDi,nextC_T,cStartS,varvioTWC,CapVehCus,varvioCAP) == 0) //depart[lastC of the trip] has changed 
//					{
//						//Quangnn+-
//						//stop = GoThroughVehicle(idVeh,nextT,numTrips_update,varcost,varvioTWC,varvioTWSP,cStartS,lastC,seg[idVeh].Trip[nextT].firstCus);
//					}
//					obj = varcost + VCAP * varvioCAP + VTWCUS * varvioTWC + VTWSP * varvioTWSP;
//					if (obj < objMIN)
//					{
//						varcostMIN = varcost; varvioCAPMIN = varvioCAP; varvioTWCMIN = varvioTWC; varvioTWSPMIN = varvioTWSP; 
//						objMIN = obj; stopMIN = stop;
//						insertAfter = nextC;
//					}
//				}
//				else //insert cusDi at the end of the trip:
//				{
//					cStartS = cStartS_tillC + problem->c[nextC][cusDi];
//					temp = cStartS - problem->node[cusDi].eTW;
//					if (temp > eps) varvioTWC = varvioTWC_tillC + temp;
//					else varvioTWC = varvioTWC_tillC;
//					//don't need varvioCAP because insert cusDi at the end of the trip
//					varcost = varcosti + problem->c[nextC][cusDi] + problem->c[cusDi][0] - problem->c[nextC][0];
//                    /*if (seg[idVeh].Trip[idTrip].waitingS == NO_WS) varcost -= problem->c[lastC][nextSP];
//					else varcost -= problem->disCWSSP[lastC][nextSP];*/
//					varcost -= seg[idVeh].Trip[idTrip].connectCost;
//					//Quangnn+-
//					//stop = GoThroughVehicle(idVeh,nextT,numTrips_update,varcost,varvioTWC,varvioTWSP,cStartS,cusDi,seg[idVeh].Trip[nextT].firstCus);
//					obj = varcost + VCAP * varvioCAP_tillC + VTWCUS * varvioTWC + VTWSP * varvioTWSP;
//					if (obj < objMIN)
//					{
//						varcostMIN = varcost; varvioCAPMIN = varvioCAP_tillC; varvioTWCMIN = varvioTWC; varvioTWSPMIN = varvioTWSP; 
//						objMIN = obj; stopMIN = stop;
//						insertAfter = nextC;
//					}
//					break; //finish the trip
//				}//end insert cusDi after nextC which is the last cus of the trip
//				nextC = nextC_T; //find another position to insert delID
//			}
//			else // (pos[pickID] <= posi)
//				break; //doesn't exist any place to insert cusDi anymore
//		}//end nextC is C2CD
//	}while (nextC > 0);
//}
//
//
//void Solution::SUBcal_InsertCusC2CIAfterJ_NotLastC_delIDIN_NextTripPORC2C(double depart_j, int CAPCusj, int j, int i, int idVeh, int idTrip, double &varcostMIN, double &varvioTWCMIN, double &varvioTWSPMIN, int &varvioCAPMIN, int &insertAfter)
//{
//	//14/12/1014: COPY SUBcal_InsertCusC2CIAfterJ_NotLastC_delIDIN_nextD, SUBcal_InsertCusC2CIAfterJ_NotLastC_LastTrip_delIDIN
//	//different from SUBcal_InsertCusC2CIAfterJ_NotLastC_nextTripPORC2C: 
//	//in this procedure cusDi belongs to the segment [j..lastC]; while in procedure SUBcal_InsertCusC2CIAfterJ_NotLastC_nextTripPORC2C, cusDi doesn't belong to this segment
//
//	int cusDi = problem->node[i].delID;
//	int posCusDi = pos[cusDi]; int pre_cusDi = predArr[cusDi]; int next_cusDi = nextArr[cusDi];
//	int nextj = nextArr[j]; int nextT = idTrip + 1;
//	int lastC = seg[idVeh].Trip[idTrip].lastCus;
//	int CapVehCusi = CAPCusj + problem->node[i].capacity;
//	int vioCapNEWi = 0; 
//	double vioTWCNEWi, temp, cStartS, obj, objMIN = PDS_INFINITY;
//    //Checking at i:
//	int tQ = CapVehCusi - Q;
//	if (tQ > 0) {vioCapNEWi = tQ; CapVehCusi = Q;}
//	int firstC_nextT = seg[idVeh].Trip[nextT].firstCus;
//	double varcostii = problem->c[j][i] + problem->c[i][nextj] - problem->c[j][nextj];	//when calling this procedure for sure nexti != cusDi: cusDi is NOT direct successor of i
//	double varcosti;
//	if (next_cusDi > 0)
//		varcosti = varcostii + (problem->c[pre_cusDi][next_cusDi] - problem->c[pre_cusDi][cusDi] - problem->c[cusDi][next_cusDi]);
//	else
//		varcosti = varcostii + (problem->c[pre_cusDi][firstC_nextT] - (problem->c[pre_cusDi][cusDi] + problem->c[cusDi][firstC_nextT]));
//
//	double departi = depart_j + problem->c[j][i];
//	temp = departi - problem->node[i].eTW;
//	if (temp > eps)
//	{
//		vioTWCNEWi = temp;
//		departi = problem->node[i].depart;
//	}
//	else {vioTWCNEWi = 0; departi = PDS_MAX(departi, problem->node[i].sTW) + problem->node[i].duration;}
//  
//	//1. Insert CusDi right after i
//	int varvioCAP = vioCapNEWi; double varvioTWC = vioTWCNEWi; double varvioTWSP = 0;
//	int CapVehCus = CapVehCusi + problem->node[cusDi].capacity;
//	tQ = CapVehCus - Q;
//	if (tQ > 0) {varvioCAP += tQ; CapVehCus = Q;}
//	
//	cStartS = departi + problem->c[i][cusDi];
//	temp = cStartS - problem->node[cusDi].eTW;
//	if (temp > eps) {varvioTWC += temp; cStartS = problem->node[cusDi].depart;}
//	else cStartS = PDS_MAX(cStartS, problem->node[cusDi].sTW) + problem->node[cusDi].duration;
//	double varcost;
//	int wherecusDi = 1;
//	bool contCAP, contTW, STOP = 0;
//
//	if (cusDi == nextj) //cusDi is already after i
//	{
//		varcost = varcostii;
//		nextj = nextArr[nextj];
//		if (nextj > 0) 
//		{
//			if (GoThroughLegC2C(cusDi,nextj, cStartS,varvioTWC,CapVehCus,varvioCAP) == 0) //fore sure nextj > 0; depart lastC has changed
//				GoThroughVehicle(idVeh,nextT,varcost,varvioTWC,varvioTWSP,cStartS,lastC, firstC_nextT);
//		}
//		else //cusDi was the last cus
//		{
//			if (PDSDIF(cStartS,depart[cusDi]) == 0) varcost += seg[idVeh].Trip[idTrip].cost;
//			else //depart lastC has changed
//				GoThroughVehicle(idVeh,nextT,varcost,varvioTWC,varvioTWSP,cStartS,cusDi,firstC_nextT);
//			STOP = 1;
//		}
//		wherecusDi = 0;
//	}
//	else //cusDi != nextj
//	{
//		varcost = varcosti + problem->c[i][cusDi] + problem->c[cusDi][nextj] - problem->c[i][nextj];
//		//cusDi belongs to nextArr[nextj]...lastC:
//		contCAP = 1; contTW = 1;
//		GoThroughLegC2C(cusDi,nextj,pre_cusDi,cStartS,CapVehCus,varvioCAP,varvioTWC,contCAP,contTW);
//		contCAP = 1; contTW = 1;
//		if (next_cusDi > 0)
//		{
//			if (GoThroughLegC2C(pre_cusDi,next_cusDi, cStartS,varvioTWC,CapVehCus,varvioCAP) == 0) //fore sure nextj > 0; depart lastC has changed
//			{
//				GoThroughVehicle(idVeh,nextT,varcost,varvioTWC,varvioTWSP,cStartS,lastC,firstC_nextT);
//			}
//		}
//		else //cusDi was the last cus --> now pre_cusDi is the last cus
//			GoThroughVehicle(idVeh,nextT,varcost,varvioTWC,varvioTWSP,cStartS,pre_cusDi,firstC_nextT);
//	}
//
//	obj = varcost + VCAP * varvioCAP + VTWCUS * varvioTWC + VTWSP * varvioTWSP;
//	if (obj < objMIN)
//	{
//		varcostMIN = varcost; varvioCAPMIN = varvioCAP; varvioTWCMIN = varvioTWC; varvioTWSPMIN = varvioTWSP;
//		objMIN = obj;
//		insertAfter = i;
//	}
//
//	//2. Find place to insert cusDi starting from position after nextj: NOTE that cusDi may already exist somewhere else in the segment from nextj ... lastC
//	if (STOP) return; //this case: Trip before move: [...i.....j,cusDi] where cusDi is the last cus of the trip --> don't exist any other place to insert cusDi
//
//	int posi = pos[j];
//	int nextC = nextj; 
//	int cal_tillC = i; int pos_cal_tillC = posi; int cal_startC = nextC; 
//	int varvioCAP_tillC = vioCapNEWi; double varvioTWC_tillC = vioTWCNEWi;
//	int CapVehCus_tillC = CapVehCusi; double cStartS_tillC = departi;
//	int pickID;
//	contCAP = 1; contTW = 1;
//
//	do
//	{
//		if (nextC < problem->startidC2CD) //nextC is C2CP
//			nextC = problem->node[nextC].delID; //jump to delID of nextC
//		else //nextC is C2CD
//		{
//				pickID = problem->node[nextC].pickID;
//			    if (i == pickID) //nextC is cusDi
//				{
//					//if it is here it means:  ...i(P+....P-=j)cusDi... --> ...(P+....P-)i cusDi...
//					//--?already calculate before in //1. Insert CusDi right after i
//					/*int preCT = predArr[nextC];
//					if (preCT != j)
//					{
//						cout<<"There is the case of C2Ctrip for moveCusC2C that I don't know it could happen: ";
//						showTripCus(idVeh,idTrip);
//						cout<<"Insert C2CP = "<<i<<" and its C2CD = "<<cusDi<<" after j = "<<j<<endl;
//						cout<<"It is now trying to insert C2CD("<<cusDi<<") after C2CD = "<<nextC<<endl;
//						exit(-1);
//					}*/
//					nextC = nextArr[nextC];
//					cal_startC = nextC;
//				}
//				else if (pos[pickID] > posi)
//				{
//					//Insert cusDi after nextC:
//					int nextC_T = nextArr[nextC];
//					if (wherecusDi != 0)
//					{
//						if (posCusDi < pos_cal_tillC) wherecusDi = 1;
//						else if (posCusDi > pos[nextC]) wherecusDi = 2;
//						else wherecusDi = 3;
//					}
//					if (pos_cal_tillC < pos[nextC]) //need to calculate vioTWC and vioCAP till nextC:
//					{
//						//Calculate from cal_startC to nextC after i already inserted into the trip after j:
//						if (wherecusDi < 3) //(posCusDi < pos_cal_tillC || posCusDi > pos[nextC])
//						{
//							if (contCAP == 0) {/*varvioCAP = varvioCAP_tillC;*/ CapVehCus_tillC = CAPCus[nextC];}
//							if (contTW == 0) {/*varvioTWC = varvioTWC_tillC;*/ cStartS_tillC = depart[nextC];}
//							GoThroughLegC2C(cal_tillC,cal_startC,nextC,cStartS_tillC,CapVehCus_tillC,varvioCAP_tillC,varvioTWC_tillC,contCAP,contTW);
//						}
//						else //cusDi belongs to cal_startC ... nextC
//						{
//							if (pre_cusDi == cal_tillC)
//							{
//								//...cal_tillC, cusDi, cal_startC.... nextC
//								GoThroughLegC2C(cal_tillC,cal_startC,nextC,cStartS_tillC,CapVehCus_tillC,varvioCAP_tillC,varvioTWC_tillC,contCAP,contTW);
//							}
//							else
//							{
//								if (contCAP == 0) {/*varvioCAP = varvioCAP_tillC;*/ CapVehCus_tillC = CAPCus[pre_cusDi]; contCAP = 1;}
//								if (contTW == 0) {/*varvioTWC = varvioTWC_tillC;*/ cStartS_tillC = depart[pre_cusDi]; contTW = 1;}
//								GoThroughLegC2C(cal_tillC,cal_startC,pre_cusDi,cStartS_tillC,CapVehCus_tillC,varvioCAP_tillC,varvioTWC_tillC,contCAP,contTW);
//								GoThroughLegC2C(pre_cusDi,next_cusDi,nextC,cStartS_tillC,CapVehCus_tillC,varvioCAP_tillC,varvioTWC_tillC,contCAP,contTW);
//							}
//						}//end cusDi belongs to start_tillC ... nextC
//						cal_tillC = nextC;	
//						pos_cal_tillC = pos[nextC];
//						cal_startC = nextC_T;
//					}//end if (pos_cal_tillC < pos[nextC])
//					//Now insert cusDi after nextC:
//					varvioTWSP = 0;
//					if (nextC_T > 0) //insert cusDi after nextC which is not the last cus of the trip
//					{
//						cStartS = cStartS_tillC + problem->c[nextC][cusDi];
//						temp = cStartS - problem->node[cusDi].eTW;
//						if (temp > eps) {varvioTWC = varvioTWC_tillC + temp; cStartS = problem->node[cusDi].depart;}
//						else 
//						{
//							varvioTWC = varvioTWC_tillC;
//							cStartS = PDS_MAX(cStartS, problem->node[cusDi].sTW) + problem->node[cusDi].duration;
//						}
//						CapVehCus = CapVehCus_tillC + problem->node[cusDi].capacity;
//						tQ = CapVehCus - Q;
//						if (tQ > 0)
//						{
//							varvioCAP = varvioCAP_tillC + tQ; 
//							CapVehCus = Q;
//						}
//						else varvioCAP = varvioCAP_tillC;
//
//						if (cusDi == nextC_T)
//						{
//							if (next_cusDi > 0)
//								varcost = varcosti + problem->c[nextC][cusDi] + problem->c[cusDi][next_cusDi] - problem->c[nextC][next_cusDi];
//							else
//								varcost = varcosti + problem->c[nextC][cusDi] + problem->c[cusDi][firstC_nextT] - problem->c[nextC][firstC_nextT];
//						}
//						else
//						   varcost = varcosti + problem->c[nextC][cusDi] + problem->c[cusDi][nextC_T] - problem->c[nextC][nextC_T];
//						//Cal from cusDi till the end of the trip:
//						if (wherecusDi == 2) //posCusDi > pos[nextC]: cusDi belongs to nextC_T ... lastcus
//						{
//							if (cusDi == nextC_T)
//							{
//								nextC_T = next_cusDi;
//							    cal_startC = nextC_T; //pos_call_tillC++;
//								contCAP = 1; contTW = 1;
//								if (nextC_T > 0)
//								{
//									if (GoThroughLegC2C(cusDi,nextC_T,cStartS,varvioTWC,CapVehCus,varvioCAP) == 0) //depart lastC has changed
//									{
//										GoThroughVehicle(idVeh,nextT,varcost,varvioTWC,varvioTWSP,cStartS,lastC,firstC_nextT);
//									}
//								}
//								else //cusDi was the last cus; now still the last cus
//								{
//									if (PDSDIF(cStartS,depart[cusDi])) //depart lastC has changed
//									{
//										GoThroughVehicle(idVeh,nextT,varcost,varvioTWC,varvioTWSP,cStartS,cusDi,firstC_nextT);
//									}
//								}
//							}
//							else //cusDi belongs to nextC_T+1 ... lastCus
//							{
//								//Cal from nextC_T ... predArr[cusDi]:
//								bool contCAP1 = 1; bool contTW1 = 1; 
//								GoThroughLegC2C(cusDi,nextC_T,pre_cusDi,cStartS,CapVehCus,varvioCAP,varvioTWC,contCAP1,contTW1);
//								//Cal from nextArr[cusDi] ... lastCus
//								if (next_cusDi > 0)
//								{
//									if (GoThroughLegC2C(pre_cusDi, next_cusDi,cStartS,varvioTWC,CapVehCus,varvioCAP) == 0) //depart lastC has changed
//									{
//										GoThroughVehicle(idVeh,nextT,varcost,varvioTWC,varvioTWSP,cStartS,lastC, firstC_nextT);
//									}
//								}
//								else //cusDi was the last cus, now pre_cusDi is the last cus
//								{
//									GoThroughVehicle(idVeh,nextT,varcost,varvioTWC,varvioTWSP,cStartS,pre_cusDi, firstC_nextT);
//								}
//							}
//						}
//						else //cusDi doesn't belong to the nextC
//						{
//							if (GoThroughLegC2C(cusDi,nextC_T,cStartS,varvioTWC,CapVehCus,varvioCAP) == 0)
//							{
//								GoThroughVehicle(idVeh,nextT,varcost,varvioTWC,varvioTWSP,cStartS,lastC,firstC_nextT);
//							}
//						}
//						obj = varcost + VCAP * varvioCAP + VTWCUS * varvioTWC + VTWSP * varvioTWSP;
//						if (obj < objMIN)
//						{
//							varcostMIN = varcost; varvioCAPMIN = varvioCAP; varvioTWCMIN = varvioTWC; varvioTWSPMIN = varvioTWSP; 
//							objMIN = obj;
//							insertAfter = nextC;
//						}
//					}
//					else //insert cusDi at the end of the trip:
//					{
//						cStartS = cStartS_tillC + problem->c[nextC][cusDi];
//						temp = cStartS - problem->node[cusDi].eTW;
//						if (temp > eps)
//						{
//							varvioTWC = varvioTWC_tillC + temp;
//							cStartS = problem->node[cusDi].depart;
//						}
//						else
//						{
//							varvioTWC = varvioTWC_tillC;
//							cStartS = PDS_MAX(cStartS, problem->node[cusDi].sTW) + problem->node[cusDi].duration;
//						}
//						//don't need varvioCAP because insert cusDi at the end of the trip
//						varcost = varcosti + problem->c[nextC][cusDi] + problem->c[cusDi][firstC_nextT] - problem->c[nextC][firstC_nextT];
//						GoThroughVehicle(idVeh,nextT,varcost,varvioTWC,varvioTWSP,cStartS,cusDi, firstC_nextT);
//
//						obj = varcost + VCAP * varvioCAP_tillC + VTWCUS * varvioTWC + VTWSP * varvioTWSP;
//						if (obj < objMIN)
//						{
//							varcostMIN = varcost; varvioCAPMIN = varvioCAP_tillC; varvioTWCMIN = varvioTWC; 
//							objMIN = obj; varvioTWSPMIN = varvioTWSP;
//							insertAfter = nextC;
//						}
//						return; //finish the trip
//					}//end insert cusDi after nextC which is the last cus of the trip
//					nextC = nextC_T; //find another position to insert delID
//				}
//				else // (pos[pickID] <= posi)
//					return; //break; //doesn't exist any place to insert cusDi anymore
//		}//end nextC is C2CD
//	}while (nextC > 0);
//
//}
//
//void Solution::SUBcal_InsertCusC2CIAfterJ_NotLastC_iANDdelIDIN_NextTripPORC2C(double depart_j, int CAPCusj, int j, int i, int idVeh, int idTrip, double &varcostMIN, double &varvioTWCMIN, double &varvioTWSPMIN, int &varvioCAPMIN, int &insertAfter)
//{
//	//14/12/2013: different from SUBcal_InsertCusC2CIAfterJ_NotLastC_nextTripPORC2C: 
//	//in this procedure i and cusDi belongs to the segment [j..lastC]; while in procedure SUBcal_InsertCusC2CIAfterJ_NotLastC_nextTripPORC2C, they dont belong to this segment
//    //for sure: next[j] != i
//	//COPY SUBcal_InsertCusC2CIAfterJ_NotLastC_lastTrip_iANDdelIDIN, SUBcal_InsertCusC2CIAfterJ_NotLastC_iANDdelIDIN_NextD
//
//	//14/12/2013: different from SUBcal_InsertCusC2CIAfterJ_NotLastC_nextD: 
//	//in this procedure i and cusDi belongs to the segment [j..lastC]; while in procedure SUBcal_InsertCusC2CIAfterJ_NotLastC_nextD, they dont belong to this segment
//    //for sure: next[j] != i
//	//COPY SUBcal_InsertCusC2CIAfterJ_NotLastC_lastTrip_iANDdelIDIN, SUBcal_InsertCusC2CIAfterJ_NotLastC_iANDdelIDIN_NextTripPORD
//
//	int prei = predArr[i]; int nexti = nextArr[i];
//	int cusDi = problem->node[i].delID; 
//	int nextT = idTrip + 1; int firstC_nextT = seg[idVeh].Trip[nextT].firstCus;
//	int posCusDi = pos[cusDi]; int pre_cusDi = predArr[cusDi]; int next_cusDi = nextArr[cusDi];
//	int nextj = nextArr[j];
//	int lastC = seg[idVeh].Trip[idTrip].lastCus;
//	int CapVehCusi = CAPCusj + problem->node[i].capacity;
//	int vioCapNEWi = 0; 
//	double vioTWCNEWi, temp, cStartS, obj, objMIN = PDS_INFINITY;
//    //Checking at i:
//	int tQ = CapVehCusi - Q;
//	if (tQ > 0) {vioCapNEWi = tQ; CapVehCusi = Q;}
//	double varcosti = problem->c[j][i] + problem->c[i][nextj] - problem->c[j][nextj];
//	if (nexti == cusDi)
//	{
//		if (next_cusDi > 0)
//			varcosti += (problem->c[prei][next_cusDi] - problem->c[prei][i] - problem->c[i][cusDi] - problem->c[cusDi][next_cusDi]);
//		else
//			varcosti -= (problem->c[prei][i] + problem->c[i][cusDi] + seg[idVeh].Trip[idTrip].connectCost);
//	}
//	else
//	{
//		varcosti += (problem->c[prei][nexti] - problem->c[prei][i] - problem->c[i][nexti]);
//		if (next_cusDi > 0)
//			varcosti += (problem->c[pre_cusDi][next_cusDi] - problem->c[pre_cusDi][cusDi] - problem->c[cusDi][next_cusDi]);
//		else
//			varcosti -= (problem->c[pre_cusDi][cusDi] + seg[idVeh].Trip[idTrip].connectCost);
//	}
//
//	double departi = depart_j + problem->c[j][i];
//	temp = departi - problem->node[i].eTW;
//	if (temp > eps)
//	{
//		vioTWCNEWi = temp;
//		departi = problem->node[i].depart;
//	}
//	else {vioTWCNEWi = 0; departi = PDS_MAX(departi, problem->node[i].sTW) + problem->node[i].duration;}
//  
//	double varvioTWSP = 0;
//	//1. Insert CusDi right after i
//	int varvioCAP = vioCapNEWi; double varvioTWC = vioTWCNEWi;
//	int CapVehCus = CapVehCusi + problem->node[cusDi].capacity;
//	tQ = CapVehCus - Q;
//	if (tQ > 0) {varvioCAP += tQ; CapVehCus = Q;}
//	
//	cStartS = departi + problem->c[i][cusDi];
//	temp = cStartS - problem->node[cusDi].eTW;
//	if (temp > eps) {varvioTWC += temp; cStartS = problem->node[cusDi].depart;}
//	else cStartS = PDS_MAX(cStartS, problem->node[cusDi].sTW) + problem->node[cusDi].duration;
//	double varcost;
//
//	varcost = varcosti + problem->c[i][cusDi] + problem->c[cusDi][nextj] - problem->c[i][nextj];
//	//i and cusDi belong to nextArr[nextj]...lastC:
//	bool contCAP = 1; bool contTW = 1;
//	GoThroughLegC2C(cusDi,nextj,prei,cStartS,CapVehCus,varvioCAP,varvioTWC,contCAP,contTW); //from nextj .. pre_i
//	contCAP = 1; contTW = 1;
//	if (nexti == cusDi)
//	{
//		if (next_cusDi > 0)
//		{
//			if (GoThroughLegC2C(prei,next_cusDi,cStartS,varvioTWC,CapVehCus,varvioCAP) == 0) //depart[lastC] has changed
//			{
//				GoThroughVehicle(idVeh,nextT,varcost,varvioTWC,varvioTWSP,cStartS,lastC, firstC_nextT);
//			}
//		}
//		else //cusDi was the last cus; prei is now the last cus
//		{
//			varcost += problem->c[prei][firstC_nextT];
//			GoThroughVehicle(idVeh,nextT,varcost,varvioTWC,varvioTWSP,cStartS,prei, firstC_nextT);
//		}
//	}
//	else
//	{
//		contCAP = 1; contTW = 1;
//		GoThroughLegC2C(prei,nexti,pre_cusDi,cStartS,CapVehCus,varvioCAP,varvioTWC,contCAP,contTW); //from prei,nexti...pre_CusDi
//		if (next_cusDi > 0)
//		{
//			if (GoThroughLegC2C(pre_cusDi,next_cusDi,cStartS,varvioTWC,CapVehCus,varvioCAP) == 0)
//			{
//				GoThroughVehicle(idVeh,nextT,varcost,varvioTWC,varvioTWSP,cStartS,lastC, firstC_nextT);
//			}
//		}
//		else //cusDi was the last cus --> pre_cusDi is now the last cus:
//		{
//			varcost += problem->c[pre_cusDi][firstC_nextT];
//			GoThroughVehicle(idVeh,nextT,varcost,varvioTWC,varvioTWSP,cStartS,pre_cusDi, firstC_nextT);
//		}
//	}
//
//	obj = varcost + VCAP * varvioCAP + VTWCUS * varvioTWC + VTWSP * varvioTWSP;
//	if (obj < objMIN)
//	{
//		varcostMIN = varcost; varvioCAPMIN = varvioCAP; varvioTWCMIN = varvioTWC; 
//		objMIN = obj; varvioTWSPMIN = varvioTWSP;
//		insertAfter = i;
//	}
//
//	//2. Find place to insert cusDi starting from position after nextj: NOTE that i and cusDi may already exist somewhere else in the leg
//	int posi = pos[j]; int posiOLD = pos[i];
//	int nextC = nextj; 
//	int cal_tillC = i; int pos_cal_tillC = posi; int cal_startC = nextC; 
//	int varvioCAP_tillC = vioCapNEWi; double varvioTWC_tillC = vioTWCNEWi;
//	int CapVehCus_tillC = CapVehCusi; double cStartS_tillC = departi;
//	int pickID;
//	contCAP = 1; contTW = 1;
//	bool contCAP1 = 1; bool contTW1 = 1;
//	do
//	{
//		if (nextC < problem->startidC2CD) //nextC is C2CP
//		{
//			if (nextC == i) {nextC = nextArr[i]; cal_startC = nextC; contCAP = 1; contTW = 1;}
//			else nextC = problem->node[nextC].delID; //jump to delID of nextC
//		}
//		else //nextC is C2CD
//		{
//			if (nextC == cusDi) {nextC = nextArr[cusDi];cal_startC = nextC; contCAP = 1; contTW = 1;}
//			else //nextC is not cusDi
//			{
//				pickID = problem->node[nextC].pickID;
//				if (pos[pickID] > posi)
//				{
//					varvioTWSP = 0;
//					int nextC_T = nextArr[nextC];
//					if (pos[pickID] > posCusDi) //1) [i...cusDi]...[pickID...nextC]
//					{
//						if (pos_cal_tillC < pos[nextC]) //need to calculate vioTWC and vioCAP till nextC:
//						{
//							//for sure [i..cusDi] < pos_cal_tillC ????
//							if (contCAP == 0) {/*varvioCAP = varvioCAP_tillC;*/ CapVehCus_tillC = CAPCus[nextC];}
//							if (contTW == 0) {/*varvioTWC = varvioTWC_tillC;*/ cStartS_tillC = depart[nextC];}
//							GoThroughLegC2C(cal_tillC,cal_startC,nextC,cStartS_tillC,CapVehCus_tillC,varvioCAP_tillC,varvioTWC_tillC,contCAP,contTW);
//							cal_tillC = nextC; pos_cal_tillC = pos[nextC];
//							cal_startC = nextC_T;
//						}
//						//insert cusDi after nextC
//						if (nextC_T > 0) //insert cusDi after nextC which is not the last cus
//						{
//							cStartS = cStartS_tillC + problem->c[nextC][cusDi];
//							temp = cStartS - problem->node[cusDi].eTW;
//							if (temp > eps) {varvioTWC = varvioTWC_tillC + temp; cStartS = problem->node[cusDi].depart;}
//							else 
//							{
//								varvioTWC = varvioTWC_tillC;
//								cStartS = PDS_MAX(cStartS, problem->node[cusDi].sTW) + problem->node[cusDi].duration;
//							}
//							CapVehCus = CapVehCus_tillC + problem->node[cusDi].capacity;
//							tQ = CapVehCus - Q;
//							if (tQ > 0)
//							{
//								varvioCAP = varvioCAP_tillC + tQ; 
//								CapVehCus = Q;
//							}
//							else varvioCAP = varvioCAP_tillC;
//							varcost = varcosti + problem->c[nextC][cusDi] + problem->c[cusDi][nextC_T] - problem->c[nextC][nextC_T];
//							//Cal from cusDi till the end of the trip: i and cusDi doesn't belong to this segment:
//                            if (GoThroughLegC2C(cusDi,nextC_T,cStartS,varvioTWC,CapVehCus,varvioCAP) == 0) //depart[lastC] has changed
//							{
//								GoThroughVehicle(idVeh,nextT,varcost,varvioTWC,varvioTWSP,cStartS,lastC, firstC_nextT);
//							}
//							obj = varcost + VCAP * varvioCAP + VTWCUS * varvioTWC + VTWSP * varvioTWSP;
//							if (obj < objMIN)
//							{
//								varcostMIN = varcost; varvioCAPMIN = varvioCAP; varvioTWCMIN = varvioTWC; 
//								objMIN = obj; varvioTWSPMIN = varvioTWSP;
//								insertAfter = nextC;
//							}
//						}
//						else //insert cusDi at the end of the trip:
//						{
//							cStartS = cStartS_tillC + problem->c[nextC][cusDi];
//							temp = cStartS - problem->node[cusDi].eTW;
//							if (temp > eps) varvioTWC = varvioTWC_tillC + temp;
//							else varvioTWC = varvioTWC_tillC;
//							//don't need varvioCAP because insert cusDi at the end of the trip
//							varcost = varcosti + problem->c[nextC][cusDi] - seg[idVeh].Trip[idTrip].connectCost;
//							//cusDi is now the last cus
//							varcost += problem->c[cusDi][firstC_nextT];
//							GoThroughVehicle(idVeh,nextT,varcost,varvioTWC,varvioTWSP,cStartS,cusDi, firstC_nextT);
//							
//							obj = varcost + VCAP * varvioCAP_tillC + VTWCUS * varvioTWC + VTWSP * varvioTWSP;
//							if (obj < objMIN)
//							{
//								varcostMIN = varcost; varvioCAPMIN = varvioCAP_tillC; varvioTWCMIN = varvioTWC; 
//								objMIN = obj; varvioTWSPMIN = varvioTWSP;
//								insertAfter = nextC;
//							}
//							return; //finish the trip
//						}//end insert cusDi at the end of the trip
//					}
//					else if (pos[nextC] < posi) //3)[pickID...nextC]....[i...cusDi]
//					{
//						if (pos_cal_tillC < pos[nextC]) //need to calculate vioTWC and vioCAP till nextC:
//						{
//							//for sure [i..cusDi] < pos_cal_tillC ????
//							if (contCAP == 0) {/*varvioCAP = varvioCAP_tillC;*/ CapVehCus_tillC = CAPCus[nextC];}
//							if (contTW == 0) {/*varvioTWC = varvioTWC_tillC;*/ cStartS_tillC = depart[nextC];}
//							GoThroughLegC2C(cal_tillC,cal_startC,nextC,cStartS_tillC,CapVehCus_tillC,varvioCAP_tillC,varvioTWC_tillC,contCAP,contTW);
//							cal_tillC = nextC; pos_cal_tillC = pos[nextC];
//							cal_startC = nextC_T;
//						}
//						//insert cusDi after nextC: i and cusDi both belong to the segment nextC..lastC
//						cStartS = cStartS_tillC + problem->c[nextC][cusDi];
//						temp = cStartS - problem->node[cusDi].eTW;
//						if (temp > eps) {varvioTWC = varvioTWC_tillC + temp; cStartS = problem->node[cusDi].depart;}
//						else 
//						{
//							varvioTWC = varvioTWC_tillC;
//							cStartS = PDS_MAX(cStartS, problem->node[cusDi].sTW) + problem->node[cusDi].duration;
//						}
//						CapVehCus = CapVehCus_tillC + problem->node[cusDi].capacity;
//						tQ = CapVehCus - Q;
//						if (tQ > 0)
//						{
//							varvioCAP = varvioCAP_tillC + tQ; 
//							CapVehCus = Q;
//						}
//						else varvioCAP = varvioCAP_tillC;
//						if (nextC_T == i)
//						{
//							if (nexti == cusDi) 
//							{
//								nextC_T = next_cusDi;cal_startC = next_cusDi; contCAP = 1; contTW = 1;
//								if (next_cusDi > 0) 
//								{
//									varcost = varcosti + problem->c[nextC][cusDi] + problem->c[cusDi][next_cusDi] - problem->c[nextC][next_cusDi];
//									//Cal nextC_T till the end of the trip: i and cusDi doesn't belong to this segment
//									if (GoThroughLegC2C(cusDi,nextC_T,cStartS,varvioTWC,CapVehCus,varvioCAP) == 0)
//									{
//										GoThroughVehicle(idVeh,nextT,varcost,varvioTWC,varvioTWSP,cStartS,lastC, firstC_nextT);
//									}
//								}
//								else //nextC was the last cus --> cusDi is now the last cus
//								{
//									varcost = varcosti + problem->c[nextC][cusDi] + problem->c[cusDi][firstC_nextT];
//									GoThroughVehicle(idVeh,nextT,varcost,varvioTWC,varvioTWSP,cStartS,cusDi, firstC_nextT);
//								}
//							}
//							else //[pickID...nextC- i...cusDi]
//							{
//								nextC_T = nexti; cal_startC = nexti; contCAP = 1; contTW = 1;
//								varcost = varcosti + problem->c[nextC][cusDi] + problem->c[cusDi][nexti] - problem->c[nextC][nexti];
//								//from cusDi(after insertion)...pre_cusDi
//								contCAP1 = 1; contTW1 = 1;
//								GoThroughLegC2C(cusDi,nexti,pre_cusDi,cStartS,CapVehCus,varvioCAP,varvioTWC,contCAP1,contTW1);
//								if (next_cusDi > 0)
//								{
//									if (GoThroughLegC2C(pre_cusDi,next_cusDi,cStartS,varvioTWC,CapVehCus,varvioCAP) == 0)
//									{
//										GoThroughVehicle(idVeh,nextT,varcost,varvioTWC,varvioTWSP,cStartS,lastC, firstC_nextT);
//									}
//								}
//								else //cusDi was the last cus --> pre_cusDi is now the last cus:
//								{
//									varcost += problem->c[pre_cusDi][firstC_nextT];
//									GoThroughVehicle(idVeh,nextT,varcost,varvioTWC,varvioTWSP,cStartS,pre_cusDi, firstC_nextT);
//								}
//							}
//						}
//						else //nextC_T != i: [pickID...nextC]....[i...cusDi]
//						{
//							varcost = varcosti + problem->c[nextC][cusDi] + problem->c[cusDi][nextC_T] - problem->c[nextC][nextC_T];
//							contCAP1 = 1; contTW1 = 1;
//							GoThroughLegC2C(cusDi,nextC_T,prei,cStartS,CapVehCus,varvioCAP,varvioTWC,contCAP1,contTW1);
//							if (nexti == cusDi)
//							{
//								if (next_cusDi > 0)
//								{
//								   if (GoThroughLegC2C(prei,next_cusDi,cStartS,varvioTWC,CapVehCus,varvioCAP) == 0)
//								   {
//										GoThroughVehicle(idVeh,nextT,varcost,varvioTWC,varvioTWSP,cStartS,lastC, firstC_nextT);
//								   }
//								}
//								else //cusDi was the last cus --> prei is now the last cus
//								{
//									varcost += problem->c[prei][firstC_nextT];
//									GoThroughVehicle(idVeh,nextT,varcost,varvioTWC,varvioTWSP,cStartS,prei, firstC_nextT);
//								}
//							}
//							else //nexti != cusDi: nextC_T != i: [pickID...nextC]....[i...cusDi]
//							{
//								contCAP1 = 1; contTW1 = 1;
//								GoThroughLegC2C(prei,nexti,pre_cusDi,cStartS,CapVehCus,varvioCAP,varvioTWC,contCAP1,contTW1);
//								if (next_cusDi > 0)
//								{
//									if (GoThroughLegC2C(pre_cusDi,next_cusDi,cStartS,varvioTWC,CapVehCus,varvioCAP)  == 0)
//									{
//										GoThroughVehicle(idVeh,nextT,varcost,varvioTWC,varvioTWSP,cStartS,lastC, firstC_nextT);
//									}
//								}
//								else //cusDi was the last cus --> pre_cusDi is now the last cus
//								{
//									varcost += problem->c[pre_cusDi][firstC_nextT];
//									GoThroughVehicle(idVeh,nextT,varcost,varvioTWC,varvioTWSP,cStartS,pre_cusDi, firstC_nextT);
//								}
//							}//end nexti != cusDi: nextC_T != i: [pickID...nextC]....[i...cusDi]
//						}//end nextC_T != i: [pickID...nextC]....[i...cusDi]
//						obj = varcost + VCAP * varvioCAP + VTWCUS * varvioTWC + VTWSP * varvioTWSP;
//						if (obj < objMIN)
//						{
//							varcostMIN = varcost; varvioCAPMIN = varvioCAP; varvioTWCMIN = varvioTWC; 
//							objMIN = obj; varvioTWSPMIN = varvioTWSP;
//							insertAfter = nextC;
//						}
//					}
//					else if (pos[nextC] > posCusDi) //4) pickID....[i...cusDi]....nextC
//					{
//						if (pos_cal_tillC < pos[nextC]) //need to calculate vioTWC and vioCAP till nextC:
//						{
//							//for sure [i..cusDi] < pos_cal_tillC ????
//							if (contCAP == 0) {/*varvioCAP = varvioCAP_tillC;*/ CapVehCus_tillC = CAPCus[prei];}
//							if (contTW == 0) {/*varvioTWC = varvioTWC_tillC;*/ cStartS_tillC = depart[prei];}
//							GoThroughLegC2C(cal_tillC,cal_startC,prei,cStartS_tillC,CapVehCus_tillC,varvioCAP_tillC,varvioTWC_tillC,contCAP,contTW);
//							if (nexti == cusDi)
//							{
//								//if (contCAP == 0) CapVehCus_tillC = CAPCus[nextC];
//								//if (contTW == 0) cStartS_tillC = depart[nextC];
//								contCAP = 1; contTW = 1;
//								GoThroughLegC2C(prei,next_cusDi,nextC,cStartS_tillC, CapVehCus_tillC,varvioCAP_tillC,varvioTWC_tillC,contCAP,contTW);
//							}
//							else
//							{
//								//if (contCAP == 0) CapVehCus_tillC = CAPCus[nextC];
//								//if (contTW == 0) cStartS_tillC = depart[nextC];
//								contCAP1 = 1; contTW1 = 1;
//								GoThroughLegC2C(prei,nexti,pre_cusDi,cStartS_tillC,CapVehCus_tillC,varvioCAP_tillC,varvioTWC_tillC,contCAP,contTW);
//								contCAP1 = 1; contTW1 = 1;
//								GoThroughLegC2C(pre_cusDi,next_cusDi,nextC,cStartS_tillC,CapVehCus_tillC,varvioCAP_tillC,varvioTWC_tillC,contCAP,contTW);
//							}						
//							cal_tillC = nextC; pos_cal_tillC = pos[nextC];
//							cal_startC = nextC_T;
//						}
//						//insert cusDi after nextC:
//						if (nextC_T > 0) //insert cusDi after nextC which is not the last cus
//						{
//							cStartS = cStartS_tillC + problem->c[nextC][cusDi];
//							temp = cStartS - problem->node[cusDi].eTW;
//							if (temp > eps) {varvioTWC = varvioTWC_tillC + temp; cStartS = problem->node[cusDi].depart;}
//							else 
//							{
//								varvioTWC = varvioTWC_tillC;
//								cStartS = PDS_MAX(cStartS, problem->node[cusDi].sTW) + problem->node[cusDi].duration;
//							}
//							CapVehCus = CapVehCus_tillC + problem->node[cusDi].capacity;
//							tQ = CapVehCus - Q;
//							if (tQ > 0)
//							{
//								varvioCAP = varvioCAP_tillC + tQ; 
//								CapVehCus = Q;
//							}
//							else varvioCAP = varvioCAP_tillC;
//							varcost = varcosti + problem->c[nextC][cusDi] + problem->c[cusDi][nextC_T] - problem->c[nextC][nextC_T];
//							//Cal from cusDi till the end of the trip: i and cusDi doesn't belong to this segment:
//                            if (GoThroughLegC2C(cusDi,nextC_T,cStartS,varvioTWC,CapVehCus,varvioCAP) == 0)
//							{
//								GoThroughVehicle(idVeh,nextT,varcost,varvioTWC,varvioTWSP,cStartS,lastC, firstC_nextT);
//							}
//							obj = varcost + VCAP * varvioCAP + VTWCUS * varvioTWC + VTWSP * varvioTWSP;
//							if (obj < objMIN)
//							{
//								varcostMIN = varcost; varvioCAPMIN = varvioCAP; varvioTWCMIN = varvioTWC; 
//								objMIN = obj; varvioTWSPMIN = varvioTWSP;
//								insertAfter = nextC;
//							}
//						}
//						else //insert cusDi at the end of the trip:
//						{
//							cStartS = cStartS_tillC + problem->c[nextC][cusDi];
//							temp = cStartS - problem->node[cusDi].eTW;
//							if (temp > eps) varvioTWC = varvioTWC_tillC + temp;
//							else varvioTWC = varvioTWC_tillC;
//							//don't need varvioCAP because insert cusDi at the end of the trip
//							varcost = varcosti + problem->c[nextC][cusDi] - seg[idVeh].Trip[idTrip].connectCost;
//							//nextC was the last cus --> cusDi is now the last cus:
//							varcost += problem->c[cusDi][firstC_nextT];
//							GoThroughVehicle(idVeh,nextT,varcost,varvioTWC,varvioTWSP,cStartS,cusDi, firstC_nextT);
//							obj = varcost + VCAP * varvioCAP_tillC + VTWCUS * varvioTWC + VTWSP * varvioTWSP;
//							if (obj < objMIN)
//							{
//								varcostMIN = varcost; varvioCAPMIN = varvioCAP_tillC; varvioTWCMIN = varvioTWC; 
//								objMIN = obj; varvioTWSPMIN = varvioTWSP;
//								insertAfter = nextC;
//							}
//							return; //finish the trip
//						}//end insert cusDi at the end of the trip
//					}
//					else //2) pos[nextC] belongs to [posi,poscusDi]: i...pickID...nextC...cusDi [BEFORE MOVE: ....nextC...i..cusDi... OR ....i...[pickID...nextC]...cusDi] 15/1/2014
//					{
//						if (pos_cal_tillC < pos[nextC]) //need to calculate vioTWC and vioCAP till nextC:
//						{
//							//for sure [i..cusDi] < pos_cal_tillC ????
//							if (contCAP == 0) {/*varvioCAP = varvioCAP_tillC;*/ CapVehCus_tillC = CAPCus[nextC];}
//							if (contTW == 0) {/*varvioTWC = varvioTWC_tillC;*/ cStartS_tillC = depart[nextC];}
//							GoThroughLegC2C(cal_tillC,cal_startC,nextC,cStartS_tillC,CapVehCus_tillC,varvioCAP_tillC,varvioTWC_tillC,contCAP,contTW);
//							cal_tillC = nextC; pos_cal_tillC = pos[nextC];
//							cal_startC = nextC_T;
//						}
//						//insert cusDi after nextC: for sure nextC_T > 0
//						cStartS = cStartS_tillC + problem->c[nextC][cusDi];
//						temp = cStartS - problem->node[cusDi].eTW;
//						if (temp > eps) {varvioTWC = varvioTWC_tillC + temp; cStartS = problem->node[cusDi].depart;}
//						else 
//						{
//							varvioTWC = varvioTWC_tillC;
//							cStartS = PDS_MAX(cStartS, problem->node[cusDi].sTW) + problem->node[cusDi].duration;
//						}
//						CapVehCus = CapVehCus_tillC + problem->node[cusDi].capacity;
//						tQ = CapVehCus - Q;
//						if (tQ > 0)
//						{
//							varvioCAP = varvioCAP_tillC + tQ; 
//							CapVehCus = Q;
//						}
//						else varvioCAP = varvioCAP_tillC;
//						if (cusDi == nextC_T)
//						{
//							varcost = varcosti + problem->c[nextC][cusDi] + problem->c[cusDi][next_cusDi] - problem->c[nextC][next_cusDi];
//							//e.g. ...j,[1+,(2+,2-),1-], i,[3+,(4+,4-)3-] cusDi,cusDj,.... where pickID = 4+; nextC = 3-; 
//							//cout<<"TRUONG HOP NAY XAY RA ?????????????????????????????????????????????? "<<endl;
//							//Cal from cusDi till the end of the trip: i and cusDi doesn't belong to this segment:
//							nextC_T = next_cusDi; cal_startC = nextC_T; contTW = 1; contCAP = 1;
//							if (nextC_T > 0)
//							{
//								varcost = varcosti + problem->c[nextC][cusDi] + problem->c[cusDi][next_cusDi] - problem->c[nextC][next_cusDi];
//								if (GoThroughLegC2C(cusDi,nextC_T,cStartS,varvioTWC,CapVehCus,varvioCAP) == 0)
//									GoThroughVehicle(idVeh,nextT,varcost,varvioTWC,varvioTWSP,cStartS,lastC, firstC_nextT);
//							}
//							else //cusDi is still the last cus:
//							{
//								varcost = varcosti + problem->c[nextC][cusDi] + seg[idVeh].Trip[idTrip].connectCost;
//								GoThroughVehicle(idVeh,nextT,varcost,varvioTWC,varvioTWSP,cStartS,lastC, firstC_nextT);
//							}
//						}
//						else //cusDi != nextC_T
//						{
//							varcost = varcosti + problem->c[nextC][cusDi] + problem->c[cusDi][nextC_T] - problem->c[nextC][nextC_T];
//						    //i...pickID...nextC...cusDi
//							//cusDi belongs to the segment nextC...lastC: cusDi != nextArr[nextC]
//							//BEFORE MOVE: ....nextC...i..cusDi... OR ....i...[pickID...nextC]...cusDi
//							if (posiOLD < pos[nextC]) //before move: ....i...[pickID...nextC]...cusDi
//							{
//								/*cout<<"j = "<<j<<"; i = "<<i<<"; cusDi = "<<cusDi<<"; pickID = "<<pickID<<"; nextC = "<<nextC<<endl;
//								cout<<"TRIP is : "; showTripCus(idVeh,idTrip);
//								exit(-1);*/
//								//e.g.[1+.....1-=j], [pickID1.....nextC1], i, [pickID...nextC],[pickID2...nextC2],cusDi.....
//								contCAP1 = 1; contTW1 = 1;
//								GoThroughLegC2C(cusDi,nextC_T,pre_cusDi,cStartS,CapVehCus,varvioCAP,varvioTWC,contCAP1,contTW1);
//								if (next_cusDi > 0)
//								{
//									if (GoThroughLegC2C(pre_cusDi,next_cusDi,cStartS,varvioTWC,CapVehCus,varvioCAP) == 0) //GoThroughLegC2C(pre_cusDi,next_cusDi,lastC,cStartS,CapVehCus,varvioCAP,varvioTWC,contCAP1,contTW1);
//										GoThroughVehicle(idVeh,nextT,varcost,varvioTWC,varvioTWSP,cStartS,lastC, firstC_nextT);
//								}
//								else //pre_cusDi is now the last cus
//								{
//									GoThroughVehicle(idVeh,nextT,varcost,varvioTWC,varvioTWSP,cStartS,pre_cusDi, firstC_nextT);
//								}
//							}
//							else // before move: ....nextC...i..cusDi...
//							{
//								if (nextC_T == i)	//...j....[pickID,...,nextID],[iOLD,......,cusDi]...
//								{
//									if (nexti == cusDi)
//									{
//										if (next_cusDi > 0)
//										{
//											//contCAP1 = 1; contTW1 = 1;
//											if (GoThroughLegC2C(cusDi,next_cusDi,cStartS,varvioTWC,CapVehCus,varvioCAP) == 0) //GoThroughLegC2C(pre_cusDi,next_cusDi,lastC,cStartS,CapVehCus,varvioCAP,varvioTWC,contCAP1,contTW1);
//											{
//												GoThroughVehicle(idVeh,nextT,varcost,varvioTWC,varvioTWSP,cStartS,lastC, firstC_nextT);
//											}
//										}
//										else //cusDi is still the last cus:????
//										{
//											GoThroughVehicle(idVeh,nextT,varcost,varvioTWC,varvioTWSP,cStartS,cusDi, firstC_nextT);
//										}
//									}
//									else
//									{
//										contCAP1 = 1; contTW1 = 1;
//										GoThroughLegC2C(cusDi,nexti,pre_cusDi,cStartS,CapVehCus,varvioCAP,varvioTWC,contCAP1,contTW1);
//										if (next_cusDi > 0)
//										{	
//											if (GoThroughLegC2C(pre_cusDi,next_cusDi,cStartS,varvioTWC,CapVehCus,varvioCAP) == 0)
//											{
//												GoThroughVehicle(idVeh,nextT,varcost,varvioTWC,varvioTWSP,cStartS,lastC, firstC_nextT);
//											}
//										}
//										else //cusDi is still the last cus:
//										{
//											GoThroughVehicle(idVeh,nextT,varcost,varvioTWC,varvioTWSP,cStartS,cusDi, firstC_nextT);
//										}
//									}
//								}
//								else //...j....[pickID,...,nextID],nextC_T,.....,[iOLD,......,cusDi]...
//								{
//									contCAP1 = 1; contTW1 = 1;
//									GoThroughLegC2C(cusDi,nextC_T,prei,cStartS,CapVehCus,varvioCAP,varvioTWC,contCAP1,contTW1);
//									if (nexti == cusDi)
//									{
//										if (next_cusDi > 0)
//										{
//											if (GoThroughLegC2C(prei,next_cusDi,cStartS,varvioTWC,CapVehCus,varvioCAP) == 0) //GoThroughLegC2C(pre_cusDi,next_cusDi,lastC,cStartS,CapVehCus,varvioCAP,varvioTWC,contCAP1,contTW1);
//											{
//												GoThroughVehicle(idVeh,nextT,varcost,varvioTWC,varvioTWSP,cStartS,lastC, firstC_nextT);
//											}
//										}
//										else //prei is now the last cus:
//										{
//											GoThroughVehicle(idVeh,nextT,varcost,varvioTWC,varvioTWSP,cStartS, prei, firstC_nextT);
//										}
//									}
//									else
//									{
//										contCAP1 = 1; contTW1 = 1;
//										GoThroughLegC2C(prei,nexti,pre_cusDi,cStartS,CapVehCus,varvioCAP,varvioTWC,contCAP1,contTW1);
//										//Cal from nextArr[cusDi] ... lastCus
//										if (next_cusDi > 0)
//										{
//											//contCAP1 = 1; contTW1 = 1;
//											if (GoThroughLegC2C(pre_cusDi,next_cusDi,cStartS,varvioTWC,CapVehCus,varvioCAP) == 0) //GoThroughLegC2C(pre_cusDi,next_cusDi,lastC,cStartS,CapVehCus,varvioCAP,varvioTWC,contCAP1,contTW1);
//											{
//												GoThroughVehicle(idVeh,nextT,varcost,varvioTWC,varvioTWSP,cStartS,lastC, firstC_nextT);
//											}
//										}
//										else //pre_cusDi is now the last cus:
//										{
//											GoThroughVehicle(idVeh,nextT,varcost,varvioTWC,varvioTWSP,cStartS,pre_cusDi, firstC_nextT);
//										}
//									}
//								}
//
//							}
//
//
//						}
//						obj = varcost + VCAP * varvioCAP + VTWCUS * varvioTWC + VTWSP * varvioTWSP;
//						if (obj < objMIN)
//						{
//							varcostMIN = varcost; varvioCAPMIN = varvioCAP; varvioTWCMIN = varvioTWC; 
//							objMIN = obj; varvioTWSPMIN = varvioTWSP;
//							insertAfter = nextC;
//						}
//					}//end 2) pos[nextC] belongs to [posi,poscusDi]: i...pickID...nextC...cusDi
//					nextC = nextC_T; //find another position to insert delID
//				}
//				else return; //pos[pickID] <= posi: doesn't exist any place to insert cusDi anymore
//			}//end nextC is not cusDi
//		}//end nextC is C2CD
//	}while (nextC > 0);
//
//}
//
//
///*----------------------------------------------------------- 13/1/2014 ----------------------------------------------*/
//
//
//
//void Solution::cal_InsertCusC2CIAfterJ_FromBeginning(int j, int i, int idVeh, int idTripj, int preT_lastC, int &varvioCAP, double &varcost, double &varvioTWC, double &varvioTWSP, int &insert_After, double cStartS)
//{
//	//idTripj > 0: insert i after j on the trip (idVeh,idTripj); then find place to insert cusDi of i (j may or mayNOT the last cus of trip)
//    //11/12/2013
//	int sucj = nextArr[j];
//	int preID, nextID;
//	preID = preT_lastC;
//	nextID = seg[idVeh].Trip[idTripj].firstCus;
//	double cArrTime, temp;
//	while (nextID != sucj)
//	{
//          cArrTime = cStartS + problem->c[preID][nextID]; //Arrive Time to Customer nextID
//		  temp = cArrTime - problem->node[nextID].eTW;
//          if (temp > eps)
//		  {
//			  if (vioTWCus[nextID] > eps)
//			  {
//				  varvioTWC += (temp - vioTWCus[nextID]);
//				  cStartS = depart[j];
//				  break;
//			  }
//			  varvioTWC += temp;
//			  cStartS = problem->node[nextID].depart;
//		  }
//		  else
//		  {
//			  varvioTWC -= vioTWCus[nextID]; //Update 15/11/2013
//			  cStartS = PDS_MAX(cArrTime, problem->node[nextID].sTW) + problem->node[nextID].duration;
//		  }
//		  preID = nextID; nextID = nextArr[nextID];
//	}//end while (nextID != sucj)
//
//	//cStartS is now the depart new of j:
//	int lastT = seg[idVeh].numTrips - 1;
//	if (seg[idVeh].Trip[idTripj].lastCus == j)
//	{
//		if (idTripj == lastT) //j was last cus of last C2C trip
//			cal_InsertCusC2CIAfterJ_LastC_LastTrip(cStartS,j, i, idVeh, idTripj, varcost, varvioTWC);
//		else //j was the last cus of not last C2C trip
//		{
//			int nextSP = seg[idVeh].Trip[idTripj].nextSP;
//			if (nextSP > 0) //nextT is DTrip
//			    cal_InsertCusC2CIAfterJ_LastC_NextD(cStartS,j, i, idVeh, idTripj,nextSP, varcost, varvioTWC, varvioTWSP);
//			else
//			    cal_InsertCusC2CIAfterJ_LastC_NextTripPORC2C(cStartS,j,i,idVeh, idTripj, varcost,varvioTWC,varvioTWSP);
//		}
//		insert_After = i;
//	}
//	else //j is not the last cus of (idVeh,idTripj)
//	{
//		double varcostMIN, varvioTWCMIN, varvioTWSPMIN; int varvioCAPMIN;
//		if (idTripj == lastT) //j is not the last cus of the last C2C trip
//		{
//			SUBcal_InsertCusC2CIAfterJ_NotLastC_LastTrip(cStartS,FCAP[j],j,i,idVeh,idTripj,varcostMIN, varvioTWCMIN, varvioCAPMIN, insert_After);
//		}
//		else //j is not the last cus of not last C2C Trip
//		{
//			int nextSP = seg[idVeh].Trip[idTripj].nextSP;
//			if (nextSP > 0) //nextT is DTrip
//			    SUBcal_InsertCusC2CIAfterJ_NotLastC_NextD(cStartS,FCAP[j],j,i,idVeh,idTripj,nextSP,varcostMIN, varvioTWCMIN, varvioTWSPMIN, varvioCAPMIN, insert_After);
//			else
//			    SUBcal_InsertCusC2CIAfterJ_NotLastC_NextTripPORC2C(cStartS,FCAP[j],j,i,idVeh,idTripj,varcostMIN, varvioTWCMIN, varvioTWSPMIN, varvioCAPMIN, insert_After);
//		}
//		varcost += varcostMIN; varvioTWC += varvioTWCMIN; varvioCAP += varvioCAPMIN;
//		varvioTWSP += varvioTWSPMIN;
//	}//end j is not the last cus of (idVeh,idTripj)
//}
//
//bool Solution::cal_InsertCusC2CIAfterJ_LastC_TillTrip(double depart_j, int j, int i, int idVeh, int idTripj, double &varcost, double &varvioTWC, double &varvioTWSP, double &cStartS, int update_idTrip)
//{
//	//11/12/2013: insert (i and delID of i) after the last cus j; calculate varvioTWC, varcost, varvioTWSP till trip update_idTrip
//	//return 1 if cStartS has not been changed; 
//	//0 otherwise --> need to update cStartS appropriate
//	//COPY cal_InsertCusC2CIAfterJ_NotLastC_TillTrip
//
//    int nextT = idTripj + 1;
//	int nextSP = seg[idVeh].Trip[idTripj].nextSP;
//	int numTrips_update = update_idTrip - idTripj;
//	if (nextSP > 0) //nextT is DTrip
//	{
//		return cal_InsertCusC2CIAfterJ_LastC_NextD_TillTrip(depart_j,j,i,idVeh,idTripj,nextSP,varcost,varvioTWC,varvioTWSP,cStartS,numTrips_update);
//	}
//	else //nextT is PTrip OR C2C
//	{
//		return cal_InsertCusC2CIAfterJ_LastC_NextTripPORC2C_TillTrip(depart_j,j, i, idVeh, idTripj, varcost, varvioTWC, varvioTWSP, cStartS, numTrips_update);
//	}//end nextT is PTrip or C2C
//}
//
//
//bool Solution::cal_InsertCusC2CIAfterJ_NotLastC_TillTrip(double depart_j, int CAPCusj, int j, int i, int idVeh, int idTripj, double &varcost, double &varvioTWC, double &varvioTWSP, int &varvioCAP, double &cStartS, int &insert_After, int update_idTrip)
//{
//	//THIS PROCEDURE DOESN'T USE ANYWHERE
//	//15/12/2013: insert i after the last cus j and find best place to insert delID of i; calculate varvioTWC, varcost, varvioTWSP till trip update_idTrip
//	//return 1 if cStartS has not been changed; 
//	//0 otherwise --> need to update cStartS appropriate
//	//COPY cal_InsertCusC2CIAfterJ_LastC_TillTrip
//
//	int nextSP = seg[idVeh].Trip[idTripj].nextSP;
//	bool stopMIN;
//	double varcostMIN, varvioTWCMIN, varvioTWSPMIN; int varvioCAPMIN;
//
//	if (nextSP > 0) //nextT is DTrip
//	{
//		//return 1 if cStartS has not been changed; 0 otherwise
//		SUBcal_InsertCusC2CIAfterJ_NotLastC_NextD_COPY(depart_j,CAPCusj,j,i,idVeh,idTripj,nextSP,varcostMIN,varvioTWCMIN,varvioTWSPMIN,varvioCAPMIN,stopMIN,cStartS,insert_After,update_idTrip);
//	}
//	else //nextT is PTrip OR C2C
//	{
//		SUBcal_InsertCusC2CIAfterJ_NotLastC_NextTripPORC2C_COPY(depart_j,CAPCusj,j,i,idVeh,idTripj,varcostMIN,varvioTWCMIN,varvioTWSPMIN,varvioCAPMIN,stopMIN,cStartS,insert_After,update_idTrip);
//	}//end nextT is PTrip or C2C
//    
//	varcost += varcostMIN; varvioTWC += varvioTWCMIN; varvioTWSP += varvioTWSPMIN; varvioCAP += varvioCAPMIN;
//	return stopMIN;
//}
//
//
//
//
//void Solution::cal_MoveCusDIAfterJ_oneTrip_LastTrip(int j, int k, int idVeh, int idTrip)
//{
//	//See on 2/12/2013
//    //ALMOST AS SAME AS Solution::cal_MoveCusDIAfterJ_oneTrip_nextTripP
//	int i = problem->node[j].neighborNode[k].id; //insert customer i after j
//
//	/*if (nextArr[j]==i) //i is already after j:
//	{
//		cout<<"ERROR cal_MoveCusDIAfterJ_oneTrip_LastTrip: nextArr[j] = i"<<endl;
//		exit(-1);
//	}*/
//
//	int prei,suci, idcur, idnext, sucj;
//	double vioTWCNEW, cArrTime, cStartS, temp, varcost;
//	int assSP = seg[idVeh].Trip[idTrip].assSP;
//
//	prei=predArr[i];suci=nextArr[i]; sucj = nextArr[j];
//	//if (starti <startj)
//	if (pos[i] < pos[j])
//	{
//		//remove i:
//		if (prei > 0) 
//		{
//			vioTWCNEW = FvioTWCus[prei];
//			cArrTime = depart[prei] + problem->c[prei][suci];
//	        varcost = problem->c[prei][suci] - (problem->c[prei][i] + problem->c[i][suci]);
//		}
//		else //i is the first customer of the trip
//		{
//			vioTWCNEW = 0;
//			cArrTime = seg[idVeh].Trip[idTrip].leaveSP + problem->c[assSP][suci];
//            varcost = problem->c[assSP][suci] - (problem->c[assSP][i] + problem->c[i][suci]);
//		}
//		temp = cArrTime - problem->node[suci].eTW;
//		if (temp > eps) 
//		{
//			vioTWCNEW += temp;
//			cStartS = problem->node[suci].depart;
//		}
//		else cStartS = PDS_MAX(cArrTime, problem->node[suci].sTW) + problem->node[suci].duration;
//
//		//from suci to j:
//		idcur = suci;
//		if (suci != j)
//		{
//			idnext = nextArr[suci];
//			while (idnext != sucj)
//			{
//				cArrTime = cStartS + problem->c[idcur][idnext];
//				temp = cArrTime - problem->node[idnext].eTW;
//				if (temp > eps)
//				{
//					vioTWCNEW += temp;
//					cStartS = problem->node[idnext].depart;
//				}
//				else cStartS = PDS_MAX(cArrTime, problem->node[idnext].sTW) + problem->node[idnext].duration;
//				idcur = idnext; idnext = nextArr[idnext];
//			}
//		}
//
//		//now idnext point to sucj; idcur is j:
//
//		//insert i after j:
//		cArrTime = cStartS + problem->c[idcur][i];
//		temp = cArrTime - problem->node[i].eTW;
//		if (temp > eps)
//		{
//			vioTWCNEW += temp;
//			cStartS = problem->node[i].depart;
//		}
//		else cStartS = PDS_MAX(cArrTime, problem->node[i].sTW) + problem->node[i].duration;
//
//		if (sucj >0)
//		{
//				varcost += ((problem->c[j][i] + problem->c[i][sucj]) - problem->c[j][sucj]);
//				//check from sucj till the end of the trip:
//				idcur=i; idnext=sucj;
//				while (idnext >0)
//				{
//					cArrTime = cStartS + problem->c[idcur][idnext];
//					temp = cArrTime - problem->node[idnext].eTW;
//					if (temp > eps)
//					{
//						vioTWCNEW += temp;
//						if (vioTWCus[idnext] > eps)
//						{
//							moveCus[j][k]->var_cost = varcost;
//							moveCus[j][k]->var_vioTWC = vioTWCNEW - FvioTWCus[idnext];
//							moveCus[j][k]->var_vioTWSP = 0;
//						    moveCus[j][k]->atIT = IT;
//							return;
//						}
//						cStartS = problem->node[idnext].depart;
//					}
//					else cStartS = PDS_MAX(cArrTime, problem->node[idnext].sTW) + problem->node[idnext].duration;
//					idcur = idnext;idnext = nextArr[idnext];
//				}
//		}
//		else //j was the last del cus
//		{idcur=i; varcost += (problem->c[j][i] + problem->c[i][0] - problem->c[j][0]);/*if (print) cout<<"problem->c[j][i] = "<<problem->c[j][i]<<endl;*/}
//	}
//	else // i after j and nextArr[j] != i:
//	{
//        vioTWCNEW = FvioTWCus[j];
//		//insert i after j:
//		cArrTime = depart[j] + problem->c[j][i];
//		temp = cArrTime - problem->node[i].eTW;
//		if (temp > eps)
//		{
//			vioTWCNEW += temp;
//			cStartS = problem->node[i].depart;
//		}
//		else cStartS = PDS_MAX(cArrTime,problem->node[i].sTW) + problem->node[i].duration; //start service time of customer i
//		
//		//from i to sucj: because nextArr[j] !=i then sucj can not be the endSP:
//		cArrTime = cStartS + problem->c[i][sucj];
//		temp = cArrTime - problem->node[sucj].eTW;
//		if (temp > eps)
//		{
//			vioTWCNEW += temp;
//			cStartS = problem->node[sucj].depart;
//		}
//		else cStartS = PDS_MAX(cArrTime,problem->node[sucj].sTW) + problem->node[sucj].duration; //start service time of customer sucj
//        varcost = problem->c[j][i] + problem->c[i][sucj] - problem->c[j][sucj];
//		//cout<<"problem->c[j][i] = "<<problem->c[j][i]<<"; problem->c[i][sucj] = "<<problem->c[i][sucj]<<"; problem->c[j][sucj] = "<<problem->c[j][sucj]<<"; varcost = "<<varcost<<endl;  
//		idcur = sucj; idnext = nextArr[sucj];
//		//checking from sucj till prei:
//		while (idnext != i)
//		{
//			cArrTime = cStartS + problem->c[idcur][idnext];
//			temp = cArrTime - problem->node[idnext].eTW;
//			if (temp > eps)
//			{
//				vioTWCNEW += temp;
//				cStartS = problem->node[idnext].depart;
//			}
//			else cStartS = PDS_MAX(cArrTime,problem->node[idnext].sTW) + problem->node[idnext].duration; //start service time of customer idnext
//            idcur = idnext; idnext = nextArr[idnext];
//		}
//
//		//now idcur points to prei:
//		//from prei to suci & suci till the end of the trip:
//		if (suci > 0) // i was not the last customer of the trip
//		{
//			varcost += (problem->c[prei][suci] - problem->c[prei][i] - problem->c[i][suci]);
//			//cout<<"problem->c[prei][suci] = "<<problem->c[prei][suci]<<"; problem->c[prei][i] = "<<problem->c[prei][i]<<"; problem->c[i][suci] = "<<problem->c[i][suci]<<endl<<"; varcost = "<<varcost<<endl;
//			idnext = suci;
//			while (idnext > 0)
//			{
//				cArrTime = cStartS + problem->c[idcur][idnext];
//				temp = cArrTime - problem->node[idnext].eTW;
//				if (temp > eps)
//				{
//					vioTWCNEW += temp;
//					if (vioTWCus[idnext] > eps) 
//					{
//						moveCus[j][k]->var_cost = varcost;
//						moveCus[j][k]->var_vioTWC = vioTWCNEW - FvioTWCus[idnext];
//						moveCus[j][k]->var_vioTWSP = 0;
//					    moveCus[j][k]->atIT = IT;
//						return;
//					}
//					cStartS = problem->node[idnext].depart;
//				}
//				else cStartS = PDS_MAX(cArrTime,problem->node[idnext].sTW) + problem->node[idnext].duration; //start service time of customer idnext
//				idcur = idnext; idnext = nextArr[idnext];
//			}
//		}
//		else //i was the last customer of the trip:
//		{
//			varcost += (problem->c[prei][0] - problem->c[prei][i] - problem->c[i][0]);
//		}
//		//now idcur points to the NEW last delivery customer of the trip:
//	}
//
//	//idcur is now the last customer of the trip and cStartS is startService at the NEW last customer of current vehicle
//    moveCus[j][k]->var_vioTWSP = 0;
//    moveCus[j][k]->var_vioTWC = vioTWCNEW - seg[idVeh].Trip[idTrip].vioTWC;
//	moveCus[j][k]->var_cost = varcost;
//    moveCus[j][k]->atIT = IT;
//
//}
//
//
//void Solution::cal_MoveCusDIAfterJ_oneTrip_NextTripPORC2C(int j, int k,int idVeh, int idTrip)
//{
//	//See on 2/12/2013
//	int i = problem->node[j].neighborNode[k].id; //insert customer i after j
//	int prei,suci, idcur, idnext, sucj;
//	double vioTWCNEW, cArrTime, cStartS, temp,varcost;
//	int assSP = seg[idVeh].Trip[idTrip].assSP;
//	
//	int nextTrip = idTrip + 1;
//    int firstC_nextT = seg[idVeh].Trip[nextTrip].firstCus;
//
//    prei=predArr[i];suci=nextArr[i]; sucj = nextArr[j];
//	//cout<<"i = "<<i<<"; prei = "<<prei<<"; suci = "<<suci<<"; sucj = "<<sucj<<"; j = "<<j<<"; k = "<<k<<endl;
//	//if (starti <startj)
//	if (pos[i]<pos[j])
//	{
//		//remove i:
//		if (prei>0) 
//		{
//			vioTWCNEW = FvioTWCus[prei];
//			cArrTime = depart[prei] + problem->c[prei][suci];
//	        varcost = problem->c[prei][suci] - (problem->c[prei][i] + problem->c[i][suci]);
//		}
//		else //i is the first customer of the trip
//		{
//			vioTWCNEW = 0;
//			cArrTime = seg[idVeh].Trip[idTrip].leaveSP + problem->c[assSP][suci];
//            varcost = problem->c[assSP][suci] - (problem->c[assSP][i] + problem->c[i][suci]);
//		}
//		temp = cArrTime - problem->node[suci].eTW;
//		if(temp > eps)
//		{
//			vioTWCNEW +=temp;
//			cStartS = problem->node[suci].depart;
//		}
//		else cStartS = PDS_MAX(cArrTime, problem->node[suci].sTW) + problem->node[suci].duration;
//
//		//from suci to j:
//		idcur = suci;
//		if (suci != j)
//		{
//			idnext = nextArr[suci];
//			//cout<<"idcur(suci) = "<<idcur<<"; idnext(next suci) = "<<idnext<<"; i = "<<i<<"; j = "<<j<<"; pos[i] = "<<pos[i]<<"; pos[j] = "<<pos[j]<<";  ";
//			//showTripCost(idVeh, idTrip);
//			while (idnext != sucj)
//			{
//				cArrTime = cStartS + problem->c[idcur][idnext];
//				temp = cArrTime - problem->node[idnext].eTW;
//				if (temp > eps)
//				{
//					vioTWCNEW +=temp;
//					cStartS = problem->node[idnext].depart;
//				}
//				else cStartS = PDS_MAX(cArrTime, problem->node[idnext].sTW) + problem->node[idnext].duration;
//				idcur = idnext; idnext = nextArr[idnext];
//			}
//		}
//
//		//now idnext point to sucj; idcur is j:
//		//insert i after j:
//
//		cArrTime = cStartS + problem->c[idcur][i];
//		temp = cArrTime - problem->node[i].eTW;
//		if (temp > eps)
//		{
//			vioTWCNEW += temp;
//			cStartS = problem->node[i].depart;
//		}
//		else cStartS = PDS_MAX(cArrTime, problem->node[i].sTW) + problem->node[i].duration; //start service time at customer i
//	
//		if (sucj >0)
//		{
//			varcost += ((problem->c[j][i] + problem->c[i][sucj]) - problem->c[j][sucj]);
//			//check from sucj till the end of the trip:
//			idcur=i; idnext=sucj;
//			while (idnext >0)
//			{
//				cArrTime = cStartS + problem->c[idcur][idnext];
//				temp = cArrTime - problem->node[idnext].eTW;
//				if (temp > eps)
//				{
//					vioTWCNEW += temp;
//					if (vioTWCus[idnext] > eps)
//					{
//						    moveCus[j][k]->atIT = IT;
//							moveCus[j][k]->var_cost = varcost;
//							moveCus[j][k]->var_vioTWC = vioTWCNEW - FvioTWCus[idnext];
//							moveCus[j][k]->var_vioTWSP = 0;
//							return;
//					}
//					cStartS = problem->node[idnext].depart;
//				}
//				else cStartS = PDS_MAX(cArrTime, problem->node[idnext].sTW) + problem->node[idnext].duration;
//				idcur = idnext;idnext = nextArr[idnext];
//			}
//		} //j was the last del cus
//		else 
//		{
//			idcur=i; 
//			varcost += (problem->c[j][i] + problem->c[i][firstC_nextT] - problem->c[j][firstC_nextT]);/*if (print) cout<<"problem->c[j][i] = "<<problem->c[j][i]<<endl;*/}
//	}
//	else // i after j and nextArr[j] !=i:
//	{
//        vioTWCNEW = FvioTWCus[j];
//		//insert i after j:
//		cArrTime = depart[j] + problem->c[j][i];
//		temp = cArrTime - problem->node[i].eTW;
//		if (temp > eps)
//		{
//			vioTWCNEW += temp;
//			cStartS = problem->node[i].depart;
//		}
//		else cStartS = PDS_MAX(cArrTime,problem->node[i].sTW) + problem->node[i].duration; //start service time of customer i
//	
//		//from i to sucj: because nextArr[j] !=i then sucj can not be the endSP:
//		cArrTime = cStartS + problem->c[i][sucj];
//		temp = cArrTime - problem->node[sucj].eTW;
//		if (temp > eps)
//		{
//			vioTWCNEW += temp;
//			cStartS = problem->node[sucj].depart;
//		}
//		else cStartS = PDS_MAX(cArrTime,problem->node[sucj].sTW) + problem->node[sucj].duration; //start service time of customer sucj
//		
//		varcost = problem->c[j][i] + problem->c[i][sucj] - problem->c[j][sucj];
//		//cout<<"problem->c[j][i] = "<<problem->c[j][i]<<"; problem->c[i][sucj] = "<<problem->c[i][sucj]<<"; problem->c[j][sucj] = "<<problem->c[j][sucj]<<"; varcost = "<<varcost<<endl;  
//		idcur = sucj; idnext = nextArr[sucj];
//		
//		//checking from sucj till prei:
//		while (idnext != i)
//		{
//			cArrTime = cStartS + problem->c[idcur][idnext];
//			temp = cArrTime - problem->node[idnext].eTW;
//			if (temp > eps)
//			{
//				vioTWCNEW += temp;
//				cStartS = problem->node[idnext].depart;
//			}
//			else
//				cStartS = PDS_MAX(cArrTime, problem->node[idnext].sTW) + problem->node[idnext].duration; //start service time of customer idnext
//		    idcur = idnext; idnext = nextArr[idnext];
//		}
//
//        //now idcur points to prei:
//		//from prei to suci & suci till the end of the leg:
//		if (suci>0) // i was not the last customer of the leg
//		{
//			varcost += (problem->c[prei][suci] - problem->c[prei][i] - problem->c[i][suci]);
//			//cout<<"problem->c[prei][suci] = "<<problem->c[prei][suci]<<"; problem->c[prei][i] = "<<problem->c[prei][i]<<"; problem->c[i][suci] = "<<problem->c[i][suci]<<endl<<"; varcost = "<<varcost<<endl;
//			idnext = suci;
//			while (idnext > 0)
//			{
//				cArrTime = cStartS + problem->c[idcur][idnext];
//				temp = cArrTime - problem->node[idnext].eTW;
//				if (temp > eps)
//				{
//					vioTWCNEW += temp;
//					if (vioTWCus[idnext] > eps)
//					{
//                        moveCus[j][k]->var_cost = varcost;
//						moveCus[j][k]->var_vioTWC = vioTWCNEW - FvioTWCus[idnext];
//						moveCus[j][k]->var_vioTWSP = 0;
//						moveCus[j][k]->atIT = IT;
//					}
//					cStartS = problem->node[idnext].depart;
//				}
//				else cStartS = PDS_MAX(cArrTime, problem->node[idnext].sTW) + problem->node[idnext].duration; //start service time of customer idnext
//				idcur = idnext; idnext = nextArr[idnext];
//			}
//		}
//		else //i was the last customer of the trip:
//		{
//			varcost += (problem->c[prei][firstC_nextT] - problem->c[prei][i] - problem->c[i][firstC_nextT]);
//			//cout<<"problem->c[prei][i] = "<<problem->c[prei][i]<<"; varcost = "<<varcost<<endl;
//		}
//		//now idcur points to the last delivery customer of the trip:
//	}
//
//	//idcur is now the last customer of the trip and cStartS is time to leave the NEW last customer of current vehicle
//
//	double varvioTWC = vioTWCNEW - seg[idVeh].Trip[idTrip].vioTWC;
//	double varvioTWSP = 0;
//	//cout<<"("<<j<<", "<<i<<", "<<cStartS<<", "<<idcur<<", "<<varcost<<", ";
//    GoThroughVehicle(idVeh, nextTrip, varcost, varvioTWC, varvioTWSP, cStartS, idcur, firstC_nextT);
//    //cout<<varcost<<", "<<varvioTWSP<<"), ";
//    moveCus[j][k]->var_vioTWSP = varvioTWSP;
//    moveCus[j][k]->var_vioTWC = varvioTWC;
//    moveCus[j][k]->var_cost = varcost;
//	moveCus[j][k]->atIT = IT;
//}
//
//
//
//void Solution::cal_MoveCusDIAfterJ_oneTrip_NextTripD(int j, int k,int idVeh, int idTrip)
//{
//	//See on 2/12/2013
//	int i = problem->node[j].neighborNode[k].id; //insert customer i after j
//	int prei,suci, idcur, idnext, sucj;
//	double vioTWCNEW, cArrTime, cStartS, temp,varcost;
//	
//	int assSP = seg[idVeh].Trip[idTrip].assSP;
//	
//	int nextTrip = idTrip + 1;
//	int assSP1 = seg[idVeh].Trip[nextTrip].assSP;
//    int firstC_nextT = seg[idVeh].Trip[nextTrip].firstCus;
//
//    prei=predArr[i];suci=nextArr[i]; sucj = nextArr[j];
//	bool lastCChanged = 0;
//
//
//	//if (starti <startj)
//	if (pos[i]<pos[j])
//	{
//		//remove i:
//		if (prei>0) 
//		{
//			vioTWCNEW = FvioTWCus[prei];
//			cArrTime = depart[prei] + problem->c[prei][suci];
//	        varcost = problem->c[prei][suci] - (problem->c[prei][i] + problem->c[i][suci]);
//		}
//		else //i is the first customer of the trip
//		{
//			vioTWCNEW = 0;
//			cArrTime = seg[idVeh].Trip[idTrip].leaveSP + problem->c[assSP][suci];
//            varcost = problem->c[assSP][suci] - (problem->c[assSP][i] + problem->c[i][suci]);
//		}
//		temp = cArrTime - problem->node[suci].eTW;
//		if(temp > eps)
//		{
//			vioTWCNEW +=temp;
//			cStartS = problem->node[suci].depart;
//		}
//		else cStartS = PDS_MAX(cArrTime, problem->node[suci].sTW) + problem->node[suci].duration;
//
//		//from suci to j:
//		idcur = suci;
//		if (suci != j)
//		{
//			idnext = nextArr[suci];
//			while (idnext != sucj)
//			{
//				cArrTime = cStartS + problem->c[idcur][idnext];
//				temp = cArrTime - problem->node[idnext].eTW;
//				if (temp > eps)
//				{
//					vioTWCNEW +=temp;
//					cStartS = problem->node[idnext].depart;
//				}
//				else cStartS = PDS_MAX(cArrTime, problem->node[idnext].sTW) + problem->node[idnext].duration;
//				idcur = idnext; idnext = nextArr[idnext];
//			}
//		}
//
//		//now idnext point to sucj; idcur is j:
//		//insert i after j:
//
//		cArrTime = cStartS + problem->c[idcur][i];
//		temp = cArrTime - problem->node[i].eTW;
//		if (temp > eps)
//		{
//			vioTWCNEW += temp;
//			cStartS = problem->node[i].depart;
//		}
//		else cStartS = PDS_MAX(cArrTime, problem->node[i].sTW) + problem->node[i].duration; //start service time at customer i
//	
//		if (sucj >0)
//		{
//			varcost += ((problem->c[j][i] + problem->c[i][sucj]) - problem->c[j][sucj]);
//			//check from sucj till the end of the trip:
//			idcur=i; idnext=sucj;
//			while (idnext >0)
//			{
//				cArrTime = cStartS + problem->c[idcur][idnext];
//				temp = cArrTime - problem->node[idnext].eTW;
//				if (temp > eps)
//				{
//					vioTWCNEW += temp;
//					if (vioTWCus[idnext] > eps)
//					{
//							moveCus[j][k]->var_cost = varcost;
//							moveCus[j][k]->var_vioTWC = vioTWCNEW - FvioTWCus[idnext];
//							moveCus[j][k]->var_vioTWSP = 0;
//							moveCus[j][k]->atIT = IT;
//							return;
//					}
//					cStartS = problem->node[idnext].depart;
//				}
//				else cStartS = PDS_MAX(cArrTime, problem->node[idnext].sTW) + problem->node[idnext].duration;
//				idcur = idnext;idnext = nextArr[idnext];
//			}
//		} 
//		else //j was the last del cus  --> i is now new lastCus
//		{
//			lastCChanged = 1;
//			idcur=i; 
//			varcost += problem->c[j][i];
//			if (seg[idVeh].Trip[idTrip].waitingS == NO_WS)
//				varcost -= problem->c[j][assSP1];
//			else varcost -= problem->disCWSSP[j][assSP1];
//		}
//	}
//	else // i after j and nextArr[j] !=i:
//	{
//        vioTWCNEW = FvioTWCus[j];
//		//insert i after j:
//		cArrTime = depart[j] + problem->c[j][i];
//		temp = cArrTime - problem->node[i].eTW;
//		if (temp > eps)
//		{
//			vioTWCNEW += temp;
//			cStartS = problem->node[i].depart;
//		}
//		else cStartS = PDS_MAX(cArrTime,problem->node[i].sTW) + problem->node[i].duration; //start service time of customer i
//	
//		//from i to sucj: because nextArr[j] !=i then sucj can not be the endSP:
//		cArrTime = cStartS + problem->c[i][sucj];
//		temp = cArrTime - problem->node[sucj].eTW;
//		if (temp > eps)
//		{
//			vioTWCNEW += temp;
//			cStartS = problem->node[sucj].depart;
//		}
//		else cStartS = PDS_MAX(cArrTime,problem->node[sucj].sTW) + problem->node[sucj].duration; //start service time of customer sucj
//		
//		varcost = problem->c[j][i] + problem->c[i][sucj] - problem->c[j][sucj];
//		//cout<<"problem->c[j][i] = "<<problem->c[j][i]<<"; problem->c[i][sucj] = "<<problem->c[i][sucj]<<"; problem->c[j][sucj] = "<<problem->c[j][sucj]<<"; varcost = "<<varcost<<endl;  
//		idcur = sucj; idnext = nextArr[sucj];
//		
//		//checking from sucj till prei:
//		while (idnext != i)
//		{
//			cArrTime = cStartS + problem->c[idcur][idnext];
//			temp = cArrTime - problem->node[idnext].eTW;
//			if (temp > eps)
//			{
//				vioTWCNEW += temp;
//				cStartS = problem->node[idnext].depart;
//			}
//			else
//				cStartS = PDS_MAX(cArrTime, problem->node[idnext].sTW) + problem->node[idnext].duration; //start service time of customer idnext
//		    idcur = idnext; idnext = nextArr[idnext];
//		}
//
//        //now idcur points to prei:
//		//from prei to suci & suci till the end of the leg:
//		if (suci>0) // i was not the last customer of the leg
//		{
//			varcost += (problem->c[prei][suci] - problem->c[prei][i] - problem->c[i][suci]);
//			//cout<<"problem->c[prei][suci] = "<<problem->c[prei][suci]<<"; problem->c[prei][i] = "<<problem->c[prei][i]<<"; problem->c[i][suci] = "<<problem->c[i][suci]<<endl<<"; varcost = "<<varcost<<endl;
//			idnext = suci;
//			while (idnext > 0)
//			{
//				cArrTime = cStartS + problem->c[idcur][idnext];
//				temp = cArrTime - problem->node[idnext].eTW;
//				if (temp > eps)
//				{
//					vioTWCNEW += temp;
//					if (vioTWCus[idnext] > eps)
//					{
//                        moveCus[j][k]->var_cost = varcost;
//						moveCus[j][k]->var_vioTWC = vioTWCNEW - FvioTWCus[idnext];
//						moveCus[j][k]->var_vioTWSP = 0;
//						moveCus[j][k]->atIT = IT;
//						return;
//					}
//					cStartS = problem->node[idnext].depart;
//				}
//				else cStartS = PDS_MAX(cArrTime, problem->node[idnext].sTW) + problem->node[idnext].duration; //start service time of customer idnext
//				idcur = idnext; idnext = nextArr[idnext];
//			}
//		}
//		else //i was the last customer of the trip:
//		{
//			lastCChanged = 1;
//			if (seg[idVeh].Trip[idTrip].waitingS == NO_WS)
//				varcost -= (problem->c[prei][i] + problem->c[i][assSP1]);
//			else varcost -= (problem->c[prei][i] + problem->disCWSSP[i][assSP1]);
//		}
//		//now idcur points to the last delivery customer of the trip:
//	}
//
//	//idcur is now the last customer of the trip and cStartS is time to leave the NEW last customer of current vehicle
//
//	double varvioTWC = vioTWCNEW - seg[idVeh].Trip[idTrip].vioTWC;
//	//Connect lastCus with assSP of next trip (idVeh, nextTrip):
//	bool stop;
//	double varvioTWSP = 0;
//	if (lastCChanged)
//		stop = calChangeCONNECTAtSP_DD_LastCChanged(idcur, idVeh, nextTrip, cStartS, varvioTWSP, varcost);
//	else
//		stop = calChangeCONNECTAtSP_DD(idcur, idVeh, nextTrip, idTrip, cStartS, varvioTWSP, varcost);
//
//	if (stop == 0)
//	    GoThroughVehicle(idVeh, nextTrip, varcost, varvioTWC, varvioTWSP, cStartS, assSP1, firstC_nextT);
//
//    moveCus[j][k]->var_vioTWSP = varvioTWSP;
//    moveCus[j][k]->var_vioTWC = varvioTWC;
//    moveCus[j][k]->var_cost = varcost;
//    moveCus[j][k]->atIT = IT;;
//}



//bool Solution::SUBcal_MoveCusPIAfterJ_oneTrip(int j, int i, int idVeh, int idTrip, double &varcost, double &varvioTWC, double &varvioTWSP, double &cStartS)
//{
//	//see on 2/12/2013
//    //ALMOST AS SAME AS Solution::cal_MoveCusDIAfterJ_oneTrip_nextTripP
//	int prei,suci, idcur, idnext, sucj;
//	double vioTWCNEW, cArrTime, temp;
//	varvioTWSP = 0;
//	
//	int assSP = seg[idVeh].Trip[idTrip].assSP;
//	bool lastCChanged = 0;
//
//	prei=predArr[i];suci=nextArr[i]; sucj = nextArr[j];
//	varcost = 0;
//	//if (starti <startj)
//	if (pos[i] < pos[j])
//	{
//		//remove i:
//		if (prei > 0) 
//		{
//			vioTWCNEW = FvioTWCus[prei];
//			cArrTime = depart[prei] + problem->c[prei][suci];
//	        varcost = problem->c[prei][suci] - (problem->c[prei][i] + problem->c[i][suci]);
//		}
//		else //i is the first customer of the trip
//		{
//			vioTWCNEW = 0;
//			if (idTrip == 0)
//			{
//				cArrTime = problem->c[0][suci];
//				varcost = problem->c[0][suci] - (problem->c[0][i] + problem->c[i][suci]);
//			}
//			else
//			{
//			    int preT = idTrip - 1;
//				if (seg[idVeh].Trip[preT].Type == 0)
//				{
//			        int assSPp = seg[idVeh].Trip[preT].assSP;
//			        cArrTime = seg[idVeh].Trip[preT].leaveSP + problem->c[assSPp][suci];
//                    varcost = problem->c[assSPp][suci] - (problem->c[assSPp][i] + problem->c[i][suci]);
//				}
//				else
//				{
//					int lastCp = seg[idVeh].Trip[preT].lastCus;
//					cArrTime = depart[lastCp] + problem->c[lastCp][suci];
//					varcost = problem->c[lastCp][suci] - (problem->c[lastCp][i] + problem->c[i][suci]);
//				}
//			}
//		}
//		temp = cArrTime - problem->node[suci].eTW;
//		if (temp > eps) 
//		{
//			vioTWCNEW += temp;
//			cStartS = problem->node[suci].depart;
//		}
//		else cStartS = PDS_MAX(cArrTime, problem->node[suci].sTW) + problem->node[suci].duration;
//
//		//from suci to j:
//		idcur = suci;
//		if (suci != j)
//		{
//			idnext = nextArr[suci];
//			while (idnext != sucj)
//			{
//				cArrTime = cStartS + problem->c[idcur][idnext];
//				temp = cArrTime - problem->node[idnext].eTW;
//				if (temp > eps)
//				{
//					vioTWCNEW += temp;
//					cStartS = problem->node[idnext].depart;
//				}
//				else cStartS = PDS_MAX(cArrTime, problem->node[idnext].sTW) + problem->node[idnext].duration;
//				idcur = idnext; idnext = nextArr[idnext];
//			}
//		}
//
//		//now idnext point to sucj; idcur is j:
//
//		//insert i after j:
//		cArrTime = cStartS + problem->c[j][i];
//		temp = cArrTime - problem->node[i].eTW;
//		if (temp > eps)
//		{
//			vioTWCNEW += temp;
//			cStartS = problem->node[i].depart;
//		}
//		else cStartS = PDS_MAX(cArrTime, problem->node[i].sTW) + problem->node[i].duration;
//
//		if (sucj >0)
//		{
//				varcost += ((problem->c[j][i] + problem->c[i][sucj]) - problem->c[j][sucj]);
//				//check from sucj till the end of the trip:
//				idcur=i; idnext=sucj;
//				while (idnext >0)
//				{
//					cArrTime = cStartS + problem->c[idcur][idnext];
//					temp = cArrTime - problem->node[idnext].eTW;
//					if (temp > eps)
//					{
//						vioTWCNEW += temp;
//						if (vioTWCus[idnext] > eps)
//						{
//							varvioTWC = vioTWCNEW - FvioTWCus[idnext];
//							varvioTWSP = 0;
//							return 1;
//						}
//						cStartS = problem->node[idnext].depart;
//					}
//					else cStartS = PDS_MAX(cArrTime, problem->node[idnext].sTW) + problem->node[idnext].duration;
//					idcur = idnext;idnext = nextArr[idnext];
//				}
//				//cout<<"(@j = "<<j<<", i = "<<i<<", varcost = "<<varcost<<", ";
//		}
//		else //j was the last pick cus
//		{
//			lastCChanged = 1;
//			idcur=i; 
//			varcost += problem->c[j][i];
//			if (seg[idVeh].Trip[idTrip].waitingS == NO_WS) varcost -= problem->c[j][assSP];
//			else varcost -= problem->disCWSSP[j][assSP];
//			//cout<<"(#j = "<<j<<", i = "<<i<<", varcost = "<<varcost<<", ";
//		}
//	}
//	else // i after j and nextArr[j] != i:
//	{
//        vioTWCNEW = FvioTWCus[j];
//		//insert i after j:
//		cArrTime = depart[j] + problem->c[j][i];
//		temp = cArrTime - problem->node[i].eTW;
//		if (temp > eps)
//		{
//			vioTWCNEW += temp;
//			cStartS = problem->node[i].depart;
//		}
//		else cStartS = PDS_MAX(cArrTime,problem->node[i].sTW) + problem->node[i].duration; //start service time of customer i
//		
//		//from i to sucj: because nextArr[j] !=i then sucj can not be the endSP:
//		cArrTime = cStartS + problem->c[i][sucj];
//		temp = cArrTime - problem->node[sucj].eTW;
//		if (temp > eps)
//		{
//			vioTWCNEW += temp;
//			cStartS = problem->node[sucj].depart;
//		}
//		else cStartS = PDS_MAX(cArrTime,problem->node[sucj].sTW) + problem->node[sucj].duration; //start service time of customer sucj
//        varcost = problem->c[j][i] + problem->c[i][sucj] - problem->c[j][sucj];
//		//cout<<"problem->c[j][i] = "<<problem->c[j][i]<<"; problem->c[i][sucj] = "<<problem->c[i][sucj]<<"; problem->c[j][sucj] = "<<problem->c[j][sucj]<<"; varcost = "<<varcost<<endl;  
//		idcur = sucj; idnext = nextArr[sucj];
//		//checking from sucj till prei:
//		while (idnext != i)
//		{
//			cArrTime = cStartS + problem->c[idcur][idnext];
//			temp = cArrTime - problem->node[idnext].eTW;
//			if (temp > eps)
//			{
//				vioTWCNEW += temp;
//				cStartS = problem->node[idnext].depart;
//			}
//			else cStartS = PDS_MAX(cArrTime,problem->node[idnext].sTW) + problem->node[idnext].duration; //start service time of customer idnext
//            idcur = idnext; idnext = nextArr[idnext];
//		}
//
//		//now idcur points to prei:
//		//from prei to suci & suci till the end of the trip:
//		if (suci > 0) // i was not the last customer of the trip
//		{
//			varcost += (problem->c[prei][suci] - problem->c[prei][i] - problem->c[i][suci]);
//			//cout<<"problem->c[prei][suci] = "<<problem->c[prei][suci]<<"; problem->c[prei][i] = "<<problem->c[prei][i]<<"; problem->c[i][suci] = "<<problem->c[i][suci]<<endl<<"; varcost = "<<varcost<<endl;
//			idnext = suci;
//			while (idnext > 0)
//			{
//				cArrTime = cStartS + problem->c[idcur][idnext];
//				temp = cArrTime - problem->node[idnext].eTW;
//				if (temp > eps)
//				{
//					vioTWCNEW += temp;
//					if (vioTWCus[idnext] > eps) 
//					{
//						varvioTWC = vioTWCNEW - FvioTWCus[idnext];
//						varvioTWSP = 0;
//						return 1;
//					}
//					cStartS = problem->node[idnext].depart;
//				}
//				else cStartS = PDS_MAX(cArrTime,problem->node[idnext].sTW) + problem->node[idnext].duration; //start service time of customer idnext
//				idcur = idnext; idnext = nextArr[idnext];
//			}
//			//cout<<"($j = "<<j<<", i = "<<i<<", varcost = "<<varcost<<", ";
//
//		}
//		else //i was the last customer of the trip:
//		{
//			lastCChanged = 1;
//			if (seg[idVeh].Trip[idTrip].waitingS == NO_WS)
//				varcost -= (problem->c[prei][i] + problem->c[i][assSP]);
//			else varcost -= (problem->c[prei][i] + problem->disCWSSP[i][assSP]);
//			//cout<<"(%j = "<<j<<", i = "<<i<<", varcost = "<<varcost<<", ";
//
//		}
//		//now idcur points to the NEW last delivery customer of the trip:
//	}
//
//	varvioTWC = vioTWCNEW - seg[idVeh].Trip[idTrip].vioTWC;
//	//idcur is now the last customer of the trip and cStartS is time to leave the NEW last customer of current vehicle
//	//cout<<"(j = "<<j<<", "<<i<<", varvioTWSP = "<<varvioTWSP<<", depart[lastC = "<<idcur<<"] = "<<cStartS<<"; ";
//    bool stop;
//	if (lastCChanged)
//	{
//		stop = calChangeCONNECTAtSP_PickTrip_LastCChanged(idcur, idVeh, idTrip, cStartS, varvioTWSP, varcost);
//		//cout<<"-> "<<varvioTWSP<<", leaveSP = "<<cStartS<<"), ";
//	}
//	else
//	{
//		stop = calChangeCONNECTAtSP_PickTrip(idcur, idVeh, idTrip, cStartS, varvioTWSP, varcost); //this one already double vioTWSP in case nextTrip is delivery trip and sameSP
//		//cout<<"->.. "<<varvioTWSP<<", leaveSP = "<<cStartS<<"), ";
//	}
//	//Till here: varvioTWSP already include vioTWSP of nextTrip if nextTrip is deliverytrip and sameSP   
//	//cout<<varvioTWSP<<", ";
//	//if (stop) cout<<"NC !"<<endl;
//	//else cout<<"CHANGED!"<<endl;
//	return stop;
//}


//
//bool Solution::SUBcal_MoveCusPIAfterJ_oneTrip(int j, int i, int idVeh, int idTrip, double &varcost, double &varvioTWC, double &varvioTWSP, double &cStartS, bool &vioTWSPTRUE)
//{
//	//see 2/12/2013
//    //ALMOST AS SAME AS Solution::cal_MoveCusDIAfterJ_oneTrip_nextTripP
//	int prei,suci, idcur, idnext, sucj;
//	double vioTWCNEW, cArrTime, temp;
//	varvioTWSP = 0;
//	
//	int assSP = seg[idVeh].Trip[idTrip].assSP;
//	bool lastCChanged = 0;
//
//	prei=predArr[i];suci=nextArr[i]; sucj = nextArr[j];
//	varcost = 0;
//	//if (starti <startj)
//	if (pos[i] < pos[j])
//	{
//		//remove i:
//		if (prei > 0) 
//		{
//			vioTWCNEW = FvioTWCus[prei];
//			cArrTime = depart[prei] + problem->c[prei][suci];
//	        varcost = problem->c[prei][suci] - (problem->c[prei][i] + problem->c[i][suci]);
//		}
//		else //i is the first customer of the trip
//		{
//			vioTWCNEW = 0;
//			if (idTrip == 0)
//			{
//				cArrTime = problem->c[0][suci];
//				varcost = problem->c[0][suci] - (problem->c[0][i] + problem->c[i][suci]);
//			}
//			else
//			{
//			    int preT = idTrip - 1;
//				if (seg[idVeh].Trip[preT].Type == 0)
//				{
//			        int assSPp = seg[idVeh].Trip[preT].assSP;
//			        cArrTime = seg[idVeh].Trip[preT].leaveSP + problem->c[assSPp][suci];
//                    varcost = problem->c[assSPp][suci] - (problem->c[assSPp][i] + problem->c[i][suci]);
//				}
//				else
//				{
//					int lastCp = seg[idVeh].Trip[preT].lastCus;
//					cArrTime = depart[lastCp] + problem->c[lastCp][suci];
//					varcost = problem->c[lastCp][suci] - (problem->c[lastCp][i] + problem->c[i][suci]);
//				}
//			}
//		}
//		temp = cArrTime - problem->node[suci].eTW;
//		if (temp > eps) 
//		{
//			vioTWCNEW += temp;
//			cStartS = problem->node[suci].depart;
//		}
//		else cStartS = PDS_MAX(cArrTime, problem->node[suci].sTW) + problem->node[suci].duration;
//
//		//from suci to j:
//		idcur = suci;
//		if (suci != j)
//		{
//			idnext = nextArr[suci];
//			while (idnext != sucj)
//			{
//				cArrTime = cStartS + problem->c[idcur][idnext];
//				temp = cArrTime - problem->node[idnext].eTW;
//				if (temp > eps)
//				{
//					vioTWCNEW += temp;
//					cStartS = problem->node[idnext].depart;
//				}
//				else cStartS = PDS_MAX(cArrTime, problem->node[idnext].sTW) + problem->node[idnext].duration;
//				idcur = idnext; idnext = nextArr[idnext];
//			}
//		}
//
//		//now idnext point to sucj; idcur is j:
//
//		//insert i after j:
//		cArrTime = cStartS + problem->c[j][i];
//		temp = cArrTime - problem->node[i].eTW;
//		if (temp > eps)
//		{
//			vioTWCNEW += temp;
//			cStartS = problem->node[i].depart;
//		}
//		else cStartS = PDS_MAX(cArrTime, problem->node[i].sTW) + problem->node[i].duration;
//
//		if (sucj >0)
//		{
//				varcost += ((problem->c[j][i] + problem->c[i][sucj]) - problem->c[j][sucj]);
//				//check from sucj till the end of the trip:
//				idcur=i; idnext=sucj;
//				while (idnext >0)
//				{
//					cArrTime = cStartS + problem->c[idcur][idnext];
//					temp = cArrTime - problem->node[idnext].eTW;
//					if (temp > eps)
//					{
//						vioTWCNEW += temp;
//						if (vioTWCus[idnext] > eps)
//						{
//							varvioTWC = vioTWCNEW - FvioTWCus[idnext];
//							varvioTWSP = 0;
//							return 1;
//						}
//						cStartS = problem->node[idnext].depart;
//					}
//					else cStartS = PDS_MAX(cArrTime, problem->node[idnext].sTW) + problem->node[idnext].duration;
//					idcur = idnext;idnext = nextArr[idnext];
//				}
//				//cout<<"(@j = "<<j<<", i = "<<i<<", varcost = "<<varcost<<", ";
//		}
//		else //j was the last pick cus
//		{
//			lastCChanged = 1;
//			idcur=i; 
//			varcost += problem->c[j][i];
//			if (seg[idVeh].Trip[idTrip].waitingS == NO_WS) varcost -= problem->c[j][assSP];
//			else varcost -= problem->disCWSSP[j][assSP];
//			//cout<<"(#j = "<<j<<", i = "<<i<<", varcost = "<<varcost<<", ";
//		}
//	}
//	else // i after j and nextArr[j] != i:
//	{
//        vioTWCNEW = FvioTWCus[j];
//		//insert i after j:
//		cArrTime = depart[j] + problem->c[j][i];
//		temp = cArrTime - problem->node[i].eTW;
//		if (temp > eps)
//		{
//			vioTWCNEW += temp;
//			cStartS = problem->node[i].depart;
//		}
//		else cStartS = PDS_MAX(cArrTime,problem->node[i].sTW) + problem->node[i].duration; //start service time of customer i
//		
//		//from i to sucj: because nextArr[j] !=i then sucj can not be the endSP:
//		cArrTime = cStartS + problem->c[i][sucj];
//		temp = cArrTime - problem->node[sucj].eTW;
//		if (temp > eps)
//		{
//			vioTWCNEW += temp;
//			cStartS = problem->node[sucj].depart;
//		}
//		else cStartS = PDS_MAX(cArrTime,problem->node[sucj].sTW) + problem->node[sucj].duration; //start service time of customer sucj
//        varcost = problem->c[j][i] + problem->c[i][sucj] - problem->c[j][sucj];
//		//cout<<"problem->c[j][i] = "<<problem->c[j][i]<<"; problem->c[i][sucj] = "<<problem->c[i][sucj]<<"; problem->c[j][sucj] = "<<problem->c[j][sucj]<<"; varcost = "<<varcost<<endl;  
//		idcur = sucj; idnext = nextArr[sucj];
//		//checking from sucj till prei:
//		while (idnext != i)
//		{
//			cArrTime = cStartS + problem->c[idcur][idnext];
//			temp = cArrTime - problem->node[idnext].eTW;
//			if (temp > eps)
//			{
//				vioTWCNEW += temp;
//				cStartS = problem->node[idnext].depart;
//			}
//			else cStartS = PDS_MAX(cArrTime,problem->node[idnext].sTW) + problem->node[idnext].duration; //start service time of customer idnext
//            idcur = idnext; idnext = nextArr[idnext];
//		}
//
//		//now idcur points to prei:
//		//from prei to suci & suci till the end of the trip:
//		if (suci > 0) // i was not the last customer of the trip
//		{
//			varcost += (problem->c[prei][suci] - problem->c[prei][i] - problem->c[i][suci]);
//			//cout<<"problem->c[prei][suci] = "<<problem->c[prei][suci]<<"; problem->c[prei][i] = "<<problem->c[prei][i]<<"; problem->c[i][suci] = "<<problem->c[i][suci]<<endl<<"; varcost = "<<varcost<<endl;
//			idnext = suci;
//			while (idnext > 0)
//			{
//				cArrTime = cStartS + problem->c[idcur][idnext];
//				temp = cArrTime - problem->node[idnext].eTW;
//				if (temp > eps)
//				{
//					vioTWCNEW += temp;
//					if (vioTWCus[idnext] > eps) 
//					{
//						varvioTWC = vioTWCNEW - FvioTWCus[idnext];
//						varvioTWSP = 0;
//						return 1;
//					}
//					cStartS = problem->node[idnext].depart;
//				}
//				else cStartS = PDS_MAX(cArrTime,problem->node[idnext].sTW) + problem->node[idnext].duration; //start service time of customer idnext
//				idcur = idnext; idnext = nextArr[idnext];
//			}
//			//cout<<"($j = "<<j<<", i = "<<i<<", varcost = "<<varcost<<", ";
//
//		}
//		else //i was the last customer of the trip:
//		{
//			lastCChanged = 1;
//			if (seg[idVeh].Trip[idTrip].waitingS == NO_WS)
//				varcost -= (problem->c[prei][i] + problem->c[i][assSP]);
//			else varcost -= (problem->c[prei][i] + problem->disCWSSP[i][assSP]);
//			//cout<<"(%j = "<<j<<", i = "<<i<<", varcost = "<<varcost<<", ";
//
//		}
//		//now idcur points to the NEW last delivery customer of the trip:
//	}
//
//	varvioTWC = vioTWCNEW - seg[idVeh].Trip[idTrip].vioTWC;
//	//idcur is now the last customer of the trip and cStartS is time to leave the NEW last customer of current vehicle
//	//cout<<"(j = "<<j<<", "<<i<<", varvioTWSP = "<<varvioTWSP<<", depart[lastC = "<<idcur<<"] = "<<cStartS<<"; ";
//    bool stop;
//	if (lastCChanged)
//	{
//		stop = calChangeCONNECTAtSP_PickTrip_LastCChanged(idcur, idVeh, idTrip, cStartS, varvioTWSP, varcost,vioTWSPTRUE);
//		//cout<<"-> "<<varvioTWSP<<", leaveSP = "<<cStartS<<"), ";
//	}
//	else
//	{
//		stop = calChangeCONNECTAtSP_PickTrip(idcur, idVeh, idTrip, cStartS, varvioTWSP, varcost, vioTWSPTRUE); //this one already double vioTWSP in case nextTrip is delivery trip and sameSP
//		//cout<<"->.. "<<varvioTWSP<<", leaveSP = "<<cStartS<<"), ";
//	}
//	//Till here: varvioTWSP already include vioTWSP of nextTrip if nextTrip is deliverytrip and sameSP   
//	//cout<<varvioTWSP<<", ";
//	//if (stop) cout<<"NC !"<<endl;
//	//else cout<<"CHANGED!"<<endl;
//	return stop;
//}
//
//void Solution::cal_MoveCusPIAfterJ_oneTrip_LastTrip(int j, int i, int idVeh, int idTrip, double &varcost, double &varvioTWC, double &varvioTWSP, double &cStartS)
//{
//	//See on 2/12/2013
//	//COPY bool Solution::SUBcal_MoveCusPIAfterJ_oneTrip
//	int prei,suci, idcur, idnext, sucj;
//	double vioTWCNEW, cArrTime, temp;
//	varvioTWSP = 0;
//	
//	int assSP = seg[idVeh].Trip[idTrip].assSP;
//	bool lastCChanged = 0;
//
//	prei=predArr[i];suci=nextArr[i]; sucj = nextArr[j];
//	varcost = 0;
//	//if (starti <startj)
//	if (pos[i] < pos[j])
//	{
//		//remove i:
//		if (prei > 0) 
//		{
//			vioTWCNEW = FvioTWCus[prei];
//			cArrTime = depart[prei] + problem->c[prei][suci];
//	        varcost = problem->c[prei][suci] - (problem->c[prei][i] + problem->c[i][suci]);
//		}
//		else //i is the first customer of the trip
//		{
//			vioTWCNEW = 0;
//			if (idTrip == 0)
//			{
//				cArrTime = problem->c[0][suci];
//				varcost = problem->c[0][suci] - (problem->c[0][i] + problem->c[i][suci]);
//			}
//			else
//			{
//			    int preT = idTrip - 1;
//				if (seg[idVeh].Trip[preT].Type == 0)
//				{
//			        int assSPp = seg[idVeh].Trip[preT].assSP;
//			        cArrTime = seg[idVeh].Trip[preT].leaveSP + problem->c[assSPp][suci];
//                    varcost = problem->c[assSPp][suci] - (problem->c[assSPp][i] + problem->c[i][suci]);
//				}
//				else
//				{
//					int lastCp = seg[idVeh].Trip[preT].lastCus;
//					cArrTime = depart[lastCp] + problem->c[lastCp][suci];
//					varcost = problem->c[lastCp][suci] - (problem->c[lastCp][i] + problem->c[i][suci]);
//				}
//			}
//		}
//		temp = cArrTime - problem->node[suci].eTW;
//		if (temp > eps) 
//		{
//			vioTWCNEW += temp;
//			cStartS = problem->node[suci].depart;
//		}
//		else cStartS = PDS_MAX(cArrTime, problem->node[suci].sTW) + problem->node[suci].duration;
//
//		//from suci to j:
//		idcur = suci;
//		if (suci != j)
//		{
//			idnext = nextArr[suci];
//			while (idnext != sucj)
//			{
//				cArrTime = cStartS + problem->c[idcur][idnext];
//				temp = cArrTime - problem->node[idnext].eTW;
//				if (temp > eps)
//				{
//					vioTWCNEW += temp;
//					cStartS = problem->node[idnext].depart;
//				}
//				else cStartS = PDS_MAX(cArrTime, problem->node[idnext].sTW) + problem->node[idnext].duration;
//				idcur = idnext; idnext = nextArr[idnext];
//			}
//		}
//
//		//now idnext point to sucj; idcur is j:
//
//		//insert i after j:
//		cArrTime = cStartS + problem->c[j][i];
//		temp = cArrTime - problem->node[i].eTW;
//		if (temp > eps)
//		{
//			vioTWCNEW += temp;
//			cStartS = problem->node[i].depart;
//		}
//		else cStartS = PDS_MAX(cArrTime, problem->node[i].sTW) + problem->node[i].duration;
//
//		if (sucj > 0)
//		{
//				varcost += ((problem->c[j][i] + problem->c[i][sucj]) - problem->c[j][sucj]);
//				//check from sucj till the end of the trip:
//				idcur=i; idnext=sucj;
//				while (idnext >0)
//				{
//					cArrTime = cStartS + problem->c[idcur][idnext];
//					temp = cArrTime - problem->node[idnext].eTW;
//					if (temp > eps)
//					{
//						vioTWCNEW += temp;
//						if (vioTWCus[idnext] > eps)
//						{
//							varvioTWC = vioTWCNEW - FvioTWCus[idnext];
//							varvioTWSP = 0;
//							return;
//						}
//						cStartS = problem->node[idnext].depart;
//					}
//					else cStartS = PDS_MAX(cArrTime, problem->node[idnext].sTW) + problem->node[idnext].duration;
//					idcur = idnext;idnext = nextArr[idnext];
//				}
//				//cout<<"(@j = "<<j<<", i = "<<i<<", varcost = "<<varcost<<", ";
//		}
//		else //j was the last pick cus
//		{
//			lastCChanged = 1;
//			idcur=i; 
//			varcost += problem->c[j][i];
//			if (seg[idVeh].Trip[idTrip].waitingS == NO_WS) varcost -= problem->c[j][assSP];
//			else varcost -= problem->disCWSSP[j][assSP];
//			//cout<<"(#j = "<<j<<", i = "<<i<<", varcost = "<<varcost<<", ";
//		}
//	}
//	else // i after j and nextArr[j] != i:
//	{
//        vioTWCNEW = FvioTWCus[j];
//		//insert i after j:
//		cArrTime = depart[j] + problem->c[j][i];
//		temp = cArrTime - problem->node[i].eTW;
//		if (temp > eps)
//		{
//			vioTWCNEW += temp;
//			cStartS = problem->node[i].depart;
//		}
//		else cStartS = PDS_MAX(cArrTime,problem->node[i].sTW) + problem->node[i].duration; //start service time of customer i
//		
//		//from i to sucj: because nextArr[j] !=i then sucj can not be the endSP:
//		cArrTime = cStartS + problem->c[i][sucj];
//		temp = cArrTime - problem->node[sucj].eTW;
//		if (temp > eps)
//		{
//			vioTWCNEW += temp;
//			cStartS = problem->node[sucj].depart;
//		}
//		else cStartS = PDS_MAX(cArrTime,problem->node[sucj].sTW) + problem->node[sucj].duration; //start service time of customer sucj
//        varcost = problem->c[j][i] + problem->c[i][sucj] - problem->c[j][sucj];
//		//cout<<"problem->c[j][i] = "<<problem->c[j][i]<<"; problem->c[i][sucj] = "<<problem->c[i][sucj]<<"; problem->c[j][sucj] = "<<problem->c[j][sucj]<<"; varcost = "<<varcost<<endl;  
//		idcur = sucj; idnext = nextArr[sucj];
//		//checking from sucj till prei:
//		while (idnext != i)
//		{
//			cArrTime = cStartS + problem->c[idcur][idnext];
//			temp = cArrTime - problem->node[idnext].eTW;
//			if (temp > eps)
//			{
//				vioTWCNEW += temp;
//				cStartS = problem->node[idnext].depart;
//			}
//			else cStartS = PDS_MAX(cArrTime,problem->node[idnext].sTW) + problem->node[idnext].duration; //start service time of customer idnext
//            idcur = idnext; idnext = nextArr[idnext];
//		}
//
//		//now idcur points to prei:
//		//from prei to suci & suci till the end of the trip:
//		if (suci > 0) // i was not the last customer of the trip
//		{
//			varcost += (problem->c[prei][suci] - problem->c[prei][i] - problem->c[i][suci]);
//			//cout<<"problem->c[prei][suci] = "<<problem->c[prei][suci]<<"; problem->c[prei][i] = "<<problem->c[prei][i]<<"; problem->c[i][suci] = "<<problem->c[i][suci]<<endl<<"; varcost = "<<varcost<<endl;
//			idnext = suci;
//			while (idnext > 0)
//			{
//				cArrTime = cStartS + problem->c[idcur][idnext];
//				temp = cArrTime - problem->node[idnext].eTW;
//				if (temp > eps)
//				{
//					vioTWCNEW += temp;
//					if (vioTWCus[idnext] > eps) 
//					{
//						varvioTWC = vioTWCNEW - FvioTWCus[idnext];
//						varvioTWSP = 0;
//						return;
//					}
//					cStartS = problem->node[idnext].depart;
//				}
//				else cStartS = PDS_MAX(cArrTime,problem->node[idnext].sTW) + problem->node[idnext].duration; //start service time of customer idnext
//				idcur = idnext; idnext = nextArr[idnext];
//			}
//			//cout<<"($j = "<<j<<", i = "<<i<<", varcost = "<<varcost<<", ";
//
//		}
//		else //i was the last customer of the trip:
//		{
//			lastCChanged = 1;
//			if (seg[idVeh].Trip[idTrip].waitingS == NO_WS)
//				varcost -= (problem->c[prei][i] + problem->c[i][assSP]);
//			else varcost -= (problem->c[prei][i] + problem->disCWSSP[i][assSP]);
//			//cout<<"(%j = "<<j<<", i = "<<i<<", varcost = "<<varcost<<", ";
//
//		}
//		//now idcur points to the NEW last delivery customer of the trip:
//	}
//
//	varvioTWC = vioTWCNEW - seg[idVeh].Trip[idTrip].vioTWC;
//	//idcur is now the last customer of the trip and cStartS is time to leave the NEW last customer of current vehicle
//	if (lastCChanged)
//	{
//		//dont check the case p-d-SAMESP where d is the next trip of (idVeh, idTrip)
//		calChangeCONNECTAtSP_PickTrip_LastCChanged2(idcur, idVeh, idTrip, cStartS, varvioTWSP, varcost);
//	}
//	else
//	{
//		//dont check the case p-d-SAMESP where d is the next trip of (idVeh, idTrip)
//		calChangeCONNECTAtSP_PickTrip2(idcur, idVeh, idTrip, cStartS, varvioTWSP, varcost); 
//	}
//}
//
//void Solution::cal_MoveCusPIAfterJ_oneTrip_NextTripPORC2C(int j, int i, int idVeh, int idTrip, double &varcost, double &varvioTWC, double &varvioTWSP)
//{
//	//see on 2/12/2013
//   double cStartS;
//   if (SUBcal_MoveCusPIAfterJ_oneTrip(j, i, idVeh, idTrip, varcost, varvioTWC, varvioTWSP, cStartS)== 0)
//   {
//       int nextT = idTrip + 1;
//       int firstC_nextT = seg[idVeh].Trip[nextT].firstCus;
//       GoThroughVehicle(idVeh, nextT, varcost, varvioTWC, varvioTWSP, cStartS, seg[idVeh].Trip[idTrip].assSP, firstC_nextT);
//   }
//  // cout<<varvioTWC<<", nP); ";
//}
//
//void Solution::cal_MoveCusPIAfterJ_oneTrip_NextTripD_SameSP(int j, int i, int idVeh, int idTrip, double &varcost, double &varvioTWC, double &varvioTWSP)
//{
//	//see 2/12/2013
//   double cStartS; 
//   bool vioTWSPTRUE;
//   if (SUBcal_MoveCusPIAfterJ_oneTrip(j, i, idVeh, idTrip, varcost, varvioTWC, varvioTWSP, cStartS, vioTWSPTRUE)== 0)
//   {
//		//varvioTWSP *= 2; //already calculated at SUBcal_MoveCusPIAfterJ_oneTrip through call procedures calChangeCONNECTAtSP_PickTrip_LastCChanged/calChangeCONNECTAtSP_PickTrip
//		int assSP = seg[idVeh].Trip[idTrip].assSP;
//		//Update 16/11/2013
//		if (vioTWSPTRUE) cStartS = problem->leaveSP[assSP][1];//load only at eTW2
//		else cStartS += problem->nodeSP[assSP].load;
//	 
//		int nextT = idTrip + 1;
// 	    int firstC_nextT = seg[idVeh].Trip[nextT].firstCus;
//		GoThroughVehicle(idVeh, nextT, varcost, varvioTWC, varvioTWSP, cStartS, assSP, firstC_nextT);
//   }
//   //cout<<varvioTWSP<<", nDS); ";
//}
//
//void Solution::cal_MoveCusPIAfterJ_oneTrip_NextTripD_DifSP(int j, int i, int idVeh, int idTrip, double &varcost, double &varvioTWC, double &varvioTWSP)
//{
//	//see 2/12/2013
//   double cStartS; 
//   if (SUBcal_MoveCusPIAfterJ_oneTrip(j, i, idVeh, idTrip, varcost, varvioTWC, varvioTWSP, cStartS)== 0)
//   {
//		int nextT = idTrip + 1;
// 	    int firstC_nextT = seg[idVeh].Trip[nextT].firstCus;
//		if (calChangeCONNECTAtSP_SPSP(idVeh, nextT, idTrip, cStartS, varvioTWSP, varcost) == 0)
//			GoThroughVehicle(idVeh, nextT, varcost, varvioTWC, varvioTWSP, cStartS, seg[idVeh].Trip[nextT].assSP, firstC_nextT);
//   }
//   //cout<<varvioTWC<<", nDD); ";
//}
//
//
//void Solution::cal_MoveCusPIAfterJ_oneVeh(int j, int idTripj, int i, int idTripi, int idVeh, double &varcost, double &varcosti, double &varcostj, double &varvioTWC, double &varvioTWCi, double &varvioTWCj, double &varvioTWSP, double &varvioTWSPi, double &varvioTWSPj, int &varvioCAP)
//{
//	//see 2/12/2013
//   //move cus i on (idVeh, idTripi) after cus j on (idVeh, idTripj)
//    bool stop;
//	int numCi = seg[idVeh].Trip[idTripi].numCus;
//	int lastT = seg[idVeh].numTrips - 1;
//	varcost = 0; varvioTWC = 0; varvioTWSP = 0; varvioCAP = 0;
//	varcosti = 0; varcostj = 0;
//	varvioTWCi = 0; varvioTWCj = 0;
//	varvioTWSPi = 0; varvioTWSPj = 0;
//	double cStartS;
//	if (idTripi < idTripj)
//	{
//		int preTjNEW = idTripj - 1;
//		//1.Del cus i and gothroughVehicle till (idTripj-1)
//		if (idTripi == 0)
//		{
//				if (numCi == 1)
//				{
//				    if (idTripi < preTjNEW)
//					   stop = cal_deleteCusArrayP_FirstTrip_Empty_TillTrip(idVeh, varcosti, varvioTWCi, varvioTWSPi, cStartS, preTjNEW); //27/11/2013
//					else
//					{
//					   //i belongs to the first cus where there is only one customer --> delete i, this trip becomes empty
//					   //then insert i after j on the second trip --> after empty the first trip, this second trip becomes the first trip
//					   cal_deleteCusArrayP_FirstTrip_Empty_insertNextTrip(j,i,idVeh, varcosti, varvioTWCi, varvioTWSPi, varcostj, varvioTWCj, varvioTWSPj, varvioCAP);
//					   varcost = varcosti + varcostj;
//		               varvioTWC = varvioTWCi + varvioTWCj;
//		               varvioTWSP = varvioTWSPi + varvioTWSPj;
//					   return;
//					}
//					//preTjNEW --; removed on 11/12/2013
//				}
//				else if (numCi == 2)
//					stop = cal_deleteCusP_FirstTrip_2Cus_TillTrip(idVeh, i, varcosti, varvioTWCi, varvioTWSPi, varvioCAP, cStartS, preTjNEW);
//				else 
//					stop = cal_deleteCusArrayP_FirstMiddleTrip_TillTrip(idVeh, 0, i, varcosti, varvioTWCi, varvioTWSPi, varvioCAP, cStartS, preTjNEW);
//		}
//		else
//		{
//				if (numCi == 1) 
//				{
//					stop = cal_deleteCusArrayPORC2C_MiddleTrip_Empty_TillTrip(idVeh, idTripi, varcosti, varvioTWCi, varvioTWSPi, cStartS, preTjNEW);
//                   	if (idTripi == preTjNEW) preTjNEW--; //updated on 11/12/2013
//				}
//				else 
//					stop = cal_deleteCusArrayP_FirstMiddleTrip_TillTrip(idVeh, idTripi, i, varcosti, varvioTWCi, varvioTWSPi, varvioCAP, cStartS, preTjNEW);
//		}
//
//		//2.Insert i after j (from beginning/from j depends on changed or not) and gothroughVehicle till the end of vehicle
//		if (stop) //nothing change
//		{
//				if (seg[idVeh].Trip[idTripj].lastCus == j)
//				{
//					if (idTripj == lastT)
//						SUBcal_InsertCusPIAfterJ_LastC1(j, i, idVeh, idTripj, varvioCAP, varcostj, varvioTWCj, varvioTWSPj, cStartS);
//					else
//					{
//						int nextT = idTripj + 1;
//						if (seg[idVeh].Trip[nextT].Type == 1)
//						{
//							if (seg[idVeh].Trip[idTripj].assSP == seg[idVeh].Trip[nextT].assSP) //j is the last pickup customer, nextTrip is delivery trip, sameSP
//								cal_InsertCusPIAfterJ_LastC_NextTripD_SameSP(j, i, idVeh, idTripj, varvioCAP, varcostj, varvioTWCj, varvioTWSPj);
//							else
//								cal_InsertCusPIAfterJ_LastC_NextTripD_DifSP(j, i, idVeh, idTripj, varvioCAP, varcostj, varvioTWCj, varvioTWSPj);
//						}
//						else
//						   cal_InsertCusPIAfterJ_LastC_NextTripPORC2C(j, i, idVeh, idTripj,varvioCAP, varcostj, varvioTWCj, varvioTWSPj);
//					}
//				}
//				else //j is not the last cus; NOT CHANGE
//				{
//					if (idTripj == lastT)
//						SUBcal_InsertCusPIAfterJ_NotLastC1(j, i, idVeh, idTripj, varvioCAP, varcostj, varvioTWCj, varvioTWSPj, cStartS);
//					else
//					{
//						int nextT = idTripj + 1;
//						if (seg[idVeh].Trip[nextT].Type == 1)
//						{
//							if (seg[idVeh].Trip[idTripj].assSP == seg[idVeh].Trip[nextT].assSP) //j is the last pickup customer, nextTrip is delivery trip, sameSP
//								cal_InsertCusPIAfterJ_NotLastC_NextTripD_SameSP(j, i, idVeh, idTripj, varvioCAP, varcostj, varvioTWCj, varvioTWSPj);
//							else
//								cal_InsertCusPIAfterJ_NotLastC_NextTripD_DifSP(j, i, idVeh, idTripj, varvioCAP, varcostj, varvioTWCj, varvioTWSPj);
//						}
//						else
//						   cal_InsertCusPIAfterJ_NotLastC_NextTripPORC2C(j, i, idVeh, idTripj,varvioCAP, varcostj, varvioTWCj, varvioTWSPj);
//					}
//				}//end j is not the lastcus; NOT CHANGE
//		}
//		else //there is a change
//		{
//				//cStartS is taken from before
//				cal_InsertCusPIAfterJ_FromBeginning(j, i, idVeh, idTripj, preTjNEW, varvioCAP, varcostj, varvioTWCj, varvioTWSPj, cStartS);
//		}//end there is a change
//		varcost = varcosti + varcostj;
//		varvioTWC = varvioTWCi + varvioTWCj;
//		varvioTWSP = varvioTWSPi + varvioTWSPj;
//	}
//	else //idTripi > idTripj
//	{
//		 int preTi = idTripi - 1;
//		 int lastT = seg[idVeh].numTrips - 1;
//		//1.Insert i after j and gothroughVehicle till (idTripi - 1)
//		//2. Delete i from beginning/from prei depends on changed or not, then gothroughVehicle till the endof vehicle
//		 if (idTripj == 0 && seg[idVeh].Trip[idTripj].numCus == 1)
//			stop = cal_InsertCusPIAfterJ_LastC_1CusFirstTrip_TillTrip(j, i,idVeh, varvioCAP, varcostj, varvioTWCj, varvioTWSPj, cStartS, preTi); 
//		 else
//			stop = cal_InsertCusPIAfterJ_OneVeh_TillTrip(j, i, idVeh, idTripj, varvioCAP, varcostj, varvioTWCj, varvioTWSPj, cStartS, preTi);
//
//		 if (stop) //not change
//		 {
//			  //cout<<"j = "<<j<<", i = "<<i<<"; NC! ";
//			  //idTripi > 0:
//			  if (numCi == 1) 
//			  {
//				 if (idTripi < lastT) 
//					 cal_deleteCusArrayPORC2C_MiddleTrip_Empty_TillTrip(idVeh,idTripi,varcosti,varvioTWCi,varvioTWSPi,cStartS,lastT); //11/12/2013
//				 else 
//			         cal_deleteCusArrayPORC2C_LastTrip_Empty(idVeh, idTripi, varcosti, varvioTWCi, varvioTWSPi);
//			  }
//			  else
//			  {
//					if (idTripi < lastT)
//						 cal_deleteCusArrayP_FirstMiddleTrip_TillTrip(idVeh, idTripi, i, varcosti, varvioTWCi, varvioTWSPi, varvioCAP, cStartS, lastT);
//					else
//				      cal_deleteCusArrayP_LastTrip(idVeh, idTripi, i, varcosti, varvioTWCi, varvioTWSPi, varvioCAP);
//			  }
//		 }
//		 else //there is a change
//		 {
//			 // cout<<"j = "<<j<<", i = "<<i<<"; cStartS = "<<cStartS<<"; CHANGED!"<<endl;
//			 //cStartS is taken from before
//			  if (numCi == 1) 
//			  {
//				 if (idTripi < lastT)
//					 cal_deleteCusArrayPORC2C_MiddleTrip_Empty_FromBeginning(idVeh, idTripi, varcosti, varvioTWCi, varvioTWSPi, cStartS);
//				 else 
//			         cal_deleteCusArrayPORC2C_LastTrip_Empty(idVeh, idTripi, varcosti, varvioTWCi, varvioTWSPi);
//			  }
//			  else 
//			  {
//				 if (idTripi < lastT)
//					 cal_deleteCusArrayP_MiddleTrip_FromBeginning(idVeh, idTripi, i, varcosti, varvioTWCi, varvioTWSPi, varvioCAP, cStartS);
//				 else 
//				     cal_deleteCusArrayP_LastTrip_FromBeginning(idVeh, idTripi, i, varcosti, varvioTWCi, varvioTWSPi, varvioCAP, cStartS);
//			  }
//		 }//end there is a change
//		 varcost = varcosti + varcostj;
//		varvioTWC = varvioTWCi + varvioTWCj;
//		varvioTWSP = varvioTWSPi + varvioTWSPj;
//	}//end idTripi > idTripj
//}
//
//
//
//void Solution::SUBcal_MoveCusC2CIAfterJ_oneTrip_LastC(int j, int i, int idVeh, int idTrip, double &varvioTWC, int &varvioCAP, int &CapVehCus, double &cStartS, double &varcost)
//{
//	//12/12/2013: move cus i and delID of cus i after cus j; calculate vioTWCNEW, vioCAPNEW, varcost till i (NOT till delID of cusDi) when the move is done
//	int prei,suci, curC, nextC, cusDi, tQ;
//	double cArrTime,temp;
//
//	prei=predArr[i];suci=nextArr[i];
//	cusDi = problem->node[i].delID;
//	int pre_cusDi = predArr[cusDi];
//	int next_cusDi = nextArr[cusDi];
//	if (cusDi != suci)
//	{
//		if (prei > 0) 
//		{
//			//vioTWCNEW = FvioTWCus[prei];
//			//vioCAPNEW = FvioCAPCus[prei];
//			cArrTime = depart[prei] + problem->c[prei][suci];
//			varcost = problem->c[prei][suci] - (problem->c[prei][i] + problem->c[i][suci]);
//			CapVehCus = CAPCus[prei] + problem->node[suci].capacity;
//			tQ = CapVehCus - Q;
//			if (tQ > 0) {varvioCAP += tQ; CapVehCus = Q;}
//		}
//		else //i is the first customer of the trip, cusDi != suci
//		{
//			//vioTWCNEW = 0; vioCAPNEW = 0;
//			CapVehCus = problem->node[suci].capacity;
//			if (idTrip == 0) //vehicle has only one C2C trip
//			{
//				cArrTime = problem->c[0][suci];
//				varcost = problem->c[0][suci] - (problem->c[0][i] + problem->c[i][suci]);
//			}
//			else
//			{
//				int preT = idTrip - 1;
//				if (seg[idVeh].Trip[preT].Type == 0)
//				{
//			        int assSPp = seg[idVeh].Trip[preT].assSP;
//			        cArrTime = seg[idVeh].Trip[preT].leaveSP + problem->c[assSPp][suci];
//                    varcost = problem->c[assSPp][suci] - (problem->c[assSPp][i] + problem->c[i][suci]);
//				}
//				else //seg[idVeh].Trip[preT].Type == 1 || 2
//				{
//					int lastCp = seg[idVeh].Trip[preT].lastCus;
//					cArrTime = depart[lastCp] + problem->c[lastCp][suci];
//					varcost = problem->c[lastCp][suci] - (problem->c[lastCp][i] + problem->c[i][suci]);
//				}
//			}
//		}//end i is the first customer of the trip, cusDi != suci
//		//Checking suci:
//		varvioCAP  -= vioCAPCus[suci];
//		temp = cArrTime - problem->node[suci].eTW;
//		if (temp > eps) 
//		{
//			varvioTWC += temp;
//			cStartS = problem->node[suci].depart;
//		}
//		else cStartS = PDS_MAX(cArrTime, problem->node[suci].sTW) + problem->node[suci].duration;
//		varvioTWC -= vioTWCus[suci];
//
//		curC = suci; nextC = nextArr[suci]; 
//		bool contCAP = 1; bool contTW = 1;
//		while (nextC != cusDi && contCAP && contTW)
//		{
//			cArrTime = cStartS + problem->c[curC][nextC];
//		    temp = cArrTime - problem->node[nextC].eTW;
//			if (temp > eps)
//			{
//				varvioTWC += temp;
//				if (vioTWCus[nextC] > eps) 
//				{
//					varvioTWC -= vioTWCus[nextC];
//					cStartS = depart[pre_cusDi]; 
//					contTW = 0;
//				}
//				else cStartS = problem->node[nextC].depart;
//			}
//			else cStartS = PDS_MAX(cArrTime, problem->node[nextC].sTW) + problem->node[nextC].duration;
//			CapVehCus += problem->node[nextC].capacity;
//			tQ = CapVehCus - Q;
//			if (tQ > 0) 
//			{
//				varvioTWC += tQ;
//				if (vioCAPCus[nextC] > 0) 
//				{
//					varvioCAP -= vioCAPCus[nextC];
//					CapVehCus = CAPCus[pre_cusDi];
//					contCAP = 0;
//				}
//				else CapVehCus = Q;
//			}
//			curC = nextC; nextC = nextArr[curC];
//		}//end while (nextC != cusDi && contCAP && contTW)
//		if (nextC != cusDi)
//		{
//			if (contTW)
//			{
//				do
//				{
//					cArrTime = cStartS + problem->c[curC][nextC];
//					temp = cArrTime - problem->node[nextC].eTW;
//					if (temp > eps)
//					{
//						varvioTWC += temp;
//						if (vioTWCus[nextC] > eps) 
//						{
//							varvioTWC -= vioTWCus[nextC];
//							cStartS = depart[pre_cusDi]; 
//							contTW = 0;
//							break;
//						}
//						else cStartS = problem->node[nextC].depart;
//					}
//					else cStartS = PDS_MAX(cArrTime, problem->node[nextC].sTW) + problem->node[nextC].duration;
//					curC = nextC; nextC = nextArr[nextC];
//				}while (nextC != cusDi);
//			}
//			else if (contCAP)
//			{
//				do
//				{
//					CapVehCus += problem->node[nextC].capacity;
//					tQ = CapVehCus - Q;
//					if (tQ > 0) 
//					{
//						varvioCAP += tQ;
//						if (vioCAPCus[nextC] > 0) 
//						{
//							varvioCAP -= vioCAPCus[nextC];
//							CapVehCus = CAPCus[pre_cusDi];
//							contCAP = 0;
//							break;
//						}
//						else CapVehCus = Q;
//					}
//					curC = nextC; nextC = nextArr[nextC];
//				}while (nextC != cusDi);
//			}
//			//else {curC = pre_cusDi; nextC = cusDi;}
//		}//end if (nextC != cusDi)
//		//now delete cusDi:
//		varcost += (problem->c[pre_cusDi][next_cusDi] - (problem->c[pre_cusDi][cusDi] + problem->c[cusDi][next_cusDi]));
//		curC = pre_cusDi; nextC = next_cusDi;
//	}
//	else //cusDi == suci
//	{
//		if (prei > 0)
//		{
//			//vioTWCNEW = FvioTWCus[prei];
//			//vioCAPNEW = FvioCAPCus[prei];
//			cStartS = depart[prei];
//			varcost = problem->c[prei][next_cusDi] - (problem->c[prei][i] + problem->c[i][cusDi] + problem->c[cusDi][next_cusDi]);
//			CapVehCus = CAPCus[prei];
//			curC = prei; 
//		}
//		else // i is the first customer of the trip, delID of i is direct succesor of i
//		{
//			//vioTWCNEW = 0; vioCAPNEW = 0;
//			CapVehCus = 0;  
//			if (idTrip == 0) //vehicle has only one C2C trip
//			{
//				cStartS = 0;
//			    curC = 0;
//			}
//			else
//			{
//				int preT = idTrip - 1;
//				if (seg[idVeh].Trip[preT].Type == 0)
//				{
//			        curC = seg[idVeh].Trip[preT].assSP;
//			        cStartS = seg[idVeh].Trip[preT].leaveSP;
//				}
//				else //seg[idVeh].Trip[preT].Type == 1 || 2
//				{
//					curC = seg[idVeh].Trip[preT].lastCus;
//					cStartS = depart[curC];
//				}
//			}
//			varcost = problem->c[curC][next_cusDi] - (problem->c[curC][i] + problem->c[i][cusDi] + problem->c[cusDi][next_cusDi]);
//		}//end i is the first customer of the trip, delID of i is direct succesor of i
//		nextC = next_cusDi;
//	}//end cusDi == suci
//
//	//Checking from next_cusDi till the end of the trip (j):
//	bool contCAP = 1; bool contTW = 1;
//	do
//	{
//			cArrTime = cStartS + problem->c[curC][nextC];
//		    temp = cArrTime - problem->node[nextC].eTW;
//			if (temp > eps)
//			{
//				varvioTWC += temp;
//				if (vioTWCus[nextC] > eps) 
//				{
//					varvioTWC -= vioTWCus[nextC];
//					cStartS = depart[j]; 
//					contTW = 0;
//				}
//				else cStartS = problem->node[nextC].depart;
//			}
//			else cStartS = PDS_MAX(cArrTime, problem->node[nextC].sTW) + problem->node[nextC].duration;
//			CapVehCus += problem->node[nextC].capacity;
//			tQ = CapVehCus - Q;
//			if (tQ > 0) 
//			{
//				varvioCAP += tQ;
//				if (vioCAPCus[nextC] > 0) 
//				{
//					varvioCAP -= vioCAPCus[nextC];
//					CapVehCus = CAPCus[j];
//					contCAP = 0;
//				}
//				else CapVehCus = Q;
//			}
//			curC = nextC; nextC = nextArr[nextC];
//	}while (curC != j && contCAP && contTW);
//	if (curC != j)
//	{
//		if (contTW)
//		{
//			do
//			{
//				cArrTime = cStartS + problem->c[curC][nextC];
//				temp = cArrTime - problem->node[nextC].eTW;
//				if (temp > eps)
//				{
//					varvioTWC += temp;
//					if (vioTWCus[nextC] > eps) 
//					{
//						varvioTWC -= vioTWCus[nextC];
//						cStartS = depart[j]; 
//						break;
//					}
//					else cStartS = problem->node[nextC].depart;
//				}
//				else cStartS = PDS_MAX(cArrTime, problem->node[nextC].sTW) + problem->node[nextC].duration;
//				curC = nextC; nextC = nextArr[nextC];
//			}while (curC != j);
//		}
//		else if (contCAP)
//		{
//			do
//			{
//				CapVehCus += problem->node[nextC].capacity;
//				tQ = CapVehCus - Q;
//				if (tQ > 0) 
//				{
//					varvioCAP += tQ;
//					if (vioCAPCus[nextC] > 0) 
//					{
//						varvioCAP -= vioCAPCus[nextC];
//						CapVehCus = CAPCus[j];
//						contCAP = 0;
//						break;
//					}
//					else CapVehCus = Q;
//				}
//				curC = nextC; nextC = nextArr[nextC];
//			}while (curC != j);
//		}
//		else {curC = j;}
//	}//end if (curC != j)
//	//Now insert i and cusDi at the end of the trip (after j):
//	//Checking i:
//	cArrTime = cStartS + problem->c[j][i];
//    temp = cArrTime - problem->node[i].eTW;
//	if (temp > eps)
//	{
//		varvioTWC += temp;
//		cStartS = problem->node[i].depart;
//	}
//	else cStartS = PDS_MAX(cArrTime, problem->node[i].sTW) + problem->node[i].duration;
//	CapVehCus += problem->node[i].capacity;
//	tQ = CapVehCus - Q;
//	if (tQ > 0) 
//	{
//		varvioCAP += tQ;
//        CapVehCus = Q;
//	}
//}
//
//void Solution::cal_MoveCusC2CIAfterJ_oneTrip_LastTrip_LastC(int j, int i, int k, int idVeh, int idTrip) //j and i are in the same trip; j is the last cus of the trip
//{
//	//12/12/2013: move (i,delID of i) after j which is the last cus of the last trip of idVeh
//	//(i and delID of i) also belong to this trip
//	double cArrTime, cStartS, temp, varvioTWC, varcost; int CapVehCus, varvioCAP;
//	int cusDi = problem->node[i].delID;
//	varvioTWC = -(vioTWCus[i] + vioTWCus[cusDi]);
//	varvioCAP = -(vioCAPCus[i] + vioCAPCus[cusDi]);
//
//	SUBcal_MoveCusC2CIAfterJ_oneTrip_LastC(j, i,idVeh, idTrip, varvioTWC, varvioCAP, CapVehCus, cStartS, varcost);
//	//Checking cusDi:
//	varcost += (problem->c[j][i] + problem->c[i][cusDi] + problem->c[cusDi][0] - problem->c[j][0]);
//	cArrTime = cStartS + problem->c[i][cusDi];
//    temp = cArrTime - problem->node[cusDi].eTW;
//	if (temp > eps)
//	{
//		varvioTWC += temp;
//		//cStartS = problem->node[cusDi].depart;
//	}
//	//else cStartS = PDS_MAX(cArrTime, problem->node[cusDi].sTW) + problem->node[cusDi].duration;
//	CapVehCus += problem->node[cusDi].capacity;
//	int tQ = CapVehCus - Q;
//	if (tQ > 0) 
//	{
//		varvioCAP += tQ;
//        //CapVehCus = Q;
//	}
//	moveCus[j][k]->var_cost = varcost;
//	moveCus[j][k]->var_vioCAP = varvioCAP;
//	moveCus[j][k]->var_vioTWC = varvioTWC;
//	moveCus[j][k]->var_vioTWSP = 0;
//	moveCus[j][k]->atIT = IT;
//	moveC2CDAfter[j][k] = i;
//}
//
//void Solution::cal_MoveCusC2CIAfterJ_oneTrip_LastC(int j, int i, int k, int idVeh, int idTrip) //(idVeh, idTrip) is not the last trip of idVeh
//{
//	//12/12/2013: move (i,delID of i) after j which is the last cus of the NOT last trip of idVeh
//	//(i and delID of i) also belong to this trip
//
//	double cArrTime, cStartS, temp, varvioTWC, varcost; int CapVehCus, varvioCAP;
//	int cusDi = problem->node[i].delID;
//	varvioTWC = -(vioTWCus[i] + vioTWCus[cusDi]);
//	varvioCAP = -(vioCAPCus[i] + vioCAPCus[cusDi]);
//	
//	SUBcal_MoveCusC2CIAfterJ_oneTrip_LastC(j, i,idVeh, idTrip, varvioTWC, varvioCAP, CapVehCus, cStartS, varcost);
//	//Checking cusDi:
//	cArrTime = cStartS + problem->c[i][cusDi];
//    temp = cArrTime - problem->node[cusDi].eTW;
//	if (temp > eps)
//	{
//		varvioTWC += temp;
//		cStartS = problem->node[cusDi].depart;
//	}
//	else cStartS = PDS_MAX(cArrTime, problem->node[cusDi].sTW) + problem->node[cusDi].duration;
//	CapVehCus += problem->node[cusDi].capacity;
//	int tQ = CapVehCus - Q;
//	if (tQ > 0) 
//	{
//		varvioCAP += tQ;
//        //CapVehCus = Q;
//	}
//	int nextT = idTrip + 1; int nextSP = seg[idVeh].Trip[idTrip].nextSP;
//	double varvioTWSP = 0;
//	if (nextSP > 0)
//	{
//    	varcost += (problem->c[j][i] + problem->c[i][cusDi] - seg[idVeh].Trip[idTrip].connectCost);
//		if (calChangeCONNECTAtSP_C2CTrip_LastCChanged(cusDi,idVeh,idTrip,nextT,cStartS,varvioTWSP,varcost) == 0)
//			GoThroughVehicle(idVeh,nextT,varcost,varvioTWC,varvioTWSP,cStartS,cusDi,nextSP);
//	}
//	else //seg[idVeh].Trip[nextT].Type == 0 OR 2
//	{
//		int firstC_nextT = seg[idVeh].Trip[nextT].firstCus;
//    	varcost += (problem->c[j][i] + problem->c[i][cusDi] + problem->c[cusDi][firstC_nextT] - problem->c[j][firstC_nextT]);
//		GoThroughVehicle(idVeh,nextT,varcost,varvioTWC,varvioTWSP,cStartS,cusDi,firstC_nextT);
//	}
//	moveCus[j][k]->var_cost = varcost;
//	moveCus[j][k]->var_vioCAP = varvioCAP;
//	moveCus[j][k]->var_vioTWC = varvioTWC;
//	moveCus[j][k]->var_vioTWSP = varvioTWSP;
//	moveCus[j][k]->atIT = IT;
//	moveC2CDAfter[j][k] = i;
//}
//
//
//void Solution::cal_MoveCusC2CIAfterJ_oneVeh_LastC(int j, int idTripj, int i, int idTripi, int idVeh, int k)
//{
//	//10/12/2013: move cus i and (delID of cus i) after j which is the last cus of the trip (idVeh,idTripj) [may last trip OR Not last trip]
//	// i and j belong to different legs of the same vehicle
//	//copy cal_MoveCusC2CIAfterJ_oneVeh_NotLastC
//    bool stop;
//	int cusDi = problem->node[i].delID;
//	int numCi = seg[idVeh].Trip[idTripi].numCus;
//	int lastT = seg[idVeh].numTrips - 1;
//	double varcost = 0; double varvioTWC = 0; double varvioTWSP = 0; int varvioCAP = 0;
//	double varcosti = 0; double varcostj = 0;
//	double varvioTWCi = 0; double varvioTWCj = 0;
//	double varvioTWSPi = 0; double varvioTWSPj = 0;
//	double cStartS = 0;
//	int nextSP = seg[idVeh].Trip[idTripi].nextSP;
//
//	if (idTripi < idTripj)
//	{
//		int preTj_lastCNEW; bool changed_pre;
//		int preTjNEW = idTripj - 1; nextSP = seg[idVeh].Trip[idTripi].nextSP;
//		//1.Del (cus i and cusDi) and gothroughVehicle till (idTripj-1)
//		if (idTripi == 0)
//		{
//			if (numCi == 2) //idTripi becomes empty
//			{
//			    if (idTripi < preTjNEW)
//				{
//					stop = cal_deleteCusArrayC2C_FirstTrip_Empty_TillTrip(idVeh, varcosti, varvioTWCi, varvioTWSPi, cStartS, preTjNEW); //10/12/2013
//				    changed_pre = 0;
//				}
//				else
//				{
//				   //(i amd cusDi) are first cus where there is only 2 customers --> delete (i, cusDi), this trip becomes empty
//				   //then insert (i, cusDi) right after last cus j on the second trip --> after empty the first trip, this second trip becomes the first trip
//				   cal_deleteCusArrayC2C_FirstTrip_Empty_insertNextTrip_LastC(j,i,idVeh, varcosti, varvioTWCi, varcostj, varvioTWCj, varvioTWSPj, varvioCAP); //10/12/2013
//				   varcost = varcosti + varcostj;
//	               varvioTWC = varvioTWCi + varvioTWCj;
//	               varvioTWSP = varvioTWSPj; varvioTWSPi = 0;
//				   moveCus[j][k]->var_cost = varcost;
//	               moveCus[j][k]->var_vioCAP = 0;
//	               moveCus[j][k]->var_vioTWC = varvioTWC;
//				   moveCus[j][k]->var_vioTWSP = varvioTWSP;
//	               moveCus[j][k]->atIT = IT;
//	               moveC2CDAfter[j][k] = i;
//				   return;
//				}
//			}
//			else if (numCi == 4 && nextSP > 0)
//			{
//				stop = cal_deleteCusC2C_FirstTrip_4Cus_nextD_TillTrip(idVeh, i, varcosti, varvioTWCi, varvioTWSPi, varvioCAP, cStartS, preTjNEW); //10/12/2013
//				changed_pre = 0;
//			}
//			else
//			{
//				stop = cal_deleteCusArrayC2C_FirstMiddleTrip_TillTrip(idVeh, 0, i, varcosti, varvioTWCi, varvioTWSPi, varvioCAP, cStartS, preTjNEW); //10/12/2013
//			    changed_pre = 1;
//			}			
//		}
//		else //idTripi > 0
//		{
//			if (numCi == 2) 
//			{
//				stop = cal_deleteCusArrayPORC2C_MiddleTrip_Empty_TillTrip(idVeh, idTripi, varcosti, varvioTWCi, varvioTWSPi, cStartS, preTjNEW); //10/12/2013
//				if (idTripi == preTjNEW)
//				{
//					preTjNEW--; changed_pre = 0;
//				}
//			}
//			else 
//			{
//				stop = cal_deleteCusArrayC2C_FirstMiddleTrip_TillTrip(idVeh, idTripi, i, varcosti, varvioTWCi, varvioTWSPi, varvioCAP, cStartS, preTjNEW); //10/12/2013
//                changed_pre = 1;
//			}
//		}//end idTripi > 0
//
//		//2.Insert (i and cusDi) right after j (from beginning/from j depends on changed or not) and gothroughVehicle till the end of vehicle
//		if (stop) //nothing change
//		{
//			if (idTripj == lastT)
//				cal_InsertCusC2CIAfterJ_LastC_LastTrip(depart[j],j,i,idVeh,idTripj,varcostj,varvioTWCj); //11/12/2013
//			else
//			{
//				int nextSP = seg[idVeh].Trip[idTripj].nextSP;
//				if (nextSP > 0)
//					cal_InsertCusC2CIAfterJ_LastC_NextD(depart[j],j,i,idVeh,idTripj,nextSP,varcostj,varvioTWCj,varvioTWSPj); //11/12/2013
//				else
//					cal_InsertCusC2CIAfterJ_LastC_NextTripPORC2C(depart[j],j,i,idVeh,idTripj,varcostj,varvioTWCj,varvioTWSPj);//11/12/2013
//			}
//		}
//		else //there has change
//		{	//cStartS is taken from before
//			//can xac dinh NEWlast cus of preTjNEW if preTjNEW is C2C 
//			if (changed_pre == 0)
//			{
//				if (seg[idVeh].Trip[preTjNEW].Type == 0) preTj_lastCNEW = seg[idVeh].Trip[preTjNEW].assSP;
//				else preTj_lastCNEW = seg[idVeh].Trip[preTjNEW].lastCus;
//			}
//			else
//			{
//				if (idTripi < preTjNEW)
//				{
//					if (seg[idVeh].Trip[preTjNEW].Type == 0) preTj_lastCNEW = seg[idVeh].Trip[preTjNEW].assSP;
//					else preTj_lastCNEW = seg[idVeh].Trip[preTjNEW].lastCus;
//				}
//				else //idTripi +1 = idTripj:
//				{
//					//checking if delID is the last cus of idTripi:
//					int delID = problem->node[i].delID;
//					if (delID == seg[idVeh].Trip[idTripi].lastCus)
//					{
//						int pre_delID = predArr[delID];
//						if (pre_delID == i) preTj_lastCNEW = predArr[i];
//						else preTj_lastCNEW = pre_delID;
//					}
//					else
//					{
//						if (seg[idVeh].Trip[preTjNEW].Type == 0) preTj_lastCNEW = seg[idVeh].Trip[preTjNEW].assSP;
//						else preTj_lastCNEW = seg[idVeh].Trip[preTjNEW].lastCus;
//					}
//				}
//			}
//			int moveAfter;
//			cal_InsertCusC2CIAfterJ_FromBeginning(j, i, idVeh, idTripj, preTj_lastCNEW, varvioCAP, varcostj, varvioTWCj, varvioTWSPj, moveAfter, cStartS); //11/12/2013
//		}
//		varcost = varcosti + varcostj;
//		varvioTWC = varvioTWCi + varvioTWCj;
//		varvioTWSP = varvioTWSPi + varvioTWSPj;
//	}
//	else //idTripi > idTripj
//	{
//		 int preTi = idTripi - 1;
//		 int lastT = seg[idVeh].numTrips - 1;
//	 	 int numCj = seg[idVeh].Trip[idTripj].numCus;
//		 int nextSP = seg[idVeh].Trip[idTripj].nextSP;
//		 int moveAfter;
//
//		//1.Insert (i and cusDi) right after last cus j and gothroughVehicle till (idTripi - 1)
//		//2. Delete (i and cusDi) from beginning/from prei depends on changed or not, then gothroughVehicle till the endof vehicle
//  		 if (idTripj == 0 && numCj == 2 && nextSP > 0) //note that: j is the C2CD --> there is only way to insert: j - i - cusDi 
//			stop = SUBcal_InsertCusC2CIAfterJ_2CusFirstTrip_nextD(j,i,idVeh,nextSP,preTi,varcostj,varvioTWCj,varvioTWSPj,varvioCAP,moveAfter,cStartS); //11/12/2013
//		 else
//			stop = cal_InsertCusC2CIAfterJ_LastC_TillTrip(depart[j],j, i, idVeh, idTripj,varcostj, varvioTWCj, varvioTWSPj, cStartS, preTi);
//
//		 if (stop) //not changed
//		 {
//			 //idTrip > 0
//			 if (numCi == 2)
//			 {
//				 if (idTripi < lastT) 
//					 cal_deleteCusArrayPORC2C_MiddleTrip_Empty_TillTrip(idVeh, idTripi, varcosti, varvioTWCi, varvioTWSPi, cStartS, lastT); //11/12/2013
//				 else 
//			         cal_deleteCusArrayPORC2C_LastTrip_Empty(idVeh,idTripi,varcosti,varvioTWCi,varvioTWSPi);//11/12/2013
//			 }
//			 else
//			 {
//				if (idTripi < lastT)
//					 cal_deleteCusArrayC2C_FirstMiddleTrip_TillTrip(idVeh,idTripi,i,varcosti,varvioTWCi,varvioTWSPi,varvioCAP,cStartS,lastT); //11/12/2013
//				else
//			      cal_deleteCusArrayC2C_LastTrip(idVeh, idTripi, i, varcosti, varvioTWCi, varvioCAP);
//			 }
//		 }
//		 else //there is a change
//		 {
//			 // cout<<"j = "<<j<<", i = "<<i<<"; cStartS = "<<cStartS<<"; CHANGED!"<<endl;
//			 //cStartS is taken from before
//			  if (preTi == idTripj) //idTripj is right before idTripi; insert i and cusDi at the end of the trip idTripj
//			  {
//				  if (numCi == 2) 
//				  {
//					 if (idTripi < lastT)
//					 {
//						 int preC = cusDi; 
//						 //need to varcost += connect(cusDi, first of trip (idTripi+1) in cal_deleteCusArrayC2C_MiddleTrip_Empty_FromBeginning
//						 cal_deleteCusArrayC2C_MiddleTrip_Empty_FromBeginning(preC,idVeh, idTripi, varcosti, varvioTWCi, varvioTWSPi, cStartS);
//					 }
//					 else 
//					 {
//						varvioTWCi -= seg[idVeh].Trip[idTripi].vioTWC;
//						varcosti += (problem->c[cusDi][0] - seg[idVeh].Trip[idTripi].cost); //seg[idVeh].Trip[idTripj].connectCost already has been substracted in the procedure cal_InsertCusC2CIAfterJ_LastC_TillTrip before
//					 }
//				  }
//				  else 
//				  {
//					 if (idTripi < lastT)
//					 {
// 						 int preC = cusDi; //need to varcost += connect(cusDi, first of trip (idTripi+1) in cal_deleteCusArrayC2C_MiddleTrip_FromBeginning
//						 cal_deleteCusArrayC2C_MiddleTrip_FromBeginning(preC,1,idVeh, idTripi, i, varcosti, varvioTWCi, varvioTWSPi, varvioCAP, cStartS);
//					 }
//					 else 
//					 {
// 						 int preC = cusDi; //need to varcost += connect(cusDi, first of trip (idTripi+1) in cal_deleteCusArrayC2C_MiddleTrip_FromBeginning
//						 cal_deleteCusArrayC2C_LastTrip_FromBeginning(preC,1,idVeh, idTripi, i, varcosti, varvioTWCi, varvioTWSPi, varvioCAP, cStartS);
//					 }
//				  }
//			  }
//			  else //idTripj is not right before idTripi
//			  {
//				  if (numCi == 2) 
//				  {
//					 if (idTripi < lastT)
//					 {
//						 cal_deleteCusArrayPORC2C_MiddleTrip_Empty_FromBeginning(idVeh,idTripi,varcosti,varvioTWCi,varvioTWSPi,cStartS);
//					 }
//					 else 
//						 cal_deleteCusArrayPORC2C_LastTrip_Empty(idVeh, idTripi, varcosti, varvioTWCi, varvioTWSPi); //11/12/2013
//				  }
//				  else 
//				  {
//					 if (idTripi < lastT)
//						 cal_deleteCusArrayC2C_MiddleTrip_FromBeginning(numCi,0,idVeh, idTripi, i, varcosti, varvioTWCi, varvioTWSPi, varvioCAP, cStartS);
//					 else 
//						 cal_deleteCusArrayC2C_LastTrip_FromBeginning(numCi,0,idVeh, idTripi, i, varcosti, varvioTWCi, varvioTWSPi, varvioCAP, cStartS);
//				  }
//			  }
//		 }//end there is a change
//		 varcost = varcosti + varcostj;
//		 varvioTWC = varvioTWCi + varvioTWCj;
//		 varvioTWSP = varvioTWSPi + varvioTWSPj;
//	}//end idTripi > idTripj
//	moveCus[j][k]->var_cost = varcost;
//	moveCus[j][k]->var_vioCAP = varvioCAP;
//	moveCus[j][k]->var_vioTWC = varvioTWC;
//	moveCus[j][k]->var_vioTWSP = varvioTWSP;
//	moveCus[j][k]->atIT = IT;
//	moveC2CDAfter[j][k] = i;
//}
//
//void Solution::cal_MoveCusC2CIAfterJ_oneVeh_NotLastC(int j, int idTripj, int i, int idTripi, int idVeh, int k)
//{
//	//10/12/2013: move cus i and (delID of cus i) after j which is the last cus of the trip (idVeh,idTripj) [may last trip OR Not last trip]
//	// i and j belong to different legs of the same vehicle
//	//copy cal_MoveCusC2CIAfterJ_oneVeh_LastC
//
//    bool stop;
//	int cusDi = problem->node[i].delID;
//	int numCi = seg[idVeh].Trip[idTripi].numCus;
//	int lastT = seg[idVeh].numTrips - 1;
//	int varvioCAPi = 0;
//	double varcosti = 0, varvioTWCi = 0, varvioTWSPi = 0; 
//	int varvioCAPj; double varcostj, varvioTWCj, varvioTWSPj; //NotLastC --> don't need to initialize = 0 as LastC 
//	//int varvioCAPj = 0; double varcostj = 0, varvioTWCj = 0, varvioTWSPj = 0; 
//	double cStartS = 0;
//	int nextSP = seg[idVeh].Trip[idTripi].nextSP;
//	int moveAfter;
//
//	if (idTripi < idTripj)
//	{
//		int preTj_lastCNEW; bool changed_pre;
//		int preTjNEW = idTripj - 1; nextSP = seg[idVeh].Trip[idTripi].nextSP;
//		//1.Del (cus i and cusDi) and gothroughVehicle till (idTripj-1)
//		if (idTripi == 0)
//		{
//			if (numCi == 2) //idTripi becomes empty
//			{
//			    if (idTripi < preTjNEW)
//				{
//					//cout<<"CALL cal_deleteCusArrayC2C_FirstTrip_Empty_TillTrip("<<endl;
//					stop = cal_deleteCusArrayC2C_FirstTrip_Empty_TillTrip(idVeh, varcosti, varvioTWCi, varvioTWSPi, cStartS, preTjNEW); //10/12/2013
//				    changed_pre = 0;
//				}
//				else
//				{
//				   //(i amd cusDi) are first cus where there is only 2 customers --> delete (i, cusDi), this trip becomes empty
//				   //then insert (i, cusDi) right after last cus j on the second trip --> after empty the first trip, this second trip becomes the first trip
//				   //cout<<"CALL cal_deleteCusArrayC2C_FirstTrip_Empty_insertNextTrip_NotLastC("<<endl;
//				   cal_deleteCusArrayC2C_FirstTrip_Empty_insertNextTrip_NotLastC(j,i,idVeh, varcosti, varvioTWCi, varcostj, varvioTWCj, varvioTWSPj, varvioCAPj,moveAfter); //10/12/2013
//				   moveCus[j][k]->var_cost = varcosti + varcostj;
//	               moveCus[j][k]->var_vioCAP = varvioCAPj;
//	               moveCus[j][k]->var_vioTWC = varvioTWCi + varvioTWCj;
//				   moveCus[j][k]->var_vioTWSP = varvioTWSPj;
//	               moveCus[j][k]->atIT = IT;
//	               moveC2CDAfter[j][k] = moveAfter;
//				   return;
//				}
//			}
//			else if (numCi == 4 && nextSP > 0)
//			{
//				//cout<<"cal_deleteCusC2C_FirstTrip_4Cus_nextD_TillTrip("<<endl;
//				stop = cal_deleteCusC2C_FirstTrip_4Cus_nextD_TillTrip(idVeh, i, varcosti, varvioTWCi, varvioTWSPi, varvioCAPi, cStartS, preTjNEW); //10/12/2013
//				changed_pre = 0;
//			}
//			else
//			{
//				//cout<<"cal_deleteCusArrayC2C_FirstMiddleTrip_TillTrip("<<endl;
//				stop = cal_deleteCusArrayC2C_FirstMiddleTrip_TillTrip(idVeh, 0, i, varcosti, varvioTWCi, varvioTWSPi, varvioCAPi, cStartS, preTjNEW); //10/12/2013
//			    changed_pre = 1;
//			}			
//		}
//		else //idTripi > 0
//		{
//			if (numCi == 2) 
//			{
//				//cout<<"cal_deleteCusArrayPORC2C_MiddleTrip_Empty_TillTrip("<<endl;
//				stop = cal_deleteCusArrayPORC2C_MiddleTrip_Empty_TillTrip(idVeh, idTripi, varcosti, varvioTWCi, varvioTWSPi, cStartS, preTjNEW); //10/12/2013
//				if (idTripi == preTjNEW)
//				{
//					preTjNEW--; changed_pre = 0;
//				}
//			}
//			else 
//			{
//				//cout<<"CALL cal_deleteCusArrayC2C_FirstMiddleTrip_TillTrip("<<endl;
//				stop = cal_deleteCusArrayC2C_FirstMiddleTrip_TillTrip(idVeh, idTripi, i, varcosti, varvioTWCi, varvioTWSPi, varvioCAPi, cStartS, preTjNEW); //10/12/2013
//                changed_pre = 1;
//			}
//		}//end idTripi > 0
//
//		//2.Insert (i and cusDi) right after j (from beginning/from j depends on changed or not) and gothroughVehicle till the end of vehicle
//		if (stop) //nothing change
//		{
//			if (idTripj == lastT)
//			{
//               //cout<<"CALL SUBcal_InsertCusC2CIAfterJ_NotLastC_LastTrip"<<endl;
//			   SUBcal_InsertCusC2CIAfterJ_NotLastC_LastTrip(depart[j],CAPCus[j],j,i,idVeh,idTripj,varcostj,varvioTWCj,varvioCAPj,moveAfter);
//			}
//			else
//			{
//				int nextSP = seg[idVeh].Trip[idTripj].nextSP;
//				if (nextSP > 0)
//				{
//				    //cout<<"CALL SUBcal_InsertCusC2CIAfterJ_NotLastC_NextD"<<endl;
//					SUBcal_InsertCusC2CIAfterJ_NotLastC_NextD(depart[j],CAPCus[j],j,i,idVeh,idTripj,nextSP,varcostj,varvioTWCj,varvioTWSPj,varvioCAPj,moveAfter);
//				}				
//				else
//				{
//					//cout<<"CALL SUBcal_InsertCusC2CIAfterJ_NotLastC_NextTripPORC2C("<<endl;
//					SUBcal_InsertCusC2CIAfterJ_NotLastC_NextTripPORC2C(depart[j],CAPCus[j],j,i,idVeh,idTripj,varcostj,varvioTWCj,varvioTWSPj,varvioCAPj,moveAfter);
//				}
//			}
//		}
//		else //there has change
//		{	//cStartS is taken from before
//			//can xac dinh NEWlast cus of preTjNEW if preTjNEW is C2C 
//			if (changed_pre == 0)
//			{
//				if (seg[idVeh].Trip[preTjNEW].Type == 0) preTj_lastCNEW = seg[idVeh].Trip[preTjNEW].assSP;
//				else preTj_lastCNEW = seg[idVeh].Trip[preTjNEW].lastCus;
//			}
//			else
//			{
//				if (idTripi < preTjNEW)
//				{
//					if (seg[idVeh].Trip[preTjNEW].Type == 0) preTj_lastCNEW = seg[idVeh].Trip[preTjNEW].assSP;
//					else preTj_lastCNEW = seg[idVeh].Trip[preTjNEW].lastCus;
//				}
//				else //idTripi +1 = idTripj:
//				{
//					//checking if delID is the last cus of idTripi:
//					int delID = problem->node[i].delID;
//					if (delID == seg[idVeh].Trip[idTripi].lastCus)
//					{
//						int pre_delID = predArr[delID];
//						if (pre_delID == i) preTj_lastCNEW = predArr[i];
//						else preTj_lastCNEW = pre_delID;
//					}
//					else
//					{
//						if (seg[idVeh].Trip[preTjNEW].Type == 0) preTj_lastCNEW = seg[idVeh].Trip[preTjNEW].assSP;
//						else preTj_lastCNEW = seg[idVeh].Trip[preTjNEW].lastCus;
//					}
//				}
//			}
//			//cout<<"CALL cal_InsertCusC2CIAfterJ_FromBeginning("<<endl;
//			cal_InsertCusC2CIAfterJ_FromBeginning(j, i, idVeh, idTripj, preTj_lastCNEW, varvioCAPj, varcostj, varvioTWCj, varvioTWSPj, moveAfter, cStartS); //11/12/2013
//		}
//	}
//	else //idTripi > idTripj
//	{
//		 int preTi = idTripi - 1;
//		 int lastT = seg[idVeh].numTrips - 1;
//	 	 int numCj = seg[idVeh].Trip[idTripj].numCus;
//		 int nextSP = seg[idVeh].Trip[idTripj].nextSP;
//		 int moveAfter;
//
//		//1.Insert (i and cusDi) right after last cus j and gothroughVehicle till (idTripi - 1)
//		//2. Delete (i and cusDi) from beginning/from prei depends on changed or not, then gothroughVehicle till the endof vehicle
//  		 if (idTripj == 0 && numCj == 2 && nextSP > 0) //note that: j is the C2CD --> there is only way to insert: j - i - cusDi 
//		 {
//			 //cout<<"CALL SUBcal_InsertCusC2CIAfterJ_2CusFirstTrip_nextD("<<endl;
//			 stop = SUBcal_InsertCusC2CIAfterJ_2CusFirstTrip_nextD(j,i,idVeh,nextSP,preTi,varcostj,varvioTWCj,varvioTWSPj,varvioCAPj,moveAfter,cStartS); //11/12/2013
//		 }
//		 else
//		 {
//			//stop = cal_InsertCusC2CIAfterJ_NotLastC_TillTrip(depart[j],CAPCus[j],j,i,idVeh,idTripj,varcostj,varvioTWCj,varvioTWSPj,varvioCAPj,cStartS,moveAfter,preTi);
//			if (nextSP > 0) //nextT is DTrip
//			{
//				//return 1 if cStartS has not been changed; 0 otherwise
//				//cout<<"CALL SUBcal_InsertCusC2CIAfterJ_NotLastC_NextD_COPY("<<endl;
//				SUBcal_InsertCusC2CIAfterJ_NotLastC_NextD_COPY(depart[j],CAPCus[j],j,i,idVeh,idTripj,nextSP,varcostj,varvioTWCj,varvioTWSPj,varvioCAPj,stop,cStartS,moveAfter,preTi);
//			}
//			else //nextT is PTrip OR C2C
//			{
//				//cout<<"CALL SUBcal_InsertCusC2CIAfterJ_NotLastC_NextTripPORC2C_COPY("<<endl;
//				SUBcal_InsertCusC2CIAfterJ_NotLastC_NextTripPORC2C_COPY(depart[j],CAPCus[j],j,i,idVeh,idTripj,varcostj,varvioTWCj,varvioTWSPj,varvioCAPj,stop,cStartS,moveAfter,preTi);
//			}//end nextT is PTrip or C2C
//		 }	
//
//		 if (stop) //not changed
//		 {
//			 //idTrip > 0
//			 if (numCi == 2)
//			 {
//				 if (idTripi < lastT) 
//				 {
//					 //cout<<"1 CALL cal_deleteCusArrayPORC2C_MiddleTrip_Empty_TillTrip("<<endl;
//				     cal_deleteCusArrayPORC2C_MiddleTrip_Empty_TillTrip(idVeh, idTripi, varcosti, varvioTWCi, varvioTWSPi, cStartS, lastT); //11/12/2013
//				 }
//				 else 
//				 {
//			         //cout<<"2 CALL cal_deleteCusArrayPORC2C_LastTrip_Empty("<<endl;
//					 cal_deleteCusArrayPORC2C_LastTrip_Empty(idVeh,idTripi,varcosti,varvioTWCi,varvioTWSPi);//11/12/2013
//				 }
//			 }
//			 else
//			 {
//				if (idTripi < lastT)
//				{
//					//cout<<"3 CALL cal_deleteCusArrayC2C_FirstMiddleTrip_TillTrip("<<endl;
//					cal_deleteCusArrayC2C_FirstMiddleTrip_TillTrip(idVeh,idTripi,i,varcosti,varvioTWCi,varvioTWSPi,varvioCAPi,cStartS,lastT); //11/12/2013
//				}
//				else
//				{
//					//cout<<"4) CALL cal_deleteCusArrayC2C_LastTrip("<<endl;
//			        cal_deleteCusArrayC2C_LastTrip(idVeh, idTripi, i, varcosti, varvioTWCi, varvioCAPi);
//				}
//			 }
//		 }
//		 else //there is a change
//		 {
//			 // cout<<"j = "<<j<<", i = "<<i<<"; cStartS = "<<cStartS<<"; CHANGED!"<<endl;
//			 //cStartS is taken from before
//			  if (preTi == idTripj) //idTripj is right before idTripi; insert i and cusDi at the end of the trip idTripj
//			  {
//				  if (numCi == 2) 
//				  {
//					 if (idTripi < lastT)
//					 {
//						 int preC = cusDi; 
//						 //need to varcost += connect(cusDi, first of trip (idTripi+1) in cal_deleteCusArrayC2C_MiddleTrip_Empty_FromBeginning
//						 //cout<<"5 CALL cal_deleteCusArrayC2C_MiddleTrip_Empty_FromBeginning("<<endl;
//						 cal_deleteCusArrayC2C_MiddleTrip_Empty_FromBeginning(preC,idVeh, idTripi, varcosti, varvioTWCi, varvioTWSPi, cStartS);
//					 }
//					 else 
//					 {
//						varvioTWCi -= seg[idVeh].Trip[idTripi].vioTWC;
//						varcosti += (problem->c[cusDi][0] - seg[idVeh].Trip[idTripi].cost); //seg[idVeh].Trip[idTripj].connectCost already has been substracted in the procedure cal_InsertCusC2CIAfterJ_LastC_TillTrip before
//					 }
//				  }
//				  else 
//				  {
//					 if (idTripi < lastT)
//					 {
// 						 int preC = cusDi; //need to varcost += connect(cusDi, first of trip (idTripi+1) in cal_deleteCusArrayC2C_MiddleTrip_FromBeginning
//						// cout<<"6 CALL cal_deleteCusArrayC2C_MiddleTrip_FromBeginning"<<endl;
//						 cal_deleteCusArrayC2C_MiddleTrip_FromBeginning(preC,1,idVeh, idTripi, i, varcosti, varvioTWCi, varvioTWSPi, varvioCAPi, cStartS);
//					 }
//					 else 
//					 {
// 						 int preC = cusDi; //need to varcost += connect(cusDi, first of trip (idTripi+1) in cal_deleteCusArrayC2C_MiddleTrip_FromBeginning
//						 //cout<<"7 CALL cal_deleteCusArrayC2C_LastTrip_FromBeginning"<<endl;
//						 cal_deleteCusArrayC2C_LastTrip_FromBeginning(preC,1,idVeh, idTripi, i, varcosti, varvioTWCi, varvioTWSPi, varvioCAPi, cStartS);
//					 }
//				  }
//			  }
//			  else //idTripj is not right before idTripi
//			  {
//				  if (numCi == 2) 
//				  {
//					 if (idTripi < lastT)
//					 {
//						 //cout<<"8 CALL cal_deleteCusArrayPORC2C_MiddleTrip_Empty_FromBeginning"<<endl;
//						 cal_deleteCusArrayPORC2C_MiddleTrip_Empty_FromBeginning(idVeh,idTripi,varcosti,varvioTWCi,varvioTWSPi,cStartS);
//					 }
//					 else 
//					 {
//						//cout<<"9 CALL cal_deleteCusArrayPORC2C_LastTrip_Empty"<<endl;
//						cal_deleteCusArrayPORC2C_LastTrip_Empty(idVeh, idTripi, varcosti, varvioTWCi, varvioTWSPi); //11/12/2013
//					 }
//				  }
//				  else 
//				  {
//					 if (idTripi < lastT)
//					 {
//						// cout<<"10 CALL cal_deleteCusArrayC2C_MiddleTrip_FromBeginning"<<endl;
//						 cal_deleteCusArrayC2C_MiddleTrip_FromBeginning(numCi,0,idVeh, idTripi, i, varcosti, varvioTWCi, varvioTWSPi, varvioCAPi, cStartS);
//					 }
//					 else 
//					 {
//						 //cout<<"11) CALL cal_deleteCusArrayC2C_LastTrip_FromBeginning"<<endl;
//						 cal_deleteCusArrayC2C_LastTrip_FromBeginning(numCi,0,idVeh, idTripi, i, varcosti, varvioTWCi, varvioTWSPi, varvioCAPi, cStartS);
//					 }
//				  }
//			  }
//		 }//end there is a change
//	}//end idTripi > idTripj
//	moveCus[j][k]->var_cost = varcosti + varcostj;
//	moveCus[j][k]->var_vioCAP = varvioCAPi + varvioCAPj;
//	moveCus[j][k]->var_vioTWC = varvioTWCi + varvioTWCj;
//	moveCus[j][k]->var_vioTWSP = varvioTWSPi + varvioTWSPj;
//	moveCus[j][k]->atIT = IT;
//	moveC2CDAfter[j][k] = moveAfter;
//}
//
//void Solution::cal_MoveCusC2CIAfterJ_oneTrip_LastTrip_NotLastC(int j, int i, int idVeh, int idTrip, double &varcost, double &varvioTWC, int &varvioCAP, int &moveAfter)
//{
//	//14/12/2013: COPY cal_MoveCusC2CIAfterJ_oneTrip_LastTrip_NotLastC_nextD,cal_MoveCusC2CIAfterJ_oneTrip_NotLastC_NextTripPORC2C
//	//cout<<"cal_MoveCusC2CIAfterJ_oneTrip_LastTrip_NotLastC(j = "<<j<<"; i = "<<i<<"; idVeh = "<<idVeh<<", idTrip = "<<idTrip<<endl;
//	
//	int posi = pos[i]; int posj = pos[j];
//	int cusDi = problem->node[i].delID; int posDi = pos[cusDi];
//	varvioTWC -= (vioTWCus[i] + vioTWCus[cusDi]);
//	varvioCAP -= (vioCAPCus[i] + vioCAPCus[cusDi]);
//	int nextC = nextArr[i];
//	int tQ, CapVehCus;
//	double cArrTime, cStartS, temp;
//	bool contTW, contCAP;
//
//	if (posi < posj)
//	{
//		//1. Delete i:
//		int prei = predArr[i];
//		if (prei > 0)
//		{
//			cStartS = depart[prei];
//			CapVehCus = CAPCus[prei];
//		}
//		else //i was the first cus of the trip:
//		{
//			int preT = idTrip - 1;
//			if (seg[idVeh].Trip[preT].Type == 0) {prei = seg[idVeh].Trip[preT].assSP;cStartS = seg[idVeh].Trip[preT].leaveSP;}
//			else {prei = seg[idVeh].Trip[preT].lastCus; cStartS = depart[prei];}
//			CapVehCus = 0;
//		}
//		if (posDi < posj)
//		{
//			if (nextC == cusDi) //cusDi is direct successor of i:
//			{
//				//1.1.Delete i and cusDi:
//				nextC = nextArr[nextC];
//				cArrTime = cStartS + problem->c[prei][nextC];
//				temp = cArrTime - problem->node[nextC].eTW;
//				if (temp > eps)
//				{
//					varvioTWC += temp;
//					cStartS = problem->node[nextC].depart;
//				}
//				else cStartS = PDS_MAX(cArrTime, problem->node[nextC].sTW) + problem->node[nextC].duration;
//				varvioTWC -= vioTWCus[nextC];
//				varcost += (problem->c[prei][nextC] - (problem->c[prei][i] + problem->c[i][cusDi] + problem->c[cusDi][nextC]));
//				//cout<<i<<", "<<j<<" : vio = "<<varvioCAP<<"; ";
//				CapVehCus += problem->node[nextC].capacity;
//				tQ = CapVehCus - Q;
//				if (tQ > 0) {CapVehCus = Q; varvioCAP += tQ; /*cout<<"vio["<<nextC<<"] = "<<tQ<<"; ";*/}
//				//else cout<<"vio["<<nextC<<"]=0;";
//				varvioCAP -= vioCAPCus[nextC];
//				//cout<<"var[till "<<nextC<<"] = "<<varvioCAP<<"; ";
//				//1.2. Cal till j (??check nextC == j):
//			}
//			else //cusDi is not direct successor of i:
//			{
//				//2.1 Delete i
//				cArrTime = cStartS + problem->c[prei][nextC];
//				temp = cArrTime - problem->node[nextC].eTW;
//				if (temp > eps)
//				{
//					varvioTWC += temp;
//					cStartS = problem->node[nextC].depart;
//				}
//				else cStartS = PDS_MAX(cArrTime, problem->node[nextC].sTW) + problem->node[nextC].duration;
//				varvioTWC -= vioTWCus[nextC];
//				varcost += (problem->c[prei][nextC] - (problem->c[prei][i] + problem->c[i][nextC]));
//				CapVehCus += problem->node[nextC].capacity;
//				//cout<<i<<", "<<j<<"; varvioCAP = "<<varvioCAP<<"; ";
//				tQ = CapVehCus - Q;
//				if (tQ > 0) {varvioCAP += tQ; CapVehCus = Q; /*cout<<"vio["<<nextC<<"]= "<<tQ<<"; ";*/}
//				//else cout<<"vio["<<nextC<<"]=0; ";
//				varvioCAP -= vioCAPCus[nextC];
//				//cout<<"var[till "<<nextC<<"] = "<<varvioCAP<<"; ";
//			
//				//2.2 Cal till predArr[cusDi]:
//				int pre_cusDi = predArr[cusDi];
//				if (nextC != pre_cusDi)
//				{
//					contCAP = 1; contTW = 1;
//				    GoThroughLegC2C(nextC,nextArr[nextC],pre_cusDi,cStartS,CapVehCus,varvioCAP,varvioTWC,contCAP,contTW);
//				}
//				//2.3 Delete cusDi:
//				nextC = nextArr[cusDi];
//				varcost += (problem->c[pre_cusDi][nextC] - problem->c[pre_cusDi][cusDi] - problem->c[cusDi][nextC]);
//				cArrTime = cStartS + problem->c[pre_cusDi][nextC];
//				temp = cArrTime - problem->node[nextC].eTW;
//				if (temp > eps)
//				{
//					varvioTWC += temp;
//					cStartS = problem->node[nextC].depart;
//				}
//				else cStartS = PDS_MAX(cArrTime, problem->node[nextC].sTW) + problem->node[nextC].duration;
//				varvioTWC -= vioTWCus[nextC];
//				CapVehCus += problem->node[nextC].capacity;
//				tQ = CapVehCus - Q;
//				if (tQ > 0) {CapVehCus = Q; varvioCAP += tQ;/*cout<<"vio["<<nextC<<"]=.. "<<tQ<<"; ";*/}
//				//else cout<<"vio["<<nextC<<"]=..0; ";
//				varvioCAP -= vioCAPCus[nextC];
//				//2.4. Cal till j (?check nextC == j)
//			}
//			//Cal till j:
//			if (nextC != j) 
//			{
//				contCAP = 1; contTW = 1;
//				GoThroughLegC2C(nextC,nextArr[nextC],j,cStartS,CapVehCus,varvioCAP, varvioTWC, contCAP,contTW);
//			}
//			//cout<<"var[till "<<j<<"] = "<<varvioCAP<<";CAP["<<j<<"] = "<<CapVehCus;
//			//Insert i after j:
//			double varcostMIN, varvioTWCMIN; int varvioCAPMIN;
//			SUBcal_InsertCusC2CIAfterJ_NotLastC_LastTrip(cStartS,CapVehCus,j,i,idVeh,idTrip,varcostMIN,varvioTWCMIN,varvioCAPMIN,moveAfter);
//			varcost += varcostMIN; varvioTWC += varvioTWCMIN; varvioCAP += varvioCAPMIN;
//			//cout<<"varMIN = "<<varvioCAPMIN<<" --> Result = "<<varvioCAP<<endl;
//		}
//		else //posDi > posj; posi < posj
//		{
//			//3.1 Delete i
//			cArrTime = cStartS + problem->c[prei][nextC];
//			temp = cArrTime - problem->node[nextC].eTW;
//			if (temp > eps)
//			{
//				varvioTWC += temp;
//				cStartS = problem->node[nextC].depart;
//			}
//			else cStartS = PDS_MAX(cArrTime, problem->node[nextC].sTW) + problem->node[nextC].duration;
//			//cout<<"("<<i<<", "<<j<<", varvioTWC = "<<varvioTWC<<"; depart["<<nextC<<"] = "<<cStartS<<"; ";
//			varvioTWC -= vioTWCus[nextC];
//			varcost += (problem->c[prei][nextC] - (problem->c[prei][i] + problem->c[i][nextC]));
//			//cout<<"--("<<i<<", "<<j<<", vio = "<< varvioCAP<<", ";
//			CapVehCus += problem->node[nextC].capacity;
//			tQ = CapVehCus - Q;
//			if (tQ > 0) {CapVehCus = Q; varvioCAP += tQ; /*cout<<"vio["<<nextC<<"] = "<<tQ<<"; ";*/}
//			//else cout<<"vio["<<nextC<<"] = 0;";
//			varvioCAP -= vioCAPCus[nextC];
//
//			//2.2 Cal till j (??Checking nextC == j)
//			if (nextC != j)
//			{
//				contTW = 1; contCAP = 1;
//				GoThroughLegC2C(nextC,nextArr[nextC],j,cStartS,CapVehCus,varvioCAP,varvioTWC,contCAP,contTW);
//			}
//			//cout<<"depart["<<j<<"] = "<<cStartS<<"; varvioTWC = "<<varvioTWC<<endl;
//			//cout<<"vio[till "<<j<<"] = "<<varvioCAP<<"; CAP["<<j<<"] = "<<CapVehCus<<";";
//			//Insert i after j:
//			double varcostMIN, varvioTWCMIN; int varvioCAPMIN;
//			SUBcal_InsertCusC2CIAfterJ_NotLastC_LastTrip_delIDIN(cStartS,CapVehCus,j,i,idVeh,idTrip,varcostMIN,varvioTWCMIN,varvioCAPMIN,moveAfter);
//			varcost += varcostMIN; varvioTWC += varvioTWCMIN; varvioCAP += varvioCAPMIN;
//			//cout<<"varvioCAPMIN = "<<varvioCAPMIN<<" --> Result = "<<varvioCAP<<endl;
//		}//end posDi > posj; posi < posj
//	}
//	else //posi > posj
//	{
//		double varcostMIN, varvioTWCMIN; int varvioCAPMIN;
//		//cout<<"CASE posi > posj: "; showTripCus(idVeh,idTrip);
//		SUBcal_InsertCusC2CIAfterJ_NotLastC_LastTrip_iANDdelIDIN(depart[j],CAPCus[j],j,i,idVeh,idTrip,varcostMIN,varvioTWCMIN,varvioCAPMIN,moveAfter);
//		varcost += varcostMIN; varvioTWC += varvioTWCMIN; varvioCAP += varvioCAPMIN;
//		//cout<<"---> FINI"<<endl;
//	}//end posi > posj
//	//cout<<"---------- FINI------------"<<endl;
//}
//
//
//
//void Solution::cal_MoveCusC2CIAfterJ_oneTrip_NotLastC_nextD(int j, int i, int idVeh, int idTrip, int nextSP, double &varcost, double &varvioTWC, double &varvioTWSP, int &varvioCAP, int &moveAfter)
//{
//	//14/12/2013: COPY cal_MoveCusC2CIAfterJ_oneTrip_LastTrip_NotLastC,cal_MoveCusC2CIAfterJ_oneTrip_NotLastC_NextTripPORC2C
//	int posi = pos[i]; int posj = pos[j];
//	int cusDi = problem->node[i].delID; int posDi = pos[cusDi];
//	varvioTWC -= (vioTWCus[i] + vioTWCus[cusDi]);
//	varvioCAP -= (vioCAPCus[i] + vioCAPCus[cusDi]);
//	int nextC = nextArr[i];
//	int tQ, CapVehCus;
//	double cArrTime, temp;
//	bool contTW, contCAP;
//	double cStartS = 0;
//
//	if (posi < posj)
//	{
//		//1. Delete i:
//		int prei = predArr[i];
//		if (prei > 0)
//		{
//			cStartS = depart[prei];
//			CapVehCus = CAPCus[prei];
//		}
//		else //i was the first cus of the trip:
//		{
//			int preT = idTrip - 1;
//			if (seg[idVeh].Trip[preT].Type == 0) {prei = seg[idVeh].Trip[preT].assSP;cStartS = seg[idVeh].Trip[preT].leaveSP;}
//			else {prei = seg[idVeh].Trip[preT].lastCus; cStartS = depart[prei];}
//			CapVehCus = 0;
//		}
//		if (posDi < posj)
//		{
//			if (nextC == cusDi) //cusDi is direct successor of i:
//			{
//				//1.1.Delete i and cusDi:
//				nextC = nextArr[nextC];
//				cArrTime = cStartS + problem->c[prei][nextC];
//				temp = cArrTime - problem->node[nextC].eTW;
//				if (temp > eps)
//				{
//					varvioTWC += temp;
//					cStartS = problem->node[nextC].depart;
//				}
//				else cStartS = PDS_MAX(cArrTime, problem->node[nextC].sTW) + problem->node[nextC].duration;
//				varvioTWC -= vioTWCus[nextC];
//				varcost += (problem->c[prei][nextC] - (problem->c[prei][i] + problem->c[i][cusDi] + problem->c[cusDi][nextC]));
//				CapVehCus += problem->node[nextC].capacity;
//				tQ = CapVehCus - Q;
//				if (tQ > 0) {CapVehCus = Q; varvioCAP += tQ;}
//				varvioCAP -= vioCAPCus[nextC];
//				//1.2. Cal till j (??check nextC == j):
//			}
//			else //cusDi is not direct successor of i:
//			{
//				//2.1 Delete i
//				cArrTime = cStartS + problem->c[prei][nextC];
//				temp = cArrTime - problem->node[nextC].eTW;
//				if (temp > eps)
//				{
//					varvioTWC += temp;
//					cStartS = problem->node[nextC].depart;
//				}
//				else cStartS = PDS_MAX(cArrTime, problem->node[nextC].sTW) + problem->node[nextC].duration;
//				varvioTWC -= vioTWCus[nextC];
//				varcost += (problem->c[prei][nextC] - (problem->c[prei][i] + problem->c[i][nextC]));
//				CapVehCus += problem->node[nextC].capacity;
//				tQ = CapVehCus - Q;
//				if (tQ > 0) {CapVehCus = Q; varvioCAP += tQ;}
//				varvioCAP -= vioCAPCus[nextC];
//				//2.2 Cal till predArr[cusDi]:
//				int pre_cusDi = predArr[cusDi];
//				if (nextC != pre_cusDi)
//				{
//					contCAP = 1; contTW = 1;
//				    GoThroughLegC2C(nextC,nextArr[nextC],pre_cusDi,cStartS,CapVehCus,varvioCAP,varvioTWC,contCAP,contTW);
//				}
//				//2.3 Delete cusDi:
//				nextC = nextArr[cusDi];
//				varcost += (problem->c[pre_cusDi][nextC] - problem->c[pre_cusDi][cusDi] - problem->c[cusDi][nextC]);
//				cArrTime = cStartS + problem->c[pre_cusDi][nextC];
//				temp = cArrTime - problem->node[nextC].eTW;
//				if (temp > eps)
//				{
//					varvioTWC += temp;
//					cStartS = problem->node[nextC].depart;
//				}
//				else cStartS = PDS_MAX(cArrTime, problem->node[nextC].sTW) + problem->node[nextC].duration;
//				varvioTWC -= vioTWCus[nextC];
//				CapVehCus += problem->node[nextC].capacity;
//				tQ = CapVehCus - Q;
//				if (tQ > 0) {CapVehCus = Q; varvioCAP += tQ;}
//				varvioCAP -= vioCAPCus[nextC];
//				//2.4. Cal till j (?check nextC == j)
//			}
//			//Cal till j:
//			if (nextC != j) 
//			{
//				contCAP = 1; contTW = 1;
//				GoThroughLegC2C(nextC,nextArr[nextC],j,cStartS,CapVehCus,varvioCAP, varvioTWC, contCAP,contTW);
//			}
//			//Insert i after j:
//			double varcostMIN, varvioTWCMIN,varvioTWSPMIN; int varvioCAPMIN; 
//			SUBcal_InsertCusC2CIAfterJ_NotLastC_NextD(cStartS,CapVehCus,j,i,idVeh,idTrip,nextSP,varcostMIN,varvioTWCMIN,varvioTWSPMIN,varvioCAPMIN,moveAfter);
//			varcost += varcostMIN; varvioTWC += varvioTWCMIN; varvioCAP += varvioCAPMIN; varvioTWSP += varvioTWSPMIN;
//		}
//		else //posDi > posj; posi < posj
//		{
//			//3.1 Delete i
//			cArrTime = cStartS + problem->c[prei][nextC];
//			temp = cArrTime - problem->node[nextC].eTW;
//			if (temp > 0.000999999999999)
//			{
//				varvioTWC += temp;
//				cStartS = problem->node[nextC].depart;
//			}
//			else cStartS = PDS_MAX(cArrTime, problem->node[nextC].sTW) + problem->node[nextC].duration;
//			varvioTWC -= vioTWCus[nextC];
//			varcost += (problem->c[prei][nextC] - (problem->c[prei][i] + problem->c[i][nextC]));
//			CapVehCus += problem->node[nextC].capacity;
//			tQ = CapVehCus - Q;
//			if (tQ > 0) {CapVehCus = Q; varvioCAP += tQ;}
//			varvioCAP -= vioCAPCus[nextC];
//			//2.2 Cal till j (??Checking nextC == j)
//			if (nextC != j)
//			{
//				contTW = 1; contCAP = 1;
//				GoThroughLegC2C(nextC,nextArr[nextC],j,cStartS,CapVehCus,varvioCAP,varvioTWC,contCAP,contTW);
//			}
//			//Insert i after j:
//			double varcostMIN, varvioTWCMIN,varvioTWSPMIN; int varvioCAPMIN;
//			SUBcal_InsertCusC2CIAfterJ_NotLastC_delIDIN_nextD(cStartS,CapVehCus,j,i,idVeh,idTrip, nextSP,varcostMIN,varvioTWCMIN, varvioTWSPMIN,varvioCAPMIN,moveAfter);
//			varcost += varcostMIN; varvioTWC += varvioTWCMIN; varvioCAP += varvioCAPMIN; varvioTWSP += varvioTWSPMIN;
//		}//end posDi > posj; posi < posj
//	}
//	else //posi > posj
//	{
//		double varcostMIN, varvioTWCMIN,varvioTWSPMIN; int varvioCAPMIN;
//		SUBcal_InsertCusC2CIAfterJ_NotLastC_iANDdelIDIN_NextD(depart[j],CAPCus[j],j,i,idVeh,idTrip,nextSP,varcostMIN,varvioTWCMIN,varvioTWSPMIN,varvioCAPMIN,moveAfter);
//		varcost += varcostMIN; varvioTWC += varvioTWCMIN; varvioCAP += varvioCAPMIN; varvioTWSP += varvioTWSPMIN;
//	}//end posi > posj
//}
//void Solution::cal_MoveCusC2CIAfterJ_oneTrip_NotLastC_NextTripPORC2C(int j, int i, int idVeh, int idTrip, double &varcost, double &varvioTWC, double &varvioTWSP, int &varvioCAP, int &moveAfter)
//{
//	//14/12/2013: COPY cal_MoveCusC2CIAfterJ_oneTrip_LastTrip_NotLastC,cal_MoveCusC2CIAfterJ_oneTrip_NotLastC_nextD
//	int posi = pos[i]; int posj = pos[j];
//	int cusDi = problem->node[i].delID; int posDi = pos[cusDi];
//	varvioTWC -= (vioTWCus[i] + vioTWCus[cusDi]);
//	varvioCAP -= (vioCAPCus[i] + vioCAPCus[cusDi]);
//	int nextC = nextArr[i];
//	int tQ, CapVehCus;
//	double cArrTime, cStartS, temp;
//	bool contTW, contCAP;
//
//	if (posi < posj)
//	{
//		//1. Delete i:
//		int prei = predArr[i];
//		if (prei > 0)
//		{
//			cStartS = depart[prei];
//			CapVehCus = CAPCus[prei];
//		}
//		else //i was the first cus of the trip:
//		{
//			int preT = idTrip - 1;
//			if (seg[idVeh].Trip[preT].Type == 0) {prei = seg[idVeh].Trip[preT].assSP;cStartS = seg[idVeh].Trip[preT].leaveSP;}
//			else {prei = seg[idVeh].Trip[preT].lastCus; cStartS = depart[prei];}
//			CapVehCus = 0;
//		}
//		if (posDi < posj)
//		{
//			if (nextC == cusDi) //cusDi is direct successor of i:
//			{
//				//1.1.Delete i and cusDi:
//				nextC = nextArr[nextC];
//				cArrTime = cStartS + problem->c[prei][nextC];
//				temp = cArrTime - problem->node[nextC].eTW;
//				if (temp > eps)
//				{
//					varvioTWC += temp;
//					cStartS = problem->node[nextC].depart;
//				}
//				else cStartS = PDS_MAX(cArrTime, problem->node[nextC].sTW) + problem->node[nextC].duration;
//				varvioTWC -= vioTWCus[nextC];
//				varcost += (problem->c[prei][nextC] - (problem->c[prei][i] + problem->c[i][cusDi] + problem->c[cusDi][nextC]));
//				CapVehCus += problem->node[nextC].capacity;
//				tQ = CapVehCus - Q;
//				if (tQ > 0) {CapVehCus = Q; varvioCAP += tQ;}
//				varvioCAP -= vioCAPCus[nextC];
//				//1.2. Cal till j (??check nextC == j):
//			}
//			else //cusDi is not direct successor of i:
//			{
//				//2.1 Delete i
//				cArrTime = cStartS + problem->c[prei][nextC];
//				temp = cArrTime - problem->node[nextC].eTW;
//				if (temp > eps)
//				{
//					varvioTWC += temp;
//					cStartS = problem->node[nextC].depart;
//				}
//				else cStartS = PDS_MAX(cArrTime, problem->node[nextC].sTW) + problem->node[nextC].duration;
//				varvioTWC -= vioTWCus[nextC];
//				varcost += (problem->c[prei][nextC] - (problem->c[prei][i] + problem->c[i][nextC]));
//				CapVehCus += problem->node[nextC].capacity;
//				tQ = CapVehCus - Q;
//				if (tQ > 0) {CapVehCus = Q; varvioCAP += tQ;}
//				varvioCAP -= vioCAPCus[nextC];
//				//2.2 Cal till predArr[cusDi]:
//				int pre_cusDi = predArr[cusDi];
//				if (nextC != pre_cusDi)
//				{
//					contCAP = 1; contTW = 1;
//				    GoThroughLegC2C(nextC,nextArr[nextC],pre_cusDi,cStartS,CapVehCus,varvioCAP,varvioTWC,contCAP,contTW);
//				}
//				//2.3 Delete cusDi:
//				nextC = nextArr[cusDi];
//				varcost += (problem->c[pre_cusDi][nextC] - problem->c[pre_cusDi][cusDi] - problem->c[cusDi][nextC]);
//				cArrTime = cStartS + problem->c[pre_cusDi][nextC];
//				temp = cArrTime - problem->node[nextC].eTW;
//				if (temp > eps)
//				{
//					varvioTWC += temp;
//					cStartS = problem->node[nextC].depart;
//				}
//				else cStartS = PDS_MAX(cArrTime, problem->node[nextC].sTW) + problem->node[nextC].duration;
//				varvioTWC -= vioTWCus[nextC];
//				CapVehCus += problem->node[nextC].capacity;
//				tQ = CapVehCus - Q;
//				if (tQ > 0) {CapVehCus = Q; varvioCAP += tQ;}
//				varvioCAP -= vioCAPCus[nextC];
//				//2.4. Cal till j (?check nextC == j)
//			}
//			//Cal till j:
//			if (nextC != j) 
//			{
//				contCAP = 1; contTW = 1;
//				GoThroughLegC2C(nextC,nextArr[nextC],j,cStartS,CapVehCus,varvioCAP, varvioTWC, contCAP,contTW);
//			}
//			//Insert i after j:
//			double varcostMIN, varvioTWCMIN, varvioTWSPMIN; int varvioCAPMIN; 
//			SUBcal_InsertCusC2CIAfterJ_NotLastC_NextTripPORC2C(cStartS,CapVehCus,j,i,idVeh,idTrip,varcostMIN,varvioTWCMIN,varvioTWSPMIN,varvioCAPMIN,moveAfter);
//			varcost += varcostMIN; varvioTWC += varvioTWCMIN; varvioCAP += varvioCAPMIN; varvioTWSP += varvioTWSPMIN;
//		}
//		else //posDi > posj; posi < posj
//		{
//			//3.1 Delete i
//			cArrTime = cStartS + problem->c[prei][nextC];
//			temp = cArrTime - problem->node[nextC].eTW;
//			if (temp > eps)
//			{
//				varvioTWC += temp;
//				cStartS = problem->node[nextC].depart;
//			}
//			else cStartS = PDS_MAX(cArrTime, problem->node[nextC].sTW) + problem->node[nextC].duration;
//			varvioTWC -= vioTWCus[nextC];
//			varcost += (problem->c[prei][nextC] - (problem->c[prei][i] + problem->c[i][nextC]));
//			CapVehCus += problem->node[nextC].capacity;
//			tQ = CapVehCus - Q;
//			if (tQ > 0) {CapVehCus = Q; varvioCAP += tQ;}
//			varvioCAP -= vioCAPCus[nextC];
//			//2.2 Cal till j (??Checking nextC == j)
//			if (nextC != j)
//			{
//				contTW = 1; contCAP = 1;
//				GoThroughLegC2C(nextC,nextArr[nextC],j,cStartS,CapVehCus,varvioCAP,varvioTWC,contCAP,contTW);
//			}
//			//Insert i after j:
//			double varcostMIN, varvioTWCMIN,varvioTWSPMIN; int varvioCAPMIN;
//			SUBcal_InsertCusC2CIAfterJ_NotLastC_delIDIN_NextTripPORC2C(cStartS,CapVehCus,j,i,idVeh,idTrip,varcostMIN,varvioTWCMIN,varvioTWSPMIN,varvioCAPMIN,moveAfter);
//			varcost += varcostMIN; varvioTWC += varvioTWCMIN; varvioCAP += varvioCAPMIN; varvioTWSP += varvioTWSPMIN;
//		}//end posDi > posj; posi < posj
//	}
//	else //posi > posj
//	{
//		double varcostMIN, varvioTWCMIN,varvioTWSPMIN; int varvioCAPMIN;
//		SUBcal_InsertCusC2CIAfterJ_NotLastC_iANDdelIDIN_NextTripPORC2C(depart[j],CAPCus[j],j,i,idVeh,idTrip,varcostMIN,varvioTWCMIN,varvioTWSPMIN,varvioCAPMIN,moveAfter);
//		varcost += varcostMIN; varvioTWC += varvioTWCMIN; varvioCAP += varvioCAPMIN; varvioTWSP += varvioTWSPMIN;
//	}//end posi > posj
//}
//
//void Solution::cal_ExchangeCusDIAndJ(int j, int k)
//{
//	//See on 2/12/2013
//	int i = problem->node[j].neighborNode[k].id; 
//    int previ, suci, prevj, sucj, idcur, idnext;
//
//    int idVehj = route_num[j]; int idTripj = trip_num[j];
//    int idVehi = route_num[i]; int idTripi = trip_num[i];
//	int nextTripj = idTripj+1;
//	int nextTripi = idTripi+1;
//
//	double vioTWCNEW, varvioTWC, varvioTWSP, varcost; 
//	int varvioCAP;
//	double cStartS, cArrTime,temp;
//
//	//cout<<"cal_ExchangeCusDIAndJ: j="<<j<<" of ("<<idVehj<<", "<<idTripj<<") and i = "<<i<<" of ("<<idVehi<<", "<<idTripi<<"):" ;
//	if (idVehi == idVehj)    //case 1: i and j in the same vehicle:
//	{
//		int assSP = seg[idVehi].Trip[idTripi].assSP; 
//		int lastCus = seg[idVehi].Trip[idTripi].lastCus;
//        bool firstI;
//		int fC = seg[idVehi].Trip[idTripi].firstCus;
//		int nC = seg[idVehi].Trip[idTripi].numCus;
//        for (int k1=1;k1<=nC;k1++)
//		{
//			if (fC ==i) {firstI=true;break;}
//			else if (fC==j) {firstI=false; break;}
//	        fC = nextArr[fC];
//		}
//		int idN = j;
//		if (!firstI) {int tt=i;i=j;j=tt;} //swap i and j so that i is before j
//		//if (nextArr[j]==i) return;
//		previ = predArr[i]; suci = nextArr[i];
//		prevj = predArr[j]; sucj = nextArr[j];
//		//if (print) cout<<"swap i and j, i = "<<i<<"; j ="<<j<<endl;
//
//		if (previ > 0) {cStartS = depart[previ]; vioTWCNEW = FvioTWCus[previ];}
//		else 
//		{
//			previ = assSP;
//			cStartS = seg[idVehi].Trip[idTripi].leaveSP;
//			vioTWCNEW = 0;
//		}
//
//		if (i != prevj)
//		{
//			//check TW till i:
//			//if (print) cout<<"check TW till i("<<i<<")"<<endl;
//			cArrTime = cStartS + problem->c[previ][j];
//			temp = cArrTime - problem->node[j].eTW;
//			if (temp > eps) 
//			{
//				vioTWCNEW += temp;
//				cStartS = problem->node[j].depart;
//			}
//			else cStartS = PDS_MAX(problem->node[j].sTW, cArrTime) + problem->node[j].duration;
//
//			cArrTime = cStartS + problem->c[j][suci];
//			temp = cArrTime - problem->node[suci].eTW;
//			if (temp > eps)
//			{
//				vioTWCNEW += temp;
//				cStartS = problem->node[suci].depart;
//			}
//			else cStartS = PDS_MAX(cArrTime, problem->node[suci].sTW) + problem->node[suci].duration;
//			
//			idcur = suci;
//			while (idcur != prevj) //check from suci to prevj
//			{
//				idnext = nextArr[idcur];
//				//cout<<"idnext = "<<idnext<<"; ";
//				cArrTime = cStartS + problem->c[idcur][idnext];
//				temp = cArrTime - problem->node[idnext].eTW;
//				if (temp > eps)
//				{
//					vioTWCNEW += temp;
//					cStartS = problem->node[idnext].depart;
//				}
//				else cStartS = PDS_MAX(problem->node[idnext].sTW, cArrTime) + problem->node[idnext].duration;
//				idcur=idnext;
//			}
//			//cout<<endl;
//			cArrTime = cStartS + problem->c[idcur][i];
//			temp = cArrTime - problem->node[i].eTW;
//			if (temp > eps)
//			{
//				vioTWCNEW += temp;
//				cStartS = problem->node[i].depart;
//			}
//			else cStartS = PDS_MAX (problem->node[i].sTW, cArrTime) + problem->node[i].duration;
//		}
//		else  // previ - i  -  j  -  sucj
//		{
//            cArrTime = cStartS + problem->c[previ][j];
//			temp = cArrTime - problem->node[j].eTW;
//            if (temp > eps) 
//			{
//				vioTWCNEW +=temp;
//				cStartS = problem->node[j].depart;
//			}   
//			else cStartS = PDS_MAX(problem->node[j].sTW, cArrTime) + problem->node[j].duration;
//		  
//			cArrTime = cStartS + problem->c[j][i];
//			temp = cArrTime - problem->node[i].eTW;
//			if (temp > eps) 
//			{
//				vioTWCNEW +=temp;
//				cStartS = problem->node[i].depart;
//			}   
//			else cStartS = PDS_MAX(problem->node[i].sTW, cArrTime) + problem->node[i].duration;
//		}
//		
//		idcur = i; 
//		//if (print) cout<<"Here i = "<<i<<endl;
//	    // need to check from sucj till the end of the trip:
//		if (sucj > 0) // last customer of the trip doesn't change
//		{
//			   idnext = sucj;
//			   while (idcur != lastCus) //check from sucj till the end of the leg
//			   {
//				    cArrTime = cStartS + problem->c[idcur][idnext];
//					temp = cArrTime - problem->node[idnext].eTW;
//					if (temp > eps)
//					{
//						vioTWCNEW += temp;
//						if (vioTWCus[idnext] > eps)
//						{
//							 if (i != prevj) // previ - i .... j - sucj --> previ - j .... - i - sucj
//								 varcost = (problem->c[previ][j] + problem->c[j][suci] + problem->c[prevj][i] + problem->c[i][sucj])
//										   -(problem->c[previ][i] + problem->c[i][suci] + problem->c[prevj][j] + problem->c[j][sucj]);
//							 else //previ - i - j - sucj --> previ - j - i - sucj
//         						 varcost = (problem->c[previ][j] + problem->c[i][sucj]) -(problem->c[previ][i] + problem->c[j][sucj]);
//							 exchangeCus[idN][k]->var_vioTWC = vioTWCNEW - FvioTWCus[idnext];
//							 exchangeCus[idN][k]->var_vioTWSP=0;
//							 exchangeCus[idN][k]->var_vioCAP = 0;
//							 exchangeCus[idN][k]->var_cost = varcost;
//							 return;
//						}
//						cStartS = problem->node[idnext].depart;
//					}
//					else cStartS = PDS_MAX(problem->node[idnext].sTW, cArrTime) + problem->node[idnext].duration;
//				    idcur=idnext; idnext = nextArr[idcur];
//			   }
//		}
//
//		//idcur is now the last customer of the trip:
//		int nextTrip = idTripi + 1;
//		if (nextTrip == seg[idVehi].numTrips) //the last trip:
//		{
//             varvioTWC = vioTWCNEW - seg[idVehi].Trip[idTripi].vioTWC;
//			 if (sucj<0) sucj=0;
//			 if (i != prevj) // previ - i .... j - sucj --> previ - j .... - i - sucj
//			     varcost = (problem->c[previ][j] + problem->c[j][suci] + problem->c[prevj][i] + problem->c[i][sucj])
//				           -(problem->c[previ][i] + problem->c[i][suci] + problem->c[prevj][j] + problem->c[j][sucj]);
//			 else //previ - i - j - sucj --> previ - j - i - sucj
//				 varcost = (problem->c[previ][j] + problem->c[i][sucj]) -(problem->c[previ][i] + problem->c[j][sucj]);
//		
//			 exchangeCus[idN][k]->var_vioTWC = varvioTWC;
//			 exchangeCus[idN][k]->var_vioTWSP=0;
//			 exchangeCus[idN][k]->var_vioCAP = 0;
//			 exchangeCus[idN][k]->var_cost = varcost;
//		}
//		else //idTrip is not the last trip
//		{
//			varvioTWSP = 0;
//           	int firstC_nextT = seg[idVehi].Trip[nextTrip].firstCus;
//			if (seg[idVehi].Trip[nextTrip].Type == 1) //nextTrip is delivery trip
//			{
//				 //cout<<"("<<idN<<", "<<k<<", "<<j<<", "<<i<<", "<<idVehi<<", "<<idTripi<<", "<<vioTWCNEW<<", ";
//				 varvioTWC = vioTWCNEW - seg[idVehi].Trip[idTripi].vioTWC;
//				 //cout<<seg[idVehi].Trip[idTripi].vioTWC<<", "<<varvioTWC<<", ";
//				 int assSP1 = seg[idVehi].Trip[nextTrip].assSP;
//				 bool stop;
//				 if (sucj < 0) // lastC change --> i is now the last cus
//				 {
//					 if (seg[idVehi].Trip[idTripi].waitingS == NO_WS)
//					 {
//						 if (i != prevj) // previ - i .... j - assSP1 --> previ - j .... - i ??-?? assSP1
//							 varcost = (problem->c[previ][j] + problem->c[j][suci] + problem->c[prevj][i])
//									   -(problem->c[previ][i] + problem->c[i][suci] + problem->c[prevj][j] + problem->c[j][assSP1]);
//						 else //previ - i - j - assSP1 --> previ - j - i ??-?? assSP1
//							 varcost = problem->c[previ][j] -(problem->c[previ][i] + problem->c[j][assSP1]);
//					 }
//					 else
//					 {
//						 if (i != prevj) // previ - i .... j -WS- assSP1 --> previ - j .... - i ??-?? assSP1
//							 varcost = (problem->c[previ][j] + problem->c[j][suci] + problem->c[prevj][i])
//									   -(problem->c[previ][i] + problem->c[i][suci] + problem->c[prevj][j] + problem->disCWSSP[j][assSP1]);
//						 else //previ - i - j -WS- assSP1 --> previ - j - i ??-?? assSP1
//							 varcost = problem->c[previ][j] -(problem->c[previ][i] + problem->disCWSSP[j][assSP1]);
//					 }
//					 stop = calChangeCONNECTAtSP_DD_LastCChanged(i, idVehi, nextTrip, cStartS, varvioTWSP, varcost);
//					 //cout<<"(1) vioTWSP = "<<vioTWSP<<"; ";
//				 }
//				 else // lastC not change --> idcur now points to the last cus
//				 {
//					 if (i != prevj) // previ - i .... j - sucj --> previ - j .... - i - sucj
//						 varcost = (problem->c[previ][j] + problem->c[j][suci] + problem->c[prevj][i] + problem->c[i][sucj])
//								   -(problem->c[previ][i] + problem->c[i][suci] + problem->c[prevj][j] + problem->c[j][sucj]);
//					 else //previ - i - j - sucj --> previ - j - i - sucj
//						 varcost = (problem->c[previ][j] + problem->c[i][sucj]) -(problem->c[previ][i] + problem->c[j][sucj]);
//					 stop = calChangeCONNECTAtSP_DD(idcur, idVehi, nextTrip, idTripi, cStartS, varvioTWSP, varcost);
//					 //cout<<"(2) vioTWSP = "<<vioTWSP<<"; ";
//				 }
//				 if (stop == 0)
//				 {
//					 GoThroughVehicle(idVehi, nextTrip, varcost, varvioTWC, varvioTWSP, cStartS, assSP1, firstC_nextT);
// 					 //cout<<"(3) vioTWSP = "<<vioTWSP<<"; ";
//				 }
//				 //cout<<varvioTWC<<endl;
//
//				exchangeCus[idN][k]->var_vioTWC = varvioTWC;
//				exchangeCus[idN][k]->var_vioTWSP = varvioTWSP;
//				exchangeCus[idN][k]->var_vioCAP = 0;
//				exchangeCus[idN][k]->var_cost = varcost;
//				//cout<<"(4) vioTWSP = "<<vioTWSP<<endl;
//			}
//			else //nextTrip is pickup trip OR C2C
//			{
//				 varvioTWC = vioTWCNEW - seg[idVehi].Trip[idTripi].vioTWC;
//				 if (sucj<0) sucj = firstC_nextT;
//				 if (i != prevj) // previ - i .... j - sucj --> previ - j .... - i - sucj
//					 varcost = (problem->c[previ][j] + problem->c[j][suci] + problem->c[prevj][i] + problem->c[i][sucj])
//							   -(problem->c[previ][i] + problem->c[i][suci] + problem->c[prevj][j] + problem->c[j][sucj]);
//				 else //previ - i - j - sucj --> previ - j - i - sucj
//					 varcost = (problem->c[previ][j] + problem->c[i][sucj]) -(problem->c[previ][i] + problem->c[j][sucj]);
//                 
//				 //cout<<"(5) vioTWSP = "<<vioTWSP<<"; ";
//				 GoThroughVehicle(idVehi, nextTrip, varcost, varvioTWC, varvioTWSP, cStartS, idcur, firstC_nextT);
//				//cout<<"(6) vioTWSP = "<<vioTWSP<<endl;
//				 exchangeCus[idN][k]->var_vioTWC = varvioTWC;
//				 exchangeCus[idN][k]->var_vioTWSP = varvioTWSP;
//				 exchangeCus[idN][k]->var_vioCAP = 0;
//				 exchangeCus[idN][k]->var_cost = varcost;
//			}//end nextTrip is pickup trip OR C2C
//       }//end else //idTrip is not the last trip
//	}
//	else //case 2: i and j are in different veh:
//	{
//		double vioTWCNEWi, vioTWCNEWj, varvioTWCi, varvioTWCj, varvioTWSPi, varvioTWSPj;
//		int assSPi = seg[idVehi].Trip[idTripi].assSP; 
//		int assSPj = seg[idVehj].Trip[idTripj].assSP; 
//
//		double varcosti, varcostj; int idcuri, idcurj;
//		previ = predArr[i]; suci = nextArr[i];
//		prevj = predArr[j]; sucj = nextArr[j];
//
//		if (previ > 0) {cStartS = depart[previ]; vioTWCNEWi = FvioTWCus[previ];}
//		else 
//		{
//			previ = assSPi;
//			cStartS = seg[idVehi].Trip[idTripi].leaveSP;
//			vioTWCNEWi = 0;
//		}
//
//		int lastCusj = seg[idVehj].Trip[idTripj].lastCus;
//		int lastCusi = seg[idVehi].Trip[idTripi].lastCus;
//		cArrTime = cStartS + problem->c[previ][j];
//		temp = cArrTime - problem->node[j].eTW;
//		if (temp > eps)
//		{
//			vioTWCNEWi += temp;
//			cStartS = problem->node[j].depart;
//		}
//		else cStartS = PDS_MAX(problem->node[j].sTW, cArrTime) + problem->node[j].duration;
//		
//        idcuri=j;
//		if (suci > 0) //need to check TW till the end of the trip i
//		{
//			idnext = suci;
//	        while (idcuri != lastCusi) //check from suci till the end of the leg i
//		    {
//		        cArrTime = cStartS + problem->c[idcuri][idnext];
//				temp = cArrTime - problem->node[idnext].eTW;
//				if (temp > eps)
//				{
//					vioTWCNEWi += temp;
//					if (vioTWCus[idnext] > eps)
//					{
//						varvioTWCi = vioTWCNEWi - FvioTWCus[idnext];
//						varvioTWSPi = 0;
//			        	//if (previ <0) previ = assSPi;
//						varcosti = problem->c[previ][j] + problem->c[j][suci] - (problem->c[previ][i] + problem->c[i][suci]);
//						goto Updatej;
//					}
//					cStartS = problem->node[idnext].depart;
//				}
//				else cStartS = PDS_MAX(problem->node[idnext].sTW, cArrTime) + problem->node[idnext].duration;
//			    idcuri=idnext; idnext = nextArr[idcuri];
//		    }
//		}
//
//		//idcuri is now the last customer of the trip and cStartS is the time to leave the NEW last customer of the trip:
//		varvioTWSPi = 0;
//		varvioTWCi = vioTWCNEWi - seg[idVehi].Trip[idTripi].vioTWC;
//
//		if (nextTripi == seg[idVehi].numTrips) //is the last trip
//		{
//        	 //if (previ <0) previ = assSPi;
//			 if (suci < 0) suci = 0;
//			 varcosti = problem->c[previ][j] + problem->c[j][suci] - (problem->c[previ][i] + problem->c[i][suci]);
//		}
//		else //not the last trip
//		{
//	         int firstC_nextT = seg[idVehi].Trip[nextTripi].firstCus;
//			 //if (previ < 0) previ = assSPi;
//			 if (seg[idVehi].Trip[nextTripi].Type == 1) //nextTripi is delivery trip
//			 {
//				 int assSP1 = seg[idVehi].Trip[nextTripi].assSP;
//				 bool stop;
//				 if (suci < 0) //change the last customer: j is now the last customer; suci was the last cus
//				 {
//					 if (seg[idVehi].Trip[idTripi].waitingS == NO_WS)
//					    varcosti = problem->c[previ][j] -(problem->c[previ][i] + problem->c[i][assSP1]);
//					 else
//						varcosti = problem->c[previ][j] -(problem->c[previ][i] + problem->disCWSSP[i][assSP1]);
// 					//cout<<"(10) vioTWSP = "<<vioTWSP<<"; ";
//					 stop = calChangeCONNECTAtSP_DD_LastCChanged(j, idVehi, nextTripi, cStartS, varvioTWSPi, varcosti);
//				 }
//				 else //doesn't change the last customer of the trip
//				 {
//					varcosti = (problem->c[previ][j] + problem->c[j][suci])
//					         - (problem->c[previ][i] + problem->c[i][suci]);
//					//cout<<"(11) vioTWSP = "<<vioTWSP<<"; ";
//					stop = calChangeCONNECTAtSP_DD(idcuri, idVehi, nextTripi, idTripi, cStartS, varvioTWSPi, varcosti);
//				 }
//				if (stop == 0)
//					GoThroughVehicle(idVehi, nextTripi, varcosti, varvioTWCi, varvioTWSPi, cStartS, assSP1, firstC_nextT);
//				//cout<<"(12) vioTWSP = "<<vioTWSP<<"; ";
//			 }//end //nextTripi is delivery trip
//			 else //nextTripi is pickup trip OR C2C
//			 {
//				if (suci < 0) //change the last customer: j is now the last customer
//				{
//					varcosti = (problem->c[previ][j] + problem->c[j][firstC_nextT])
//						      -(problem->c[previ][i] + problem->c[i][firstC_nextT]);
//				}
//				else //doesn't change the last customer of the trip
//				{
//					varcosti = (problem->c[previ][j] + problem->c[j][suci]) 
//						     - (problem->c[previ][i] + problem->c[i][suci]);
//				}
//				//cout<<"(13) vioTWSP = "<<vioTWSP<<"; ";
//				GoThroughVehicle(idVehi, nextTripi, varcosti, varvioTWCi, varvioTWSPi, cStartS, idcuri, firstC_nextT);
//			 }//end nextTripi is pickup trip OR C2C
//		}//end idTripi is not the last trip
//		//cout<<"(14) vioTWSP = "<<vioTWSP<<"; ";
//
//	Updatej:
//   		if (prevj > 0) {cStartS = depart[prevj]; vioTWCNEWj = FvioTWCus[prevj];}
//		else 
//		{
//			prevj = assSPj;
//			cStartS = seg[idVehj].Trip[idTripj].leaveSP;
//			vioTWCNEWj = 0;
//		}
//
//		cArrTime = cStartS + problem->c[prevj][i];
//		temp = cArrTime - problem->node[i].eTW;
//		if (temp > eps)
//		{
//			vioTWCNEWj += temp;
//			cStartS = problem->node[i].depart;
//		}
//		else cStartS = PDS_MAX(problem->node[i].sTW, cArrTime) + problem->node[i].duration;
//		
//		idcurj=i;
//		if (sucj > 0) //need to check TW till the end of the trip j
//		{
//			idnext = sucj;
//	        while (idcurj != lastCusj) //check from suci till the end of the trip j
//		    {
//		        cArrTime = cStartS + problem->c[idcurj][idnext];
//				temp = cArrTime - problem->node[idnext].eTW;
//				if (temp > eps)
//				{
//					vioTWCNEWj += temp;
//					if (vioTWCus[idnext] > eps)
//					{
//						varvioTWCj = vioTWCNEWj - FvioTWCus[idnext];
//						varvioTWSPj = 0;
//						//if (prevj < 0) prevj = assSPj;
//						varcostj = problem->c[prevj][i] + problem->c[i][sucj] - (problem->c[prevj][j] + problem->c[j][sucj]);
//						goto Update;
//					}
//					cStartS = problem->node[idnext].depart;
//				}
//				else  cStartS = PDS_MAX(problem->node[idnext].sTW, cArrTime) + problem->node[idnext].duration;
//			    idcurj=idnext; idnext = nextArr[idcurj];
//		    }
//		}
//		//idcurj is now the last customer of the trip and cStartS is the start service at the NEW last customer of the trip:
//		varvioTWSPj = 0;
//		varvioTWCj = vioTWCNEWj - seg[idVehj].Trip[idTripj].vioTWC;
//			 
//		if (nextTripj == seg[idVehj].numTrips) //is the last trip
//		{
//		     //if (prevj < 0) prevj = assSPj;
//			 if (sucj < 0) sucj = 0;
//			 varcostj = problem->c[prevj][i] + problem->c[i][sucj] - (problem->c[prevj][j] + problem->c[j][sucj]);
//		}
//		else //not the last trip
//		{
//			 int firstC_nextT = seg[idVehj].Trip[nextTripj].firstCus;
//			 //if (prevj < 0) prevj = assSPj;
//			 if (seg[idVehj].Trip[nextTripj].Type == 1) //nextTripj is delivery trip
//			 {
//			    int assSP1 = seg[idVehj].Trip[nextTripj].assSP;
//				bool stop;
//				if (sucj < 0) //change the last customer: i is now the last customer; j was the last customer
//				{
//					if (seg[idVehj].Trip[idTripj].waitingS == NO_WS)
//						varcostj = problem->c[prevj][i] -(problem->c[prevj][j] + problem->c[j][assSP1]);
//					else 
//						varcostj = problem->c[prevj][i] -(problem->c[prevj][j] + problem->disCWSSP[j][assSP1]);
//
//					stop = calChangeCONNECTAtSP_DD_LastCChanged(i, idVehj, nextTripj, cStartS, varvioTWSPj, varcostj);
//					//cout<<"(15) vioTWSP = "<<vioTWSP<<"; ";
//
//				}
//				else //doesn't change the last customer of the trip
//				{
//					varcostj = (problem->c[prevj][i] + problem->c[i][sucj]) 
//						     - (problem->c[prevj][j] + problem->c[j][sucj]);
//					stop = calChangeCONNECTAtSP_DD(idcurj, idVehj, nextTripj, idTripj, cStartS, varvioTWSPj, varcostj);
//					//cout<<"(16) vioTWSP = "<<vioTWSP<<"; ";
//				}
//				if (stop == 0)
//				   GoThroughVehicle(idVehj, nextTripj, varcostj, varvioTWCj, varvioTWSPj, cStartS, assSP1, firstC_nextT);
//				//cout<<"(17) vioTWSP = "<<vioTWSP<<"; ";
//			 }//end nextTripj is delivery trip
//			 else //nextTripj is pickup trip OR C2C
//			 {
//				if (sucj < 0) //change the last customer: i is now the last customer
//					varcostj = (problem->c[prevj][i] + problem->c[i][firstC_nextT])
//						      -(problem->c[prevj][j] + problem->c[j][firstC_nextT]);
//				else //doesn't change the last customer of the trip
//					varcostj = (problem->c[prevj][i] + problem->c[i][sucj]) 
//					         - (problem->c[prevj][j] + problem->c[j][sucj]);
//				GoThroughVehicle(idVehj, nextTripj, varcostj, varvioTWCj, varvioTWSPj, cStartS, idcurj, firstC_nextT);
//				//cout<<"(18) vioTWSP = "<<vioTWSP<<"; ";
//			 }//end nextTripj is pickup trip OR C2C
//		}//end idTripj is not the last trip
//
//	Update:
//		varvioTWC = varvioTWCi + varvioTWCj;
//		varvioTWSP = varvioTWSPi + varvioTWSPj;
//		int capi = seg[idVehi].Trip[idTripi].capacity - problem->node[i].capacity + problem->node[j].capacity;
//		int capj = seg[idVehj].Trip[idTripj].capacity - problem->node[j].capacity + problem->node[i].capacity;
//		int vioCapi = PDS_MAX(capi - problem->Q,0);
//		int vioCapj = PDS_MAX(capj - problem->Q,0);
//		varvioCAP = (vioCapi - seg[idVehi].Trip[idTripi].vioCAP) + (vioCapj - seg[idVehj].Trip[idTripj].vioCAP);
//	    varcost = varcosti + varcostj;
//
//		exchangeCus[j][k]->var_vioTWC = varvioTWC;
//    	exchangeCus[j][k]->var_vioTWSP = varvioTWSP;
//		exchangeCus[j][k]->var_vioCAP = varvioCAP;
//		exchangeCus[j][k]->var_cost = varcost;
//		//cout<<"(19) vioTWSP = "<<vioTWSP<<endl;
//	}
//}
//
//void Solution::cal_ExchangeCusPIAndJ(int j, int k)
//{
//	//see on 2/12/2013
//	int i = problem->node[j].neighborNode[k].id; 
//
//    int previ, suci, prevj, sucj, idcur, idnext;
//
//    int idVehj = route_num[j]; int idTripj = trip_num[j];
//    int idVehi = route_num[i]; int idTripi = trip_num[i];
//
//	double vioTWCNEW, varvioTWC, varvioTWSP=0, varcost; 
//	int varvioCAP;
//	double cStartS, cArrTime,temp;
//
//    if (idVehi == idVehj)
//	{
//		if (idTripi == idTripj) // i and j are in the same trip:
//		{
//			int assSP = seg[idVehi].Trip[idTripi].assSP; 
//			int lastCus = seg[idVehi].Trip[idTripi].lastCus;
//			int idN = j;
//			if (pos[i] > pos[j])
//			{int tt=i;i=j;j=tt;} //swap i and j so that i is before j
//			
//			//if (nextArr[j]==i) return;
//			previ = predArr[i]; suci = nextArr[i];
//			prevj = predArr[j]; sucj = nextArr[j];
//			//if (print) cout<<"swap i and j, i = "<<i<<"; j ="<<j<<endl;
//
//			if (previ > 0) {cStartS = depart[previ]; vioTWCNEW = FvioTWCus[previ];}
//			else 
//			{
//				vioTWCNEW = 0;
//				if (idTripi == 0)
//				{
//					previ = 0;
//					cStartS = 0;
//				}
//				else
//				{
//					int preT = idTripi - 1;
//					if (seg[idVehi].Trip[preT].Type == 0)
//					{
//						previ = seg[idVehi].Trip[preT].assSP;
//						cStartS = seg[idVehi].Trip[preT].leaveSP;
//					}
//					else
//					{
//						previ = seg[idVehi].Trip[preT].lastCus;
//						cStartS = depart[previ];
//					}
//				}
//			}
//			/*cout<<"i = "<<i<<"; j = "<<j<<"; ";
//			cout << fixed << setprecision(7) << cStartS <<"; ";*/
//				
//
//			if (i != prevj)
//			{
//				//check TW till i:
//				//if (print) cout<<"check TW till i("<<i<<")"<<endl;
//				cArrTime = cStartS + problem->c[previ][j];
//				temp = cArrTime - problem->node[j].eTW;
//				if (temp > eps) 
//				{
//					vioTWCNEW += temp;
//					cStartS = problem->node[j].depart;
//				}
//				else cStartS = PDS_MAX(problem->node[j].sTW, cArrTime) + problem->node[j].duration;
//				/*cout<<"(j) ";
//				cout << fixed << setprecision(7) << cStartS <<"; ";*/
//				//cout<<"(j="<<j<<";i="<<i<<";"<<idTripi<<";"<<suci<<";"<<prevj<<";"<<previ<<");"<<endl;
//
//				cArrTime = cStartS + problem->c[j][suci];
//				temp = cArrTime - problem->node[suci].eTW;
//				if (temp > eps)
//				{
//					vioTWCNEW += temp;
//					cStartS = problem->node[suci].depart;
//				}
//				else cStartS = PDS_MAX(cArrTime, problem->node[suci].sTW) + problem->node[suci].duration;
//				//cout << fixed << setprecision(7) << cStartS <<"; ";
//								
//				idcur = suci;
//				while (idcur != prevj) //check from suci to prevj
//				{
//					idnext = nextArr[idcur];
//					//cout<<"idnext = "<<idnext<<"; ";
//					cArrTime = cStartS + problem->c[idcur][idnext];
//					temp = cArrTime - problem->node[idnext].eTW;
//					if (temp > eps)
//					{
//						vioTWCNEW += temp;
//						cStartS = problem->node[idnext].depart;
//					}
//					else cStartS = PDS_MAX(problem->node[idnext].sTW, cArrTime) + problem->node[idnext].duration;
//					idcur=idnext;
//				}
//				//cout<<endl;
//				cArrTime = cStartS + problem->c[idcur][i];
//				temp = cArrTime - problem->node[i].eTW;
//				if (temp > eps)
//				{
//					vioTWCNEW += temp;
//					cStartS = problem->node[i].depart;
//				}
//				else cStartS = PDS_MAX (problem->node[i].sTW, cArrTime) + problem->node[i].duration;
//				/*cout<<"(i) ";
//				cout << fixed << setprecision(7) << cStartS <<"; ";*/
//				
//			}
//			else  // previ - i  -  j  -  sucj
//			{
//				cArrTime = cStartS + problem->c[previ][j];
//				temp = cArrTime - problem->node[j].eTW;
//				if (temp > eps) 
//				{
//					vioTWCNEW +=temp;
//					cStartS = problem->node[j].depart;
//				}   
//				else cStartS = PDS_MAX(problem->node[j].sTW, cArrTime) + problem->node[j].duration;
//				/*cout<<"[j] ";
//				cout << fixed << setprecision(7) << cStartS <<"; ";*/
//				
//				cArrTime = cStartS + problem->c[j][i];
//				temp = cArrTime - problem->node[i].eTW;
//				if (temp > eps) 
//				{
//					vioTWCNEW +=temp;
//					cStartS = problem->node[i].depart;
//				}   
//				else cStartS = PDS_MAX(problem->node[i].sTW, cArrTime) + problem->node[i].duration;
//				/*cout<<"[i] ";
//				cout << fixed << setprecision(7) << cStartS <<"; ";*/
//				
//			}
//			
//			idcur = i; bool stop, vioTWSPTRUE;
//			//if (print) cout<<"Here i = "<<i<<endl;
//			// need to check from sucj till the end of the trip:
//			if (sucj > 0) // last customer of the trip doesn't change
//			{
//				   idnext = sucj;
//				   while (idcur != lastCus) //check from sucj till the end of the leg
//				   {
//						cArrTime = cStartS + problem->c[idcur][idnext];
//						temp = cArrTime - problem->node[idnext].eTW;
//						if (temp > eps)
//						{
//							vioTWCNEW += temp;
//							if (vioTWCus[idnext] > eps)
//							{
//								 if (i != prevj) // previ - i .... j - sucj --> previ - j .... - i - sucj
//									 varcost = (problem->c[previ][j] + problem->c[j][suci] + problem->c[prevj][i] + problem->c[i][sucj])
//											   -(problem->c[previ][i] + problem->c[i][suci] + problem->c[prevj][j] + problem->c[j][sucj]);
//								 else //previ - i - j - sucj --> previ - j - i - sucj
//         							 varcost = (problem->c[previ][j] + problem->c[i][sucj]) -(problem->c[previ][i] + problem->c[j][sucj]);
//								 exchangeCus[idN][k]->var_vioTWC = vioTWCNEW - FvioTWCus[idnext];
//								 exchangeCus[idN][k]->var_vioTWSP = 0;
//								 exchangeCus[idN][k]->var_vioCAP = 0;
//								 exchangeCus[idN][k]->var_cost = varcost;
//								 return;
//							}
//							cStartS = problem->node[idnext].depart;
//						}
//						else cStartS = PDS_MAX(problem->node[idnext].sTW, cArrTime) + problem->node[idnext].duration;
//						idcur=idnext; idnext = nextArr[idcur];
//				   }
//				   //lastC doesn't change; idcur now points to the last cus
//					if (i != prevj) // previ - i .... j - sucj --> previ - j .... - i - sucj
//						 varcost = (problem->c[previ][j] + problem->c[j][suci] + problem->c[prevj][i] + problem->c[i][sucj])
//								   -(problem->c[previ][i] + problem->c[i][suci] + problem->c[prevj][j] + problem->c[j][sucj]);
//					else //previ - i - j - sucj --> previ - j - i - sucj
//						 varcost = (problem->c[previ][j] + problem->c[i][sucj]) -(problem->c[previ][i] + problem->c[j][sucj]);
//					/*cout<<" depart["<<idcur<<"] = ";
//					cout << fixed << setprecision(7) << cStartS <<"; ";*/
//					stop = calChangeCONNECTAtSP_PickTrip(idcur, idVehi, idTripi, cStartS, varvioTWSP, varcost, vioTWSPTRUE);
//					//cout<<varvioTWSP<<"; ";
//			}
//			else //lastC is changed: i is now the last cus; j was the last cus
//			{
//				if (i != prevj) // previ - i .... j. --> previ - j .... - i.
//					 varcost = (problem->c[previ][j] + problem->c[j][suci] + problem->c[prevj][i])
//							   -(problem->c[previ][i] + problem->c[i][suci] + problem->c[prevj][j]);
//				else //previ - i - j. --> previ - j - i.
//					varcost = problem->c[previ][j] - problem->c[previ][i];
//				if (seg[idVehi].Trip[idTripi].waitingS == NO_WS)
//					varcost -= problem->c[j][assSP];
//				else varcost -= problem->disCWSSP[j][assSP];
//				stop = calChangeCONNECTAtSP_PickTrip_LastCChanged(i, idVehi, idTripi, cStartS, varvioTWSP, varcost, vioTWSPTRUE);
//				//cout<<varvioTWSP<<"; ";
//			}
//
//			varvioTWC = vioTWCNEW - seg[idVehi].Trip[idTripi].vioTWC;
//			if (stop == 0)
//			{
//				int nextT = idTripi + 1;
//				if (nextT < seg[idVehi].numTrips)
//				{
//					int firstC_nextT = seg[idVehi].Trip[nextT].firstCus;
//					if (seg[idVehi].Trip[nextT].Type == 1)
//					{
//						if (seg[idVehi].Trip[nextT].assSP == assSP)
//						{
//							//varvioTWSP *= 2; //already calculated at calChangeCONNECTAtSP_PickTrip/calChangeCONNECTAtSP_PickTrip_LastCChanged
//							//cout << fixed << setprecision(7) << cStartS <<"; ";
//							//Update 16/11/2013
//							if (vioTWSPTRUE) cStartS = problem->leaveSP[assSP][1]; //load at eTW2
//							else cStartS += problem->nodeSP[assSP].load;
//						    GoThroughVehicle(idVehi, nextT, varcost, varvioTWC, varvioTWSP, cStartS, assSP, firstC_nextT);
//						}
//						else // p - asssP -- asssP1 - d
//						{
//							if (calChangeCONNECTAtSP_SPSP(idVehi, nextT, idTripi, cStartS, varvioTWSP, varcost) == 0)
//							    GoThroughVehicle(idVehi, nextT, varcost, varvioTWC, varvioTWSP, cStartS, seg[idVehi].Trip[nextT].assSP, firstC_nextT);
//						}//end p - asssP -- asssP1 - d
//					}
//					else //nextT is pickup trip OR C2C
//					{
//						GoThroughVehicle(idVehi, nextT, varcost, varvioTWC, varvioTWSP, cStartS, assSP, firstC_nextT);
//					}//end nextT is pickup trip OR C2C
//				}
//				//cout<<"varvioTWSP = "<<varvioTWSP<<endl;
//			}
//			//else cout<<" NC!"<<endl;
//			exchangeCus[idN][k]->var_vioTWC = varvioTWC;
//			exchangeCus[idN][k]->var_vioTWSP = varvioTWSP;
//			exchangeCus[idN][k]->var_vioCAP = 0;
//			exchangeCus[idN][k]->var_cost = varcost;
//		}
//		else // i and j are in the same vehicle, but different trips
//		{
//				int assSPi = seg[idVehi].Trip[idTripi].assSP; 
//				int assSPj = seg[idVehj].Trip[idTripj].assSP; 
//				if (problem->belong[j][assSPi] == 0 || problem->belong[i][assSPj] == 0)
//				{
//					exchangeCus[j][k]->var_vioCAP = PDS_INFINITY_INT;
//					return;
//				}
//				double vioTWCNEWi, vioTWCNEWj, varvioTWCi, varvioTWCj, varvioTWSPi, varvioTWSPj;
//				varvioTWSPi = 0; varvioTWSPj = 0;
//
//				double varcosti, varcostj; int idcuri, idcurj;
//
//				int idN = j;
//				if (idTripi > idTripj) 
//				{
//					int tt=i;i=j;j=tt;
//					tt = idTripi; idTripi = idTripj; idTripj = tt;
//					assSPi = seg[idVehi].Trip[idTripi].assSP; 
//					assSPj = seg[idVehj].Trip[idTripj].assSP; 
//				} //swap i and j so that i is before j
//
//
//				int numTrips = idTripj-idTripi - 1;
//				previ = predArr[i]; suci = nextArr[i];
//				prevj = predArr[j]; sucj = nextArr[j];
//				int preTi, preTj = idTripj - 1;
//				bool stop, vioTWSPTRUE;
//				int lastCusj = seg[idVehj].Trip[idTripj].lastCus;
//				int lastCusi = seg[idVehi].Trip[idTripi].lastCus;
//
//
//				if (idTripi == 0 && seg[idVehi].Trip[idTripi].numCus == 1)
//				{
//					varcosti = problem->c[0][j] - problem->c[0][i];
//					if (seg[idVehi].Trip[idTripi].waitingS == NO_WS)
//						varcosti -= problem->c[i][assSPi];
//					else varcosti -= problem->disCWSSP[i][assSPi];
//					cStartS = problem->startSOneP[j][assSPi] + problem->node[j].duration;
//					varvioTWCi = 0;
//					stop = calChangeCONNECTAtSP_PickTrip_LastCChanged(j, idVehi, idTripi, cStartS, varvioTWSPi, varcosti, vioTWSPTRUE);
//				}
//				else
//				{
//					if (previ > 0) {cStartS = depart[previ]; vioTWCNEWi = FvioTWCus[previ];}
//					else 
//					{
//						vioTWCNEWi = 0;
//						if (idTripi == 0)
//						{
//						   previ = 0;
//						   cStartS = 0;
//						}
//						else
//						{
//							preTi = idTripi - 1;
//							if (seg[idVehi].Trip[preTi].Type == 0)
//							{
//								previ = seg[idVehi].Trip[preTi].assSP;
//								cStartS = seg[idVehi].Trip[preTi].leaveSP;
//							}
//							else // == 1 OR 2
//							{
//								previ = seg[idVehi].Trip[preTi].lastCus;
//								cStartS = depart[previ];
//							}
//						}
//					}
//					cArrTime = cStartS + problem->c[previ][j];
//					temp = cArrTime - problem->node[j].eTW;
//					if (temp > eps)
//					{
//						vioTWCNEWi += temp;
//						cStartS = problem->node[j].depart;
//					}
//					else cStartS = PDS_MAX(problem->node[j].sTW, cArrTime) + problem->node[j].duration;
//					
//					idcuri=j; 
//					if (suci > 0) //need to check TW till the end of the trip i
//					{
//						idnext = suci;
//						while (idcuri != lastCusi) //check from suci till the end of the trip i
//						{
//							cArrTime = cStartS + problem->c[idcuri][idnext];
//							temp = cArrTime - problem->node[idnext].eTW;
//							if (temp > eps)
//							{
//								vioTWCNEWi += temp;
//								if (vioTWCus[idnext] > eps)
//								{
//									varvioTWCi = vioTWCNEWi - FvioTWCus[idnext];
//									//varvioTWSPi = 0;
//									//if (previ <0) previ = assSPi;
//									varcosti = problem->c[previ][j] + problem->c[j][suci] - (problem->c[previ][i] + problem->c[i][suci]);
//									if (seg[idVehj].Trip[preTj].Type == 0)
//									{
//										idcurj = seg[idVehj].Trip[preTj].assSP;
//										cStartS = seg[idVehj].Trip[preTj].leaveSP;
//									}
//									else // == 1 OR 2
//									{
//										idcurj = seg[idVehj].Trip[preTj].lastCus;
//										cStartS = depart[idcurj];
//									}
//									goto Updatej;
//								}
//								cStartS = problem->node[idnext].depart;
//							}
//							else cStartS = PDS_MAX(problem->node[idnext].sTW, cArrTime) + problem->node[idnext].duration;
//							idcuri=idnext; idnext = nextArr[idcuri];
//						}
//						//dont change the last customer: idcuri now points to the last customer
//						varcosti = problem->c[previ][j] + problem->c[j][suci] - (problem->c[previ][i] + problem->c[i][suci]);
//						stop = calChangeCONNECTAtSP_PickTrip(idcuri, idVehi, idTripi, cStartS, varvioTWSPi, varcosti, vioTWSPTRUE);
//					}
//					else //change the last customer: j is now the last customer; i was the last customer
//					{
//						varcosti = problem->c[previ][j] - problem->c[previ][i];
//						if (seg[idVehi].Trip[idTripi].waitingS == NO_WS)
//							varcosti -= problem->c[i][assSPi];
//						else varcosti -= problem->disCWSSP[i][assSPi];
//						stop = calChangeCONNECTAtSP_PickTrip_LastCChanged(j, idVehi, idTripi, cStartS, varvioTWSPi, varcosti, vioTWSPTRUE);
//					}
//					varvioTWCi = vioTWCNEWi - seg[idVehi].Trip[idTripi].vioTWC;
//				}//end not (idTripi == 0 && seg[idVehi].Trip[idTripi].numCus == 1)
//
//
//				if (stop == 0)
//				{
//					if (numTrips > 0)
//					{
//							int nextT = idTripi + 1;
//							int firstC_nextT = seg[idVehi].Trip[nextT].firstCus;
//							if (seg[idVehi].Trip[nextT].Type == 1)
//							{
//								if (assSPi == seg[idVehi].Trip[nextT].assSP)
//								{
//									//varvioTWSPi *= 2; already calculated at calChangeCONNECTAtSP_PickTrip/calChangeCONNECTAtSP_PickTrip_LastCChanged
//									//Update 16/11/2013
//									if (vioTWSPTRUE) cStartS = problem->leaveSP[assSPi][1]; //unload at eTW2
//									else cStartS += problem->nodeSP[assSPi].load;
//									//Quangnn+-
//									//stop = GoThroughVehicle(idVehi, nextT, numTrips, varcosti, varvioTWCi, varvioTWSPi, cStartS, assSPi, firstC_nextT);
//								}
//								else //p - assSPi -- assSP1 - d
//								{
//									if (calChangeCONNECTAtSP_SPSP(idVehi, nextT, idTripi, cStartS, varvioTWSPi, varcosti) == 0){
//										//Quangnn+-
//										//stop = GoThroughVehicle(idVehi, nextT, numTrips, varcosti, varvioTWCi, varvioTWSPi, cStartS, seg[idVehi].Trip[nextT].assSP, firstC_nextT);
//									}
//								}
//							}
//							else{ //== 0 OR 2
//							   //Quangnn+-
//								//stop = GoThroughVehicle(idVehi, nextT,numTrips, varcosti, varvioTWCi, varvioTWSPi, cStartS, assSPi, firstC_nextT);
//							}
//
//							if (stop)
//							{
//								if (seg[idVehj].Trip[preTj].Type == 0)
//								{
//									idcurj = seg[idVehj].Trip[preTj].assSP;
//									cStartS = seg[idVehj].Trip[preTj].leaveSP;
//								}
//								else //== 1 OR 2
//								{
//									idcurj = seg[idVehj].Trip[preTj].lastCus;
//									cStartS = depart[idcurj];
//								}
//							}
//							else
//							{
//								if (seg[idVehj].Trip[preTj].Type == 0) idcurj = seg[idVehj].Trip[preTj].assSP;
//								else idcurj = seg[idVehj].Trip[preTj].lastCus;
//								//cStartS taken from GoThroughVehicle
//							}
//					}//end if (numTrips > 0)
//					else //idTripj == idTripi + 1:
//					{
//						idcurj = seg[idVehi].Trip[idTripi].assSP;
//						//cStartS taken from the call of calChangeCONNECTAtSP_PickTrip/alChangeCONNECTAtSP_PickTrip_LastCChanged
//					}
//				}//end if (stop == 0)
//				else //stop = 1 --> nothing's changed after replace i by j in pickup trip (idVehi, idTripi)
//				{
//					if (seg[idVehj].Trip[preTj].Type == 0) 
//					{
//						idcurj = seg[idVehj].Trip[preTj].assSP;
//						cStartS = seg[idVehj].Trip[preTj].leaveSP;
//					}
//					else // == 1 OR 2
//					{
//						idcurj = seg[idVehj].Trip[preTj].lastCus;
//						cStartS = depart[idcurj];
//					}
//				}
//
//			Updatej:
//				vioTWCNEWj = 0;
//				idnext = seg[idVehj].Trip[idTripj].firstCus;
//				if (prevj < 0) prevj = idcurj;
//				//cout<<" i = "<<i<<"; j = "<<j<<"; cStartS = "<<cStartS<<"; ";
//				while (idnext != j)
//				{
//						cArrTime = cStartS + problem->c[idcurj][idnext];
//						temp = cArrTime - problem->node[idnext].eTW;
//						if (temp > eps)
//						{
//							vioTWCNEWj += temp;
//							cStartS = problem->node[idnext].depart;
//						}
//						else cStartS = PDS_MAX(cArrTime, problem->node[idnext].sTW) + problem->node[idnext].duration;
//						idcurj = idnext; idnext = nextArr[idcurj];
//				}
//				//idcurj now points to prevj:
//				//cout<<"depart["<<idcurj<<"] = "<<cStartS<<"; ";
//				cArrTime = cStartS + problem->c[idcurj][i];
//				temp = cArrTime - problem->node[i].eTW;
//				if (temp > eps)
//				{
//					vioTWCNEWj += temp;
//					cStartS = problem->node[i].depart;
//				}
//				else cStartS = PDS_MAX(cArrTime, problem->node[i].sTW) + problem->node[i].duration;
//				//cout<<"depart[i] = "<<cStartS<<"; vioTWCNEWj_till_i = "<<vioTWCNEWj<<"; ";
//
//				idcurj = i; 
//				if (sucj > 0) //need to check TW till the end of the trip j
//				{
//					idnext = sucj;
//					while (idcurj != lastCusj) //check from sucj till the end of the trip j
//					{
//						cArrTime = cStartS + problem->c[idcurj][idnext];
//						temp = cArrTime - problem->node[idnext].eTW;
//						if (temp > eps)
//						{
//							vioTWCNEWj += temp;
//							if (vioTWCus[idnext] > eps)
//							{
//								varvioTWCj = vioTWCNEWj - FvioTWCus[idnext];
//								//varvioTWSPi = 0;
//								//if (previ <0) previ = assSPi;
//								varcostj = problem->c[prevj][i] + problem->c[i][sucj] - (problem->c[prevj][j] + problem->c[j][sucj]);
//								goto Updatej1;
//							}
//							cStartS = problem->node[idnext].depart;
//						}
//						else cStartS = PDS_MAX(problem->node[idnext].sTW, cArrTime) + problem->node[idnext].duration;
//						idcurj=idnext; idnext = nextArr[idcurj];
//					}
//					//dont change the last customer: idcurj now points to the last customer
//					varcostj = problem->c[prevj][i] + problem->c[i][sucj] - (problem->c[prevj][j] + problem->c[j][sucj]);
//					stop = calChangeCONNECTAtSP_PickTrip(idcurj, idVehj, idTripj, cStartS, varvioTWSPj, varcostj, vioTWSPTRUE);
//				}
//				else //change the last customer: i is now the last customer; j was the last customer
//				{
//					varcostj = problem->c[prevj][i] - problem->c[prevj][j];
//					//cout<<"j = "<<j<<"; varcostj = "<<varcostj<<"; ";
//					if (seg[idVehj].Trip[idTripj].waitingS == NO_WS)
//						varcostj -= problem->c[j][assSPj];
//					else varcostj -= problem->disCWSSP[j][assSPj];
//					//cout<<varcostj<<"; ";
//					stop = calChangeCONNECTAtSP_PickTrip_LastCChanged(i, idVehj, idTripj, cStartS, varvioTWSPj, varcostj, vioTWSPTRUE);
//				   // cout<<varcostj<<endl;
//				}
//				
//				varvioTWCj = vioTWCNEWj - seg[idVehj].Trip[idTripj].vioTWC;
//				if (stop == 0)
//				{
//					int nextT = idTripj + 1;
//					if (nextT < seg[idVehj].numTrips) //not the last trip:
//					{
//						int firstC_nextT = seg[idVehj].Trip[nextT].firstCus;
//						if (seg[idVehj].Trip[nextT].Type == 1) //nextT is delivery trip
//						{
//							if (assSPj == seg[idVehj].Trip[nextT].assSP) // p - assSPj - d
//							{
//								//varvioTWSPj *= 2; already calculated at calChangeCONNECTAtSP_PickTrip/calChangeCONNECTAtSP_PickTrip_LastCChanged
//								//Update 16/11/2013
//								if (vioTWSPTRUE) cStartS = problem->leaveSP[assSPj][1]; //load at eTW2
//								else cStartS += problem->nodeSP[assSPj].load;
//								GoThroughVehicle(idVehj, nextT, varcostj, varvioTWCj, varvioTWSPj, cStartS, assSPj, firstC_nextT);
//							}
//							else //p  - assSPj - assSP1 - d
//							{
//								if (calChangeCONNECTAtSP_SPSP(idVehj, nextT, idTripj, cStartS, varvioTWSPj, varcostj) == 0)
//									GoThroughVehicle(idVehj, nextT, varcostj, varvioTWCj, varvioTWSPj, cStartS, seg[idVehj].Trip[nextT].assSP, firstC_nextT);
//							}//end p  - assSPj - assSP1 - d
//						}
//						else //nextT is pickup trip OR C2C:
//						{
//							GoThroughVehicle(idVehj, nextT, varcostj, varvioTWCj, varvioTWSPj, cStartS, assSPj, firstC_nextT);
//						}//end nextT is pickup trip OR C2C
//					}
//				}
//			Updatej1:
//				varvioTWC = varvioTWCi + varvioTWCj;
//				//cout<<"vioTWCNEWj = "<<vioTWCNEWj<<"; varvioTWCj = "<<varvioTWCj<<endl;
//				varvioTWSP = varvioTWSPi + varvioTWSPj;
//				int capi = seg[idVehi].Trip[idTripi].capacity - problem->node[i].capacity + problem->node[j].capacity;
//				int capj = seg[idVehj].Trip[idTripj].capacity - problem->node[j].capacity + problem->node[i].capacity;
//				int vioCapi = PDS_MAX(capi - problem->Q,0);
//				int vioCapj = PDS_MAX(capj - problem->Q,0);
//				varvioCAP = (vioCapi - seg[idVehi].Trip[idTripi].vioCAP) + (vioCapj - seg[idVehj].Trip[idTripj].vioCAP);
//				varcost = varcosti + varcostj;
//
//				exchangeCus[idN][k]->var_vioTWC = varvioTWC;
//				exchangeCus[idN][k]->var_vioTWCi = varvioTWCi;
//				exchangeCus[idN][k]->var_vioTWCj = varvioTWCj;
//    			exchangeCus[idN][k]->var_vioTWSP = varvioTWSP;
//    			exchangeCus[idN][k]->var_vioTWSPi = varvioTWSPi;
//    			exchangeCus[idN][k]->var_vioTWSPj = varvioTWSPj;
//				exchangeCus[idN][k]->var_vioCAP = varvioCAP;
//				exchangeCus[idN][k]->var_cost = varcost;
//				exchangeCus[idN][k]->var_costi = varcosti;
//				exchangeCus[idN][k]->var_costj = varcostj;
//		}//end i and j are in the same vehicle, but different trips
//	}
//	else // i and j are in the different vehicles:
//	{
//		int assSPi = seg[idVehi].Trip[idTripi].assSP; 
//		int assSPj = seg[idVehj].Trip[idTripj].assSP; 
//
//		if (problem->belong[j][assSPi] == 0 || problem->belong[i][assSPj] == 0)
//		{
//			exchangeCus[j][k]->var_vioCAP = PDS_INFINITY_INT;
//			return;
//		}
//		
//		double vioTWCNEWi, vioTWCNEWj, varvioTWCi, varvioTWCj, varvioTWSPi, varvioTWSPj;
//		varvioTWSPi = 0; varvioTWSPj = 0;
//
//		double varcosti, varcostj; int idcuri, idcurj;
//		previ = predArr[i]; suci = nextArr[i];
//		prevj = predArr[j]; sucj = nextArr[j];
//		int preTi, preTj;
//		bool stop, vioTWSPTRUE;
//
//		int lastCusj = seg[idVehj].Trip[idTripj].lastCus;
//		int lastCusi = seg[idVehi].Trip[idTripi].lastCus;
//
//		if (idTripi == 0 && seg[idVehi].Trip[idTripi].numCus == 1)
//		{
//			varvioTWCi = 0;
//			varcosti = problem->c[0][j] - problem->c[0][i];
//			if (seg[idVehi].Trip[idTripi].waitingS == NO_WS)
//				varcosti -= problem->c[i][assSPi];
//			else varcosti -= problem->disCWSSP[i][assSPi];
//			//cStartS = problem->startSOneP[j][assSPi] + problem->node[j].duration;
//			if (problem->waitingSOneP[j][assSPi])
//			{
//				varcosti += problem->disCWSSP[j][assSPi];
//				//cStartS += problem->disCWSSP[j][assSPi];
//				//cStartS = PDS_MAX(cStartS, problem->nodeSP[assSPi].sTW1);
//			}
//			else
//			{
//				varcosti += problem->c[j][assSPi];
//				//cStartS += problem->c[j][assSPi];
//			}
//			//cStartS += problem->nodeSP[assSPi].unload;
//			cStartS = problem->leaveSPOneP[j][assSPi];
//			if (PDSDIF(cStartS, seg[idVehi].Trip[0].leaveSP)==0) goto Updatej2;
//			stop = 0;
//		}
//		else
//		{
//			if (previ > 0) {cStartS = depart[previ]; vioTWCNEWi = FvioTWCus[previ];}
//			else 
//			{
//				vioTWCNEWi = 0;
//				if (idTripi == 0)
//				{
//				   previ = 0;
//				   cStartS = 0;
//				}
//				else
//				{
//					preTi = idTripi - 1;
//					if (seg[idVehi].Trip[preTi].Type == 0)
//					{
//						previ = seg[idVehi].Trip[preTi].assSP;
//						cStartS = seg[idVehi].Trip[preTi].leaveSP;
//					}
//					else // == 1 OR 2
//					{
//						previ = seg[idVehi].Trip[preTi].lastCus;
//						cStartS = depart[previ];
//					}
//				}
//			}
//
//			cArrTime = cStartS + problem->c[previ][j];
//			temp = cArrTime - problem->node[j].eTW;
//			if (temp > eps)
//			{
//				vioTWCNEWi += temp;
//				cStartS = problem->node[j].depart;
//			}
//			else cStartS = PDS_MAX(problem->node[j].sTW, cArrTime) + problem->node[j].duration;
//			
//			idcuri=j; 
//			if (suci > 0) //need to check TW till the end of the trip i
//			{
//				idnext = suci;
//				while (idcuri != lastCusi) //check from suci till the end of the leg i
//				{
//					cArrTime = cStartS + problem->c[idcuri][idnext];
//					temp = cArrTime - problem->node[idnext].eTW;
//					if (temp > eps)
//					{
//						vioTWCNEWi += temp;
//						if (vioTWCus[idnext] > eps)
//						{
//							varvioTWCi = vioTWCNEWi - FvioTWCus[idnext];
//							//varvioTWSPi = 0;
//							//if (previ <0) previ = assSPi;
//							varcosti = problem->c[previ][j] + problem->c[j][suci] - (problem->c[previ][i] + problem->c[i][suci]);
//							goto Updatej2;
//						}
//						cStartS = problem->node[idnext].depart;
//					}
//					else cStartS = PDS_MAX(problem->node[idnext].sTW, cArrTime) + problem->node[idnext].duration;
//					idcuri=idnext; idnext = nextArr[idcuri];
//				}
//				//dont change the last customer: idcuri now points to the last customer
//				varcosti = problem->c[previ][j] + problem->c[j][suci] - (problem->c[previ][i] + problem->c[i][suci]);
//				//cout<<"#j = "<<j<<"; i = "<<i<<"; "<<cStartS<<"; "<<varvioTWSPi<<"; ";
//				stop = calChangeCONNECTAtSP_PickTrip(idcuri, idVehi, idTripi, cStartS, varvioTWSPi, varcosti, vioTWSPTRUE);
//				//cout<<varvioTWSPi<<"; -- ";
//			}
//			else //change the last customer: j is now the last customer; i was the last customer
//			{
//				varcosti = problem->c[previ][j] - problem->c[previ][i];
//				if (seg[idVehi].Trip[idTripi].waitingS == NO_WS)
//					varcosti -= problem->c[i][assSPi];
//				else varcosti -= problem->disCWSSP[i][assSPi];
//				//cout<<"@j = "<<j<<"; i = "<<i<<"; "<<cStartS<<"; "<<varvioTWSPi<<"; ";
//				stop = calChangeCONNECTAtSP_PickTrip_LastCChanged(j, idVehi, idTripi, cStartS, varvioTWSPi, varcosti, vioTWSPTRUE);
//				//cout<<varvioTWSPi<<"; -- ";
//			}
//			varvioTWCi = vioTWCNEWi - seg[idVehi].Trip[idTripi].vioTWC;
//		}
//
//		if (stop == 0)
//		{
//			int nextT = idTripi + 1;
//			if (nextT < seg[idVehi].numTrips)
//			{
//				int firstC_nextT = seg[idVehi].Trip[nextT].firstCus;
//				if (seg[idVehi].Trip[nextT].Type == 1)
//				{
//					if (assSPi == seg[idVehi].Trip[nextT].assSP)
//					{
//						//varvioTWSPi *= 2; //already calculated at calChangeCONNECTAtSP_PickTrip/calChangeCONNECTAtSP_PickTrip_LastCChanged
//						//Update 16/11/2013
//						if (vioTWSPTRUE) cStartS = problem->leaveSP[assSPi][1]; //unload only at eTW2
//						else cStartS += problem->nodeSP[assSPi].load;
//						GoThroughVehicle(idVehi, nextT, varcosti, varvioTWCi, varvioTWSPi, cStartS, assSPi, firstC_nextT);
//					}
//					else //p - assSPi -- assSP1 - d
//					{
//						if (calChangeCONNECTAtSP_SPSP(idVehi, nextT, idTripi, cStartS, varvioTWSPi, varcosti) == 0)
//							GoThroughVehicle(idVehi, nextT, varcosti, varvioTWCi, varvioTWSPi, cStartS, seg[idVehi].Trip[nextT].assSP, firstC_nextT);
//					}
//				}
//				else // == 0 OR 2
//				{
//					GoThroughVehicle(idVehi, nextT, varcosti, varvioTWCi, varvioTWSPi, cStartS, assSPi, firstC_nextT);
//				}
//			}
//			//cout<<"CHANGED: "<<varvioTWSPi<<"...";
//		}
//		//else cout<<"NOTCHANGED: "<<varvioTWSPi<<"... ";
//
//
//	Updatej2:
//		if (idTripj == 0 && seg[idVehj].Trip[idTripj].numCus == 1)
//		{
//			varvioTWCj = 0; varvioTWSPj = 0;
//			varcostj = problem->c[0][i] - problem->c[0][j];
//			if (seg[idVehj].Trip[0].waitingS == NO_WS) varcostj -= problem->c[j][assSPj];
//			else varcostj -= problem->disCWSSP[j][assSPj];
//			//cStartS = problem->startSOneP[i][assSPj] + problem->node[i].duration;
//			if (problem->waitingSOneP[i][assSPj])
//			{
//				varcostj += problem->disCWSSP[i][assSPj];
//				//cStartS = PDS_MAX(cStartS + problem->disCWSSP[i][assSPj], problem->nodeSP[assSPj].sTW1);
//			}
//			else
//			{
//				varcostj += problem->c[i][assSPj];
//				//cStartS += problem->c[i][assSPj];
//			}
//			//cStartS += problem->nodeSP[assSPj].unload;
//			cStartS = problem->leaveSPOneP[i][assSPj];
//			if (PDSDIF(cStartS, seg[idVehj].Trip[0].leaveSP)==0) goto Update;
//			stop = 0;
//		}
//		else
//		{
//   			if (prevj > 0) {cStartS = depart[prevj]; vioTWCNEWj = FvioTWCus[prevj];}
//			else 
//			{
//				vioTWCNEWj = 0;
//				if (idTripj == 0)
//				{
//					prevj = 0;
//					cStartS = 0;
//				}
//				else
//				{
//					preTj = idTripj - 1;
//					if (seg[idVehj].Trip[preTj].Type == 0)
//					{
//						prevj = seg[idVehj].Trip[preTj].assSP;
//						cStartS = seg[idVehj].Trip[preTj].leaveSP;
//					}
//					else // == 1 OR 2
//					{
//						prevj = seg[idVehj].Trip[preTj].lastCus;
//						cStartS = depart[prevj];
//					}
//				}
//			}
//
//			cArrTime = cStartS + problem->c[prevj][i];
//			temp = cArrTime - problem->node[i].eTW;
//			if (temp > eps)
//			{
//				vioTWCNEWj += temp;
//				cStartS = problem->node[i].depart;
//			}
//			else cStartS = PDS_MAX(problem->node[i].sTW, cArrTime) + problem->node[i].duration;
//			
//			idcurj=i;
//			if (sucj > 0) //need to check TW till the end of the trip j
//			{
//				idnext = sucj;
//				while (idcurj != lastCusj) //check from suci till the end of the trip j
//				{
//					cArrTime = cStartS + problem->c[idcurj][idnext];
//					temp = cArrTime - problem->node[idnext].eTW;
//					if (temp > eps)
//					{
//						vioTWCNEWj += temp;
//						if (vioTWCus[idnext] > eps)
//						{
//							varvioTWCj = vioTWCNEWj - FvioTWCus[idnext];
//							//varvioTWSPj = 0;
//							//if (prevj <0) prevj = assSPj;
//							varcostj = problem->c[prevj][i] + problem->c[i][sucj] - (problem->c[prevj][j] + problem->c[j][sucj]);
//							goto Update;
//						}
//						cStartS = problem->node[idnext].depart;
//					}
//					else  cStartS = PDS_MAX(problem->node[idnext].sTW, cArrTime) + problem->node[idnext].duration;
//					idcurj=idnext; idnext = nextArr[idcurj];
//				}
//				//idcurj now points to the last customer; lastCustomer doesn't change
//				varcostj = problem->c[prevj][i] + problem->c[i][sucj] - (problem->c[prevj][j] + problem->c[j][sucj]);
//				stop = calChangeCONNECTAtSP_PickTrip(idcurj, idVehj, idTripj, cStartS, varvioTWSPj, varcostj, vioTWSPTRUE);
//			}
//			else //i is now the last customer; j was the last customer
//			{
//				varcostj = problem->c[prevj][i] - problem->c[prevj][j];
//				if (seg[idVehj].Trip[idTripj].waitingS == NO_WS)
//					varcostj -= problem->c[j][assSPj];
//				else varcostj -= problem->disCWSSP[j][assSPj];
//				stop = calChangeCONNECTAtSP_PickTrip_LastCChanged(i, idVehj, idTripj, cStartS, varvioTWSPj, varcostj, vioTWSPTRUE);
//			}//end //i is now the last customer; j was the last customer
//			varvioTWCj = vioTWCNEWj - seg[idVehj].Trip[idTripj].vioTWC;
//		}
//
//
//		if (stop == 0)
//		{
//			int nextT = idTripj + 1;
//			if (nextT < seg[idVehj].numTrips) //not the last trip:
//			{
//				int firstC_nextT = seg[idVehj].Trip[nextT].firstCus;
//				if (seg[idVehj].Trip[nextT].Type == 1) //nextT is delivery trip
//				{
//					if (assSPj == seg[idVehj].Trip[nextT].assSP) // p - assSPj - d
//					{
//						//varvioTWSPj *= 2; //already calculated at calChangeCONNECTAtSP_PickTrip/calChangeCONNECTAtSP_PickTrip_LastCChanged
//						//Update 16/11/2013
//						if (vioTWSPTRUE) cStartS = problem->leaveSP[assSPj][1]; //load only at eTW2
//						else cStartS += problem->nodeSP[assSPj].load;
//						GoThroughVehicle(idVehj, nextT, varcostj, varvioTWCj, varvioTWSPj, cStartS, assSPj, firstC_nextT);
//					}
//					else //p  - assSPj - assSP1 - d
//					{
//						if (calChangeCONNECTAtSP_SPSP(idVehj, nextT, idTripj, cStartS, varvioTWSPj, varcostj) == 0)
//							GoThroughVehicle(idVehj, nextT, varcostj, varvioTWCj, varvioTWSPj, cStartS, seg[idVehj].Trip[nextT].assSP, firstC_nextT);
//					}//end p  - assSPj - assSP1 - d
//				}
//				else //nextT is pickup trip OR C2C:
//				{
//					GoThroughVehicle(idVehj, nextT, varcostj, varvioTWCj, varvioTWSPj, cStartS, assSPj, firstC_nextT);
//				}//end nextT is pickup trip OR C2C
//			}
//		}
//	Update:
//		varvioTWC = varvioTWCi + varvioTWCj;
//		varvioTWSP = varvioTWSPi + varvioTWSPj;
//		int capi = seg[idVehi].Trip[idTripi].capacity - problem->node[i].capacity + problem->node[j].capacity;
//		int capj = seg[idVehj].Trip[idTripj].capacity - problem->node[j].capacity + problem->node[i].capacity;
//		int vioCapi = PDS_MAX(capi - problem->Q,0);
//		int vioCapj = PDS_MAX(capj - problem->Q,0);
//		varvioCAP = (vioCapi - seg[idVehi].Trip[idTripi].vioCAP) + (vioCapj - seg[idVehj].Trip[idTripj].vioCAP);
//	    varcost = varcosti + varcostj;
//
//		exchangeCus[j][k]->var_vioTWC = varvioTWC;
//		exchangeCus[j][k]->var_vioTWCi = varvioTWCi;
//		exchangeCus[j][k]->var_vioTWCj = varvioTWCj;
//    	exchangeCus[j][k]->var_vioTWSP = varvioTWSP;
//    	exchangeCus[j][k]->var_vioTWSPi = varvioTWSPi;
//    	exchangeCus[j][k]->var_vioTWSPj = varvioTWSPj;
//		exchangeCus[j][k]->var_vioCAP = varvioCAP;
//		exchangeCus[j][k]->var_cost = varcost;
//		exchangeCus[j][k]->var_costi = varcosti;
//		exchangeCus[j][k]->var_costj = varcostj;
//	}//end i and j are in the different vehicles
//}
//
//
//void Solution::cal_ExchangeCusC2CIAndJ(int j, int k)
//{
//	int i = problem->nodeC2C[j].neighborNodeExchange[k].id;
//	int cusDj = problem->node[j].delID;
//	int cusDi = problem->node[i].delID;
//	if (i >= problem->startidC2CD)
//	{
//		cout<<"ERROR: i = "<<i<<" is not c2cp"<<endl;cout<<"j = "<<j<<"; i is its "<<k<<" neighbors"<<endl;
//	    cout<<"C2CP id = "<<problem->startidC2C<<"... "<<problem->endidC2CP<<endl;
//	    cout<<"C2CD id = "<<problem->startidC2CD<<" ... "<<problem->endidC2C<<endl;
//	    exit(-1);
//	}
//	if (j < 0)
//	{
//		cout<<"j = "<<j<<endl;
//		exit(-1);
//	}
//
//    int prei, nexti, prej, nextj, pre_cusDi, pre_cusDj, next_cusDi, next_cusDj;
//
//    int idVehj = route_num[j]; int idTripj = trip_num[j];
//    int idVehi = route_num[i]; int idTripi = trip_num[i];
//
//	double varvioTWC, varvioTWSP=0, varcost; 
//	int varvioCAP,PRE, tQ,CapVehCus;
//	double cStartS, cArrTime,temp;
//	bool contCAP, contTW;
//
//
//    if (idVehi == idVehj)
//	{
//		if (idTripi == idTripj) // i and j are in the same trip:
//		{
//			int lastC = seg[idVehi].Trip[idTripi].lastCus;
//			int lastT = seg[idVehi].numTrips - 1;
//			int nextT = idTripi + 1;
//			int nextSP = seg[idVehi].Trip[idTripi].nextSP;
//			int idN = j;
//			if (pos[i] > pos[j])
//			{int tt=i;i=j;j=tt; tt= cusDi; cusDi = cusDj; cusDj = tt;} //swap i and j so that i is before j
//			
//			//if (nextArr[j]==i) return;
//			prei = predArr[i]; nexti = nextArr[i];
//			prej = predArr[j]; nextj = nextArr[j];
//			pre_cusDi = predArr[cusDi]; next_cusDi = nextArr[cusDi];
//			pre_cusDj = predArr[cusDj]; next_cusDj = nextArr[cusDj];
//			varvioCAP = -(vioCAPCus[i] + vioCAPCus[j] + vioCAPCus[cusDi] + vioCAPCus[cusDj]);
//			varvioTWC = - (vioTWCus[i] + vioTWCus[j] + vioTWCus[cusDi] + vioTWCus[cusDj]);
//			//if (print) cout<<"swap i and j, i = "<<i<<"; j ="<<j<<endl;
//
//			if (prei > 0) {cStartS = depart[prei];CapVehCus = CAPCus[prei];}
//			else 
//			{
//				CapVehCus = 0;
//				if (idTripi == 0)
//				{
//					prei = 0;
//					cStartS = 0; 
//				}
//				else
//				{
//					int preT = idTripi - 1;
//					if (seg[idVehi].Trip[preT].Type == 0)
//					{
//						prei = seg[idVehi].Trip[preT].assSP;
//						cStartS = seg[idVehi].Trip[preT].leaveSP;
//					}
//					else
//					{
//						prei = seg[idVehi].Trip[preT].lastCus;
//						cStartS = depart[prei];
//					}
//				}
//			}
//
//			//check TW till i:
//			//if (print) cout<<"check TW till i("<<i<<")"<<endl;
//			cArrTime = cStartS + problem->c[prei][j];
//			temp = cArrTime - problem->node[j].eTW;
//			if (temp > eps) 
//			{
//				varvioTWC += temp;
//				cStartS = problem->node[j].depart;
//			}
//			else cStartS = PDS_MAX(problem->node[j].sTW, cArrTime) + problem->node[j].duration;
//			CapVehCus += problem->node[j].capacity;
//			tQ = CapVehCus - Q;
//			if (tQ > 0) {CapVehCus = Q; varvioCAP += tQ;}
//			if (pos[cusDi] < pos[j]) // (CASE 1) before exchange: ..i..cusDi...j...cusDj....
//			{
//				//Checking from nexti ... pre_cusDi:
//				if (nexti != pre_cusDi) //1.1 i... cusDi
//				{
//					varcost = problem->c[prei][j] + problem->c[j][nexti] - problem->c[prei][i] - problem->c[i][nexti];
//					contCAP = 1; contTW = 1;
//				    GoThroughLegC2C(j,nexti,pre_cusDi,cStartS,CapVehCus,varvioCAP,varvioTWC,contCAP,contTW);
//					varcost += (problem->c[pre_cusDi][cusDj] - problem->c[pre_cusDi][cusDi]);
//					PRE = pre_cusDi;
//				}
//				else //else1.1 i,cusDi,...
//				{
//					varcost = problem->c[prei][j] + problem->c[j][cusDj] - (problem->c[prei][i] + problem->c[i][cusDi]);
//					PRE = j;
//				}
//				//Assign cusDj at place of cusDi:
//				cArrTime = cStartS + problem->c[PRE][cusDj];
//				temp = cArrTime - problem->node[cusDj].eTW;
//				if (temp > eps) 
//				{
//					varvioTWC += temp;
//					cStartS = problem->node[cusDj].depart;
//				}
//				else cStartS = PDS_MAX(problem->node[cusDj].sTW, cArrTime) + problem->node[cusDj].duration;
//				CapVehCus += problem->node[cusDj].capacity;
//				tQ = CapVehCus - Q;
//				if (tQ > 0) {CapVehCus = Q; varvioCAP += tQ;}
//
//				if (next_cusDi == j) //1.2   (i...cusDi),j.... OR (i,cusDi),j // before exchange: ..i..cusDi...j...cusDj....
//				{
//					varcost += (problem->c[cusDj][i] - problem->c[cusDi][j]);
//					PRE = cusDj;
//				}
//				else //next_cusDi != j: //1.2   (i...cusDi),next_cusDi,..,j.... OR (i,cusDi),next_cusDi,...,j... // before exchange: ..i..cusDi...j...cusDj....
//				{
//					varcost += (problem->c[cusDj][next_cusDi] - problem->c[cusDi][next_cusDi]);
//					contCAP = 1; contTW = 1;
//				    GoThroughLegC2C(cusDj,next_cusDi,prej,cStartS,CapVehCus,varvioCAP,varvioTWC,contCAP,contTW);
//					PRE = prej;
//				}
//				//Assign i at place of j:
//				cArrTime = cStartS + problem->c[PRE][i];
//				temp = cArrTime - problem->node[i].eTW;
//				if (temp > eps) 
//				{
//					varvioTWC += temp;
//					cStartS = problem->node[i].depart;
//				}
//				else cStartS = PDS_MAX(problem->node[i].sTW, cArrTime) + problem->node[i].duration;
//				CapVehCus += problem->node[i].capacity;
//				tQ = CapVehCus - Q;
//				if (tQ > 0) {CapVehCus = Q; varvioCAP += tQ;}
//				if (nextj != cusDj) //....(j,....,cusDj)...
//				{
//					varcost += (problem->c[i][nextj] - problem->c[j][nextj]);
//					contCAP = 1; contTW = 1;
//					GoThroughLegC2C(i,nextj,pre_cusDj,cStartS,CapVehCus,varvioCAP,varvioTWC,contCAP,contTW);
//					PRE = pre_cusDj;
//				}
//				else //nextj == cusDj: (i...cusDi)....(j,cusDj)... 
//				{
//					varcost += (problem->c[i][cusDi] - problem->c[j][cusDj]);
//					PRE = i;
//				}//end nextj == cusDj: (i...cusDi)....(j,cusDj)
//				//Assign cusDi at place of cusDj:
//				cArrTime = cStartS + problem->c[PRE][cusDi];
//				temp = cArrTime - problem->node[cusDi].eTW;
//				if (temp > eps) 
//				{
//					varvioTWC += temp;
//					cStartS = problem->node[cusDi].depart;
//				}
//				else cStartS = PDS_MAX(problem->node[cusDi].sTW, cArrTime) + problem->node[cusDi].duration;
//				CapVehCus += problem->node[cusDi].capacity;
//				tQ = CapVehCus - Q;
//				if (tQ > 0) {CapVehCus = Q; varvioCAP += tQ;}
//				if (next_cusDj > 0) //1.4 cusDj was not the last cus
//				{
//					varcost += (problem->c[cusDi][next_cusDj] - problem->c[cusDj][next_cusDj]);
//					//lastCus doesn't change:
//					if (idTripi == lastT)
//					{
//						GoThroughLegC2C(cusDi,next_cusDj,cStartS,varvioTWC,CapVehCus,varvioCAP);
//					}
//					else //not the last trip; lastCus doesn't change
//					{
//						if (nextSP > 0) //nextTrip is DTrip:
//						{
//						   if (GoThroughLegC2C(cusDi,next_cusDj,cStartS,varvioTWC,CapVehCus,varvioCAP) == 0) //depart lastC has changed
//						   {
//							  //int nextT = idTrip + 1;
//							  if (calChangeCONNECTAtSP_C2CTrip(lastC,idVehi,idTripi,nextT,cStartS,varvioTWSP,varcost) == 0) //seg[idVeh].Trip[nextT].leaveSP has changed
//								 GoThroughVehicle(idVehi,nextT,varcost,varvioTWC,varvioTWSP,cStartS,nextSP,seg[idVehi].Trip[nextT].firstCus);
//						   }
//						}
//						else //nextTrip is PTrip OR C2C:
//						{
//						   if (GoThroughLegC2C(cusDi,next_cusDj,cStartS,varvioTWC,CapVehCus,varvioCAP) == 0) //depart lastC has changed
//								GoThroughVehicle(idVehi,nextT,varcost,varvioTWC,varvioTWSP,cStartS,lastC,seg[idVehi].Trip[nextT].firstCus);
//						}
//					}//end //not the last trip; lastCus doesn't change
//				}
//				else //cusDi is now the last cus:
//				{
//					varcost -= seg[idVehi].Trip[idTripi].connectCost;
//                    if (idTripi == lastT)
//						varcost += problem->c[cusDi][0];
//					else //not the last trip:
//					{
//						if (nextSP > 0) //nextTrip is DTrip
//						{
//						    if (calChangeCONNECTAtSP_C2CTrip_LastCChanged(cusDi,idVehi,idTripi,nextT,cStartS,varvioTWSP,varcost) == 0)
//								 GoThroughVehicle(idVehi,nextT,varcost,varvioTWC,varvioTWSP,cStartS,nextSP,seg[idVehi].Trip[nextT].firstCus);
//						}
//						else //nextT is PTrip OR C2C
//						{
//							int firstC_nextT = seg[idVehi].Trip[nextT].firstCus;
//							varcost += problem->c[cusDi][firstC_nextT];
//							GoThroughVehicle(idVehi,nextT,varcost,varvioTWC,varvioTWSP,cStartS,cusDi,firstC_nextT);
//						}//end nextT is PTrip OR C2C
//					}//end not the last trip
//				}//end cusDi is now the last cus
//			}
//			else // (CASE 2) before exchange: ...i....j...cusDj...cusDi....
//			{
//				//Checking from nexti ... pre_j:
//				if (nexti != j) //2.1 i,...,j
//				{
//					varcost = problem->c[prei][j] + problem->c[j][nexti] - problem->c[prei][i] - problem->c[i][nexti];
//					contCAP = 1; contTW = 1;
//				    GoThroughLegC2C(j,nexti,prej,cStartS,CapVehCus,varvioCAP,varvioTWC,contCAP,contTW);
//					varcost += (problem->c[prej][i] - problem->c[prej][j]);
//					PRE = prej;
//				}
//				else //else2.1 i,j,...
//				{
//					varcost = problem->c[prei][j] - problem->c[prei][i];
//					PRE = j;
//				}
//				//Assign i at place of j:
//				cArrTime = cStartS + problem->c[PRE][i];
//				temp = cArrTime - problem->node[i].eTW;
//				if (temp > eps) 
//				{
//					varvioTWC += temp;
//					cStartS = problem->node[i].depart;
//				}
//				else cStartS = PDS_MAX(problem->node[i].sTW, cArrTime) + problem->node[i].duration;
//				CapVehCus += problem->node[i].capacity;
//				tQ = CapVehCus - Q;
//				if (tQ > 0) {CapVehCus = Q; varvioCAP += tQ;}
//				if (nextj == cusDj) //2.2 ...i...j,cusDj,....
//				{
//					varcost += (problem->c[i][cusDi] - problem->c[j][cusDj]);
//					//Assign cusDi at place of cusDj
//					PRE = i;
//
//				}
//				else //nextj != cusDj: //...i....j,....,cusDj,....
//				{
//					varcost += (problem->c[i][nextj] - problem->c[j][nextj] + problem->c[pre_cusDj][cusDi] - problem->c[pre_cusDj][cusDj]);
//					contCAP = 1; contTW = 1;
//					GoThroughLegC2C(i,nextj,pre_cusDj,cStartS,CapVehCus,varvioCAP,varvioTWC,contCAP,contTW);
//					PRE = pre_cusDj;
//				}//end nextj != cusDj
//				//Assign cusDi at place of cusDj:
//				cArrTime = cStartS + problem->c[PRE][cusDi];
//				temp = cArrTime - problem->node[cusDi].eTW;
//				if (temp > eps) 
//				{
//					varvioTWC += temp;
//					cStartS = problem->node[cusDi].depart;
//				}
//				else cStartS = PDS_MAX(problem->node[cusDi].sTW, cArrTime) + problem->node[cusDi].duration;
//				CapVehCus += problem->node[cusDi].capacity;
//				tQ = CapVehCus - Q;
//				if (tQ > 0) {CapVehCus = Q; varvioCAP += tQ;}
//				if (next_cusDj == cusDi) //2.3 i....j....cusDj,cusDi.....
//				{
//					//varcost += (problem->c[cusDi][cusDj]);
//					//Assign cusDj at place of cusDi
//					PRE = cusDi;
//				}
//				else //else2.3 i....j....cusDj....cusDi.....
//				{
//					varcost += (problem->c[cusDi][next_cusDj] - problem->c[cusDj][next_cusDj] + problem->c[pre_cusDi][cusDj] - problem->c[pre_cusDi][cusDi]);
//					contCAP = 1; contTW = 1;
//					GoThroughLegC2C(cusDi,next_cusDj,pre_cusDi,cStartS,CapVehCus,varvioCAP,varvioTWC,contCAP,contTW);
//					PRE = pre_cusDi;
//				}//end else2.3 
//				//Assign cusDj at place of cusDi:
//				cArrTime = cStartS + problem->c[PRE][cusDj];
//				temp = cArrTime - problem->node[cusDj].eTW;
//				if (temp > eps) 
//				{
//					varvioTWC += temp;
//					cStartS = problem->node[cusDj].depart;
//				}
//				else cStartS = PDS_MAX(problem->node[cusDj].sTW, cArrTime) + problem->node[cusDj].duration;
//				CapVehCus += problem->node[cusDj].capacity;
//				tQ = CapVehCus - Q;
//				if (tQ > 0) {CapVehCus = Q; varvioCAP += tQ;}
//				if (next_cusDi > 0) //lastCus doesn't change: i....j....cusDj....cusDi...
//				{
//					varcost += (problem->c[cusDj][next_cusDi] - problem->c[cusDi][next_cusDi]);
//					//lastCus doesn't change:
//					if (idTripi == lastT)
//					{
//						GoThroughLegC2C(cusDj,next_cusDi,cStartS,varvioTWC,CapVehCus,varvioCAP);
//					}
//					else //not the last trip; lastCus doesn't change
//					{
//						if (nextSP > 0) //nextTrip is DTrip:
//						{
//						   if (GoThroughLegC2C(cusDj,next_cusDi,cStartS,varvioTWC,CapVehCus,varvioCAP) == 0) //depart lastC has changed
//						   {
//							  //int nextT = idTrip + 1;
//							  if (calChangeCONNECTAtSP_C2CTrip(lastC,idVehi,idTripi,nextT,cStartS,varvioTWSP,varcost) == 0) //seg[idVeh].Trip[nextT].leaveSP has changed
//								 GoThroughVehicle(idVehi,nextT,varcost,varvioTWC,varvioTWSP,cStartS,nextSP,seg[idVehi].Trip[nextT].firstCus);
//						   }
//						}
//						else //nextTrip is PTrip OR C2C:
//						{
//						   if (GoThroughLegC2C(cusDj,next_cusDi,cStartS,varvioTWC,CapVehCus,varvioCAP) == 0) //depart lastC has changed
//								GoThroughVehicle(idVehi,nextT,varcost,varvioTWC,varvioTWSP,cStartS,lastC,seg[idVehi].Trip[nextT].firstCus);
//						}
//					}//end //not the last trip; lastCus doesn't change
//				}
//				else //cusDj is now the last cus:
//				{
//					varcost -= seg[idVehi].Trip[idTripi].connectCost;
//                    if (idTripi == lastT)
//						varcost += problem->c[cusDj][0];
//					else //not the last trip:
//					{
//						if (nextSP > 0) //nextTrip is DTrip
//						{
//						    if (calChangeCONNECTAtSP_C2CTrip_LastCChanged(cusDj,idVehi,idTripi,nextT,cStartS,varvioTWSP,varcost) == 0)
//								 GoThroughVehicle(idVehi,nextT,varcost,varvioTWC,varvioTWSP,cStartS,nextSP,seg[idVehi].Trip[nextT].firstCus);
//						}
//						else //nextT is PTrip OR C2C
//						{
//							int firstC_nextT = seg[idVehi].Trip[nextT].firstCus;
//							varcost += problem->c[cusDj][firstC_nextT];
//							GoThroughVehicle(idVehi,nextT,varcost,varvioTWC,varvioTWSP,cStartS,cusDj,firstC_nextT);
//						}//end nextT is PTrip OR C2C
//					}//end not the last trip
//				}//end cusDj is now the last cus
//			}//END (CASE 2) before exchange: ...i....j...cusDj...cusDi....
//			exchangeCus[idN][k]->var_vioTWC = varvioTWC;
//			exchangeCus[idN][k]->var_vioTWSP = varvioTWSP;
//			exchangeCus[idN][k]->var_vioCAP = varvioCAP;
//			exchangeCus[idN][k]->var_cost = varcost;
//		}
//		else // i and j are in the same vehicle, but different trips
//		{
//				double varvioTWCi, varvioTWCj, varvioTWSPi = 0, varvioTWSPj = 0;
//				int varvioCAPi, varvioCAPj;
//				double varcosti, varcostj,  startS_CHANGE_at_idTripi = 0; 
//				int idN = j;
//				if (idTripi > idTripj) 
//				{
//					int tt=i;i=j;j=tt;
//					tt= cusDi; cusDi = cusDj; cusDj = tt;
//					tt = idTripi; idTripi = idTripj; idTripj = tt;
//				} //swap i and j so that i is before j
//
//
//				int numTrips = idTripj-idTripi - 1;
//				prei = predArr[i]; nexti = nextArr[i];
//				prej = predArr[j]; nextj = nextArr[j];
//				pre_cusDi = predArr[cusDi]; next_cusDi = nextArr[cusDi];
//				pre_cusDj = predArr[cusDj]; next_cusDj = nextArr[cusDj];
//
//				int preTj = idTripj - 1; int nextTi = idTripi + 1;
//				int lastCj = seg[idVehj].Trip[idTripj].lastCus;
//				int lastCi = seg[idVehi].Trip[idTripi].lastCus;
//				int nextSPi = seg[idVehi].Trip[idTripi].nextSP;
//				int nextSPj = seg[idVehj].Trip[idTripj].nextSP;
//
//				if (idTripi == 0 && seg[idVehi].Trip[idTripi].numCus == 2 && nextSPi > 0)
//				{
//					varvioTWCi = 0; varvioCAPi = 0;
//					varcosti = problem->c[0][j] + problem->c[j][cusDj] - seg[idVehi].Trip[idTripi].cost;
//					if (problem->waitingSOneP[j][nextSPi])
//						varcosti += problem->disCWSSP[cusDj][nextSPi];
//					else varcosti += problem->c[cusDj][nextSPi];
//					cStartS = problem->leaveSPOneP[j][nextSPi];
//					if (PDSDIF(cStartS, seg[idVehi].Trip[0].leaveSP)==0) 
//					{
//						if (seg[idVehi].Trip[preTj].Type == 0) //PTrip
//							 cStartS = seg[idVehi].Trip[preTj].leaveSP;
//						else cStartS = seg[idVehi].Trip[preTj].endS;
//					}
//					else{
//						//GoThroughVehicle(idVehi,1, numTrips,varcosti,varvioTWCi,varvioTWSPi,cStartS,nextSPi,seg[idVehi].Trip[1].firstCus);
//					}
//				}
//				else
//				{
//					varvioTWCi = -(vioTWCus[i] + vioTWCus[cusDi]);
//					varvioCAPi = -(vioCAPCus[i] + vioCAPCus[cusDi]);
//					if (prei > 0) {cStartS = depart[prei]; CapVehCus = CAPCus[prei];}
//					else 
//					{
//					    CapVehCus = 0;
//						if (idTripi == 0)
//						{
//						   prei = 0;
//						   cStartS = 0;
//						}
//						else
//						{
//							int preTi = idTripi - 1;
//							if (seg[idVehi].Trip[preTi].Type == 0)
//							{
//								prei = seg[idVehi].Trip[preTi].assSP;
//								cStartS = seg[idVehi].Trip[preTi].leaveSP;
//							}
//							else // == 1 OR 2
//							{
//								prei = seg[idVehi].Trip[preTi].lastCus;
//								cStartS = depart[prei];
//							}
//						}
//					}
//					//Assign j at place of i:
//					cArrTime = cStartS + problem->c[prei][j];
//					temp = cArrTime - problem->node[j].eTW;
//					if (temp > eps)
//					{
//						varvioTWCi += temp;
//						cStartS = problem->node[j].depart;
//					}
//					else cStartS = PDS_MAX(problem->node[j].sTW, cArrTime) + problem->node[j].duration;
//					CapVehCus += problem->node[j].capacity;
//					tQ = CapVehCus - Q;
//					if (tQ > 0) {CapVehCus = Q; varvioCAPi += tQ;}
//					if (nexti == cusDi)
//					{
//						//....i,cusDi,....
//						varcosti = (problem->c[prei][j] - problem->c[prei][i]) + (problem->c[j][cusDj] - problem->c[i][cusDi]);
//						//Assign cusDj at place of cusDi:
//						PRE = j;
//					}
//					else //nexti != cusDi
//					{
//						//....i....,cusDi....
//						varcosti = (problem->c[prei][j] - problem->c[prei][i]) + (problem->c[j][nexti] - problem->c[i][nexti]) + (problem->c[pre_cusDi][cusDj] - problem->c[pre_cusDi][cusDi]);
//						contCAP = 1; contTW = 1;
//						GoThroughLegC2C(j,nexti,pre_cusDi,cStartS,CapVehCus,varvioCAPi,varvioTWCi,contCAP,contTW);
//						PRE = pre_cusDi;
//					}//end nexti != cusDi
//					//Assign cusDj at place of cusDi:
//					cArrTime = cStartS + problem->c[PRE][cusDj];
//					temp = cArrTime - problem->node[cusDj].eTW;
//					if (temp > eps)
//					{
//						varvioTWCi += temp;
//						cStartS = problem->node[cusDj].depart;
//					}
//					else cStartS = PDS_MAX(problem->node[cusDj].sTW, cArrTime) + problem->node[cusDj].duration;
//					CapVehCus += problem->node[cusDj].capacity;
//					tQ = CapVehCus - Q;
//					if (tQ > 0) {CapVehCus = Q; varvioCAPi += tQ;}
//        			if (next_cusDi > 0) //lastCus doesnt change
//					{
//						varcosti += (problem->c[cusDj][next_cusDi] - problem->c[cusDi][next_cusDi]);
//						//lastCus doesn't change:
//						if (nextSPi > 0) //nextTrip is DTrip:
//						{
//						   if (GoThroughLegC2C(cusDj,next_cusDi,cStartS,varvioTWCi,CapVehCus,varvioCAPi) == 0) //depart lastC has changed
//						   {
//							  if (calChangeCONNECTAtSP_C2CTrip(lastCi,idVehi,idTripi,nextTi,cStartS,varvioTWSPi,varcosti) == 0){ //seg[idVeh].Trip[nextT].leaveSP has changed
//								  //Quangnn+-
//									// GoThroughVehicle(idVehi,nextTi,numTrips,varcosti,varvioTWCi,varvioTWSPi,cStartS,nextSPi,seg[idVehi].Trip[nextTi].firstCus);
//							  }
//						   }
//						}
//						else //nextTrip is PTrip OR C2C:
//						{
//						   if (GoThroughLegC2C(cusDj,next_cusDi,cStartS,varvioTWCi,CapVehCus,varvioCAPi) == 0) //depart lastC has changed
//								if (idTripi != preTj){
//									//Quangnn+-
//									//GoThroughVehicle(idVehi,nextTi,numTrips,varcosti,varvioTWCi,varvioTWSPi,cStartS,lastCi,seg[idVehi].Trip[nextTi].firstCus);
//								}
//						}
//					}
//					else //cusDi was the last cus--> cusDj is now the last cus
//					{
//						varcosti -= seg[idVehi].Trip[idTripi].connectCost;
//						if (nextSPi > 0)
//						{
//							if (calChangeCONNECTAtSP_C2CTrip_LastCChanged(cusDj,idVehi,idTripi,nextTi,cStartS,varvioTWSPi,varcosti) == 0){
//								//Quangnn+-
//								//GoThroughVehicle(idVehi,nextTi,numTrips,varcosti,varvioTWCi,varvioTWSPi,cStartS,nextSPi,seg[idVehi].Trip[nextTi].firstCus);
//							}
//						}
//						else //nextT is PTrip OR C2C
//						{
//							if (idTripi != preTj)
//							{
//								int firstC_nextT = seg[idVehi].Trip[nextTi].firstCus;
//								varcosti += problem->c[cusDj][firstC_nextT];
//								//Quangnn+-
//								//GoThroughVehicle(idVehi,nextTi,numTrips,varcosti,varvioTWCi,varvioTWSPi,cStartS,cusDj,firstC_nextT);
//							}
//						}//end nextT is PTrip OR C2C
//					}//end cusDi was the last cus--> cusDj is now the last cus
//				}
//			
//				//2.2. WORKING on idTripj: assign i at place of j and assign cusDi at place of cusDj: for sure idTripj > 0
//				varvioTWCj = -(vioTWCus[j] + vioTWCus[cusDj]);
//				varvioCAPj = -(vioCAPCus[j] + vioCAPCus[cusDj]);
//				
//				int firstCj = seg[idVehj].Trip[idTripj].firstCus;
//				int lastTj = seg[idVehj].numTrips - 1;
//				int nextTj = idTripj + 1;
//				if (idTripi == preTj)
//				{
//					if (cusDi == lastCi)
//					{
//						if (j == firstCj) //CASE 1: cusDi is the last cus of idTripi; j is the first cus of idTripj; idTripi + 1= idTripj
//						{
//							varcosti += problem->c[cusDj][i];
//							prej = cusDj; CapVehCus = 0;
//						}
//						else //CASE 2: cusDi is the last cus of idTripi; j is not the first cus of idTripj; idTripi + 1= idTripj
//						{
//							varcosti += problem->c[cusDj][firstCj];
//							contCAP = 1; contTW = 1; CapVehCus = 0;
//							//Quangnn+-
//							//GoThroughLegC2C(cusDj,firstCj,prej,cStartS,CapVehCus,varvioCAPj,varvioTWCj,contCAP,contTW);
//						}
//					}
//					else //cusDi is not the last cus of idTripi
//					{
//						if (j == firstCj) //CASE 3: cusDi is not the last cus of idTripi; j is the first cus of idTripj; idTripi + 1=idTripj
//						{
//							varcosti += (problem->c[lastCi][i] - seg[idVehi].Trip[idTripi].connectCost);
//							prej = lastCi; CapVehCus = 0;
//						}
//						else //CASE 4: cusDi is not the last cus of idTripi, j is not the first cus of idTripj; idTripi + 1 = idTirpj
//						{
//							contCAP = 1; contTW = 1; CapVehCus = 0;
//							//Quangnn+-
//							//GoThroughLegC2C(lastCi,firstCj,prej,cStartS,CapVehCus,varvioCAPj,varvioTWCj,contCAP,contTW);
//						}
//					}//end cusDi is not the last cus of idTripi
//				}
//				else //idTripi != preTj
//				{
//					if (prej > 0)
//					{
//						contCAP = 1; contTW = 1; CapVehCus = 0;
//						if (seg[idVehj].Trip[preTj].Type == 0){
//						  //Quangnn+-
//							//GoThroughLegC2C(seg[idVehi].Trip[preTj].assSP,firstCj,prej,cStartS,CapVehCus,varvioCAPj,varvioTWCj,contCAP,contTW);
//						}
//						else
//						  GoThroughLegC2C(seg[idVehi].Trip[preTj].lastCus,firstCj,prej,cStartS,CapVehCus,varvioCAPj,varvioTWCj,contCAP,contTW);
//					}
//					else 
//					{
//					    CapVehCus = 0;
//						if (seg[idVehj].Trip[preTj].Type == 0)
//							prej = seg[idVehi].Trip[preTj].assSP;
//						else // == 1 OR 2
//							prej = seg[idVehj].Trip[preTj].lastCus;
//					}
//				}
//				//Assign i at place of j:
//				cArrTime = cStartS + problem->c[prej][i];
//				temp = cArrTime - problem->node[i].eTW;
//				if (temp > eps)
//				{
//					varvioTWCj += temp;
//					cStartS = problem->node[i].depart;
//				}
//				else cStartS = PDS_MAX(problem->node[i].sTW, cArrTime) + problem->node[i].duration;
//				CapVehCus += problem->node[i].capacity;
//				tQ = CapVehCus - Q;
//				if (tQ > 0) {CapVehCus = Q; varvioCAPj += tQ;}
//				if (nextj == cusDj)
//				{
//					//....j,cusDj,....
//					varcostj = (problem->c[prej][i] - problem->c[prej][j]) + (problem->c[i][cusDi] - problem->c[j][cusDj]);
//					//Assign cusDi at place of cusDj:
//					PRE = i;
//				}
//				else //nextj != cusDj
//				{
//					//....j....,cusDj....
//					varcostj = (problem->c[prej][i] - problem->c[prej][j]) + (problem->c[i][nextj] - problem->c[j][nextj]) + (problem->c[pre_cusDj][cusDi] - problem->c[pre_cusDj][cusDj]);
//					contCAP = 1; contTW = 1;
//					GoThroughLegC2C(i,nextj,pre_cusDj,cStartS,CapVehCus,varvioCAPj,varvioTWCj,contCAP,contTW);
//					PRE = pre_cusDj;
//				}//end nextj != cusDj
//				//Assign cusDi at place of cusDj:
//				cArrTime = cStartS + problem->c[PRE][cusDi];
//				temp = cArrTime - problem->node[cusDi].eTW;
//				if (temp > eps)
//				{
//					varvioTWCj += temp;
//					cStartS = problem->node[cusDi].depart;
//				}
//				else cStartS = PDS_MAX(problem->node[cusDi].sTW, cArrTime) + problem->node[cusDi].duration;
//				CapVehCus += problem->node[cusDi].capacity;
//				tQ = CapVehCus - Q;
//				if (tQ > 0) {CapVehCus = Q; varvioCAPj += tQ;}
//				if (next_cusDj > 0) //lastCus doesnt change
//				{
//					varcostj += (problem->c[cusDi][next_cusDj] - problem->c[cusDj][next_cusDj]);
//					//lastCus doesn't change:
//					if (idTripj == lastTj)
//					{
//						GoThroughLegC2C(cusDi,next_cusDj,cStartS,varvioTWCj,CapVehCus,varvioCAPj);
//					}
//					else //not the last trip; lastCus doesn't change
//					{
//							if (nextSPj > 0) //nextTrip is DTrip:
//							{
//							   if (GoThroughLegC2C(cusDi,next_cusDj,cStartS,varvioTWCj,CapVehCus,varvioCAPj) == 0) //depart lastC has changed
//							   {
//								  if (calChangeCONNECTAtSP_C2CTrip(lastCj,idVehj,idTripj,nextTj,cStartS,varvioTWSPj,varcostj) == 0) //seg[idVeh].Trip[nextT].leaveSP has changed
//									 GoThroughVehicle(idVehj,nextTj,varcostj,varvioTWCj,varvioTWSPj,cStartS,nextSPj,seg[idVehj].Trip[nextTj].firstCus);
//							   }
//							}
//							else //nextTrip is PTrip OR C2C:
//							{
//							   if (GoThroughLegC2C(cusDi,next_cusDj,cStartS,varvioTWCj,CapVehCus,varvioCAPj) == 0) //depart lastC has changed
//									GoThroughVehicle(idVehj,nextTj,varcostj,varvioTWCj,varvioTWSPj,cStartS,lastCj,seg[idVehj].Trip[nextTj].firstCus);
//							}
//					}//end //not the last trip; lastCus doesn't change
//				}
//				else //cusDj was the last cus--> cusDi is now the last cus
//				{
//					varcostj -= seg[idVehj].Trip[idTripj].connectCost;
//					if (idTripj == lastTj) varcostj += problem->c[cusDi][0];
//					else
//					{
//						if (nextSPj > 0)
//						{
//							if (calChangeCONNECTAtSP_C2CTrip_LastCChanged(cusDi,idVehj,idTripj,nextTj,cStartS,varvioTWSPj,varcostj) == 0)
//								GoThroughVehicle(idVehj,nextTj,varcostj,varvioTWCj,varvioTWSPj,cStartS,nextSPj,seg[idVehj].Trip[nextTj].firstCus);
//						}
//						else //nextT is PTrip OR C2C
//						{
//							int firstC_nextT = seg[idVehj].Trip[nextTj].firstCus;
//							varcostj += problem->c[cusDi][firstC_nextT];
//							GoThroughVehicle(idVehj,nextTj,varcostj,varvioTWCj,varvioTWSPj,cStartS,cusDi,firstC_nextT);
//						}//end nextT is PTrip OR C2C
//					}
//				}//end cusDj was the last cus--> cusDi is now the last cus
//				varvioTWC = varvioTWCi + varvioTWCj;
//				varvioTWSP = varvioTWSPi + varvioTWSPj;
//				varvioCAP = varvioCAPi + varvioCAPj;
//				varcost = varcosti + varcostj;
//
//				exchangeCus[idN][k]->var_vioTWC = varvioTWC;
//				exchangeCus[idN][k]->var_vioTWCi = varvioTWCi;
//				exchangeCus[idN][k]->var_vioTWCj = varvioTWCj;
//    			exchangeCus[idN][k]->var_vioTWSP = varvioTWSP;
//    			exchangeCus[idN][k]->var_vioTWSPi = varvioTWSPi;
//    			exchangeCus[idN][k]->var_vioTWSPj = varvioTWSPj;
//				exchangeCus[idN][k]->var_vioCAP = varvioCAP;
//				exchangeCus[idN][k]->var_cost = varcost;
//				exchangeCus[idN][k]->var_costi = varcosti;
//				exchangeCus[idN][k]->var_costj = varcostj;
//		}//end i and j are in the same vehicle, but different trips
//	}
//	else // i and j are in the different vehicles:
//	{
//        double varvioTWCi = 0, varvioTWCj = 0, varvioTWSPi =0, varvioTWSPj = 0;
//		double varcosti, varcostj; 
//		int varvioCAPi, varvioCAPj;
//		prei = predArr[i]; nexti = nextArr[i];
//		prej = predArr[j]; nextj = nextArr[j];
//		pre_cusDi = predArr[cusDi]; next_cusDi = nextArr[cusDi];
//		pre_cusDj = predArr[cusDj]; next_cusDj = nextArr[cusDj];
//
//		int lastCj = seg[idVehj].Trip[idTripj].lastCus;
//		int lastCi = seg[idVehi].Trip[idTripi].lastCus;
//		int nextSPi = seg[idVehi].Trip[idTripi].nextSP;
//		int nextSPj = seg[idVehj].Trip[idTripj].nextSP;
//		int nextTi = idTripi + 1; int lastTi = seg[idVehi].numTrips - 1;
//		if (idTripi == 0 && seg[idVehi].Trip[idTripi].numCus == 2 && nextSPi > 0)
//		{
//			varvioTWCi = 0; varvioCAPi = 0;
//			varcosti = problem->c[0][j] + problem->c[j][cusDj] - seg[idVehi].Trip[idTripi].cost;
//			if (problem->waitingSOneP[j][nextSPi])
//				varcosti += problem->disCWSSP[cusDj][nextSPi];
//			else varcosti += problem->c[cusDj][nextSPi];
//			cStartS = problem->leaveSPOneP[j][nextSPi];
//			if (PDSDIF(cStartS, seg[idVehi].Trip[0].leaveSP)) 
//				GoThroughVehicle(idVehi,1,varcosti,varvioTWCi,varvioTWSPi,cStartS,nextSPi,seg[idVehi].Trip[1].firstCus);
//		}
//		else
//		{
//			varvioTWCi = -(vioTWCus[i] + vioTWCus[cusDi]);
//			varvioCAPi = -(vioCAPCus[i] + vioCAPCus[cusDi]);
//			if (prei > 0) {cStartS = depart[prei]; CapVehCus = CAPCus[prei];}
//			else 
//			{
//			   CapVehCus = 0;
//				if (idTripi == 0)
//				{
//				   prei = 0;
//				   cStartS = 0;
//				}
//				else
//				{
//					int preTi = idTripi - 1;
//					if (seg[idVehi].Trip[preTi].Type == 0)
//					{
//						prei = seg[idVehi].Trip[preTi].assSP;
//						cStartS = seg[idVehi].Trip[preTi].leaveSP;
//					}
//					else // == 1 OR 2
//					{
//						prei = seg[idVehi].Trip[preTi].lastCus;
//						cStartS = depart[prei];
//					}
//				}
//			}
//
//			//Assign j at place of i:
//			cArrTime = cStartS + problem->c[prei][j];
//			temp = cArrTime - problem->node[j].eTW;
//			if (temp > eps)
//			{
//				varvioTWCi += temp;
//				cStartS = problem->node[j].depart;
//			}
//			else cStartS = PDS_MAX(problem->node[j].sTW, cArrTime) + problem->node[j].duration;
//			CapVehCus += problem->node[j].capacity;
//			tQ = CapVehCus - Q;
//			if (tQ > 0) {CapVehCus = Q; varvioCAPi += tQ;}
//
//			if (nexti == cusDi)
//			{
//				//....i,cusDi,....
//				varcosti = (problem->c[prei][j] - problem->c[prei][i]) + (problem->c[j][cusDj] - problem->c[i][cusDi]);
//				//Assign cusDj at place of cusDi:
//				PRE = j;
//			}
//			else //nexti != cusDi
//			{
//				//....i....,cusDi....
//				varcosti = (problem->c[prei][j] - problem->c[prei][i]) + (problem->c[j][nexti] - problem->c[i][nexti]) + (problem->c[pre_cusDi][cusDj] - problem->c[pre_cusDi][cusDi]);
//				contCAP = 1; contTW = 1;
//				GoThroughLegC2C(j,nexti,pre_cusDi,cStartS,CapVehCus,varvioCAPi,varvioTWCi,contCAP,contTW);
//				PRE = pre_cusDi;
//			}//end nexti != cusDi
//			//Assign cusDj at place of cusDi:
//			cArrTime = cStartS + problem->c[PRE][cusDj];
//			temp = cArrTime - problem->node[cusDj].eTW;
//			if (temp > eps)
//			{
//				varvioTWCi += temp;
//				cStartS = problem->node[cusDj].depart;
//			}
//			else cStartS = PDS_MAX(problem->node[cusDj].sTW, cArrTime) + problem->node[cusDj].duration;
//			CapVehCus += problem->node[cusDj].capacity;
//			tQ = CapVehCus - Q;
//			if (tQ > 0) {CapVehCus = Q; varvioCAPi += tQ;}
//			if (next_cusDi > 0) //lastCus doesnt change
//			{
//				varcosti += (problem->c[cusDj][next_cusDi] - problem->c[cusDi][next_cusDi]);
//				//lastCus doesn't change:
//				if (idTripi == lastTi)
//				{
//					GoThroughLegC2C(cusDj,next_cusDi,cStartS,varvioTWCi,CapVehCus,varvioCAPi);
//				}
//				else //not the last trip; lastCus doesn't change
//				{
//						if (nextSPi > 0) //nextTrip is DTrip:
//						{
//						   if (GoThroughLegC2C(cusDj,next_cusDi,cStartS,varvioTWCi,CapVehCus,varvioCAPi) == 0) //depart lastC has changed
//						   {
//							  if (calChangeCONNECTAtSP_C2CTrip(lastCi,idVehi,idTripi,nextTi,cStartS,varvioTWSPi,varcosti) == 0) //seg[idVeh].Trip[nextT].leaveSP has changed
//								 GoThroughVehicle(idVehi,nextTi,varcosti,varvioTWCi,varvioTWSPi,cStartS,nextSPi,seg[idVehi].Trip[nextTi].firstCus);
//						   }
//						}
//						else //nextTrip is PTrip OR C2C:
//						{
//						   if (GoThroughLegC2C(cusDj,next_cusDi,cStartS,varvioTWCi,CapVehCus,varvioCAPi) == 0) //depart lastC has changed
//								GoThroughVehicle(idVehi,nextTi,varcosti,varvioTWCi,varvioTWSPi,cStartS,lastCi,seg[idVehi].Trip[nextTi].firstCus);
//						}
//				}//end //not the last trip; lastCus doesn't change
//			}
//			else //cusDi was the last cus--> cusDj is now the last cus
//			{
//				varcosti -= seg[idVehi].Trip[idTripi].connectCost;
//				if (idTripi == lastTi) varcosti += problem->c[cusDj][0];
//				else
//				{
//					if (nextSPi > 0)
//					{
//					    if (calChangeCONNECTAtSP_C2CTrip_LastCChanged(cusDj,idVehi,idTripi,nextTi,cStartS,varvioTWSPi,varcosti) == 0)
//							GoThroughVehicle(idVehi,nextTi,varcosti,varvioTWCi,varvioTWSPi,cStartS,nextSPi,seg[idVehi].Trip[nextTi].firstCus);
//					}
//					else //nextT is PTrip OR C2C
//					{
//						int firstC_nextT = seg[idVehi].Trip[nextTi].firstCus;
//						varcosti += problem->c[cusDj][firstC_nextT];
//						GoThroughVehicle(idVehi,nextTi,varcosti,varvioTWCi,varvioTWSPi,cStartS,cusDj,firstC_nextT);
//					}//end nextT is PTrip OR C2C
//				}
//			}//end cusDi was the last cus--> cusDj is now the last cus
//		}
//
//		//WORK on (idVehj,idTripj): assign (i,cusDi) at place of (j,cusDj) respectively: [case dif vehicles)
//		if (idTripj == 0 && seg[idVehj].Trip[idTripj].numCus == 2 && nextSPj > 0)
//		{
//			varvioTWCj = 0; varvioCAPj = 0;
//			varcostj = problem->c[0][i] + problem->c[i][cusDi] - seg[idVehj].Trip[idTripj].cost;
//			if (problem->waitingSOneP[i][nextSPj])
//				varcostj += problem->disCWSSP[cusDi][nextSPj];
//			else varcostj += problem->c[cusDi][nextSPj];
//			cStartS = problem->leaveSPOneP[i][nextSPj];
//			if (PDSDIF(cStartS, seg[idVehj].Trip[0].leaveSP)==1) 
//				GoThroughVehicle(idVehj,1,varcostj,varvioTWCj,varvioTWSPj,cStartS,nextSPj,seg[idVehj].Trip[1].firstCus);
//		}
//		else
//		{
//			varvioTWCj = -(vioTWCus[j] + vioTWCus[cusDj]);
//			varvioCAPj = -(vioCAPCus[j] + vioCAPCus[cusDj]);
//			int lastTj = seg[idVehj].numTrips - 1;
//			int nextTj = idTripj + 1;
//			if (prej > 0) {cStartS = depart[prej]; CapVehCus = CAPCus[prej];}
//			else 
//			{
//			   CapVehCus = 0;
//				if (idTripj == 0)
//				{
//				   prej = 0;
//				   cStartS = 0;
//				}
//				else
//				{
//					int preTj = idTripj - 1;
//					if (seg[idVehj].Trip[preTj].Type == 0)
//					{
//						prej = seg[idVehi].Trip[preTj].assSP;
//						cStartS = seg[idVehj].Trip[preTj].leaveSP;
//					}
//					else // == 1 OR 2
//					{
//						prej = seg[idVehj].Trip[preTj].lastCus;
//						cStartS = depart[prej];
//					}
//				}
//			}
//
//			//Assign i at place of j:
//			cArrTime = cStartS + problem->c[prej][i];
//			temp = cArrTime - problem->node[i].eTW;
//			if (temp > eps)
//			{
//				varvioTWCj += temp;
//				cStartS = problem->node[i].depart;
//			}
//			else cStartS = PDS_MAX(problem->node[i].sTW, cArrTime) + problem->node[i].duration;
//			CapVehCus += problem->node[i].capacity;
//			tQ = CapVehCus - Q;
//			if (tQ > 0) {CapVehCus = Q; varvioCAPj += tQ;}
//
//			if (nextj == cusDj)
//			{
//				//....j,cusDj,....
//				varcostj = (problem->c[prej][i] - problem->c[prej][j]) + (problem->c[i][cusDi] - problem->c[j][cusDj]);
//				//Assign cusDi at place of cusDj:
//				PRE = i;
//			}
//			else //nextj != cusDj
//			{
//				//....j....,cusDj....
//				varcostj = (problem->c[prej][i] - problem->c[prej][j]) + (problem->c[i][nextj] - problem->c[j][nextj]) + (problem->c[pre_cusDj][cusDi] - problem->c[pre_cusDj][cusDj]);
//				contCAP = 1; contTW = 1;
//				GoThroughLegC2C(i,nextj,pre_cusDj,cStartS,CapVehCus,varvioCAPj,varvioTWCj,contCAP,contTW);
//				PRE = pre_cusDj;
//			}//end nextj != cusDj
//			//Assign cusDi at place of cusDj:
//			cArrTime = cStartS + problem->c[PRE][cusDi];
//			temp = cArrTime - problem->node[cusDi].eTW;
//			if (temp > eps)
//			{
//				varvioTWCj += temp;
//				cStartS = problem->node[cusDi].depart;
//			}
//			else cStartS = PDS_MAX(problem->node[cusDi].sTW, cArrTime) + problem->node[cusDi].duration;
//			CapVehCus += problem->node[cusDi].capacity;
//			tQ = CapVehCus - Q;
//			if (tQ > 0) {CapVehCus = Q; varvioCAPj += tQ;}
//			if (next_cusDj > 0) //lastCus doesnt change
//			{
//				varcostj += (problem->c[cusDi][next_cusDj] - problem->c[cusDj][next_cusDj]);
//				//lastCus doesn't change:
//				if (idTripj == lastTj)
//				{
//					GoThroughLegC2C(cusDi,next_cusDj,cStartS,varvioTWCj,CapVehCus,varvioCAPj);
//				}
//				else //not the last trip; lastCus doesn't change
//				{
//						if (nextSPj > 0) //nextTrip is DTrip:
//						{
//						   if (GoThroughLegC2C(cusDi,next_cusDj,cStartS,varvioTWCj,CapVehCus,varvioCAPj) == 0) //depart lastC has changed
//						   {
//							  if (calChangeCONNECTAtSP_C2CTrip(lastCj,idVehj,idTripj,nextTj,cStartS,varvioTWSPj,varcostj) == 0) //seg[idVeh].Trip[nextT].leaveSP has changed
//								 GoThroughVehicle(idVehj,nextTj,varcostj,varvioTWCj,varvioTWSPj,cStartS,nextSPj,seg[idVehj].Trip[nextTj].firstCus);
//						   }
//						}
//						else //nextTrip is PTrip OR C2C:
//						{
//						   if (GoThroughLegC2C(cusDi,next_cusDj,cStartS,varvioTWCj,CapVehCus,varvioCAPj) == 0) //depart lastC has changed
//								GoThroughVehicle(idVehj,nextTj,varcostj,varvioTWCj,varvioTWSPj,cStartS,lastCj,seg[idVehj].Trip[nextTj].firstCus);
//						}
//				}//end //not the last trip; lastCus doesn't change
//			}
//			else //cusDj was the last cus--> cusDi is now the last cus
//			{
//				varcostj -= seg[idVehj].Trip[idTripj].connectCost;
//				if (idTripj == lastTj) varcostj += problem->c[cusDi][0];
//				else
//				{
//					if (nextSPj > 0)
//					{
//					    if (calChangeCONNECTAtSP_C2CTrip_LastCChanged(cusDi,idVehj,idTripj,nextTj,cStartS,varvioTWSPj,varcostj) == 0)
//							GoThroughVehicle(idVehj,nextTj,varcostj,varvioTWCj,varvioTWSPj,cStartS,nextSPj,seg[idVehj].Trip[nextTj].firstCus);
//					}
//					else //nextT is PTrip OR C2C
//					{
//						int firstC_nextT = seg[idVehj].Trip[nextTj].firstCus;
//						varcostj += problem->c[cusDi][firstC_nextT];
//						GoThroughVehicle(idVehj,nextTj,varcostj,varvioTWCj,varvioTWSPj,cStartS,cusDi,firstC_nextT);
//					}//end nextT is PTrip OR C2C
//				}
//			}//end cusDj was the last cus--> cusDi is now the last cus
//		}
//		varvioTWC = varvioTWCi + varvioTWCj;
//		varvioTWSP = varvioTWSPi + varvioTWSPj;
//		varvioCAP =  varvioCAPi + varvioCAPj;
//		varcost = varcosti + varcostj;
//
//		exchangeCus[j][k]->var_vioTWC = varvioTWC;
//		exchangeCus[j][k]->var_vioTWCi = varvioTWCi;
//		exchangeCus[j][k]->var_vioTWCj = varvioTWCj;
//    	exchangeCus[j][k]->var_vioTWSP = varvioTWSP;
//    	exchangeCus[j][k]->var_vioTWSPi = varvioTWSPi;
//    	exchangeCus[j][k]->var_vioTWSPj = varvioTWSPj;
//		exchangeCus[j][k]->var_vioCAP = varvioCAP;
//		exchangeCus[j][k]->var_cost = varcost;
//		exchangeCus[j][k]->var_costi = varcosti;
//		exchangeCus[j][k]->var_costj = varcostj;
//	}//end i and j are in the different vehicles
//}
//
//
//
//void Solution::cal_twoOPTstarCusDIAndJ_oneTrip_LastTrip(int j, int k) //connect j with i where j and i are in the same trip; i after j and i != sucj
//{
//	//see on 2/12/2013
//   	int i = problem->node[j].neighborNode[k].id;  // i != sucj
//	int prei, suci, sucj, idcur, idnext,idpre;
//	
//	int idVeh = route_num[i];int idTrip = trip_num[i];
//
//    double varcost,vioTWCNEW, varvioTWC;
//	double cStartS, cArrTime,temp;
//
//	prei = predArr[i]; suci = nextArr[i];sucj = nextArr[j];
//
//	//Start to check leg:	
//	cStartS = depart[j]; vioTWCNEW = FvioTWCus[j];
//    cArrTime = cStartS + problem->c[j][i];
//	temp = cArrTime - problem->node[i].eTW;
//	if (temp > eps)
//	{
//		vioTWCNEW += temp;
//		cStartS = problem->node[i].depart;
//	}
//	else cStartS = PDS_MAX(cArrTime, problem->node[i].sTW) + problem->node[i].duration;
//
//	idcur=i;
//	idpre = prei;
//    while (idpre != j) //check reverse from prei to sucj
//    {
//		cArrTime = cStartS + problem->c[idcur][idpre];
//	    temp = cArrTime - problem->node[idpre].eTW;
//	    if (temp > eps)
//		{
//			vioTWCNEW +=temp;
//			cStartS = problem->node[idpre].depart;
//		}
//		else cStartS = PDS_MAX(problem->node[idpre].sTW, cArrTime) + problem->node[idpre].duration;
//		idcur=idpre; idpre = predArr[idpre];
//    }
//	//idcur is now sucj; check sucj-->suci & suci till the end of the trip:
//	idnext = suci;
//    while (idnext >0)
//	{
//		cArrTime = cStartS + problem->c[idcur][idnext];
//		temp = cArrTime - problem->node[idnext].eTW;
//		if (temp > eps)
//		{
//			vioTWCNEW += temp;
//			if (vioTWCus[idnext] > eps)
//			{
//				varvioTWC = vioTWCNEW - FvioTWCus[idnext];
//				goto Update;
//			}
//			cStartS = problem->node[idnext].depart;
//		}
//		else cStartS = PDS_MAX(problem->node[idnext].sTW, cArrTime) + problem->node[idnext].duration;
//		idcur = idnext;idnext=nextArr[idnext];
//	}
//	//idcur is now the lastCus of the trip
//	varvioTWC = vioTWCNEW - seg[idVeh].Trip[idTrip].vioTWC;
//
//		Update:
//		    if (suci >0) //i was not the last customer of the trip:
//			   varcost = problem->c[j][i] + problem->c[sucj][suci] - problem->c[j][sucj] - problem->c[i][suci];
//			 else //i was the last customer of the trip --> sucj is now the last customer of the trip:
//				 varcost = problem->c[j][i] + problem->c[sucj][0] - problem->c[j][sucj] - problem->c[i][0];
//			 twoOPTstarCus[j][k]->var_vioCAP = 0;
//			 twoOPTstarCus[j][k]->var_vioTWC = varvioTWC;
//			 twoOPTstarCus[j][k]->var_vioTWSP = 0;
//			 twoOPTstarCus[j][k]->var_cost = varcost;
//			 twoOPTstarCus[j][k]->empty=0;
//}
//
//
//void Solution::cal_twoOPTstarCusDIAndJ_oneTrip_NextTripD(int j, int k) //connect j with i where j and i are in the same trip
//{
//	//see on 2/12/2013
//   	int i = problem->node[j].neighborNode[k].id;  // i != sucj
//	int prei, suci, sucj, idcur, idnext,idpre;
//	
//	int idVeh = route_num[i]; int idTrip = trip_num[i];
//    //cout<<"j = "<<j<<"; i = "<<i<<"; ";showTripCost(idVeh, idTrip);
//
//    double varcost, vioTWCNEW, varvioTWC;
//	double cStartS, cArrTime,temp;
//	double varvioTWSP = 0;
//
//	prei = predArr[i]; suci = nextArr[i];sucj = nextArr[j];
//
//	//Start to check leg:	
//	cStartS = depart[j]; vioTWCNEW = FvioTWCus[j];
//    cArrTime = cStartS + problem->c[j][i];
//	temp = cArrTime - problem->node[i].eTW;
//	if (temp > eps)
//	{
//		vioTWCNEW += temp;
//		cStartS = problem->node[i].depart;
//	}
//	else cStartS = PDS_MAX(problem->node[i].sTW, cArrTime) + problem->node[i].duration;
//
//	idcur=i;
//	idpre = prei;
//	while (idpre != j) //check reverse from prei to sucj
//	{
//		cArrTime = cStartS + problem->c[idcur][idpre];
//		temp = cArrTime - problem->node[idpre].eTW;
//		if (temp > eps)
//		{
//			vioTWCNEW += temp;
//			cStartS = problem->node[idpre].depart;
//		}
//		else  cStartS = PDS_MAX(problem->node[idpre].sTW, cArrTime) + problem->node[idpre].duration;
//	    idcur=idpre; idpre = predArr[idpre];
//	}
//	//idcur is now sucj; check sucj-->suci & suci till the end of the trip:
//	bool stop; int nextT;
//	if (suci > 0)
//	{
//		idnext = suci;
//		while (idnext >0)
//		{
//			cArrTime = cStartS + problem->c[idcur][idnext];
//			temp = cArrTime - problem->node[idnext].eTW;
//			if (temp > eps)
//			{
//				vioTWCNEW += temp;
//				if (vioTWCus[idnext] > eps)
//				{
//					varvioTWC = vioTWCNEW - FvioTWCus[idnext];
//					varcost = problem->c[j][i] + problem->c[sucj][suci] - problem->c[j][sucj] - problem->c[i][suci];
//					goto Update;
//				}
//				cStartS = problem->node[idnext].depart;
//			}
//			else cStartS = PDS_MAX(problem->node[idnext].sTW, cArrTime) + problem->node[idnext].duration;
//			idcur = idnext;idnext=nextArr[idnext];
//		}
//		varcost = problem->c[j][i] + problem->c[sucj][suci] - problem->c[j][sucj] - problem->c[i][suci];
//		varvioTWC = vioTWCNEW - seg[idVeh].Trip[idTrip].vioTWC;
//		nextT = idTrip + 1;
//		stop = calChangeCONNECTAtSP_DD(idcur, idVeh, nextT, idTrip, cStartS, varvioTWSP, varcost);
//	}
//	else //change lastC: i was the last; sucj is now the last
//	{
//		 varvioTWC = vioTWCNEW - seg[idVeh].Trip[idTrip].vioTWC;
//		 varcost = problem->c[j][i] - problem->c[j][sucj];
//		 nextT = idTrip + 1;
//		 if (seg[idVeh].Trip[idTrip].waitingS == NO_WS)
//			 varcost -= problem->c[i][seg[idVeh].Trip[nextT].assSP];
//		 else varcost -= problem->disCWSSP[i][seg[idVeh].Trip[nextT].assSP];
//		 stop = calChangeCONNECTAtSP_DD_LastCChanged(sucj, idVeh, nextT, cStartS, varvioTWSP, varcost);
//	}//end change lastC: i was the last; sucj is now the last
//	if (stop == 0)
//	{
//        int firstC_nextT = seg[idVeh].Trip[nextT].firstCus;	 
//		GoThroughVehicle(idVeh, nextT, varcost, varvioTWC, varvioTWSP, cStartS, seg[idVeh].Trip[nextT].assSP, firstC_nextT);
//	}
//
//Update:
//	 twoOPTstarCus[j][k]->var_vioCAP = 0;
//     twoOPTstarCus[j][k]->var_vioTWC = varvioTWC;
//     twoOPTstarCus[j][k]->var_vioTWSP = varvioTWSP;
//     twoOPTstarCus[j][k]->var_cost = varcost;
//     twoOPTstarCus[j][k]->empty=0;
//
//}
//
//void Solution::cal_twoOPTstarCusDIAndJ_oneTrip_NextTripPORC2C(int j, int k) //connect j with i where j and i are in the same trip
//{
//	//see 2/12/2013
//   	int i = problem->node[j].neighborNode[k].id;  // i != sucj
//	int prei, suci, sucj, idcur, idnext,idpre;
//	
//	int idVeh = route_num[i]; int idTrip = trip_num[i];
//
//    double varcost, vioTWCNEW, varvioTWC;
//	double cStartS, cArrTime,temp;
//	double varvioTWSP = 0;
//
//	prei = predArr[i]; suci = nextArr[i];sucj = nextArr[j];
//
//	//Start to check leg:	
//	cStartS = depart[j]; vioTWCNEW = FvioTWCus[j];
//    cArrTime = cStartS + problem->c[j][i];
//	temp = cArrTime - problem->node[i].eTW;
//	if (temp > eps)
//	{
//		vioTWCNEW += temp;
//		cStartS = problem->node[i].depart;
//	}
//	else cStartS = PDS_MAX(problem->node[i].sTW, cArrTime) + problem->node[i].duration;
//
//	idcur=i;
//	idpre = prei;
//	while (idpre != j) //check reverse from prei to sucj
//	{
//		cArrTime = cStartS + problem->c[idcur][idpre];
//		temp = cArrTime - problem->node[idpre].eTW;
//		if (temp > eps)
//		{
//			vioTWCNEW += temp;
//			cStartS = problem->node[idpre].depart;
//		}
//		else  cStartS = PDS_MAX(problem->node[idpre].sTW, cArrTime) + problem->node[idpre].duration;
//	    idcur=idpre; idpre = predArr[idpre];
//	}
//	//idcur is now sucj; check sucj-->suci & suci till the end of the trip:
//	int nextT = idTrip + 1;
//	int firstC_nextT = seg[idVeh].Trip[nextT].firstCus;
//
//	if (suci > 0)
//	{
//		idnext = suci;
//		while (idnext >0)
//		{
//			cArrTime = cStartS + problem->c[idcur][idnext];
//			temp = cArrTime - problem->node[idnext].eTW;
//			if (temp > eps)
//			{
//				vioTWCNEW += temp;
//				if (vioTWCus[idnext] > eps)
//				{
//					varvioTWC = vioTWCNEW - FvioTWCus[idnext];
//					varcost = problem->c[j][i] + problem->c[sucj][suci] - problem->c[j][sucj] - problem->c[i][suci];
//					goto Update;
//				}
//				cStartS = problem->node[idnext].depart;
//			}
//			else cStartS = PDS_MAX(problem->node[idnext].sTW, cArrTime) + problem->node[idnext].duration;
//			idcur = idnext;idnext=nextArr[idnext];
//		}
//		varcost = problem->c[j][i] + problem->c[sucj][suci] - problem->c[j][sucj] - problem->c[i][suci];
//	}
//	else //change lastC: i was the last; sucj is now the last
//	{
//		 varcost = problem->c[j][i] + problem->c[sucj][firstC_nextT] - problem->c[j][sucj] - problem->c[i][firstC_nextT];
//
//	}//end change lastC: i was the last; sucj is now the last
//	varvioTWC = vioTWCNEW - seg[idVeh].Trip[idTrip].vioTWC;
//	//idcur now points to the last customer:
//	GoThroughVehicle(idVeh, nextT, varcost, varvioTWC, varvioTWSP, cStartS, idcur, firstC_nextT);
//
//Update:
//	 twoOPTstarCus[j][k]->var_vioCAP = 0;
//     twoOPTstarCus[j][k]->var_vioTWC = varvioTWC;
//     twoOPTstarCus[j][k]->var_vioTWSP = varvioTWSP;
//     twoOPTstarCus[j][k]->var_cost = varcost;
//     twoOPTstarCus[j][k]->empty=0;
//
//}
//
//
//void Solution::cal_twoOPTstarCusDIAndJ(int j, int k) //j and its #k neighbor belong to different vehicles
//{
//	//see 2/12/2013
//	//Moi trip sau idTripi va idTripj giu nguyen vehicle, ko exchange vehicle cua chung:
//	int i = problem->node[j].neighborNode[k].id; //connect j with i
//	int prei, suci, prej, sucj, idcur, idnext;
//
//
//	prei = predArr[i]; suci = nextArr[i];
//	prej = predArr[j]; sucj = nextArr[j];
//
//	int capi;
//	int capj = FCAP[j] + BCAP[i];
//	int idVehj = route_num[j]; int idVehi = route_num[i];
//	int idTripj = trip_num[j];  int idTripi = trip_num[i];
//	int assSPi = seg[idVehi].Trip[idTripi].assSP;
//
//    if (prei <0 && sucj <0) //Tripi becomes empty after move
//	{
//		if (capj > exceed) //24Oct: too long route & still don't have move to cut it--> don't use this move when capacity exceeds 1.5 capacity of the vehicle
//		{
//			  twoOPTstarCus[j][k]->var_vioCAP = PDS_INFINITY_INT;
//			  return;
//		}
//		if (numTripDSP[assSPi] <= problem->minTripSP[assSPi]) 
//		{
//			  twoOPTstarCus[j][k]->var_vioCAP = PDS_INFINITY_INT;
//			  return;
//		}
//	}
//	else //Tripi is not empty after move
//	{
//		capi=0; 
//		if (prei > 0) capi = FCAP[prei];
//		if (sucj>0) capi += BCAP[sucj];
//		if (capj > exceed || capi > exceed)
//		{
//			 twoOPTstarCus[j][k]->var_vioCAP = PDS_INFINITY_INT;
//			 return;
//		}
//	}
//
//
//		int varvioCAP;
//		double cStartS, cArrTime,temp;
//		double varcosti, varcostj;
//		double varvioTWCi, varvioTWCj, varvioTWSPi = 0, varvioTWSPj = 0;
//
//		int assSPj = seg[idVehj].Trip[idTripj].assSP;
//
//		int lastCOLDj = seg[idVehj].Trip[idTripj].lastCus;
//		int lastCOLDi = seg[idVehi].Trip[idTripi].lastCus;
//
//        //Start to check trip j	
//		varcostj = problem->c[j][i];
//		if (sucj >0) varcostj -= problem->c[j][sucj];
//		varcostj -= seg[idVehj].Trip[idTripj].connectCost;
//
//		cStartS = depart[j]; 
//        cArrTime = cStartS + problem->c[j][i];
//		temp = cArrTime - problem->node[i].eTW;
//		if (temp > eps)
//		{
//			if (vioTWCus[i] > eps)
//			{
//				varvioTWCj = temp - vioTWCus[i];
//				cStartS = depart[lastCOLDi];
//				goto CalConnectj;
//			}
//			varvioTWCj = temp;
//			cStartS = problem->node[i].depart;
//		}
//		else 
//		{
//			cStartS = PDS_MAX(cArrTime, problem->node[i].sTW) + problem->node[i].duration;
//			varvioTWCj = -vioTWCus[i];
//		}
//		idcur=i;
//		if (suci > 0) //need to check TW till the end of the trip i:
//		{
//			idnext = suci;
//	        while (idcur != lastCOLDi) //check from suci till the end of the leg i
//		    {
//		        cArrTime = cStartS + problem->c[idcur][idnext];
//				temp = cArrTime - problem->node[idnext].eTW;
//				if (temp > eps)
//				{
//					if (vioTWCus[idnext] > eps)
//					{
//						varvioTWCj += (temp - vioTWCus[idnext]); 
//						cStartS = depart[lastCOLDi];
//						goto CalConnectj;
//					}
//					varvioTWCj += temp;
//					cStartS = problem->node[idnext].depart;
//				}
//				else
//				{
//					cStartS = PDS_MAX(problem->node[idnext].sTW, cArrTime) + problem->node[idnext].duration;
//					varvioTWCj -= vioTWCus[idnext];
//				}
//				idcur=idnext; idnext = nextArr[idcur];
//		    }
//		}
//		//idcur is now the NEW last customer of the tripj: = lastCOLDi
//	CalConnectj:
//		int nextTj = idTripj + 1;
//		//cout<<"(j = "<<j<<", i = "<<i<<"; varvioTWCj  = "<<varvioTWCj<<", ";
//		if (nextTj < seg[idVehj].numTrips) //Tripj is not the last trip
//		{
//			int firstC_nextT = seg[idVehj].Trip[nextTj].firstCus;
//			if (seg[idVehj].Trip[nextTj].Type == 1) //nextTrip is delivery trip
//			{
//				 int assSP1 = seg[idVehj].Trip[nextTj].assSP;
//				 if (calChangeCONNECTAtSP_DD_LastCChanged(lastCOLDi, idVehj, nextTj, cStartS, varvioTWSPj, varcostj) == 0)
//					GoThroughVehicle(idVehj, nextTj, varcostj, varvioTWCj, varvioTWSPj, cStartS, assSP1, firstC_nextT);
//			}
//			else //nextTripj is pickup trip OR C2C
//			{
//				varcostj += problem->c[lastCOLDi][firstC_nextT];
//				GoThroughVehicle(idVehj, nextTj, varcostj, varvioTWCj, varvioTWSPj, cStartS, lastCOLDi, firstC_nextT);
//			}//end nextTripj is pickup trip
//			//cout<<"varvioTWCj' = "<<varvioTWCj<<"; ";
//		} //end Tripj is not the last trip
//		else varcostj += problem->c[lastCOLDi][0];
//
//		int nextTripi = idTripi+1;
//		bool empty_idVehi = 0;
//		varcosti = -seg[idVehi].Trip[idTripi].connectCost;
//
//		if (prei <0 && sucj <0) //Tripi becomes empty after move
//		{
//	        varvioTWCi = 0;
//  			varcosti -= problem->c[assSPi][i];
//			int vioCapj = PDS_MAX(capj - problem->Q, 0);
//			varvioCAP = -seg[idVehi].Trip[idTripi].vioCAP + (vioCapj - seg[idVehj].Trip[idTripj].vioCAP);
//
//			if (seg[idVehi].numTrips == 1) // after move, idVehi becomes empty
//			{
//				 varcosti -= problem->c[0][assSPi];
//				 empty_idVehi = 1;
//			}
//			else //vehicle i has >= 2trips
//			{
//				if (idTripi == 0) //tripi is the first trip
//				{
//					varcosti -= problem->c[0][assSPi];
//					if (seg[idVehi].Trip[1].Type == 1) //nextTripi is delivery trip: ok
//					{
//					   varvioTWSPi = -seg[idVehi].Trip[1].vioTWSP;
//					   int assSP1 = seg[idVehi].Trip[1].assSP;
//					   varcosti += problem->c[0][assSP1];
//					   cStartS = problem->leaveSP[assSP1][4]; //load only at sTW2
//					   if (PDSDIF(cStartS, seg[idVehi].Trip[1].leaveSP) == 0)
//						   goto Update;
//					   else
//					   {
//					       int firstC_nextT = seg[idVehi].Trip[1].firstCus; 
//						   GoThroughVehicle(idVehi,1, varcosti, varvioTWCi, varvioTWSPi, cStartS, assSP1, firstC_nextT);
//					   }
//					}
//					else if (seg[idVehi].Trip[1].Type == 0) //nextTripi is pickup trip
//					{
//						int firstC_nextT = seg[idVehi].Trip[1].firstCus;
//						varcosti += problem->c[0][firstC_nextT];
//						int assSPT = seg[idVehi].Trip[1].assSP;
//						if (seg[idVehi].Trip[1].numCus == 1)
//						{
//							//cStartS = problem->startSOneP[firstC_nextT][assSPT] + problem->node[firstC_nextT].duration;
//							if (problem->waitingSOneP[firstC_nextT][assSPT])
//							{
//								//cStartS += problem->disCWSSP[firstC_nextT][assSPT];
//								//cStartS = PDS_MAX(cStartS, problem->nodeSP[assSPT].sTW1);
//								if (seg[idVehi].Trip[1].waitingS == NO_WS)
//									varcosti += (problem->disCWSSP[firstC_nextT][assSPT] - problem->c[firstC_nextT][assSPT]);
//							}
//							else
//							{
//								//cStartS += problem->c[firstC_nextT][assSPT];
//								if (seg[idVehi].Trip[1].waitingS != NO_WS)
//									varcosti += (problem->c[firstC_nextT][assSPT] - problem->disCWSSP[firstC_nextT][assSPT]);
//							}
//							//cStartS += problem->nodeSP[assSPT].unload;
//							cStartS = problem->leaveSPOneP[firstC_nextT][assSPT];
//							if (seg[idVehi].numTrips > 2)
//							{
//								if (PDSDIF(cStartS, seg[idVehi].Trip[1].leaveSP))
//								{
//                                    firstC_nextT = seg[idVehi].Trip[2].firstCus;
//									GoThroughVehicle(idVehi, 2, varcosti, varvioTWCi, varvioTWSPi, cStartS, assSPT, firstC_nextT);
//								}
//							}
//						}
//						else
//						{
//							cStartS = 0;
//							GoThroughVehicle(idVehi, 1, varcosti, varvioTWCi, varvioTWSPi, cStartS, 0, firstC_nextT);
//						}
//					}//end nextTripi is pickup trip (CASE: tripi becomes empty, tripi is the first trip)
//					else //nextTripi is C2C trip
//					{
//						int firstC_nextT = seg[idVehi].Trip[1].firstCus;
//						varcosti += problem->c[0][firstC_nextT];
//						int assSPT = seg[idVehi].Trip[1].nextSP;
//						if (assSPT > 0) //[0-p] - C2C - (SP-d)
//						{
//							if (seg[idVehi].Trip[1].numCus == 2)
//							{
//								//cStartS = problem->startSOneP[firstC_nextT][assSPT] + problem->node[firstC_nextT].duration;
//								if (problem->waitingSOneP[firstC_nextT][assSPT])
//								{
//									//cStartS += problem->disCWSSP[firstC_nextT][assSPT];
//									//cStartS = PDS_MAX(cStartS, problem->nodeSP[assSPT].sTW1);
//									if (seg[idVehi].Trip[1].waitingS == NO_WS)
//										varcosti += (problem->disCWSSP[nextArr[firstC_nextT]][assSPT] - problem->c[nextArr[firstC_nextT]][assSPT]);
//								}
//								else
//								{
//									//cStartS += problem->c[firstC_nextT][assSPT];
//									if (seg[idVehi].Trip[1].waitingS != NO_WS)
//										varcosti += (problem->c[nextArr[firstC_nextT]][assSPT] - problem->disCWSSP[nextArr[firstC_nextT]][assSPT]);
//								}
//								//cStartS += problem->nodeSP[assSPT].unload;
//								cStartS = problem->leaveSPOneP[firstC_nextT][assSPT];
//								if (PDSDIF(cStartS, seg[idVehi].Trip[2].leaveSP))
//								{
//									firstC_nextT = seg[idVehi].Trip[2].firstCus;
//									GoThroughVehicle(idVehi, 2, varcosti, varvioTWCi, varvioTWSPi, cStartS, assSPT, firstC_nextT);
//								}
//							}
//							else
//							{
//								cStartS = 0;
//								GoThroughVehicle(idVehi, 1, varcosti, varvioTWCi, varvioTWSPi, cStartS, 0, firstC_nextT);
//							}
//						}
//						else
//						{
//							cStartS = 0;
//							GoThroughVehicle(idVehi, 1, varcosti, varvioTWCi, varvioTWSPi, cStartS, 0, firstC_nextT);
//						}
//					}//end nextTripi is C2C trip (CASE: tripi becomes empty, tripi is the first trip)
//				}
//				else //tripi is not the first trip:
//				{
//					 int preTripi = idTripi - 1;
//					 varcosti -= seg[idVehi].Trip[preTripi].connectCost;
//					 varvioTWSPi -= seg[idVehi].Trip[idTripi].vioTWSP;
//                     if (nextTripi == seg[idVehi].numTrips) //tripi is the last trip
//					 {
//						 if (seg[idVehi].Trip[preTripi].Type == 0)
//							 varcosti += problem->c[seg[idVehi].Trip[preTripi].assSP][0];
//						 else
//							 varcosti += problem->c[seg[idVehi].Trip[preTripi].lastCus][0];
//					 }
//					 else //idTripi is not the lastTrip (is middle)
//					 {
//						 if (seg[idVehi].Trip[preTripi].Type == 0) //preTripi is the pickup trip
//						 {
//							 cStartS = seg[idVehi].Trip[preTripi].leaveSP;
//							 int assSPprei = seg[idVehi].Trip[preTripi].assSP;
//							 if (seg[idVehi].Trip[nextTripi].Type == 1) // nextTripi is delivery trip
//							 {
//                                  bool stop = calCONNECTCSPTOSPD_FORDELETE(assSPprei, idVehi, nextTripi, cStartS, varvioTWSPi, varcosti);
//                                  if (stop) goto Update;
//								  int firstC_nextT = seg[idVehi].Trip[nextTripi].firstCus;
//								  GoThroughVehicle(idVehi, nextTripi, varcosti, varvioTWCi, varvioTWSPi, cStartS, seg[idVehi].Trip[nextTripi].assSP, firstC_nextT);
//							 }//end preTripi is pickup, nextTripi is delivery
//							 else //preTripi is pickup, nextTripi is pickup or C2C
//							 {
//								 int firstC_nextT = seg[idVehi].Trip[nextTripi].firstCus;
//								 varcosti += problem->c[assSPprei][firstC_nextT];
//								 GoThroughVehicle(idVehi, nextTripi, varcosti, varvioTWCi, varvioTWSPi, cStartS, assSPprei, firstC_nextT);
//							 }//end preTripi is pickup, nextTripi is pickup or C2C
//						 }
//						 else //if (seg[idVehi].Trip[preTripi].Type == 1 || 2) //preTripi is delivery trip OR C2C
//						 {
//							 int lastCprei = seg[idVehi].Trip[preTripi].lastCus;
//							 cStartS = depart[lastCprei];
//							 if (seg[idVehi].Trip[nextTripi].Type == 1) //nextTripi is delivery trip
//							 {
//                                 bool stop = calCONNECTCSPTOSPD_FORDELETE(lastCprei, idVehi, nextTripi, cStartS, varvioTWSPi, varcosti);
//                                 if (stop) goto Update;
//								 int assSP1 = seg[idVehi].Trip[nextTripi].assSP;
//								 int firstC_nextT = seg[idVehi].Trip[nextTripi].firstCus;
//								 GoThroughVehicle(idVehi, nextTripi, varcosti, varvioTWCi, varvioTWSPi, cStartS, assSP1, firstC_nextT);
//							 }//end nextTripi is delivery trip; preTripi is delivery trip
//							 else //nextTripi is pickup trip OR C2C; preTripi is delivery trip OR C2C
//							 {
//								 int firstC_nextT = seg[idVehi].Trip[nextTripi].firstCus;
//								 varcosti += problem->c[lastCprei][firstC_nextT];
//								 GoThroughVehicle(idVehi, nextTripi, varcosti, varvioTWCi, varvioTWSPi, cStartS, lastCprei, firstC_nextT);
//							 }//end nextTripi is pickup trip OR C2C; preTripi is delivery trip OR C2C
//						 }//end preTripi is delivery trip OR C2C
//					 }//end //idTripi is not the lastTrip (is middle)
//				}//end tripi is not the first trip
//			}//end vehicle i has >= 2 trips
//		}
//		else //Tripi is not empty after move
//		{
//			 int vioCapi = PDS_MAX(capi - problem->Q, 0);
//			 int vioCapj = PDS_MAX(capj - problem->Q, 0);
//			 varvioCAP = (vioCapi - seg[idVehi].Trip[idTripi].vioCAP) + (vioCapj - seg[idVehj].Trip[idTripj].vioCAP);
//
//			//Start to check trip i	
//			if (prei > 0)
//			{
//				cStartS = depart[prei]; 
//				varcosti -= problem->c[prei][i];
//				if (sucj > 0) varcosti += problem->c[prei][sucj];
//			}
//			else //prei < 0 --> sucj > 0
//			{
//				prei = assSPi;
//				cStartS = seg[idVehi].Trip[idTripi].leaveSP;
//				varcosti += (problem->c[assSPi][sucj] - problem->c[assSPi][i]);
//			}
//
//			varvioTWCi = 0;
//			idcur = prei;
//			if (sucj >0)
//			{
//				idnext = sucj;
//				while (idcur != lastCOLDj) //check from previ till the end of the leg j
//				{
//					cArrTime = cStartS + problem->c[idcur][idnext];
//					temp = cArrTime - problem->node[idnext].eTW;
//					if (temp > eps)
//					{
//						if (vioTWCus[idnext] > eps)
//						{
//							varvioTWCi += (temp - vioTWCus[idnext]);
//							cStartS = depart[lastCOLDj];
//							idcur = lastCOLDj;
//							goto CalConnecti;
//						}
//						varvioTWCi += temp;
//						cStartS = problem->node[idnext].depart;
//					}
//					else 
//					{
//						cStartS = PDS_MAX(problem->node[idnext].sTW, cArrTime) + problem->node[idnext].duration;
//						varvioTWCi -= vioTWCus[idnext];
//					}
//					idcur=idnext; idnext = nextArr[idcur];
//				}
//			}
//			//idcur is now the last customer of new idTripi:
//		CalConnecti:
//			if (nextTripi == seg[idVehi].numTrips) //Tripi is the last trip of idVehi:
//			{
//				 varcosti += problem->c[idcur][0];
//			}
//			else //Tripi is not the last trip of idVehi:
//			{
//				 int firstC_nextT = seg[idVehi].Trip[nextTripi].firstCus;
//				 if (seg[idVehi].Trip[nextTripi].Type == 1) //nextTripi is delivery trip:
//				 {
//					 int assSP1 = seg[idVehi].Trip[nextTripi].assSP;
//                     if (calChangeCONNECTAtSP_DD_LastCChanged(idcur, idVehi, nextTripi, cStartS, varvioTWSPi, varcosti) == 0)
//  					     GoThroughVehicle(idVehi, nextTripi, varcosti, varvioTWCi, varvioTWSPi, cStartS, assSP1, firstC_nextT);
//				 }//end nextTripi is delivery trip 
//				 else //nextTripi is pickup trip OR C2C:
//				 {
//					 varcosti += problem->c[idcur][firstC_nextT];
//					 GoThroughVehicle(idVehi, nextTripi, varcosti, varvioTWCi, varvioTWSPi, cStartS, idcur, firstC_nextT);
//				 }//end nextTripi is pickup trip OR C2C
//			 }//end Tripi is not the last trip of idVehi
//	}//end Tripi is not empty after move
//	// cout<<varvioTWCi<<endl;
//
//    Update:
//	    twoOPTstarCus[j][k]->var_vioTWC = varvioTWCi + varvioTWCj;
//		twoOPTstarCus[j][k]->var_vioTWSP = varvioTWSPi + varvioTWSPj;
//		//twoOPTstarCus[j][k]->var_vioTWSPi = varvioTWSPi;
//		//twoOPTstarCus[j][k]->var_vioTWSPj = varvioTWSPj;
//
//		twoOPTstarCus[j][k]->var_vioCAP = varvioCAP;
//		twoOPTstarCus[j][k]->var_cost = varcosti + varcostj;
//        //twoOPTstarCus[j][k]->var_costi = varcosti;
//		//twoOPTstarCus[j][k]->var_costj = varcostj;
//		if (empty_idVehi) twoOPTstarCus[j][k]->empty = 1;
//		else twoOPTstarCus[j][k]->empty = 0;
//}





//bool Solution::SUBcal_twoOPTstarCusPIAndJ_oneTrip(int j, int i, int idVeh, int idTrip, double &varcost, double &varvioTWC, double &varvioTWSP, double &cStartS) //connect j with i where j and i are in the same trip
//{
//	//see on 2/12/2013
//	int prei, suci, sucj, idcur, idnext,idpre;
//    double vioTWCNEW, cArrTime,temp;
//	varvioTWSP = 0;
//
//	prei = predArr[i]; suci = nextArr[i];sucj = nextArr[j];
//
//	//Start to check trip:	
//	cStartS = depart[j]; vioTWCNEW = FvioTWCus[j];
//    cArrTime = cStartS + problem->c[j][i];
//	temp = cArrTime - problem->node[i].eTW;
//	if (temp > eps)
//	{
//		vioTWCNEW += temp;
//		cStartS = problem->node[i].depart;
//	}
//	else cStartS = PDS_MAX(problem->node[i].sTW, cArrTime) + problem->node[i].duration;
//
//	idcur=i;
//	idpre = prei;
//	while (idpre != j) //check reverse from prei to sucj
//	{
//		cArrTime = cStartS + problem->c[idcur][idpre];
//		temp = cArrTime - problem->node[idpre].eTW;
//		if (temp > eps)
//		{
//			vioTWCNEW += temp;
//			cStartS = problem->node[idpre].depart;
//		}
//		else  cStartS = PDS_MAX(problem->node[idpre].sTW, cArrTime) + problem->node[idpre].duration;
//	    idcur=idpre; idpre = predArr[idpre];
//	}
//	//idcur is now sucj; check sucj-->suci & suci till the end of the trip:
//	if (suci > 0)
//	{
//		idnext = suci;
//		while (idnext >0)
//		{
//			cArrTime = cStartS + problem->c[idcur][idnext];
//			temp = cArrTime - problem->node[idnext].eTW;
//			if (temp > eps)
//			{
//				vioTWCNEW += temp;
//				if (vioTWCus[idnext] > eps)
//				{
//					varvioTWC = vioTWCNEW - FvioTWCus[idnext];
//					varcost = problem->c[j][i] + problem->c[sucj][suci] - problem->c[j][sucj] - problem->c[i][suci];
//					return 1;
//				}
//				cStartS = problem->node[idnext].depart;
//			}
//			else cStartS = PDS_MAX(problem->node[idnext].sTW, cArrTime) + problem->node[idnext].duration;
//			idcur = idnext;idnext=nextArr[idnext];
//		}
//		varcost = problem->c[j][i] + problem->c[sucj][suci] - problem->c[j][sucj] - problem->c[i][suci];
//		varvioTWC = vioTWCNEW - seg[idVeh].Trip[idTrip].vioTWC;
//		return calChangeCONNECTAtSP_PickTrip(idcur, idVeh, idTrip, cStartS, varvioTWSP, varcost);
//	}
//	else //change lastC: i was the last; sucj is now the last
//	{
//		 varvioTWC = vioTWCNEW - seg[idVeh].Trip[idTrip].vioTWC;
//		 varcost = problem->c[j][i] - problem->c[j][sucj];
//		 if (seg[idVeh].Trip[idTrip].waitingS == NO_WS)
//			 varcost -= problem->c[i][seg[idVeh].Trip[idTrip].assSP];
//		 else varcost -= problem->disCWSSP[i][seg[idVeh].Trip[idTrip].assSP];
//		 return calChangeCONNECTAtSP_PickTrip_LastCChanged(sucj, idVeh, idTrip, cStartS, varvioTWSP, varcost);
//	}//end change lastC: i was the last; sucj is now the last
//}


//bool Solution::SUBcal_twoOPTstarCusPIAndJ_oneTrip(int j, int i, int idVeh, int idTrip, double &varcost, double &varvioTWC, double &varvioTWSP, double &cStartS, bool &vioTWSPTRUE)  //connect j with i where j and i are in the same trip
//{
//	//see on 2/12/2013
//	int prei, suci, sucj, idcur, idnext,idpre;
//    double vioTWCNEW, cArrTime,temp;
//	varvioTWSP = 0;
//
//	prei = predArr[i]; suci = nextArr[i];sucj = nextArr[j];
//
//	//Start to check trip:	
//	cStartS = depart[j]; vioTWCNEW = FvioTWCus[j];
//    cArrTime = cStartS + problem->c[j][i];
//	temp = cArrTime - problem->node[i].eTW;
//	if (temp > eps)
//	{
//		vioTWCNEW += temp;
//		cStartS = problem->node[i].depart;
//	}
//	else cStartS = PDS_MAX(problem->node[i].sTW, cArrTime) + problem->node[i].duration;
//
//	idcur=i;
//	idpre = prei;
//	while (idpre != j) //check reverse from prei to sucj
//	{
//		cArrTime = cStartS + problem->c[idcur][idpre];
//		temp = cArrTime - problem->node[idpre].eTW;
//		if (temp > eps)
//		{
//			vioTWCNEW += temp;
//			cStartS = problem->node[idpre].depart;
//		}
//		else  cStartS = PDS_MAX(problem->node[idpre].sTW, cArrTime) + problem->node[idpre].duration;
//	    idcur=idpre; idpre = predArr[idpre];
//	}
//	//idcur is now sucj; check sucj-->suci & suci till the end of the trip:
//	if (suci > 0)
//	{
//		idnext = suci;
//		while (idnext >0)
//		{
//			cArrTime = cStartS + problem->c[idcur][idnext];
//			temp = cArrTime - problem->node[idnext].eTW;
//			if (temp > eps)
//			{
//				vioTWCNEW += temp;
//				if (vioTWCus[idnext] > eps)
//				{
//					varvioTWC = vioTWCNEW - FvioTWCus[idnext];
//					varcost = problem->c[j][i] + problem->c[sucj][suci] - problem->c[j][sucj] - problem->c[i][suci];
//					return 1;
//				}
//				cStartS = problem->node[idnext].depart;
//			}
//			else cStartS = PDS_MAX(problem->node[idnext].sTW, cArrTime) + problem->node[idnext].duration;
//			idcur = idnext;idnext=nextArr[idnext];
//		}
//		varcost = problem->c[j][i] + problem->c[sucj][suci] - problem->c[j][sucj] - problem->c[i][suci];
//		varvioTWC = vioTWCNEW - seg[idVeh].Trip[idTrip].vioTWC;
//		return calChangeCONNECTAtSP_PickTrip(idcur, idVeh, idTrip, cStartS, varvioTWSP, varcost, vioTWSPTRUE);
//	}
//	else //change lastC: i was the last; sucj is now the last
//	{
//		 varvioTWC = vioTWCNEW - seg[idVeh].Trip[idTrip].vioTWC;
//		 varcost = problem->c[j][i] - problem->c[j][sucj];
//		 if (seg[idVeh].Trip[idTrip].waitingS == NO_WS)
//			 varcost -= problem->c[i][seg[idVeh].Trip[idTrip].assSP];
//		 else varcost -= problem->disCWSSP[i][seg[idVeh].Trip[idTrip].assSP];
//		 return calChangeCONNECTAtSP_PickTrip_LastCChanged(sucj, idVeh, idTrip, cStartS, varvioTWSP, varcost, vioTWSPTRUE);
//	}//end change lastC: i was the last; sucj is now the last
//}


//void Solution::cal_twoOPTstarCusPIAndJ_oneTrip_LastTrip(int j, int i, int idVeh, int idTrip, double &varcost, double &varvioTWC, double &varvioTWSP, double &cStartS) //connect j with i where j and i are in the same trip
//{
//	//see on 2/12/2013
//	//COPY SUBcal_twoOPTstarCusPIAndJ_oneTrip
//	int prei, suci, sucj, idcur, idnext,idpre;
//    double vioTWCNEW, cArrTime,temp;
//	varvioTWSP = 0;
//
//	prei = predArr[i]; suci = nextArr[i];sucj = nextArr[j];
//
//	//Start to check trip:	
//	cStartS = depart[j]; vioTWCNEW = FvioTWCus[j];
//    cArrTime = cStartS + problem->c[j][i];
//	temp = cArrTime - problem->node[i].eTW;
//	if (temp > eps)
//	{
//		vioTWCNEW += temp;
//		cStartS = problem->node[i].depart;
//	}
//	else cStartS = PDS_MAX(problem->node[i].sTW, cArrTime) + problem->node[i].duration;
//
//	idcur=i;
//	idpre = prei;
//	while (idpre != j) //check reverse from prei to sucj
//	{
//		cArrTime = cStartS + problem->c[idcur][idpre];
//		temp = cArrTime - problem->node[idpre].eTW;
//		if (temp > eps)
//		{
//			vioTWCNEW += temp;
//			cStartS = problem->node[idpre].depart;
//		}
//		else  cStartS = PDS_MAX(problem->node[idpre].sTW, cArrTime) + problem->node[idpre].duration;
//	    idcur=idpre; idpre = predArr[idpre];
//	}
//	//idcur is now sucj; check sucj-->suci & suci till the end of the trip:
//	if (suci > 0)
//	{
//		idnext = suci;
//		while (idnext >0)
//		{
//			cArrTime = cStartS + problem->c[idcur][idnext];
//			temp = cArrTime - problem->node[idnext].eTW;
//			if (temp > eps)
//			{
//				vioTWCNEW += temp;
//				if (vioTWCus[idnext] > eps)
//				{
//					varvioTWC = vioTWCNEW - FvioTWCus[idnext];
//					varcost = problem->c[j][i] + problem->c[sucj][suci] - problem->c[j][sucj] - problem->c[i][suci];
//					return;
//				}
//				cStartS = problem->node[idnext].depart;
//			}
//			else cStartS = PDS_MAX(problem->node[idnext].sTW, cArrTime) + problem->node[idnext].duration;
//			idcur = idnext;idnext=nextArr[idnext];
//		}
//		varcost = problem->c[j][i] + problem->c[sucj][suci] - problem->c[j][sucj] - problem->c[i][suci];
//		varvioTWC = vioTWCNEW - seg[idVeh].Trip[idTrip].vioTWC;
//		calChangeCONNECTAtSP_PickTrip2(idcur, idVeh, idTrip, cStartS, varvioTWSP, varcost);
//	}
//	else //change lastC: i was the last; sucj is now the last
//	{
//		 varvioTWC = vioTWCNEW - seg[idVeh].Trip[idTrip].vioTWC;
//		 varcost = problem->c[j][i] - problem->c[j][sucj];
//		 if (seg[idVeh].Trip[idTrip].waitingS == NO_WS)
//			 varcost -= problem->c[i][seg[idVeh].Trip[idTrip].assSP];
//		 else varcost -= problem->disCWSSP[i][seg[idVeh].Trip[idTrip].assSP];
//		 calChangeCONNECTAtSP_PickTrip_LastCChanged2(sucj, idVeh, idTrip, cStartS, varvioTWSP, varcost);
//	}//end change lastC: i was the last; sucj is now the last
//}


//void Solution::cal_twoOPTstarCusPIAndJ_oneTrip_NextTripP(int j, int i, int idVeh, int idTrip, double &varcost, double &varvioTWC, double &varvioTWSP)
//{
//	//see on 2/12/2013
//   double cStartS; 
//   if (SUBcal_twoOPTstarCusPIAndJ_oneTrip(j, i, idVeh, idTrip, varcost, varvioTWC, varvioTWSP, cStartS)== 0)
//   {
//       int nextT = idTrip + 1;
//       int firstC_nextT = seg[idVeh].Trip[nextT].firstCus;
//       GoThroughVehicle(idVeh, nextT, varcost, varvioTWC, varvioTWSP, cStartS, seg[idVeh].Trip[idTrip].assSP, firstC_nextT);
//   }
//}

//void Solution::cal_twoOPTstarCusPIAndJ_oneTrip_NextTripD_SameSP(int j, int i, int idVeh, int idTrip, double &varcost, double &varvioTWC, double &varvioTWSP)
//{
//   double cStartS; 
//   bool vioTWSPTRUE;
//   if (SUBcal_twoOPTstarCusPIAndJ_oneTrip(j, i, idVeh, idTrip, varcost, varvioTWC, varvioTWSP, cStartS, vioTWSPTRUE)== 0)
//   {
//		//varvioTWSP *= 2; //already calculated at SUBcal_twoOPTstarCusPIAndJ_oneTrip through calling procedures calChangeCONNECTAtSP_PickTrip/calChangeCONNECTAtSP_PickTrip_LastCChanged
//		int assSP = seg[idVeh].Trip[idTrip].assSP;
//		//Update 16/11/2013
//		if (vioTWSPTRUE) cStartS = problem->leaveSP[assSP][1]; //unload only at eTW2
//		else  cStartS += problem->nodeSP[assSP].load;
//	 
//		int nextT = idTrip + 1;
// 	    int firstC_nextT = seg[idVeh].Trip[nextT].firstCus;
//		GoThroughVehicle(idVeh, nextT, varcost, varvioTWC, varvioTWSP, cStartS, assSP, firstC_nextT);
//   }
//   //else varvioTWSP *= 2;
//}

//void Solution::cal_twoOPTstarCusPIAndJ_oneTrip_NextTripD_DifSP(int j, int i, int idVeh, int idTrip, double &varcost, double &varvioTWC, double &varvioTWSP)
//{
//   double cStartS; 
//   if (SUBcal_twoOPTstarCusPIAndJ_oneTrip(j, i, idVeh, idTrip, varcost, varvioTWC, varvioTWSP, cStartS)== 0)
//   {
//		int nextT = idTrip + 1;
// 	    int firstC_nextT = seg[idVeh].Trip[nextT].firstCus;
//		if (calChangeCONNECTAtSP_SPSP(idVeh, nextT, idTrip, cStartS, varvioTWSP, varcost) == 0)
//			GoThroughVehicle(idVeh, nextT, varcost, varvioTWC, varvioTWSP, cStartS, seg[idVeh].Trip[nextT].assSP, firstC_nextT);
//   }
//
//}

//void Solution::cal_twoOPTstarCusPIAndJ_oneTrip(int j, int k)
//{
//	//see on 2/12/2013
//   	int i = problem->node[j].neighborNode[k].id;
//	int idVeh = route_num[i]; int idTrip = trip_num[i];
//	int lastT = seg[idVeh].numTrips - 1;
//	double cStartS;
//
//	//cout<<"Inside cal_twoOPTstarCusPIAndJ_oneTrip: trip("<<idVeh<<", "<<idTrip<<")"<<endl;
//	twoOPTstarCus[j][k]->var_vioCAP = 0;
//	if (idTrip == lastT)
//	{
//		cal_twoOPTstarCusPIAndJ_oneTrip_LastTrip(j, i, idVeh, idTrip, twoOPTstarCus[j][k]->var_cost, twoOPTstarCus[j][k]->var_vioTWC,  twoOPTstarCus[j][k]->var_vioTWSP, cStartS); //connect j with i where j and i are in the same trip
//	}
//	else
//	{
//	   double varcost, varvioTWC, varvioTWSP;
//	   bool vioTWSPTRUE;
//	   if (SUBcal_twoOPTstarCusPIAndJ_oneTrip(j, i, idVeh, idTrip, varcost, varvioTWC, varvioTWSP, cStartS, vioTWSPTRUE)== 0)
//	   {
//		   int nextT = idTrip + 1;
//		   int firstC_nextT = seg[idVeh].Trip[nextT].firstCus;
//		   if (seg[idVeh].Trip[nextT].Type == 1)
//		   {
//			   int assSP = seg[idVeh].Trip[idTrip].assSP;
//			   if (assSP == seg[idVeh].Trip[nextT].assSP) //same SP
//			   {
//					//varvioTWSP *= 2; //already calculated at SUBcal_twoOPTstarCusPIAndJ_oneTrip through calling procedures ::calChangeCONNECTAtSP_PickTrip/::calChangeCONNECTAtSP_PickTrip_LastCChanged
//				   //Update 16/11/2013	
//				    if (vioTWSPTRUE) cStartS = problem->leaveSP[assSP][1]; //load only at eTW2
//					else cStartS += problem->nodeSP[assSP].load;
//					GoThroughVehicle(idVeh, nextT, varcost, varvioTWC, varvioTWSP, cStartS, assSP, firstC_nextT);
//			   }
//			   else //dif SP
//			   {
//					if (calChangeCONNECTAtSP_SPSP(idVeh, nextT, idTrip, cStartS, varvioTWSP, varcost) == 0)
//						GoThroughVehicle(idVeh, nextT, varcost, varvioTWC, varvioTWSP, cStartS, seg[idVeh].Trip[nextT].assSP, firstC_nextT);
//			   }
//		   }
//		   else // if (seg[idVeh].Trip[nextT].Type == 0 || 2)
//		       GoThroughVehicle(idVeh, nextT, varcost, varvioTWC, varvioTWSP, cStartS, seg[idVeh].Trip[idTrip].assSP, firstC_nextT);
//	   }
//	   /*else
//	   {
//		   int nextT = idTrip + 1;
//		   if (seg[idVeh].Trip[nextT].Type)
//		   {
//			   int assSP = seg[idVeh].Trip[idTrip].assSP;
//			   if (assSP == seg[idVeh].Trip[nextT].assSP) //same SP
//			   {
//				   varvioTWSP *= 2;
//			   }
//		   }
//	   }*/
//	   twoOPTstarCus[j][k]->var_cost = varcost;
//	   twoOPTstarCus[j][k]->var_vioTWSP = varvioTWSP;
//	   twoOPTstarCus[j][k]->var_vioTWC = varvioTWC;
//
//	}
//
//}



//void Solution::cal_twoOPTstarCusPIAndJ(int j, int k) //j and its neighbor #k belong to different vehicles
//{
//	//see on 2/12/2013
//	//Moi trip sau idTripi va idTripj giu nguyen vehicle, ko exchange vehicle cua chung:
//	int i = problem->node[j].neighborNode[k].id; //connect j with i
//	int prei, suci, prej, sucj, idcur, idnext;
//
//	int idVehj = route_num[j]; int idVehi = route_num[i];
//	int idTripj = trip_num[j]; int idTripi = trip_num[i];
//	//cout<<"Inside cal_twoOPTstarCusPIAndJ: j of trip("<<idVehj<<", "<<idTripj<<"); i of trip ("<<idVehi<<", "<<idTripj<<")"<<endl;
//	int assSPi = seg[idVehi].Trip[idTripi].assSP;
//	int assSPj = seg[idVehj].Trip[idTripj].assSP;
//
//	prei = predArr[i]; suci = nextArr[i];
//	prej = predArr[j]; sucj = nextArr[j];
//
//	int capi;
//	int capj = FCAP[j] + BCAP[i];
//	bool TripiEmpty = 0;
//
//	if (prei <0 && sucj <0) //Tripi becomes empty after move
//	{
//		if (capj > exceed) //24Oct: too long route & still don't have move to cut it--> don't use this move when capacity exceeds 1.5 capacity of the vehicle
//		{
//			  twoOPTstarCus[j][k]->var_vioCAP = PDS_INFINITY_INT;
//			  return;
//		}
//		TripiEmpty = 1;
//	}
//	else //Tripi is not empty after move
//	{
//		capi=0; 
//		if (prei > 0) capi = FCAP[prei];
//		if (sucj>0) capi += BCAP[sucj];
//		if (capj > exceed || capi > exceed)
//		{
//			 twoOPTstarCus[j][k]->var_vioCAP = PDS_INFINITY_INT;
//			 return;
//		}
//	}
//	//cout<<"(j = "<<j<<", i = "<<i<<"): capi = "<<capi<<"; capj = "<<capj;
//	//cout<<"prei = "<<prei<<"; sucj = "<<sucj<<endl;
//
//
//		int varvioCAP;
//		double cStartS, cArrTime,temp;
//		double varcosti, varcostj;
//		double varvioTWCi=0, varvioTWCj=0, varvioTWSPi = 0, varvioTWSPj = 0;
//
//		int lastCOLDj = seg[idVehj].Trip[idTripj].lastCus;
//		int lastCOLDi = seg[idVehi].Trip[idTripi].lastCus;
//
//        //Start to check trip j	
//		varcostj = problem->c[j][i];
//		if (sucj >0) varcostj -= problem->c[j][sucj];
//		if (seg[idVehj].Trip[idTripj].waitingS == NO_WS)
//			varcostj -= problem->c[lastCOLDj][assSPj];
//		else varcostj -= problem->disCWSSP[lastCOLDj][assSPj];
//
//		//Update 18/11/2013
//		if (idTripj==0 && seg[idVehj].Trip[idTripj].numCus == 1) //
//			cStartS = PDS_MAX(problem->c[0][j], problem->node[j].sTW) + problem->node[j].duration;
//		else
//			cStartS = depart[j]; 
//		
//		cArrTime = cStartS + problem->c[j][i];
//		temp = cArrTime - problem->node[i].eTW;
//		if (temp > eps)
//		{
//			if (vioTWCus[i] > eps)
//			{
//				varvioTWCj += (temp - vioTWCus[i]);
//				cStartS = depart[lastCOLDi];
//				goto CalConnectj;
//			}
//			varvioTWCj += temp;
//			cStartS = problem->node[i].depart;
//		}
//		else 
//		{
//			cStartS = PDS_MAX(cArrTime, problem->node[i].sTW) + problem->node[i].duration;
//			varvioTWCj -= vioTWCus[i];
//		}
//		idcur=i;
//		if (suci > 0) //need to check TW till the end of the trip i:
//		{
//			idnext = suci;
//	        while (idcur != lastCOLDi) //check from suci till the end of the leg i
//		    {
//		        cArrTime = cStartS + problem->c[idcur][idnext];
//				temp = cArrTime - problem->node[idnext].eTW;
//				if (temp > eps)
//				{
//					if (vioTWCus[idnext] > eps)
//					{
//						varvioTWCj += (temp - vioTWCus[idnext]); 
//						cStartS = depart[lastCOLDi];
//						goto CalConnectj;
//					}
//					varvioTWCj += temp;
//					cStartS = problem->node[idnext].depart;
//				}
//				else 
//				{
//					varvioTWCj -= vioTWCus[idnext];
//					cStartS = PDS_MAX(problem->node[idnext].sTW, cArrTime) + problem->node[idnext].duration;
//				}
//			    idcur=idnext; idnext = nextArr[idcur];
//		    }
//		}
//		//idcur is now the NEW last customer of the tripj: = lastCOLDi
//	CalConnectj:
//		//lastC is changed: old lastCus = lastCOLDj; new lastcus = lastCOLDi
//		bool vioTWSPTRUE;
//		bool stop = calChangeCONNECTAtSP_PickTrip_LastCChanged(lastCOLDi, idVehj, idTripj, cStartS, varvioTWSPj, varcostj, vioTWSPTRUE);
//        if (stop == 0)
//		{
//			int nextTj = idTripj + 1;
//			if (nextTj < seg[idVehj].numTrips) // Tripj is not the last trip
//			{
//				int firstC_nextT = seg[idVehj].Trip[nextTj].firstCus;
//				if (seg[idVehj].Trip[nextTj].Type == 1)
//				{
//					if (seg[idVehj].Trip[nextTj].assSP == assSPj)
//					{
//						//varvioTWSPj *= 2; Already calculated at calChangeCONNECTAtSP_PickTrip_LastCChanged
//						//Update 16/11/2013
//						if (vioTWSPTRUE) cStartS = problem->leaveSP[assSPj][1]; //load only at eTW2
//						else cStartS += problem->nodeSP[assSPj].load;
//						GoThroughVehicle(idVehj, nextTj, varcostj, varvioTWCj, varvioTWSPj, cStartS, assSPj, firstC_nextT);
//					}
//					else // p - asssP -- asssP1 - d
//					{
//						if (calChangeCONNECTAtSP_SPSP(idVehj, nextTj, idTripj, cStartS, varvioTWSPj, varcostj) == 0)
//						    GoThroughVehicle(idVehj, nextTj, varcostj, varvioTWCj, varvioTWSPj, cStartS, seg[idVehj].Trip[nextTj].assSP, firstC_nextT);
//					}
//				}
//				else //nextTj is pickup trip OR C2C:
//				{
//                    GoThroughVehicle(idVehj, nextTj, varcostj, varvioTWCj, varvioTWSPj, cStartS, assSPj, firstC_nextT);
//				}//end nextTj is pickup trip OR C2C
//			}
//		}
//
//		int nextTripi = idTripi+1;
//		bool empty_idVehi = 0;
//		if (seg[idVehi].Trip[idTripi].waitingS == NO_WS)
//			varcosti = -problem->c[lastCOLDi][assSPi];
//		else varcosti = -problem->disCWSSP[lastCOLDi][assSPi];
//
//		if (TripiEmpty) //prei <0 && sucj <0) //Tripi becomes empty after move
//		{
//			varcosti -= seg[idVehi].Trip[idTripi].connectCost;
//	        //varvioTWCi = 0;
//			int vioCapj = PDS_MAX(capj - problem->Q, 0);
//			varvioCAP = -seg[idVehi].Trip[idTripi].vioCAP + (vioCapj - seg[idVehj].Trip[idTripj].vioCAP);
//			varvioTWSPi = -seg[idVehi].Trip[idTripi].vioTWSP;
//
//			if (seg[idVehi].numTrips == 1) // after move, idVehi becomes empty
//			{
//				 varcosti -= problem->c[0][i];
//				 empty_idVehi = 1;
//			}
//			else //vehicle i has >= 2trips
//			{
//				if (idTripi == 0) //tripi is the first trip
//				{
//					varcosti -= problem->c[0][i];
//					if (seg[idVehi].Trip[1].Type == 1) //nextTripi is delivery trip: ok
//					{
//					   varvioTWSPi -= seg[idVehi].Trip[1].vioTWSP;
//					   int assSP1 = seg[idVehi].Trip[1].assSP;
//					   varcosti += problem->c[0][assSP1];
//					   cStartS = problem->leaveSP[assSP1][4]; //load only at sTW2
//					   if (PDSDIF(cStartS, seg[idVehi].Trip[1].leaveSP) == 0)
//						   goto Update;
//					   else
//					   {
//					       int firstC_nextT = seg[idVehi].Trip[1].firstCus; 
//						   GoThroughVehicle(idVehi,1, varcosti, varvioTWCi, varvioTWSPi, cStartS, assSP1, firstC_nextT);
//					   }
//					}
//					else if (seg[idVehi].Trip[1].Type == 0)//nextTripi is pickup trip
//					{
//						int firstC_nextT = seg[idVehi].Trip[1].firstCus;
//						varcosti += problem->c[0][firstC_nextT];
//						int assSPT = seg[idVehi].Trip[1].assSP;
//						if (seg[idVehi].Trip[1].numCus == 1)
//						{
//							//cStartS = problem->startSOneP[firstC_nextT][assSPT] + problem->node[firstC_nextT].duration;
//							if (problem->waitingSOneP[firstC_nextT][assSPT])
//							{
//								//cStartS = PDS_MAX(cStartS + problem->disCWSSP[firstC_nextT][assSPT], problem->nodeSP[assSPT].sTW1);
//								if (seg[idVehi].Trip[1].waitingS == NO_WS)
//									varcosti += (problem->disCWSSP[firstC_nextT][assSPT] - problem->c[firstC_nextT][assSPT]);
//							}
//							else
//							{
//								//cStartS += problem->c[firstC_nextT][assSPT];
//								if (seg[idVehi].Trip[1].waitingS != NO_WS)
//									varcosti += (problem->c[firstC_nextT][assSPT] - problem->disCWSSP[firstC_nextT][assSPT]);
//							}
//							//cStartS += problem->nodeSP[assSPT].unload;
//							cStartS = problem->leaveSPOneP[firstC_nextT][assSPT];
//							if (seg[idVehi].numTrips > 2)
//							{
//								if (PDSDIF(cStartS, seg[idVehi].Trip[1].leaveSP))
//								{
//									firstC_nextT = seg[idVehi].Trip[2].firstCus;
//									GoThroughVehicle(idVehi, 2, varcosti, varvioTWCi, varvioTWSPi, cStartS, assSPT, firstC_nextT);
//								}
//							}
//						}
//						else
//						{
//							cStartS = 0;
//							GoThroughVehicle(idVehi, 1, varcosti, varvioTWCi, varvioTWSPi, cStartS, 0, firstC_nextT);
//						}
//					}//end nextTripi is pickup trip (CASE: tripi becomes empty, tripi is the first trip)
//					else  //nextTripi is C2C trip (CASE: tripi becomes empty, tripi is the first trip)
//					{
//						int firstC_nextT = seg[idVehi].Trip[1].firstCus;
//						varcosti += problem->c[0][firstC_nextT];
//						int assSPT = seg[idVehi].Trip[1].nextSP;
//						if (assSPT > 0)
//						{
//							if (seg[idVehi].Trip[1].numCus == 2)
//							{
//								//cStartS = problem->startSOneP[firstC_nextT][assSPT] + problem->node[firstC_nextT].duration;
//								if (problem->waitingSOneP[firstC_nextT][assSPT])
//								{
//									//cStartS = PDS_MAX(cStartS + problem->disCWSSP[firstC_nextT][assSPT], problem->nodeSP[assSPT].sTW1);
//									if (seg[idVehi].Trip[1].waitingS == NO_WS)
//										varcosti += (problem->disCWSSP[nextArr[firstC_nextT]][assSPT] - problem->c[nextArr[firstC_nextT]][assSPT]);
//								}
//								else
//								{
//									//cStartS += problem->c[firstC_nextT][assSPT];
//									if (seg[idVehi].Trip[1].waitingS != NO_WS)
//										varcosti += (problem->c[nextArr[firstC_nextT]][assSPT] - problem->disCWSSP[nextArr[firstC_nextT]][assSPT]);
//								}
//								//cStartS += problem->nodeSP[assSPT].unload;
//								cStartS = problem->leaveSPOneP[firstC_nextT][assSPT];
//								if (PDSDIF(cStartS, seg[idVehi].Trip[2].leaveSP))
//								{
//									firstC_nextT = seg[idVehi].Trip[2].firstCus;
//									GoThroughVehicle(idVehi, 2, varcosti, varvioTWCi, varvioTWSPi, cStartS, assSPT, firstC_nextT);
//								}
//							}
//							else
//							{
//								cStartS = 0;
//								GoThroughVehicle(idVehi, 1, varcosti, varvioTWCi, varvioTWSPi, cStartS, 0, firstC_nextT);
//							}
//						}
//						else
//						{
//							cStartS = 0;
//							GoThroughVehicle(idVehi, 1, varcosti, varvioTWCi, varvioTWSPi, cStartS, 0, firstC_nextT);
//						}
//					}//end  nextTripi is C2C trip (CASE: tripi becomes empty, tripi is the first trip)
//				}
//				else //tripi is not the first trip:
//				{
//					 int preTripi = idTripi - 1;
//					 varcosti -= seg[idVehi].Trip[preTripi].connectCost;
//                     if (nextTripi == seg[idVehi].numTrips) //tripi is the last trip
//					 {
//						 if (seg[idVehi].Trip[preTripi].Type == 0)
//							 varcosti += problem->c[seg[idVehi].Trip[preTripi].assSP][0];
//						 else
//							 varcosti += problem->c[seg[idVehi].Trip[preTripi].lastCus][0];
//					 }
//					 else //idTripi is not the lastTrip (is middle)
//					 {
//						 if (seg[idVehi].Trip[preTripi].Type == 0) //preTripi is the pickup trip
//						 {
//							 cStartS = seg[idVehi].Trip[preTripi].leaveSP;
//							 int assSPprei = seg[idVehi].Trip[preTripi].assSP;
//							 if (seg[idVehi].Trip[nextTripi].Type == 1) // nextTripi is delivery trip
//							 {
//                                  bool stop = calCONNECTCSPTOSPD_FORDELETE(assSPprei, idVehi, nextTripi, cStartS, varvioTWSPi, varcosti);
//                                  if (stop) goto Update;
//								  int firstC_nextT = seg[idVehi].Trip[nextTripi].firstCus;
//								  GoThroughVehicle(idVehi, nextTripi, varcosti, varvioTWCi, varvioTWSPi, cStartS, seg[idVehi].Trip[nextTripi].assSP, firstC_nextT);
//							 }//end preTripi is pickup, nextTripi is delivery
//							 else //preTripi is pickup, nextTripi is pickup OR C2C
//							 {
//								 int firstC_nextT = seg[idVehi].Trip[nextTripi].firstCus;
//								 varcosti += problem->c[assSPprei][firstC_nextT];
//								 GoThroughVehicle(idVehi, nextTripi, varcosti, varvioTWCi, varvioTWSPi, cStartS, assSPprei, firstC_nextT);
//							 }//end preTripi is pickup, nextTripi is pickup OR C2C
//						 }
//						 else //preTripi is delivery trip OR C2C
//						 {
//							 int lastCprei = seg[idVehi].Trip[preTripi].lastCus;
//							 cStartS = depart[lastCprei];
//							 if (seg[idVehi].Trip[nextTripi].Type == 1) //nextTripi is delivery trip
//							 {
//                                 bool stop = calCONNECTCSPTOSPD_FORDELETE(lastCprei, idVehi, nextTripi, cStartS, varvioTWSPi, varcosti);
//                                 if (stop) goto Update;
//								 int assSP1 = seg[idVehi].Trip[nextTripi].assSP;
//								 int firstC_nextT = seg[idVehi].Trip[nextTripi].firstCus;
//								 GoThroughVehicle(idVehi, nextTripi, varcosti, varvioTWCi, varvioTWSPi, cStartS, assSP1, firstC_nextT);
//							 }//end nextTripi is delivery trip; preTripi is delivery trip
//							 else //nextTripi is pickup trip OR C2C; preTripi is delivery trip OR C2C
//							 {
//								 int firstC_nextT = seg[idVehi].Trip[nextTripi].firstCus;
//								 varcosti += problem->c[lastCprei][firstC_nextT];
//								 GoThroughVehicle(idVehi, nextTripi, varcosti, varvioTWCi, varvioTWSPi, cStartS, lastCprei, firstC_nextT);
//							 }//end nextTripi is pickup trip OR C2C; preTripi is delivery trip OR C2C
//						 }//end preTripi is delivery trip OR C2C
//					 }//end //idTripi is not the lastTrip (is middle)
//				}//end tripi is not the first trip
//			}//end vehicle i has >= 2 trips
//		}
//		else //Tripi is not empty after move
//		{
//			 int vioCapi = PDS_MAX(capi - problem->Q, 0);
//			 int vioCapj = PDS_MAX(capj - problem->Q, 0);
//			 varvioCAP = (vioCapi - seg[idVehi].Trip[idTripi].vioCAP) + (vioCapj - seg[idVehj].Trip[idTripj].vioCAP);
//			 //cout<<"-->vioCapiNEW = "<<vioCapi<<"; vioCapjNEW = "<<vioCapj<<"; vioCapiOLD = "<<seg[idVehi].Trip[idTripi].vioCAP<<"; vioCapjOLD = "<<seg[idVehj].Trip[idTripj].vioCAP<<"buc = "<<varvioCAP<<"; ";
//
//			//Start to check trip i	
//			int UUU = 0; bool stop, vioTWSPTRUE;
//		    if (idTripi == 0)
//			{
//				if (prei > 0)
//				{
//					if (sucj < 0 && pos[prei] == 1) UUU = prei;
//				}
//				else // prei < 0 -> sucj > 0
//				{
//					if (nextArr[sucj] < 0) UUU = sucj;
//				}
//			}
//			if (UUU > 0) //idTripi is first pickup trip and has only 1 cus after the move:
//			{
//				if (UUU==prei) // idTripi now has only 1 cus prei:
//				{
//					 varcosti -= problem->c[prei][i];
//					 varvioTWCi = - vioTWCus[prei];
//				}
//				else //idTripi now has only 1 cus sucj
//				{
//					varcosti += (problem->c[0][sucj] - problem->c[0][i]);
//					varvioTWCi = -vioTWCus[sucj];
//				}//end idTripi now has only 1 cus sucj
//				cStartS = problem->startSOneP[UUU][assSPi] + problem->node[UUU].duration;
//				stop = calChangeCONNECTAtSP_PickTrip_LastCChanged(UUU, idVehi, idTripi, cStartS, varvioTWSPi, varcosti, vioTWSPTRUE);
//			}
//			else
//			{
//					if (prei > 0)
//					{
//						cStartS = depart[prei]; 
//						varcosti -= problem->c[prei][i];
//						if (sucj > 0) varcosti += problem->c[prei][sucj];
//					}
//					else //prei < 0 --> sucj > 0
//					{
//						if (idTripi == 0)
//						{
//							prei = 0;
//							cStartS = 0;
//						}
//						else
//						{
//							int preTi = idTripi - 1;
//							if (seg[idVehi].Trip[preTi].Type == 0)
//							{
//								prei = seg[idVehi].Trip[preTi].assSP;
//								cStartS = seg[idVehi].Trip[preTi].leaveSP;
//							}
//							else
//							{
//							   prei = seg[idVehi].Trip[preTi].lastCus;
//							   cStartS = depart[prei];
//							}
//						}
//						varcosti += (problem->c[prei][sucj] - problem->c[prei][i]);
//					}
//
//					varvioTWCi = 0;
//					idcur = prei;
//					if (sucj >0)
//					{
//						idnext = sucj;
//						while (idcur != lastCOLDj) //check from previ till the end of the trip j
//						{
//							cArrTime = cStartS + problem->c[idcur][idnext];
//							temp = cArrTime - problem->node[idnext].eTW;
//							if (temp > eps)
//							{
//								if (vioTWCus[idnext] > eps)
//								{
//									varvioTWCi += (temp - vioTWCus[idnext]);
//									cStartS = depart[lastCOLDj];
//									idcur = lastCOLDj;
//									goto CalConnecti;
//								}
//								varvioTWCi += temp;
//								cStartS = problem->node[idnext].depart;
//							}
//							else 
//							{
//								varvioTWCi -= vioTWCus[idnext];
//								cStartS = PDS_MAX(problem->node[idnext].sTW, cArrTime) + problem->node[idnext].duration;
//							}
//							idcur=idnext; idnext = nextArr[idcur];
//						}
//					}
//					CalConnecti:
//						stop = calChangeCONNECTAtSP_PickTrip_LastCChanged(idcur, idVehi, idTripi, cStartS, varvioTWSPi, varcosti, vioTWSPTRUE);
//			}
//
//			if (stop == 0)
//			{
//				int nextTi = idTripi + 1;
//				if (nextTi < seg[idVehi].numTrips) // Tripi is not the last trip
//				{
//					int firstC_nextT = seg[idVehi].Trip[nextTi].firstCus;
//					if (seg[idVehi].Trip[nextTi].Type == 1)
//					{
//						if (seg[idVehi].Trip[nextTi].assSP == assSPi)
//						{
//							//varvioTWSPi *= 2; already calculated at calChangeCONNECTAtSP_PickTrip_LastCChanged
//							//Update 16/11/2013
//							if (vioTWSPTRUE) cStartS = problem->leaveSP[assSPi][1]; //load only at eTW2
//							else cStartS += problem->nodeSP[assSPi].load;
//							GoThroughVehicle(idVehi, nextTi, varcosti, varvioTWCi, varvioTWSPi, cStartS, assSPi, firstC_nextT);
//						}
//						else // p - asssP -- asssP1 - d
//						{
//							if (calChangeCONNECTAtSP_SPSP(idVehi, nextTi, idTripi, cStartS, varvioTWSPi, varcosti) == 0)
//								GoThroughVehicle(idVehi, nextTi, varcosti, varvioTWCi, varvioTWSPi, cStartS, seg[idVehi].Trip[nextTi].assSP, firstC_nextT);
//						}
//					}
//					else //nextTi is pickup trip OR C2C:
//					{
//						GoThroughVehicle(idVehi, nextTi, varcosti, varvioTWCi, varvioTWSPi, cStartS, assSPi, firstC_nextT);
//					}//end nextTi is pickup trip OR C2C
//				}
//			}
//	}//end Tripi is not empty after move
//
//    Update:
//	    twoOPTstarCus[j][k]->var_vioTWC = varvioTWCi + varvioTWCj;
//		twoOPTstarCus[j][k]->var_vioTWCi = varvioTWCi;
//		twoOPTstarCus[j][k]->var_vioTWCj = varvioTWCj;
//
//		twoOPTstarCus[j][k]->var_vioTWSP = varvioTWSPi + varvioTWSPj;
//		twoOPTstarCus[j][k]->var_vioTWSPi = varvioTWSPi;
//		twoOPTstarCus[j][k]->var_vioTWSPj = varvioTWSPj;
//
//		twoOPTstarCus[j][k]->var_vioCAP = varvioCAP;
//		//cout<<"-->KQ = "<<twoOPTstarCus[j][k]->var_vioCAP<<endl;
//		twoOPTstarCus[j][k]->var_cost = varcosti + varcostj;
//        //twoOPTstarCus[j][k]->var_costi = varcosti;
//		//twoOPTstarCus[j][k]->var_costj = varcostj;
//		if (empty_idVehi) twoOPTstarCus[j][k]->empty = 1;
//		else twoOPTstarCus[j][k]->empty = 0;
//}





//int Solution::CreateNewVeh_DTrip(int idCus)
//{
//	//see on 2/12/2013
//	int i;
//	for (i=0;i<numVeh;i++)
//		if (seg[i].numTrips == 0) break;
//	seg[i].numTrips=1;
//	seg[i].Trip[0].Type = 1;
//	seg[i].Trip[0].coordinate = 0;
//	seg[i].Trip[0].assSP = problem->node[idCus].zone;
//	seg[i].Trip[0].firstCus = idCus;
//	seg[i].Trip[0].lastCus= idCus;
//	seg[i].Trip[0].numCus=1;
//	numVehUsed++;
//    nextArr[idCus]=-1; predArr[idCus]=-1;
//
//	seg[i].Trip[0].leaveSP = problem->leaveSP[seg[i].Trip[0].assSP][4];
//
//	
//	double cArrTime = seg[i].Trip[0].leaveSP + problem->c[seg[i].Trip[0].assSP][idCus];
//	double temp = cArrTime - problem->node[idCus].eTW;
//	if (temp > eps)
//	{
//		vioTWCus[idCus] = temp;
//		FvioTWCus[idCus] = temp; BvioTWCus[idCus] = temp;
//		startS[idCus] = problem->node[idCus].eTW;
//		depart[idCus] = problem->node[idCus].depart;
//	}
//	else
//	{
//		vioTWCus[idCus] = 0;
//		FvioTWCus[idCus] = 0; BvioTWCus[idCus] = 0;
//		startS[idCus] = PDS_MAX(cArrTime, problem->node[idCus].sTW);
//		depart[idCus] = startS[idCus] + problem->node[idCus].duration;
//	}
//   
//	seg[i].Trip[0].endS = depart[idCus];
//    seg[i].Trip[0].cost = problem->c[0][seg[i].Trip[0].assSP] + problem->c[seg[i].Trip[0].assSP][idCus];
//	seg[i].Trip[0].connectCost = problem->c[idCus][0];
//	seg[i].Trip[0].capacity = problem->node[idCus].capacity;
//	seg[i].Trip[0].vioCAP = 0;
//	seg[i].Trip[0].vioTWC = vioTWCus[idCus];
//	seg[i].Trip[0].vioTWSP = 0;
//	seg[i].Trip[0].waitingS = NO_WS;
//	if (seg[i].Trip[0].vioTWC > eps)
//	{
//        seg[i].Trip[0].feasible = 0;
//		seg[i].Trip[0].fitness = seg[i].Trip[0].cost + vioTWCC * seg[i].Trip[0].vioTWC;
//	}
//	else
//	{
//		seg[i].Trip[0].feasible=1;
//	    seg[i].Trip[0].fitness = seg[i].Trip[0].cost;
//	}
//	route_num[idCus]=i; trip_num[idCus]=0;
//	FCAP[idCus]=problem->node[idCus].capacity;
//	BCAP[idCus] = problem->node[idCus].capacity;
//	pos[idCus] = 1;
//	
//	cout<<"NEW VEHICLE: with fit = "<<seg[i].Trip[0].fitness<<"; cost = "<<seg[i].Trip[0].cost<<"; c = "<<problem->c[seg[i].Trip[0].assSP][idCus]<<"; idCus = "<<idCus<<endl;
//	cout<<"sp = "<<problem->node[idCus].zone<<endl;
//	showTripCost(i,0);
//	//UpdateMoveSPNotEmptyVeh(i); CAN XEM
//	return i;
//}

//void Solution::deleteCusDTrip(int idVeh, int idTrip, int idCus)
//{
//	//see on 2/12/2013
//	int pre = predArr[idCus]; int next = nextArr[idCus];
//	int preID = pre; int nextID = next;
//	int assSP = seg[idVeh].Trip[idTrip].assSP;
//	int lastCus = seg[idVeh].Trip[idTrip].lastCus;
//
//    double cStartS,cArrTime,temp;
//
//	int capDEL = problem->node[idCus].capacity;
//	seg[idVeh].Trip[idTrip].capacity -= capDEL;
//	int vioCAPNEW = PDS_MAX(seg[idVeh].Trip[idTrip].capacity - problem->Q,0);
//	int varvioCAP = vioCAPNEW - seg[idVeh].Trip[idTrip].vioCAP;
//	seg[idVeh].Trip[idTrip].vioCAP = vioCAPNEW;
//
//	seg[idVeh].Trip[idTrip].numCus -=1;
//
//	double varcost, varvioTWC;
//    int nextTrip = idTrip + 1;
//	int id;
//	
//    if (nextTrip == seg[idVeh].numTrips) //idCus belongs to the last delivery trip >= 2customers
//	{
//		if (pre <0)  //delete the first cus
//		{
//			cStartS = seg[idVeh].Trip[idTrip].leaveSP;
//			seg[idVeh].Trip[idTrip].firstCus = next;
//		    predArr[next] = -1;
//			preID = assSP;
//			varcost = problem->c[assSP][next] - problem->c[assSP][idCus] - problem->c[idCus][next];
//		}
//		else //pre > 0
//		{
//			cStartS = depart[pre];
//			if (next > 0) //delete the middle cus
//			{
//				varcost = problem->c[pre][next] - problem->c[pre][idCus] - problem->c[idCus][next];
//				nextArr[pre] = next; predArr[next] = pre;
//			}
//			else //delete the last cus
//			{	
//				varcost = problem->c[pre][0] - problem->c[pre][idCus] - problem->c[idCus][0];
//				seg[idVeh].Trip[idTrip].lastCus = pre;
//				seg[idVeh].Trip[idTrip].connectCost = problem->c[pre][0];
//				nextArr[pre] = -1;
//			}
//		}
//
//		while (nextID >0)
//		{
//			cArrTime = cStartS + problem->c[preID][nextID]; //arrTime at customer nextID
//			cStartS = PDS_MAX(cArrTime, problem->node[nextID].sTW);
//            if (PDSDIF(cStartS, startS[nextID]) == 0) //it means varvioTWCus[curC] =0 
//			{
//				temp = cStartS - problem->node[nextID].eTW;
//				if (temp > eps) vioTWCus[nextID] = temp;
//				else vioTWCus[nextID] = 0;
//
//				//Update BvioTWCus from nextID to firstCus
//				id = nextArr[nextID];
//				if (id < 0) BvioTWCus[nextID] = vioTWCus[nextID];
//				else BvioTWCus[nextID] = BvioTWCus[id] + vioTWCus[nextID];
//				id = nextID;
//				while (preID != pre)
//				{
//					BvioTWCus[preID] = BvioTWCus[id] + vioTWCus[preID];
//					id = preID; preID = predArr[id];
//				}
//				
//				//update BCAP from pre to firstCus
//				id = next;
//				while (preID > 0)
//				{
//					BvioTWCus[preID] = BvioTWCus[id] + vioTWCus[preID];
//					BCAP[preID] -= capDEL;
//					id = preID; preID = predArr[id];
//				}
//				//update FCAP, FvioTWCus from nextID to lastCus:
//				id = nextID; preID = predArr[nextID];
//				do
//				{
//					FCAP[id] -= capDEL;
//					FvioTWCus[id] = FvioTWCus[preID] + vioTWCus[id];
//					preID = id; id = nextArr[id];
//				}while (id > 0);
//				//preID now points to lastCus
//				varvioTWC = FvioTWCus[preID] - seg[idVeh].Trip[idTrip].vioTWC;
//				seg[idVeh].Trip[idTrip].vioTWC = FvioTWCus[preID];
//				goto Update;
//			}
//			temp = cStartS - problem->node[nextID].eTW;
//			if (temp > eps)
//			{
//				if (vioTWCus[nextID] > eps) 
//				{
//					vioTWCus[nextID] = temp;
//					//Update BvioTWCus from nextID to firstCus
//					id = nextArr[nextID];
//					if (id < 0) BvioTWCus[nextID] = vioTWCus[nextID];
//					else BvioTWCus[nextID] = BvioTWCus[id] + vioTWCus[nextID];
//					id = nextID;
//					while (preID != pre)
//					{
//						BvioTWCus[preID] = BvioTWCus[id] + vioTWCus[preID];
//						id = preID; preID = predArr[id];
//					}
//					//update BCAP from pre to firstCus:
//					id = next;
//					while (preID > 0)
//					{
//						BvioTWCus[preID] = BvioTWCus[id] + vioTWCus[preID];
//						BCAP[preID] -= capDEL;
//						id = preID; preID = predArr[id];
//					}
//					//Update FCAP and FvioTWCus from nextID to lastCus
//					id = nextID; preID = predArr[nextID];
//					do
//					{
//						FCAP[id] -= capDEL;
//						FvioTWCus[id] = FvioTWCus[preID] + vioTWCus[id];
//						preID = id; id = nextArr[id];
//					}while (id > 0);
//					//preID now points to lastCus
//					varvioTWC = FvioTWCus[preID] - seg[idVeh].Trip[idTrip].vioTWC;
//					seg[idVeh].Trip[idTrip].vioTWC = FvioTWCus[preID];
//					goto Update;
//				}
//				vioTWCus[nextID] = temp;
//				FvioTWCus[nextID] = FvioTWCus[preID] + temp;
//				cStartS = problem->node[nextID].eTW;
//			}
//			else 
//			{
//				vioTWCus[nextID] = 0;
//				FvioTWCus[nextID] = FvioTWCus[preID];
//			}
//			startS[nextID] = cStartS;
//			cStartS += problem->node[nextID].duration;
//			depart[nextID] = cStartS;
//			FCAP[nextID] -= capDEL;
//			preID = nextID; nextID = nextArr[nextID];
//		}
//		seg[idVeh].Trip[idTrip].endS = cStartS;
//		varvioTWC = FvioTWCus[preID] - seg[idVeh].Trip[idTrip].vioTWC;
//        seg[idVeh].Trip[idTrip].vioTWC = FvioTWCus[preID];
//		//preID now points to the last cus:
//		//Update BCAP from pre to firstCus
//		//Update BvioTWCus from lastCus to firstCus
//		if (next > 0)
//		{
//			BvioTWCus[preID] = vioTWCus[preID];
//			id = predArr[preID];
//			while (id != pre)
//			{
//				BvioTWCus[id] = BvioTWCus[preID] + vioTWCus[id];
//				preID = id; id = predArr[id];
//			}
//			while (id > 0)
//			{
//				BvioTWCus[id] = BvioTWCus[preID] + vioTWCus[id];
//				BCAP[id] -= capDEL;
//				preID = id; id = predArr[id];
//			}
//		}
//		else //delete the last cus:
//		{
//			BvioTWCus[preID] = vioTWCus[preID];
//			BCAP[preID] -= capDEL;
//			id = predArr[preID];
//			while (id > 0)
//			{
//				BvioTWCus[id] = BvioTWCus[preID] + vioTWCus[id];
//				BCAP[id] -= capDEL; //ok
//				preID = id; id = predArr[id];
//			}
//		}
//
//   Update:
//		seg[idVeh].Trip[idTrip].cost += varcost;
//		double varFIT = varcost + VCAP * varvioCAP + VTWCUS * varvioTWC;
//		if (FvioTWCus[seg[idVeh].Trip[idTrip].lastCus] > eps || vioCAPNEW > 0 || seg[idVeh].Trip[idTrip].vioTWSP > eps)
//		{
//			seg[idVeh].Trip[idTrip].feasible = 0;
//			seg[idVeh].Trip[idTrip].fitness +=  varFIT;
//		}
//		else
//		{
//			seg[idVeh].Trip[idTrip].feasible = 1;
//			seg[idVeh].Trip[idTrip].fitness = seg[idVeh].Trip[idTrip].cost;
//		}
//		seg[idVeh].cost += varcost; seg[idVeh].fitness += varFIT; seg[idVeh].vioCAP += varvioCAP; seg[idVeh].vioTWC += varvioTWC;
//		cost += varcost; fitness += varFIT; vioCAP += varvioCAP; vioTWC += varvioTWC;
//	}
//	else //vehicle has >= 2 trips, delivery trip >= 2 customers not the last trip:
//	{
//			if (pre <0)  //delete the first cus
//			{
//				cStartS = seg[idVeh].Trip[idTrip].leaveSP;
//				seg[idVeh].Trip[idTrip].firstCus = next;
//				predArr[next] = -1;
//				preID = assSP;
//				varcost = problem->c[assSP][next] - problem->c[assSP][idCus] - problem->c[idCus][next];
//			}
//			else 
//			{
//				cStartS = depart[pre];
//				if (next > 0)
//					varcost = problem->c[pre][next] - problem->c[pre][idCus] - problem->c[idCus][next];
//			}
//			while (nextID >0)
//			{
//				cArrTime = cStartS + problem->c[preID][nextID]; //arrTime at customer nextID
//				cStartS = PDS_MAX(cArrTime, problem->node[nextID].sTW);
//				cStartS = PDS_MAX(cArrTime, problem->node[nextID].sTW);
//				if (PDSDIF(cStartS, startS[nextID])==0) //it means varvioTWCus[nextID] =0 if cStartS != node[nextID].eTW
//				{
//					temp = cStartS - problem->node[nextID].eTW;
//					if (temp > eps) vioTWCus[nextID] = temp;
//					else vioTWCus[nextID] = 0;
//
//					//Update BvioTWCus from nextID to the firstCus
//					id = nextArr[nextID];
//					if (id < 0) BvioTWCus[nextID] = vioTWCus[nextID];
//					else BvioTWCus[nextID] = BvioTWCus[id] + vioTWCus[nextID];
//					id = nextID;
//					while (preID != pre)
//					{
//						BvioTWCus[preID] = BvioTWCus[id] + vioTWCus[preID];
//						id = preID; preID = predArr[id];
//					}
//
//					//Update BCAP from pre to firstCus
//					id = next;
//					while (preID > 0)
//					{
//						BvioTWCus[preID] = BvioTWCus[id] + vioTWCus[preID];
//						BCAP[preID] -= capDEL;
//						id = preID; preID = predArr[id];
//					}
//					//Update FCAP, FvioTWCus from nextID to lastCus
//					id = nextID; preID = predArr[id];
//					do
//					{
//						FCAP[id] -= capDEL;
//						FvioTWCus[id] = FvioTWCus[preID] + vioTWCus[id];
//						preID = id; id = nextArr[id];
//					}while (id > 0);
//					//preID now points to lastCus
//					varvioTWC = FvioTWCus[preID] - seg[idVeh].Trip[idTrip].vioTWC;
//					seg[idVeh].Trip[idTrip].vioTWC = FvioTWCus[preID];
//					goto Update1;
//				}
//				temp = cStartS - problem->node[nextID].eTW;
//				if (temp > eps)
//				{
//					if (vioTWCus[nextID] > eps) 
//					{
//						vioTWCus[nextID] = temp;
//						//Update BvioTWCus from nextID to the firstCus
//						id = nextArr[nextID];
//						if (id < 0) BvioTWCus[nextID] = vioTWCus[nextID];
//						else BvioTWCus[nextID] = BvioTWCus[id] + vioTWCus[nextID];
//						id = nextID;
//						while (preID != pre)
//						{
//							BvioTWCus[preID] = BvioTWCus[id] + vioTWCus[preID];
//							id = preID; preID = predArr[id];
//						}
//						//Update BCAP from pre to firstCus
//						id = next;
//						while (preID > 0)
//						{
//							BvioTWCus[preID] = BvioTWCus[id] + vioTWCus[preID];
//							BCAP[preID] -= capDEL;
//							id = preID; preID = predArr[id];
//						}
//
//						//Update FCAP and FvioTWCus from nextID to lastCus
//						id = nextID; preID = predArr[nextID];
//						do
//						{
//							FCAP[id] -= capDEL;
//							FvioTWCus[id] = FvioTWCus[preID] + vioTWCus[id];
//							preID = id; id = nextArr[id];
//						}while (id > 0);
//						varvioTWC = FvioTWCus[preID] - seg[idVeh].Trip[idTrip].vioTWC;
//						seg[idVeh].Trip[idTrip].vioTWC = FvioTWCus[preID];
//
//						goto Update1;
//					}
//					vioTWCus[nextID] = temp;
//					FvioTWCus[nextID] = FvioTWCus[preID] + temp;
//					cStartS = problem->node[nextID].eTW;
//				}
//				else 
//				{
//					vioTWCus[nextID] = 0;
//					FvioTWCus[nextID] = FvioTWCus[preID];
//				}
//				startS[nextID] = cStartS;
//				cStartS += problem->node[nextID].duration;
//				depart[nextID] = cStartS;
//				FCAP[nextID] -= capDEL;
//				preID = nextID; nextID = nextArr[nextID];
//			}
//			seg[idVeh].Trip[idTrip].endS = cStartS;
//			varvioTWC = FvioTWCus[preID] - seg[idVeh].Trip[idTrip].vioTWC;
//			seg[idVeh].Trip[idTrip].vioTWC = FvioTWCus[preID];
//			//preID now points to lastCus:
//			if (seg[idVeh].Trip[idTrip].vioTWSP > eps || seg[idVeh].Trip[idTrip].vioCAP > 0 || seg[idVeh].Trip[idTrip].vioTWC > eps)
//				seg[idVeh].Trip[idTrip].feasible = 0;
//			else
//				seg[idVeh].Trip[idTrip].feasible = 1;
//
//			//Update BvioTWCus from lastCus to the firstCus
//			//Update BCAP from pre to firstCus
//			if (next > 0) //not delete the lastCus
//			{
//				BvioTWCus[preID] = vioTWCus[preID];
//				id = predArr[preID];
//				while (id != pre)
//				{
//					BvioTWCus[id] = BvioTWCus[preID] + vioTWCus[id];
//					preID = id; id = predArr[id];
//				}
//				while (id > 0)
//				{
//					BvioTWCus[id] = BvioTWCus[preID] + vioTWCus[id];
//					BCAP[id] -= capDEL;
//					preID = id; id = predArr[id];
//				}
//
//				preID = seg[idVeh].Trip[idTrip].lastCus;
//				if (seg[idVeh].Trip[nextTrip].Type == 1) //nextTrip is delivery trip, not delete the last cus of idTrip
//				{
//					bool stop = updateChangeCONNECTAtSP_DD(preID, idVeh, nextTrip, idTrip, varvioCAP, varvioTWC, varcost);
//					if (stop == 0)
//						UpdateVehicle(idVeh, nextTrip, seg[idVeh].Trip[nextTrip].assSP, seg[idVeh].Trip[nextTrip].leaveSP, varvioCAP, seg[idVeh].numTrips - 1);
//					goto Update2;
//				}
//				else //next Trip is (pickup OR C2C), not delete the last cus of idTrip
//				{
//					double varFIT = varcost + VCAP * varvioCAP + VTWCUS * varvioTWC;
//					seg[idVeh].Trip[idTrip].cost += varcost;
//					seg[idVeh].Trip[idTrip].fitness += varFIT;
//
//					UpdateVehicle(idVeh, nextTrip, preID, seg[idVeh].Trip[idTrip].endS, varvioCAP, seg[idVeh].numTrips - 1);
//					goto Update2;
//				}//end nextTrip is pickup, not delete the last cus of idTrip
//			}
//			else //delete the lastCus:
//			{
//				BvioTWCus[preID] = vioTWCus[preID];
//				BCAP[preID] -= capDEL;
//				id = predArr[preID];
//				while (id > 0)
//				{
//					BvioTWCus[id] = BvioTWCus[preID] + vioTWCus[id];
//					BCAP[id] -= capDEL;
//					preID = id; id = predArr[preID];
//				}
//				if (seg[idVeh].Trip[nextTrip].Type == 1) //nextTrip is delivery trip, delete the last cus of idTrip:
//				{
//					varcost = -problem->c[pre][idCus];
//					bool stop = calChangeCONNECTAtSP_DD_LastCChanged(idCus, pre, idVeh, nextTrip, idTrip, varvioCAP, varvioTWC,varcost); //for deleteCusD procedure
//					if (stop == 0)
//						UpdateVehicle(idVeh, nextTrip, seg[idVeh].Trip[nextTrip].assSP, seg[idVeh].Trip[nextTrip].leaveSP, varvioCAP, seg[idVeh].numTrips - 1);
//					goto Update2;
//				}
//				else //nextTrip is (pickup OR C2C), delete the last cus of idTrip
//				{
//					int firstC_nextT = seg[idVeh].Trip[nextTrip].firstCus;
//					varcost = problem->c[pre][firstC_nextT] - problem->c[pre][idCus] - problem->c[idCus][firstC_nextT];
//					seg[idVeh].Trip[idTrip].connectCost = problem->c[pre][firstC_nextT];
//					seg[idVeh].Trip[idTrip].cost += varcost;
//					double varFIT = varcost + VCAP * varvioCAP + VTWCUS * varvioTWC;
//					seg[idVeh].Trip[idTrip].fitness += varFIT;
//					UpdateVehicle(idVeh, nextTrip, pre, seg[idVeh].Trip[idTrip].endS, varvioCAP,seg[idVeh].numTrips - 1);
//					goto Update2;
//				}//end nextTrip is pickup, delete the last cus of idTrip
//			}
//   Update1: //this happened when not delete the last cus
//			double varFIT = varcost + VCAP * varvioCAP + VTWCUS * varvioTWC;
//			seg[idVeh].Trip[idTrip].cost += varcost;
//			seg[idVeh].Trip[idTrip].fitness += varFIT;
//			if (seg[idVeh].Trip[idTrip].vioTWSP > eps || seg[idVeh].Trip[idTrip].vioCAP > 0 || seg[idVeh].Trip[idTrip].vioTWC > eps)
//				seg[idVeh].Trip[idTrip].feasible = 0;
//			else
//				seg[idVeh].Trip[idTrip].feasible = 1;
//			seg[idVeh].cost += varcost; seg[idVeh].fitness += varFIT; 
//			seg[idVeh].vioCAP += varvioCAP; seg[idVeh].vioTWC += varvioTWC;
//			cost += varcost; fitness += varFIT; vioCAP += varvioCAP; vioTWC += varvioTWC;
//	}//end vehicle has >= 2 trips, delivery trip >= 2 customers, not the last trip
//
//Update2:
//    UpdatePos(idVeh, idTrip);
//	bool stop = checkTripD_ALLFIELDS(idVeh, idTrip);
//	if (stop)
//	{
//	  cout<<"STOP AT deleteCusDTrip @IT = "<<IT<<endl;
//	  exit(-1);
//	}
//	//return 0;
//}

//void Solution::insertCusDTrip(int insert_after, int IDinsert, int idVeh, int idTrip) //insert IDinsert after insert_after: note that insert_after is always a customer, so don't need tocheck if it is startSP or endSP or not
//{
//	//see on 2/12/2013
//    //cout<<"Cost old = "<<seg[idVeh].leg[idLeg].cost<<"; fitold = "<<seg[idVeh].leg[idLeg].fitness<<endl; 
//	route_num[IDinsert] = idVeh; trip_num[IDinsert] = idTrip;
//    
//	//1. Update capacity, numCus, vio_CAP
//	int capINS = problem->node[IDinsert].capacity;
//	seg[idVeh].Trip[idTrip].capacity += capINS;
//	int vioCAPNEW = PDS_MAX(seg[idVeh].Trip[idTrip].capacity - problem->Q,0);
//	int varvioCAP = vioCAPNEW - seg[idVeh].Trip[idTrip].vioCAP;
//	seg[idVeh].Trip[idTrip].vioCAP = vioCAPNEW;
//	
//	seg[idVeh].Trip[idTrip].numCus += 1;
//
//	int assSP = seg[idVeh].Trip[idTrip].assSP; 
//	int lastCOLD = seg[idVeh].Trip[idTrip].lastCus;
//	int next = nextArr[insert_after];
//	int nextTrip = idTrip + 1;
//	double varcost, varvioTWC, cStartS, temp, cArrTime;
//	int id;
//
//
//    if (nextTrip == seg[idVeh].numTrips) //idCus belongs to the last delivery trip >= 2customers
//	{
//		if (next > 0)
//		{
//			varcost = problem->c[insert_after][IDinsert] + problem->c[IDinsert][next] - problem->c[insert_after][next];
//            nextArr[insert_after] = IDinsert; predArr[IDinsert] = insert_after;
//			nextArr[IDinsert] = next; predArr[next] = IDinsert;
//		}
//		else //insert at the end of the trip
//		{
//			varcost = problem->c[insert_after][IDinsert] + problem->c[IDinsert][0] - problem->c[insert_after][0];
//			nextArr[insert_after] = IDinsert; predArr[IDinsert] = insert_after;
//			nextArr[IDinsert] = -1;
//			seg[idVeh].Trip[idTrip].lastCus = IDinsert;
//			seg[idVeh].Trip[idTrip].connectCost = problem->c[IDinsert][0];
//		}
//		FCAP[IDinsert] = FCAP[insert_after] + capINS;
//		cArrTime = depart[insert_after] + problem->c[insert_after][IDinsert];
//		temp = cArrTime - problem->node[IDinsert].eTW;
//		if (temp > eps)
//		{
//			vioTWCus[IDinsert] = temp;
//			FvioTWCus[IDinsert] = FvioTWCus[insert_after] + temp;
//			startS[IDinsert] = problem->node[IDinsert].eTW;
//			depart[IDinsert] = problem->node[IDinsert].depart;
//		}
//		else
//		{
//			vioTWCus[IDinsert] = 0;
//			FvioTWCus[IDinsert] = FvioTWCus[insert_after];
//			startS[IDinsert] = PDS_MAX(cArrTime, problem->node[IDinsert].sTW);
//			depart[IDinsert] = startS[IDinsert] + problem->node[IDinsert].duration;
//		}
//		cStartS = depart[IDinsert];
//		int nextID = next; int preID = IDinsert;
//		while (nextID >0)
//		{
//			cArrTime = cStartS + problem->c[preID][nextID]; //arrTime at customer nextID
//			cStartS = PDS_MAX(cArrTime, problem->node[nextID].sTW);
//            if (PDSDIF(cStartS, startS[nextID])==0) //it means varvioTWCus[curC] =0 
//			{
//				temp = cStartS - problem->node[nextID].eTW;
//				if (temp > eps) vioTWCus[nextID] = temp;
//				else vioTWCus[nextID] = 0;
//
//				//Update BvioTWCus from nextID to firstCus
//				//Update BCAP from IDinsert to firstCus
//				//Update FCAP, FvioTWCus from nextID to lastCus
//				id = nextArr[nextID];
//				if (id < 0) BvioTWCus[nextID] = vioTWCus[nextID];
//				else BvioTWCus[nextID] = BvioTWCus[id] + vioTWCus[nextID];
//
//				id = nextID;
//				while (preID != IDinsert)
//				{
//					BvioTWCus[preID] = BvioTWCus[id] + vioTWCus[preID];
//					id = preID; preID = predArr[id];
//				}
//
//				//update BCAP and BvioTWCus at IDinsert
//				BvioTWCus[IDinsert] = BvioTWCus[next] + vioTWCus[IDinsert];
//				BCAP[IDinsert] = BCAP[next] + capINS;
//				//update BCAP from insert_after to firstCus
//				preID = insert_after; id = IDinsert;
//				do
//				{
//					BvioTWCus[preID] = BvioTWCus[id] + vioTWCus[preID];
//					BCAP[preID] += capINS;
//					id = preID; preID = predArr[id];
//				}while (preID > 0);
//				//update FCAP, FvioTWCus from nextID to lastCus:
//				id = nextID; preID = predArr[nextID];
//				do
//				{
//					FCAP[id] += capINS;
//					FvioTWCus[id] = FvioTWCus[preID] + vioTWCus[id];
//					preID = id; id = nextArr[id];
//				}while (id > 0);
//				//preID now points to the last cus
//				varvioTWC = FvioTWCus[preID] - seg[idVeh].Trip[idTrip].vioTWC; 
//				seg[idVeh].Trip[idTrip].vioTWC = FvioTWCus[preID];
//				goto Update;
//			}
//			temp = cStartS - problem->node[nextID].eTW;
//			if (temp > eps)
//			{
//				if (vioTWCus[nextID] > eps) 
//				{
//					vioTWCus[nextID] = temp;
//					//Update BvioTWCus from nextID to firstCus
//					//Update BCAP from IDinsert to firstCus
//					//Update FCAP, FvioTWCus from nextID to lastCus
//					id = nextArr[nextID];
//					if (id < 0) BvioTWCus[nextID] = vioTWCus[nextID];
//					else BvioTWCus[nextID] = BvioTWCus[id] + vioTWCus[nextID];
//
//					id = nextID;
//					while (preID != IDinsert)
//					{
//						BvioTWCus[preID] = BvioTWCus[id] + vioTWCus[preID];
//						id = preID; preID = predArr[id];
//					}
//					//Update BCAP and BvioTWCus at IDinsert
//					BCAP[IDinsert] = BCAP[next] + capINS;
//					BvioTWCus[IDinsert] = BvioTWCus[next] + vioTWCus[IDinsert];
//
//					//update BCAP from insert_after to firstCus:
//					preID = insert_after; id = IDinsert;
//					do
//					{
//						BvioTWCus[preID] = BvioTWCus[id] + vioTWCus[preID];
//						BCAP[preID] += capINS;
//						id = preID; preID = predArr[id];
//					}while (preID > 0);
//
//					//Update FCAP and FvioTWCus from nextID to lastCus
//					id = nextID; preID = predArr[nextID];
//					do
//					{
//						FCAP[id] += capINS;
//						FvioTWCus[id] = FvioTWCus[preID] + vioTWCus[id];
//						preID = id; id = nextArr[id];
//					}while (id > 0);
//					//preID now points to the last cus
//					varvioTWC = FvioTWCus[preID] - seg[idVeh].Trip[idTrip].vioTWC;
//					seg[idVeh].Trip[idTrip].vioTWC = FvioTWCus[preID];
//					goto Update;
//				}
//				vioTWCus[nextID] = temp;
//				FvioTWCus[nextID] = FvioTWCus[preID] + temp;
//				cStartS = problem->node[nextID].eTW;
//			}
//			else 
//			{
//				vioTWCus[nextID] = 0;
//				FvioTWCus[nextID] = FvioTWCus[preID];
//			}
//			startS[nextID] = cStartS;
//			cStartS += problem->node[nextID].duration;
//			depart[nextID] = cStartS;
//			FCAP[nextID] += capINS;
//			preID = nextID; nextID = nextArr[nextID];
//		}
//		seg[idVeh].Trip[idTrip].endS = cStartS;
//		varvioTWC = FvioTWCus[preID] - seg[idVeh].Trip[idTrip].vioTWC;
//        seg[idVeh].Trip[idTrip].vioTWC = FvioTWCus[preID];
//		//preID now points to the last cus:
//		//Update BCAP from IDinsert to firstCus
//		//Update BvioTWCus from lastCus to firstCus
//		if (next > 0)
//		{
//			BvioTWCus[preID] = vioTWCus[preID];
//			id = predArr[preID];
//			while (id != IDinsert)
//			{
//				BvioTWCus[id] = BvioTWCus[preID] + vioTWCus[id];
//				preID = id; id = predArr[id];
//			}
//			BvioTWCus[IDinsert] = BvioTWCus[preID] + vioTWCus[IDinsert];
//			BCAP[IDinsert] = BCAP[preID] + capINS;
//			id = predArr[IDinsert]; preID = IDinsert;
//			while (id > 0)
//			{
//				BvioTWCus[id] = BvioTWCus[preID] + vioTWCus[id];
//				BCAP[id] += capINS;
//				preID = id; id = predArr[id];
//			}
//		}
//		else //insert at the end of the trip:
//		{
//			BvioTWCus[preID] = vioTWCus[preID];
//			BCAP[preID] = capINS;
//			id = predArr[preID];
//			while (id > 0)
//			{
//				BvioTWCus[id] = BvioTWCus[preID] + vioTWCus[id];
//				BCAP[id] += capINS;
//				preID = id; id = predArr[id];
//			}
//		}
//
//   Update:
//		seg[idVeh].Trip[idTrip].cost += varcost;
//		double varFIT = varcost + VCAP * varvioCAP + VTWCUS * varvioTWC;
//		if (FvioTWCus[seg[idVeh].Trip[idTrip].lastCus] > eps || vioCAPNEW > 0 || seg[idVeh].Trip[idTrip].vioTWSP > eps)
//		{
//			seg[idVeh].Trip[idTrip].feasible = 0;
//			seg[idVeh].Trip[idTrip].fitness +=  varFIT;
//		}
//		else
//		{
//			seg[idVeh].Trip[idTrip].feasible = 1;
//			seg[idVeh].Trip[idTrip].fitness = seg[idVeh].Trip[idTrip].cost;
//		}
//		seg[idVeh].cost += varcost; seg[idVeh].fitness += varFIT; seg[idVeh].vioCAP += varvioCAP; seg[idVeh].vioTWC += varvioTWC;
//		cost += varcost; fitness += varFIT; vioCAP += varvioCAP; vioTWC += varvioTWC;
//	}
//	else //vehicle has >= 2 trips, delivery trip >= 2 customers not the last trip:
//	{
//		if (next > 0) //not insert at the end of the trip
//		{
//			varcost = problem->c[insert_after][IDinsert] + problem->c[IDinsert][next] - problem->c[insert_after][next];
//            nextArr[insert_after] = IDinsert; predArr[IDinsert] = insert_after;
//			nextArr[IDinsert] = next; predArr[next] = IDinsert;
//		}
//		else //insert IDinsert at the end of the trip:
//		{
//			nextArr[insert_after] = IDinsert; predArr[IDinsert] = insert_after;
//			nextArr[IDinsert] = -1;
//			seg[idVeh].Trip[idTrip].lastCus = IDinsert;
//		}//end insert IDinsert at the end of the trip
//
//		FCAP[IDinsert] = FCAP[insert_after] + capINS;
//		cArrTime = depart[insert_after] + problem->c[insert_after][IDinsert];
//		temp = cArrTime - problem->node[IDinsert].eTW;
//		if (temp > eps)
//		{
//			vioTWCus[IDinsert] = temp;
//			FvioTWCus[IDinsert] = FvioTWCus[insert_after] + temp;
//			startS[IDinsert] = problem->node[IDinsert].eTW;
//			depart[IDinsert] = problem->node[IDinsert].depart;
//		}
//		else
//		{
//			vioTWCus[IDinsert] = 0;
//			FvioTWCus[IDinsert] = FvioTWCus[insert_after];
//			startS[IDinsert] = PDS_MAX(cArrTime, problem->node[IDinsert].sTW);
//			depart[IDinsert] = startS[IDinsert] + problem->node[IDinsert].duration;
//		}
//		cStartS = depart[IDinsert];
//		int nextID = next; int preID = IDinsert;
//		while (nextID > 0)
//		{
//			cArrTime = cStartS + problem->c[preID][nextID]; //arrTime at customer nextID
//			cStartS = PDS_MAX(cArrTime, problem->node[nextID].sTW);
//            if (PDSDIF(cStartS, startS[nextID])==0) //it means varvioTWCus[curC] =0 
//			{
//				temp = cStartS - problem->node[nextID].eTW;
//				if (temp > eps) vioTWCus[nextID] = temp;
//				else vioTWCus[nextID] = 0;
//
//				//Update BvioTWCus from nextID to firstCus
//				//Update BCAP from IDinsert to firstCus
//				//Update FCAP, FvioTWCus from nextID to lastCus
//				id = nextArr[nextID];
//				if (id < 0) BvioTWCus[nextID] = vioTWCus[nextID];
//				else BvioTWCus[nextID] = BvioTWCus[id] + vioTWCus[nextID];
//
//				id = nextID;
//				while (preID != IDinsert)
//				{
//					BvioTWCus[preID] = BvioTWCus[id] + vioTWCus[preID];
//					id = preID; preID = predArr[id];
//				}
//
//				//update BCAP and BvioTWCus at IDinsert
//				BvioTWCus[IDinsert] = BvioTWCus[next] + vioTWCus[IDinsert];
//				BCAP[IDinsert] = BCAP[next] + capINS;
//				//update BCAP from insert_after to firstCus
//				preID = insert_after; id = IDinsert;
//				do
//				{
//					BvioTWCus[preID] = BvioTWCus[id] + vioTWCus[preID];
//					BCAP[preID] += capINS;
//					id = preID; preID = predArr[id];
//				}while (preID > 0);
//				//update FCAP, FvioTWCus from nextID to lastCus:
//				id = nextID; preID = predArr[nextID];
//				do
//				{
//					FCAP[id] += capINS;
//					FvioTWCus[id] = FvioTWCus[preID] + vioTWCus[id];
//					preID = id; id = nextArr[id];
//				}while (id > 0);
//				//preID now points to the last cus
//				varvioTWC = FvioTWCus[preID] - seg[idVeh].Trip[idTrip].vioTWC; 
//				seg[idVeh].Trip[idTrip].vioTWC = FvioTWCus[preID];
//				goto Update1;
//			}
//			temp = cStartS - problem->node[nextID].eTW;
//			if (temp > eps)
//			{
//				if (vioTWCus[nextID] > eps) 
//				{
//					vioTWCus[nextID] = temp;
//					//Update BvioTWCus from nextID to firstCus
//					//Update BCAP from IDinsert to firstCus
//					//Update FCAP, FvioTWCus from nextID to lastCus
//					id = nextArr[nextID];
//					if (id < 0) BvioTWCus[nextID] = vioTWCus[nextID];
//					else BvioTWCus[nextID] = BvioTWCus[id] + vioTWCus[nextID];
//
//					id = nextID;
//					while (preID != IDinsert)
//					{
//						BvioTWCus[preID] = BvioTWCus[id] + vioTWCus[preID];
//						id = preID; preID = predArr[id];
//					}
//					//Update BCAP and BvioTWCus at IDinsert
//					BCAP[IDinsert] = BCAP[next] + capINS;
//					BvioTWCus[IDinsert] = BvioTWCus[next] + vioTWCus[IDinsert];
//
//					//update BCAP from insert_after to firstCus:
//					preID = insert_after; id = IDinsert;
//					do
//					{
//						BvioTWCus[preID] = BvioTWCus[id] + vioTWCus[preID];
//						BCAP[preID] += capINS;
//						id = preID; preID = predArr[id];
//					}while (preID > 0);
//
//					//Update FCAP and FvioTWCus from nextID to lastCus
//					id = nextID; preID = predArr[nextID];
//					do
//					{
//						FCAP[id] += capINS;
//						FvioTWCus[id] = FvioTWCus[preID] + vioTWCus[id];
//						preID = id; id = nextArr[id];
//					}while (id > 0);
//					//preID now points to the last cus
//					varvioTWC = FvioTWCus[preID] - seg[idVeh].Trip[idTrip].vioTWC;
//					seg[idVeh].Trip[idTrip].vioTWC = FvioTWCus[preID];
//					goto Update1;
//				}
//				vioTWCus[nextID] = temp;
//				FvioTWCus[nextID] = FvioTWCus[preID] + temp;
//				cStartS = problem->node[nextID].eTW;
//			}
//			else 
//			{
//				vioTWCus[nextID] = 0;
//				FvioTWCus[nextID] = FvioTWCus[preID];
//			}
//			startS[nextID] = cStartS;
//			cStartS += problem->node[nextID].duration;
//			depart[nextID] = cStartS;
//			FCAP[nextID] += capINS;
//			preID = nextID; nextID = nextArr[nextID];
//		}
//		seg[idVeh].Trip[idTrip].endS = cStartS;
//		varvioTWC = FvioTWCus[preID] - seg[idVeh].Trip[idTrip].vioTWC;
//        seg[idVeh].Trip[idTrip].vioTWC = FvioTWCus[preID];
//
//		if (seg[idVeh].Trip[idTrip].vioTWSP > eps || seg[idVeh].Trip[idTrip].vioCAP > 0 || seg[idVeh].Trip[idTrip].vioTWC > eps)
//			seg[idVeh].Trip[idTrip].feasible = 0;
//		else
//			seg[idVeh].Trip[idTrip].feasible = 1;
//
//		//preID now points to the last cus:
//		//Update BCAP from IDinsert to firstCus
//		//Update BvioTWCus from lastCus to firstCus
//		if (next > 0)
//		{
//			BvioTWCus[preID] = vioTWCus[preID];
//			id = predArr[preID];
//			while (id != IDinsert)
//			{
//				BvioTWCus[id] = BvioTWCus[preID] + vioTWCus[id];
//				preID = id; id = predArr[id];
//			}
//			BvioTWCus[IDinsert] = BvioTWCus[preID] + vioTWCus[IDinsert];
//			BCAP[IDinsert] = BCAP[preID] + capINS;
//			id = predArr[IDinsert]; preID = IDinsert;
//			while (id > 0)
//			{
//				BvioTWCus[id] = BvioTWCus[preID] + vioTWCus[id];
//				BCAP[id] += capINS;
//				preID = id; id = predArr[id];
//			}
//
//			preID = seg[idVeh].Trip[idTrip].lastCus;
//			if (seg[idVeh].Trip[nextTrip].Type == 1) //nextTrip is delivery trip, not insert at the end of the idTrip
//			{
//				bool stop = updateChangeCONNECTAtSP_DD(preID, idVeh, nextTrip, idTrip, varvioCAP, varvioTWC, varcost);
//				if (stop == 0)
//					UpdateVehicle(idVeh, nextTrip, seg[idVeh].Trip[nextTrip].assSP, seg[idVeh].Trip[nextTrip].leaveSP, varvioCAP, seg[idVeh].numTrips - 1);
//				goto Update2;
//			}
//			else //next Trip is pickup OR C2C, not insert at the end of the idTrip
//			{
//				double varFIT = varcost + VCAP * varvioCAP + VTWCUS * varvioTWC;
//				seg[idVeh].Trip[idTrip].cost += varcost;
//				seg[idVeh].Trip[idTrip].fitness += varFIT;
//
//				UpdateVehicle(idVeh, nextTrip, preID, seg[idVeh].Trip[idTrip].endS, varvioCAP, seg[idVeh].numTrips - 1);
//				goto Update2;
//			}//end next Trip is pickup OR C2C, not insert at the end of the idTrip
//		}
//		else //insert at the end of the trip:
//		{
//			BvioTWCus[preID] = vioTWCus[preID];
//			BCAP[preID] = capINS;
//			id = predArr[preID];
//			while (id > 0)
//			{
//				BvioTWCus[id] = BvioTWCus[preID] + vioTWCus[id];
//				BCAP[id] += capINS;
//				preID = id; id = predArr[id];
//			}
//
//			if (seg[idVeh].Trip[nextTrip].Type == 1) //nextTrip is delivery trip, insert at the end of the idTrip:
//			{
//				varcost = problem->c[insert_after][IDinsert];
//				bool stop = calChangeCONNECTAtSP_DD_LastCChanged(insert_after, IDinsert, idVeh, nextTrip, idTrip, varvioCAP, varvioTWC, varcost); //for insertCusD procedure
//				if (stop == 0)
//					UpdateVehicle(idVeh, nextTrip, seg[idVeh].Trip[nextTrip].assSP, seg[idVeh].Trip[nextTrip].leaveSP, varvioCAP, seg[idVeh].numTrips - 1);
//				goto Update2;
//			}
//			else //nextTrip is pickup OR C2C, insert at the end of the idTrip
//			{
//				int firstC_nextT = seg[idVeh].Trip[nextTrip].firstCus;
//				varcost = problem->c[insert_after][IDinsert] + problem->c[IDinsert][firstC_nextT]
//				        - problem->c[insert_after][firstC_nextT];
//				seg[idVeh].Trip[idTrip].connectCost = problem->c[IDinsert][firstC_nextT];
//				seg[idVeh].Trip[idTrip].cost += varcost;
//				double varFIT = varcost + VCAP * varvioCAP + VTWCUS * varvioTWC;
//				seg[idVeh].Trip[idTrip].fitness += varFIT;
//				UpdateVehicle(idVeh, nextTrip, IDinsert, seg[idVeh].Trip[idTrip].endS, varvioCAP, seg[idVeh].numTrips - 1);
//				goto Update2;
//			}//end nextTrip is pickup OR C2C, insert at the end of the idTrip
//		}//end insert at the end of the trip
//
//	 Update1: //this happened when not insert at the the last cus
//			double varFIT = varcost + VCAP * varvioCAP + VTWCUS * varvioTWC;
//			seg[idVeh].Trip[idTrip].cost += varcost;
//			seg[idVeh].Trip[idTrip].fitness += varFIT;
//			if (seg[idVeh].Trip[idTrip].vioTWSP > eps || seg[idVeh].Trip[idTrip].vioCAP > 0 || seg[idVeh].Trip[idTrip].vioTWC > eps)
//				seg[idVeh].Trip[idTrip].feasible = 0;
//			else
//				seg[idVeh].Trip[idTrip].feasible = 1;
//			seg[idVeh].cost += varcost; seg[idVeh].fitness += varFIT; 
//			seg[idVeh].vioCAP += varvioCAP; seg[idVeh].vioTWC += varvioTWC;
//			cost += varcost; fitness += varFIT; vioCAP += varvioCAP; vioTWC += varvioTWC;
//	}//end vehicle has >= 2 trips, delivery trip >= 2 customers, not the last trip
//
//Update2:
//    UpdatePos(idVeh, idTrip);
//	bool stop = checkTripD_ALLFIELDS(idVeh, idTrip);
//	if (stop)
//	{
//	  cout<<"STOP AT insertCusDTrip @IT = "<<IT<<endl;
//	  exit(-1);
//	}
//	//return 0;
//}



//void Solution::moveCusDTrip(int j, int i, int idVeh, int idTrip) //move customer i from its current place to place after j: both i and j are at the same trip
//{
//	//see on 2/12/2013
//	int assSP = seg[idVeh].Trip[idTrip].assSP;
//	int lastCOLD = seg[idVeh].Trip[idTrip].lastCus;
//
//	int preID, nextID;
//	int prei = predArr[i]; int suci = nextArr[i];
//	int sucj=nextArr[j];
//
//	double cArrTime, cStartS, varvioTWC, temp, varcost;
//	bool caseij; //=1 if i was before j in the trip
//
//	//2. Update nextArr and predArr, firstCus, lastCus:
//	varcost = problem->c[j][i];
//	if (prei > 0) 
//	{
//		if (suci > 0) 
//		{
//			if (pos[i] < pos[j]) caseij = 1;
//			else caseij = 0;
//			predArr[suci]=prei;
//			varcost += (problem->c[prei][suci] - problem->c[prei][i] - problem->c[i][suci]);
//		}
//		else //i was the last customer of the trip:
//		{
//			seg[idVeh].Trip[idTrip].lastCus = prei;caseij=0;
//			varcost -= problem->c[prei][i];
//		} //i was the last customer of the trip
//		nextArr[prei] = suci;
//		if (caseij) {cStartS = depart[prei]; preID = prei;}
//		else {cStartS = depart[j]; preID = j;}
//		nextArr[j] = i;  predArr[i]=j; nextArr[i] = sucj;
//		nextID = nextArr[preID]; 
//	}
//	else  //customer i was first customer of the trip:
//	{
//		seg[idVeh].Trip[idTrip].firstCus = suci;
//		predArr[suci]=-1;
//		cStartS = seg[idVeh].Trip[idTrip].leaveSP; preID = assSP; 
//		varcost += (problem->c[assSP][suci] - problem->c[assSP][i] - problem->c[i][suci]);
//		nextID = seg[idVeh].Trip[idTrip].firstCus;
//		nextArr[j] = i;  predArr[i]=j; nextArr[i] = sucj;
//	}
//	
//	int nextTrip = idTrip + 1;
//	if (nextTrip == seg[idVeh].numTrips)
//	{
//		if (sucj > 0)
//		{
//			predArr[sucj]=i;
//			varcost += (problem->c[i][sucj] - problem->c[j][sucj]);
//			if (suci <0)
//			{
//				varcost += (problem->c[prei][0] - problem->c[i][0]);
//				seg[idVeh].Trip[idTrip].connectCost = problem->c[prei][0];
//			}
//		}
//		else //i becomes that last cus of idTrip
//		{
//			seg[idVeh].Trip[idTrip].lastCus = i; // insert i at the end of the trip
//			varcost += (problem->c[i][0] - problem->c[j][0]);
//			seg[idVeh].Trip[idTrip].connectCost = problem->c[i][0];
//		}
//	
//		while (nextID >0)
//		{
//			cArrTime = cStartS + problem->c[preID][nextID]; //arrTime at customer nextID
//			temp = cArrTime - problem->node[nextID].eTW;
//			if (temp > eps)
//			{
//				vioTWCus[nextID] = temp;
//				FvioTWCus[nextID] = FvioTWCus[preID] + temp;
//				startS[nextID] = problem->node[nextID].eTW;
//			}
//			else
//			{
//				vioTWCus[nextID] = 0;
//				FvioTWCus[nextID] = FvioTWCus[preID];
//                startS[nextID] = PDS_MAX(cArrTime, problem->node[nextID].sTW);
//			}
//			depart[nextID] = startS[nextID] + problem->node[nextID].duration;
//			cStartS = depart[nextID];
//			FCAP[nextID] = FCAP[preID] + problem->node[nextID].capacity;
//			preID = nextID; nextID = nextArr[nextID];
//		}
//		//preID now points to the last cus
//		seg[idVeh].Trip[idTrip].endS = cStartS;
//		varvioTWC = FvioTWCus[preID] - seg[idVeh].Trip[idTrip].vioTWC;
//        seg[idVeh].Trip[idTrip].vioTWC = FvioTWCus[preID];
//
//		//Update BCAP and BvioTWCus from the lastCus to the firstCus:
//		BCAP[preID] = problem->node[preID].capacity;
//		BvioTWCus[preID] = vioTWCus[preID];
//		int id = predArr[preID];
//		while (id > 0)
//		{
//			BCAP[id] = BCAP[preID] + problem->node[id].capacity;
//			BvioTWCus[id] = BvioTWCus[preID] + vioTWCus[id];
//			preID = id; id = predArr[id];
//		}
//		if (seg[idVeh].Trip[idTrip].vioCAP > 0 || seg[idVeh].Trip[idTrip].vioTWC > eps || seg[idVeh].Trip[idTrip].vioTWSP > eps)
//			 seg[idVeh].Trip[idTrip].feasible = 0;
//		else seg[idVeh].Trip[idTrip].feasible = 1;
//		seg[idVeh].Trip[idTrip].cost += varcost;
//		double varFIT = VTWCUS * varvioTWC + varcost;
//		seg[idVeh].Trip[idTrip].fitness += varFIT;
//		seg[idVeh].cost += varcost; seg[idVeh].fitness += varFIT;
//		cost += varcost; fitness += varFIT;
//	}
//	else //not the last trip
//	{
//		while (nextID >0)
//		{
//			cArrTime = cStartS + problem->c[preID][nextID]; //arrTime at customer nextID
//			temp = cArrTime - problem->node[nextID].eTW;
//			if (temp > eps)
//			{
//				vioTWCus[nextID] = temp;
//				FvioTWCus[nextID] = FvioTWCus[preID] + temp;
//				startS[nextID] = problem->node[nextID].eTW;
//			}
//			else
//			{
//				vioTWCus[nextID] = 0;
//				FvioTWCus[nextID] = FvioTWCus[preID];
//                startS[nextID] = PDS_MAX(cArrTime, problem->node[nextID].sTW);
//			}
//			depart[nextID] = startS[nextID] + problem->node[nextID].duration;
//			cStartS = depart[nextID];
//			FCAP[nextID] = FCAP[preID] + problem->node[nextID].capacity;
//			preID = nextID; nextID = nextArr[nextID];
//		}
//		//preID now points to the last cus
//		seg[idVeh].Trip[idTrip].endS = cStartS;
//		varvioTWC = FvioTWCus[preID] - seg[idVeh].Trip[idTrip].vioTWC;
//        seg[idVeh].Trip[idTrip].vioTWC = FvioTWCus[preID];
//		if (seg[idVeh].Trip[idTrip].vioCAP > 0 || seg[idVeh].Trip[idTrip].vioTWC > eps || seg[idVeh].Trip[idTrip].vioTWSP > eps)
//			 seg[idVeh].Trip[idTrip].feasible = 0;
//		else seg[idVeh].Trip[idTrip].feasible = 1;
//
//		if (sucj > 0)
//		{
//			predArr[sucj]=i;
//			varcost += (problem->c[i][sucj] - problem->c[j][sucj]);
//			if (seg[idVeh].Trip[nextTrip].Type == 1)
//			{
//				if (suci < 0) //prei now the last cus
//				{
//					bool stop = calChangeCONNECTAtSP_DD_LastCChanged(i, prei, idVeh, nextTrip, idTrip, 0, varvioTWC,varcost); //for insertCusD procedure
//					if (stop == 0)
//						UpdateVehicle(idVeh, nextTrip, seg[idVeh].Trip[nextTrip].assSP, seg[idVeh].Trip[nextTrip].leaveSP, 0, seg[idVeh].numTrips - 1);
//				}
//				else //the last cus doesnot change
//				{
//					bool stop = updateChangeCONNECTAtSP_DD(preID, idVeh, nextTrip, idTrip, 0, varvioTWC, varcost);
//					if (stop == 0)
//						UpdateVehicle(idVeh, nextTrip, seg[idVeh].Trip[nextTrip].assSP, seg[idVeh].Trip[nextTrip].leaveSP, 0, seg[idVeh].numTrips - 1);
//				}
//			}
//			else //nextTrip is pickup OR C2C, sucj > 0
//			{
//				if (suci < 0) //prei now the last cus, nextTrip is pickup
//				{
//					int firstC_nextT = seg[idVeh].Trip[nextTrip].firstCus;
//					varcost += (problem->c[prei][firstC_nextT] - problem->c[i][firstC_nextT]);
//					seg[idVeh].Trip[idTrip].connectCost = problem->c[prei][firstC_nextT];
//					seg[idVeh].Trip[idTrip].cost += varcost;
//					double varFIT = varcost + VTWCUS * varvioTWC;
//					seg[idVeh].Trip[idTrip].fitness += varFIT;
//					UpdateVehicle(idVeh, nextTrip, prei, seg[idVeh].Trip[idTrip].endS, 0, seg[idVeh].numTrips - 1);
//				}
//				else //the last cus doesnt change
//				{
//					double varFIT = varcost + VTWCUS * varvioTWC;
//					seg[idVeh].Trip[idTrip].cost += varcost;
//					seg[idVeh].Trip[idTrip].fitness += varFIT;
//					//preID now points to the lastCus
//					UpdateVehicle(idVeh, nextTrip, preID, seg[idVeh].Trip[idTrip].endS, 0, seg[idVeh].numTrips - 1);
//				}
//			}//end nextTrip is pickup OR C2C, sucj > 0
//		}
//		else //i becomes that last cus of idTrip
//		{
//			seg[idVeh].Trip[idTrip].lastCus = i; // insert i at the end of the trip
//			if (seg[idVeh].Trip[nextTrip].Type == 1)
//			{
//				bool stop = calChangeCONNECTAtSP_DD_LastCChanged(j, i, idVeh, nextTrip, idTrip, 0, varvioTWC,varcost); //for insertCusD procedure
//				if (stop == 0)
//					UpdateVehicle(idVeh, nextTrip, seg[idVeh].Trip[nextTrip].assSP, seg[idVeh].Trip[nextTrip].leaveSP, 0, seg[idVeh].numTrips - 1);
//			}
//			else //i becomes the last cus of idTrip, nextTrip is pickup OR C2C
//			{
//				int firstC_nextT = seg[idVeh].Trip[nextTrip].firstCus;
//				varcost += (problem->c[i][firstC_nextT] - problem->c[j][firstC_nextT]);
//				seg[idVeh].Trip[idTrip].connectCost = problem->c[i][firstC_nextT];
//				seg[idVeh].Trip[idTrip].cost += varcost;
//				double varFIT = varcost + VTWCUS * varvioTWC;
//				seg[idVeh].Trip[idTrip].fitness += varFIT;
//				UpdateVehicle(idVeh, nextTrip, i, seg[idVeh].Trip[idTrip].endS, 0, seg[idVeh].numTrips -1);
//			} //end i becomes the last cus of idTrip, nextTrip is pickup OR C2C
//		}//end i becomes that last cus of idTrip
//
//		//Update BCAP and BvioTWCus from the lastCus to the firstCus
//		preID = seg[idVeh].Trip[idTrip].lastCus;
//		BCAP[preID] = problem->node[preID].capacity;
//		BvioTWCus[preID] = vioTWCus[preID];
//		int id = predArr[preID];
//		while (id > 0)
//		{
//			BCAP[id] = BCAP[preID] + problem->node[id].capacity;
//			BvioTWCus[id] = BvioTWCus[preID] + vioTWCus[id];
//			preID = id; id = predArr[id];
//		}
//	}//end not the last trip
//
//    UpdatePos(idVeh, idTrip);
//
//	bool stop = checkVehicle(idVeh);
//	if (stop)
//	{
//	  cout<<"STOP AT moveCusDTrip @IT = "<<IT<<endl;
//	  exit(-1);
//	}
//	//else cout<<"Vehicle "<<idVeh<<" is ok"<<endl;
//
//} //move customer i (neighbor of customer j) after customer j



//void Solution::exchangeCusDTrip(int j, int i) //exchange customer j and its neighbor i: in 1 trip OR 2 trips
//{
//	//see on 2/12/2013
//	int idVehi = route_num[i]; int idTripi = trip_num[i];
//	int idVehj = route_num[j]; int idTripj = trip_num[j];
//	
//	double varvioTWC;
//	double cStartS, cArrTime,temp,varcost;
//	int prei, prej, suci, sucj;
//
//    if (idVehi == idVehj) // customer i and j are in the same trip:
//	{
//	    int assSP = seg[idVehi].Trip[idTripi].assSP; 
//		int lastCOLD = seg[idVehi].Trip[idTripi].lastCus;
//	    
//		if (pos[i] > pos[j]) {int tt=i;i=j;j=tt;} //swap i and j so that i is before j
//		prei = predArr[i]; suci = nextArr[i];
//		prej = predArr[j]; sucj = nextArr[j];
//		int preID,nextID;
//		
//		//2.Update predArr, nextArr, firstCus, lastCus:
//		if (prei > 0) //suci and prej always > 0
//		{
//			cStartS = depart[prei]; 
//			preID = prei;
//			nextArr[prei]=j;predArr[j]=prei;
//			if (i != prej)
//			{
//				varcost = problem->c[prei][j] + problem->c[j][suci] - (problem->c[prei][i] + problem->c[i][suci])
//					   + (problem->c[prej][i] - problem->c[prej][j]);
//				 nextArr[j]=suci;predArr[suci]=j;
//				 nextArr[prej]=i; predArr[i]=prej;
//			}
//			else //-i-j-
//			{
//				varcost = problem->c[prei][j] - problem->c[prei][i];
//				nextArr[j]=i;predArr[i]=j;
//			}
//			nextArr[i] = sucj; 
//			if (sucj > 0)
//			{
//				predArr[sucj]=i;
//				varcost += (problem->c[i][sucj] - problem->c[j][sucj]);
//			}
//			else //j was the last customer --> i is now the last customer
//			{
//                 seg[idVehi].Trip[idTripi].lastCus=i;
//			}
//			nextID = nextArr[preID];
//		}
//		else //i was the first customer --> j is now the first customer: //suci and prej always > 0
//		{
//			predArr[j]= -1;
//			if (i != prej)
//			{
//				varcost = problem->c[assSP][j] + problem->c[j][suci] - (problem->c[assSP][i] + problem->c[i][suci])
//					   + (problem->c[prej][i] - problem->c[prej][j]);
//				nextArr[j] = suci; predArr[suci]=j;
//				nextArr[prej]=i;predArr[i]=prej;
//			}
//			else 
//			{
//				varcost = problem->c[assSP][j] - problem->c[assSP][i];
//				nextArr[j]=i;
//				predArr[i]=j;
//			}
//			seg[idVehi].Trip[idTripi].firstCus=j;
//			nextArr[i]=sucj;
//			if (sucj > 0)
//			{
//				predArr[sucj]=i;
//				varcost += (problem->c[i][sucj] - problem->c[j][sucj]);
//			}
//			else //j was the last customer --> i is now the last customer
//				seg[idVehi].Trip[idTripi].lastCus=i;
//
//			preID = assSP; cStartS = seg[idVehi].Trip[idTripi].leaveSP; 
//			nextID = j;
//		}
//
//		int nextTrip = idTripi + 1;
//		if (nextTrip == seg[idVehi].numTrips)
//		{
//			if (sucj < 0) //j was the last --> i is now the last
//			{
//				varcost += (problem->c[i][0] - problem->c[j][0]);
//				seg[idVehi].Trip[idTripi].connectCost = problem->c[i][0];
//			}
//			while (nextID >0)
//			{
//				cArrTime = cStartS + problem->c[preID][nextID]; //arrTime at customer nextID
//				temp = cArrTime - problem->node[nextID].eTW;
//				if (temp > eps)
//				{
//					vioTWCus[nextID] = temp;
//					FvioTWCus[nextID] = FvioTWCus[preID] + temp;
//					startS[nextID] = problem->node[nextID].eTW;
//				}
//				else
//				{
//					vioTWCus[nextID] = 0;
//					FvioTWCus[nextID] = FvioTWCus[preID];
//					startS[nextID] = PDS_MAX(cArrTime, problem->node[nextID].sTW);
//				}
//				depart[nextID] = startS[nextID] + problem->node[nextID].duration;
//				cStartS = depart[nextID];
//				FCAP[nextID] = FCAP[preID] + problem->node[nextID].capacity;
//				preID = nextID; nextID = nextArr[nextID];
//			}
//			//preID now points to the last cus
//			seg[idVehi].Trip[idTripi].endS = cStartS;
//			varvioTWC = FvioTWCus[preID] - seg[idVehi].Trip[idTripi].vioTWC;
//			seg[idVehi].Trip[idTripi].vioTWC = FvioTWCus[preID];
//
//			//Update BCAP and BvioTWCus, pos from the lastCus to the firstCus:
//			BCAP[preID] = problem->node[preID].capacity;
//			BvioTWCus[preID] = vioTWCus[preID];
//			pos[preID] = seg[idVehi].Trip[idTripi].numCus;
//			int id = predArr[preID];
//			while (id > 0)
//			{
//				BCAP[id] = BCAP[preID] + problem->node[id].capacity;
//				BvioTWCus[id] = BvioTWCus[preID] + vioTWCus[id];
//				pos[id] = pos[preID] - 1;
//				preID = id; id = predArr[id];
//			}
//			if (seg[idVehi].Trip[idTripi].vioCAP > 0 || seg[idVehi].Trip[idTripi].vioTWC > eps || seg[idVehi].Trip[idTripi].vioTWSP > eps)
//				 seg[idVehi].Trip[idTripi].feasible = 0;
//			else seg[idVehi].Trip[idTripi].feasible = 1;
//			seg[idVehi].Trip[idTripi].cost += varcost;
//			double varFIT = VTWCUS * varvioTWC + varcost;
//			seg[idVehi].Trip[idTripi].fitness += varFIT;
//			seg[idVehi].cost += varcost; seg[idVehi].fitness += varFIT;
//			cost += varcost; fitness += varFIT;
//
//		}
//		else //not the last trip
//		{
//			while (nextID >0)
//			{
//				cArrTime = cStartS + problem->c[preID][nextID]; //arrTime at customer nextID
//				temp = cArrTime - problem->node[nextID].eTW;
//				if (temp > eps)
//				{
//					vioTWCus[nextID] = temp;
//					FvioTWCus[nextID] = FvioTWCus[preID] + temp;
//					startS[nextID] = problem->node[nextID].eTW;
//				}
//				else
//				{
//					vioTWCus[nextID] = 0;
//					FvioTWCus[nextID] = FvioTWCus[preID];
//					startS[nextID] = PDS_MAX(cArrTime, problem->node[nextID].sTW);
//				}
//				depart[nextID] = startS[nextID] + problem->node[nextID].duration;
//				cStartS = depart[nextID];
//				FCAP[nextID] = FCAP[preID] + problem->node[nextID].capacity;
//				preID = nextID; nextID = nextArr[nextID];
//			}
//			//preID now points to the last cus
//			seg[idVehi].Trip[idTripi].endS = cStartS;
//			varvioTWC = FvioTWCus[preID] - seg[idVehi].Trip[idTripi].vioTWC;
//			seg[idVehi].Trip[idTripi].vioTWC = FvioTWCus[preID];
//			if (seg[idVehi].Trip[idTripi].vioCAP > 0 || seg[idVehi].Trip[idTripi].vioTWC > eps || seg[idVehi].Trip[idTripi].vioTWSP > eps)
//				 seg[idVehi].Trip[idTripi].feasible = 0;
//			else seg[idVehi].Trip[idTripi].feasible = 1;
//
//			if (seg[idVehi].Trip[nextTrip].Type == 1)
//			{
//				if (sucj > 0) //lastCus doesn't change
//				{
//					bool stop = updateChangeCONNECTAtSP_DD(preID, idVehi, nextTrip, idTripi, 0, varvioTWC, varcost);
//					if (stop == 0)
//						UpdateVehicle(idVehi, nextTrip, seg[idVehi].Trip[nextTrip].assSP, seg[idVehi].Trip[nextTrip].leaveSP, 0, seg[idVehi].numTrips - 1);
//				}
//				else //i is now the last cus, j was the lastCus
//				{
//					bool stop = calChangeCONNECTAtSP_DD_LastCChanged(j, i, idVehi, nextTrip, idTripi, 0, varvioTWC,varcost); //for insertCusD procedure
//					if (stop == 0)
//						UpdateVehicle(idVehi, nextTrip, seg[idVehi].Trip[nextTrip].assSP, seg[idVehi].Trip[nextTrip].leaveSP, 0, seg[idVehi].numTrips - 1);
//				}//end i is now the last cus, j was the lastCus
//			}
//			else //nextTrip is pickup OR C2C
//			{
//				if (sucj > 0) //lastCus doesn't change:
//				{
//					double varFIT = varcost + VTWCUS * varvioTWC;
//					seg[idVehi].Trip[idTripi].cost += varcost;
//					seg[idVehi].Trip[idTripi].fitness += varFIT;
//					//preID now points to the lastCus
//					UpdateVehicle(idVehi, nextTrip, preID, seg[idVehi].Trip[idTripi].endS, 0, seg[idVehi].numTrips - 1);
//				}
//				else //i is now the last cus; j was the last cus
//				{
//					int firstC_nextT = seg[idVehi].Trip[nextTrip].firstCus;
//					varcost += (problem->c[i][firstC_nextT] - problem->c[j][firstC_nextT]); 
//					//cout<<"i = "<<i<<"; firstC = "<<firstC_nextT<<"; connectcostNEW = "<<problem->c[i][firstC_nextT]<<endl;
//                    seg[idVehi].Trip[idTripi].connectCost = problem->c[i][firstC_nextT];
//				    seg[idVehi].Trip[idTripi].cost += varcost;
//				    double varFIT = varcost + VTWCUS * varvioTWC;
//				    seg[idVehi].Trip[idTripi].fitness += varFIT;
//				    UpdateVehicle(idVehi, nextTrip, i, seg[idVehi].Trip[idTripi].endS, 0, seg[idVehi].numTrips - 1);
//				}//end i is now the last cus
//			}///end nextTrip is pickup OR C2C
//			
//			//Update BCAP and BvioTWCus, pos, from the lastCus to the firstCus
//			preID = seg[idVehi].Trip[idTripi].lastCus;
//			BCAP[preID] = problem->node[preID].capacity;
//			BvioTWCus[preID] = vioTWCus[preID];
//			pos[preID] = seg[idVehi].Trip[idTripi].numCus;
//			int id = predArr[preID];
//			while (id > 0)
//			{
//				BCAP[id] = BCAP[preID] + problem->node[id].capacity;
//				BvioTWCus[id] = BvioTWCus[preID] + vioTWCus[id];
//				pos[id] = pos[preID] - 1;
//				preID = id; id = predArr[id];
//			}
//		}//end not the last trip
//		bool stop = checkTripD_ALLFIELDS(idVehi, idTripi);
//		if (stop)
//		{
//		  cout<<"STOP AT exchangeCusDTrip sameTrip @IT = "<<IT<<endl;
//		  exit(-1);
//		}
//	}
//	else //customer i and j are in different trips:
//	{
//		//1. Update capacity, numCus, vio_CAP
//		int assSPi = seg[idVehi].Trip[idTripi].assSP; 
//		int assSPj = seg[idVehj].Trip[idTripj].assSP; 
//		double varcosti, varcostj;
//
//	    //2.Update predArr, nextArr, firstCus, lastCus:
//		prei = predArr[i]; suci = nextArr[i];
//		prej = predArr[j]; sucj = nextArr[j];
//		predArr[j]=prei;
//		if (prei >0) 
//		{
//			nextArr[prei]=j; 
//			varcosti = problem->c[prei][j] - problem->c[prei][i];
//		}
//		else //i was the first customer of the trip --> j is now the first customer of the trip:
//		{
//			seg[idVehi].Trip[idTripi].firstCus=j;
//			varcosti = problem->c[assSPi][j] - problem->c[assSPi][i];
//		}
//		nextArr[j]=suci;
//		if (suci > 0)
//		{
//			predArr[suci]=j;
//			varcosti += (problem->c[j][suci] - problem->c[i][suci]);
//		}
//		else seg[idVehi].Trip[idTripi].lastCus = j; //j is now the last customer of the legi
//		
//		predArr[i]=prej;
//		if (prej >0) 
//		{
//			nextArr[prej]=i;
//			varcostj = problem->c[prej][i] - problem->c[prej][j];
//		}
//		else //j was the first customer of the trip --> i is now the first customer of the trip:
//		{
//			seg[idVehj].Trip[idTripj].firstCus=i;
//			varcostj = problem->c[assSPj][i] - problem->c[assSPj][j];
//		}
//		nextArr[i]=sucj;
//		if (sucj > 0)
//		{
//			predArr[sucj]=i;
//			varcostj += (problem->c[i][sucj] - problem->c[j][sucj]);
//		}
//		else seg[idVehj].Trip[idTripj].lastCus = i; //i is now the last customer of the legj
//		
//		trip_num[i] = idTripj; route_num[i] = idVehj;
//		trip_num[j] = idTripi; route_num[j] = idVehi;
//		//cout<<"CALL SUBexchangeCusDTrip: prei = "<<prei<<"; suci = "<<suci<<";i = "<<i<<"; j = "<<j<<endl;
//		SUBexchangeCusDTrip(idVehi, idTripi, prei, suci, i, j, varcosti); //replace i by j on (idVehi, idTripi)
//		//cout<<"CALL SUBexchangeCusDTrip: prej = "<<prej<<"; sucj = "<<sucj<<";j = "<<j<<"; i = "<<i<<endl;
//		SUBexchangeCusDTrip(idVehj, idTripj, prej, sucj, j, i, varcostj); //replace j by i on (idVehj, idTripj)
//	}//end customer i and j are in different trips
//}

//void Solution::SUBexchangeCusDTrip(int idVeh, int idTrip, int prei, int suci, int i, int j, double varcost) //replace i by j
//{
//	//see on 2/12/2013
//	double cStartS, cArrTime, temp, varvioTWC;
//	int preID, nextID, id;
//
//	int deltaCAP = problem->node[j].capacity - problem->node[i].capacity;
//	seg[idVeh].Trip[idTrip].capacity += deltaCAP;
//	int vioCAPNEW = PDS_MAX(seg[idVeh].Trip[idTrip].capacity - problem->Q, 0);
//	int varvioCAP = vioCAPNEW - seg[idVeh].Trip[idTrip].vioCAP;
//	seg[idVeh].Trip[idTrip].vioCAP = vioCAPNEW;
//	int assSP = seg[idVeh].Trip[idTrip].assSP;
//
//		if (prei > 0) 
//		{
//			//Update at j:
//			FCAP[j] = FCAP[prei] + problem->node[j].capacity;
//			cArrTime = depart[prei] + problem->c[prei][j];
//			temp = cArrTime - problem->node[j].eTW;
//			if (temp > eps)
//			{
//				vioTWCus[j] = temp;
//				FvioTWCus[j] = FvioTWCus[prei] + temp;
//				startS[j] = problem->node[j].eTW;
//				depart[j] = problem->node[j].depart;
//			}
//			else
//			{
//				vioTWCus[j] = 0;
//				FvioTWCus[j] = FvioTWCus[prei];
//				startS[j] = PDS_MAX(cArrTime, problem->node[j].sTW);
//				depart[j] = startS[j] + problem->node[j].duration;
//			}
//		}
//		else 
//		{
//			cStartS = seg[idVeh].Trip[idTrip].leaveSP; 
//			//Update at j:
//			FCAP[j] = problem->node[j].capacity;
//			cArrTime = cStartS + problem->c[assSP][j];
//			temp = cArrTime - problem->node[j].eTW;
//			if (temp > eps)
//			{
//				vioTWCus[j] = temp;
//				FvioTWCus[j] = temp;
//				startS[j] = problem->node[j].eTW;
//				depart[j] = problem->node[j].depart;
//			}
//			else
//			{
//				vioTWCus[j] = 0;
//				FvioTWCus[j] = 0;
//				startS[j] = PDS_MAX(cArrTime, problem->node[j].sTW);
//				depart[j] = startS[j] + problem->node[j].duration;
//			}
//		}
//		cStartS = depart[j]; preID = j; nextID = nextArr[j];
//		//cout<<"DEPART[j="<<j<<"] = "<<cStartS<<"; nextID = "<<nextID<<endl;
//		
//		int nextTrip = idTrip + 1;
//
//		if (nextTrip == seg[idVeh].numTrips)
//		{
//			while (nextID > 0)
//			{
//				cArrTime = cStartS + problem->c[preID][nextID]; //arrTime at customer nextID
//				cStartS = PDS_MAX(cArrTime, problem->node[nextID].sTW);
//				if (PDSDIF(cStartS, startS[nextID])==0) //it means varvioTWCus[nextID] =0 if (cStartS != node[nextID].eTW)
//				{
//					temp = cStartS - problem->node[nextID].eTW;
//					if (temp > eps)
//						vioTWCus[nextID] = temp;
//					else
//						vioTWCus[nextID] = 0;
//					
//					//Update BvioTWCus from nextID to firstCus
//					//Update BCAP from j to firstCus
//					//Update FCAP, FvioTWCus from nextID to lastCus
//					id = nextArr[nextID];
//					if (id < 0) BvioTWCus[nextID] = vioTWCus[nextID];
//					else BvioTWCus[nextID] = BvioTWCus[id] + vioTWCus[nextID];
//
//					id = nextID;
//					while (preID != j)
//					{
//						BvioTWCus[preID] = BvioTWCus[id] + vioTWCus[preID];
//						id = preID; preID = predArr[id];
//					}
//					//update BCAP and BvioTWCus at j
//					BvioTWCus[j] = BvioTWCus[id] + vioTWCus[j];
//					BCAP[j] = BCAP[id] + problem->node[j].capacity;
//
//					//update BCAP from prei = predArr[j] to firstCus
//					preID = prei; id = j;
//					while (preID > 0)
//					{
//						BvioTWCus[preID] = BvioTWCus[id] + vioTWCus[preID];
//						BCAP[preID] += deltaCAP;
//						id = preID; preID = predArr[id];
//					}
//
//					//update FCAP, FvioTWCus from nextID to lastCus:
//					id = nextID; preID = predArr[nextID];
//					do
//					{
//						FCAP[id] += deltaCAP;
//						FvioTWCus[id] = FvioTWCus[preID] + vioTWCus[id];
//						preID = id; id = nextArr[id];
//					}while (id > 0);
//					//preID now points to the last cus
//					varvioTWC = FvioTWCus[preID] - seg[idVeh].Trip[idTrip].vioTWC; 
//					seg[idVeh].Trip[idTrip].vioTWC = FvioTWCus[preID];
//					goto Update;
//				}
//				temp = cStartS - problem->node[nextID].eTW;
//				if (temp > eps)
//				{
//					if (vioTWCus[nextID] > eps) 
//					{
//						vioTWCus[nextID] = temp;
//						//Update BvioTWCus from nextID to firstCus
//						//Update BCAP from j to firstCus
//						//Update FCAP, FvioTWCus from nextID to lastCus
//						id = nextArr[nextID];
//						if (id < 0) BvioTWCus[nextID] = vioTWCus[nextID];
//						else BvioTWCus[nextID] = BvioTWCus[id] + vioTWCus[nextID];
//
//						id = nextID;
//						while (preID != j)
//						{
//							BvioTWCus[preID] = BvioTWCus[id] + vioTWCus[preID];
//							id = preID; preID = predArr[id];
//						}
//						//Update BCAP and BvioTWCus at j
//						BCAP[j] = BCAP[id] + problem->node[j].capacity;
//						BvioTWCus[j] = BvioTWCus[id] + vioTWCus[j];
//
//						//update BCAP from prei to firstCus:
//						preID = prei; id = j;
//						while (preID > 0)
//						{
//							BvioTWCus[preID] = BvioTWCus[id] + vioTWCus[preID];
//							BCAP[preID] += deltaCAP;
//							id = preID; preID = predArr[id];
//						}
//
//						//Update FCAP and FvioTWCus from nextID to lastCus
//						id = nextID; preID = predArr[nextID];
//						do
//						{
//							FCAP[id] += deltaCAP;
//							FvioTWCus[id] = FvioTWCus[preID] + vioTWCus[id];
//							preID = id; id = nextArr[id];
//						}while (id > 0);
//						//preID now points to the last cus
//						varvioTWC = FvioTWCus[preID] - seg[idVeh].Trip[idTrip].vioTWC;
//						seg[idVeh].Trip[idTrip].vioTWC = FvioTWCus[preID];
//						goto Update;
//					}
//					vioTWCus[nextID] = temp;
//					FvioTWCus[nextID] = FvioTWCus[preID] + temp;
//					cStartS = problem->node[nextID].eTW;
//				}
//				else 
//				{
//					vioTWCus[nextID] = 0;
//					FvioTWCus[nextID] = FvioTWCus[preID];
//				}
//				startS[nextID] = cStartS;
//				cStartS += problem->node[nextID].duration;
//				depart[nextID] = cStartS;
//				FCAP[nextID] += deltaCAP;
//				preID = nextID; nextID = nextArr[nextID];
//			}
//			seg[idVeh].Trip[idTrip].endS = cStartS;
//			varvioTWC = FvioTWCus[preID] - seg[idVeh].Trip[idTrip].vioTWC;
//			seg[idVeh].Trip[idTrip].vioTWC = FvioTWCus[preID];
//			//preID now points to the last cus:
//			//Update BCAP from j to firstCus
//			//Update BvioTWCus from lastCus to firstCus
//			if (suci > 0)
//			{
//				BvioTWCus[preID] = vioTWCus[preID];
//				id = predArr[preID];
//				while (id != j)
//				{
//					BvioTWCus[id] = BvioTWCus[preID] + vioTWCus[id];
//					preID = id; id = predArr[id];
//				}
//				BvioTWCus[j] = BvioTWCus[preID] + vioTWCus[j];
//				BCAP[j] = BCAP[preID] + problem->node[j].capacity;
//				id = prei; preID = j;
//				while (id > 0)
//				{
//					BvioTWCus[id] = BvioTWCus[preID] + vioTWCus[id];
//					BCAP[id] += deltaCAP;
//					preID = id; id = predArr[id];
//				}
//			}
//			else //j is now the last cus:
//			{
//				varcost += (problem->c[j][0] - problem->c[i][0]);
//				seg[idVeh].Trip[idTrip].connectCost = problem->c[j][0];
//
//				BvioTWCus[preID] = vioTWCus[preID];
//				BCAP[preID] = problem->node[j].capacity;
//				id = predArr[preID];
//				while (id > 0)
//				{
//					BvioTWCus[id] = BvioTWCus[preID] + vioTWCus[id];
//					BCAP[id] += deltaCAP; //ok
//					preID = id; id = predArr[id];
//				}
//			}
//
//			Update:
//				seg[idVeh].Trip[idTrip].cost += varcost;
//				double varFIT = varcost + VCAP * varvioCAP + VTWCUS * varvioTWC;
//				if (seg[idVeh].Trip[idTrip].vioTWC > eps || seg[idVeh].Trip[idTrip].vioCAP > 0 || seg[idVeh].Trip[idTrip].vioTWSP > eps)
//				{
//					seg[idVeh].Trip[idTrip].feasible = 0;
//					seg[idVeh].Trip[idTrip].fitness +=  varFIT;
//				}
//				else
//				{
//					seg[idVeh].Trip[idTrip].feasible = 1;
//					seg[idVeh].Trip[idTrip].fitness = seg[idVeh].Trip[idTrip].cost;
//				}
//				seg[idVeh].cost += varcost; seg[idVeh].fitness += varFIT; 
//				seg[idVeh].vioCAP += varvioCAP; seg[idVeh].vioTWC += varvioTWC;
//				cost += varcost; fitness += varFIT; vioCAP += varvioCAP; vioTWC += varvioTWC;
//		}
//		else //idTrip not the last trip
//		{
//				while (nextID > 0)
//				{
//					cArrTime = cStartS + problem->c[preID][nextID]; //arrTime at customer nextID
//					cStartS = PDS_MAX(cArrTime, problem->node[nextID].sTW);
//            		if (PDSDIF(cStartS, startS[nextID])==0) //it means varvioTWCus[nextID] =0 
//					{
//						temp = cStartS - problem->node[nextID].eTW;
//						if (temp > eps) vioTWCus[nextID] = temp;
//						else vioTWCus[nextID] = 0;
//
//						//Update BvioTWCus from nextID to firstCus
//						//Update BCAP from j to firstCus
//						//Update FCAP, FvioTWCus from nextID to lastCus
//						id = nextArr[nextID];
//						if (id < 0) BvioTWCus[nextID] = vioTWCus[nextID];
//						else BvioTWCus[nextID] = BvioTWCus[id] + vioTWCus[nextID];
//
//						id = nextID;
//						while (preID != j)
//						{
//							BvioTWCus[preID] = BvioTWCus[id] + vioTWCus[preID];
//							id = preID; preID = predArr[id];
//						}
//					
//						//update BCAP and BvioTWCus at j
//						BvioTWCus[j] = BvioTWCus[id] + vioTWCus[j];
//						BCAP[j] = BCAP[id] + problem->node[j].capacity;
//						//update BCAP from prei to firstCus
//						preID = prei; id = j;
//						while (preID > 0)
//						{
//							BvioTWCus[preID] = BvioTWCus[id] + vioTWCus[preID];
//							BCAP[preID] += deltaCAP;
//							id = preID; preID = predArr[id];
//						}
//						//update FCAP, FvioTWCus from nextID to lastCus:
//						id = nextID; preID = predArr[nextID];
//						do
//						{
//							FCAP[id] += deltaCAP;
//							FvioTWCus[id] = FvioTWCus[preID] + vioTWCus[id];
//							preID = id; id = nextArr[id];
//						}while (id > 0);
//						//preID now points to the last cus
//						varvioTWC = FvioTWCus[preID] - seg[idVeh].Trip[idTrip].vioTWC; 
//						seg[idVeh].Trip[idTrip].vioTWC = FvioTWCus[preID];
//						goto Update1;
//					}
//					temp = cStartS - problem->node[nextID].eTW;
//					if (temp > eps)
//					{
//						if (vioTWCus[nextID] > eps) 
//						{
//							vioTWCus[nextID] = temp;
//							//Update BvioTWCus from nextID to firstCus
//							//Update BCAP from j to firstCus
//							//Update FCAP, FvioTWCus from nextID to lastCus
//							id = nextArr[nextID];
//							if (id < 0) BvioTWCus[nextID] = vioTWCus[nextID];
//							else BvioTWCus[nextID] = BvioTWCus[id] + vioTWCus[nextID];
//
//							id = nextID;
//							while (preID != j)
//							{
//								BvioTWCus[preID] = BvioTWCus[id] + vioTWCus[preID];
//								id = preID; preID = predArr[id];
//							}
//							//Update BCAP and BvioTWCus at j
//							BCAP[j] = BCAP[id] + problem->node[j].capacity;
//							BvioTWCus[j] = BvioTWCus[id] + vioTWCus[j];
//
//							//update BCAP from prei to firstCus:
//							preID = prei; id = j;
//							while (preID > 0)
//							{
//								BvioTWCus[preID] = BvioTWCus[id] + vioTWCus[preID];
//								BCAP[preID] += deltaCAP;
//								id = preID; preID = predArr[id];
//							}
//
//							//Update FCAP and FvioTWCus from nextID to lastCus
//							id = nextID; preID = predArr[nextID];
//							do
//							{
//								FCAP[id] += deltaCAP;
//								FvioTWCus[id] = FvioTWCus[preID] + vioTWCus[id];
//								preID = id; id = nextArr[id];
//							}while (id > 0);
//							//preID now points to the last cus
//							varvioTWC = FvioTWCus[preID] - seg[idVeh].Trip[idTrip].vioTWC;
//							seg[idVeh].Trip[idTrip].vioTWC = FvioTWCus[preID];
//							goto Update1;
//						}
//						vioTWCus[nextID] = temp;
//						FvioTWCus[nextID] = FvioTWCus[preID] + temp;
//						cStartS = problem->node[nextID].eTW;
//					}
//					else 
//					{
//						vioTWCus[nextID] = 0;
//						FvioTWCus[nextID] = FvioTWCus[preID];
//					}
//					startS[nextID] = cStartS;
//					cStartS += problem->node[nextID].duration;
//					depart[nextID] = cStartS;
//					FCAP[nextID] += deltaCAP;
//					preID = nextID; nextID = nextArr[nextID];
//				}
//				seg[idVeh].Trip[idTrip].endS = cStartS;
//				//cout<<"endS of ("<<idVeh<<", "<<idTrip<<") = "<<cStartS<<endl;
//				varvioTWC = FvioTWCus[preID] - seg[idVeh].Trip[idTrip].vioTWC;
//				seg[idVeh].Trip[idTrip].vioTWC = FvioTWCus[preID];
//
//				if (seg[idVeh].Trip[idTrip].vioTWSP > eps || seg[idVeh].Trip[idTrip].vioCAP > 0 || seg[idVeh].Trip[idTrip].vioTWC > eps)
//					seg[idVeh].Trip[idTrip].feasible = 0;
//				else
//					seg[idVeh].Trip[idTrip].feasible = 1;
//
//				//preIDi now points to the last cus:
//				//Update BCAP from j to firstCus
//				//Update BvioTWCus from lastCus to firstCus
//				if (suci > 0)
//				{
//					BvioTWCus[preID] = vioTWCus[preID];
//					id = predArr[preID];
//					while (id != j)
//					{
//						BvioTWCus[id] = BvioTWCus[preID] + vioTWCus[id];
//						preID = id; id = predArr[id];
//					}
//					BvioTWCus[j] = BvioTWCus[preID] + vioTWCus[j];
//					BCAP[j] = BCAP[preID] + problem->node[j].capacity;
//					id = prei; preID = j;
//					while (id > 0)
//					{
//						BvioTWCus[id] = BvioTWCus[preID] + vioTWCus[id];
//						BCAP[id] += deltaCAP;
//						preID = id; id = predArr[id];
//					}
//
//					preID = seg[idVeh].Trip[idTrip].lastCus;
//					if (seg[idVeh].Trip[nextTrip].Type == 1) //nextTrip is delivery trip, doesnot change the last cus of idTrip
//					{
//						//cout<<"NextTrip is delivery trip: endS = "<<seg[idVeh].Trip[idTrip].endS<<"; depart["<<preID<<"] = "<<depart[preID]<<endl;
//						bool stop = updateChangeCONNECTAtSP_DD(preID, idVeh, nextTrip, idTrip, varvioCAP, varvioTWC, varcost);
//						if (stop == 0)
//							UpdateVehicle(idVeh, nextTrip, seg[idVeh].Trip[nextTrip].assSP, seg[idVeh].Trip[nextTrip].leaveSP, varvioCAP, seg[idVeh].numTrips - 1);
//						goto Update2;
//					}
//					else //nextTrip is pickup OR C2C, doesnot change the lastCus of the idTrip
//					{
//						double varFIT = varcost + VCAP * varvioCAP + VTWCUS * varvioTWC;
//						seg[idVeh].Trip[idTrip].cost += varcost;
//						seg[idVeh].Trip[idTrip].fitness += varFIT;
//						//cout<<"NextTrip is pickup trip: endS = "<<seg[idVeh].Trip[idTrip].endS<<"; depart["<<preID<<"] = "<<depart[preID]<<endl;
//						UpdateVehicle(idVeh, nextTrip, preID, seg[idVeh].Trip[idTrip].endS, varvioCAP, seg[idVeh].numTrips - 1);
//						goto Update2;
//					}//end nextTrip is pickup OR C2C, doesnot change the lastCus of the idTrip
//				}
//				else //j is now the last cus of the trip:
//				{
//					BvioTWCus[j] = vioTWCus[j];
//					BCAP[j] = problem->node[j].capacity;
//					id = prei; 
//					while (id > 0)
//					{
//						BvioTWCus[id] = BvioTWCus[preID] + vioTWCus[id];
//						BCAP[id] += deltaCAP; //OK
//						preID = id; id = predArr[id];
//					}
//
//					if (seg[idVeh].Trip[nextTrip].Type == 1) //nextTrip is delivery trip, change the lastCus of the idTrip:
//					{
//						bool stop = calChangeCONNECTAtSP_DD_LastCChanged(i, j, idVeh, nextTrip, idTrip, varvioCAP, varvioTWC, varcost); //for insertCusD procedure
//						if (stop == 0)
//							UpdateVehicle(idVeh, nextTrip, seg[idVeh].Trip[nextTrip].assSP, seg[idVeh].Trip[nextTrip].leaveSP, varvioCAP, seg[idVeh].numTrips - 1);
//						goto Update2;
//					}
//					else //nextTrip is pickup OR C2C, change the lastCus of the idTrip
//					{
//						int firstC_nextT = seg[idVeh].Trip[nextTrip].firstCus;
//						varcost += (problem->c[j][firstC_nextT] - problem->c[i][firstC_nextT]);
//						seg[idVeh].Trip[idTrip].connectCost = problem->c[j][firstC_nextT];
//						seg[idVeh].Trip[idTrip].cost += varcost;
//						double varFIT = varcost + VCAP * varvioCAP + VTWCUS * varvioTWC;
//						seg[idVeh].Trip[idTrip].fitness += varFIT;
//						//cout<<"j = "<<j<<"; NextTrip is pickup trip: endS = "<<seg[idVeh].Trip[idTrip].endS<<"; depart["<<j<<"] = "<<depart[preID]<<endl;
//						UpdateVehicle(idVeh, nextTrip, j, seg[idVeh].Trip[idTrip].endS, varvioCAP, seg[idVeh].numTrips - 1);
//						goto Update2;
//					}//end nextTrip is pickup OR C2C, change the lastCus of the idTrip
//				}//end insert at the end of the trip
//				 Update1: //this happened when i is not the last cus of idTrip
//							double varFIT = varcost + VCAP * varvioCAP + VTWCUS * varvioTWC;
//							seg[idVeh].Trip[idTrip].cost += varcost;
//							seg[idVeh].Trip[idTrip].fitness += varFIT;
//							if (seg[idVeh].Trip[idTrip].vioTWSP > eps || seg[idVeh].Trip[idTrip].vioCAP > 0 || seg[idVeh].Trip[idTrip].vioTWC > eps)
//								seg[idVeh].Trip[idTrip].feasible = 0;
//							else
//								seg[idVeh].Trip[idTrip].feasible = 1;
//							seg[idVeh].cost += varcost; seg[idVeh].fitness += varFIT; 
//							seg[idVeh].vioCAP += varvioCAP; seg[idVeh].vioTWC += varvioTWC;
//							cost += varcost; fitness += varFIT; vioCAP += varvioCAP; vioTWC += varvioTWC;
//		}//end not the lastTrip
//
//		Update2:
//			UpdatePos(idVeh, idTrip);
//			bool stop = checkTripD_ALLFIELDS(idVeh, idTrip);
//			if (stop)
//			{
//			  cout<<"STOP AT SUBexchangeCusDTrip @IT = "<<IT<<endl;
//			  exit(-1);
//			}
//}

//void Solution::twoOPTstarCusDTrip_oneTrip(int j, int i, int idVeh, int idTrip) //2opt* between 2 customer j and its neighbor (i) where j and i are in the same trip
//{    //see on 2/12/2013
//	 //posD[j] < posD[i] 
//	 int assSP = seg[idVeh].Trip[idTrip].assSP;
//
//	 int lastCOLD = seg[idVeh].Trip[idTrip].lastCus;
//	 int sucj = nextArr[j]; int prei = predArr[i];
//	 int suci = nextArr[i]; 
//
//	 int idpre,idcur,idTemp;
//	 double cArrTime, cStartS,temp;
//
//	 double varcost = problem->c[j][i] - problem->c[j][sucj];
//
//	 cArrTime = depart[j] + problem->c[j][i];
//	 //Update i:
//	 temp = cArrTime - problem->node[i].eTW;
//	 if (temp > eps)
//	 {
//		 vioTWCus[i] = temp;
//		 FvioTWCus[i] = FvioTWCus[j] + temp;
//		 startS[i] = problem->node[i].eTW;
//		 depart[i] = problem->node[i].depart;
//	 }
//	 else
//	 {
//		 startS[i] = PDS_MAX(cArrTime, problem->node[i].sTW);
//		 vioTWCus[i] = 0;
//		 FvioTWCus[i] = FvioTWCus[j];
//		 depart[i] = startS[i] + problem->node[i].duration;
//	 }
//	 cStartS = depart[i];
//     nextArr[j] = i; predArr[i] = j; 
//	 FCAP[i] = FCAP[j] + problem->node[i].capacity;
//	 pos[i] = pos[j] + 1;
//
//	 idcur = i; idpre = prei;
//	 while (idpre != j) 
//	 {
//		   cArrTime = cStartS + problem->c[idcur][idpre];
//		   temp = cArrTime - problem->node[idpre].eTW;
//		   if (temp > eps)
//		   {
//			   startS[idpre] = problem->node[idpre].eTW;
//			   depart[idpre] = problem->node[idpre].depart;
//			   vioTWCus[idpre] = temp;
//			   FvioTWCus[idpre] = FvioTWCus[idcur] + temp;
//		   }
//		   else
//		   {
//			   startS[idpre] = PDS_MAX(cArrTime, problem->node[idpre].sTW);
//			   depart[idpre] = startS[idpre] + problem->node[idpre].duration;
//			   vioTWCus[idpre] = 0;
//			   FvioTWCus[idpre] = FvioTWCus[idcur];
//		   }
//		   cStartS = depart[idpre];
//		   FCAP[idpre] = FCAP[idcur] + problem->node[idpre].capacity;
//		   pos[idpre] = pos[idcur] + 1;
//		   idTemp = idpre; idpre = predArr[idpre];
//		   predArr[idTemp]=idcur; nextArr[idcur]=idTemp;
//		   idcur = idTemp;
//	  }
//	  nextArr[sucj]=suci;
//
//	  //now idpre is j; idcur is sucj
//	  //from sucj to suci:
//	  int nextTrip = idTrip + 1;
//	  int nextID, preID, id;
//	  double varvioTWC;
//	  if (nextTrip == seg[idVeh].numTrips)
//	  {
//		  if (suci > 0) //i was not the last customer of the trip; sucj has to be > 0
//		  {
//				varcost += (problem->c[sucj][suci] - problem->c[i][suci]);
//				//idcur is now sucj; check sucj-->suci & suci till the end of the leg:
//				predArr[suci] = sucj;
//				nextID = suci; preID = sucj; cStartS = depart[sucj];
//				while (nextID > 0)
//				{
//					cArrTime = cStartS + problem->c[preID][nextID]; //arrTime at customer nextID
//					cStartS = PDS_MAX(cArrTime, problem->node[nextID].sTW);
//            		if (PDSDIF(cStartS, startS[nextID])==0) //it means varvioTWCus[nextID]=0 
//					{
//						temp = cStartS - problem->node[nextID].eTW;
//						if (temp > eps) vioTWCus[nextID] = temp;
//						else vioTWCus[nextID] = 0;
//
//						//Update BvioTWCus from nextID to firstCus
//						//Update BCAP from sucj to i
//						//Update FvioTWCus from nextID to lastCus; DONT NEED TO UPDATE FCAP
//						id = nextArr[nextID];
//						if (id < 0) BvioTWCus[nextID] = vioTWCus[nextID];
//						else BvioTWCus[nextID] = BvioTWCus[id] + vioTWCus[nextID];
//
//						id = nextID;
//						while (preID != sucj)
//						{
//							BvioTWCus[preID] = BvioTWCus[id] + vioTWCus[preID];
//							id = preID; preID = predArr[id];
//						}
//						
//						do
//						{
//							BvioTWCus[preID] = BvioTWCus[id] + vioTWCus[preID];
//							BCAP[preID] = BCAP[id] + problem->node[preID].capacity;
//							id = preID; preID = predArr[id];
//						}while (preID != j);
//						do
//						{
//							BvioTWCus[preID] = BvioTWCus[id] + vioTWCus[preID];
//							id = preID; preID = predArr[id];
//						}while (preID > 0);
//
//						//update FvioTWCus from nextID to lastCus:
//						id = nextID; preID = predArr[nextID];
//						do
//						{
//							FvioTWCus[id] = FvioTWCus[preID] + vioTWCus[id];
//							preID = id; id = nextArr[id];
//						}while (id > 0);
//						//preID now points to the last cus
//						varvioTWC = FvioTWCus[preID] - seg[idVeh].Trip[idTrip].vioTWC; 
//						seg[idVeh].Trip[idTrip].vioTWC = FvioTWCus[preID];
//						goto Update;
//					}
//					temp = cStartS - problem->node[nextID].eTW;
//					if (temp > eps)
//					{
//						if (vioTWCus[nextID] > eps) 
//						{
//							vioTWCus[nextID] = temp;
//							//Update BvioTWCus from nextID to firstCus
//							//Update BCAP from sucj to i
//							//Update FvioTWCus from nextID to lastCus; DONT NEED TO UPDATE FCAP
//							id = nextArr[nextID];
//							if (id < 0) BvioTWCus[nextID] = vioTWCus[nextID];
//							else BvioTWCus[nextID] = BvioTWCus[id] + vioTWCus[nextID];
//
//							id = nextID;
//							while (preID != sucj)
//							{
//								BvioTWCus[preID] = BvioTWCus[id] + vioTWCus[preID];
//								id = preID; preID = predArr[id];
//							}
//							do
//							{
//								BvioTWCus[preID] = BvioTWCus[id] + vioTWCus[preID];
//								BCAP[preID] = BCAP[id] + problem->node[preID].capacity;
//								id = preID; preID = predArr[id];
//							}while (preID != j);
//
//							do
//							{
//								BvioTWCus[preID] = BvioTWCus[id] + vioTWCus[preID];
//								id = preID; preID = predArr[id];
//							}while (preID > 0);
//
//							//Update FvioTWCus from nextID to lastCus
//							id = nextID; preID = predArr[nextID];
//							do
//							{
//								FvioTWCus[id] = FvioTWCus[preID] + vioTWCus[id];
//								preID = id; id = nextArr[id];
//							}while (id > 0);
//							//preID now points to the last cus
//							varvioTWC = FvioTWCus[preID] - seg[idVeh].Trip[idTrip].vioTWC;
//							seg[idVeh].Trip[idTrip].vioTWC = FvioTWCus[preID];
//							goto Update;
//						}
//						vioTWCus[nextID] = temp;
//						FvioTWCus[nextID] = FvioTWCus[preID] + temp;
//						cStartS = problem->node[nextID].eTW;
//					}
//					else 
//					{
//						vioTWCus[nextID] = 0;
//						FvioTWCus[nextID] = FvioTWCus[preID];
//					}
//					startS[nextID] = cStartS;
//					cStartS += problem->node[nextID].duration;
//					depart[nextID] = cStartS;
//					//FCAP[nextID] don't need to update FCAP
//					preID = nextID; nextID = nextArr[nextID];
//				}
//				seg[idVeh].Trip[idTrip].endS = cStartS;
//				varvioTWC = FvioTWCus[preID] - seg[idVeh].Trip[idTrip].vioTWC;
//				seg[idVeh].Trip[idTrip].vioTWC = FvioTWCus[preID];
//
//				//preID now points to the last cus:
//				//Update BCAP from sucj to i
//				//Update BvioTWCus from lastCus to firstCus
//				BvioTWCus[preID] = vioTWCus[preID];
//				id = predArr[preID];
//				while (id != sucj)
//				{
//					BvioTWCus[id] = BvioTWCus[preID] + vioTWCus[id];
//					preID = id; id = predArr[id];
//				}
//				do
//				{
//					BvioTWCus[id] = BvioTWCus[preID] + vioTWCus[id];
//					BCAP[id] = BCAP[preID] + problem->node[id].capacity;
//					preID = id; id = predArr[id];
//				}while (id != j);
//				do
//				{
//					BvioTWCus[id] = BvioTWCus[preID] + vioTWCus[id];
//					preID = id; id = predArr[id];
//				}while (id > 0);
//		  }
//		  else //i was the last customer of the trip --> sucj is now the last customer of the trip:
//		  {
//			  seg[idVeh].Trip[idTrip].lastCus = sucj;
//			  seg[idVeh].Trip[idTrip].endS = depart[sucj];
//			  varcost += (problem->c[sucj][0] - problem->c[i][0]);
//			  seg[idVeh].Trip[idTrip].connectCost = problem->c[sucj][0];
//			  varvioTWC = FvioTWCus[sucj] - seg[idVeh].Trip[idTrip].vioTWC;
//              seg[idVeh].Trip[idTrip].vioTWC = FvioTWCus[sucj];
//              //Update BvioTWCus from lastCus to firstCus
//			  //Update BCAP from lastCus to i
//			  BvioTWCus[sucj] = vioTWCus[sucj];
//			  BCAP[sucj] = problem->node[sucj].capacity;
//			  id = predArr[sucj]; preID = sucj;
//			  while (id != j)
//			  {
//					BvioTWCus[id] = BvioTWCus[preID] + vioTWCus[id];
//					BCAP[id] = BCAP[preID] + problem->node[id].capacity; //ok
//					preID = id; id = predArr[id];
//			 }
//			 do
//			 {
//					BvioTWCus[id] = BvioTWCus[preID] + vioTWCus[id];
//					preID = id; id = predArr[id];
//			 }while (id > 0);
//		  }//i was the last customer of the trip --> sucj is now the last customer of the trip
//		   Update:
//				seg[idVeh].Trip[idTrip].cost += varcost;
//				double varFIT = varcost + VTWCUS * varvioTWC;
//				if (FvioTWCus[seg[idVeh].Trip[idTrip].lastCus] > eps || seg[idVeh].Trip[idTrip].vioCAP > 0 || seg[idVeh].Trip[idTrip].vioTWSP > eps)
//				{
//					seg[idVeh].Trip[idTrip].feasible = 0;
//					seg[idVeh].Trip[idTrip].fitness +=  varFIT;
//				}
//				else
//				{
//					seg[idVeh].Trip[idTrip].feasible = 1;
//					seg[idVeh].Trip[idTrip].fitness = seg[idVeh].Trip[idTrip].cost;
//				}
//				seg[idVeh].cost += varcost; seg[idVeh].fitness += varFIT; seg[idVeh].vioTWC += varvioTWC;
//				cost += varcost; fitness += varFIT; vioTWC += varvioTWC;
//				goto Update2;
//	  }
//	  else //not the last trip
//	  {
//		  if (suci > 0) //i was not the last customer of the trip; sucj has to be > 0
//		  {
//				varcost += (problem->c[sucj][suci] - problem->c[i][suci]);
//				//idcur is now sucj; check sucj-->suci & suci till the end of the leg:
//				predArr[suci] = sucj;
//				nextID = suci; preID = sucj; cStartS = depart[sucj];
//				while (nextID > 0)
//				{
//					cArrTime = cStartS + problem->c[preID][nextID]; //arrTime at customer nextID
//					cStartS = PDS_MAX(cArrTime, problem->node[nextID].sTW);
//            		if (PDSDIF(cStartS, startS[nextID])==0) //it means varvioTWCus[nextID]=0 
//					{
//						temp = cStartS - problem->node[nextID].eTW;
//						if (temp > eps) vioTWCus[nextID] = temp;
//						else vioTWCus[nextID] = 0;
//
//						//Update BvioTWCus from nextID to firstCus
//						//Update BCAP from sucj to i
//						//Update FvioTWCus from nextID to lastCus; DONT NEED TO UPDATE FCAP
//						id = nextArr[nextID];
//						if (id < 0) BvioTWCus[nextID] = vioTWCus[nextID];
//						else BvioTWCus[nextID] = BvioTWCus[id] + vioTWCus[nextID];
//
//						id = nextID;
//						while (preID != sucj)
//						{
//							BvioTWCus[preID] = BvioTWCus[id] + vioTWCus[preID];
//							id = preID; preID = predArr[id];
//						}
//
//						do
//						{
//							BvioTWCus[preID] = BvioTWCus[id] + vioTWCus[preID];
//							BCAP[preID] = BCAP[id] + problem->node[preID].capacity;
//							id = preID; preID = predArr[id];
//						}while (preID != j);
//						do
//						{
//							BvioTWCus[preID] = BvioTWCus[id] + vioTWCus[preID];
//							id = preID; preID = predArr[id];
//						}while (preID > 0);
//
//						//update FvioTWCus from nextID to lastCus:
//						id = nextID; preID = predArr[nextID];
//						do
//						{
//							FvioTWCus[id] = FvioTWCus[preID] + vioTWCus[id];
//							preID = id; id = nextArr[id];
//						}while (id > 0);
//						//preID now points to the last cus
//						varvioTWC = FvioTWCus[preID] - seg[idVeh].Trip[idTrip].vioTWC; 
//						seg[idVeh].Trip[idTrip].vioTWC = FvioTWCus[preID];
//						goto Update1;
//					}
//					temp = cStartS - problem->node[nextID].eTW;
//					if (temp > eps)
//					{
//						if (vioTWCus[nextID] > eps) 
//						{
//							vioTWCus[nextID] = temp;
//							//Update BvioTWCus from nextID to firstCus
//							//Update BCAP from sucj to i
//							//Update FvioTWCus from nextID to lastCus; DONT NEED TO UPDATE FCAP
//							id = nextArr[nextID];
//							if (id < 0) BvioTWCus[nextID] = vioTWCus[nextID];
//							else BvioTWCus[nextID] = BvioTWCus[id] + vioTWCus[nextID];
//
//							id = nextID;
//							while (preID != sucj)
//							{
//								BvioTWCus[preID] = BvioTWCus[id] + vioTWCus[preID];
//								id = preID; preID = predArr[id];
//							}
//							do
//							{
//								BvioTWCus[preID] = BvioTWCus[id] + vioTWCus[preID];
//								BCAP[preID] = BCAP[id] + problem->node[preID].capacity;
//								id = preID; preID = predArr[id];
//							}while (preID != j);
//
//							do
//							{
//								BvioTWCus[preID] = BvioTWCus[id] + vioTWCus[preID];
//								id = preID; preID = predArr[id];
//							}while (preID > 0);
//
//							//Update FvioTWCus from nextID to lastCus
//							id = nextID; preID = predArr[nextID];
//							do
//							{
//								FvioTWCus[id] = FvioTWCus[preID] + vioTWCus[id];
//								preID = id; id = nextArr[id];
//							}while (id > 0);
//							//preID now points to the last cus
//							varvioTWC = FvioTWCus[preID] - seg[idVeh].Trip[idTrip].vioTWC;
//							seg[idVeh].Trip[idTrip].vioTWC = FvioTWCus[preID];
//							goto Update1;
//						}
//						vioTWCus[nextID] = temp;
//						FvioTWCus[nextID] = FvioTWCus[preID] + temp;
//						cStartS = problem->node[nextID].eTW;
//					}
//					else 
//					{
//						vioTWCus[nextID] = 0;
//						FvioTWCus[nextID] = FvioTWCus[preID];
//					}
//					startS[nextID] = cStartS;
//					cStartS += problem->node[nextID].duration;
//					depart[nextID] = cStartS;
//					//FCAP[nextID] don't need to update FCAP
//					preID = nextID; nextID = nextArr[nextID];
//				}
//				seg[idVeh].Trip[idTrip].endS = cStartS;
//				varvioTWC = FvioTWCus[preID] - seg[idVeh].Trip[idTrip].vioTWC;
//				seg[idVeh].Trip[idTrip].vioTWC = FvioTWCus[preID];
//		
//				if (seg[idVeh].Trip[idTrip].vioTWSP > eps || seg[idVeh].Trip[idTrip].vioCAP > 0 || seg[idVeh].Trip[idTrip].vioTWC > eps)
//					seg[idVeh].Trip[idTrip].feasible = 0;
//				else
//					seg[idVeh].Trip[idTrip].feasible = 1;
//
//				//preID now points to the last cus:
//				//Update BCAP from sucj to i
//				//Update BvioTWCus from lastCus to firstCus
//				BvioTWCus[preID] = vioTWCus[preID];
//				id = predArr[preID];
//				while (id != sucj)
//				{
//					BvioTWCus[id] = BvioTWCus[preID] + vioTWCus[id];
//					preID = id; id = predArr[id];
//				}
//				do
//				{
//					BvioTWCus[id] = BvioTWCus[preID] + vioTWCus[id];
//					BCAP[id] = BCAP[preID] + problem->node[id].capacity;
//					preID = id; id = predArr[id];
//				}while (id != j);
//				do
//				{
//					BvioTWCus[id] = BvioTWCus[preID] + vioTWCus[id];
//					preID = id; id = predArr[id];
//				}while (id > 0);
//
//				preID = seg[idVeh].Trip[idTrip].lastCus;
//				if (seg[idVeh].Trip[nextTrip].Type == 1) //nextTrip is delivery trip, lastCus doesn't change
//				{
//					bool stop = updateChangeCONNECTAtSP_DD(preID, idVeh, nextTrip, idTrip, 0, varvioTWC, varcost);
//					if (stop == 0)
//						UpdateVehicle(idVeh, nextTrip, seg[idVeh].Trip[nextTrip].assSP, seg[idVeh].Trip[nextTrip].leaveSP, 0, seg[idVeh].numTrips - 1);
//					goto Update2;
//				}
//				else //next Trip is pickup OR C2C, lastCus doesn't change
//				{
//					double varFIT = varcost + VTWCUS * varvioTWC;
//					seg[idVeh].Trip[idTrip].cost += varcost;
//					seg[idVeh].Trip[idTrip].fitness += varFIT;
//
//					UpdateVehicle(idVeh, nextTrip, preID, seg[idVeh].Trip[idTrip].endS, 0, seg[idVeh].numTrips - 1);
//					goto Update2;
//				}//end next Trip is pickup OR C2C, not insert at the end of the idTrip
//		  }
//		  else //i was the last customer of the trip --> sucj is now the last customer of the trip:
//		  {
//			  seg[idVeh].Trip[idTrip].lastCus = sucj;
//			  seg[idVeh].Trip[idTrip].endS = depart[sucj];
//			  preID = sucj;
//			  varvioTWC = FvioTWCus[preID] - seg[idVeh].Trip[idTrip].vioTWC;
//              seg[idVeh].Trip[idTrip].vioTWC = FvioTWCus[preID];
//              //Update BvioTWCus from lastCus to firstCus
//			  //Update BCAP from lastCus to i
//			  BvioTWCus[preID] = vioTWCus[preID];
//			  BCAP[preID] = problem->node[sucj].capacity;
//			  id = predArr[preID];
//			  while (id != j)
//			  {
//					BvioTWCus[id] = BvioTWCus[preID] + vioTWCus[id];
//					BCAP[id] = BCAP[preID] + problem->node[id].capacity; //ok
//					preID = id; id = predArr[id];
//			 }
//			 do
//			 {
//					BvioTWCus[id] = BvioTWCus[preID] + vioTWCus[id];
//					preID = id; id = predArr[id];
//			 }while (id > 0);
//
//			 if (seg[idVeh].Trip[idTrip].vioTWSP > eps || seg[idVeh].Trip[idTrip].vioCAP > 0 || seg[idVeh].Trip[idTrip].vioTWC > eps)
//				seg[idVeh].Trip[idTrip].feasible = 0;
//			 else
//				seg[idVeh].Trip[idTrip].feasible = 1;
//
//			 if (seg[idVeh].Trip[nextTrip].Type == 1)
//			 {
//				bool stop = calChangeCONNECTAtSP_DD_LastCChanged(i, sucj, idVeh, nextTrip, idTrip, 0, varvioTWC, varcost); //for insertCusD procedure
//				if (stop == 0)
//					UpdateVehicle(idVeh, nextTrip, seg[idVeh].Trip[nextTrip].assSP, seg[idVeh].Trip[nextTrip].leaveSP, 0, seg[idVeh].numTrips - 1);
//				goto Update2;
//			 }
//			 else //nextTrip is pickup OR C2C, lastCus change:
//			 {
//				int firstC_nextT = seg[idVeh].Trip[nextTrip].firstCus;
//				varcost += (problem->c[sucj][firstC_nextT] - problem->c[i][firstC_nextT]);
//				seg[idVeh].Trip[idTrip].connectCost = problem->c[sucj][firstC_nextT];
//				seg[idVeh].Trip[idTrip].cost += varcost;
//				double varFIT = varcost + VTWCUS * varvioTWC;
//				seg[idVeh].Trip[idTrip].fitness += varFIT;
//				UpdateVehicle(idVeh, nextTrip, sucj, seg[idVeh].Trip[idTrip].endS, 0, seg[idVeh].numTrips - 1);
//				goto Update2;
//			 }//end nextTrip is pickup OR C2C, lastCus change
//		  }//i was the last customer of the trip --> sucj is now the last customer of the trip
//
//	 Update1: //this happened when not insert at the the last cus
//			double varFIT = varcost + VTWCUS * varvioTWC;
//			seg[idVeh].Trip[idTrip].cost += varcost;
//			seg[idVeh].Trip[idTrip].fitness += varFIT;
//			if (seg[idVeh].Trip[idTrip].vioTWSP > eps || seg[idVeh].Trip[idTrip].vioCAP > 0 || seg[idVeh].Trip[idTrip].vioTWC > eps)
//				seg[idVeh].Trip[idTrip].feasible = 0;
//			else
//				seg[idVeh].Trip[idTrip].feasible = 1;
//			seg[idVeh].cost += varcost; seg[idVeh].fitness += varFIT; 
//			seg[idVeh].vioTWC += varvioTWC;
//			cost += varcost; fitness += varFIT; vioTWC += varvioTWC;
//	  }//not the last trip
//	Update2:
//		//UpdatePos(idVeh, idTrip);
//		bool stop = checkVehicle(idVeh);
//		if (stop)
//		{
//		  cout<<"STOP AT twoOPTstarCusDTrip_oneTrip @IT = "<<IT<<endl;
//		  exit(-1);
//		}
//		//return 0;
//}


//void Solution::twoOPTstarCusDTrip(int j, int idVehj, int idTripj, int i, int idVehi, int idTripi) //2opt* between 2 customer j and its neighbor (i) where j and i belong to different trips
//{
//	//see on 2/12/2013
//	//April 17th: moi trip sau idTripj va idTripi can giu nguyen vehicle
//
//	 int assSPi = seg[idVehi].Trip[idTripi].assSP;
//	 int assSPj = seg[idVehj].Trip[idTripj].assSP;
//	 int lastCOLDi = seg[idVehi].Trip[idTripi].lastCus;
//	 int lastCOLDj = seg[idVehj].Trip[idTripj].lastCus;
//	 double TcostOLD = seg[idVehi].Trip[idTripi].cost + seg[idVehj].Trip[idTripj].cost; //total cost old
//
//	 int sucj = nextArr[j]; int prei = predArr[i];
//	 bool emptyTripi=0;
//     double COSTOLDj = seg[idVehj].Trip[idTripj].cost;
//	 double COSTOLDi = seg[idVehi].Trip[idTripi].cost;
//
//	 //1. vioCAP,capacity:
//	 int capj = FCAP[j] + BCAP[i];
//	 int capi=0; 
//	 if (prei > 0) capi = FCAP[prei];
//	 if (sucj > 0) capi += BCAP[sucj];
//	 
//	 seg[idVehi].Trip[idTripi].capacity = capi;
//	 int vioCAPNEW = PDS_MAX(capi - problem->Q, 0);
//	 int varvioCAPi = vioCAPNEW - seg[idVehi].Trip[idTripi].vioCAP;
//	 seg[idVehi].Trip[idTripi].vioCAP = vioCAPNEW;
//
//	 seg[idVehj].Trip[idTripj].capacity = capj;
//	 vioCAPNEW = PDS_MAX(capj - problem->Q, 0);
//	 int varvioCAPj = vioCAPNEW - seg[idVehj].Trip[idTripj].vioCAP;
//     seg[idVehj].Trip[idTripj].vioCAP = vioCAPNEW;
//	 
//	 double cArrTime, cStartSi, cStartS, temp, varvioTWC, varcostj, varcosti;
//     int fC,id,preID, nextID, curi, idnexti;
//
//	 //2. Update nextArr, predArr, firstCus, lastCus
//	 //For the trip contains j:
//	 nextArr[j] = i; predArr[i] = j;
//	 seg[idVehj].Trip[idTripj].lastCus = lastCOLDi;
//	
//	 //For the trip contained i before:
//	 if (prei > 0)
//	 {
//		 if (sucj > 0) 
//		 {
//			 nextArr[prei]=sucj;
//			 predArr[sucj]=prei;
//			 seg[idVehi].Trip[idTripi].lastCus = lastCOLDj;
//		 }
//		 else 
//		 {
//			 seg[idVehi].Trip[idTripi].lastCus = prei; 
//			 nextArr[prei]=-1;
//		 }
//		 cStartSi = depart[prei]; 
//		 curi=prei; idnexti=sucj;
//	 }
//	 else //i was the first customer of idTripi
//	 {
//		 if (sucj > 0) 
//		 {
//			 seg[idVehi].Trip[idTripi].firstCus = sucj; 
//             predArr[sucj]=-1; 
//			 seg[idVehi].Trip[idTripi].lastCus = lastCOLDj;
//			 cStartSi = seg[idVehi].Trip[idTripi].leaveSP; 
//			 curi = assSPi; idnexti = sucj;
//		 }
//		 else {emptyTripi=1; /*update_EmptyLeg(idVehi,idLegi);*///cout<<"EMPTY LEG ("<<idVehi<<", "<<idLegi<<")"<<endl;
//		      } //it is now the empty leg
//	 }
//
//	 int numCusj = seg[idVehj].Trip[idTripj].numCus;
//	 int numCusi = seg[idVehi].Trip[idTripi].numCus;
//	 seg[idVehj].Trip[idTripj].numCus = pos[j] + (numCusi - pos[i] + 1);
//	 seg[idVehi].Trip[idTripi].numCus = numCusi + numCusj - seg[idVehj].Trip[idTripj].numCus;
//	 
//     
//	 //Calculate cost from firstCus of idTripj to j:
//	 double COSTj=0; fC = seg[idVehj].Trip[idTripj].firstCus; int preCC= assSPj;
//
//	 if (idTripj == 0) COSTj += problem->c[0][assSPj];
//	 
//	 if (sucj > 0)
//	 {
//		 while (preCC != j)
//		 {
//			 COSTj += problem->c[preCC][fC];
//			 preCC=fC; fC =nextArr[fC];
//		 }
//	 }
//	 else 
//		 COSTj = seg[idVehj].Trip[idTripj].cost - seg[idVehj].Trip[idTripj].connectCost;
//
//	 double COSTi = 0;
//	 if (idTripi == 0) COSTi += problem->c[0][assSPi];
//
//	 if (prei > 0)
//	 {
//		 preCC = assSPi; fC = seg[idVehi].Trip[idTripi].firstCus;
//		 while (preCC != prei)
//		 {
//			 COSTi += problem->c[preCC][fC];
//			 preCC = fC; fC = nextArr[fC];
//		 }
//	 }
// 
//	 //For the trip contain j:
//	 cStartS = depart[j]; preID = j; nextID = i;
//	 int nextTrip = idTripj+1;
//	 if (nextTrip == seg[idVehj].numTrips) //idTripj is the last trip
//	 {
// 		 while (nextID > 0) 
//		 {
//			   cArrTime = cStartS + problem->c[preID][nextID];
//			   cStartS = PDS_MAX(cArrTime, problem->node[nextID].sTW);
//			   if (PDSDIF(cStartS, startS[nextID])==0) //it means varvioTWCus[nextID] = 0 
//			   {
//				   temp = cStartS - problem->node[nextID].eTW;
//				   if (temp > eps) vioTWCus[nextID] = temp;
//				   else vioTWCus[nextID] = 0;
//
//				   //Update BvioTWCus from nextID to firstCus
//					//Update BCAP from j to firstCus
//					//Update FCAP, FvioTWCus from nextID to lastCus
//					//Update trip_num, route_num fro nextID to lastCus
//					//Update cost
//					id = nextArr[nextID];
//					if (id < 0) BvioTWCus[nextID] = vioTWCus[nextID];
//					else BvioTWCus[nextID] = BvioTWCus[id] + vioTWCus[nextID];
//
//				    id = nextID;
//				    while (preID != j)
//				    {
//					   BvioTWCus[preID] = BvioTWCus[id] + vioTWCus[preID];
//					   id = preID; preID = predArr[preID];
//				    }
//
//				   do
//				   {
//					   BvioTWCus[preID] = BvioTWCus[id] + vioTWCus[preID];
//					   BCAP[preID] = BCAP[id] + problem->node[preID].capacity;
//					   id = preID; preID = predArr[preID];
//				   }while (preID > 0);
//				   id = nextID; preID = predArr[id];
//				   do
//				   {
//					   route_num[id] = idVehj; trip_num[id] = idTripj;
//					   pos[id] = pos[preID] + 1;
//					   FCAP[id] = FCAP[preID] + problem->node[id].capacity;
//					   FvioTWCus[id] = FvioTWCus[preID] + vioTWCus[id];
//					   COSTj += problem->c[preID][id];
//					   preID = id; id = nextArr[id];
//				   }while (id > 0);
//				   //preID now points to lastCus:
//				   varvioTWC = seg[idVehj].Trip[idTripj].vioTWC - FvioTWCus[preID];
//				   seg[idVehj].Trip[idTripj].vioTWC = FvioTWCus[preID];
//				   seg[idVehj].Trip[idTripj].endS = depart[preID];
//				   goto Update;
//			   }
//			   temp = cStartS - problem->node[nextID].eTW;
//			   if (temp > eps)
//			   {
//					if (vioTWCus[nextID] > eps) 
//					{
//						vioTWCus[nextID] = temp;
//						//Update BvioTWCus from nextID to firstCus
//						//Update BCAP from j to firstCus
//						//Update FCAP, FvioTWCus from nextID to lastCus
//						//Update trip_num, route_num from nextID to lastCus
//						//Update cost
//						id = nextArr[nextID];
//						if (id < 0) BvioTWCus[nextID] = vioTWCus[nextID];
//						else BvioTWCus[nextID] = BvioTWCus[id] + vioTWCus[nextID];
//
//					    id = nextID;
//					    while (preID != j)
//					    {
//						   BvioTWCus[preID] = BvioTWCus[id] + vioTWCus[preID];
//						   id = preID; preID = predArr[preID];
//					    }
//					    do
//					    {
//						   BvioTWCus[preID] = BvioTWCus[id] + vioTWCus[preID];
//						   BCAP[preID] = BCAP[id] + problem->node[preID].capacity;
//						   id = preID; preID = predArr[preID];
//					    }while (preID > 0);
//					    id = nextID; preID = predArr[id];
//					    do
//					    {
//						   route_num[id] = idVehj; trip_num[id] = idTripj;
//						   pos[id] = pos[preID] + 1;
//						   FCAP[id] = FCAP[preID] + problem->node[id].capacity;
//						   FvioTWCus[id] = FvioTWCus[preID] + vioTWCus[id];
//						   COSTj += problem->c[preID][id];
//						   preID = id; id = nextArr[id];
//					    }while (id > 0);
//					    //preID now points to lastCus:
//					    varvioTWC = seg[idVehj].Trip[idTripj].vioTWC - FvioTWCus[preID];
//					    seg[idVehj].Trip[idTripj].vioTWC = FvioTWCus[preID];
//						seg[idVehj].Trip[idTripj].endS = depart[preID];
//						goto Update;
//					}
//					vioTWCus[nextID] = temp;
//					FvioTWCus[nextID] = FvioTWCus[preID] + temp;
//					cStartS = problem->node[nextID].eTW;
//			   }
//			   else 
//			   {
//					vioTWCus[nextID] = 0;
//					FvioTWCus[nextID] = FvioTWCus[preID];
//			   }
//			   startS[nextID] = cStartS;
//			   cStartS += problem->node[nextID].duration;
//			   depart[nextID] = cStartS;
//			   FCAP[nextID] = FCAP[preID] + problem->node[nextID].capacity;
//			   route_num[nextID] = idVehj; trip_num[nextID] = idTripj;
//			   pos[nextID] = pos[preID] + 1;
//			   COSTj += problem->c[preID][nextID];
//			   preID = nextID; nextID = nextArr[nextID];
//		 }
//		 seg[idVehj].Trip[idTripj].endS = cStartS;
//		 varvioTWC = FvioTWCus[preID] - seg[idVehj].Trip[idTripj].vioTWC;
//		 seg[idVehj].Trip[idTripj].vioTWC = FvioTWCus[preID];
//		//preID now points to the last cus:
//		 //seg[idVehj].Trip[idTripj].connectCost = problem->c[preID][0];
//
//		 //Update BCAP from j to firstCus
//		 //Update BvioTWCus from lastCus to firstCus
//		 BvioTWCus[preID] = vioTWCus[preID];
//		 id = predArr[preID];
//		 while (id != j)
//		 {
//			BvioTWCus[id] = BvioTWCus[preID] + vioTWCus[id];
//			preID = id; id = predArr[id];
//		}
//		BvioTWCus[j] = BvioTWCus[preID] + vioTWCus[j];
//		BCAP[j] = BCAP[preID] + problem->node[j].capacity;
//		id = predArr[j]; preID = j;
//		while (id > 0)
//		{
//			BvioTWCus[id] = BvioTWCus[preID] + vioTWCus[id];
//			BCAP[id] = BCAP[preID] + problem->node[id].capacity;
//			preID = id; id = predArr[id];
//		}
//
//		Update:
//		    COSTj += problem->c[lastCOLDi][0];
//			seg[idVehj].Trip[idTripj].connectCost = problem->c[lastCOLDi][0];
//			seg[idVehj].Trip[idTripj].cost = COSTj;
//			varcostj = COSTj - COSTOLDj;
//			double varFIT = varcostj + VCAP * varvioCAPj + VTWCUS * varvioTWC;
//			if (seg[idVehj].Trip[idTripj].vioTWC > eps || seg[idVehj].Trip[idTripj].vioCAP > 0 || seg[idVehj].Trip[idTripj].vioTWSP > eps)
//			{
//				seg[idVehj].Trip[idTripj].feasible = 0;
//				seg[idVehj].Trip[idTripj].fitness +=  varFIT;
//			}
//			else
//			{
//				seg[idVehj].Trip[idTripj].feasible = 1;
//				seg[idVehj].Trip[idTripj].fitness = seg[idVehj].Trip[idTripj].cost;
//			}
//			seg[idVehj].cost += varcostj; seg[idVehj].fitness += varFIT; 
//			seg[idVehj].vioCAP += varvioCAPj; seg[idVehj].vioTWC += varvioTWC;
//			cost += varcostj; fitness += varFIT; vioCAP += varvioCAPj; vioTWC += varvioTWC;
//	 }
//	 else //idTripj is not the last trip
//	 {
// 		 while (nextID > 0) 
//		 {
//			   cArrTime = cStartS + problem->c[preID][nextID];
//			   cStartS = PDS_MAX(cArrTime, problem->node[nextID].sTW);
//			   if (PDSDIF(cStartS, startS[nextID])==0) //it means varvioTWCus[nextID] = 0 
//			   {
//				   temp = cStartS - problem->node[nextID].eTW;
//				   if (temp > eps) vioTWCus[nextID] = temp;
//				   else vioTWCus[nextID] = 0;
//
//				   //Update BvioTWCus from nextID to firstCus
//					//Update BCAP from j to firstCus
//					//Update FCAP, FvioTWCus from nextID to lastCus
//					//Update trip_num, route_num fro nextID to lastCus
//					//Update cost
//					id = nextArr[nextID];
//					if (id < 0) BvioTWCus[nextID] = vioTWCus[nextID];
//					else BvioTWCus[nextID] = BvioTWCus[id] + vioTWCus[nextID];
//
//				    id = nextID;
//				    while (preID != j)
//				    {
//					   BvioTWCus[preID] = BvioTWCus[id] + vioTWCus[preID];
//					   id = preID; preID = predArr[preID];
//				    }
//				   
//				   do
//				   {
//					   BvioTWCus[preID] = BvioTWCus[id] + vioTWCus[preID];
//					   BCAP[preID] = BCAP[id] + problem->node[preID].capacity;
//					   id = preID; preID = predArr[preID];
//				   }while (preID > 0);
//				   id = nextID; preID = predArr[id];
//				   do
//				   {
//					   route_num[id] = idVehj; trip_num[id] = idTripj;
//					   pos[id] = pos[preID] + 1;
//					   FCAP[id] = FCAP[preID] + problem->node[id].capacity;
//					   FvioTWCus[id] = FvioTWCus[preID] + vioTWCus[id];
//					   COSTj += problem->c[preID][id];
//					   preID = id; id = nextArr[id];
//				   }while (id > 0);
//				   //preID now points to lastCus:
//				   varvioTWC = seg[idVehj].Trip[idTripj].vioTWC - FvioTWCus[preID];
//				   seg[idVehj].Trip[idTripj].vioTWC = FvioTWCus[preID];
//				   seg[idVehj].Trip[idTripj].endS = depart[preID];
//				   goto Update1;
//			   }
//			   temp = cStartS - problem->node[nextID].eTW;
//			   if (temp > eps)
//			   {
//					if (vioTWCus[nextID] > eps) 
//					{
//						vioTWCus[nextID] = temp;
//						//Update BvioTWCus from nextID to firstCus
//						//Update BCAP from j to firstCus
//						//Update FCAP, FvioTWCus from nextID to lastCus
//						//Update trip_num, route_num fro nextID to lastCus
//						//Update cost
//						id = nextArr[nextID];
//						if (id < 0) BvioTWCus[nextID] = vioTWCus[nextID];
//						else BvioTWCus[nextID] = BvioTWCus[id] + vioTWCus[nextID];
//
//					    id = nextID;
//					    while (preID != j)
//					    {
//						   BvioTWCus[preID] = BvioTWCus[id] + vioTWCus[preID];
//						   id = preID; preID = predArr[preID];
//					    }
//					    do
//					    {
//						   BvioTWCus[preID] = BvioTWCus[id] + vioTWCus[preID];
//						   BCAP[preID] = BCAP[id] + problem->node[preID].capacity;
//						   id = preID; preID = predArr[preID];
//					    }while (preID > 0);
//					    id = nextID; preID = predArr[id];
//					    do
//					    {
//						   route_num[id] = idVehj; trip_num[id] = idTripj;
//						   pos[id] = pos[preID] + 1;
//						   FCAP[id] = FCAP[preID] + problem->node[id].capacity;
//						   FvioTWCus[id] = FvioTWCus[preID] + vioTWCus[id];
//						   COSTj += problem->c[preID][id];
//						   preID = id; id = nextArr[id];
//					    }while (id > 0);
//					    //preID now points to lastCus:
//					    varvioTWC = seg[idVehj].Trip[idTripj].vioTWC - FvioTWCus[preID];
//					    seg[idVehj].Trip[idTripj].vioTWC = FvioTWCus[preID];
//					    seg[idVehj].Trip[idTripj].endS = depart[preID];
//						goto Update1;
//					}
//					vioTWCus[nextID] = temp;
//					FvioTWCus[nextID] = FvioTWCus[preID] + temp;
//					cStartS = problem->node[nextID].eTW;
//			   }
//			   else 
//			   {
//			   	  vioTWCus[nextID] = 0;
//				  FvioTWCus[nextID] = FvioTWCus[preID];
//			   }
//			   startS[nextID] = cStartS;
//			   cStartS += problem->node[nextID].duration;
//			   depart[nextID] = cStartS;
//			   FCAP[nextID] = FCAP[preID] + problem->node[nextID].capacity;
//			   pos[nextID] = pos[preID]+1;
//			   route_num[nextID] = idVehj; trip_num[nextID] = idTripj;
//			   COSTj += problem->c[preID][nextID];
//			   preID = nextID; nextID = nextArr[nextID];
//		 }
//		 seg[idVehj].Trip[idTripj].endS = cStartS;
//		 varvioTWC = FvioTWCus[preID] - seg[idVehj].Trip[idTripj].vioTWC;
//		 seg[idVehj].Trip[idTripj].vioTWC = FvioTWCus[preID];
//		//preID now points to the last cus:
//		 //Update BCAP from j to firstCus
//		 //Update BvioTWCus from lastCus to firstCus
//		 BvioTWCus[preID] = vioTWCus[preID];
//		 id = predArr[preID];
//		 while (id != j)
//		 {
//			BvioTWCus[id] = BvioTWCus[preID] + vioTWCus[id];
//			preID = id; id = predArr[id];
//		}
//		BvioTWCus[j] = BvioTWCus[preID] + vioTWCus[j];
//		BCAP[j] = BCAP[preID] + problem->node[j].capacity;
//		id = predArr[j]; preID = j;
//		while (id > 0)
//		{
//			BvioTWCus[id] = BvioTWCus[preID] + vioTWCus[id];
//			BCAP[id] = BCAP[preID] + problem->node[id].capacity;
//			preID = id; id = predArr[id];
//		}
//
//		Update1:
//		if (seg[idVehj].Trip[idTripj].vioTWSP > eps || seg[idVehj].Trip[idTripj].vioCAP > 0 || seg[idVehj].Trip[idTripj].vioTWC > eps)
//			seg[idVehj].Trip[idTripj].feasible = 0;
//		else
//			seg[idVehj].Trip[idTripj].feasible = 1;
//
//		if (seg[idVehj].Trip[nextTrip].Type == 1) //nextTrip is delivery trip, change the lastCus of the idTrip:
//		{
//			bool stop = updateChangeCONNECTAtSP_DD(lastCOLDi, idVehj, nextTrip, idTripj, varvioCAPj, varvioTWC, COSTj, COSTOLDj);
//			if (stop == 0)
//				UpdateVehicle(idVehj, nextTrip, seg[idVehj].Trip[nextTrip].assSP, seg[idVehj].Trip[nextTrip].leaveSP, varvioCAPj, seg[idVehj].numTrips - 1);
//		}
//		else //nextTrip is pickup OR C2C, change the lastCus of the idTripj
//		{
//			int firstC_nextT = seg[idVehj].Trip[nextTrip].firstCus;
//			COSTj += problem->c[lastCOLDi][firstC_nextT];
//			seg[idVehj].Trip[idTripj].connectCost = problem->c[lastCOLDi][firstC_nextT];
//			seg[idVehj].Trip[idTripj].cost = COSTj;
//			varcostj = COSTj - COSTOLDj;
//			double varFIT = varcostj + VCAP * varvioCAPj + VTWCUS * varvioTWC;
//			seg[idVehj].Trip[idTripj].fitness += varFIT;
//			UpdateVehicle(idVehj, nextTrip, lastCOLDi, seg[idVehj].Trip[idTripj].endS, varvioCAPj, seg[idVehj].numTrips - 1);
//		}//end nextTrip is pickup OR C2C, change the lastCus of the idTrip
//	 }//end idTripj is not the last trip
//   	 
//
//	  //For the trip contain i:
//	  if (!emptyTripi) //tripi is not the empty trip:
//	  {
//			 preID = curi; nextID = idnexti; cStartS = cStartSi;
//			 nextTrip = idTripi + 1;
//			 while (nextID > 0) 
//			 {
//				   cArrTime = cStartS + problem->c[preID][nextID];
//				   cStartS = PDS_MAX(cArrTime, problem->node[nextID].sTW);
//				   if (PDSDIF(cStartS, startS[nextID])==0) //it means varvioTWCus[nextID] = 0 
//				   {
//					   temp = cStartS - problem->node[nextID].eTW;
//					   if (temp > eps) vioTWCus[nextID] = temp;
//					   else vioTWCus[nextID] = 0;
//
//
//					   //Update BvioTWCus from nextID to firstCus
//						//Update BCAP from prei to firstCus (prei may = assSPi)
//						//Update FCAP, FvioTWCus from nextID to lastCus
//						//Update trip_num, route_num, pos from nextID to lastCus
//						//Update cost
//						id = nextArr[nextID];
//						if (id < 0) BvioTWCus[nextID] = vioTWCus[nextID];
//						else BvioTWCus[nextID] = BvioTWCus[id] + vioTWCus[nextID];
//
//						id = nextID; preID = predArr[id];
//						while (preID > 0)
//						{
//						   BvioTWCus[preID] = BvioTWCus[id] + vioTWCus[preID];
//						   BCAP[preID] = BCAP[id] + problem->node[preID].capacity;
//						   id = preID; preID = predArr[preID];
//						}
//
//					   id = nextID; preID = predArr[id];
//					   if (preID < 0) 
//					   {
//						   pos[id] = 1;route_num[id] = idVehi; trip_num[id] = idTripi;
//						   FCAP[id] = problem->node[id].capacity;
//						   FvioTWCus[id] = vioTWCus[id];
//						   COSTi += problem->c[assSPi][nextID];
//						   //cout<<"@CostI = "<<COSTi<<"(fC = "<<nextID<<") + ";
//						   preID = id; id = nextArr[id];
//					   }
//					   while (id > 0)
//					   {
//						   route_num[id] = idVehi; trip_num[id] = idTripi;
//						   pos[id] = pos[preID] + 1;
//						   FCAP[id] = FCAP[preID] + problem->node[id].capacity;
//						   FvioTWCus[id] = FvioTWCus[preID] + vioTWCus[id];
//						   COSTi += problem->c[preID][id];
//						   //cout<<problem->c[preID][id]<<"("<<id<<") + ";
//						   preID = id; id = nextArr[id];
//					   }
//					   //preID now points to lastCus:
//					   varvioTWC = seg[idVehi].Trip[idTripi].vioTWC - FvioTWCus[preID];
//					   seg[idVehi].Trip[idTripi].vioTWC = FvioTWCus[preID];
//					   seg[idVehi].Trip[idTripi].endS = depart[preID];
//					   goto Update3;
//				   }
//				   temp = cStartS - problem->node[nextID].eTW;
//				   if (temp > eps)
//				   {
//						if (vioTWCus[nextID] > eps) 
//						{
//							vioTWCus[nextID] = temp;
//							//Update BvioTWCus from nextID to firstCus
//							//Update BCAP from prei to firstCus (prei may = assSPi)
//							//Update FCAP, FvioTWCus from nextID to lastCus
//							//Update trip_num, route_num, pos from nextID to lastCus
//							//Update cost
//							id = nextArr[nextID];
//							if (id < 0) BvioTWCus[nextID] = vioTWCus[nextID];
//							else BvioTWCus[nextID] = BvioTWCus[id] + vioTWCus[nextID];
//
//							id = nextID; preID = predArr[id];
//							while (preID > 0)
//							{
//							   BvioTWCus[preID] = BvioTWCus[id] + vioTWCus[preID];
//							   BCAP[preID] = BCAP[id] + problem->node[preID].capacity;
//							   id = preID; preID = predArr[preID];
//							}
//							
//							id = nextID; preID = predArr[nextID];
//							if (preID < 0)
//							{
//								route_num[nextID] = idVehi; trip_num[nextID] = idTripi; 
//								pos[nextID] = 1;
//								COSTi = problem->c[assSPi][nextID];
//								//cout<<"#CostI = "<<COSTi<<"(fC = "<<nextID<<") + ";
//								FCAP[nextID] = problem->node[nextID].capacity;
//								FvioTWCus[nextID] = vioTWCus[nextID];
//								preID = nextID; id = nextArr[nextID];
//							}
//
//							while (id > 0)
//							{
//								route_num[id] = idVehi; trip_num[id] = idTripi;
//								pos[id] = pos[preID] + 1;
//								COSTi += problem->c[preID][id];
//							    //cout<<problem->c[preID][id]<<"("<<id<<") + ";
//								FCAP[id] = FCAP[preID] + problem->node[id].capacity;
//								FvioTWCus[id] = FvioTWCus[preID] + vioTWCus[id];
//								preID = id; id = nextArr[id];
//							}
//							//preID now points to lastCus:
//							varvioTWC = seg[idVehi].Trip[idTripi].vioTWC - FvioTWCus[preID];
//							seg[idVehi].Trip[idTripi].vioTWC = FvioTWCus[preID];
//							seg[idVehi].Trip[idTripi].endS = depart[preID];
//							//cout<<"KQ = "<<COSTi<<"; ";
//							goto Update3;
//						}
//						vioTWCus[nextID] = temp;
//						FvioTWCus[nextID] = FvioTWCus[preID] + temp;
//						cStartS = problem->node[nextID].eTW;
//				   }
//				   else 
//				   {
//						vioTWCus[nextID] = 0;
//						FvioTWCus[nextID] = FvioTWCus[preID];
//				   }
//				   startS[nextID] = cStartS;
//				   cStartS += problem->node[nextID].duration;
//				   depart[nextID] = cStartS;
//				   FCAP[nextID] = FCAP[preID] + problem->node[nextID].capacity;
//				   route_num[nextID] = idVehi; trip_num[nextID] = idTripi;
//				   pos[nextID] = pos[preID] + 1;
//				   COSTi += problem->c[preID][nextID];
//				   //cout<<problem->c[preID][nextID]<<"("<<nextID<<") ++ ";
//				   preID = nextID; nextID = nextArr[nextID];
//			 }//end while (nextID > 0)
//			 seg[idVehi].Trip[idTripi].endS = cStartS;
//			 varvioTWC = FvioTWCus[preID] - seg[idVehi].Trip[idTripi].vioTWC;
//			 seg[idVehi].Trip[idTripi].vioTWC = FvioTWCus[preID];
//			//preID now points to the last cus:
//			 //Update BCAP from prei to firstCus
//			 //Update BvioTWCus from lastCus to firstCus
//			 BvioTWCus[preID] = vioTWCus[preID];
//			 BCAP[preID] = problem->node[preID].capacity;
//			 id = predArr[preID];
//			 while (id > 0)
//			 {
//				 BvioTWCus[id] = BvioTWCus[preID] + vioTWCus[id];
//				 BCAP[id] = BCAP[preID] + problem->node[id].capacity;
//				 preID = id; id = predArr[id];
//			 }
//			 Update3:
//			  if (nextTrip == seg[idVehi].numTrips)
//			  {
//				    COSTi += problem->c[seg[idVehi].Trip[idTripi].lastCus][0];
//					seg[idVehi].Trip[idTripi].connectCost = problem->c[seg[idVehi].Trip[idTripi].lastCus][0];
//					seg[idVehi].Trip[idTripi].cost = COSTi;
//					varcosti = COSTi - COSTOLDi;
//					double varFIT = varcosti + VCAP * varvioCAPi + VTWCUS * varvioTWC;
//					if (seg[idVehi].Trip[idTripi].vioTWC > eps || seg[idVehi].Trip[idTripi].vioCAP > 0 || seg[idVehi].Trip[idTripi].vioTWSP > eps)
//					{
//						seg[idVehi].Trip[idTripi].feasible = 0;
//						seg[idVehi].Trip[idTripi].fitness +=  varFIT;
//					}
//					else
//					{
//						seg[idVehi].Trip[idTripi].feasible = 1;
//						seg[idVehi].Trip[idTripi].fitness = seg[idVehi].Trip[idTripi].cost;
//					}
//					seg[idVehi].cost += varcosti; seg[idVehi].fitness += varFIT; 
//					seg[idVehi].vioCAP += varvioCAPi; seg[idVehi].vioTWC += varvioTWC;
//					cost += varcosti; fitness += varFIT; vioCAP += varvioCAPi; vioTWC += varvioTWC;
//			  }
//			  else //not the last trip
//			  {
//					if (seg[idVehi].Trip[idTripi].vioTWC > eps || seg[idVehi].Trip[idTripi].vioCAP > 0 || seg[idVehi].Trip[idTripi].vioTWSP > eps)
//						seg[idVehi].Trip[idTripi].feasible = 0;
//					else
//						seg[idVehi].Trip[idTripi].feasible = 1;
//		
//					if (seg[idVehi].Trip[nextTrip].Type == 1)
//					{
//						bool stop = updateChangeCONNECTAtSP_DD(seg[idVehi].Trip[idTripi].lastCus, idVehi, nextTrip, idTripi, varvioCAPi, varvioTWC, COSTi, COSTOLDi);
//						if (stop == 0)
//							UpdateVehicle(idVehi, nextTrip, seg[idVehi].Trip[nextTrip].assSP, seg[idVehi].Trip[nextTrip].leaveSP, varvioCAPi, seg[idVehi].numTrips - 1);
//					}
//					else //nextTrip is pickup OR C2C
//					{
//						  int firstC_nextT = seg[idVehi].Trip[nextTrip].firstCus;
//						  seg[idVehi].Trip[idTripi].connectCost = problem->c[seg[idVehi].Trip[idTripi].lastCus][firstC_nextT];
//						  COSTi += seg[idVehi].Trip[idTripi].connectCost;
//						  seg[idVehi].Trip[idTripi].cost = COSTi;
//						  varcosti = COSTi - COSTOLDi;
//						  double varFIT = VCAP * varvioCAPi + VTWCUS * varvioTWC + varcosti;
//						  seg[idVehi].Trip[idTripi].fitness += varFIT;
//						  UpdateVehicle(idVehi, nextTrip, seg[idVehi].Trip[idTripi].lastCus, seg[idVehi].Trip[idTripi].endS, varvioCAPi, seg[idVehi].numTrips - 1);
//					}//end nextTrip is pickup OR C2C
//			  }//end not the last trip
//			  //cout<<"  --> COST = "<<COSTi<<endl;
//	  }
//	  else  //idVehi.idTripi is empty
//	  {
//		  Update_EmptyTripD(idVehi, idTripi);
//	  }//idTripi empty
//
//	  bool stop = checkVehicle(idVehj);
//	  if (stop)
//	  {
//		  cout<<"STOP AT twoOPTstarCusDTrip of vehj = "<<idVehj<<"; @IT = "<<IT<<endl;
//		  exit(-1);
//	  }
//	  stop = checkVehicle(idVehi);
//	  if (stop)
//	  {
//		  cout<<"STOP AT twoOPTstarCusDTrip of vehi = "<<idVehi<<"; @IT = "<<IT<<endl;
//		  exit(-1);
//	  }
//}



//bool Solution::Update_EmptyTripP(int idVeh, int idTrip)
//{
//	//see on 2/12/2013
//	int lastTrip = seg[idVeh].numTrips - 1;
//	seg[idVeh].numTrips --;
//	int i;
//	double varvioTWSP, varcost, varFIT;
//
//	int varvioCAP = -seg[idVeh].Trip[idTrip].vioCAP;
//	seg[idVeh].Trip[idTrip].numCus=0;
//	if (seg[idVeh].numTrips == 0) //vehicle now becomes empty:
//	{
//         //cout<<"Vehicle "<<idVeh<<"-> now becomes empty"<<endl;
//		 numVehUsed--;
//		 return 1;
//		 //UpdateMoveSPEmptyVeh(idVeh); CAN XEM
//	}
//	else //vehicle doesn't become empty
//	{
//		if (idTrip == 0) //first trip becomes empty
//		{
//			//Don toa:
//			for (i=0;i<seg[idVeh].numTrips; i++)
//			{
//				seg[idVeh].Trip[i] = seg[idVeh].Trip[i+1];
//				UpdateTripnum(idVeh,i);
//			}
//			if (seg[idVeh].Trip[0].Type == 1)
//			{
//				seg[idVeh].Trip[0].coordinate = 0;
//				int assSP = seg[idVeh].Trip[0].assSP;
//				seg[idVeh].Trip[0].leaveSP = problem->leaveSP[assSP][4]; //load only at sTW2
//				varvioTWSP = -seg[idVeh].Trip[0].vioTWSP;
//				seg[idVeh].Trip[0].vioTWSP = 0;
//				varcost = problem->c[0][assSP];
//				seg[idVeh].Trip[0].cost += varcost;
//				varFIT = varcost + VTWSP * varvioTWSP;
//				seg[idVeh].Trip[0].fitness += varFIT;
//				UpdateVehicle(idVeh, 0, assSP, seg[idVeh].Trip[0].leaveSP, varvioCAP, seg[idVeh].numTrips - 1);
//			}
//			else
//			{
//				varcost = problem->c[0][seg[idVeh].Trip[0].firstCus];
//				seg[idVeh].Trip[0].cost += varcost;
//				seg[idVeh].Trip[0].fitness += varcost;
//				if (seg[idVeh].Trip[0].Type == 2) seg[idVeh].Trip[0].assSP = 0;
//				UpdateVehicle(idVeh, 0, 0, 0, varvioCAP, seg[idVeh].numTrips - 1);
//			}
//		}
//		else //middle/last pickup trip becomes empty
//		{
//			int preT = idTrip - 1;
//			if (idTrip < lastTrip) //middle trip becomes empty:
//			{
//				//Don toa:
//				for (i=idTrip;i<seg[idVeh].numTrips; i++)
//				{
//					seg[idVeh].Trip[i] = seg[idVeh].Trip[i+1];
//					UpdateTripnum(idVeh,i);
//				}
//				if (seg[idVeh].Trip[preT].Type == 1)
//				{
//					if (seg[idVeh].Trip[idTrip].Type == 1) //preT is delivery trip, nextTrip is deliverytrip 
//					{
//						seg[idVeh].Trip[idTrip].coordinate = 0;
//						updateChangeCONNECTAtSP_DDORC2CD(idVeh, idTrip, preT, varvioCAP, seg[idVeh].numTrips - 1); //for Update_EmptyTripD and Update_EmptyTripP: connect deliverytrip(idVeh, preT) with delivery trip (idVeh, nextTrip) where (idVeh, idTrip) is already deleted 
//					}
//					else //preT is delivery trip, nextTrip is (pickup OR C2C)
//					{
//						varcost = -seg[idVeh].Trip[preT].connectCost;
//						seg[idVeh].Trip[preT].connectCost = problem->c[seg[idVeh].Trip[preT].lastCus][seg[idVeh].Trip[idTrip].firstCus];
//					    varcost += seg[idVeh].Trip[preT].connectCost;
//						seg[idVeh].Trip[preT].cost += varcost;
//						seg[idVeh].Trip[preT].fitness += varcost;
//						UpdateVehicle(idVeh, idTrip, seg[idVeh].Trip[preT].lastCus, seg[idVeh].Trip[preT].endS, varvioCAP, seg[idVeh].numTrips - 1);
//					}//end preT is delivery trip, nextTrip is (pickup OR C2C)
//				}
//				else if (seg[idVeh].Trip[preT].Type == 0) //preT is pickup (middle trip becomes empty)
//				{
//					if (seg[idVeh].Trip[idTrip].Type == 1) //preT is pickup trip, nextTrip is delivery (middle trip becomes empty)
//					{
//						seg[idVeh].Trip[idTrip].coordinate = 0;
//						updateChangeCONNECTAtSP_SPSP(idVeh, idTrip, preT, varvioCAP, seg[idVeh].numTrips - 1); //for Update_EmptyTripD and Update_EmptyTripP: connect pickuptrip(idVeh, preT) with delivery trip (idVeh, nextTrip) where (idVeh, idTrip) is already deleted 
//					}
//					else //preT is pickup trip, nextTrip is (pickup OR C2C) (middle trip becomes empty)
//					{
//						varcost = -seg[idVeh].Trip[preT].connectCost;
//						seg[idVeh].Trip[preT].connectCost = problem->c[seg[idVeh].Trip[preT].assSP][seg[idVeh].Trip[idTrip].firstCus];
//					    varcost += seg[idVeh].Trip[preT].connectCost;
//						seg[idVeh].Trip[preT].cost += varcost;
//						seg[idVeh].Trip[preT].fitness += varcost;
//						UpdateVehicle(idVeh, idTrip, seg[idVeh].Trip[preT].assSP, seg[idVeh].Trip[preT].leaveSP, varvioCAP, seg[idVeh].numTrips - 1);
//					}//end preT is pickup trip, nextTrip is pickup (middle trip becomes empty)
//				}//end preT is pickup (middle trip becomes empty)
//				else //preT is C2C
//				{
//					if (seg[idVeh].Trip[idTrip].Type == 1) //preT is C2C trip, nextTrip is deliverytrip 
//					{
//						seg[idVeh].Trip[preT].nextSP = seg[idVeh].Trip[idTrip].assSP;
//						seg[idVeh].Trip[idTrip].coordinate = 0;
//						updateChangeCONNECTAtSP_DDORC2CD(idVeh, idTrip, preT, varvioCAP, seg[idVeh].numTrips - 1); //for Update_EmptyTripD and Update_EmptyTripP: connect deliverytrip(idVeh, preT) with delivery trip (idVeh, nextTrip) where (idVeh, idTrip) is already deleted 
//					}
//					else //if (seg[idVeh].Trip[idTrip].Type == 0 || 2) //preT is C2C trip, nextTrip is pickup OR C2C
//					{
//						//seg[idVeh].Trip[preT].nextSP = -1;
//						varcost = -seg[idVeh].Trip[preT].connectCost;
//						seg[idVeh].Trip[preT].connectCost = problem->c[seg[idVeh].Trip[preT].lastCus][seg[idVeh].Trip[idTrip].firstCus];
//					    varcost += seg[idVeh].Trip[preT].connectCost;
//						seg[idVeh].Trip[preT].cost += varcost;
//						seg[idVeh].Trip[preT].fitness += varcost;
//						UpdateVehicle(idVeh, idTrip, seg[idVeh].Trip[preT].lastCus, seg[idVeh].Trip[preT].endS, varvioCAP, seg[idVeh].numTrips - 1);
//					}
//				}//end preT is C2C (middle trip becomes empty)
//			}
//			else //lastTrip becomes empty
//			{
//				varcost = - seg[idVeh].Trip[preT].connectCost;
//				if (seg[idVeh].Trip[preT].Type == 1)
//				{
//					seg[idVeh].Trip[preT].connectCost = problem->c[seg[idVeh].Trip[preT].lastCus][0];
//					seg[idVeh].Trip[preT].waitingS = NO_WS;
//				}
//				else if (seg[idVeh].Trip[preT].Type == 0)//preT is pickup, lastTrip becomes empty:
//				{
//					seg[idVeh].Trip[preT].connectCost = problem->c[seg[idVeh].Trip[preT].assSP][0];
//					seg[idVeh].Trip[preT].waitingS1 = NO_WS;
//				}//end preT is pickup, lastTrip becomes empty
//				else // preT is C2C, lastTrip becomes empty
//				{
//					seg[idVeh].Trip[preT].connectCost = problem->c[seg[idVeh].Trip[preT].lastCus][0];
//					seg[idVeh].Trip[preT].waitingS = NO_WS;
//					seg[idVeh].Trip[preT].nextSP = 0;
//				}
//				varcost += seg[idVeh].Trip[preT].connectCost;
//				seg[idVeh].Trip[preT].cost += varcost;
//				seg[idVeh].Trip[preT].fitness += varcost;
//				varFIT = varcost - seg[idVeh].Trip[idTrip].fitness;
//				varcost -= seg[idVeh].Trip[idTrip].cost;
//				seg[idVeh].cost += varcost; 
//				seg[idVeh].vioCAP -= seg[idVeh].Trip[idTrip].vioCAP;
//				seg[idVeh].vioTWC -= seg[idVeh].Trip[idTrip].vioTWC;
//				seg[idVeh].vioTWSP -= seg[idVeh].Trip[idTrip].vioTWSP;
//				seg[idVeh].fitness += varFIT;
//				cost += varcost; fitness += varFIT;
//				vioCAP -= seg[idVeh].Trip[idTrip].vioCAP;
//				vioTWC -= seg[idVeh].Trip[idTrip].vioTWC;
//				vioTWSP -= seg[idVeh].Trip[idTrip].vioTWSP;
//			}//end lastTrip becomes empty
//		}//end middle/last pickup trip becomes empty
//	}//end vehicle doesn't become empty
//	return 0;
//}

//bool Solution::Update_EmptyTripD(int idVeh, int idTrip)
//{
//	//see on 2/12/2013
//	int assSP = seg[idVeh].Trip[idTrip].assSP;
//
//	int varvioCAP = -seg[idVeh].Trip[idTrip].vioCAP;
//
//	seg[idVeh].Trip[idTrip].numCus=0;
//	seg[idVeh].numTrips --;
//
//	int nL = seg[idVeh].numTrips;
//	int i;
//
//	if (seg[idVeh].numTrips==0) //vehicle now becomes empty:
//	{
//         //cout<<"Vehicle "<<idVeh<<"-> now becomes empty"<<endl;
//		 numVehUsed--;
//		 return 1;
//		 //UpdateMoveSPEmptyVeh(idVeh); CAN XEM
//	}
//	else //vehicle doesn't become empty
//	{
//			if (idTrip == seg[idVeh].numTrips) //last trip becomes empty
//			{
//				//cout<<"Last trip becomes empty"<<endl;
//				int preT = idTrip - 1;
//				double varcost = -seg[idVeh].Trip[preT].connectCost;
//				if (seg[idVeh].Trip[preT].Type == 1)
//				{
//					seg[idVeh].Trip[preT].connectCost = problem->c[seg[idVeh].Trip[preT].lastCus][0];
//					seg[idVeh].Trip[preT].waitingS = NO_WS;
//				}
//				else //preT is pickup OR C2C, lastTrip becomes empty:
//				{
//					seg[idVeh].Trip[preT].connectCost = problem->c[seg[idVeh].Trip[preT].assSP][0];
//					seg[idVeh].Trip[preT].waitingS1 = NO_WS;
//					if (seg[idVeh].Trip[preT].Type == 2) seg[idVeh].Trip[preT].nextSP = 0;
//				}//end preT is pickup OR C2C, lastTrip becomes empty
//				varcost += seg[idVeh].Trip[preT].connectCost;
//				seg[idVeh].Trip[preT].cost += varcost;
//				seg[idVeh].Trip[preT].fitness += varcost;
//				double varFIT = varcost - seg[idVeh].Trip[idTrip].fitness;
//				varcost -= seg[idVeh].Trip[idTrip].cost;
//				seg[idVeh].cost += varcost; 
//				seg[idVeh].vioCAP -= seg[idVeh].Trip[idTrip].vioCAP;
//				seg[idVeh].vioTWC -= seg[idVeh].Trip[idTrip].vioTWC;
//				seg[idVeh].vioTWSP -= seg[idVeh].Trip[idTrip].vioTWSP;
//				seg[idVeh].fitness += varFIT;
//				cost += varcost; fitness += varFIT;
//				vioCAP -= seg[idVeh].Trip[idTrip].vioCAP;
//				vioTWC -= seg[idVeh].Trip[idTrip].vioTWC;
//				vioTWSP -= seg[idVeh].Trip[idTrip].vioTWSP;
//			}
//			else if (idTrip == 0) //first delivery trip becomes empty
//			{
//				//cout<<"first trip becomes empty"<<endl;
//				//Don toa:
//				for (i=0;i<seg[idVeh].numTrips; i++)
//				{
//					seg[idVeh].Trip[i] = seg[idVeh].Trip[i+1];
//					UpdateTripnum(idVeh,i);
//				}
//				if (seg[idVeh].Trip[0].Type == 1) 
//				{
//					seg[idVeh].Trip[0].leaveSP = problem->leaveSP[seg[idVeh].Trip[0].assSP][4]; //load at sTW2
//					double varcost = problem->c[0][seg[idVeh].Trip[0].assSP];
//					seg[idVeh].Trip[0].cost += varcost;
//					seg[idVeh].Trip[0].fitness +=  (varcost - VTWSP * seg[idVeh].Trip[0].vioTWSP);
//					seg[idVeh].Trip[0].vioTWSP = 0;
//					UpdateVehicle(idVeh,0, seg[idVeh].Trip[0].assSP, seg[idVeh].Trip[0].leaveSP, varvioCAP, seg[idVeh].numTrips - 1);
//				}
//				else 
//				{
//					double varcost = problem->c[0][seg[idVeh].Trip[0].firstCus];
//					seg[idVeh].Trip[0].cost += varcost;
//					seg[idVeh].Trip[0].fitness += varcost;
//					if (seg[idVeh].Trip[0].Type == 2) seg[idVeh].Trip[0].assSP = 0;
//					UpdateVehicle(idVeh,0, 0, 0, varvioCAP,seg[idVeh].numTrips - 1);
//				}
//			}
//			else  //middle delivery trip becomes empty: 6 cases
//			{
//				//Don toa:
//				for (i=idTrip;i<seg[idVeh].numTrips; i++)
//				{
//					seg[idVeh].Trip[i] = seg[idVeh].Trip[i+1];
//					UpdateTripnum(idVeh,i);
//				}
//				int preT = idTrip - 1;
//				int assSPpreT = seg[idVeh].Trip[preT].assSP;
//				double varC;
//
//				if (seg[idVeh].Trip[preT].Type == 0) //preTrip is pickup trip
//				{
//					if (seg[idVeh].Trip[idTrip].Type == 1) //preTrip is pickup trip and nextTrip is delivery trip
//					{
//						updateChangeCONNECTAtSP_SPSP(idVeh, idTrip, preT, varvioCAP, seg[idVeh].numTrips - 1); //for Update_EmptyTripD and Update_EmptyTripP: connect pickuptrip(idVeh, preT) with delivery trip (idVeh, nextTrip) where (idVeh, idTrip) is already deleted 
//					}
//					else //preTrip is pickup trip and nextTrip is (pickup trip OR C2C)
//					{
//						varC = -seg[idVeh].Trip[preT].connectCost;
//						int firstC_nextT = seg[idVeh].Trip[idTrip].firstCus;
//						varC += problem->c[assSPpreT][firstC_nextT];
//						seg[idVeh].Trip[preT].waitingS1 = NO_WS;
//						seg[idVeh].Trip[preT].connectCost = problem->c[assSPpreT][firstC_nextT];
//						seg[idVeh].Trip[preT].cost += varC;
//						seg[idVeh].Trip[preT].fitness += varC;
//						if (seg[idVeh].Trip[idTrip].Type == 2) seg[idVeh].Trip[idTrip].assSP = assSPpreT;
//						UpdateVehicle(idVeh, idTrip, assSPpreT, seg[idVeh].Trip[preT].leaveSP, varvioCAP,seg[idVeh].numTrips - 1);
//					}//end preTrip is pickup trip and nextTrip is pickup trip OR C2C
//				}
//				else if (seg[idVeh].Trip[preT].Type == 1)//preTrip is delivery trip
//				{
//					if (seg[idVeh].Trip[idTrip].Type == 1) //preTrip is delivery trip, nextTrip is delivery trip
//					{
//						updateChangeCONNECTAtSP_DDORC2CD(idVeh, idTrip, preT, varvioCAP,seg[idVeh].numTrips - 1); //for Update_EmptyTripD and Update_EmptyTripP: connect deliverytrip(idVeh, preT) with delivery trip (idVeh, nextTrip) where (idVeh, idTrip) is already deleted 
//					}
//					else //preTrip is delivery trip, nextTrip is (pickup trip OR C2C)
//					{
//						varC = -seg[idVeh].Trip[preT].connectCost;
//						seg[idVeh].Trip[preT].connectCost = problem->c[seg[idVeh].Trip[preT].lastCus][seg[idVeh].Trip[idTrip].firstCus];
//						varC += seg[idVeh].Trip[preT].connectCost;
//						seg[idVeh].Trip[preT].waitingS = NO_WS;
//						seg[idVeh].Trip[preT].cost += varC;
//						seg[idVeh].Trip[preT].fitness += varC;
//						UpdateVehicle(idVeh, idTrip, seg[idVeh].Trip[preT].lastCus, seg[idVeh].Trip[preT].endS, varvioCAP, seg[idVeh].numTrips - 1);
//					}//end preTrip is delivery trip, nextTrip is (pickup trip OR C2C)
//				}//end preTrip is delivery trip
//				else //preTrip is C2C
//				{
//					if (seg[idVeh].Trip[idTrip].Type == 1) //preTrip is c2c trip, nextTrip is delivery trip
//					{
//						seg[idVeh].Trip[preT].nextSP = seg[idVeh].Trip[idTrip].assSP;
//						updateChangeCONNECTAtSP_DDORC2CD(idVeh, idTrip, preT, varvioCAP,seg[idVeh].numTrips - 1); //for Update_EmptyTripD and Update_EmptyTripP: connect deliverytrip(idVeh, preT) with delivery trip (idVeh, nextTrip) where (idVeh, idTrip) is already deleted 
//					}
//					else //preTrip is c2c trip, nextTrip is (pickup trip OR C2C)
//					{
//						seg[idVeh].Trip[preT].nextSP = -1;
//						varC = -seg[idVeh].Trip[preT].connectCost;
//						seg[idVeh].Trip[preT].connectCost = problem->c[seg[idVeh].Trip[preT].lastCus][seg[idVeh].Trip[idTrip].firstCus];
//						varC += seg[idVeh].Trip[preT].connectCost;
//						seg[idVeh].Trip[preT].waitingS = NO_WS;
//						seg[idVeh].Trip[preT].cost += varC;
//						seg[idVeh].Trip[preT].fitness += varC;
//						UpdateVehicle(idVeh, idTrip, seg[idVeh].Trip[preT].lastCus, seg[idVeh].Trip[preT].endS, varvioCAP, seg[idVeh].numTrips - 1);
//					}//end preTrip is delivery trip, nextTrip is (pickup trip OR C2C)
//				}//end preTrip is C2C
//		    }//end middle delivery trip becomes empty: 6 cases
//	} //end vehicle doesn't become empty
//    return 0;
//}




//bool Solution::Update_EmptyTripPD(int idVeh, int idTrip) //delete P-D Trips (idVeh, idTrip) 
//{
//	int assSP = seg[idVeh].Trip[idTrip].assSP;
//	int idTrip1 = idTrip + 1;
//
//	int vioCAPDEL = (seg[idVeh].Trip[idTrip].vioCAP + seg[idVeh].Trip[idTrip1].vioCAP);
//	
//	seg[idVeh].Trip[idTrip].numCus=0;
//	seg[idVeh].Trip[idTrip1].numCus=0;
//
//	seg[idVeh].numTrips -=2;
//
//	int nL = seg[idVeh].numTrips;
//	int i;
//
//	if (seg[idVeh].numTrips==0) //vehicle now becomes empty:
//	{
//         //cout<<"Vehicle "<<idVeh<<"-> now becomes empty"<<endl;
//		 numVehUsed--;
//		 return 1;
//	}
//	else //vehicle doesn't become empty
//	{
//			if (idTrip == seg[idVeh].numTrips) //last trip becomes empty
//			{
//				//cout<<"Last trip becomes empty"<<endl;
//				int preT = idTrip - 1;
//				double varcost = -seg[idVeh].Trip[preT].connectCost;
//				if (seg[idVeh].Trip[preT].Type)
//				{
//					seg[idVeh].Trip[preT].connectCost = problem->c[seg[idVeh].Trip[preT].lastCus][0];
//					seg[idVeh].Trip[preT].waitingS = NO_WS;
//				}
//				else //preT is pickup, lastTrip becomes empty:
//				{
//					seg[idVeh].Trip[preT].connectCost = problem->c[seg[idVeh].Trip[preT].assSP][0];
//					seg[idVeh].Trip[preT].waitingS1 = NO_WS;
//				}//end preT is pickup, lastTrip becomes empty
//				varcost += seg[idVeh].Trip[preT].connectCost;
//				seg[idVeh].Trip[preT].cost += varcost;
//				seg[idVeh].Trip[preT].fitness += varcost;
//				double costDEL = (seg[idVeh].Trip[idTrip].cost + seg[idVeh].Trip[idTrip1].cost);
//				double fitDEL = (seg[idVeh].Trip[idTrip].fitness + seg[idVeh].Trip[idTrip1].fitness);
//				double vioTWCDEL = (seg[idVeh].Trip[idTrip].vioTWC + seg[idVeh].Trip[idTrip1].vioTWC);
//				double vioTWSPDEL = 2*seg[idVeh].Trip[idTrip].vioTWSP;
//
//				double varFIT = varcost - fitDEL;
//				varcost -= costDEL;
//				seg[idVeh].cost += varcost; 
//				seg[idVeh].vioCAP -= vioCAPDEL;
//				seg[idVeh].vioTWC -= vioTWCDEL;
//				seg[idVeh].vioTWSP -= vioTWSPDEL;
//				seg[idVeh].fitness += varFIT;
//				cost += varcost; fitness += varFIT;
//				vioCAP -= vioCAPDEL;
//				vioTWC -= vioTWCDEL;
//				vioTWSP -= vioTWSPDEL;
//			}
//			else if (idTrip == 0) //first P-D trips become empty
//			{
//				//cout<<"first trip becomes empty"<<endl;
//				//Don toa:
//				for (i=0;i<seg[idVeh].numTrips; i++)
//				{
//					seg[idVeh].Trip[i] = seg[idVeh].Trip[i+2];
//					UpdateTripnum(idVeh,i);
//				}
//				if (seg[idVeh].Trip[0].Type) 
//				{
//					seg[idVeh].Trip[0].leaveSP = problem->leaveSP[seg[idVeh].Trip[0].assSP][4]; //load at sTW2
//					double varcost = problem->c[0][seg[idVeh].Trip[0].assSP];
//					seg[idVeh].Trip[0].cost += varcost;
//					seg[idVeh].Trip[0].fitness +=  (varcost - VTWSP * seg[idVeh].Trip[0].vioTWSP);
//					seg[idVeh].Trip[0].vioTWSP = 0;
//					UpdateVehicle(idVeh,0, seg[idVeh].Trip[0].assSP, seg[idVeh].Trip[0].leaveSP, -vioCAPDEL, seg[idVeh].numTrips -1);
//				}
//				else 
//				{
//					double varcost = problem->c[0][seg[idVeh].Trip[0].firstCus];
//					seg[idVeh].Trip[0].cost += varcost;
//					seg[idVeh].Trip[0].fitness += varcost;
//					UpdateVehicle(idVeh,0, 0, 0, -vioCAPDEL, seg[idVeh].numTrips - 1);
//				}
//			}
//			else  //middle P-D trips become empty: 6 cases
//			{
//				//Don toa:
//				for (i=idTrip;i<seg[idVeh].numTrips; i++)
//				{
//					seg[idVeh].Trip[i] = seg[idVeh].Trip[i+2];
//					UpdateTripnum(idVeh,i);
//				}
//				int preT = idTrip - 1;
//				int assSPpreT = seg[idVeh].Trip[preT].assSP;
//				double varC;
//
//				if (seg[idVeh].Trip[preT].Type == 0) //preTrip is pickup trip
//				{
//					if (seg[idVeh].Trip[idTrip].Type == 0) //preTrip is pickup trip and nextTrip is pickup trip
//					{
//						varC = -seg[idVeh].Trip[preT].connectCost;
//						int firstC_nextT = seg[idVeh].Trip[idTrip].firstCus;
//						varC += problem->c[assSPpreT][firstC_nextT];
//						seg[idVeh].Trip[preT].waitingS1 = NO_WS;
//						seg[idVeh].Trip[preT].connectCost = problem->c[assSPpreT][firstC_nextT];
//						seg[idVeh].Trip[preT].cost += varC;
//						seg[idVeh].Trip[preT].fitness += varC;
//						UpdateVehicle(idVeh, idTrip, assSPpreT, seg[idVeh].Trip[preT].leaveSP, -vioCAPDEL, seg[idVeh].numTrips - 1);
//					}
//					else //preTrip is pickup trip and nextTrip is delivery trip
//					{
//						updateChangeCONNECTAtSP_SPSP(idVeh, idTrip, preT, -vioCAPDEL, seg[idVeh].numTrips - 1); //for Update_EmptyTripD and Update_EmptyTripP: connect pickuptrip(idVeh, preT) with delivery trip (idVeh, nextTrip) where (idVeh, idTrip) is already deleted 
//					}//end preTrip is pickup trip and nextTrip is delivery trip
//				}
//				else //preTrip is delivery trip
//				{
//					if (seg[idVeh].Trip[idTrip].Type) //preTrip is delivery trip, nextTrip is delivery trip
//					{
//						updateChangeCONNECTAtSP_DDORC2CD(idVeh, idTrip, preT, -vioCAPDEL, seg[idVeh].numTrips - 1); //for Update_EmptyTripD and Update_EmptyTripP: connect deliverytrip(idVeh, preT) with delivery trip (idVeh, nextTrip) where (idVeh, idTrip) is already deleted 
//					}
//					else //preTrip is delivery trip, nextTrip is pickup trip
//					{
//						varC = -seg[idVeh].Trip[preT].connectCost;
//						seg[idVeh].Trip[preT].connectCost = problem->c[seg[idVeh].Trip[preT].lastCus][seg[idVeh].Trip[idTrip].firstCus];
//						varC += seg[idVeh].Trip[preT].connectCost;
//						seg[idVeh].Trip[preT].waitingS = NO_WS;
//						seg[idVeh].Trip[preT].cost += varC;
//						seg[idVeh].Trip[preT].fitness += varC;
//						UpdateVehicle(idVeh, idTrip, seg[idVeh].Trip[preT].lastCus, seg[idVeh].Trip[preT].endS, -vioCAPDEL, seg[idVeh].numTrips - 1);
//					}//end preTrip is delivery trip, nextTrip is pickup trip
//				}//end preTrip is delivery trip
//		    }//end middle delivery trip becomes empty: 6 cases
//	} //end vehicle doesn't become empty
//    return 0;
//}

//bool Solution::Update_EmptyTripC2C(int idVeh, int idTrip)
//{
//	//15/12/2013
//	int lastTrip = seg[idVeh].numTrips - 1;
//	seg[idVeh].numTrips --;
//	int i;
//	double varvioTWSP, varcost, varFIT;
//
//	int varvioCAP = -seg[idVeh].Trip[idTrip].vioCAP;
//	seg[idVeh].Trip[idTrip].numCus=0;
//	if (seg[idVeh].numTrips == 0) //vehicle now becomes empty:
//	{
//         //cout<<"Vehicle "<<idVeh<<"-> now becomes empty"<<endl;
//		 numVehUsed--;
//		 return 1;
//		 //UpdateMoveSPEmptyVeh(idVeh); CAN XEM
//	}
//	else //vehicle doesn't become empty
//	{
//		if (idTrip == 0) //first trip becomes empty
//		{
//			//Don toa:
//			for (i=0;i<seg[idVeh].numTrips; i++)
//			{
//				seg[idVeh].Trip[i] = seg[idVeh].Trip[i+1];
//				UpdateTripnum(idVeh,i);
//			}
//			if (seg[idVeh].Trip[0].Type == 1)
//			{
//				//seg[idVeh].Trip[0].coordinate = 0;
//				int assSP = seg[idVeh].Trip[0].assSP;
//				seg[idVeh].Trip[0].leaveSP = problem->leaveSP[assSP][4]; //load only at sTW2
//				varvioTWSP = -seg[idVeh].Trip[0].vioTWSP;
//				seg[idVeh].Trip[0].vioTWSP = 0;
//				varcost = problem->c[0][assSP];
//				seg[idVeh].Trip[0].cost += varcost;
//				varFIT = varcost + VTWSP * varvioTWSP;
//				seg[idVeh].Trip[0].fitness += varFIT;
//				UpdateVehicle(idVeh, 0, assSP, seg[idVeh].Trip[0].leaveSP, varvioCAP, seg[idVeh].numTrips - 1);
//			}
//			else
//			{
//				varcost = problem->c[0][seg[idVeh].Trip[0].firstCus];
//				seg[idVeh].Trip[0].cost += varcost;
//				seg[idVeh].Trip[0].fitness += varcost;
//				//if (seg[idVeh].Trip[0].Type == 2) seg[idVeh].Trip[0].assSP = 0;
//				UpdateVehicle(idVeh, 0, 0, 0, varvioCAP, seg[idVeh].numTrips - 1);
//			}
//		}
//		else //middle/last C2C trip becomes empty
//		{
//			int preT = idTrip - 1;
//			if (idTrip < lastTrip) //middle trip becomes empty:
//			{
//				//Don toa:
//				for (i=idTrip;i<seg[idVeh].numTrips; i++)
//				{
//					seg[idVeh].Trip[i] = seg[idVeh].Trip[i+1];
//					UpdateTripnum(idVeh,i);
//				}
//				if (seg[idVeh].Trip[preT].Type == 1)
//				{
//					if (seg[idVeh].Trip[idTrip].Type == 1) //preT is delivery trip, nextTrip is deliverytrip 
//					{
//						//seg[idVeh].Trip[idTrip].coordinate = 0;
//						cout<<"CALLING updateChangeCONNECTAtSP_DDORC2CD"<<endl;
//						updateChangeCONNECTAtSP_DDORC2CD(idVeh, idTrip, preT, varvioCAP, seg[idVeh].numTrips - 1); //for Update_EmptyTripD and Update_EmptyTripP: connect deliverytrip(idVeh, preT) with delivery trip (idVeh, nextTrip) where (idVeh, idTrip) is already deleted 
//					}
//					else //preT is delivery trip, nextTrip is (pickup OR C2C)
//					{
//						varcost = -seg[idVeh].Trip[preT].connectCost;
//						seg[idVeh].Trip[preT].connectCost = problem->c[seg[idVeh].Trip[preT].lastCus][seg[idVeh].Trip[idTrip].firstCus];
//					    varcost += seg[idVeh].Trip[preT].connectCost;
//						seg[idVeh].Trip[preT].cost += varcost;
//						seg[idVeh].Trip[preT].fitness += varcost;
//						UpdateVehicle(idVeh, idTrip, seg[idVeh].Trip[preT].lastCus, seg[idVeh].Trip[preT].endS, varvioCAP, seg[idVeh].numTrips - 1);
//					}//end preT is delivery trip, nextTrip is (pickup OR C2C)
//				}
//				else if (seg[idVeh].Trip[preT].Type == 0) //preT is pickup (middle trip becomes empty)
//				{
//					if (seg[idVeh].Trip[idTrip].Type == 1) //preT is pickup trip, nextTrip is delivery (middle trip becomes empty)
//					{
//						if (seg[idVeh].Trip[preT].assSP != seg[idVeh].Trip[idTrip].assSP)
//						{
//						   seg[idVeh].Trip[idTrip].coordinate = 0;
//						   updateChangeCONNECTAtSP_SPSP(idVeh, idTrip, preT, varvioCAP, seg[idVeh].numTrips - 1); //for Update_EmptyTripD and Update_EmptyTripP: connect pickuptrip(idVeh, preT) with delivery trip (idVeh, nextTrip) where (idVeh, idTrip) is already deleted 
//						}
//						else //create new coordinate trip:
//						{
//							seg[idVeh].Trip[idTrip].coordinate = 1;
//                            updateChangeCONNECTAtSP_SameSP(idVeh,idTrip,preT,varvioCAP,seg[idVeh].numTrips - 1);
//						}
//					}
//					else //preT is pickup trip, nextTrip is (pickup OR C2C) (middle trip becomes empty)
//					{
//						varcost = -seg[idVeh].Trip[preT].connectCost;
//						seg[idVeh].Trip[preT].connectCost = problem->c[seg[idVeh].Trip[preT].assSP][seg[idVeh].Trip[idTrip].firstCus];
//					    varcost += seg[idVeh].Trip[preT].connectCost;
//						seg[idVeh].Trip[preT].cost += varcost;
//						seg[idVeh].Trip[preT].fitness += varcost;
//						UpdateVehicle(idVeh, idTrip, seg[idVeh].Trip[preT].assSP, seg[idVeh].Trip[preT].leaveSP, varvioCAP, seg[idVeh].numTrips - 1);
//					}//end preT is pickup trip, nextTrip is pickup (middle trip becomes empty)
//				}//end preT is pickup (middle trip becomes empty)
//				else //preT is C2C
//				{
//					if (seg[idVeh].Trip[idTrip].Type == 1) //preT is C2C trip, nextTrip is deliverytrip 
//					{
//						seg[idVeh].Trip[preT].nextSP = seg[idVeh].Trip[idTrip].assSP;
//						seg[idVeh].Trip[idTrip].coordinate = 0;
//						updateChangeCONNECTAtSP_DDORC2CD(idVeh, idTrip, preT, varvioCAP, seg[idVeh].numTrips - 1); //for Update_EmptyTripD and Update_EmptyTripP: connect deliverytrip(idVeh, preT) with delivery trip (idVeh, nextTrip) where (idVeh, idTrip) is already deleted 
//					}
//					else //if (seg[idVeh].Trip[idTrip].Type == 0 || 2) //preT is C2C trip, nextTrip is pickup OR C2C
//					{
//						//seg[idVeh].Trip[preT].nextSP = -1;
//						varcost = -seg[idVeh].Trip[preT].connectCost;
//						seg[idVeh].Trip[preT].connectCost = problem->c[seg[idVeh].Trip[preT].lastCus][seg[idVeh].Trip[idTrip].firstCus];
//					    varcost += seg[idVeh].Trip[preT].connectCost;
//						seg[idVeh].Trip[preT].cost += varcost;
//						seg[idVeh].Trip[preT].fitness += varcost;
//						UpdateVehicle(idVeh, idTrip, seg[idVeh].Trip[preT].lastCus, seg[idVeh].Trip[preT].endS, varvioCAP, seg[idVeh].numTrips - 1);
//					}
//				}//end preT is C2C (middle trip becomes empty)
//			}
//			else //lastTrip becomes empty
//			{
//				varcost = - seg[idVeh].Trip[preT].connectCost;
//				if (seg[idVeh].Trip[preT].Type == 1)
//				{
//					seg[idVeh].Trip[preT].connectCost = problem->c[seg[idVeh].Trip[preT].lastCus][0];
//					seg[idVeh].Trip[preT].waitingS = NO_WS;
//				}
//				else if (seg[idVeh].Trip[preT].Type == 0)//preT is pickup, lastTrip becomes empty:
//				{
//					seg[idVeh].Trip[preT].connectCost = problem->c[seg[idVeh].Trip[preT].assSP][0];
//					seg[idVeh].Trip[preT].waitingS1 = NO_WS;
//				}//end preT is pickup, lastTrip becomes empty
//				else // preT is C2C, lastTrip becomes empty
//				{
//					seg[idVeh].Trip[preT].connectCost = problem->c[seg[idVeh].Trip[preT].lastCus][0];
//					seg[idVeh].Trip[preT].waitingS = NO_WS;
//					seg[idVeh].Trip[preT].nextSP = 0;
//				}
//				varcost += seg[idVeh].Trip[preT].connectCost;
//				seg[idVeh].Trip[preT].cost += varcost;
//				seg[idVeh].Trip[preT].fitness += varcost;
//				varFIT = varcost - seg[idVeh].Trip[idTrip].fitness;
//				varcost -= seg[idVeh].Trip[idTrip].cost;
//				seg[idVeh].cost += varcost; 
//				seg[idVeh].vioCAP -= seg[idVeh].Trip[idTrip].vioCAP;
//				seg[idVeh].vioTWC -= seg[idVeh].Trip[idTrip].vioTWC;
//				seg[idVeh].vioTWSP -= seg[idVeh].Trip[idTrip].vioTWSP;
//				seg[idVeh].fitness += varFIT;
//				cost += varcost; fitness += varFIT;
//				vioCAP -= seg[idVeh].Trip[idTrip].vioCAP;
//				vioTWC -= seg[idVeh].Trip[idTrip].vioTWC;
//				vioTWSP -= seg[idVeh].Trip[idTrip].vioTWSP;
//			}//end lastTrip becomes empty
//		}//end middle/last pickup trip becomes empty
//	}//end vehicle doesn't become empty
//	cout<<"FINISH Update_EmptyTripC2C"<<endl;
//	return 0;
//}
//void Solution::moveCusPTrip_OneTrip(int j, int i, int idVeh, int idTrip) //move customer i from its current place to place after j: both i and j are at the same trip
//{
//	//see on 2/12/2013
//    //ALMOST AS SAME AS Solution::cal_MoveCusDIAfterJ_oneTrip_nextTripP
//	int prei,suci, sucj, preID, nextID,id;
//	bool stop;
//	double cStartS, cArrTime, temp, varcost, varvioTWC, varcostpreT=0, varFIT, varC1;
//	
//	int assSP = seg[idVeh].Trip[idTrip].assSP;
//	int FCAPT;
//
//	prei=predArr[i];suci=nextArr[i]; sucj = nextArr[j];
//
//	if (pos[i] < pos[j])
//	{
//		//remove i:
//		if (prei > 0) 
//		{
//			nextArr[prei] = suci; predArr[suci] = prei;
//			cStartS = depart[prei]; preID = prei; nextID = suci;
//			FCAPT = FCAP[prei];
//	        varcost = problem->c[prei][suci] - (problem->c[prei][i] + problem->c[i][suci]);
//		}
//		else //i was the first customer of the trip
//		{
//			FCAPT = 0;
//			if (idTrip == 0)
//			{
//				cStartS = 0; preID = 0;
//				varcost = problem->c[0][suci] - (problem->c[0][i] + problem->c[i][suci]);
//			}
//			else
//			{
//			    int preT = idTrip - 1;
//				if (seg[idVeh].Trip[preT].Type == 0)
//				{
//					cStartS = seg[idVeh].Trip[preT].leaveSP;
//					preID = seg[idVeh].Trip[preT].assSP; 
//				}
//				else //if (seg[idVeh].Trip[preT].Type == 1 || 2)
//				{
//					preID = seg[idVeh].Trip[preT].lastCus;
//					cStartS = depart[preID]; 
//				}
//				varcostpreT = problem->c[preID][suci] - problem->c[preID][i];
//				seg[idVeh].Trip[preT].connectCost = problem->c[preID][suci];
//				seg[idVeh].Trip[preT].cost += varcostpreT;
//				seg[idVeh].Trip[preT].fitness += varcostpreT;
//                varcost = -problem->c[i][suci];
//			}
//			nextID = suci;
//			seg[idVeh].Trip[idTrip].firstCus = suci;
//			predArr[suci] = -1;
//		}//end i was the first customer of the trip
//
//		//Check at suci (= nextID)
//		cArrTime = cStartS + problem->c[preID][nextID];
//		temp = cArrTime - problem->node[nextID].eTW;
//		if (temp > eps) 
//		{
//			vioTWCus[suci] = temp;
//			if (prei > 0) FvioTWCus[suci] = FvioTWCus[preID] + temp;
//			else FvioTWCus[suci] = temp;
//			startS[suci] = problem->node[suci].eTW;
//			depart[suci] = problem->node[suci].depart;
//		}
//		else 
//		{
//            vioTWCus[suci] = 0;
//			if (prei > 0) FvioTWCus[suci] = FvioTWCus[preID];
//			else FvioTWCus[suci] = 0;
//			startS[suci] = PDS_MAX(cArrTime, problem->node[suci].sTW);
//			depart[suci] = startS[suci] + problem->node[suci].duration;
//		}
//		cStartS = depart[suci];
//		FCAP[suci] = FCAPT + problem->node[suci].capacity;
//		pos[suci] -=1;
//
//		
//		//from suci to j:
//		preID = suci;
//		if (suci != j)
//		{
//			nextID = nextArr[suci];
//			while (nextID != sucj)
//			{
//				pos[nextID] -=1;
//				cArrTime = cStartS + problem->c[preID][nextID];
//				temp = cArrTime - problem->node[nextID].eTW;
//				if (temp > eps)
//				{
//					vioTWCus[nextID] = temp;
//					FvioTWCus[nextID] = FvioTWCus[preID] + temp;
//					startS[nextID] = problem->node[nextID].eTW;
//					depart[nextID] = problem->node[nextID].depart;
//				}
//				else
//				{
//					vioTWCus[nextID] = 0;
//					FvioTWCus[nextID] = FvioTWCus[preID];
//					startS[nextID] = PDS_MAX(cArrTime, problem->node[nextID].sTW);
//					depart[nextID] = startS[nextID] + problem->node[nextID].duration;
//				}
//				cStartS = depart[nextID];
//				FCAP[nextID] = FCAP[preID] + problem->node[nextID].capacity;
//				preID = nextID; nextID = nextArr[nextID];
//			}
//		}
//
//		//insert i after j:
//		pos[i] = pos[j]+1;
//		cArrTime = cStartS + problem->c[j][i];
//		temp = cArrTime - problem->node[i].eTW;
//		if (temp > eps)
//		{
//			vioTWCus[i] = temp;
//			FvioTWCus[i] = FvioTWCus[j] + temp;
//			startS[i] = problem->node[i].eTW;
//			depart[i] = problem->node[i].depart;
//		}
//		else
//		{
//			vioTWCus[i] = 0;
//			FvioTWCus[i] = FvioTWCus[j];
//			startS[i] = PDS_MAX(cArrTime, problem->node[i].sTW);
//			depart[i] = startS[i] + problem->node[i].duration;
//		}
//		cStartS = depart[i];
//		FCAP[i] = FCAP[j] + problem->node[i].capacity;
//		nextArr[j] = i; predArr[i] = j; nextArr[i] = sucj;
//
//		if (sucj >0)
//		{
//			    predArr[sucj] = i;
//				varcost += ((problem->c[j][i] + problem->c[i][sucj]) - problem->c[j][sucj]);
//				//check from sucj till the end of the trip:
//				preID = i; nextID = sucj;
//				while (nextID > 0)
//				{
//					cArrTime = cStartS + problem->c[preID][nextID]; //arrTime at customer nextID
//					cStartS = PDS_MAX(cArrTime, problem->node[nextID].sTW);
//					if (PDSDIF(cStartS, startS[nextID])==0) //it means varvioTWCus[nextID] =0 if (cStartS != node[nextID].eTW)
//					{
//						temp = cStartS - problem->node[nextID].eTW;
//						if (temp > eps) vioTWCus[nextID] = temp;
//						else vioTWCus[nextID] = 0;
//					
//						//Update BvioTWCus from nextID to firstCus
//						//Update BCAP from i to firstCus
//						//Update FvioTWCus from nextID to lastCus  //dont need FCAP 
//						id = nextArr[nextID];
//						if (id < 0) BvioTWCus[nextID] = vioTWCus[nextID];
//						else BvioTWCus[nextID] = BvioTWCus[id] + vioTWCus[nextID];
//
//						id = nextID;
//						while (preID != i)
//						{
//							BvioTWCus[preID] = BvioTWCus[id] + vioTWCus[preID];
//							id = preID; preID = predArr[id];
//						}
//						//update BCAP and BvioTWCus at i
//						BvioTWCus[i] = BvioTWCus[id] + vioTWCus[i];
//						BCAP[i] = BCAP[id] + problem->node[i].capacity;
//
//						//update BCAP from j to firstCus
//						preID = j; id = i;
//						while (preID > 0)
//						{
//							BvioTWCus[preID] = BvioTWCus[id] + vioTWCus[preID];
//							BCAP[preID] = BCAP[id] + problem->node[preID].capacity;
//							id = preID; preID = predArr[id];
//						}
//						//update FvioTWCus from nextID to lastCus: //don't need FCAP
//						id = nextID; preID = predArr[nextID];
//						do
//						{
//							FvioTWCus[id] = FvioTWCus[preID] + vioTWCus[id];
//							preID = id; id = nextArr[id];
//						}while (id > 0);
//						//preID now points to the last cus
//						varvioTWC = FvioTWCus[preID] - seg[idVeh].Trip[idTrip].vioTWC; 
//						seg[idVeh].Trip[idTrip].vioTWC = FvioTWCus[preID];
//						goto UpdateNC; //not changed: endS, ...
//				}
//				temp = cStartS - problem->node[nextID].eTW;
//				if (temp > eps)
//				{
//					if (vioTWCus[nextID] > eps) 
//					{
//						vioTWCus[nextID] = temp;
//						//Update BvioTWCus from nextID to firstCus
//						//Update BCAP from i to firstCus
//						//Update FvioTWCus from nextID to lastCus //dont need FCAP
//						id = nextArr[nextID];
//						if (id < 0) BvioTWCus[nextID] = vioTWCus[nextID];
//						else BvioTWCus[nextID] = BvioTWCus[id] + vioTWCus[nextID];
//
//						id = nextID;
//						while (preID != i)
//						{
//							BvioTWCus[preID] = BvioTWCus[id] + vioTWCus[preID];
//							id = preID; preID = predArr[id];
//						}
//						//Update BCAP and BvioTWCus at i
//						BCAP[i] = BCAP[id] + problem->node[i].capacity;
//						BvioTWCus[i] = BvioTWCus[id] + vioTWCus[i];
//
//						//update BCAP from j to firstCus:
//						preID = j; id = i;
//						while (preID > 0)
//						{
//							BvioTWCus[preID] = BvioTWCus[id] + vioTWCus[preID];
//							BCAP[preID] = BCAP[id] + problem->node[preID].capacity;
//							id = preID; preID = predArr[id];
//						}
//
//						//Update FvioTWCus from nextID to lastCus //dont need FCAP
//						id = nextID; preID = predArr[nextID];
//						do
//						{
//							FvioTWCus[id] = FvioTWCus[preID] + vioTWCus[id];
//							preID = id; id = nextArr[id];
//						}while (id > 0);
//						//preID now points to the last cus
//						varvioTWC = FvioTWCus[preID] - seg[idVeh].Trip[idTrip].vioTWC;
//						seg[idVeh].Trip[idTrip].vioTWC = FvioTWCus[preID];
//						goto UpdateNC; //not changed: endS, ...
//					
//					}
//					vioTWCus[nextID] = temp;
//					FvioTWCus[nextID] = FvioTWCus[preID] + temp;
//					//dont need FCAP
//					cStartS = problem->node[nextID].eTW;
//				}
//				else 
//				{
//					vioTWCus[nextID] = 0;
//					FvioTWCus[nextID] = FvioTWCus[preID];
//				}
//				startS[nextID] = cStartS;
//				cStartS += problem->node[nextID].duration;
//				depart[nextID] = cStartS;
//				//don't need FCAP
//				preID = nextID; nextID = nextArr[nextID];
//			}//end while (nextID > 0)
//			seg[idVeh].Trip[idTrip].endS = cStartS;
//			varvioTWC = FvioTWCus[preID] - seg[idVeh].Trip[idTrip].vioTWC;
//			seg[idVeh].Trip[idTrip].vioTWC = FvioTWCus[preID];
//			//preID now points to the last cus:
//			//Update BCAP from i to firstCus
//			//Update BvioTWCus from lastCus to firstCus
//			BvioTWCus[preID] = vioTWCus[preID];
//			id = predArr[preID];
//			while (id != i)
//			{
//				BvioTWCus[id] = BvioTWCus[preID] + vioTWCus[id];
//				preID = id; id = predArr[id];
//			}
//			while (id > 0)
//			{
//				BvioTWCus[id] = BvioTWCus[preID] + vioTWCus[id];
//				BCAP[id] = BCAP[preID] + problem->node[id].capacity;
//				preID = id; id = predArr[id];
//			}
//			preID = seg[idVeh].Trip[idTrip].lastCus;
//			if (seg[idVeh].Trip[idTrip].waitingS == NO_WS) varcost -= problem->c[preID][assSP];
//			else varcost -= problem->disCWSSP[preID][assSP];
//			goto UpdateC;
//		}
//		else //j was the last pick cus
//		{
//			//lastCChanged = 1;
//			seg[idVeh].Trip[idTrip].lastCus = i;
//			seg[idVeh].Trip[idTrip].endS = depart[i];
//			varvioTWC = FvioTWCus[i] - seg[idVeh].Trip[idTrip].vioTWC;
//			seg[idVeh].Trip[idTrip].vioTWC = FvioTWCus[i];
//
//			//Update BCAP from lastCus(i) to prei
//			//Update BvioTWCus from lastCus to firstCus
//			BvioTWCus[i] = vioTWCus[i]; BCAP[i] = problem->node[i].capacity;
//			id = predArr[i]; preID = i;
//			while (id != prei)
//			{
//				BvioTWCus[id] = BvioTWCus[preID] + vioTWCus[id];
//				BCAP[id] = BCAP[preID] + problem->node[id].capacity;
//				preID = id; id = predArr[id];
//			}
//			while (id > 0)
//			{
//				BvioTWCus[id] = BvioTWCus[preID] + vioTWCus[id];
//				preID = id; id = predArr[id];
//			}
//
//			preID = i; 
//			varcost += problem->c[j][i];
//			if (seg[idVeh].Trip[idTrip].waitingS == NO_WS) varcost -= problem->c[j][assSP];
//			else varcost -= problem->disCWSSP[j][assSP];
//			goto UpdateC;
//		}//end j was the last pick cus
//	}
//	else // i after j and nextArr[j] != i:
//	{
//		//insert i after j:
//		pos[i] = pos[j]+1;
//		cArrTime = depart[j] + problem->c[j][i];
//		temp = cArrTime - problem->node[i].eTW;
//		if (temp > eps)
//		{
//			vioTWCus[i] = temp;
//			FvioTWCus[i] = FvioTWCus[j] + temp;
//			startS[i] = problem->node[i].eTW;
//			depart[i] = problem->node[i].depart;
//		}
//		else
//		{
//			vioTWCus[i] = 0;
//			FvioTWCus[i] = FvioTWCus[j];
//			startS[i] = PDS_MAX(cArrTime, problem->node[i].sTW);
//			depart[i] = startS[i] + problem->node[i].duration;
//		}
//		cStartS = depart[i];
//		FCAP[i] = FCAP[j] + problem->node[i].capacity;
//
//		//from i to sucj: because nextArr[j] !=i then sucj can not be the endSP:
//		pos[sucj]++;
//		cArrTime = cStartS + problem->c[i][sucj];
//		temp = cArrTime - problem->node[sucj].eTW;
//		if (temp > eps)
//		{
//			vioTWCus[sucj] = temp;
//			FvioTWCus[sucj] = FvioTWCus[i] + temp;
//			startS[sucj] = problem->node[sucj].eTW;
//			depart[sucj] = problem->node[sucj].depart;
//		}
//		else
//		{
//			vioTWCus[sucj] = 0;
//			FvioTWCus[sucj] = FvioTWCus[i];
//			startS[sucj] = PDS_MAX(cArrTime, problem->node[sucj].sTW);
//			depart[sucj] = startS[sucj] + problem->node[sucj].duration;
//		}
//		cStartS = depart[sucj];
//		FCAP[sucj] = FCAP[i] + problem->node[sucj].capacity;
//        varcost = problem->c[j][i] + problem->c[i][sucj] - problem->c[j][sucj];
//		preID = sucj; nextID = nextArr[sucj];
//		//checking from sucj till prei:
//		while (nextID != i)
//		{
//			pos[nextID]++;
//			cArrTime = depart[preID] + problem->c[preID][nextID];
//			temp = cArrTime - problem->node[nextID].eTW;
//			if (temp > eps)
//			{
//				vioTWCus[nextID] = temp;
//				FvioTWCus[nextID] = FvioTWCus[preID] + temp;
//				startS[nextID] = problem->node[nextID].eTW;
//				depart[nextID] = problem->node[nextID].depart;
//			}
//			else
//			{
//				vioTWCus[nextID] = 0;
//				FvioTWCus[nextID] = FvioTWCus[preID];
//				startS[nextID] = PDS_MAX(cArrTime, problem->node[nextID].sTW);
//				depart[nextID] = startS[nextID] + problem->node[nextID].duration;
//			}
//			FCAP[nextID] = FCAP[preID] + problem->node[nextID].capacity;
//			preID = nextID; nextID = nextArr[nextID];
//		}
//		cStartS = depart[preID];
//		nextArr[j] = i; predArr[i] = j; nextArr[i] = sucj; predArr[sucj] = i;
//		nextArr[prei] = suci;
//
//		//now preID points to prei:
//		//from prei to suci & suci till the end of the trip:
//		if (suci > 0) // i was not the last customer of the trip
//		{
//			predArr[suci] = prei;
//			varcost += (problem->c[prei][suci] - problem->c[prei][i] - problem->c[i][suci]);
//			nextID = suci;
//			while (nextID > 0)
//			{
//				cArrTime = cStartS + problem->c[preID][nextID];
//				cStartS = PDS_MAX(cArrTime, problem->node[nextID].sTW);
//				if (PDSDIF(cStartS, startS[nextID])==0) //it means varvioTWCus[nextID] =0 if (cStartS != node[nextID].eTW)
//				{
//					temp = cStartS - problem->node[nextID].eTW;
//					if (temp > eps) vioTWCus[nextID] = temp;
//					else vioTWCus[nextID] = 0;
//					
//					//Update BvioTWCus from nextID to firstCus
//					//Update BCAP from prei to firstCus
//					//Update FvioTWCus from nextID to lastCus  //dont need FCAP 
//					id = nextArr[nextID];
//					if (id < 0) BvioTWCus[nextID] = vioTWCus[nextID];
//					else BvioTWCus[nextID] = BvioTWCus[id] + vioTWCus[nextID];
//
//					id = nextID;
//					while (preID != prei)
//					{
//						BvioTWCus[preID] = BvioTWCus[id] + vioTWCus[preID];
//						id = preID; preID = predArr[id];
//					}
//					//update BCAP and BvioTWCus at prei
//					BvioTWCus[prei] = BvioTWCus[id] + vioTWCus[prei];
//					BCAP[prei] = BCAP[id] + problem->node[prei].capacity;
//
//					//update BCAP from predArr[prei] to firstCus
//					preID = predArr[prei]; id = prei;
//					while (preID > 0)
//					{
//						BvioTWCus[preID] = BvioTWCus[id] + vioTWCus[preID];
//						BCAP[preID] = BCAP[id] + problem->node[preID].capacity;
//						id = preID; preID = predArr[id];
//					}
//					//update FvioTWCus from nextID to lastCus: //don't need FCAP
//					id = nextID; preID = predArr[nextID];
//					do
//					{
//						FvioTWCus[id] = FvioTWCus[preID] + vioTWCus[id];
//						preID = id; id = nextArr[id];
//					}while (id > 0);
//					//preID now points to the last cus
//					varvioTWC = FvioTWCus[preID] - seg[idVeh].Trip[idTrip].vioTWC; 
//					seg[idVeh].Trip[idTrip].vioTWC = FvioTWCus[preID];
//					goto UpdateNC; //not changed: endS, ...
//				}
//				temp = cStartS - problem->node[nextID].eTW;
//				if (temp > eps)
//				{
//					if (vioTWCus[nextID] > eps) 
//					{
//						vioTWCus[nextID] = temp;
//						//Update BvioTWCus from nextID to firstCus
//						//Update BCAP from prei to firstCus
//						//Update FvioTWCus from nextID to lastCus //dont need FCAP
//						id = nextArr[nextID];
//						if (id < 0) BvioTWCus[nextID] = vioTWCus[nextID];
//						else BvioTWCus[nextID] = BvioTWCus[id] + vioTWCus[nextID];
//
//						id = nextID;
//						while (preID != prei)
//						{
//							BvioTWCus[preID] = BvioTWCus[id] + vioTWCus[preID];
//							id = preID; preID = predArr[id];
//						}
//						//Update BCAP and BvioTWCus at prei
//						BCAP[prei] = BCAP[id] + problem->node[prei].capacity;
//						BvioTWCus[prei] = BvioTWCus[id] + vioTWCus[prei];
//
//						//update BCAP from predArr[prei] to firstCus:
//						preID = predArr[prei]; id = prei;
//						while (preID > 0)
//						{
//							BvioTWCus[preID] = BvioTWCus[id] + vioTWCus[preID];
//							BCAP[preID] = BCAP[id] + problem->node[preID].capacity;
//							id = preID; preID = predArr[id];
//						}
//						//Update FvioTWCus from nextID to lastCus //dont need FCAP
//						id = nextID; preID = predArr[nextID];
//						do
//						{
//							FvioTWCus[id] = FvioTWCus[preID] + vioTWCus[id];
//							preID = id; id = nextArr[id];
//						}while (id > 0);
//						//preID now points to the last cus
//						varvioTWC = FvioTWCus[preID] - seg[idVeh].Trip[idTrip].vioTWC;
//						seg[idVeh].Trip[idTrip].vioTWC = FvioTWCus[preID];
//						goto UpdateNC;
//
//					}
//					vioTWCus[nextID] = temp;
//					FvioTWCus[nextID] = FvioTWCus[preID] + temp;
//					//dont need FCAP
//					cStartS = problem->node[nextID].eTW;
//				}
//				else 
//				{
//					vioTWCus[nextID] = 0;
//					FvioTWCus[nextID] = FvioTWCus[preID];
//				}
//				startS[nextID] = cStartS;
//				cStartS += problem->node[nextID].duration;
//				depart[nextID] = cStartS;
//				//don't need FCAP
//				preID = nextID; nextID = nextArr[nextID];
//			}//end while(nextID > 0)
//			seg[idVeh].Trip[idTrip].endS = cStartS;
//			varvioTWC = FvioTWCus[preID] - seg[idVeh].Trip[idTrip].vioTWC;
//			seg[idVeh].Trip[idTrip].vioTWC = FvioTWCus[preID];
//			//preID now points to the last cus:
//			//Update BCAP from prei to firstCus
//			//Update BvioTWCus from lastCus to firstCus
//			BvioTWCus[preID] = vioTWCus[preID];
//			id = predArr[preID];
//			while (id != prei)
//			{
//				BvioTWCus[id] = BvioTWCus[preID] + vioTWCus[id];
//				preID = id; id = predArr[id];
//			}
//			while (id > 0)
//			{
//				BvioTWCus[id] = BvioTWCus[preID] + vioTWCus[id];
//				BCAP[id] = BCAP[preID] + problem->node[id].capacity;
//				preID = id; id = predArr[id];
//			}
//			preID = seg[idVeh].Trip[idTrip].lastCus;
//			if (seg[idVeh].Trip[idTrip].waitingS == NO_WS) varcost -= problem->c[preID][assSP];
//			else varcost -= problem->disCWSSP[preID][assSP];
//			goto UpdateC;
//		}
//		else //i was the last customer of the trip:
//		{
//			//lastCChanged = 1;
//			seg[idVeh].Trip[idTrip].lastCus = prei;
//			seg[idVeh].Trip[idTrip].endS = depart[prei];
//			varvioTWC = FvioTWCus[prei] - seg[idVeh].Trip[idTrip].vioTWC;
//			seg[idVeh].Trip[idTrip].vioTWC = FvioTWCus[prei];
//
//			//Update BCAP, BvioTWCus from lastCus to firstCus
//			BvioTWCus[prei] = vioTWCus[prei];
//			BCAP[prei] = problem->node[prei].capacity;
//			id = predArr[prei]; preID = prei;
//			while (id > 0)
//			{
//				BvioTWCus[id] = BvioTWCus[preID] + vioTWCus[id];
//				BCAP[id] = BCAP[preID] + problem->node[id].capacity;
//				preID = id; id = predArr[id];
//			}
//			if (seg[idVeh].Trip[idTrip].waitingS == NO_WS)
//				varcost -= (problem->c[prei][i] + problem->c[i][assSP]);
//			else varcost -= (problem->c[prei][i] + problem->disCWSSP[i][assSP]);
//			goto UpdateC;
//		}
//		//now preID points to the NEW last delivery customer of the trip:
//	}
//UpdateNC: //not changed: endS, ...
//	    //cout<<"NOT CHANGED"<<endl;
//		varFIT = varcost + VTWCUS * varvioTWC;
//		seg[idVeh].Trip[idTrip].cost += varcost;
//		if (seg[idVeh].Trip[idTrip].vioCAP > 0 || seg[idVeh].Trip[idTrip].vioTWC > eps || seg[idVeh].Trip[idTrip].vioTWSP > eps)
//		{
//			seg[idVeh].Trip[idTrip].feasible = 0;
//			seg[idVeh].Trip[idTrip].fitness += varFIT;
//		}
//		else
//		{
//			seg[idVeh].Trip[idTrip].feasible = 1;
//			seg[idVeh].Trip[idTrip].fitness = seg[idVeh].Trip[idTrip].cost;
//		}
//		varC1 = varcost + varcostpreT;
//		varFIT += varcostpreT;
//		seg[idVeh].cost += varC1; seg[idVeh].fitness += varFIT; seg[idVeh].vioTWC += varvioTWC;
//		cost += varC1; fitness += varFIT;vioTWC += varvioTWC;
//		stop = checkVehicle(idVeh);
//		if (stop)
//		{
//			cout<<"CASE1: STOP AT moveCusPTrip @IT = "<<IT<<endl;
//			exit(-1);
//		}
//		return;
//	//preID is now the last customer of the trip and cStartS is time to leave the NEW last customer of current vehicle
//UpdateC:
//   // cout<<"CHANGED --> CALL UpdateChangeCONNECTAtSP_PickTrip"<<endl;
//	UpdateChangeCONNECTAtSP_PickTrip(idVeh, idTrip, varcost, varcostpreT, varvioTWC,0,seg[idVeh].numTrips - 1);
//	stop = checkVehicle(idVeh);
//	if (stop)
//	{
//		cout<<"CASE2: STOP AT moveCusPTrip @IT = "<<IT<<endl;
//		exit(-1);
//	}
// }
//
//void Solution::UpdateChangeCONNECTAtSP_PickTrip(int idVeh, int idTrip, double varcostpreT, double varvioTWC, int varvioCAP, double costTrip) //for twoOPTstarCusPTrip,insertCusPArraySuc,insertCusPArrayPre
//{
//	//See on 2/12/2013
//	//Update all change for pickup trip (idVeh, idTrip) and then all ramainning trips in idVeh vehicle if neccessary
//	//ALMOST AS SAME AS Solution::calChangeCONNECTAtSP_PickTrip
//	//calculate variation of varcost, varvioTWSP, cStartS when connecting lastC of pickup trip (idVeh, idTrip) with its assSP
//
//	int	assSP = seg[idVeh].Trip[idTrip].assSP;
//	int lastC = seg[idVeh].Trip[idTrip].lastCus;
//	double varvioTWSP, varcost;
//	double cStartS, temp, varFIT, varC1;
//	int nextTrip;
//
//	double	cArrTime = seg[idVeh].Trip[idTrip].endS + problem->c[lastC][assSP];
//
//	if (PDSINRANGE(cArrTime, problem->nodeSP[assSP].sTW1, problem->nodeSP[assSP].eTW1))
//	{
//		varvioTWSP = -seg[idVeh].Trip[idTrip].vioTWSP;
//		seg[idVeh].Trip[idTrip].vioTWSP = 0;
//		costTrip += problem->c[lastC][assSP];
//		cStartS = cArrTime + problem->nodeSP[assSP].unload;
//		seg[idVeh].Trip[idTrip].waitingS = NO_WS;
//		if (PDSDIF(cStartS, seg[idVeh].Trip[idTrip].leaveSP)) goto UpdateC;
//		else goto UpdateNC;
//	}
//	else
//	{
//		temp = cArrTime - problem->nodeSP[assSP].eTW1;
//		if (temp > eps)
//		{
//			varvioTWSP = (temp - seg[idVeh].Trip[idTrip].vioTWSP);
//			costTrip += problem->c[lastC][assSP];
//			if (seg[idVeh].Trip[idTrip].vioTWSP > eps)
//			{
//				seg[idVeh].Trip[idTrip].vioTWSP = temp;
//				goto UpdateNC;
//			}
//			seg[idVeh].Trip[idTrip].vioTWSP = temp;
//			cStartS = problem->leaveSP[assSP][0]; //unload only at eTW1
//			seg[idVeh].Trip[idTrip].waitingS = NO_WS;
//			goto UpdateC;
//		}
//		else
//		{
//			double cArrTimeI = seg[idVeh].Trip[idTrip].endS + problem->disCWSSP[lastC][assSP];
//			temp = cArrTimeI - problem->nodeSP[assSP].eTW1;
//			if (temp > eps) //too soon to go sp directly, too late through WS
//			{
//				temp = problem->nodeSP[assSP].sTW1 - cArrTime;
//				varvioTWSP = (temp - seg[idVeh].Trip[idTrip].vioTWSP);
//				costTrip += problem->c[lastC][assSP];
//				if (seg[idVeh].Trip[idTrip].vioTWSP > eps) 
//				{
//					seg[idVeh].Trip[idTrip].vioTWSP = temp;
//					goto UpdateNC;
//				}
//				seg[idVeh].Trip[idTrip].vioTWSP = temp;
//				seg[idVeh].Trip[idTrip].waitingS = NO_WS;
//				cStartS = problem->leaveSP[assSP][0]; //unload only at eTW1
//				goto UpdateC;
//			}
//			else //go through WS:
//			{
//				varvioTWSP = -seg[idVeh].Trip[idTrip].vioTWSP;
//				costTrip += problem->disCWSSP[lastC][assSP];
//				seg[idVeh].Trip[idTrip].vioTWSP = 0;
//				seg[idVeh].Trip[idTrip].waitingS = problem->CWSSP[lastC][assSP];
//				cStartS = PDS_MAX(cArrTimeI, problem->nodeSP[assSP].sTW1) + problem->nodeSP[assSP].unload;
//				if (PDSDIF(cStartS, seg[idVeh].Trip[idTrip].leaveSP)) goto UpdateC;
//				else goto UpdateNC;
//			}
//		}
//	}
//UpdateNC: //not changed: leaveSP, ...
//	costTrip += seg[idVeh].Trip[idTrip].connectCost;
//	varcost = costTrip - seg[idVeh].Trip[idTrip].cost;
//	seg[idVeh].Trip[idTrip].cost = costTrip;
//	varFIT = varcost + VTWCUS * varvioTWC + VTWSP * varvioTWSP + VCAP * varvioCAP;
//	if (seg[idVeh].Trip[idTrip].vioCAP > 0 || seg[idVeh].Trip[idTrip].vioTWC > eps || seg[idVeh].Trip[idTrip].vioTWSP > eps)
//	{
//		seg[idVeh].Trip[idTrip].feasible = 0;
//		seg[idVeh].Trip[idTrip].fitness += varFIT;
//	}
//	else
//	{
//		seg[idVeh].Trip[idTrip].feasible = 1;
//		seg[idVeh].Trip[idTrip].fitness = seg[idVeh].Trip[idTrip].cost;
//	}
//	nextTrip = idTrip + 1;
//	if (nextTrip < seg[idVeh].numTrips)
//	{
//		if (seg[idVeh].Trip[nextTrip].Type == 1)
//		{
//			if (seg[idVeh].Trip[nextTrip].assSP == assSP)
//			{
//				//Update 17/11/2013: there is a case where pickup trip after the move has the leaveSP = eTW + unload same as before the move, but now not infeasible any more
//				if (seg[idVeh].Trip[nextTrip].vioTWSP > eps && seg[idVeh].Trip[idTrip].vioTWSP == 0) //before vio, after the move not vio anymore:
//				{
//					seg[idVeh].Trip[nextTrip].leaveSP = seg[idVeh].Trip[idTrip].leaveSP + problem->nodeSP[assSP].load;
//					seg[idVeh].Trip[nextTrip].vioTWSP = seg[idVeh].Trip[idTrip].vioTWSP;
//					UpdateVehicle(idVeh, nextTrip, assSP, seg[idVeh].Trip[nextTrip].leaveSP, varvioCAP, seg[idVeh].numTrips - 1);
//					return;
//				}
//				else
//				{
//					seg[idVeh].Trip[nextTrip].vioTWSP = seg[idVeh].Trip[idTrip].vioTWSP;
//					if (seg[idVeh].Trip[nextTrip].vioCAP > 0 || seg[idVeh].Trip[nextTrip].vioTWC > eps || seg[idVeh].Trip[nextTrip].vioTWSP > eps)
//					{
//						seg[idVeh].Trip[nextTrip].feasible = 0;
//						seg[idVeh].Trip[nextTrip].fitness += (VTWSP * varvioTWSP);
//					}
//					else
//					{
//						seg[idVeh].Trip[nextTrip].feasible = 1;
//						seg[idVeh].Trip[nextTrip].fitness = seg[idVeh].Trip[nextTrip].cost;
//					}
//					varFIT +=  (VTWSP * varvioTWSP);
//					varvioTWSP *= 2;
//				}
//			}
//		}
//	}
//
//	varC1 = varcost + varcostpreT;
//	varFIT += varcostpreT;
//	seg[idVeh].cost += varC1; seg[idVeh].fitness += varFIT; seg[idVeh].vioTWC += varvioTWC;seg[idVeh].vioTWSP += varvioTWSP; seg[idVeh].vioCAP += varvioCAP;
//	cost += varC1; fitness += varFIT;vioTWC += varvioTWC; vioTWSP += varvioTWSP; vioCAP += varvioCAP;
//
//	return;
//
//UpdateC:
//	seg[idVeh].Trip[idTrip].leaveSP = cStartS;
//	costTrip += seg[idVeh].Trip[idTrip].connectCost;
//	varcost = costTrip - seg[idVeh].Trip[idTrip].cost;
//	seg[idVeh].Trip[idTrip].cost = costTrip;
//	varFIT = varcost + VTWCUS * varvioTWC + VTWSP * varvioTWSP + VCAP * varvioCAP;
//	if (seg[idVeh].Trip[idTrip].vioCAP > 0 || seg[idVeh].Trip[idTrip].vioTWC > eps || seg[idVeh].Trip[idTrip].vioTWSP > eps)
//	{
//		seg[idVeh].Trip[idTrip].feasible = 0;
//		seg[idVeh].Trip[idTrip].fitness += varFIT;
//	}
//	else
//	{
//		seg[idVeh].Trip[idTrip].feasible = 1;
//		seg[idVeh].Trip[idTrip].fitness = seg[idVeh].Trip[idTrip].cost;
//	}
//	nextTrip = idTrip + 1;
//	if (nextTrip == seg[idVeh].numTrips)
//	{
//		varC1 = varcost + varcostpreT;
//		varFIT += varcostpreT;
//		seg[idVeh].cost += varC1; seg[idVeh].fitness += varFIT; seg[idVeh].vioTWC += varvioTWC;seg[idVeh].vioTWSP += varvioTWSP; seg[idVeh].vioCAP += varvioCAP;
//		cost += varC1; fitness += varFIT;vioTWC += varvioTWC; vioTWSP += varvioTWSP; vioCAP += varvioCAP;
//	}
//	else
//	{
//		if (seg[idVeh].Trip[nextTrip].Type == 1) //nextTrip is delivery trip
//		{
//			int assSP1 = seg[idVeh].Trip[nextTrip].assSP;
//			if (assSP1 == assSP) //sameSP
//			{
//				seg[idVeh].Trip[nextTrip].vioTWSP = seg[idVeh].Trip[idTrip].vioTWSP;
//				seg[idVeh].Trip[nextTrip].fitness += (VTWSP * varvioTWSP);
//				//Update 16/11/2013
//				if (seg[idVeh].Trip[nextTrip].vioTWSP > eps)
//					seg[idVeh].Trip[nextTrip].leaveSP = problem->leaveSP[assSP][1]; //load only at eTW2
//				else
//				   seg[idVeh].Trip[nextTrip].leaveSP = seg[idVeh].Trip[idTrip].leaveSP + problem->nodeSP[assSP].load;
//				UpdateVehicle(idVeh, nextTrip, assSP1, seg[idVeh].Trip[nextTrip].leaveSP, varvioCAP, seg[idVeh].numTrips - 1);
//			}
//			else //nextTrip is delivery trip, dif sp:
//			{
//				double varvioTWSP1;
//				cArrTime = seg[idVeh].Trip[idTrip].leaveSP + problem->c[assSP][assSP1];
//				if (PDSINRANGE(cArrTime, problem->nodeSP[assSP1].sTW2, problem->nodeSP[assSP1].eTW2))
//				{
//					varvioTWSP1 = -seg[idVeh].Trip[nextTrip].vioTWSP;
//					if (seg[idVeh].Trip[idTrip].waitingS1 != NO_WS)
//					{
//						seg[idVeh].Trip[idTrip].waitingS1 = NO_WS;
//						double varcost1 = (problem->c[assSP][assSP1] - problem->disCWSSP[assSP][assSP1]);
//						seg[idVeh].Trip[idTrip].connectCost = problem->c[assSP][assSP1];
//						seg[idVeh].Trip[idTrip].cost += varcost1;
//						seg[idVeh].Trip[idTrip].fitness += varcost1;
//					}
//					seg[idVeh].Trip[nextTrip].vioTWSP = 0;
//					cStartS = cArrTime + problem->nodeSP[assSP1].load;
//				}
//				else
//				{
//					double temp = cArrTime - problem->nodeSP[assSP1].eTW2;
//					if (temp > eps)
//					{
//						varvioTWSP1 = (temp - seg[idVeh].Trip[nextTrip].vioTWSP);
//						if (seg[idVeh].Trip[nextTrip].vioTWSP > eps)
//						{
//							seg[idVeh].Trip[nextTrip].vioTWSP = temp;	
//							if (seg[idVeh].Trip[nextTrip].vioCAP > 0 || seg[idVeh].Trip[nextTrip].vioTWC > eps || seg[idVeh].Trip[nextTrip].vioTWSP > eps)
//							{
//								seg[idVeh].Trip[nextTrip].feasible = 0;
//								seg[idVeh].Trip[nextTrip].fitness += (VTWSP * varvioTWSP1);
//							}
//							else
//							{
//								seg[idVeh].Trip[nextTrip].feasible = 1;
//								seg[idVeh].Trip[nextTrip].fitness = seg[idVeh].Trip[nextTrip].cost;
//							}
//							varFIT += (VTWSP * varvioTWSP1);
//							double varC1 = varcost + varcostpreT;
//							varFIT += varcostpreT;
//							varvioTWSP += varvioTWSP1;
//							seg[idVeh].cost += varC1; seg[idVeh].fitness += varFIT; seg[idVeh].vioTWC += varvioTWC;
//							seg[idVeh].vioTWSP += varvioTWSP; seg[idVeh].vioCAP += varvioCAP;
//							cost += varC1; fitness += varFIT;vioTWC += varvioTWC; vioTWSP += varvioTWSP; vioCAP += varvioCAP;
//							return;
//						}
//						if (seg[idVeh].Trip[idTrip].waitingS1 != NO_WS)
//						{
//							double varcost1 = (problem->c[assSP][assSP1] - problem->disCWSSP[assSP][assSP1]);
//							seg[idVeh].Trip[idTrip].waitingS1 = NO_WS;
//							seg[idVeh].Trip[idTrip].connectCost = problem->c[assSP][assSP1];
//							seg[idVeh].Trip[idTrip].cost += varcost1;
//							seg[idVeh].Trip[idTrip].fitness += varcost1;
//						}
//						seg[idVeh].Trip[nextTrip].vioTWSP = temp;	
//						cStartS = problem->leaveSP[assSP1][1]; //load only at eTW2
//					}
//					else
//					{
//						double cArrTimeI = seg[idVeh].Trip[idTrip].leaveSP + problem->disCWSSP[assSP][assSP1];
//						temp = cArrTimeI - problem->nodeSP[assSP1].eTW2;
//						if (temp > eps) //too soon to go sp directly, too late to go through WS:
//						{
//							temp = problem->nodeSP[assSP1].sTW2 - cArrTime;
//							varvioTWSP1 = temp - seg[idVeh].Trip[nextTrip].vioTWSP;
//							if (seg[idVeh].Trip[nextTrip].vioTWSP > eps)
//							{
//								seg[idVeh].Trip[nextTrip].vioTWSP = temp;	
//								if (seg[idVeh].Trip[nextTrip].vioCAP > 0 || seg[idVeh].Trip[nextTrip].vioTWC > eps || seg[idVeh].Trip[nextTrip].vioTWSP > eps)
//								{
//									seg[idVeh].Trip[nextTrip].feasible = 0;
//									seg[idVeh].Trip[nextTrip].fitness += (VTWSP * varvioTWSP1);
//								}
//								else
//								{
//									seg[idVeh].Trip[nextTrip].feasible = 1;
//									seg[idVeh].Trip[nextTrip].fitness = seg[idVeh].Trip[nextTrip].cost;
//								}
//								varFIT += (VTWSP * varvioTWSP1);
//								double varC1 = varcost + varcostpreT;
//								varFIT += varcostpreT;
//								varvioTWSP += varvioTWSP1;
//								seg[idVeh].cost += varC1; seg[idVeh].fitness += varFIT; seg[idVeh].vioTWC += varvioTWC;
//								seg[idVeh].vioTWSP += varvioTWSP; seg[idVeh].vioCAP += varvioCAP;
//								cost += varC1; fitness += varFIT;vioTWC += varvioTWC; vioTWSP += varvioTWSP; vioCAP += varvioCAP;
//								return;
//							}
//							if (seg[idVeh].Trip[idTrip].waitingS1 != NO_WS)
//							{
//								double varcost1 = (problem->c[assSP][assSP1] - problem->disCWSSP[assSP][assSP1]);
//								seg[idVeh].Trip[idTrip].waitingS1 = NO_WS;
//								seg[idVeh].Trip[idTrip].connectCost = problem->c[assSP][assSP1];
//								seg[idVeh].Trip[idTrip].cost += varcost1;
//								seg[idVeh].Trip[idTrip].fitness += varcost1;
//							}
//							seg[idVeh].Trip[nextTrip].vioTWSP = temp;
//							cStartS = problem->leaveSP[assSP1][1]; //load at eTW2
//						}
//						else //go through WS:
//						{
//							varvioTWSP1 = -seg[idVeh].Trip[nextTrip].vioTWSP;
//							if (seg[idVeh].Trip[idTrip].waitingS1 == NO_WS)
//							{
//								double varcost1 = (problem->disCWSSP[assSP][assSP1] - problem->c[assSP][assSP1]);
//								seg[idVeh].Trip[idTrip].waitingS1 = problem->CWSSP[assSP][assSP1];
//								seg[idVeh].Trip[idTrip].connectCost = problem->disCWSSP[assSP][assSP1];
//								seg[idVeh].Trip[idTrip].cost += varcost1;
//								seg[idVeh].Trip[idTrip].fitness += varcost1;
//							}
//							seg[idVeh].Trip[nextTrip].vioTWSP = 0;
//							cStartS = PDS_MAX(cArrTimeI, problem->nodeSP[assSP1].sTW2) + problem->nodeSP[assSP1].load;
//						}//end go through WS
//					}
//				}
//				//Can't happen the case where seg[idVeh].Trip[nextTrip].leaveSP doesn't change; because already checking if seg[idVeh].Trip[idTrip].leaveSP changed or not before coming here
//				seg[idVeh].Trip[nextTrip].leaveSP = cStartS;
//				seg[idVeh].Trip[nextTrip].fitness += (VTWSP * varvioTWSP1);
//				UpdateVehicle(idVeh, nextTrip, assSP1, seg[idVeh].Trip[nextTrip].leaveSP, varvioCAP, seg[idVeh].numTrips - 1);
//			}//end nextTrip is delivery trip, dif sp
//		}
//		else //nextTrip is pickup trip OR C2C
//		{
//			UpdateVehicle(idVeh, nextTrip, assSP, seg[idVeh].Trip[idTrip].leaveSP, varvioCAP, seg[idVeh].numTrips - 1);
//		}//end nextTrip is pickup trip OR C2C
//	}
//}
//
//
//void Solution::UpdateChangeCONNECTAtSP_PickTrip(int idVeh, int idTrip, double varcost, double varcostpreT, double varvioTWC, int varvioCAP, int update_idTrip) //for  moveCusPTrip_OneTrip, deleteCusP
//{
//	//see on 2/12/2013
//	//Update all change for pickup trip (idVeh, idTrip) and then all remainning trips till update_idTrip trip in idVeh vehicle if neccessary
//	//Dif from UpdateChangeCONNECTAtSP_PickTrip: just update remaining trips till update_idTrip rather than all remainning trips of idVeh
//	
//	//calculate variation of varcost, varvioTWSP, cStartS when connecting lastC of pickup trip (idVeh, idTrip) with its assSP
//
//	int	assSP = seg[idVeh].Trip[idTrip].assSP;
//	int lastC = seg[idVeh].Trip[idTrip].lastCus;
//	double varvioTWSP;
//	double cStartS, temp, varFIT, varC1;
//	int nextTrip;
//
//	double	cArrTime = seg[idVeh].Trip[idTrip].endS + problem->c[lastC][assSP];
//
//	if (PDSINRANGE(cArrTime, problem->nodeSP[assSP].sTW1, problem->nodeSP[assSP].eTW1))
//	{
//		varvioTWSP = -seg[idVeh].Trip[idTrip].vioTWSP;
//		seg[idVeh].Trip[idTrip].vioTWSP = 0;
//		varcost += problem->c[lastC][assSP];
//		cStartS = cArrTime + problem->nodeSP[assSP].unload;
//		seg[idVeh].Trip[idTrip].waitingS = NO_WS;
//		if (PDSDIF(cStartS, seg[idVeh].Trip[idTrip].leaveSP)) goto UpdateC;
//		else goto UpdateNC;
//	}
//	else
//	{
//		temp = cArrTime - problem->nodeSP[assSP].eTW1;
//		if (temp > eps)
//		{
//			varvioTWSP = (temp - seg[idVeh].Trip[idTrip].vioTWSP);
//			varcost += problem->c[lastC][assSP];
//			if (seg[idVeh].Trip[idTrip].vioTWSP > eps)
//			{
//				seg[idVeh].Trip[idTrip].vioTWSP = temp;
//				goto UpdateNC;
//			}
//			seg[idVeh].Trip[idTrip].vioTWSP = temp;
//			cStartS = problem->leaveSP[assSP][0]; //unload at eTW1
//			seg[idVeh].Trip[idTrip].waitingS = NO_WS;
//			goto UpdateC;
//		}
//		else
//		{
//			double cArrTimeI = seg[idVeh].Trip[idTrip].endS + problem->disCWSSP[lastC][assSP];
//			temp = cArrTimeI - problem->nodeSP[assSP].eTW1;
//			if (temp > eps) //too soon to go sp directly, too late through WS
//			{
//				temp = problem->nodeSP[assSP].sTW1 - cArrTime;
//				varvioTWSP = (temp - seg[idVeh].Trip[idTrip].vioTWSP);
//				varcost += problem->c[lastC][assSP];
//				if (seg[idVeh].Trip[idTrip].vioTWSP > eps) 
//				{
//					seg[idVeh].Trip[idTrip].vioTWSP = temp;
//					goto UpdateNC;
//				}
//				seg[idVeh].Trip[idTrip].vioTWSP = temp;
//				seg[idVeh].Trip[idTrip].waitingS = NO_WS;
//				cStartS = problem->leaveSP[assSP][0]; //unload only at eTW1
//				goto UpdateC;
//			}
//			else //go through WS:
//			{
//				varvioTWSP = -seg[idVeh].Trip[idTrip].vioTWSP;
//				varcost += problem->disCWSSP[lastC][assSP];
//				seg[idVeh].Trip[idTrip].vioTWSP = 0;
//				seg[idVeh].Trip[idTrip].waitingS = problem->CWSSP[lastC][assSP];
//				cStartS = PDS_MAX(cArrTimeI, problem->nodeSP[assSP].sTW1) + problem->nodeSP[assSP].unload;
//				if (PDSDIF(cStartS, seg[idVeh].Trip[idTrip].leaveSP)) goto UpdateC;
//				else goto UpdateNC;
//			}
//		}
//	}
//UpdateNC: //not changed: leaveSP, ...
//	varFIT = varcost + VTWCUS * varvioTWC + VTWSP * varvioTWSP + VCAP * varvioCAP;
//	seg[idVeh].Trip[idTrip].cost += varcost;
//	if (seg[idVeh].Trip[idTrip].vioCAP > 0 || seg[idVeh].Trip[idTrip].vioTWC > eps || seg[idVeh].Trip[idTrip].vioTWSP > eps)
//	{
//		seg[idVeh].Trip[idTrip].feasible = 0;
//		seg[idVeh].Trip[idTrip].fitness += varFIT;
//	}
//	else
//	{
//		seg[idVeh].Trip[idTrip].feasible = 1;
//		seg[idVeh].Trip[idTrip].fitness = seg[idVeh].Trip[idTrip].cost;
//	}
//	nextTrip = idTrip + 1;
//	if (nextTrip < seg[idVeh].numTrips)
//	{
//		if (seg[idVeh].Trip[nextTrip].Type == 1)
//		{
//			if (seg[idVeh].Trip[nextTrip].assSP == assSP)
//			{
//				//Update 17/11/2013: there is a case where pickup trip after the move has the leaveSP = eTW + unload same as before the move, but now not infeasible any more
//				if (seg[idVeh].Trip[nextTrip].vioTWSP > eps && seg[idVeh].Trip[idTrip].vioTWSP == 0) //before vio, after the move not vio anymore:
//				{
//					seg[idVeh].Trip[nextTrip].leaveSP = seg[idVeh].Trip[idTrip].leaveSP + problem->nodeSP[assSP].load;
//					seg[idVeh].Trip[nextTrip].vioTWSP = seg[idVeh].Trip[idTrip].vioTWSP;
//					UpdateVehicle(idVeh, nextTrip, assSP, seg[idVeh].Trip[nextTrip].leaveSP, varvioCAP, update_idTrip);
//					return;
//				}
//				else
//				{
//					seg[idVeh].Trip[nextTrip].vioTWSP = seg[idVeh].Trip[idTrip].vioTWSP;
//					if (seg[idVeh].Trip[nextTrip].vioCAP > 0 || seg[idVeh].Trip[nextTrip].vioTWC > eps || seg[idVeh].Trip[nextTrip].vioTWSP > eps)
//					{
//						seg[idVeh].Trip[nextTrip].feasible = 0;
//						seg[idVeh].Trip[nextTrip].fitness += (VTWSP * varvioTWSP);
//					}
//					else
//					{
//						seg[idVeh].Trip[nextTrip].feasible = 1;
//						seg[idVeh].Trip[nextTrip].fitness = seg[idVeh].Trip[nextTrip].cost;
//					}
//					varFIT +=  (VTWSP * varvioTWSP);
//					varvioTWSP *= 2;
//				}
//			}
//		}
//	}
//
//	varC1 = varcost + varcostpreT;
//	varFIT += varcostpreT;
//	seg[idVeh].cost += varC1; seg[idVeh].fitness += varFIT; seg[idVeh].vioTWC += varvioTWC;seg[idVeh].vioTWSP += varvioTWSP; seg[idVeh].vioCAP += varvioCAP;
//	cost += varC1; fitness += varFIT;vioTWC += varvioTWC; vioTWSP += varvioTWSP; vioCAP += varvioCAP;
//	return;
//
//UpdateC:
//	seg[idVeh].Trip[idTrip].leaveSP = cStartS;
//	varFIT = varcost + VTWCUS * varvioTWC + VTWSP * varvioTWSP + VCAP * varvioCAP;
//	seg[idVeh].Trip[idTrip].cost += varcost;
//	if (seg[idVeh].Trip[idTrip].vioCAP > 0 || seg[idVeh].Trip[idTrip].vioTWC > eps || seg[idVeh].Trip[idTrip].vioTWSP > eps)
//	{
//		seg[idVeh].Trip[idTrip].feasible = 0;
//		seg[idVeh].Trip[idTrip].fitness += varFIT;
//	}
//	else
//	{
//		seg[idVeh].Trip[idTrip].feasible = 1;
//		seg[idVeh].Trip[idTrip].fitness = seg[idVeh].Trip[idTrip].cost;
//	}
//	nextTrip = idTrip + 1;
//	if (nextTrip == seg[idVeh].numTrips)
//	{
//		double varC1 = varcost + varcostpreT;
//		varFIT += varcostpreT;
//		seg[idVeh].cost += varC1; seg[idVeh].fitness += varFIT; seg[idVeh].vioTWC += varvioTWC;seg[idVeh].vioTWSP += varvioTWSP; seg[idVeh].vioCAP += varvioCAP;
//		cost += varC1; fitness += varFIT;vioTWC += varvioTWC; vioTWSP += varvioTWSP; vioCAP += varvioCAP;
//	}
//	else if (nextTrip <= update_idTrip)
//	{
//		if (seg[idVeh].Trip[nextTrip].Type == 1) //nextTrip is delivery trip
//		{
//			int assSP1 = seg[idVeh].Trip[nextTrip].assSP;
//			if (assSP1 == assSP) //sameSP
//			{
//				seg[idVeh].Trip[nextTrip].vioTWSP = seg[idVeh].Trip[idTrip].vioTWSP;
//				seg[idVeh].Trip[nextTrip].fitness += (VTWSP * varvioTWSP);
//				//Update 16/11/2013
//				if (seg[idVeh].Trip[nextTrip].vioTWSP > eps)
//					seg[idVeh].Trip[nextTrip].leaveSP = problem->leaveSP[assSP][1]; //load only at eTW2
//				else
//					seg[idVeh].Trip[nextTrip].leaveSP = seg[idVeh].Trip[idTrip].leaveSP + problem->nodeSP[assSP].load;
//				UpdateVehicle(idVeh, nextTrip, assSP1, seg[idVeh].Trip[nextTrip].leaveSP, varvioCAP, update_idTrip);
//			}
//			else //nextTrip is delivery trip, dif sp:
//			{
//				double varvioTWSP1;
//				cArrTime = seg[idVeh].Trip[idTrip].leaveSP + problem->c[assSP][assSP1];
//				if (PDSINRANGE(cArrTime, problem->nodeSP[assSP1].sTW2, problem->nodeSP[assSP1].eTW2))
//				{
//					varvioTWSP1 = -seg[idVeh].Trip[nextTrip].vioTWSP;
//					if (seg[idVeh].Trip[idTrip].waitingS1 != NO_WS)
//					{
//						seg[idVeh].Trip[idTrip].waitingS1 = NO_WS;
//						double varcost1 = (problem->c[assSP][assSP1] - problem->disCWSSP[assSP][assSP1]);
//						seg[idVeh].Trip[idTrip].connectCost = problem->c[assSP][assSP1];
//						seg[idVeh].Trip[idTrip].cost += varcost1;
//						seg[idVeh].Trip[idTrip].fitness += varcost1;
//					}
//					seg[idVeh].Trip[nextTrip].vioTWSP = 0;
//					cStartS = cArrTime + problem->nodeSP[assSP1].load;
//				}
//				else
//				{
//					double temp = cArrTime - problem->nodeSP[assSP1].eTW2;
//					if (temp > eps)
//					{
//						varvioTWSP1 = (temp - seg[idVeh].Trip[nextTrip].vioTWSP);
//						if (seg[idVeh].Trip[nextTrip].vioTWSP > eps)
//						{
//							seg[idVeh].Trip[nextTrip].vioTWSP = temp;	
//							if (seg[idVeh].Trip[nextTrip].vioCAP > 0 || seg[idVeh].Trip[nextTrip].vioTWC > eps || seg[idVeh].Trip[nextTrip].vioTWSP > eps)
//							{
//								seg[idVeh].Trip[nextTrip].feasible = 0;
//								seg[idVeh].Trip[nextTrip].fitness += (VTWSP * varvioTWSP1);
//							}
//							else
//							{
//								seg[idVeh].Trip[nextTrip].feasible = 1;
//								seg[idVeh].Trip[nextTrip].fitness = seg[idVeh].Trip[nextTrip].cost;
//							}
//							varFIT += (VTWSP * varvioTWSP1);
//							double varC1 = varcost + varcostpreT;
//							varFIT += varcostpreT;
//							varvioTWSP += varvioTWSP1;
//							seg[idVeh].cost += varC1; seg[idVeh].fitness += varFIT; seg[idVeh].vioTWC += varvioTWC;
//							seg[idVeh].vioTWSP += varvioTWSP; seg[idVeh].vioCAP += varvioCAP;
//							cost += varC1; fitness += varFIT;vioTWC += varvioTWC; vioTWSP += varvioTWSP; vioCAP += varvioCAP;
//							return;
//						}
//						if (seg[idVeh].Trip[idTrip].waitingS1 != NO_WS)
//						{
//							double varcost1 = (problem->c[assSP][assSP1] - problem->disCWSSP[assSP][assSP1]);
//							seg[idVeh].Trip[idTrip].waitingS1 = NO_WS;
//							seg[idVeh].Trip[idTrip].connectCost = problem->c[assSP][assSP1];
//							seg[idVeh].Trip[idTrip].cost += varcost1;
//							seg[idVeh].Trip[idTrip].fitness += varcost1;
//						}
//						seg[idVeh].Trip[nextTrip].vioTWSP = temp;	
//						cStartS = problem->leaveSP[assSP1][1]; //load at eTW2
//					}
//					else
//					{
//						double cArrTimeI = seg[idVeh].Trip[idTrip].leaveSP + problem->disCWSSP[assSP][assSP1];
//						temp = cArrTimeI - problem->nodeSP[assSP1].eTW2;
//						if (temp > eps) //too soon to go sp directly, too late to go through WS:
//						{
//							temp = problem->nodeSP[assSP1].sTW2 - cArrTime;
//							varvioTWSP1 = temp - seg[idVeh].Trip[nextTrip].vioTWSP;
//							if (seg[idVeh].Trip[nextTrip].vioTWSP > eps)
//							{
//								seg[idVeh].Trip[nextTrip].vioTWSP = temp;	
//								if (seg[idVeh].Trip[nextTrip].vioCAP > 0 || seg[idVeh].Trip[nextTrip].vioTWC > eps || seg[idVeh].Trip[nextTrip].vioTWSP > eps)
//								{
//									seg[idVeh].Trip[nextTrip].feasible = 0;
//									seg[idVeh].Trip[nextTrip].fitness += (VTWSP * varvioTWSP1);
//								}
//								else
//								{
//									seg[idVeh].Trip[nextTrip].feasible = 1;
//									seg[idVeh].Trip[nextTrip].fitness = seg[idVeh].Trip[nextTrip].cost;
//								}
//								varFIT += (VTWSP * varvioTWSP1);
//								double varC1 = varcost + varcostpreT;
//								varFIT += varcostpreT;
//								varvioTWSP += varvioTWSP1;
//								seg[idVeh].cost += varC1; seg[idVeh].fitness += varFIT; seg[idVeh].vioTWC += varvioTWC;
//								seg[idVeh].vioTWSP += varvioTWSP; seg[idVeh].vioCAP += varvioCAP;
//								cost += varC1; fitness += varFIT;vioTWC += varvioTWC; vioTWSP += varvioTWSP; vioCAP += varvioCAP;
//								return;
//							}
//							if (seg[idVeh].Trip[idTrip].waitingS1 != NO_WS)
//							{
//								double varcost1 = (problem->c[assSP][assSP1] - problem->disCWSSP[assSP][assSP1]);
//								seg[idVeh].Trip[idTrip].waitingS1 = NO_WS;
//								seg[idVeh].Trip[idTrip].connectCost = problem->c[assSP][assSP1];
//								seg[idVeh].Trip[idTrip].cost += varcost1;
//								seg[idVeh].Trip[idTrip].fitness += varcost1;
//							}
//							seg[idVeh].Trip[nextTrip].vioTWSP = temp;
//							cStartS = problem->leaveSP[assSP1][1]; //load at eTW2
//						}
//						else //go through WS:
//						{
//							varvioTWSP1 = -seg[idVeh].Trip[nextTrip].vioTWSP;
//							if (seg[idVeh].Trip[idTrip].waitingS1 == NO_WS)
//							{
//								double varcost1 = (problem->disCWSSP[assSP][assSP1] - problem->c[assSP][assSP1]);
//								seg[idVeh].Trip[idTrip].waitingS1 = problem->CWSSP[assSP][assSP1];
//								seg[idVeh].Trip[idTrip].connectCost = problem->disCWSSP[assSP][assSP1];
//								seg[idVeh].Trip[idTrip].cost += varcost1;
//								seg[idVeh].Trip[idTrip].fitness += varcost1;
//							}
//							seg[idVeh].Trip[nextTrip].vioTWSP = 0;
//							cStartS = PDS_MAX(cArrTimeI, problem->nodeSP[assSP1].sTW2) + problem->nodeSP[assSP1].load;
//						}//end go through WS
//					}
//				}
//				//Can't happen the case where seg[idVeh].Trip[nextTrip].leaveSP doesn't change; because already checking if seg[idVeh].Trip[idTrip].leaveSP changed or not before coming here
//				seg[idVeh].Trip[nextTrip].leaveSP = cStartS;
//				seg[idVeh].Trip[nextTrip].fitness += (VTWSP * varvioTWSP1);
//				UpdateVehicle(idVeh, nextTrip, assSP1, seg[idVeh].Trip[nextTrip].leaveSP, varvioCAP, update_idTrip);
//			}//end nextTrip is delivery trip, dif sp
//		}
//		else //nextTrip is pickup trip OR C2C
//		{
//			//cout<<"CALL UpdateVehicle: start @trip = "<<nextTrip<<" till the trip "<<update_idTrip<<endl;
//			UpdateVehicle(idVeh, nextTrip, assSP, seg[idVeh].Trip[idTrip].leaveSP, varvioCAP, update_idTrip);
//		}//end nextTrip is pickup trip OR C2C
//	}//else if (nextTrip <= update_idTrip)
//}
//
//
//void Solution::UpdateChangeCONNECTAtSP_C2CTrip(int idVeh, int idTrip, int nextT, int nextSP, double varcost, double varcostpreT, double varvioTWC, int varvioCAP, int update_idTrip) //for deleteCusC2C
//{
//	//15/12/2013
//	//Update all change for c2c trip (idVeh, idTrip) and then all remainning trips till update_idTrip trip in idVeh vehicle if neccessary
//	//Dif from UpdateChangeCONNECTAtSP_PickTrip: just update remaining trips till update_idTrip rather than all remainning trips of idVeh
//	
//	//calculate variation of varcost, varvioTWSP, cStartS when connecting lastC of pickup trip (idVeh, idTrip) with its assSP
//
//	int lastC = seg[idVeh].Trip[idTrip].lastCus;
//	double varvioTWSP;
//	double cStartS, temp, varFIT, varC1;
//
//	double	cArrTime = seg[idVeh].Trip[idTrip].endS + problem->c[lastC][nextSP];
//
//	if (PDSINRANGE(cArrTime, problem->nodeSP[nextSP].sTW2, problem->nodeSP[nextSP].eTW2))
//	{
//		varvioTWSP = -seg[idVeh].Trip[nextT].vioTWSP;
//		seg[idVeh].Trip[nextT].vioTWSP = 0;
//		varcost += problem->c[lastC][nextSP];
//		seg[idVeh].Trip[idTrip].connectCost = problem->c[lastC][nextSP];
//		seg[idVeh].Trip[idTrip].waitingS = NO_WS;
//		if (PDSDIF(cArrTime, seg[idVeh].Trip[idTrip].arriveSP))
//		{
//			seg[idVeh].Trip[idTrip].arriveSP = cArrTime;
//		    cStartS = cArrTime + problem->nodeSP[nextSP].load; 
//			seg[idVeh].Trip[nextT].leaveSP = cStartS;
//			goto UpdateC;
//		}
//		else goto UpdateNC;
//	}
//	else
//	{
//		temp = cArrTime - problem->nodeSP[nextSP].eTW2;
//		if (temp > eps)
//		{
//			varvioTWSP = (temp - seg[idVeh].Trip[nextT].vioTWSP);
//			varcost += problem->c[lastC][nextSP];
//			seg[idVeh].Trip[idTrip].connectCost = problem->c[lastC][nextSP];
//			if (seg[idVeh].Trip[nextT].vioTWSP > eps)
//			{
//				seg[idVeh].Trip[nextT].vioTWSP = temp;
//				goto UpdateNC;
//			}
//			seg[idVeh].Trip[nextT].vioTWSP = temp;
//			seg[idVeh].Trip[idTrip].waitingS = NO_WS;
//			seg[idVeh].Trip[idTrip].arriveSP = problem->nodeSP[nextSP].eTW2;
//			cStartS = problem->leaveSP[nextSP][1]; //load at eTW2
//			seg[idVeh].Trip[idTrip].leaveSP = cStartS;
//			goto UpdateC;
//		}
//		else
//		{
//			double cArrTimeI = seg[idVeh].Trip[idTrip].endS + problem->disCWSSP[lastC][nextSP];
//			temp = cArrTimeI - problem->nodeSP[nextSP].eTW2;
//			if (temp > eps) //too soon to go sp directly, too late through WS
//			{
//				temp = problem->nodeSP[nextSP].sTW2 - cArrTime;
//				varvioTWSP = (temp - seg[idVeh].Trip[nextT].vioTWSP);
//				varcost += problem->c[lastC][nextSP];
//				seg[idVeh].Trip[idTrip].connectCost = problem->c[lastC][nextSP];
//				if (seg[idVeh].Trip[nextT].vioTWSP > eps) 
//				{
//					seg[idVeh].Trip[nextT].vioTWSP = temp;
//					goto UpdateNC;
//				}
//				seg[idVeh].Trip[nextT].vioTWSP = temp;
//				seg[idVeh].Trip[idTrip].waitingS = NO_WS;
//				seg[idVeh].Trip[idTrip].arriveSP = problem->nodeSP[nextSP].eTW2;
//				cStartS = problem->leaveSP[nextSP][1]; //load only at eTW2
//				seg[idVeh].Trip[idTrip].leaveSP = cStartS;
//				goto UpdateC;
//			}
//			else //go through WS:
//			{
//				varvioTWSP = -seg[idVeh].Trip[nextT].vioTWSP;
//				varcost += problem->disCWSSP[lastC][nextSP];
//				seg[idVeh].Trip[idTrip].connectCost = problem->disCWSSP[lastC][nextSP];
//				seg[idVeh].Trip[nextT].vioTWSP = 0;
//				seg[idVeh].Trip[idTrip].waitingS = problem->CWSSP[lastC][nextSP];
//				cStartS = PDS_MAX(cArrTimeI, problem->nodeSP[nextSP].sTW2);
//				if (PDSDIF(cStartS, seg[idVeh].Trip[idTrip].arriveSP))
//				{
//					seg[idVeh].Trip[idTrip].arriveSP = cStartS;
//					cStartS += problem->nodeSP[nextSP].load;
//					seg[idVeh].Trip[nextT].leaveSP = cStartS;
//					goto UpdateC;
//				}
//				else goto UpdateNC;
//			}
//		}
//	}
//
//UpdateNC: //not changed: leaveSP, ...
//	varFIT = varcost + VTWCUS * varvioTWC + VCAP * varvioCAP;
//	seg[idVeh].Trip[idTrip].cost += varcost;
//	if (seg[idVeh].Trip[idTrip].vioCAP > 0 || seg[idVeh].Trip[idTrip].vioTWC > eps)
//	{
//		seg[idVeh].Trip[idTrip].feasible = 0;
//		seg[idVeh].Trip[idTrip].fitness += varFIT;
//	}
//	else
//	{
//		seg[idVeh].Trip[idTrip].feasible = 1;
//		seg[idVeh].Trip[idTrip].fitness = seg[idVeh].Trip[idTrip].cost;
//	}
//	if (varvioTWSP > 0) //case: before vioTWSP; now still vioTWSP but amount of violation is different
//	{
//		UpdateVehicle(idVeh, nextT, nextSP, seg[idVeh].Trip[nextT].leaveSP, varvioCAP, update_idTrip);
//		return;
//	}
//
//	varC1 = varcost + varcostpreT;
//	varFIT += varcostpreT;
//	seg[idVeh].cost += varC1; seg[idVeh].fitness += varFIT; seg[idVeh].vioTWC += varvioTWC;seg[idVeh].vioTWSP += varvioTWSP; seg[idVeh].vioCAP += varvioCAP;
//	cost += varC1; fitness += varFIT;vioTWC += varvioTWC; vioTWSP += varvioTWSP; vioCAP += varvioCAP;
//	return;
//
//UpdateC:
//	varFIT = varcost + VTWCUS * varvioTWC + VCAP * varvioCAP;
//	seg[idVeh].Trip[idTrip].cost += varcost;
//	if (seg[idVeh].Trip[idTrip].vioCAP > 0 || seg[idVeh].Trip[idTrip].vioTWC > eps)
//	{
//		seg[idVeh].Trip[idTrip].feasible = 0;
//		seg[idVeh].Trip[idTrip].fitness += varFIT;
//	}
//	else
//	{
//		seg[idVeh].Trip[idTrip].feasible = 1;
//		seg[idVeh].Trip[idTrip].fitness = seg[idVeh].Trip[idTrip].cost;
//	}
//	seg[idVeh].Trip[nextT].fitness += (VTWSP * varvioTWSP);
//	UpdateVehicle(idVeh, nextT, nextSP, seg[idVeh].Trip[nextT].leaveSP, varvioCAP, update_idTrip);
//}
//
//
//void Solution::moveCusPTrip_OneVeh(int j, int idTripj, int i, int idTripi, int idVeh)//move cus i on (idVeh, fromTrip) after cus j on (idVeh, toTrip) where i and j are on the same vehicle idVeh
//{
//	//see on 2/12/2013
//   if (idTripj < idTripi) // j before i
//   {
//	   //cout<<"j before i"<<endl;
//	   int preTi = idTripi - 1; double cStartSOLD;
//	   cStartSOLD = depart[seg[idVeh].Trip[preTi].lastCus];
//	   int prei = predArr[i]; int nexti = nextArr[i];
//
//	   //1. Insert i after j on Trip(idVeh, toTrip) and recalculate all information if neccessary:
//	   insertCusPTrip(j,i,idVeh,idTripj, preTi); //insert i after j on (idVeh, idTripj) and update remaining trips till trip (idtripi-1)
//       if (seg[idVeh].Trip[idTripi].numCus == 1)
//	   {
//		   Update_EmptyTripP(idVeh, idTripi);
//	   }
//	   else
//	   {
//		   if (PDSDIF(cStartSOLD, depart[seg[idVeh].Trip[preTi].lastCus]))
//		   {
//				//cout<<"CALL deleteCusPTrip_FromBeginning"<<endl;
//				deleteCusPTrip_FromBeginning(idVeh, idTripi, prei, i, nexti);
//		   }
//		   else
//		   {
//			   //cout<<"CALL deleteCusPTrip"<<endl;
//			   deleteCusPTrip(idVeh, idTripi, prei, i, nexti);
//		   }
//	   }
//   }
//   else //j after i
//   {
//	   //cout<<"j after i "<<endl;
//	   if (seg[idVeh].Trip[idTripi].numCus == 1)
//   		   delete_insertCusPTrip(i,idTripi, j, idTripj, idVeh); //empty idTripi which is before idTripj, (NOT NECCESSARY RIGHT BEFORE), then insert i after j on trip idTripj, then DON TOA and update all remaining trips of idVeh
//	   else
//	   {
//		   int preTj = idTripj - 1; double cStartSOLD;
//		   cStartSOLD = depart[seg[idVeh].Trip[preTj].lastCus];
//		   //cout<<"CALL deleteCusPTrip_TillTrip on trip("<<idVeh<<", "<<idTripi<<"): cut at cus "<<i<<"; preTj= "<<preTj<<endl;
//           deleteCusPTrip_TillTrip(idVeh,idTripi,i,preTj); //delete cus i from (idVeh, idTripi) where idTripi >= 2 customers; and update remaining trips till trip (idTripj - 1)	
//		   if (PDSDIF(cStartSOLD, depart[seg[idVeh].Trip[preTj].lastCus]))
//		   {
//			   //cout<<"CALL insertCusPTrip_FromBeginning on trip ("<<idVeh<<", "<<idTripj<<"):"<<endl;
//			   insertCusPTrip_FromBeginning(j, i, idVeh, idTripj);
//		   }
//		   else
//		   {
//			   //cout<<"CALL insertCusPTrip"<<endl; 
//			   insertCusPTrip(j,i, idVeh,idTripj, seg[idVeh].numTrips - 1);//insert i after j on (idVeh, idTripj) and update remaining trips till lastTrip of veh
//		   }
//	   }
//   }//end j after i
//	bool stop = checkVehicle(idVeh);
//	if (stop)
//	{
//		cout<<"STOP AT moveCusPTrip_OneVeh @IT = "<<IT<<endl;
//		exit(-1);
//	}
//
//}
//
//void Solution::deleteCusPTrip(int idVeh, int idTrip, int pre, int idCus, int next) //for the trip with >=2 customers
//{
//	     //see on 2/12/2013
//	    //trip_num[idCus] = -1;
//		int preID, nextID,id;
//		int assSP = seg[idVeh].Trip[idTrip].assSP;
//		int lastCus = seg[idVeh].Trip[idTrip].lastCus;
//		double cStartS,cArrTime,temp, varFIT, varC1;
//		bool stop;
//
//		int capDEL = problem->node[idCus].capacity;
//		seg[idVeh].Trip[idTrip].capacity -= capDEL;
//		int vioCAPNEW = PDS_MAX(seg[idVeh].Trip[idTrip].capacity - problem->Q,0);
//		int varvioCAP = vioCAPNEW - seg[idVeh].Trip[idTrip].vioCAP;
//		seg[idVeh].Trip[idTrip].vioCAP = vioCAPNEW;
//
//		seg[idVeh].Trip[idTrip].numCus -=1;
//		int lastCOLD = seg[idVeh].Trip[idTrip].lastCus;
//		double varcostpreT = 0, varcost, varvioTWC, FvioTWCUST;
//
//		if (pre < 0)
//		{
//			seg[idVeh].Trip[idTrip].firstCus = next;
//			FvioTWCUST = 0;
//			predArr[next] = -1; nextID = next;
//			if (idTrip == 0) //delete the first cus of first trip
//			{
//				preID = 0;cStartS = 0; 
//				varcost = problem->c[0][next] - (problem->c[0][idCus] + problem->c[idCus][next]);
//			}
//			else //delete the first cus of middle/last trip
//			{
//				int preT = idTrip - 1;
//				if (seg[idVeh].Trip[preT].Type == 0)
//				{
//					preID = seg[idVeh].Trip[preT].assSP;
//					cStartS = seg[idVeh].Trip[preT].leaveSP;
//				}
//				else
//				{
//					preID = seg[idVeh].Trip[preT].lastCus;
//					cStartS = depart[preID];
//				}
//				varcost = -problem->c[idCus][next];
//				varcostpreT = problem->c[preID][next] - problem->c[preID][idCus];
//				seg[idVeh].Trip[preT].connectCost = problem->c[preID][next];
//				seg[idVeh].Trip[preT].cost += varcostpreT;
//				seg[idVeh].Trip[preT].fitness += varcostpreT;
//			}//end delete the first cus of middle/last trip
//
//		}
//		else //delete the middle/last cus
//		{
//			if (next > 0) //delete the middle cus
//			{
//				nextArr[pre] = next; predArr[next] = pre;
//				cStartS = depart[pre]; preID = pre; nextID = next;
//				varcost = problem->c[pre][next] - (problem->c[pre][idCus] + problem->c[idCus][next]);
//			}
//			else //delete the lastcus
//			{
//				seg[idVeh].Trip[idTrip].lastCus = pre;
//				nextArr[pre] = -1; preID = pre; nextID = -1;
//				varcost = -problem->c[pre][idCus];
//				cStartS = depart[pre];
//			}//end delete the lastCus
//			FvioTWCUST = FvioTWCus[preID];
//		}//end delete the middle/last cus
//
//		if (idTrip == 0 && seg[idVeh].Trip[idTrip].numCus == 1)
//		{
//			preID = seg[idVeh].Trip[idTrip].firstCus;
//			startS[preID] = problem->startSOneP[preID][assSP];
//			depart[preID] = startS[preID] + problem->node[preID].duration;
//			vioTWCus[preID] = 0; FvioTWCus[preID] = 0; BvioTWCus[preID] = 0;
//			seg[idVeh].Trip[idTrip].endS = depart[preID];
//			varvioTWC = -seg[idVeh].Trip[idTrip].vioTWC;
//			seg[idVeh].Trip[idTrip].vioTWC = 0;
//
//			cStartS = depart[preID];
//			FCAP[preID] = problem->node[preID].capacity; BCAP[preID] = problem->node[preID].capacity;
//			pos[preID] = 1;
//		}
//		else
//		{
//			while (nextID > 0)
//			{
//				cArrTime = cStartS + problem->c[preID][nextID]; //arrTime at customer nextID
//				cStartS = PDS_MAX(cArrTime, problem->node[nextID].sTW);
//				if (PDSDIF(cStartS, startS[nextID]) == 0) //it means varvioTWCus[nextID] = 0 if (cStartS != node[nextID].eTW)
//				{
//					temp = cStartS - problem->node[nextID].eTW;
//					if (temp > eps) vioTWCus[nextID] = temp;
//					else vioTWCus[nextID] = 0;
//					//Update BvioTWCus from nextID to firstCus
//					//Update BCAP from pre to firstCus (note: pre may < 0)
//					//Update FCAP, FvioTWCus, pos from nextID to lastCus   
//					id = nextArr[nextID];
//					if (id < 0) BvioTWCus[nextID] = vioTWCus[nextID];
//					else BvioTWCus[nextID] = BvioTWCus[id] + vioTWCus[nextID];
//
//					if (nextID != seg[idVeh].Trip[idTrip].firstCus)
//					{
//						id = nextID;
//						while (preID != pre)
//						{
//							BvioTWCus[preID] = BvioTWCus[id] + vioTWCus[preID];
//							id = preID; preID = predArr[id];
//							/*if (preID == 0)
//							{
//								cout<<"id = "<<id<<endl;
//								showTripCost(idVeh,idTrip);
//								exit(-1);
//							}
//							cout<<"preID = "<<preID<<"; pre = "<<pre<<endl;*/
//						}
//						//update BCAP from pre to firstCus
//						while (preID > 0)
//						{
//							BvioTWCus[preID] = BvioTWCus[id] + vioTWCus[preID];
//							BCAP[preID] -= capDEL;
//							id = preID; preID = predArr[id];
//						}
//						//update FCAP, FvioTWCus from nextID to lastCus: 
//						id = nextID; preID = predArr[nextID];
//						do
//						{
//							FvioTWCus[id] = FvioTWCus[preID] + vioTWCus[id];
//							FCAP[id] -= capDEL; 
//							pos[id] --;
//							preID = id; id = nextArr[id];
//						}while (id > 0);
//					}
//					else //nextID is the firstcus:
//					{
//						//update FCAP, FvioTWCus from nextID to lastCus: 
//						FvioTWCus[nextID] = vioTWCus[nextID];
//						FCAP[nextID] -= capDEL; pos[nextID] =1;
//						id = nextArr[nextID]; preID = nextID;
//						while (id > 0)
//						{
//							FvioTWCus[id] = FvioTWCus[preID] + vioTWCus[id];
//							FCAP[id] -= capDEL;
//							pos[id] --;
//							preID = id; id = nextArr[id];
//						}
//					}
//					//preID now points to the last cus
//					varvioTWC = FvioTWCus[preID] - seg[idVeh].Trip[idTrip].vioTWC; 
//					seg[idVeh].Trip[idTrip].vioTWC = FvioTWCus[preID];
//					goto UpdateNC; //not changed: endS, ...
//				}
//				temp = cStartS - problem->node[nextID].eTW;
//				if (temp > eps)
//				{
//					if (vioTWCus[nextID] > eps) 
//					{
//						vioTWCus[nextID] = temp;
//						//Update BvioTWCus from nextID to firstCus
//						//Update BCAP from pre to firstCus //pre may < 0
//						//Update FCAP, FvioTWCus, pos from nextID to lastCus 
//						id = nextArr[nextID];
//						if (id < 0) BvioTWCus[nextID] = vioTWCus[nextID];
//						else BvioTWCus[nextID] = BvioTWCus[id] + vioTWCus[nextID];
//						if (nextID != seg[idVeh].Trip[idTrip].firstCus)
//						{
//							id = nextID;
//							while (preID != pre) //pre may < 0
//							{
//								BvioTWCus[preID] = BvioTWCus[id] + vioTWCus[preID];
//								id = preID; preID = predArr[id];
//								/*if (preID == 0)
//								{
//									cout<<"id = "<<id<<endl;
//									showTripCost(idVeh, idTrip);
//									exit(-1);
//								}
//								cout<<"..preID = "<<preID<<"; pre = "<<pre<<endl;*/
//							}
//							while (preID > 0)
//							{
//								BvioTWCus[preID] = BvioTWCus[id] + vioTWCus[preID];
//								BCAP[preID] -= capDEL;
//								id = preID; preID = predArr[id];
//							}
//							//Update FCAP, FvioTWCus from nextID to lastCus:
//							id = nextID; preID = predArr[nextID];
//							do
//							{
//								FvioTWCus[id] = FvioTWCus[preID] + vioTWCus[id];
//								FCAP[id] -= capDEL;
//								pos[id]--;
//								preID = id; id = nextArr[id];
//							}while (id > 0);
//						}
//						else //nextID is now the firstCus:
//						{
//							//Update FCAP, FvioTWCus from nextID to lastCus:
//							FvioTWCus[nextID] = vioTWCus[nextID];
//							FCAP[nextID] -= capDEL; pos[nextID] = 1;
//							id = nextArr[nextID]; preID = nextID;
//							while (id > 0)
//							{
//								FvioTWCus[id] = FvioTWCus[preID] + vioTWCus[id];
//								FCAP[id] -= capDEL;
//								pos[id]--;
//								preID = id; id = nextArr[id];
//							}
//						}
//
//						//preID now points to the last cus
//						varvioTWC = FvioTWCus[preID] - seg[idVeh].Trip[idTrip].vioTWC;
//						seg[idVeh].Trip[idTrip].vioTWC = FvioTWCus[preID];
//						goto UpdateNC; //not changed: endS, ...
//					}
//					vioTWCus[nextID] = temp;
//					//FvioTWCus[nextID] = FvioTWCus[preID] + temp;
//					cStartS = problem->node[nextID].eTW;
//				}
//				else 
//				{
//					vioTWCus[nextID] = 0;
//					//FvioTWCus[nextID] = FvioTWCus[preID];
//				}
//				FvioTWCUST += vioTWCus[nextID];
//				FvioTWCus[nextID] = FvioTWCUST;
//				startS[nextID] = cStartS;
//				cStartS += problem->node[nextID].duration;
//				depart[nextID] = cStartS;
//				FCAP[nextID] -= capDEL;
//				pos[nextID]--;
//				preID = nextID; nextID = nextArr[nextID];
//			}//end while (nextID > 0)
//			seg[idVeh].Trip[idTrip].endS = cStartS;
//			varvioTWC = FvioTWCus[preID] - seg[idVeh].Trip[idTrip].vioTWC;
//			seg[idVeh].Trip[idTrip].vioTWC = FvioTWCus[preID];
//			//preID now points to the last cus:
//			//Update BCAP from pre to firstCus
//			//Update BvioTWCus from lastCus to firstCus
//			if (preID != pre) //not delete the lastCus
//			{
//				BvioTWCus[preID] = vioTWCus[preID];
//				id = predArr[preID];
//				while (id != pre) //pre may < 0
//				{
//					BvioTWCus[id] = BvioTWCus[preID] + vioTWCus[id];
//					preID = id; id = predArr[id];
//				}
//				while (id > 0)
//				{
//					BvioTWCus[id] = BvioTWCus[preID] + vioTWCus[id];
//					BCAP[id] -= capDEL;
//					preID = id; id = predArr[id];
//				}
//			}
//			else //delete the lastCus
//			{
//				BvioTWCus[pre] = vioTWCus[pre];
//				BCAP[pre] = problem->node[pre].capacity;
//				id = predArr[pre];
//				while (id > 0)
//				{
//					BvioTWCus[id] = BvioTWCus[preID] + vioTWCus[id];
//					BCAP[id] -= capDEL;
//					preID = id; id = predArr[id];
//				}
//			}//end delete the lastCus
//		}
//
//
//		if (seg[idVeh].Trip[idTrip].waitingS == NO_WS)
//			varcost -= problem->c[lastCOLD][assSP];
//		else varcost -= problem->disCWSSP[lastCOLD][assSP];
//
//		UpdateChangeCONNECTAtSP_PickTrip(idVeh, idTrip, varcost, varcostpreT, varvioTWC, varvioCAP,seg[idVeh].numTrips - 1);
//		stop = checkVehicle(idVeh);
//		if (stop)
//		{
//			cout<<"CASE2: STOP AT deleteCusPTrip @IT = "<<IT<<endl;
//			exit(-1);
//		}
//		return;
//
//UpdateNC: //not changed: endS, ...
//		varFIT = varcost + VTWCUS * varvioTWC + VCAP * varvioCAP;
//		seg[idVeh].Trip[idTrip].cost += varcost;
//		if (seg[idVeh].Trip[idTrip].vioCAP > 0 || seg[idVeh].Trip[idTrip].vioTWC > eps || seg[idVeh].Trip[idTrip].vioTWSP > eps)
//		{
//			seg[idVeh].Trip[idTrip].feasible = 0;
//			seg[idVeh].Trip[idTrip].fitness += varFIT;
//		}
//		else
//		{
//			seg[idVeh].Trip[idTrip].feasible = 1;
//			seg[idVeh].Trip[idTrip].fitness = seg[idVeh].Trip[idTrip].cost;
//		}
//		varC1 = varcost + varcostpreT;
//		varFIT += varcostpreT;
//		seg[idVeh].cost += varC1; seg[idVeh].fitness += varFIT; seg[idVeh].vioTWC += varvioTWC; seg[idVeh].vioCAP += varvioCAP;
//		cost += varC1; fitness += varFIT;vioTWC += varvioTWC; vioCAP += varvioCAP;
//		stop = checkVehicle(idVeh);
//		if (stop)
//		{
//			cout<<"CASE1: STOP AT deleteCusPTrip @IT = "<<IT<<endl;
//			exit(-1);
//		}
//}
//
//void Solution::deleteCusPTrip_FromBeginning(int idVeh, int idTrip, int pre, int idCus, int next) //for the trip with >=2 customers
//{
//	    //see on 2/12/2013
//		int preID, nextID,id;
//		int assSP = seg[idVeh].Trip[idTrip].assSP;
//		int lastCus = seg[idVeh].Trip[idTrip].lastCus;
//		double cStartS,cArrTime,temp, varFIT, varC1;
//		bool stop;
//
//		int capDEL = problem->node[idCus].capacity;
//		seg[idVeh].Trip[idTrip].capacity -= capDEL;
//		int vioCAPNEW = PDS_MAX(seg[idVeh].Trip[idTrip].capacity - problem->Q,0);
//		int varvioCAP = vioCAPNEW - seg[idVeh].Trip[idTrip].vioCAP;
//		seg[idVeh].Trip[idTrip].vioCAP = vioCAPNEW;
//
//		seg[idVeh].Trip[idTrip].numCus -=1;
//		int lastCOLD = seg[idVeh].Trip[idTrip].lastCus;
//		double varcostpreT = 0, varcost, varvioTWC;
//
//		if (pre < 0)
//		{
//			seg[idVeh].Trip[idTrip].firstCus = next;
//			predArr[next] = -1; 
//			if (idTrip == 0) //delete the first cus of first trip
//			{
//				preID = 0;cStartS = 0; 
//				varcost = problem->c[0][next] - (problem->c[0][idCus] + problem->c[idCus][next]);
//			}
//			else //delete the first cus of middle/last trip
//			{
//				int preT = idTrip - 1;
//				if (seg[idVeh].Trip[preT].Type == 0)
//				{
//					preID = seg[idVeh].Trip[preT].assSP;
//					cStartS = seg[idVeh].Trip[preT].leaveSP;
//				}
//				else
//				{
//					preID = seg[idVeh].Trip[preT].lastCus;
//					cStartS = depart[preID];
//				}
//				varcost = -problem->c[idCus][next];
//				varcostpreT = problem->c[preID][next] - problem->c[preID][idCus];
//				seg[idVeh].Trip[preT].connectCost = problem->c[preID][next];
//				seg[idVeh].Trip[preT].cost += varcostpreT;
//				seg[idVeh].Trip[preT].fitness += varcostpreT;
//			}//end delete the first cus of middle/last trip
//		}
//		else //delete the middle/last cus
//		{
//			if (next > 0) //delete the middle cus
//			{
//				nextArr[pre] = next; predArr[next] = pre;
//				varcost = problem->c[pre][next] - (problem->c[pre][idCus] + problem->c[idCus][next]);
//			}
//			else //delete the lastcus
//			{
//				seg[idVeh].Trip[idTrip].lastCus = pre;
//				nextArr[pre] = -1; 
//				varcost = -problem->c[pre][idCus];
//				cStartS = depart[pre];
//			}//end delete the lastCus
//			int preT = idTrip - 1;
//			if (seg[idVeh].Trip[preT].Type == 0)
//			{
//				preID = seg[idVeh].Trip[preT].assSP;
//				cStartS = seg[idVeh].Trip[preT].leaveSP;
//			}
//			else
//			{
//				preID = seg[idVeh].Trip[preT].lastCus;
//				cStartS = depart[preID];
//			}
//
//		}//end delete the middle/last cus
//
//		if (idTrip == 0 && seg[idVeh].Trip[idTrip].numCus == 1)
//		{
//			preID = seg[idVeh].Trip[idTrip].firstCus;
//			startS[preID] = problem->startSOneP[preID][assSP];
//			depart[preID] = startS[preID] + problem->node[preID].duration;
//			cStartS = depart[preID];
//			FCAP[preID] = problem->node[preID].capacity; BCAP[preID] = FCAP[preID];
//			vioTWCus[preID] = 0; FvioTWCus[preID] = 0; BvioTWCus[preID] = 0;
//			pos[preID] = 1;
//			seg[idVeh].Trip[idTrip].endS = cStartS;
//			varvioTWC = -seg[idVeh].Trip[idTrip].vioTWC;
//			seg[idVeh].Trip[idTrip].vioTWC = 0;
//		}
//		else
//		{
//			nextID = seg[idVeh].Trip[idTrip].firstCus;
//			double FVIOTWCUST;
//			if (pre > 0) //not delete the first cus
//			{
//				cArrTime = cStartS + problem->c[preID][nextID]; //arrTime at customer nextID
//				temp = cArrTime - problem->node[nextID].eTW;
//				if (temp > eps)
//				{
//					vioTWCus[nextID] = temp;
//					FvioTWCus[nextID] = temp;
//					startS[nextID] = problem->node[nextID].eTW;
//					depart[nextID] = problem->node[nextID].depart;
//				}
//				else
//				{
//					vioTWCus[nextID] = 0;
//					FvioTWCus[nextID] = 0;
//					startS[nextID] = PDS_MAX(cArrTime, problem->node[nextID].sTW);
//					depart[nextID] = startS[nextID] + problem->node[nextID].duration;
//				}
//				cStartS = depart[nextID];
//				//FCAP[nextID] = problem->node[nextID].capacity;
//				preID = nextID; nextID = nextArr[nextID];
//				while (nextID != next)
//				{
//					cArrTime = cStartS + problem->c[preID][nextID]; //arrTime at customer nextID
//					temp = cArrTime - problem->node[nextID].eTW;
//					if (temp > eps)
//					{
//						vioTWCus[nextID] = temp;
//						FvioTWCus[nextID] = FvioTWCus[preID] + temp;
//						startS[nextID] = problem->node[nextID].eTW;
//						depart[nextID] = problem->node[nextID].depart;
//					}
//					else
//					{
//						vioTWCus[nextID] = 0;
//						FvioTWCus[nextID] = FvioTWCus[preID];
//						startS[nextID] = PDS_MAX(cArrTime, problem->node[nextID].sTW);
//						depart[nextID] = startS[nextID] + problem->node[nextID].duration;
//					}
//					cStartS = depart[nextID];
//					//FCAP[nextID] = FCAP[preID] + problem->node[nextID].capacity;
//					preID = nextID; nextID = nextArr[nextID];
//				}
//				FVIOTWCUST = FvioTWCus[preID];
//			}
//			else FVIOTWCUST = 0;
//			
//			//nextID now points to suc: nextID maybe now the first cus--> should be careful with FCAP and FvioTWCus
//			while (nextID > 0)
//			{
//				cArrTime = cStartS + problem->c[preID][nextID]; //arrTime at customer nextID
//				cStartS = PDS_MAX(cArrTime, problem->node[nextID].sTW);
//				if (PDSDIF(cStartS, startS[nextID]) == 0) //it means varvioTWCus[nextID] = 0 if (cStartS != node[nextID].eTW)
//				{
//					temp = cStartS - problem->node[nextID].eTW;
//					if (temp > eps) vioTWCus[nextID] = temp;
//					else vioTWCus[nextID] = 0;
//					//Update BvioTWCus from nextID to firstCus
//					//Update BCAP from pre to firstCus (note: pre may < 0)
//					//Update FCAP, FvioTWCus, pos from nextID to lastCus   
//					id = nextArr[nextID];
//					if (id < 0) BvioTWCus[nextID] = vioTWCus[nextID];
//					else BvioTWCus[nextID] = BvioTWCus[id] + vioTWCus[nextID];
//
//					if (nextID != seg[idVeh].Trip[idTrip].firstCus)
//					{
//						id = nextID;
//						while (preID != pre)
//						{
//							BvioTWCus[preID] = BvioTWCus[id] + vioTWCus[preID];
//							id = preID; preID = predArr[id];
//							/*if (preID == 0)
//							{
//								cout<<"id = "<<id<<endl;
//								showTripCost(idVeh,idTrip);
//								exit(-1);
//							}
//							cout<<"preID = "<<preID<<"; pre = "<<pre<<endl;*/
//						}
//						//update BCAP from pre to firstCus
//						while (preID > 0)
//						{
//							BvioTWCus[preID] = BvioTWCus[id] + vioTWCus[preID];
//							BCAP[preID] -= capDEL;
//							id = preID; preID = predArr[id];
//						}
//						//update FCAP, FvioTWCus from nextID to lastCus: 
//						id = nextID; preID = predArr[nextID];
//						do
//						{
//							FvioTWCus[id] = FvioTWCus[preID] + vioTWCus[id];
//							FCAP[id] -= capDEL; 
//							pos[id] --;
//							preID = id; id = nextArr[id];
//						}while (id > 0);
//					}
//					else //nextID is the firstcus:
//					{
//						//update FCAP, FvioTWCus from nextID to lastCus: 
//						FvioTWCus[nextID] = vioTWCus[nextID];
//						FCAP[nextID] -= capDEL; pos[nextID] =1;
//						id = nextArr[nextID]; preID = nextID;
//						while (id > 0)
//						{
//							FvioTWCus[id] = FvioTWCus[preID] + vioTWCus[id];
//							FCAP[id] -= capDEL;
//							pos[id] --;
//							preID = id; id = nextArr[id];
//						}
//					}
//					//preID now points to the last cus
//					varvioTWC = FvioTWCus[preID] - seg[idVeh].Trip[idTrip].vioTWC; 
//					seg[idVeh].Trip[idTrip].vioTWC = FvioTWCus[preID];
//					goto UpdateNC; //not changed: endS, ...
//				}
//				temp = cStartS - problem->node[nextID].eTW;
//				if (temp > eps)
//				{
//					if (vioTWCus[nextID] > eps) 
//					{
//						vioTWCus[nextID] = temp;
//						//Update BvioTWCus from nextID to firstCus
//						//Update BCAP from pre to firstCus //pre may < 0
//						//Update FCAP, FvioTWCus, pos from nextID to lastCus 
//						id = nextArr[nextID];
//						if (id < 0) BvioTWCus[nextID] = vioTWCus[nextID];
//						else BvioTWCus[nextID] = BvioTWCus[id] + vioTWCus[nextID];
//						if (nextID != seg[idVeh].Trip[idTrip].firstCus)
//						{
//							id = nextID;
//							while (preID != pre) //pre may < 0
//							{
//								BvioTWCus[preID] = BvioTWCus[id] + vioTWCus[preID];
//								id = preID; preID = predArr[id];
//								/*if (preID == 0)
//								{
//									cout<<"id = "<<id<<endl;
//									showTripCost(idVeh, idTrip);
//									exit(-1);
//								}
//								cout<<"..preID = "<<preID<<"; pre = "<<pre<<endl;*/
//							}
//							while (preID > 0)
//							{
//								BvioTWCus[preID] = BvioTWCus[id] + vioTWCus[preID];
//								BCAP[preID] -= capDEL;
//								id = preID; preID = predArr[id];
//							}
//							//Update FCAP, FvioTWCus from nextID to lastCus:
//							id = nextID; preID = predArr[nextID];
//							do
//							{
//								FvioTWCus[id] = FvioTWCus[preID] + vioTWCus[id];
//								FCAP[id] -= capDEL;
//								pos[id]--;
//								preID = id; id = nextArr[id];
//							}while (id > 0);
//						}
//						else //nextID is now the firstCus:
//						{
//							//Update FCAP, FvioTWCus from nextID to lastCus:
//							FvioTWCus[nextID] = vioTWCus[nextID];
//							FCAP[nextID] -= capDEL; pos[nextID] = 1;
//							id = nextArr[nextID]; preID = nextID;
//							while (id > 0)
//							{
//								FvioTWCus[id] = FvioTWCus[preID] + vioTWCus[id];
//								FCAP[id] -= capDEL;
//								pos[id]--;
//								preID = id; id = nextArr[id];
//							}
//						}
//
//						//preID now points to the last cus
//						varvioTWC = FvioTWCus[preID] - seg[idVeh].Trip[idTrip].vioTWC;
//						seg[idVeh].Trip[idTrip].vioTWC = FvioTWCus[preID];
//						goto UpdateNC; //not changed: endS, ...
//					}
//					vioTWCus[nextID] = temp;
//					FVIOTWCUST += temp;
//					FvioTWCus[nextID] = FVIOTWCUST;
//					//FvioTWCus[nextID] = FvioTWCus[preID] + temp;
//					cStartS = problem->node[nextID].eTW;
//				}
//				else 
//				{
//					vioTWCus[nextID] = 0;
//					FvioTWCus[nextID] = FVIOTWCUST;
//				}
//				startS[nextID] = cStartS;
//				cStartS += problem->node[nextID].duration;
//				depart[nextID] = cStartS;
//				FCAP[nextID] -= capDEL;
//				pos[nextID]--;
//				preID = nextID; nextID = nextArr[nextID];
//			}//end while (nextID > 0)
//			seg[idVeh].Trip[idTrip].endS = cStartS;
//			varvioTWC = FvioTWCus[preID] - seg[idVeh].Trip[idTrip].vioTWC;
//			seg[idVeh].Trip[idTrip].vioTWC = FvioTWCus[preID];
//			//preID now points to the last cus:
//			//Update BCAP from pre to firstCus
//			//Update BvioTWCus from lastCus to firstCus
//			if (preID != pre) //not delete the lastCus
//			{
//				BvioTWCus[preID] = vioTWCus[preID];
//				id = predArr[preID];
//				while (id != pre) //pre may < 0
//				{
//					BvioTWCus[id] = BvioTWCus[preID] + vioTWCus[id];
//					preID = id; id = predArr[id];
//				}
//				while (id > 0)
//				{
//					BvioTWCus[id] = BvioTWCus[preID] + vioTWCus[id];
//					BCAP[id] -= capDEL;
//					preID = id; id = predArr[id];
//				}
//			}
//			else //delete the lastCus
//			{
//				BvioTWCus[pre] = vioTWCus[pre];
//				BCAP[pre] = problem->node[pre].capacity;
//				id = predArr[pre];
//				while (id > 0)
//				{
//					BvioTWCus[id] = BvioTWCus[preID] + vioTWCus[id];
//					BCAP[id] -= capDEL;
//					preID = id; id = predArr[id];
//				}
//			}//end delete the lastCus
//		}//end not if (numCus == 1 && idTrip == 0)
//
//		if (seg[idVeh].Trip[idTrip].waitingS == NO_WS)
//			varcost -= problem->c[lastCOLD][assSP];
//		else varcost -= problem->disCWSSP[lastCOLD][assSP];
//
//		UpdateChangeCONNECTAtSP_PickTrip(idVeh, idTrip, varcost, varcostpreT, varvioTWC, varvioCAP,seg[idVeh].numTrips - 1);
//		stop = checkVehicle(idVeh);
//		if (stop)
//		{
//			cout<<"CASE CHANGE: STOP AT deleteCusPTrip_FromBeginning @IT = "<<IT<<endl;
//			exit(-1);
//		}
//		return;
//
//UpdateNC: //not changed: endS, ...
//		varFIT = varcost + VTWCUS * varvioTWC + VCAP * varvioCAP;
//		seg[idVeh].Trip[idTrip].cost += varcost;
//		if (seg[idVeh].Trip[idTrip].vioCAP > 0 || seg[idVeh].Trip[idTrip].vioTWC > eps || seg[idVeh].Trip[idTrip].vioTWSP > eps)
//		{
//			seg[idVeh].Trip[idTrip].feasible = 0;
//			seg[idVeh].Trip[idTrip].fitness += varFIT;
//		}
//		else
//		{
//			seg[idVeh].Trip[idTrip].feasible = 1;
//			seg[idVeh].Trip[idTrip].fitness = seg[idVeh].Trip[idTrip].cost;
//		}
//		varC1 = varcost + varcostpreT;
//		varFIT += varcostpreT;
//		seg[idVeh].cost += varC1; seg[idVeh].fitness += varFIT; seg[idVeh].vioTWC += varvioTWC; seg[idVeh].vioCAP += varvioCAP;
//		cost += varC1; fitness += varFIT;vioTWC += varvioTWC; vioCAP += varvioCAP;
//		stop = checkVehicle(idVeh);
//		if (stop)
//		{
//			cout<<"CASE Not change: STOP AT deleteCusPTrip_FromBeginning @IT = "<<IT<<endl;
//			exit(-1);
//		}
//}
//
//
//
//
//void Solution::deleteCusPTrip_TillTrip(int idVeh, int idTrip, int idCus, int update_idTrip) //for the trip with >=2 customers
//{
//	     //see on 2/12/2013
//		//delete cus idCus from (idVeh, idTrip) where idTrip >= 2 customers; and update remaining trips till trip update_idTrip	
//        //dif from deletecusPTrip: just update remaining trips till update_idTrip rather than all remaining trips
//	    //trip_num[idCus] = -1;
//		int pre = predArr[idCus]; int next = nextArr[idCus];
//		int preID, nextID,id;
//		int assSP = seg[idVeh].Trip[idTrip].assSP;
//		int lastCus = seg[idVeh].Trip[idTrip].lastCus;
//		double cStartS,cArrTime,temp, varFIT, varC1;
//
//		int capDEL = problem->node[idCus].capacity;
//		seg[idVeh].Trip[idTrip].capacity -= capDEL;
//		int vioCAPNEW = PDS_MAX(seg[idVeh].Trip[idTrip].capacity - problem->Q,0);
//		int varvioCAP = vioCAPNEW - seg[idVeh].Trip[idTrip].vioCAP;
//		seg[idVeh].Trip[idTrip].vioCAP = vioCAPNEW;
//
//		seg[idVeh].Trip[idTrip].numCus -=1;
//		int lastCOLD = seg[idVeh].Trip[idTrip].lastCus;
//		double varcostpreT = 0, varcost, varvioTWC, FvioTWCUST;
//
//		if (pre < 0)
//		{
//			seg[idVeh].Trip[idTrip].firstCus = next;
//			FvioTWCUST = 0;
//			predArr[next] = -1; nextID = next;
//			if (idTrip == 0) //delete the first cus of first trip
//			{
//				preID = 0;cStartS = 0; 
//				varcost = problem->c[0][next] - (problem->c[0][idCus] + problem->c[idCus][next]);
//			}
//			else //delete the first cus of middle/last trip
//			{
//				int preT = idTrip - 1;
//				if (seg[idVeh].Trip[preT].Type == 0)
//				{
//					preID = seg[idVeh].Trip[preT].assSP;
//					cStartS = seg[idVeh].Trip[preT].leaveSP;
//				}
//				else
//				{
//					preID = seg[idVeh].Trip[preT].lastCus;
//					cStartS = depart[preID];
//				}
//				varcost = -problem->c[idCus][next];
//				varcostpreT = problem->c[preID][next] - problem->c[preID][idCus];
//				seg[idVeh].Trip[preT].connectCost = problem->c[preID][next];
//				seg[idVeh].Trip[preT].cost += varcostpreT;
//				seg[idVeh].Trip[preT].fitness += varcostpreT;
//			}//end delete the first cus of middle/last trip
//		}
//		else //delete the middle/last cus
//		{
//			if (next > 0) //delete the middle cus
//			{
//				nextArr[pre] = next; predArr[next] = pre;
//				cStartS = depart[pre]; preID = pre; nextID = next;
//				varcost = problem->c[pre][next] - (problem->c[pre][idCus] + problem->c[idCus][next]);
//			}
//			else //delete the lastcus
//			{
//				seg[idVeh].Trip[idTrip].lastCus = pre;
//				nextArr[pre] = -1; preID = pre; nextID = -1;
//				varcost = -problem->c[pre][idCus];
//				cStartS = depart[pre];
//			}//end delete the lastCus
//			FvioTWCUST = FvioTWCus[preID];
//		}//end delete the middle/last cus
//
//
//		if (idTrip == 0 && seg[idVeh].Trip[idTrip].numCus == 1)
//		{
//			preID = seg[idVeh].Trip[idTrip].firstCus;
//			startS[preID] = problem->startSOneP[preID][assSP];
//			depart[preID] = startS[preID] + problem->node[preID].duration;
//			cStartS = depart[preID];
//			FCAP[preID] = problem->node[preID].capacity; BCAP[preID] = FCAP[preID];
//			vioTWCus[preID] = 0; FvioTWCus[preID] = 0; BvioTWCus[preID] = 0;
//			pos[preID] = 1;
//			seg[idVeh].Trip[idTrip].endS = cStartS;
//			varvioTWC =  -seg[idVeh].Trip[idTrip].vioTWC;
//			seg[idVeh].Trip[idTrip].vioTWC = 0;
//		}
//		else
//		{
//			while (nextID > 0)
//			{
//				cArrTime = cStartS + problem->c[preID][nextID]; //arrTime at customer nextID
//				cStartS = PDS_MAX(cArrTime, problem->node[nextID].sTW);
//				if (PDSDIF(cStartS, startS[nextID]) == 0) //it means varvioTWCus[nextID] = 0 if (cStartS != node[nextID].eTW)
//				{
//					temp = cStartS - problem->node[nextID].eTW;
//					if (temp > eps) vioTWCus[nextID] = temp;
//					else vioTWCus[nextID] = 0;
//					//Update BvioTWCus from nextID to firstCus
//					//Update BCAP from pre to firstCus (note: pre may < 0)
//					//Update FCAP, FvioTWCus, pos from nextID to lastCus   
//					id = nextArr[nextID];
//					if (id < 0) BvioTWCus[nextID] = vioTWCus[nextID];
//					else BvioTWCus[nextID] = BvioTWCus[id] + vioTWCus[nextID];
//
//					if (nextID != seg[idVeh].Trip[idTrip].firstCus)
//					{
//						id = nextID;
//						while (preID != pre)
//						{
//							BvioTWCus[preID] = BvioTWCus[id] + vioTWCus[preID];
//							id = preID; preID = predArr[id];
//							/*if (preID == 0)
//							{
//								cout<<"id = "<<id<<endl;
//								showTripCost(idVeh,idTrip);
//								exit(-1);
//							}
//							cout<<"preID = "<<preID<<"; pre = "<<pre<<endl;*/
//						}
//						//update BCAP from pre to firstCus
//						while (preID > 0)
//						{
//							BvioTWCus[preID] = BvioTWCus[id] + vioTWCus[preID];
//							BCAP[preID] -= capDEL;
//							id = preID; preID = predArr[id];
//						}
//						//update FCAP, FvioTWCus from nextID to lastCus: 
//						id = nextID; preID = predArr[nextID];
//						do
//						{
//							FvioTWCus[id] = FvioTWCus[preID] + vioTWCus[id];
//							FCAP[id] -= capDEL; 
//							pos[id] --;
//							preID = id; id = nextArr[id];
//						}while (id > 0);
//					}
//					else //nextID is the firstcus:
//					{
//						//update FCAP, FvioTWCus from nextID to lastCus: 
//						FvioTWCus[nextID] = vioTWCus[nextID];
//						FCAP[nextID] -= capDEL; pos[nextID] =1;
//						id = nextArr[nextID]; preID = nextID;
//						while (id > 0)
//						{
//							FvioTWCus[id] = FvioTWCus[preID] + vioTWCus[id];
//							FCAP[id] -= capDEL;
//							pos[id] --;
//							preID = id; id = nextArr[id];
//						}
//					}
//					//preID now points to the last cus
//					varvioTWC = FvioTWCus[preID] - seg[idVeh].Trip[idTrip].vioTWC; 
//					seg[idVeh].Trip[idTrip].vioTWC = FvioTWCus[preID];
//					goto UpdateNC; //not changed: endS, ...
//				}
//				temp = cStartS - problem->node[nextID].eTW;
//				if (temp > eps)
//				{
//					if (vioTWCus[nextID] > eps) 
//					{
//						vioTWCus[nextID] = temp;
//						//Update BvioTWCus from nextID to firstCus
//						//Update BCAP from pre to firstCus //pre may < 0
//						//Update FCAP, FvioTWCus, pos from nextID to lastCus 
//						id = nextArr[nextID];
//						if (id < 0) BvioTWCus[nextID] = vioTWCus[nextID];
//						else BvioTWCus[nextID] = BvioTWCus[id] + vioTWCus[nextID];
//						if (nextID != seg[idVeh].Trip[idTrip].firstCus)
//						{
//							id = nextID;
//							while (preID != pre) //pre may < 0
//							{
//								BvioTWCus[preID] = BvioTWCus[id] + vioTWCus[preID];
//								id = preID; preID = predArr[id];
//								/*if (preID == 0)
//								{
//									cout<<"id = "<<id<<endl;
//									showTripCost(idVeh, idTrip);
//									exit(-1);
//								}
//								cout<<"..preID = "<<preID<<"; pre = "<<pre<<endl;*/
//							}
//							while (preID > 0)
//							{
//								BvioTWCus[preID] = BvioTWCus[id] + vioTWCus[preID];
//								BCAP[preID] -= capDEL;
//								id = preID; preID = predArr[id];
//							}
//							//Update FCAP, FvioTWCus from nextID to lastCus:
//							id = nextID; preID = predArr[nextID];
//							do
//							{
//								FvioTWCus[id] = FvioTWCus[preID] + vioTWCus[id];
//								FCAP[id] -= capDEL;
//								pos[id]--;
//								preID = id; id = nextArr[id];
//							}while (id > 0);
//						}
//						else //nextID is now the firstCus:
//						{
//							//Update FCAP, FvioTWCus from nextID to lastCus:
//							FvioTWCus[nextID] = vioTWCus[nextID];
//							FCAP[nextID] -= capDEL; pos[nextID] = 1;
//							id = nextArr[nextID]; preID = nextID;
//							while (id > 0)
//							{
//								FvioTWCus[id] = FvioTWCus[preID] + vioTWCus[id];
//								FCAP[id] -= capDEL;
//								pos[id]--;
//								preID = id; id = nextArr[id];
//							}
//						}
//
//						//preID now points to the last cus
//						varvioTWC = FvioTWCus[preID] - seg[idVeh].Trip[idTrip].vioTWC;
//						seg[idVeh].Trip[idTrip].vioTWC = FvioTWCus[preID];
//						goto UpdateNC; //not changed: endS, ...
//					}
//					vioTWCus[nextID] = temp;
//					//FvioTWCus[nextID] = FvioTWCus[preID] + temp;
//					cStartS = problem->node[nextID].eTW;
//				}
//				else 
//				{
//					vioTWCus[nextID] = 0;
//					//FvioTWCus[nextID] = FvioTWCus[preID];
//				}
//				FvioTWCUST += vioTWCus[nextID];
//				FvioTWCus[nextID] = FvioTWCUST;
//				startS[nextID] = cStartS;
//				cStartS += problem->node[nextID].duration;
//				depart[nextID] = cStartS;
//				FCAP[nextID] -= capDEL;
//				pos[nextID]--;
//				preID = nextID; nextID = nextArr[nextID];
//			}//end while (nextID > 0)
//			seg[idVeh].Trip[idTrip].endS = cStartS;
//			varvioTWC = FvioTWCus[preID] - seg[idVeh].Trip[idTrip].vioTWC;
//			seg[idVeh].Trip[idTrip].vioTWC = FvioTWCus[preID];
//			//preID now points to the last cus:
//			//Update BCAP from pre to firstCus
//			//Update BvioTWCus from lastCus to firstCus
//			if (preID != pre) //not delete the lastCus
//			{
//				BvioTWCus[preID] = vioTWCus[preID];
//				id = predArr[preID];
//				while (id != pre) //pre may < 0
//				{
//					BvioTWCus[id] = BvioTWCus[preID] + vioTWCus[id];
//					preID = id; id = predArr[id];
//				}
//				while (id > 0)
//				{
//					BvioTWCus[id] = BvioTWCus[preID] + vioTWCus[id];
//					BCAP[id] -= capDEL;
//					preID = id; id = predArr[id];
//				}
//			}
//			else //delete the lastCus
//			{
//				BvioTWCus[pre] = vioTWCus[pre];
//				BCAP[pre] = problem->node[pre].capacity;
//				id = predArr[pre];
//				while (id > 0)
//				{
//					BvioTWCus[id] = BvioTWCus[preID] + vioTWCus[id];
//					BCAP[id] -= capDEL;
//					preID = id; id = predArr[id];
//				}
//			}//end delete the lastCus
//
//		}
//		if (seg[idVeh].Trip[idTrip].waitingS == NO_WS)
//			varcost -= problem->c[lastCOLD][assSP];
//		else varcost -= problem->disCWSSP[lastCOLD][assSP];
//
//		UpdateChangeCONNECTAtSP_PickTrip(idVeh, idTrip, varcost, varcostpreT, varvioTWC, varvioCAP, seg[idVeh].numTrips - 1);
//		return;
//
//UpdateNC: //not changed: endS, ...
//		varFIT = varcost + VTWCUS * varvioTWC + VCAP * varvioCAP;
//		seg[idVeh].Trip[idTrip].cost += varcost;
//		if (seg[idVeh].Trip[idTrip].vioCAP > 0 || seg[idVeh].Trip[idTrip].vioTWC > eps || seg[idVeh].Trip[idTrip].vioTWSP > eps)
//		{
//			seg[idVeh].Trip[idTrip].feasible = 0;
//			seg[idVeh].Trip[idTrip].fitness += varFIT;
//		}
//		else
//		{
//			seg[idVeh].Trip[idTrip].feasible = 1;
//			seg[idVeh].Trip[idTrip].fitness = seg[idVeh].Trip[idTrip].cost;
//		}
//		varC1 = varcost + varcostpreT;
//		varFIT += varcostpreT;
//		seg[idVeh].cost += varC1; seg[idVeh].fitness += varFIT; seg[idVeh].vioTWC += varvioTWC; seg[idVeh].vioCAP += varvioCAP;
//		cost += varC1; fitness += varFIT;vioTWC += varvioTWC; vioCAP += varvioCAP;
//}
//
//void Solution::insertCusPTrip_FromBeginning(int insert_after, int IDinsert, int idVeh, int idTrip) //insert IDinsert after insert_after: note that insert_after is always a customer, so don't need tocheck if it is startSP or endSP or not
//{
//	//see on 2/12/2013
//		route_num[IDinsert] = idVeh; trip_num[IDinsert] = idTrip;
//	
//		//1. Update capacity, numCus, vio_CAP
//		int capINS = problem->node[IDinsert].capacity;
//		seg[idVeh].Trip[idTrip].capacity += capINS;
//		int vioCAPNEW = PDS_MAX(seg[idVeh].Trip[idTrip].capacity - problem->Q,0);
//		int varvioCAP = vioCAPNEW - seg[idVeh].Trip[idTrip].vioCAP;
//		seg[idVeh].Trip[idTrip].vioCAP = vioCAPNEW;
//		
//		int assSP = seg[idVeh].Trip[idTrip].assSP; 
//		int lastCOLD = seg[idVeh].Trip[idTrip].lastCus;
//		int next = nextArr[insert_after];
//		int nextTrip = idTrip + 1;
//		double varcost, varvioTWC, cStartS, temp, cArrTime;
//		int id, preID, nextID;
//		
//		nextArr[insert_after] = IDinsert; predArr[IDinsert] = insert_after;
//		nextArr[IDinsert] = next;
//		if (next > 0)
//		{
//			predArr[next] = IDinsert;
//			varcost = problem->c[insert_after][IDinsert] + problem->c[IDinsert][next] - problem->c[insert_after][next];
//		    BCAP[IDinsert] = BCAP[next] + capINS;
//		}
//		else //insert_after was the lastCus--> IDinsert is now the lastCus
//		{
//			seg[idVeh].Trip[idTrip].lastCus = IDinsert;
//			varcost = problem->c[insert_after][IDinsert];
//			BCAP[IDinsert] = capINS;
//		}//end insert_after was the lastCus--> IDinsert is now the lastCus
//
//		//1.Recalculate from beginning to predArr[IDinsert]
//		//Update 11/11/2013
//		if (idTrip == 0 && seg[idVeh].Trip[idTrip].numCus == 1)
//		{
//			startS[insert_after] = PDS_MAX(problem->c[0][insert_after], problem->node[insert_after].sTW);
//			depart[insert_after] = startS[insert_after] + problem->node[insert_after].duration;
//		    seg[idVeh].Trip[idTrip].numCus += 1;
//		}
//		else
//		{
//			seg[idVeh].Trip[idTrip].numCus += 1;
//			if (idTrip == 0)
//			{
//				preID = 0; cStartS = 0;
//			}
//			else
//			{
//				int preT = idTrip - 1;
//				if (seg[idVeh].Trip[preT].Type == 0)
//				{
//					preID = seg[idVeh].Trip[preT].assSP;
//					cStartS = seg[idVeh].Trip[preT].leaveSP;
//				}
//				else
//				{
//					preID = seg[idVeh].Trip[preT].lastCus;
//					cStartS = depart[preID];
//				}
//			}
//			nextID = seg[idVeh].Trip[idTrip].firstCus;
//			while (nextID != IDinsert)
//			{
//				cArrTime = cStartS + problem->c[preID][nextID]; //arrTime at customer nextID
//				temp = cArrTime - problem->node[nextID].eTW;
//				if (temp > eps)
//				{
//					vioTWCus[nextID] = temp;
//					FvioTWCus[nextID] = FvioTWCus[preID] + temp;
//					startS[nextID] = problem->node[nextID].eTW;
//					depart[nextID] = problem->node[nextID].depart;
//				}
//				else
//				{
//					vioTWCus[nextID] = 0;
//					FvioTWCus[nextID] = FvioTWCus[preID];
//					startS[nextID] = PDS_MAX(cArrTime, problem->node[nextID].sTW);
//					depart[nextID] = startS[nextID] + problem->node[nextID].duration;
//				}
//				cStartS = depart[nextID];
//				preID = nextID; nextID = nextArr[nextID];
//			}
//		}
//		
//		//Check at IDinsert
//		cArrTime = depart[insert_after] + problem->c[insert_after][IDinsert];
//		temp = cArrTime - problem->node[IDinsert].eTW;
//		if (temp > eps) 
//		{
//			vioTWCus[IDinsert] = temp;
//			FvioTWCus[IDinsert] = FvioTWCus[insert_after] + temp;
//			startS[IDinsert] = problem->node[IDinsert].eTW;
//			depart[IDinsert] = problem->node[IDinsert].depart;
//		}
//		else 
//		{
//            vioTWCus[IDinsert] = 0;
//			FvioTWCus[IDinsert] = FvioTWCus[insert_after];
//			startS[IDinsert] = PDS_MAX(cArrTime, problem->node[IDinsert].sTW);
//			depart[IDinsert] = startS[IDinsert] + problem->node[IDinsert].duration;
//		}
//		cStartS = depart[IDinsert];
//		FCAP[IDinsert] = FCAP[insert_after] + problem->node[IDinsert].capacity;
//		pos[IDinsert] = pos[insert_after]+1;
//		
//		preID = IDinsert; nextID = next;
//		while (nextID > 0)
//		{
//			cArrTime = cStartS + problem->c[preID][nextID]; //arrTime at customer nextID
//			cStartS = PDS_MAX(cArrTime, problem->node[nextID].sTW);
//			if (PDSDIF(cStartS, startS[nextID]) == 0) //it means varvioTWCus[nextID] = 0 if (cStartS != node[nextID].eTW)
//			{
//				temp = cStartS - problem->node[nextID].eTW;
//				if (temp > eps) vioTWCus[nextID] = temp;
//				else vioTWCus[nextID] = 0;
//				//Update BvioTWCus from nextID to firstCus
//				//Update BCAP from insert_after to firstCus 
//				//Update FCAP, FvioTWCus, pos from nextID to lastCus   
//				id = nextArr[nextID];
//				if (id < 0) BvioTWCus[nextID] = vioTWCus[nextID];
//				else BvioTWCus[nextID] = BvioTWCus[id] + vioTWCus[nextID];
//				id = nextID;
//				while (preID != insert_after)
//				{
//					BvioTWCus[preID] = BvioTWCus[id] + vioTWCus[preID];
//					id = preID; preID = predArr[id];
//				}
//				//update BCAP from insert_after to firstCus
//				while (preID > 0)
//				{
//					BvioTWCus[preID] = BvioTWCus[id] + vioTWCus[preID];
//					BCAP[preID] += capINS;
//					id = preID; preID = predArr[id];
//				}
//				//update FCAP, FvioTWCus, pos from nextID to lastCus: 
//				id = nextID; preID = predArr[nextID];
//				do
//				{
//					FvioTWCus[id] = FvioTWCus[preID] + vioTWCus[id];
//					FCAP[id] += capINS; 
//					pos[id] ++;
//					preID = id; id = nextArr[id];
//				}while (id > 0);
//				//preID now points to the last cus
//				varvioTWC = FvioTWCus[preID] - seg[idVeh].Trip[idTrip].vioTWC; 
//				seg[idVeh].Trip[idTrip].vioTWC = FvioTWCus[preID];
//				goto UpdateNC; //not changed: endS, ...
//			}
//			temp = cStartS - problem->node[nextID].eTW;
//			if (temp > eps)
//			{
//				if (vioTWCus[nextID] > eps) 
//				{
//					vioTWCus[nextID] = temp;
//					//Update BvioTWCus from nextID to firstCus
//					//Update BCAP from insert_after to firstCus 
//					//Update FCAP, FvioTWCus, pos from nextID to lastCus 
//					id = nextArr[nextID];
//					if (id < 0) BvioTWCus[nextID] = vioTWCus[nextID];
//					else BvioTWCus[nextID] = BvioTWCus[id] + vioTWCus[nextID];
//
//					id = nextID;
//					while (preID != insert_after) 
//					{
//						BvioTWCus[preID] = BvioTWCus[id] + vioTWCus[preID];
//						id = preID; preID = predArr[id];
//					}
//					while (preID > 0)
//					{
//						BvioTWCus[preID] = BvioTWCus[id] + vioTWCus[preID];
//						BCAP[preID] += capINS;
//						id = preID; preID = predArr[id];
//					}
//
//					//Update FCAP, FvioTWCus, pos from nextID to lastCus:
//					id = nextID; preID = predArr[nextID];
//					do
//					{
//						FvioTWCus[id] = FvioTWCus[preID] + vioTWCus[id];
//						FCAP[id] += capINS;
//						pos[id] ++;
//						preID = id; id = nextArr[id];
//					}while (id > 0);
//					//preID now points to the last cus
//					varvioTWC = FvioTWCus[preID] - seg[idVeh].Trip[idTrip].vioTWC;
//					seg[idVeh].Trip[idTrip].vioTWC = FvioTWCus[preID];
//					goto UpdateNC; //not changed: endS, ...
//				}
//				vioTWCus[nextID] = temp;
//				FvioTWCus[nextID] = FvioTWCus[preID] + temp;
//				cStartS = problem->node[nextID].eTW;
//			}
//			else 
//			{
//				vioTWCus[nextID] = 0;
//				FvioTWCus[nextID] = FvioTWCus[preID];
//			}
//			startS[nextID] = cStartS;
//			cStartS += problem->node[nextID].duration;
//			depart[nextID] = cStartS;
//			FCAP[nextID] += capINS;
//			pos[nextID] ++;
//			preID = nextID; nextID = nextArr[nextID];
//		}//end while (nextID > 0)
//		seg[idVeh].Trip[idTrip].endS = cStartS;
//		varvioTWC = FvioTWCus[preID] - seg[idVeh].Trip[idTrip].vioTWC;
//		seg[idVeh].Trip[idTrip].vioTWC = FvioTWCus[preID];
//		//preID now points to the last cus:
//		//Update BCAP from insert_after to firstCus
//		//Update BvioTWCus from lastCus to firstCus
//		BvioTWCus[preID] = vioTWCus[preID];
//		id = predArr[preID];
//		while (id != insert_after) 
//		{
//			BvioTWCus[id] = BvioTWCus[preID] + vioTWCus[id];
//			preID = id; id = predArr[id];
//		}
//		while (id > 0)
//		{
//			BvioTWCus[id] = BvioTWCus[preID] + vioTWCus[id];
//			BCAP[id] += capINS;
//			preID = id; id = predArr[id];
//		}
//		if (seg[idVeh].Trip[idTrip].waitingS == NO_WS)
//			varcost -= problem->c[lastCOLD][assSP];
//		else varcost -= problem->disCWSSP[lastCOLD][assSP];
//
//		UpdateChangeCONNECTAtSP_PickTrip(idVeh, idTrip, varcost, 0, varvioTWC, varvioCAP, seg[idVeh].numTrips - 1); //varcostpreT = 0
//		return;
//
//UpdateNC: //not changed: endS, ...
//		double varFIT = varcost + VTWCUS * varvioTWC + VCAP * varvioCAP;
//		seg[idVeh].Trip[idTrip].cost += varcost;
//		if (seg[idVeh].Trip[idTrip].vioCAP > 0 || seg[idVeh].Trip[idTrip].vioTWC > eps || seg[idVeh].Trip[idTrip].vioTWSP > eps)
//		{
//			seg[idVeh].Trip[idTrip].feasible = 0;
//			seg[idVeh].Trip[idTrip].fitness += varFIT;
//		}
//		else
//		{
//			seg[idVeh].Trip[idTrip].feasible = 1;
//			seg[idVeh].Trip[idTrip].fitness = seg[idVeh].Trip[idTrip].cost;
//		}
//		seg[idVeh].cost += varcost; seg[idVeh].fitness += varFIT; seg[idVeh].vioTWC += varvioTWC; seg[idVeh].vioCAP += varvioCAP;
//		cost += varcost; fitness += varFIT;vioTWC += varvioTWC; vioCAP += varvioCAP;
//}
//
//
//void Solution::insertCusPTrip(int insert_after, int IDinsert,int idVeh, int idTrip, int update_idTrip)
//{       //see on 2/12/2013
//	    //Copy insertCusPTrip: except that just update remaining trips till update_idTrip rather than all remaining trips
//		route_num[IDinsert] = idVeh; trip_num[IDinsert] = idTrip;
//	
//		//1. Update capacity, numCus, vio_CAP
//		int capINS = problem->node[IDinsert].capacity;
//		seg[idVeh].Trip[idTrip].capacity += capINS;
//		int vioCAPNEW = PDS_MAX(seg[idVeh].Trip[idTrip].capacity - problem->Q,0);
//		int varvioCAP = vioCAPNEW - seg[idVeh].Trip[idTrip].vioCAP;
//		seg[idVeh].Trip[idTrip].vioCAP = vioCAPNEW;
//		
//		//Update 11/11/2013
//		if (idTrip == 0 && seg[idVeh].Trip[idTrip].numCus == 1)
//		{
//			startS[insert_after] = PDS_MAX(problem->c[0][insert_after], problem->node[insert_after].sTW);
//			depart[insert_after] = startS[insert_after] + problem->node[insert_after].duration;
//		}
//
//		seg[idVeh].Trip[idTrip].numCus += 1;
//
//		int assSP = seg[idVeh].Trip[idTrip].assSP; 
//		int lastCOLD = seg[idVeh].Trip[idTrip].lastCus;
//		int next = nextArr[insert_after];
//		int nextTrip = idTrip + 1;
//		double varcost, varvioTWC, cStartS, temp, cArrTime;
//		int id, preID, nextID;
//		
//		nextArr[insert_after] = IDinsert; predArr[IDinsert] = insert_after;
//		nextArr[IDinsert] = next;
//		if (next > 0)
//		{
//			predArr[next] = IDinsert;
//			varcost = problem->c[insert_after][IDinsert] + problem->c[IDinsert][next] - problem->c[insert_after][next];
//		    BCAP[IDinsert] = BCAP[next] + capINS;
//		}
//		else //insert_after was the lastCus--> IDinsert is now the lastCus
//		{
//			seg[idVeh].Trip[idTrip].lastCus = IDinsert;
//			varcost = problem->c[insert_after][IDinsert];
//			BCAP[IDinsert] = capINS;
//		}//end insert_after was the lastCus--> IDinsert is now the lastCus
//
//
//		//Check at IDinsert
//		cArrTime = depart[insert_after] + problem->c[insert_after][IDinsert];
//		temp = cArrTime - problem->node[IDinsert].eTW;
//		if (temp > eps) 
//		{
//			vioTWCus[IDinsert] = temp;
//			FvioTWCus[IDinsert] = FvioTWCus[insert_after] + temp;
//			startS[IDinsert] = problem->node[IDinsert].eTW;
//			depart[IDinsert] = problem->node[IDinsert].depart;
//		}
//		else 
//		{
//            vioTWCus[IDinsert] = 0;
//			FvioTWCus[IDinsert] = FvioTWCus[insert_after];
//			startS[IDinsert] = PDS_MAX(cArrTime, problem->node[IDinsert].sTW);
//			depart[IDinsert] = startS[IDinsert] + problem->node[IDinsert].duration;
//		}
//		cStartS = depart[IDinsert];
//		FCAP[IDinsert] = FCAP[insert_after] + problem->node[IDinsert].capacity;
//		pos[IDinsert] = pos[insert_after]+1;
//		
//		preID = IDinsert; nextID = next;
//		while (nextID > 0)
//		{
//			cArrTime = cStartS + problem->c[preID][nextID]; //arrTime at customer nextID
//			cStartS = PDS_MAX(cArrTime, problem->node[nextID].sTW);
//			if (PDSDIF(cStartS, startS[nextID]) == 0) //it means varvioTWCus[nextID] = 0 if (cStartS != node[nextID].eTW)
//			{
//				temp = cStartS - problem->node[nextID].eTW;
//				if (temp > eps) vioTWCus[nextID] = temp;
//				else vioTWCus[nextID] = 0;
//				//Update BvioTWCus from nextID to firstCus
//				//Update BCAP from insert_after to firstCus 
//				//Update FCAP, FvioTWCus, pos from nextID to lastCus   
//				id = nextArr[nextID];
//				if (id < 0) BvioTWCus[nextID] = vioTWCus[nextID];
//				else BvioTWCus[nextID] = BvioTWCus[id] + vioTWCus[nextID];
//				id = nextID;
//				while (preID != insert_after)
//				{
//					BvioTWCus[preID] = BvioTWCus[id] + vioTWCus[preID];
//					id = preID; preID = predArr[id];
//				}
//				//update BCAP from insert_after to firstCus
//				while (preID > 0)
//				{
//					BvioTWCus[preID] = BvioTWCus[id] + vioTWCus[preID];
//					BCAP[preID] += capINS;
//					id = preID; preID = predArr[id];
//				}
//				//update FCAP, FvioTWCus, pos from nextID to lastCus: 
//				id = nextID; preID = predArr[nextID];
//				do
//				{
//					FvioTWCus[id] = FvioTWCus[preID] + vioTWCus[id];
//					FCAP[id] += capINS; 
//					pos[id] ++;
//					preID = id; id = nextArr[id];
//				}while (id > 0);
//				//preID now points to the last cus
//				varvioTWC = FvioTWCus[preID] - seg[idVeh].Trip[idTrip].vioTWC; 
//				seg[idVeh].Trip[idTrip].vioTWC = FvioTWCus[preID];
//				goto UpdateNC; //not changed: endS, ...
//			}
//			temp = cStartS - problem->node[nextID].eTW;
//			if (temp > eps)
//			{
//				if (vioTWCus[nextID] > eps) 
//				{
//					vioTWCus[nextID] = temp;
//					//Update BvioTWCus from nextID to firstCus
//					//Update BCAP from insert_after to firstCus 
//					//Update FCAP, FvioTWCus, pos from nextID to lastCus 
//					id = nextArr[nextID];
//					if (id < 0) BvioTWCus[nextID] = vioTWCus[nextID];
//					else BvioTWCus[nextID] = BvioTWCus[id] + vioTWCus[nextID];
//
//					id = nextID;
//					while (preID != insert_after) 
//					{
//						BvioTWCus[preID] = BvioTWCus[id] + vioTWCus[preID];
//						id = preID; preID = predArr[id];
//					}
//					while (preID > 0)
//					{
//						BvioTWCus[preID] = BvioTWCus[id] + vioTWCus[preID];
//						BCAP[preID] += capINS;
//						id = preID; preID = predArr[id];
//					}
//
//					//Update FCAP, FvioTWCus, pos from nextID to lastCus:
//					id = nextID; preID = predArr[nextID];
//					do
//					{
//						FvioTWCus[id] = FvioTWCus[preID] + vioTWCus[id];
//						FCAP[id] += capINS;
//						pos[id] ++;
//						preID = id; id = nextArr[id];
//					}while (id > 0);
//					//preID now points to the last cus
//					varvioTWC = FvioTWCus[preID] - seg[idVeh].Trip[idTrip].vioTWC;
//					seg[idVeh].Trip[idTrip].vioTWC = FvioTWCus[preID];
//					goto UpdateNC; //not changed: endS, ...
//				}
//				vioTWCus[nextID] = temp;
//				FvioTWCus[nextID] = FvioTWCus[preID] + temp;
//				cStartS = problem->node[nextID].eTW;
//			}
//			else 
//			{
//				vioTWCus[nextID] = 0;
//				FvioTWCus[nextID] = FvioTWCus[preID];
//			}
//			startS[nextID] = cStartS;
//			cStartS += problem->node[nextID].duration;
//			depart[nextID] = cStartS;
//			FCAP[nextID] += capINS;
//			pos[nextID] ++;
//			preID = nextID; nextID = nextArr[nextID];
//		}//end while (nextID > 0)
//		seg[idVeh].Trip[idTrip].endS = cStartS;
//		varvioTWC = FvioTWCus[preID] - seg[idVeh].Trip[idTrip].vioTWC;
//		seg[idVeh].Trip[idTrip].vioTWC = FvioTWCus[preID];
//		//preID now points to the last cus:
//		//Update BCAP from insert_after to firstCus
//		//Update BvioTWCus from lastCus to firstCus
//		BvioTWCus[preID] = vioTWCus[preID];
//		id = predArr[preID];
//		while (id != insert_after) 
//		{
//			BvioTWCus[id] = BvioTWCus[preID] + vioTWCus[id];
//			preID = id; id = predArr[id];
//		}
//		while (id > 0)
//		{
//			BvioTWCus[id] = BvioTWCus[preID] + vioTWCus[id];
//			BCAP[id] += capINS;
//			preID = id; id = predArr[id];
//		}
//		if (seg[idVeh].Trip[idTrip].waitingS == NO_WS)
//			varcost -= problem->c[lastCOLD][assSP];
//		else varcost -= problem->disCWSSP[lastCOLD][assSP];
//
//		UpdateChangeCONNECTAtSP_PickTrip(idVeh, idTrip, varcost, 0, varvioTWC, varvioCAP, update_idTrip); //varcostpreT = 0
//		return;
//
//UpdateNC: //not changed: endS, ...
//		double varFIT = varcost + VTWCUS * varvioTWC + VCAP * varvioCAP;
//		seg[idVeh].Trip[idTrip].cost += varcost;
//		if (seg[idVeh].Trip[idTrip].vioCAP > 0 || seg[idVeh].Trip[idTrip].vioTWC > eps || seg[idVeh].Trip[idTrip].vioTWSP > eps)
//		{
//			seg[idVeh].Trip[idTrip].feasible = 0;
//			seg[idVeh].Trip[idTrip].fitness += varFIT;
//		}
//		else
//		{
//			seg[idVeh].Trip[idTrip].feasible = 1;
//			seg[idVeh].Trip[idTrip].fitness = seg[idVeh].Trip[idTrip].cost;
//		}
//		seg[idVeh].cost += varcost; seg[idVeh].fitness += varFIT; seg[idVeh].vioTWC += varvioTWC; seg[idVeh].vioCAP += varvioCAP;
//		cost += varcost; fitness += varFIT;vioTWC += varvioTWC; vioCAP += varvioCAP;
//}
//
//void Solution::delete_insertCusPTrip(int idCusi, int idTripi, int idCusj, int idTripj, int idVeh)
//{
//	//see on 2/12/2013
//	//empty idTripi which is before idTripj, (NOT NECCESSARY RIGHT BEFORE), then insert idCusi after idCusj on trip idTripj, then DON TOA and update all remaining trips of idVeh
//   
//	//1. Copy from Update_EmptyTripP:
//	int lastTrip = seg[idVeh].numTrips - 1;
//	seg[idVeh].numTrips --;
//	int i;
//	double varvioTWSP, varcost, varFIT;
//
//	int varvioCAP = -seg[idVeh].Trip[idTripi].vioCAP;
//	//seg[idVeh].Trip[idTrip].numCus=0;
//
//	idTripj--;
//	int update_idTrip = idTripj - 1;
//	double cStartSOLD = depart[seg[idVeh].Trip[update_idTrip].lastCus];
//
//		if (idTripi == 0) //first trip becomes empty
//		{
//			//Don toa:
//			for (i=0;i<seg[idVeh].numTrips; i++)
//			{
//				seg[idVeh].Trip[i] = seg[idVeh].Trip[i+1];
//				UpdateTripnum(idVeh,i);
//			}
//			if (seg[idVeh].Trip[0].Type == 1)
//			{
//				seg[idVeh].Trip[0].coordinate = 0;
//				int assSP = seg[idVeh].Trip[0].assSP;
//				seg[idVeh].Trip[0].leaveSP = problem->leaveSP[assSP][4]; //load only at sTW2
//				varvioTWSP = -seg[idVeh].Trip[0].vioTWSP;
//				seg[idVeh].Trip[0].vioTWSP = 0;
//				varcost = problem->c[0][assSP];
//				seg[idVeh].Trip[0].cost += varcost;
//				varFIT = varcost + VTWSP * varvioTWSP;
//				seg[idVeh].Trip[0].fitness += varFIT;
//				UpdateVehicle(idVeh, 0, assSP, seg[idVeh].Trip[0].leaveSP, varvioCAP,update_idTrip);
//			}
//			else
//			{
//				varcost = problem->c[0][seg[idVeh].Trip[0].firstCus];
//				seg[idVeh].Trip[0].cost += varcost;
//				seg[idVeh].Trip[0].fitness += varcost;
//				if (seg[idVeh].Trip[0].Type == 2) seg[idVeh].Trip[0].assSP = 0;
//				if (update_idTrip >= 0)
//				    UpdateVehicle(idVeh, 0, 0, 0, varvioCAP, update_idTrip);
//			}
//		}
//		else //middle pickup trip becomes empty: CAN'T BE LAST TRIP BECAUSE NEED TO INSERT idCusi later into idTripj
//		{
//			//Don toa:
//			for (i=idTripi;i<seg[idVeh].numTrips; i++)
//			{
//				seg[idVeh].Trip[i] = seg[idVeh].Trip[i+1];
//				UpdateTripnum(idVeh,i);
//			}
//			int preT = idTripi - 1;
//			if (seg[idVeh].Trip[preT].Type == 1)
//			{
//				if (seg[idVeh].Trip[idTripi].Type == 1) //preT is delivery trip, nextTrip is deliverytrip 
//				{
//					seg[idVeh].Trip[idTripi].coordinate = 0;
//					updateChangeCONNECTAtSP_DDORC2CD(idVeh, idTripi, preT, varvioCAP, update_idTrip); //for delete_insertCusPTrip: connect deliverytrip(idVeh, preT) with delivery trip (idVeh, nextTrip) where (idVeh, idTrip) is already deleted 
//				}
//				else //preT is delivery trip, nextTrip is (pickup OR C2C)
//				{
//					varcost = -seg[idVeh].Trip[preT].connectCost;
//					seg[idVeh].Trip[preT].connectCost = problem->c[seg[idVeh].Trip[preT].lastCus][seg[idVeh].Trip[idTripi].firstCus];
//				    varcost += seg[idVeh].Trip[preT].connectCost;
//					seg[idVeh].Trip[preT].cost += varcost;
//					seg[idVeh].Trip[preT].fitness += varcost;
//					if (idTripi != idTripj) //idTripj is not right after idTripi (before deletion)
//					   UpdateVehicle(idVeh, idTripi, seg[idVeh].Trip[preT].lastCus, seg[idVeh].Trip[preT].endS, varvioCAP, update_idTrip);
//				}//end preT is delivery trip, nextTrip is (pickup OR C2C)
//			}
//			else if (seg[idVeh].Trip[preT].Type == 0) //preT is pickup (middle trip becomes empty)
//			{
//				if (seg[idVeh].Trip[idTripi].Type == 1) //preT is pickup trip, nextTrip is delivery (middle trip becomes empty)
//				{
//					seg[idVeh].Trip[idTripi].coordinate = 0;
//					updateChangeCONNECTAtSP_SPSP(idVeh, idTripi, preT, varvioCAP, update_idTrip); //for Update_EmptyTripD and Update_EmptyTripP: connect pickuptrip(idVeh, preT) with delivery trip (idVeh, nextTrip) where (idVeh, idTrip) is already deleted 
//				}
//				else //preT is pickup trip, nextTrip is pickup OR C2C (middle trip becomes empty)
//				{
//					varcost = -seg[idVeh].Trip[preT].connectCost;
//					seg[idVeh].Trip[preT].connectCost = problem->c[seg[idVeh].Trip[preT].assSP][seg[idVeh].Trip[idTripi].firstCus];
//				    varcost += seg[idVeh].Trip[preT].connectCost;
//					seg[idVeh].Trip[preT].cost += varcost;
//					seg[idVeh].Trip[preT].fitness += varcost;
//					if (seg[idVeh].Trip[idTripi].Type == 2) seg[idVeh].Trip[idTripi].assSP = seg[idVeh].Trip[preT].assSP;
//					if (idTripi != idTripj) //idTripj is not right after idTripi (before deletion)
//					   UpdateVehicle(idVeh, idTripi, seg[idVeh].Trip[preT].assSP, seg[idVeh].Trip[preT].leaveSP, varvioCAP, update_idTrip);
//				}//end preT is pickup trip, nextTrip is pickup OR C2C (middle trip becomes empty)
//			}//end preT is pickup (middle trip becomes empty)
//			else //preT is C2C (middle trip becomes empty)
//			{
//				if (seg[idVeh].Trip[idTripi].Type == 1) //preT is C2C trip, nextTrip is deliverytrip 
//				{
//					seg[idVeh].Trip[preT].nextSP = seg[idVeh].Trip[idTripi].assSP;
//					seg[idVeh].Trip[idTripi].coordinate = 0;
//					updateChangeCONNECTAtSP_DDORC2CD(idVeh, idTripi, preT, varvioCAP, update_idTrip); //for delete_insertCusPTrip: connect deliverytrip(idVeh, preT) with delivery trip (idVeh, nextTrip) where (idVeh, idTrip) is already deleted 
//				}
//				else //preT is C2C trip, nextTrip is (pickup OR C2C)
//				{
//					//seg[idVeh].Trip[preT].nextSP = -1;
//					varcost = -seg[idVeh].Trip[preT].connectCost;
//					seg[idVeh].Trip[preT].connectCost = problem->c[seg[idVeh].Trip[preT].lastCus][seg[idVeh].Trip[idTripi].firstCus];
//				    varcost += seg[idVeh].Trip[preT].connectCost;
//					seg[idVeh].Trip[preT].cost += varcost;
//					seg[idVeh].Trip[preT].fitness += varcost;
//					if (idTripi != idTripj) //idTripj is not right after idTripi (before deletion)
//					   UpdateVehicle(idVeh, idTripi, seg[idVeh].Trip[preT].lastCus, seg[idVeh].Trip[preT].endS, varvioCAP, update_idTrip);
//				}//end preT is delivery trip, nextTrip is (pickup OR C2C)
//			}//end preT is C2C (middle trip becomes empty)
//		}//end middle pickup trip becomes empty
//
//		//2. Insert idCusi after idCusj on idTripj: copy insertCusPTrip
//		if (idTripi == idTripj) //idTripj is right after idTripi
//			insertCusPTrip_FromBeginning(idCusj, idCusi, idVeh, idTripj);
//		else
//		{
//			if (PDSDIF(cStartSOLD, depart[seg[idVeh].Trip[update_idTrip].lastCus]))
//				insertCusPTrip_FromBeginning(idCusj, idCusi, idVeh, idTripj);
//			else
//				insertCusPTrip(idCusj, idCusi, idVeh, idTripj, seg[idVeh].numTrips - 1);
//		}
//}
//
//
//
//void Solution::replaceCusPTrip_FromBeginning(int pre, int IDReplaced, int suc, int IDinsert, int lastCOLD, int idVeh, int idTrip)
//{
//	//see on 2/12/2013
//	//insert IDinsert between pre and suc (delete the cus between pre and suc): if pre < 0 that means insert IDinsert at the beginning of the trip 
//    //then update all remaining trips in the vehicle idVeh
//	//DIF from replaceCusPTrip: calculate from beginning of the trip rather than from pre as in replaceCusPTrip
//
//	route_num[IDinsert] = idVeh; trip_num[IDinsert] = idTrip;
//	predArr[IDinsert] = pre; nextArr[IDinsert] = suc; 
//
//	int assSP = seg[idVeh].Trip[idTrip].assSP; 
//	double cStartS, varcost, varcostpreT = 0;
//	double varvioTWC = 0;
//	int varvioCAP = 0;
//
//	if (idTrip == 0 && seg[idVeh].Trip[idTrip].numCus == 1)
//	{
//		pos[IDinsert] = 1;
//		startS[IDinsert] = problem->startSOneP[IDinsert][assSP];
//		depart[IDinsert] = startS[IDinsert] + problem->node[IDinsert].duration;
//		vioTWCus[IDinsert] = 0; FvioTWCus[IDinsert] = 0; BvioTWCus[IDinsert] = 0;
//		seg[idVeh].Trip[0].capacity = problem->node[IDinsert].capacity;
//		FCAP[IDinsert] = problem->node[IDinsert].capacity;
//		BCAP[IDinsert] = problem->node[IDinsert].capacity;
//		seg[idVeh].Trip[0].endS = depart[IDinsert];
//		seg[idVeh].Trip[0].firstCus = IDinsert;
//		seg[idVeh].Trip[0].lastCus = IDinsert;
//		//dont need varvioTWC
//		varcost = problem->c[0][IDinsert] - problem->c[0][IDReplaced];
//	}
//	else
//	{
//		int nextID, preID;
//
//		if (pre < 0) //Replace the first cus
//		{
//			seg[idVeh].Trip[idTrip].firstCus = IDinsert;
//			pos[IDinsert] = 1;
//			if (idTrip == 0) //replace the first cus of first trip
//			{
//				preID = 0;cStartS = 0; 
//				varcost = problem->c[0][IDinsert] - problem->c[0][IDReplaced];
//			}
//			else //replace the first cus of middle/last trip
//			{
//				int preT = idTrip - 1;
//				if (seg[idVeh].Trip[preT].Type == 0)
//				{
//					preID = seg[idVeh].Trip[preT].assSP;
//					cStartS = seg[idVeh].Trip[preT].leaveSP;
//				}
//				else
//				{
//					preID = seg[idVeh].Trip[preT].lastCus;
//					cStartS = depart[preID];
//				}
//				varcost = 0;
//				varcostpreT = problem->c[preID][IDinsert] - problem->c[preID][IDReplaced];
//				seg[idVeh].Trip[preT].connectCost = problem->c[preID][IDinsert];
//				seg[idVeh].Trip[preT].cost += varcostpreT;
//				seg[idVeh].Trip[preT].fitness += varcostpreT;
//			}//end delete the first cus of middle/last trip
//			if (suc > 0)
//			{
//				varcost += (problem->c[IDinsert][suc] - problem->c[IDReplaced][suc]);
//				BCAP[IDinsert] = BCAP[suc] + problem->node[IDinsert].capacity;
//				predArr[suc] = IDinsert;
//			}
//			else
//			{
//				BCAP[IDinsert] = problem->node[IDinsert].capacity;
//				seg[idVeh].Trip[idTrip].lastCus = IDinsert;
//			}
//		}
//		else //replace the middle/last cus
//		{
//			pos[IDinsert] = pos[pre] + 1;
//			nextArr[pre] = IDinsert; preID = pre;
//			if (suc > 0) //delete the middle cus
//			{
//				predArr[suc] = IDinsert;
//				varcost = (problem->c[pre][IDinsert] + problem->c[IDinsert][suc]) - (problem->c[pre][IDReplaced] + problem->c[IDReplaced][suc]);
//				BCAP[IDinsert] = BCAP[suc] + problem->node[IDinsert].capacity;
//			}
//			else //replace the lastcus
//			{
//				seg[idVeh].Trip[idTrip].lastCus = IDinsert;
//				varcost = problem->c[pre][IDinsert] - problem->c[pre][IDReplaced];
//				BCAP[IDinsert] = problem->node[IDinsert].capacity;
//			}//end replace the lastCus
//
//			if (idTrip == 0)
//			{
//				preID = 0; cStartS = 0;
//			}
//			else
//			{
//				int preT = idTrip - 1;
//				if (seg[idVeh].Trip[preT].Type == 0)
//				{
//					preID = seg[idVeh].Trip[preT].assSP;
//					cStartS = seg[idVeh].Trip[preT].leaveSP;
//				}
//				else
//				{
//					preID = seg[idVeh].Trip[preT].lastCus;
//					cStartS = depart[preID];
//				}
//			}
//		}//end replace the middle/last cus
//
//		//1. Update capacity, numCus, vio_CAP
//		int capDELTA = problem->node[IDinsert].capacity - problem->node[IDReplaced].capacity;
//		seg[idVeh].Trip[idTrip].capacity += capDELTA;
//		int vioCAPNEW = PDS_MAX(seg[idVeh].Trip[idTrip].capacity - problem->Q,0);
//		varvioCAP = vioCAPNEW - seg[idVeh].Trip[idTrip].vioCAP;
//		seg[idVeh].Trip[idTrip].vioCAP = vioCAPNEW;
//			
//		int nextTrip = idTrip + 1;
//		double temp, cArrTime;
//		int id;
//
//		nextID = seg[idVeh].Trip[idTrip].firstCus;
//		cArrTime = cStartS + problem->c[preID][nextID]; //arrTime at customer nextID
//		temp = cArrTime - problem->node[nextID].eTW;
//		if (temp > eps)
//		{
//			vioTWCus[nextID] = temp;
//			FvioTWCus[nextID] = temp;
//			startS[nextID] = problem->node[nextID].eTW;
//			depart[nextID] = problem->node[nextID].depart;
//		}
//		else
//		{
//			vioTWCus[nextID] = 0;
//			FvioTWCus[nextID] = 0;
//            startS[nextID] = PDS_MAX(cArrTime, problem->node[nextID].sTW);
//			depart[nextID] = startS[nextID] + problem->node[nextID].duration;
//		}
//		cStartS = depart[nextID];
//		FCAP[nextID] = problem->node[nextID].capacity;
//		preID = nextID; nextID = nextArr[nextID];
//		while (nextID != suc)
//		{
//			cArrTime = cStartS + problem->c[preID][nextID]; //arrTime at customer nextID
//			temp = cArrTime - problem->node[nextID].eTW;
//			if (temp > eps)
//			{
//				vioTWCus[nextID] = temp;
//				FvioTWCus[nextID] = FvioTWCus[preID] + temp;
//				startS[nextID] = problem->node[nextID].eTW;
//				depart[nextID] = problem->node[nextID].depart;
//			}
//			else
//			{
//				vioTWCus[nextID] = 0;
//				FvioTWCus[nextID] = FvioTWCus[preID];
//                startS[nextID] = PDS_MAX(cArrTime, problem->node[nextID].sTW);
//				depart[nextID] = startS[nextID] + problem->node[nextID].duration;
//			}
//			cStartS = depart[nextID];
//			FCAP[nextID] = FCAP[preID] + problem->node[nextID].capacity;
//			preID = nextID; nextID = nextArr[nextID];
//		}
//
//		//nextID now points to suc:
//		while (nextID > 0)
//		{
//			cArrTime = cStartS + problem->c[preID][nextID]; //arrTime at customer nextID
//			cStartS = PDS_MAX(cArrTime, problem->node[nextID].sTW);
//			if (PDSDIF(cStartS, startS[nextID]) == 0) //it means varvioTWCus[nextID] = 0 if (cStartS != node[nextID].eTW)
//			{
//				temp = cStartS - problem->node[nextID].eTW;
//				if (temp > eps) vioTWCus[nextID] = temp;
//				else vioTWCus[nextID] = 0;
//				//Update BvioTWCus from nextID to firstCus
//				//Update BCAP from pre to firstCus (pre may < 0) 
//				//Update FCAP, FvioTWCus from nextID to lastCus //don't need to update pos
//				id = nextArr[nextID];
//				if (id < 0) BvioTWCus[nextID] = vioTWCus[nextID];
//				else BvioTWCus[nextID] = BvioTWCus[id] + vioTWCus[nextID];
//				if (pre < 0) //dont need to update BCAP
//				{
//					id = nextID; 
//					while (preID > 0)
//					{
//						BvioTWCus[preID] = BvioTWCus[id] + vioTWCus[preID];
//						id = preID; preID = predArr[preID];
//					}
//				}
//				else
//				{
//					id = nextID;
//					while (preID != pre)
//					{
//						BvioTWCus[preID] = BvioTWCus[id] + vioTWCus[preID];
//						id = preID; preID = predArr[id];
//					}
//					//update BCAP from pre to firstCus
//					while (preID > 0)
//					{
//						BvioTWCus[preID] = BvioTWCus[id] + vioTWCus[preID];
//						BCAP[preID] += capDELTA;
//						id = preID; preID = predArr[id];
//					}
//				}
//
//				//update FCAP, FvioTWCus from nextID to lastCus: 
//				id = nextID; preID = predArr[nextID];
//				do
//				{
//					FvioTWCus[id] = FvioTWCus[preID] + vioTWCus[id];
//					FCAP[id] += capDELTA; 
//					preID = id; id = nextArr[id];
//				}while (id > 0);
//				//preID now points to the last cus
//				varvioTWC = FvioTWCus[preID] - seg[idVeh].Trip[idTrip].vioTWC; 
//				seg[idVeh].Trip[idTrip].vioTWC = FvioTWCus[preID];
//				goto UpdateNC; //not changed: endS, ...
//			}
//			temp = cStartS - problem->node[nextID].eTW;
//			if (temp > eps)
//			{
//				if (vioTWCus[nextID] > eps) 
//				{
//					vioTWCus[nextID] = temp;
//					//Update BvioTWCus from nextID to firstCus
//					//Update BCAP from pre to firstCus (pre may < 0) 
//					//Update FCAP, FvioTWCus from nextID to lastCus //don't need to update pos
//					id = nextArr[nextID];
//					if (id < 0) BvioTWCus[nextID] = vioTWCus[nextID];
//					else BvioTWCus[nextID] = BvioTWCus[id] + vioTWCus[nextID];
//					if (pre < 0) //dont need to update BCAP
//					{
//						id = nextID; 
//						while (preID > 0)
//						{
//							BvioTWCus[preID] = BvioTWCus[id] + vioTWCus[preID];
//							id = preID; preID = predArr[preID];
//						}
//					}
//					else
//					{
//						id = nextID;
//						while (preID != pre)
//						{
//							BvioTWCus[preID] = BvioTWCus[id] + vioTWCus[preID];
//							id = preID; preID = predArr[id];
//						}
//						//update BCAP from pre to firstCus
//						while (preID > 0)
//						{
//							BvioTWCus[preID] = BvioTWCus[id] + vioTWCus[preID];
//							BCAP[preID] += capDELTA;
//							id = preID; preID = predArr[id];
//						}
//					}
//
//					//update FCAP, FvioTWCus from nextID to lastCus: 
//					id = nextID; preID = predArr[nextID];
//					do
//					{
//						FvioTWCus[id] = FvioTWCus[preID] + vioTWCus[id];
//						FCAP[id] += capDELTA; 
//						preID = id; id = nextArr[id];
//					}while (id > 0);
//
//					//preID now points to the last cus
//					varvioTWC = FvioTWCus[preID] - seg[idVeh].Trip[idTrip].vioTWC;
//					seg[idVeh].Trip[idTrip].vioTWC = FvioTWCus[preID];
//					goto UpdateNC; //not changed: endS, ...
//				}
//				vioTWCus[nextID] = temp;
//				FvioTWCus[nextID] = FvioTWCus[preID] + temp;
//				cStartS = problem->node[nextID].eTW;
//			}
//			else 
//			{
//				vioTWCus[nextID] = 0;
//				FvioTWCus[nextID] = FvioTWCus[preID];
//			}
//			startS[nextID] = cStartS;
//			cStartS += problem->node[nextID].duration;
//			depart[nextID] = cStartS;
//			FCAP[nextID] += capDELTA;
//			preID = nextID; nextID = nextArr[nextID];
//		}//end while (nextID > 0)
//
//		seg[idVeh].Trip[idTrip].endS = cStartS;
//		varvioTWC = FvioTWCus[preID] - seg[idVeh].Trip[idTrip].vioTWC;
//		seg[idVeh].Trip[idTrip].vioTWC = FvioTWCus[preID];
//		//preID now points to the last cus:
//		//Update BCAP from pre to firstCus
//		//Update BvioTWCus from lastCus to firstCus
//		BvioTWCus[preID] = vioTWCus[preID];
//		if (pre < 0) //don't need to update BCAP:
//		{
//			id = predArr[preID];
//			while (id > 0)
//			{
//				BvioTWCus[id] = BvioTWCus[preID] + vioTWCus[id];
//				preID = id; id = predArr[preID];
//			}
//		}
//		else
//		{
//			id = predArr[preID];
//			while (id != pre) 
//			{
//				BvioTWCus[id] = BvioTWCus[preID] + vioTWCus[id];
//				preID = id; id = predArr[id];
//			}
//			while (id > 0)
//			{
//				BvioTWCus[id] = BvioTWCus[preID] + vioTWCus[id];
//				BCAP[id] += capDELTA;
//				preID = id; id = predArr[id];
//			}
//		}
//	}//end else not (idTrip == 0 && seg[idVeh].Trip[idTrip].numCus == 1)
//
//	if (seg[idVeh].Trip[idTrip].waitingS == NO_WS)
//			varcost -= problem->c[lastCOLD][assSP];
//	else varcost -= problem->disCWSSP[lastCOLD][assSP];
//
//	UpdateChangeCONNECTAtSP_PickTrip(idVeh, idTrip, varcost, varcostpreT, varvioTWC, varvioCAP, seg[idVeh].numTrips - 1); 
//	return;
//
//UpdateNC: //not changed: endS, ...
//		double varFIT = varcost + VTWCUS * varvioTWC + VCAP * varvioCAP;
//		seg[idVeh].Trip[idTrip].cost += varcost;
//		if (seg[idVeh].Trip[idTrip].vioCAP > 0 || seg[idVeh].Trip[idTrip].vioTWC > eps || seg[idVeh].Trip[idTrip].vioTWSP > eps)
//		{
//			seg[idVeh].Trip[idTrip].feasible = 0;
//			seg[idVeh].Trip[idTrip].fitness += varFIT;
//		}
//		else
//		{
//			seg[idVeh].Trip[idTrip].feasible = 1;
//			seg[idVeh].Trip[idTrip].fitness = seg[idVeh].Trip[idTrip].cost;
//		}
//		double varC = varcost + varcostpreT;
//		varFIT += varcostpreT;
//		seg[idVeh].cost += varC; seg[idVeh].fitness += varFIT; 
//		seg[idVeh].vioTWC += varvioTWC; seg[idVeh].vioCAP += varvioCAP;
//		cost += varC; fitness += varFIT;vioTWC += varvioTWC; vioCAP += varvioCAP;
//
//}
//
//
//
//void Solution::replaceCusPTrip(int pre, int IDReplaced, int suc, int IDinsert, int lastCOLD, int idVeh, int idTrip, int update_idTrip)
//{
//	//see on 2/12/2013
//	//insert IDinsert between pre and suc (delete the cus between pre and suc): if pre < 0 that means insert IDinsert at the beginning of the trip 
//    //then update remaining trips till update_idTrip in the vehicle idVeh
//    //COPY replaceCusPTrip: dif is that only update trips till update_idTrip rather than all remaining trips
//
//	route_num[IDinsert] = idVeh; trip_num[IDinsert] = idTrip;
//	predArr[IDinsert] = pre; nextArr[IDinsert] = suc; 
//
//	double cStartS, varcost, varcostpreT = 0;
//	int assSP = seg[idVeh].Trip[idTrip].assSP; 
//	double varvioTWC = 0;
//	int varvioCAP = 0;
//
//
//	if (idTrip == 0 && seg[idVeh].Trip[idTrip].numCus == 1)
//	{
//		pos[IDinsert] = 1;
//		startS[IDinsert] = problem->startSOneP[IDinsert][assSP];
//		depart[IDinsert] = startS[IDinsert] + problem->node[IDinsert].duration;
//		vioTWCus[IDinsert] = 0; FvioTWCus[IDinsert] = 0; BvioTWCus[IDinsert] = 0;
//		seg[idVeh].Trip[0].capacity = problem->node[IDinsert].capacity;
//		FCAP[IDinsert] = problem->node[IDinsert].capacity;
//		BCAP[IDinsert] = problem->node[IDinsert].capacity;
//		seg[idVeh].Trip[0].endS = depart[IDinsert];
//		seg[idVeh].Trip[0].firstCus = IDinsert;
//		seg[idVeh].Trip[0].lastCus = IDinsert;
//		//dont need varvioTWC
//		varcost = problem->c[0][IDinsert] - problem->c[0][IDReplaced];
//	}
//	else
//	{
//		int nextID, preID;
//		//cout<<"pre = "<<pre<<"; suc = "<<suc<<endl;
//		if (pre < 0) //Replace the first cus
//		{
//			pos[IDinsert] = 1;
//			seg[idVeh].Trip[idTrip].firstCus = IDinsert;
//			if (idTrip == 0) //replace the first cus of first trip
//			{
//				preID = 0;cStartS = 0; 
//				varcost = problem->c[0][IDinsert] - problem->c[0][IDReplaced];
//			}
//			else //replace the first cus of middle/last trip
//			{
//				int preT = idTrip - 1;
//				if (seg[idVeh].Trip[preT].Type == 0)
//				{
//					preID = seg[idVeh].Trip[preT].assSP;
//					cStartS = seg[idVeh].Trip[preT].leaveSP;
//				}
//				else
//				{
//					preID = seg[idVeh].Trip[preT].lastCus;
//					cStartS = depart[preID];
//				}
//				varcost = 0;
//				varcostpreT = problem->c[preID][IDinsert] - problem->c[preID][IDReplaced];
//				seg[idVeh].Trip[preT].connectCost = problem->c[preID][IDinsert];
//				seg[idVeh].Trip[preT].cost += varcostpreT;
//				seg[idVeh].Trip[preT].fitness += varcostpreT;
//			}//end delete the first cus of middle/last trip
//			if (suc > 0)
//			{
//				varcost += (problem->c[IDinsert][suc] - problem->c[IDReplaced][suc]);
//				BCAP[IDinsert] = BCAP[suc] + problem->node[IDinsert].capacity;
//				predArr[suc] = IDinsert;
//			}
//			else
//			{
//				seg[idVeh].Trip[idTrip].lastCus = IDinsert;
//				BCAP[IDinsert] = problem->node[IDinsert].capacity;
//			}
//		}
//		else //replace the middle/last cus
//		{
//			pos[IDinsert] = pos[pre] + 1;
//			nextArr[pre] = IDinsert; preID = pre;
//			//cout<<"pre = "<<pre<<"; nextArr["<<pre<<"] = "<<nextArr[pre]<<endl;
//			if (suc > 0) //delete the middle cus
//			{
//				predArr[suc] = IDinsert;
//				cStartS = depart[pre]; 
//				varcost = (problem->c[pre][IDinsert] + problem->c[IDinsert][suc]) - (problem->c[pre][IDReplaced] + problem->c[IDReplaced][suc]);
//				BCAP[IDinsert] = BCAP[suc] + problem->node[IDinsert].capacity;
//			}
//			else //replace the lastcus
//			{
//				seg[idVeh].Trip[idTrip].lastCus = IDinsert;
//				varcost = problem->c[pre][IDinsert] - problem->c[pre][IDReplaced];
//				cStartS = depart[pre];
//				BCAP[IDinsert] = problem->node[IDinsert].capacity;
//			}//end replace the lastCus
//		}//end replace the middle/last cus
//
//	//1. Update capacity, numCus, vio_CAP
//	int capDELTA = problem->node[IDinsert].capacity - problem->node[IDReplaced].capacity;
//	seg[idVeh].Trip[idTrip].capacity += capDELTA;
//	int vioCAPNEW = PDS_MAX(seg[idVeh].Trip[idTrip].capacity - problem->Q,0);
//	varvioCAP = vioCAPNEW - seg[idVeh].Trip[idTrip].vioCAP;
//	seg[idVeh].Trip[idTrip].vioCAP = vioCAPNEW;
//		
//	
//	int nextTrip = idTrip + 1;
//	double temp, cArrTime;
//	int id;
//
//		//Check at IDinsert
//		cArrTime = cStartS + problem->c[preID][IDinsert];
//		temp = cArrTime - problem->node[IDinsert].eTW;
//		if (temp > eps) 
//		{
//			vioTWCus[IDinsert] = temp;
//			if (pre > 0)
//			{
//				FvioTWCus[IDinsert] = FvioTWCus[preID] + temp;
//				FCAP[IDinsert] = FCAP[preID] + problem->node[IDinsert].capacity;
//			}
//			else 
//			{
//				FvioTWCus[IDinsert] = temp;
//				FCAP[IDinsert] = problem->node[IDinsert].capacity;
//			}
//			startS[IDinsert] = problem->node[IDinsert].eTW;
//			depart[IDinsert] = problem->node[IDinsert].depart;
//		}
//		else 
//		{
//			vioTWCus[IDinsert] = 0;
//			if (pre > 0)
//			{
//				FvioTWCus[IDinsert] = FvioTWCus[preID];
//				FCAP[IDinsert] = FCAP[preID] + problem->node[IDinsert].capacity;
//			}
//			else 
//			{
//				FvioTWCus[IDinsert] = 0;
//				FCAP[IDinsert] = problem->node[IDinsert].capacity;
//			}
//			startS[IDinsert] = PDS_MAX(cArrTime, problem->node[IDinsert].sTW);
//			depart[IDinsert] = startS[IDinsert] + problem->node[IDinsert].duration;
//		}
//		
//		cStartS = depart[IDinsert];
//		preID = IDinsert; nextID = suc;
//		while (nextID > 0)
//		{
//				cArrTime = cStartS + problem->c[preID][nextID]; //arrTime at customer nextID
//				cStartS = PDS_MAX(cArrTime, problem->node[nextID].sTW);
//				if (PDSDIF(cStartS, startS[nextID]) == 0) //it means varvioTWCus[nextID] = 0 if (cStartS != node[nextID].eTW)
//				{
//					temp = cStartS - problem->node[nextID].eTW;
//					if (temp > eps) vioTWCus[nextID] = temp;
//					else vioTWCus[nextID] = 0;
//					//Update BvioTWCus from nextID to firstCus
//					//Update BCAP from pre to firstCus (pre may < 0) 
//					//Update FCAP, FvioTWCus from nextID to lastCus //don't need to update pos
//					id = nextArr[nextID];
//					if (id < 0) BvioTWCus[nextID] = vioTWCus[nextID];
//					else BvioTWCus[nextID] = BvioTWCus[id] + vioTWCus[nextID];
//					if (pre < 0) //dont need to update BCAP
//					{
//						id = nextID; 
//						while (preID > 0)
//						{
//							BvioTWCus[preID] = BvioTWCus[id] + vioTWCus[preID];
//							id = preID; preID = predArr[preID];
//						}
//					}
//					else
//					{
//						id = nextID;
//						while (preID != pre)
//						{
//							BvioTWCus[preID] = BvioTWCus[id] + vioTWCus[preID];
//							id = preID; preID = predArr[id];
//						}
//						//update BCAP from pre to firstCus
//						while (preID > 0)
//						{
//							BvioTWCus[preID] = BvioTWCus[id] + vioTWCus[preID];
//							BCAP[preID] += capDELTA;
//							id = preID; preID = predArr[id];
//						}
//					}
//
//					//update FCAP, FvioTWCus from nextID to lastCus: 
//					id = nextID; preID = predArr[nextID];
//					do
//					{
//						FvioTWCus[id] = FvioTWCus[preID] + vioTWCus[id];
//						FCAP[id] += capDELTA; 
//						preID = id; id = nextArr[id];
//					}while (id > 0);
//					//preID now points to the last cus
//					varvioTWC = FvioTWCus[preID] - seg[idVeh].Trip[idTrip].vioTWC; 
//					seg[idVeh].Trip[idTrip].vioTWC = FvioTWCus[preID];
//					goto UpdateNC; //not changed: endS, ...
//				}
//				temp = cStartS - problem->node[nextID].eTW;
//				if (temp > eps)
//				{
//					if (vioTWCus[nextID] > eps) 
//					{
//						vioTWCus[nextID] = temp;
//						//Update BvioTWCus from nextID to firstCus
//						//Update BCAP from pre to firstCus (pre may < 0) 
//						//Update FCAP, FvioTWCus from nextID to lastCus //don't need to update pos
//						id = nextArr[nextID];
//						if (id < 0) BvioTWCus[nextID] = vioTWCus[nextID];
//						else BvioTWCus[nextID] = BvioTWCus[id] + vioTWCus[nextID];
//						if (pre < 0) //dont need to update BCAP
//						{
//							id = nextID; 
//							while (preID > 0)
//							{
//								BvioTWCus[preID] = BvioTWCus[id] + vioTWCus[preID];
//								id = preID; preID = predArr[preID];
//							}
//						}
//						else
//						{
//							id = nextID;
//							while (preID != pre)
//							{
//								BvioTWCus[preID] = BvioTWCus[id] + vioTWCus[preID];
//								id = preID; preID = predArr[id];
//							}
//							//update BCAP from pre to firstCus
//							while (preID > 0)
//							{
//								BvioTWCus[preID] = BvioTWCus[id] + vioTWCus[preID];
//								BCAP[preID] += capDELTA;
//								id = preID; preID = predArr[id];
//							}
//						}
//
//						//update FCAP, FvioTWCus from nextID to lastCus: 
//						id = nextID; preID = predArr[nextID];
//						do
//						{
//							FvioTWCus[id] = FvioTWCus[preID] + vioTWCus[id];
//							FCAP[id] += capDELTA; 
//							preID = id; id = nextArr[id];
//						}while (id > 0);
//
//						//preID now points to the last cus
//						varvioTWC = FvioTWCus[preID] - seg[idVeh].Trip[idTrip].vioTWC;
//						seg[idVeh].Trip[idTrip].vioTWC = FvioTWCus[preID];
//						goto UpdateNC; //not changed: endS, ...
//					}
//					vioTWCus[nextID] = temp;
//					FvioTWCus[nextID] = FvioTWCus[preID] + temp;
//					cStartS = problem->node[nextID].eTW;
//				}
//				else 
//				{
//					vioTWCus[nextID] = 0;
//					FvioTWCus[nextID] = FvioTWCus[preID];
//				}
//				startS[nextID] = cStartS;
//				cStartS += problem->node[nextID].duration;
//				depart[nextID] = cStartS;
//				FCAP[nextID] += capDELTA;
//				preID = nextID; nextID = nextArr[nextID];
//			}//end while (nextID > 0)
//			seg[idVeh].Trip[idTrip].endS = cStartS;
//			varvioTWC = FvioTWCus[preID] - seg[idVeh].Trip[idTrip].vioTWC;
//			seg[idVeh].Trip[idTrip].vioTWC = FvioTWCus[preID];
//			//preID now points to the last cus:
//			//Update BCAP from pre to firstCus
//			//Update BvioTWCus from lastCus to firstCus
//			BvioTWCus[preID] = vioTWCus[preID];
//			if (pre < 0) //don't need to update BCAP:
//			{
//				id = predArr[preID];
//				while (id > 0)
//				{
//					BvioTWCus[id] = BvioTWCus[preID] + vioTWCus[id];
//					preID = id; id = predArr[preID];
//				}
//			}
//			else
//			{
//				id = predArr[preID];
//				while (id != pre) 
//				{
//					BvioTWCus[id] = BvioTWCus[preID] + vioTWCus[id];
//					preID = id; id = predArr[id];
//				}
//				while (id > 0)
//				{
//					BvioTWCus[id] = BvioTWCus[preID] + vioTWCus[id];
//					BCAP[id] += capDELTA;
//					preID = id; id = predArr[id];
//				}
//			}
//	}
//
//	if (seg[idVeh].Trip[idTrip].waitingS == NO_WS)
//		varcost -= problem->c[lastCOLD][assSP];
//	else varcost -= problem->disCWSSP[lastCOLD][assSP];
//
//	UpdateChangeCONNECTAtSP_PickTrip(idVeh, idTrip, varcost, varcostpreT, varvioTWC, varvioCAP, update_idTrip); 
//	return;
//
//UpdateNC: //not changed: endS, ...
//		double varFIT = varcost + VTWCUS * varvioTWC + VCAP * varvioCAP;
//		seg[idVeh].Trip[idTrip].cost += varcost;
//		if (seg[idVeh].Trip[idTrip].vioCAP > 0 || seg[idVeh].Trip[idTrip].vioTWC > eps || seg[idVeh].Trip[idTrip].vioTWSP > eps)
//		{
//			seg[idVeh].Trip[idTrip].feasible = 0;
//			seg[idVeh].Trip[idTrip].fitness += varFIT;
//		}
//		else
//		{
//			seg[idVeh].Trip[idTrip].feasible = 1;
//			seg[idVeh].Trip[idTrip].fitness = seg[idVeh].Trip[idTrip].cost;
//		}
//		double varC = varcost + varcostpreT;
//		varFIT += varcostpreT;
//		seg[idVeh].cost += varC; seg[idVeh].fitness += varFIT; 
//		seg[idVeh].vioTWC += varvioTWC; seg[idVeh].vioCAP += varvioCAP;
//		cost += varC; fitness += varFIT;vioTWC += varvioTWC; vioCAP += varvioCAP;
//}
//
//
//void Solution::exchangeCusPTrip_OneVeh(int idCusj, int idTripj, int idCusi, int idTripi, int idVeh) //exchange cus idCusj on (idVeh, idTripj) with cus idCusi on (idVeh, idTripi) of the same vehicle idVeh
//{
//	//see on 2/12/2013
//	if (idTripi > idTripj)
//	{
//        int tt = idTripj; idTripj = idTripi; idTripi = tt;
//		tt = idCusj; idCusj = idCusi; idCusi = tt;
//	}
//	// idTripi is always before idTripj:
//	int prei = predArr[idCusi]; int suci = nextArr[idCusi]; int lastCOLDi = seg[idVeh].Trip[idTripi].lastCus;
//	int prej = predArr[idCusj]; int sucj = nextArr[idCusj]; int lastCOLDj = seg[idVeh].Trip[idTripj].lastCus;
//	//cout<<"prei = "<<prei<<", i = "<<idCusi<<", suci = "<<suci<<endl;
//	//cout<<"prej = "<<prej<<", j = "<<idCusj<<", sucj = "<<sucj<<endl;
//
//	int preTj = idTripj - 1; double endSOLD;
//	endSOLD = depart[seg[idVeh].Trip[preTj].lastCus];
//	replaceCusPTrip(prei,idCusi,suci, idCusj,lastCOLDi, idVeh, idTripi, preTj);
//
//	if (PDSDIF(endSOLD, depart[seg[idVeh].Trip[preTj].lastCus])) //there is a change
//		replaceCusPTrip_FromBeginning(prej,idCusj,sucj, idCusi,lastCOLDj, idVeh, idTripj);
//	else
//		replaceCusPTrip(prej,idCusj,sucj, idCusi,lastCOLDj, idVeh, idTripj, seg[idVeh].numTrips - 1);
//		
//	bool stop = checkVehicle(idVeh);
//	if (stop)
//	{
//		cout<<"STOP AT exchangeCusPTrip_OneVeh @IT = "<<IT<<endl;
//		exit(-1);
//	}
//}
//
//void Solution::exchangeCusPTrip_OneTrip(int i, int j, int idVeh, int idTrip)
//{
//	//see on 2/12/2013
//	    int assSP = seg[idVeh].Trip[idTrip].assSP; 
//		int lastCOLD = seg[idVeh].Trip[idTrip].lastCus;
//	    
//		int tt;
//		if (pos[i] > pos[j]) {tt=i;i=j;j=tt;} //swap i and j so that i is before j
//		int prei = predArr[i]; int suci = nextArr[i];
//		int prej = predArr[j]; int sucj = nextArr[j];
//		int preID,nextID, id;
//		double FvioTWCusT; int FCAPT;
//		double cStartS, cArrTime, temp;
//		double varcost, varvioTWC, varcostpreT=0;
//		bool stop;
//
//		tt = pos[i]; pos[i] = pos[j]; pos[j] = tt;
//
//		if (prei > 0) 
//		{
//			cStartS = depart[prei]; preID = prei;
//			FvioTWCusT = FvioTWCus[prei]; FCAPT = FCAP[prei];
//			nextArr[prei]=j;predArr[j]=prei;
//			varcost = problem->c[prei][j] - problem->c[prei][i];
//		}
//		else //i is the first cus
//		{
//			seg[idVeh].Trip[idTrip].firstCus = j;
//			FvioTWCusT = 0; FCAPT = 0;
//			predArr[j] = -1; 
//			if (idTrip == 0)
//			{
//				preID = 0;
//				cStartS = 0;
//				varcost = problem->c[0][j] - problem->c[0][i];
//			}
//			else
//			{
//				int preT = idTrip - 1;
//				if (seg[idVeh].Trip[preT].Type == 0)
//				{
//					preID = seg[idVeh].Trip[preT].assSP;
//					cStartS = seg[idVeh].Trip[preT].leaveSP;
//				}
//				else
//				{
//					preID = seg[idVeh].Trip[preT].lastCus;
//					cStartS = depart[preID];
//				}
//				varcostpreT = -seg[idVeh].Trip[preT].connectCost;
//				seg[idVeh].Trip[preT].connectCost = problem->c[preID][j];
//				varcostpreT += seg[idVeh].Trip[preT].connectCost;
//				seg[idVeh].Trip[preT].cost += varcostpreT;
//				seg[idVeh].Trip[preT].fitness += varcostpreT;
//				varcost = 0;
//			}
//		}//end i is the first cus
//		
//		//Check at j:
//		cArrTime = cStartS + problem->c[preID][j];
//		temp = cArrTime - problem->node[j].eTW;
//		if (temp > eps) 
//		{
//			vioTWCus[j] = temp;
//			FvioTWCus[j] = FvioTWCusT + temp;
//			startS[j] = problem->node[j].eTW;
//			depart[j] = problem->node[j].depart;
//		}
//		else 
//		{
//            vioTWCus[j] = 0;
//			FvioTWCus[j] = FvioTWCusT;
//			startS[j] = PDS_MAX(problem->node[j].sTW, cArrTime);
//			depart[j] = startS[j] + problem->node[j].duration;
//		}
//		cStartS = depart[j];
//		FCAP[j] = FCAPT + problem->node[j].capacity;
//
//		if (i != prej)
//		{
//			varcost += (problem->c[j][suci] + problem->c[prej][i] + problem->c[i][sucj])
//				   -(problem->c[i][suci] + problem->c[prej][j] + problem->c[j][sucj]);
//			preID = j; nextID = suci;
//			while (nextID != j)
//			{
//				cArrTime = cStartS + problem->c[preID][nextID];
//				temp = cArrTime - problem->node[nextID].eTW;
//				if (temp > eps)
//				{
//					vioTWCus[nextID] = temp;
//					FvioTWCus[nextID] = FvioTWCus[preID] + temp;
//					startS[nextID] = problem->node[nextID].eTW;
//					depart[nextID] = problem->node[nextID].depart;
//				}
//				else
//				{
//					vioTWCus[nextID] = 0;
//					FvioTWCus[nextID] = FvioTWCus[preID];
//					startS[nextID] = PDS_MAX(cArrTime, problem->node[nextID].sTW);
//					depart[nextID] = startS[nextID] + problem->node[nextID].duration;
//				}
//				cStartS = depart[nextID];
//				FCAP[nextID] = FCAP[preID] + problem->node[nextID].capacity;
//				preID = nextID; nextID = nextArr[nextID];
//			}
//			//nextID now points to j; preID points to prej
//			nextArr[j] = suci; predArr[suci] = j;
//			nextArr[prej] = i; predArr[i] = prej;
//
//			//Check at i:
//			cArrTime = cStartS + problem->c[prej][i];
//			temp = cArrTime - problem->node[i].eTW;
//			if (temp > eps)
//			{
//				vioTWCus[i] = temp;
//				FvioTWCus[i] = FvioTWCus[prej] + temp;
//				startS[i] = problem->node[i].eTW;
//				depart[i] = problem->node[i].depart;
//			}
//			else
//			{
//				vioTWCus[i] = 0;
//				FvioTWCus[i] = FvioTWCus[prej];
//				startS[i] = PDS_MAX (cArrTime, problem->node[i].sTW);
//				depart[i] = startS[i] + problem->node[i].duration;
//			}
//			cStartS = depart[i];
//			FCAP[i] = FCAP[prej] + problem->node[i].capacity;
//		}
//		else  // prei - i  -  j  -  sucj
//		{
//			varcost += (problem->c[i][sucj] - problem->c[j][sucj]);
//			nextArr[j] = i; predArr[i] = j;
//			//Check at i:
//			cArrTime = cStartS + problem->c[j][i];
//			temp = cArrTime - problem->node[i].eTW;
//			if (temp > eps)
//			{
//				vioTWCus[i] = temp;
//				FvioTWCus[i] = FvioTWCus[j] + temp;
//				startS[i] = problem->node[i].eTW;
//				depart[i] = problem->node[i].depart;
//			}
//			else
//			{
//				vioTWCus[i] = 0;
//				FvioTWCus[i] = FvioTWCus[j];
//				startS[i] = PDS_MAX (cArrTime, problem->node[i].sTW);
//				depart[i] = startS[i] + problem->node[i].duration;
//			}
//			cStartS = depart[i];
//			FCAP[i] = FCAP[j] + problem->node[i].capacity;
//		} //end prei - i  -  j  -  sucj
//
//		//Check from i till the end of the trip:
//		nextArr[i] = sucj;
//		if (sucj > 0)
//		{
//			predArr[sucj] = i;
//			preID = i; nextID = nextArr[i];
//			while (nextID > 0)
//			{
//				cArrTime = cStartS + problem->c[preID][nextID]; //arrTime at customer nextID
//				cStartS = PDS_MAX(cArrTime, problem->node[nextID].sTW);
//				if (PDSDIF(cStartS, startS[nextID]) == 0) //it means varvioTWCus[nextID] = 0 if (cStartS != node[nextID].eTW)
//				{
//					temp = cStartS - problem->node[nextID].eTW;
//					if (temp > eps) vioTWCus[nextID] = temp;
//					else vioTWCus[nextID] = 0;
//					//Update BvioTWCus from nextID to firstCus
//					//Update BCAP from i to j 
//					//Update FCAP, FvioTWCus from nextID to lastCus 
//					
//					id = nextArr[nextID];
//					if (id < 0) BvioTWCus[nextID] = vioTWCus[nextID];
//					else BvioTWCus[nextID] = BvioTWCus[id] + vioTWCus[nextID];
//					id = nextID;
//					while (preID != i)
//					{
//						BvioTWCus[preID] = BvioTWCus[id] + vioTWCus[preID];
//						id = preID; preID = predArr[preID];
//					}
//					//Update at i:
//					BvioTWCus[preID] = BvioTWCus[id] + vioTWCus[preID];
//					BCAP[preID] = BCAP[id] + problem->node[i].capacity;
//					preID = predArr[i]; id = i;
//					while (preID != j)
//					{
//						BvioTWCus[preID] = BvioTWCus[id] + vioTWCus[preID];
//						BCAP[preID] = BCAP[id] + problem->node[preID].capacity;
//						id = preID; preID = predArr[preID];
//					}
//					//Update at j:
//					BvioTWCus[preID] = BvioTWCus[id] + vioTWCus[preID];
//					BCAP[preID] = BCAP[id] + problem->node[j].capacity;
//					preID = predArr[j]; id = j;
//					while (preID > 0)
//					{
//						BvioTWCus[preID] = BvioTWCus[id] + vioTWCus[preID];
//						id = preID; preID = predArr[id];
//					}
//					//update FvioTWCus from nextID to lastCus: 
//					id = nextID; preID = predArr[nextID];
//					do
//					{
//						FvioTWCus[id] = FvioTWCus[preID] + vioTWCus[id];
//						preID = id; id = nextArr[id];
//					}while (id > 0);
//					//preID now points to the last cus
//					varvioTWC = FvioTWCus[preID] - seg[idVeh].Trip[idTrip].vioTWC; 
//					seg[idVeh].Trip[idTrip].vioTWC = FvioTWCus[preID];
//					goto UpdateNC; //not changed: endS, ...
//				}
//				temp = cStartS - problem->node[nextID].eTW;
//				if (temp > eps)
//				{
//					if (vioTWCus[nextID] > eps) 
//					{
//						vioTWCus[nextID] = temp;
//						//Update BvioTWCus from nextID to firstCus
//						//Update BCAP from i to j 
//						//Update FCAP, FvioTWCus from nextID to lastCus 
//						
//						id = nextArr[nextID];
//						if (id < 0) BvioTWCus[nextID] = vioTWCus[nextID];
//						else BvioTWCus[nextID] = BvioTWCus[id] + vioTWCus[nextID];
//						id = nextID;
//						while (preID != i)
//						{
//							BvioTWCus[preID] = BvioTWCus[id] + vioTWCus[preID];
//							id = preID; preID = predArr[preID];
//						}
//						//Update at i:
//						BvioTWCus[preID] = BvioTWCus[id] + vioTWCus[preID];
//						BCAP[preID] = BCAP[id] + problem->node[i].capacity;
//						preID = predArr[i]; id = i;
//						while (preID != j)
//						{
//							BvioTWCus[preID] = BvioTWCus[id] + vioTWCus[preID];
//							BCAP[preID] = BCAP[id] + problem->node[preID].capacity;
//							id = preID; preID = predArr[preID];
//						}
//						//Update at j:
//						BvioTWCus[preID] = BvioTWCus[id] + vioTWCus[preID];
//						BCAP[preID] = BCAP[id] + problem->node[j].capacity;
//						preID = predArr[j]; id = j;
//						while (preID > 0)
//						{
//							BvioTWCus[preID] = BvioTWCus[id] + vioTWCus[preID];
//							id = preID; preID = predArr[id];
//						}
//						//update FvioTWCus from nextID to lastCus: 
//						id = nextID; preID = predArr[nextID];
//						do
//						{
//							FvioTWCus[id] = FvioTWCus[preID] + vioTWCus[id];
//							preID = id; id = nextArr[id];
//						}while (id > 0);
//						//preID now points to the last cus
//						varvioTWC = FvioTWCus[preID] - seg[idVeh].Trip[idTrip].vioTWC; 
//						seg[idVeh].Trip[idTrip].vioTWC = FvioTWCus[preID];
//						goto UpdateNC; //not changed: endS, ...
//					}
//					vioTWCus[nextID] = temp;
//					FvioTWCus[nextID] = FvioTWCus[preID] + temp;
//					cStartS = problem->node[nextID].eTW;
//				}
//				else 
//				{
//					vioTWCus[nextID] = 0;
//					FvioTWCus[nextID] = FvioTWCus[preID];
//				}
//				startS[nextID] = cStartS;
//				cStartS += problem->node[nextID].duration;
//				depart[nextID] = cStartS; //dont need to update FCAP
//				preID = nextID; nextID = nextArr[nextID];
//			}//end while (nextID > 0)
//			seg[idVeh].Trip[idTrip].endS = cStartS;
//			varvioTWC = FvioTWCus[preID] - seg[idVeh].Trip[idTrip].vioTWC;
//			seg[idVeh].Trip[idTrip].vioTWC = FvioTWCus[preID];
//			//preID now points to the last cus:
//			//Update BCAP from i to j
//			//Update BvioTWCus from lastCus to firstCus
//			BvioTWCus[preID] = vioTWCus[preID];
//			id = predArr[preID];
//			while (id != i)
//			{
//				BvioTWCus[id] = BvioTWCus[preID] + vioTWCus[id];
//				preID = id; id = predArr[id];
//			}
//			do
//			{
//				BvioTWCus[id] = BvioTWCus[preID] + vioTWCus[id];
//				BCAP[id] = BCAP[preID] + problem->node[id].capacity;
//				preID = id; id = predArr[id];
//			}while (id != j);
//			//Update at j:
//			BvioTWCus[j] = BvioTWCus[preID] + vioTWCus[j];
//			BCAP[j] = BCAP[preID] + problem->node[j].capacity;
//			preID = predArr[j]; id = j;
//			while (preID > 0)
//			{
//				BvioTWCus[preID] = BvioTWCus[id] + vioTWCus[preID];
//				id = preID; preID = predArr[preID];
//			}
//		}
//		else // i is now the last cus of trip:
//		{
//			seg[idVeh].Trip[idTrip].lastCus = i;
//			seg[idVeh].Trip[idTrip].endS = cStartS;
//			varvioTWC = FvioTWCus[i] - seg[idVeh].Trip[idTrip].vioTWC;
//			seg[idVeh].Trip[idTrip].vioTWC = FvioTWCus[i];
//
//			//Update BvioTWCus from lastcus to firstcus
//			//Update BCAP from i to j
//			BvioTWCus[i] = vioTWCus[i];
//			BCAP[i] = problem->node[i].capacity;
//			preID = predArr[i]; nextID = i;
//			while (preID != j)
//			{
//				BvioTWCus[preID] = BvioTWCus[nextID] + vioTWCus[preID];
//				BCAP[preID] = BCAP[nextID] + problem->node[preID].capacity;
//				nextID = preID; preID = predArr[preID];
//			}
//			//Update at j:
//			BvioTWCus[j] = BvioTWCus[nextID] + vioTWCus[j];
//			BCAP[j] = BCAP[nextID] + problem->node[j].capacity;
//			preID = predArr[j]; nextID = j;
//			while (preID > 0)
//			{
//				BvioTWCus[preID] = BvioTWCus[nextID] + vioTWCus[preID];
//				nextID = preID; preID = predArr[preID];
//			}
//		} //end i is now the last cus of trip
//		
//		if (seg[idVeh].Trip[idTrip].waitingS == NO_WS)
//			varcost -= problem->c[lastCOLD][assSP];
//		else varcost -= problem->disCWSSP[lastCOLD][assSP];
//		UpdateChangeCONNECTAtSP_PickTrip(idVeh, idTrip, varcost, varcostpreT, varvioTWC, 0, seg[idVeh].numTrips - 1); //varvioCAP = 0 
//
//		stop = checkVehicle(idVeh);
//		if (stop)
//		{
//			cout<<"CASE2 CHANGED: STOP AT exchangeCusPTrip_OneTrip @IT = "<<IT<<endl;
//			exit(-1);
//		}
//		return;
//
//UpdateNC: //not changed: endS, ...
//		double varFIT = varcost + VTWCUS * varvioTWC;
//		seg[idVeh].Trip[idTrip].cost += varcost;
//		if (seg[idVeh].Trip[idTrip].vioCAP > 0 || seg[idVeh].Trip[idTrip].vioTWC > eps || seg[idVeh].Trip[idTrip].vioTWSP > eps)
//		{
//			seg[idVeh].Trip[idTrip].feasible = 0;
//			seg[idVeh].Trip[idTrip].fitness += varFIT;
//		}
//		else
//		{
//			seg[idVeh].Trip[idTrip].feasible = 1;
//			seg[idVeh].Trip[idTrip].fitness = seg[idVeh].Trip[idTrip].cost;
//		}
//		varcost += varcostpreT;
//		varFIT += varcostpreT;
//		//don't have varvioCAP
//		seg[idVeh].cost += varcost; seg[idVeh].fitness += varFIT; seg[idVeh].vioTWC += varvioTWC; 
//		cost += varcost; fitness += varFIT;vioTWC += varvioTWC; 
//		stop = checkVehicle(idVeh);
//		if (stop)
//		{
//			cout<<"CASE NOT CHANGE: STOP AT exchangeCusPTrip_OneTrip @IT = "<<IT<<endl;
//			exit(-1);
//		}
//
//}
//
//void Solution::twoOPTstarCusPTrip_oneTrip(int j, int i, int idVeh, int idTrip)
//{
//	//see on 2/12/2013
//	 //posD[j] < posD[i] 
//	 int assSP = seg[idVeh].Trip[idTrip].assSP;
//
//	 int lastCOLD = seg[idVeh].Trip[idTrip].lastCus;
//	 int sucj = nextArr[j]; int prei = predArr[i];
//	 int suci = nextArr[i]; 
//
//	 int idpre,idcur,idTemp;
//	 double cArrTime, cStartS,temp;
//	 bool stop;
//
//	 double varcost = problem->c[j][i] - problem->c[j][sucj];
//
//	 cArrTime = depart[j] + problem->c[j][i];
//	 //Update i:
//	 temp = cArrTime - problem->node[i].eTW;
//	 pos[i] = pos[j] + 1;
//	 if (temp > eps)
//	 {
//		 vioTWCus[i] = temp;
//		 FvioTWCus[i] = FvioTWCus[j] + temp;
//		 startS[i] = problem->node[i].eTW;
//		 depart[i] = problem->node[i].depart;
//	 }
//	 else
//	 {
//		 startS[i] = PDS_MAX(cArrTime, problem->node[i].sTW);
//		 vioTWCus[i] = 0;
//		 FvioTWCus[i] = FvioTWCus[j];
//		 depart[i] = startS[i] + problem->node[i].duration;
//	 }
//	 cStartS = depart[i];
//     nextArr[j] = i; predArr[i] = j; 
//	 FCAP[i] = FCAP[j] + problem->node[i].capacity;
//
//	 idcur = i; idpre = prei;
//	 while (idpre != j) 
//	 {
//		   cArrTime = cStartS + problem->c[idcur][idpre];
//		   temp = cArrTime - problem->node[idpre].eTW;
//		   if (temp > eps)
//		   {
//			   startS[idpre] = problem->node[idpre].eTW;
//			   depart[idpre] = problem->node[idpre].depart;
//			   vioTWCus[idpre] = temp;
//			   FvioTWCus[idpre] = FvioTWCus[idcur] + temp;
//		   }
//		   else
//		   {
//			   startS[idpre] = PDS_MAX(cArrTime, problem->node[idpre].sTW);
//			   depart[idpre] = startS[idpre] + problem->node[idpre].duration;
//			   vioTWCus[idpre] = 0;
//			   FvioTWCus[idpre] = FvioTWCus[idcur];
//		   }
//		   cStartS = depart[idpre];
//		   FCAP[idpre] = FCAP[idcur] + problem->node[idpre].capacity;
//		   pos[idpre] = pos[idcur] + 1;
//		   idTemp = idpre; idpre = predArr[idpre];
//		   predArr[idTemp]=idcur; nextArr[idcur]=idTemp;
//		   idcur = idTemp;
//	  }
//	  nextArr[sucj]=suci;
//
//	  //now idpre is j; idcur is sucj
//	  //from sucj to suci:
//	  int nextTrip = idTrip + 1;
//	  int nextID, preID, id;
//	  double varvioTWC;
//	  if (suci > 0)
//	  {
//				varcost += (problem->c[sucj][suci] - problem->c[i][suci]);
//				//idcur is now sucj; check sucj-->suci & suci till the end of the leg:
//				predArr[suci] = sucj;
//				nextID = suci; preID = sucj; cStartS = depart[sucj];
//				while (nextID > 0)
//				{
//					cArrTime = cStartS + problem->c[preID][nextID]; //arrTime at customer nextID
//					cStartS = PDS_MAX(cArrTime, problem->node[nextID].sTW);
//            		if (PDSDIF(cStartS, startS[nextID])==0) //it means varvioTWCus[nextID]=0 
//					{
//						temp = cStartS - problem->node[nextID].eTW;
//						if (temp > eps) vioTWCus[nextID] = temp;
//						else vioTWCus[nextID] = 0;
//
//						//Update BvioTWCus from nextID to firstCus
//						//Update BCAP from sucj to i
//						//Update FvioTWCus from nextID to lastCus; DONT NEED TO UPDATE FCAP
//						id = nextArr[nextID];
//						if (id < 0) BvioTWCus[nextID] = vioTWCus[nextID];
//						else BvioTWCus[nextID] = BvioTWCus[id] + vioTWCus[nextID];
//
//						id = nextID;
//						while (preID != sucj)
//						{
//							BvioTWCus[preID] = BvioTWCus[id] + vioTWCus[preID];
//							id = preID; preID = predArr[id];
//						}
//
//						do
//						{
//							BvioTWCus[preID] = BvioTWCus[id] + vioTWCus[preID];
//							BCAP[preID] = BCAP[id] + problem->node[preID].capacity;
//							id = preID; preID = predArr[id];
//						}while (preID != j);
//						do
//						{
//							BvioTWCus[preID] = BvioTWCus[id] + vioTWCus[preID];
//							id = preID; preID = predArr[id];
//						}while (preID > 0);
//
//						//update FvioTWCus from nextID to lastCus:
//						id = nextID; preID = predArr[nextID];
//						do
//						{
//							FvioTWCus[id] = FvioTWCus[preID] + vioTWCus[id];
//							preID = id; id = nextArr[id];
//						}while (id > 0);
//						//preID now points to the last cus
//						varvioTWC = FvioTWCus[preID] - seg[idVeh].Trip[idTrip].vioTWC; 
//						seg[idVeh].Trip[idTrip].vioTWC = FvioTWCus[preID];
//						goto UpdateNC;
//					}
//					temp = cStartS - problem->node[nextID].eTW;
//					if (temp > eps)
//					{
//						if (vioTWCus[nextID] > eps) 
//						{
//							vioTWCus[nextID] = temp;
//							//Update BvioTWCus from nextID to firstCus
//							//Update BCAP from sucj to i
//							//Update FvioTWCus from nextID to lastCus; DONT NEED TO UPDATE FCAP
//							id = nextArr[nextID];
//							if (id < 0) BvioTWCus[nextID] = vioTWCus[nextID];
//							else BvioTWCus[nextID] = BvioTWCus[id] + vioTWCus[nextID];
//
//							id = nextID;
//							while (preID != sucj)
//							{
//								BvioTWCus[preID] = BvioTWCus[id] + vioTWCus[preID];
//								id = preID; preID = predArr[id];
//							}
//							do
//							{
//								BvioTWCus[preID] = BvioTWCus[id] + vioTWCus[preID];
//								BCAP[preID] = BCAP[id] + problem->node[preID].capacity;
//								id = preID; preID = predArr[id];
//							}while (preID != j);
//
//							do
//							{
//								BvioTWCus[preID] = BvioTWCus[id] + vioTWCus[preID];
//								id = preID; preID = predArr[id];
//							}while (preID > 0);
//
//							//Update FvioTWCus from nextID to lastCus
//							id = nextID; preID = predArr[nextID];
//							do
//							{
//								FvioTWCus[id] = FvioTWCus[preID] + vioTWCus[id];
//								preID = id; id = nextArr[id];
//							}while (id > 0);
//							//preID now points to the last cus
//							varvioTWC = FvioTWCus[preID] - seg[idVeh].Trip[idTrip].vioTWC;
//							seg[idVeh].Trip[idTrip].vioTWC = FvioTWCus[preID];
//							goto UpdateNC;
//						}
//						vioTWCus[nextID] = temp;
//						FvioTWCus[nextID] = FvioTWCus[preID] + temp;
//						cStartS = problem->node[nextID].eTW;
//					}
//					else 
//					{
//						vioTWCus[nextID] = 0;
//						FvioTWCus[nextID] = FvioTWCus[preID];
//					}
//					startS[nextID] = cStartS;
//					cStartS += problem->node[nextID].duration;
//					depart[nextID] = cStartS;
//					//FCAP[nextID] don't need to update FCAP
//					preID = nextID; nextID = nextArr[nextID];
//				}
//				seg[idVeh].Trip[idTrip].endS = cStartS;
//				varvioTWC = FvioTWCus[preID] - seg[idVeh].Trip[idTrip].vioTWC;
//				seg[idVeh].Trip[idTrip].vioTWC = FvioTWCus[preID];
//
//				//preID now points to the last cus:
//				//Update BCAP from sucj to i
//				//Update BvioTWCus from lastCus to firstCus
//				BvioTWCus[preID] = vioTWCus[preID];
//				id = predArr[preID];
//				while (id != sucj)
//				{
//					BvioTWCus[id] = BvioTWCus[preID] + vioTWCus[id];
//					preID = id; id = predArr[id];
//				}
//				do
//				{
//					BvioTWCus[id] = BvioTWCus[preID] + vioTWCus[id];
//					BCAP[id] = BCAP[preID] + problem->node[id].capacity;
//					preID = id; id = predArr[id];
//				}while (id != j);
//				do
//				{
//					BvioTWCus[id] = BvioTWCus[preID] + vioTWCus[id];
//					preID = id; id = predArr[id];
//				}while (id > 0);
//	  }
//	  else //i was the last cus --> sucj is now the last cus
//	  {
//			  seg[idVeh].Trip[idTrip].lastCus = sucj;
//			  seg[idVeh].Trip[idTrip].endS = depart[sucj];
//			  preID = sucj;
//			  varvioTWC = FvioTWCus[preID] - seg[idVeh].Trip[idTrip].vioTWC;
//              seg[idVeh].Trip[idTrip].vioTWC = FvioTWCus[preID];
//              //Update BvioTWCus from lastCus to firstCus
//			  //Update BCAP from lastCus to i
//			  BvioTWCus[preID] = vioTWCus[preID];
//			  BCAP[preID] = problem->node[sucj].capacity;
//			  id = predArr[preID];
//			  while (id != j)
//			  {
//					BvioTWCus[id] = BvioTWCus[preID] + vioTWCus[id];
//					BCAP[id] = BCAP[preID] + problem->node[id].capacity; //ok
//					preID = id; id = predArr[id];
//			 }
//			 do
//			 {
//					BvioTWCus[id] = BvioTWCus[preID] + vioTWCus[id];
//					preID = id; id = predArr[id];
//			 }while (id > 0);
//	  }//end i was the last cus --> sucj is now the last cus
//
//		if (seg[idVeh].Trip[idTrip].waitingS == NO_WS)
//			varcost -= problem->c[lastCOLD][assSP];
//		else varcost -= problem->disCWSSP[lastCOLD][assSP];
//		UpdateChangeCONNECTAtSP_PickTrip(idVeh, idTrip, varcost, 0, varvioTWC, 0, seg[idVeh].numTrips - 1); //varvioCAP = 0, varcostpreT = 0 
//
//		stop = checkVehicle(idVeh);
//		if (stop)
//		{
//			cout<<"CASE2 CHANGED: STOP AT twoOPTstarCusP_OneTrip @IT = "<<IT<<endl;
//			exit(-1);
//		}
//		return;
//
//
//UpdateNC: //not changed: endS, ...
//		double varFIT = varcost + VTWCUS * varvioTWC;
//		seg[idVeh].Trip[idTrip].cost += varcost;
//		if (seg[idVeh].Trip[idTrip].vioCAP > 0 || seg[idVeh].Trip[idTrip].vioTWC > eps || seg[idVeh].Trip[idTrip].vioTWSP > eps)
//		{
//			seg[idVeh].Trip[idTrip].feasible = 0;
//			seg[idVeh].Trip[idTrip].fitness += varFIT;
//		}
//		else
//		{
//			seg[idVeh].Trip[idTrip].feasible = 1;
//			seg[idVeh].Trip[idTrip].fitness = seg[idVeh].Trip[idTrip].cost;
//		}
//		//don't have varcostpreT
//		seg[idVeh].cost += varcost; seg[idVeh].fitness += varFIT; seg[idVeh].vioTWC += varvioTWC; 
//		cost += varcost; fitness += varFIT;vioTWC += varvioTWC; 
//		stop = checkVehicle(idVeh);
//		if (stop)
//		{
//			cout<<"CASE NOT CHANGE: STOP AT twoOPTstarCusPTrip_oneTrip @IT = "<<IT<<endl;
//			exit(-1);
//		}
//}
//
//
//void Solution::twoOPTstarCusPTrip(int j, int idVehj, int idTripj, int i, int idVehi, int idTripi) //2opt* between 2 customer j and its neighbor (i) where j and i belong to different trips
//{
//	//see on 2/12/2013
//	//April 17th: moi trip sau idTripj va idTripi can giu nguyen vehicle
//
//	 int assSPi = seg[idVehi].Trip[idTripi].assSP;
//	 int assSPj = seg[idVehj].Trip[idTripj].assSP;
//	 int lastCOLDi = seg[idVehi].Trip[idTripi].lastCus;
//	 int lastCOLDj = seg[idVehj].Trip[idTripj].lastCus;
//
//	 int sucj = nextArr[j]; int prei = predArr[i];
//	 bool emptyTripi=0;
//
//	 //1. vioCAP,capacity:
//	 int capj = FCAP[j] + BCAP[i];
//	 int capi=0; 
//	 if (prei > 0) capi = FCAP[prei];
//	 if (sucj > 0) capi += BCAP[sucj];
//	 
//	 seg[idVehi].Trip[idTripi].capacity = capi;
//	 int vioCAPNEW = PDS_MAX(capi - problem->Q, 0);
//	 int varvioCAPi = vioCAPNEW - seg[idVehi].Trip[idTripi].vioCAP;
//	 seg[idVehi].Trip[idTripi].vioCAP = vioCAPNEW;
//
//	 seg[idVehj].Trip[idTripj].capacity = capj;
//	 vioCAPNEW = PDS_MAX(capj - problem->Q, 0);
//	 int varvioCAPj = vioCAPNEW - seg[idVehj].Trip[idTripj].vioCAP;
//     seg[idVehj].Trip[idTripj].vioCAP = vioCAPNEW;
//	 
//	 double cArrTime, cStartSi, cStartS, temp, varvioTWC;
//     int fC,id,preID, nextID, curi, idnexti;
//
//	 //2. Update nextArr, predArr, firstCus, lastCus
//	 //For the trip contains j:
//	 nextArr[j] = i; predArr[i] = j;
//	 seg[idVehj].Trip[idTripj].lastCus = lastCOLDi;
//	 double varcostpreTi = 0;
//	
//	 //For the trip contained i before:
//	 if (prei > 0)
//	 {
//		 if (sucj > 0) 
//		 {
//			 nextArr[prei]=sucj;
//			 predArr[sucj]=prei;
//			 seg[idVehi].Trip[idTripi].lastCus = lastCOLDj;
//		 }
//		 else 
//		 {
//			 seg[idVehi].Trip[idTripi].lastCus = prei; 
//			 nextArr[prei]=-1;
//		 }
//		 cStartSi = depart[prei]; 
//		 curi=prei; idnexti=sucj;
//	 }
//	 else //i was the first customer of idTripi
//	 {
//		 if (sucj > 0) 
//		 {
//			 seg[idVehi].Trip[idTripi].firstCus = sucj; 
//			 idnexti = sucj;
//			 //pos[sucj] = 1;
//             predArr[sucj]=-1; 
//			 seg[idVehi].Trip[idTripi].lastCus = lastCOLDj;
//			 if (idTripi > 0)
//			 {
//				 int preT = idTripi - 1;
//				 if (seg[idVehi].Trip[preT].Type == 0)
//				 {
//					curi = seg[idVehi].Trip[preT].assSP;
//					cStartSi = seg[idVehi].Trip[preT].leaveSP;
//				}
//				else
//				{
//					curi = seg[idVehi].Trip[preT].lastCus;
//					cStartSi = depart[curi];
//				}
//				varcostpreTi = problem->c[curi][sucj] - seg[idVehi].Trip[preT].connectCost;
//				seg[idVehi].Trip[preT].connectCost = problem->c[curi][sucj];
//				seg[idVehi].Trip[preT].cost += varcostpreTi;
//				seg[idVehi].Trip[preT].fitness += varcostpreTi;
//			 }
//			 else
//			 {
//				 curi = 0;
//				 cStartSi = 0;
//			 }
//		 }
//		 else {emptyTripi=1; /*update_EmptyLeg(idVehi,idLegi);*///cout<<"EMPTY LEG ("<<idVehi<<", "<<idLegi<<")"<<endl;
//		      } //it is now the empty leg
//	 }
//
//	 int numCusjOLD = seg[idVehj].Trip[idTripj].numCus;
//	 int numCusi = seg[idVehi].Trip[idTripi].numCus;
//	 seg[idVehj].Trip[idTripj].numCus = pos[j] + (numCusi - pos[i] + 1);
//	 seg[idVehi].Trip[idTripi].numCus = numCusi + numCusjOLD - seg[idVehj].Trip[idTripj].numCus;
//	 
//     
//	 //Calculate cost from firstCus of idTripj to j:
//	 double COSTj; fC = seg[idVehj].Trip[idTripj].firstCus; int nextCC;
//
//	 if (idTripj == 0) COSTj = problem->c[0][fC];
//	 else COSTj = 0;
//	 
//	 if (sucj > 0)
//	 {
//		 while (fC != j)
//		 {
//			 nextCC = nextArr[fC];
//			 COSTj += problem->c[fC][nextCC];
//			 fC = nextCC;
//		 }
//	 }
//	 else 
//	 {
//		 COSTj = seg[idVehj].Trip[idTripj].cost - seg[idVehj].Trip[idTripj].connectCost;
//		 if (seg[idVehj].Trip[idTripj].waitingS == NO_WS)
//			 COSTj -= problem->c[lastCOLDj][assSPj];
//		 else COSTj -= problem->disCWSSP[lastCOLDj][assSPj];
//	 }
//	 //cout<<"COSTj = "<<COSTj<<endl;
//
//	 double COSTi=0;
//
//	 if (prei > 0)
//	 {
//		 fC = seg[idVehi].Trip[idTripi].firstCus;
//		 if (idTripi == 0) COSTi = problem->c[0][fC];
//		 while (fC != prei)
//		 {
//			 nextCC = nextArr[fC];
//			 COSTi += problem->c[fC][nextCC];
//			 fC = nextCC; nextCC = nextArr[nextCC];
//		 }
//	 }
// 
//	 //For the trip contain j:
//	 if (idTripj==0 && numCusjOLD == 1) //before j is the only one customer in the trip
//	 {
//		 startS[j] = PDS_MAX(problem->c[0][j], problem->node[j].sTW);
//		 depart[j] = startS[j] + problem->node[j].duration;
//		 //vioTWCus[j] = 0; FvioTWCus[j] = 0;
//	 }
//	 cStartS = depart[j]; preID = j; nextID = i;
//	 while (nextID > 0) 
//	 {
//		   cArrTime = cStartS + problem->c[preID][nextID];
//		   cStartS = PDS_MAX(cArrTime, problem->node[nextID].sTW);
//		   if (PDSDIF(cStartS, startS[nextID]) == 0) //it means varvioTWCus[nextID] = 0 
//		   {
//			   temp = cStartS - problem->node[nextID].eTW;
//			   if (temp > eps) vioTWCus[nextID] = temp;
//			   else vioTWCus[nextID] = 0;
//
//			   //Update BvioTWCus from nextID to firstCus
//				//Update BCAP from j to firstCus
//				//Update FCAP, FvioTWCus from nextID to lastCus
//				//Update trip_num, route_num from nextID to lastCus
//				//Update cost
//				id = nextArr[nextID];
//				if (id < 0) BvioTWCus[nextID] = vioTWCus[nextID];
//				else BvioTWCus[nextID] = BvioTWCus[id] + vioTWCus[nextID];
//
//			    id = nextID;
//			    while (preID != j)
//			    {
//				   BvioTWCus[preID] = BvioTWCus[id] + vioTWCus[preID];
//				   id = preID; preID = predArr[preID];
//			    }
//			   
//			   do
//			   {
//				   BvioTWCus[preID] = BvioTWCus[id] + vioTWCus[preID];
//				   BCAP[preID] = BCAP[id] + problem->node[preID].capacity;
//				   id = preID; preID = predArr[preID];
//			   }while (preID > 0);
//			   id = nextID; preID = predArr[id];
//			   do
//			   {
//				   route_num[id] = idVehj; trip_num[id] = idTripj;
//				   pos[id] = pos[preID] + 1;
//				   FCAP[id] = FCAP[preID] + problem->node[id].capacity;
//				   FvioTWCus[id] = FvioTWCus[preID] + vioTWCus[id];
//				   COSTj += problem->c[preID][id];
//				   //cout<<"["<<id<<"] = "<<COSTj<<", ";
//				   preID = id; id = nextArr[id];
//			   }while (id > 0);
//			   //preID now points to lastCus:
//			   varvioTWC = seg[idVehj].Trip[idTripj].vioTWC - FvioTWCus[preID];
//			   seg[idVehj].Trip[idTripj].vioTWC = FvioTWCus[preID];
//			   seg[idVehj].Trip[idTripj].endS = depart[preID];
//			   goto Updatej;
//		   }
//		   temp = cStartS - problem->node[nextID].eTW;
//		   if (temp > eps)
//		   {
//				if (vioTWCus[nextID] > eps) 
//				{
//					vioTWCus[nextID] = temp;
//					//Update BvioTWCus from nextID to firstCus
//					//Update BCAP from j to firstCus
//					//Update FCAP, FvioTWCus from nextID to lastCus
//					//Update trip_num, route_num fro nextID to lastCus
//					//Update cost
//					id = nextArr[nextID];
//					if (id < 0) BvioTWCus[nextID] = vioTWCus[nextID];
//					else BvioTWCus[nextID] = BvioTWCus[id] + vioTWCus[nextID];
//
//				    id = nextID;
//				    while (preID != j)
//				    {
//					   BvioTWCus[preID] = BvioTWCus[id] + vioTWCus[preID];
//					   id = preID; preID = predArr[preID];
//				    }
//				    do
//				    {
//					   BvioTWCus[preID] = BvioTWCus[id] + vioTWCus[preID];
//					   BCAP[preID] = BCAP[id] + problem->node[preID].capacity;
//					   id = preID; preID = predArr[preID];
//				    }while (preID > 0);
//				    id = nextID; preID = predArr[id];
//				    do
//				    {
//					   route_num[id] = idVehj; trip_num[id] = idTripj;
//					   pos[id] = pos[preID] + 1;
//					   FCAP[id] = FCAP[preID] + problem->node[id].capacity;
//					   FvioTWCus[id] = FvioTWCus[preID] + vioTWCus[id];
//					   COSTj += problem->c[preID][id];
//					   //cout<<"["<<id<<"] = "<<COSTj<<"; ";
//					   preID = id; id = nextArr[id];
//				    }while (id > 0);
//				    //preID now points to lastCus:
//				    varvioTWC = seg[idVehj].Trip[idTripj].vioTWC - FvioTWCus[preID];
//				    seg[idVehj].Trip[idTripj].vioTWC = FvioTWCus[preID];
//				    seg[idVehj].Trip[idTripj].endS = depart[preID];
//					goto Updatej;
//				}
//				vioTWCus[nextID] = temp;
//				FvioTWCus[nextID] = FvioTWCus[preID] + temp;
//				cStartS = problem->node[nextID].eTW;
//		   }
//		   else 
//		   {
//		   	  vioTWCus[nextID] = 0;
//			  FvioTWCus[nextID] = FvioTWCus[preID];
//		   }
//		   startS[nextID] = cStartS;
//		   cStartS += problem->node[nextID].duration;
//		   depart[nextID] = cStartS;
//		   FCAP[nextID] = FCAP[preID] + problem->node[nextID].capacity;
//		   pos[nextID] = pos[preID]+1;
//		   route_num[nextID] = idVehj; trip_num[nextID] = idTripj;
//		   COSTj += problem->c[preID][nextID];
//		   //cout<<"["<<nextID<<"] = "<<COSTj<<", ";
//		   preID = nextID; nextID = nextArr[nextID];
//	 }//end while (nextID > 0)
//	 //cout<<COSTj<<endl;
//	 seg[idVehj].Trip[idTripj].endS = cStartS;
//	 varvioTWC = FvioTWCus[preID] - seg[idVehj].Trip[idTripj].vioTWC;
//	 seg[idVehj].Trip[idTripj].vioTWC = FvioTWCus[preID];
//	//preID now points to the last cus:
//	 //Update BCAP from j to firstCus
//	 //Update BvioTWCus from lastCus to firstCus
//	 BvioTWCus[preID] = vioTWCus[preID];
//	 id = predArr[preID];
//	 while (id != j)
//	 {
//			BvioTWCus[id] = BvioTWCus[preID] + vioTWCus[id];
//			preID = id; id = predArr[id];
//	}
//	BvioTWCus[j] = BvioTWCus[preID] + vioTWCus[j];
//	BCAP[j] = BCAP[preID] + problem->node[j].capacity;
//	id = predArr[j]; preID = j;
//	while (id > 0)
//	{
//			BvioTWCus[id] = BvioTWCus[preID] + vioTWCus[id];
//			BCAP[id] = BCAP[preID] + problem->node[id].capacity;
//			preID = id; id = predArr[id];
//	}
//
//	Updatej:
//		UpdateChangeCONNECTAtSP_PickTrip(idVehj, idTripj, 0, varvioTWC, varvioCAPj, COSTj); //varcostpreT = 0
//
//   	 
//
//	  //17/11/2013: NOTE WHEN idTripi = 0 and has only 1 customer
//	  //For the trip contain i:
//	  if (!emptyTripi) //tripi is not the empty trip:
//	  {
//			 if (idTripi == 0 && seg[idVehi].Trip[idTripi].numCus == 1) //tripi is now the first trip and has only one customer
//			 {
//				int IDNEW = seg[idVehi].Trip[idTripi].firstCus;
//				pos[IDNEW] = 1;
//				startS[IDNEW] = problem->startSOneP[IDNEW][assSPi];
//				depart[IDNEW] = startS[IDNEW] + problem->node[IDNEW].duration;
//				vioTWCus[IDNEW] = 0; FvioTWCus[IDNEW] = 0; BvioTWCus[IDNEW] = 0;
//				seg[idVehi].Trip[0].capacity = problem->node[IDNEW].capacity;
//				FCAP[IDNEW] = problem->node[IDNEW].capacity;
//				BCAP[IDNEW] = problem->node[IDNEW].capacity;
//			    route_num[IDNEW] = idVehi; trip_num[IDNEW] = idTripi;
//				seg[idVehi].Trip[0].endS = depart[IDNEW];
//				varvioTWC = -seg[idVehi].Trip[0].vioTWC;
//				seg[idVehi].Trip[0].vioTWC = 0;
//				COSTi = problem->c[0][IDNEW];
//				//seg[idVehi].Trip[0].firstCus = sucj;
//				//seg[idVehi].Trip[0].lastCus = sucj;
//			 }
//			 else
//			 {
//				 preID = curi; nextID = idnexti; cStartS = cStartSi;
//				 if (prei < 0)
//				 {
//					 cArrTime = cStartS + problem->c[preID][nextID];
//					 cStartS = PDS_MAX(cArrTime, problem->node[nextID].sTW);
//					 temp = cStartS - problem->node[nextID].eTW;
//					 if (temp > eps)
//					 {
//						 vioTWCus[nextID] = temp;
//						 FvioTWCus[nextID] = temp;
//						 cStartS = problem->node[nextID].eTW;
//					 }
//					 else
//					 {
//						 vioTWCus[nextID] = 0;
//						 FvioTWCus[nextID] = 0;
//					 }
//					 startS[nextID] = cStartS;
//					 cStartS += problem->node[nextID].duration;
//					 depart[nextID] = cStartS;
//					 FCAP[nextID] = problem->node[nextID].capacity;
//					 route_num[nextID] = idVehi; trip_num[nextID] = idTripi;
//					 pos[nextID] = 1;
//					 //cout<<"pos["<<nextID<<"] = 1"<<endl;
//					 if (idTripi == 0) COSTi += problem->c[0][nextID];
//					 //COSTi += problem->c[preID][nextID];
//					 preID = nextID; nextID = nextArr[nextID];
//				 }
//
//				 while (nextID > 0) 
//				 {
//					   cArrTime = cStartS + problem->c[preID][nextID];
//					   cStartS = PDS_MAX(cArrTime, problem->node[nextID].sTW);
//					   if (PDSDIF(cStartS, startS[nextID])==0) //it means varvioTWCus[nextID] = 0 
//					   {
//						   temp = cStartS - problem->node[nextID].eTW;
//						   if (temp > eps) vioTWCus[nextID] = temp;
//						   else vioTWCus[nextID] = 0;
//
//
//						   //Update BvioTWCus from nextID to firstCus
//							//Update BCAP from prei to firstCus (prei may = assSPi)
//							//Update FCAP, FvioTWCus from nextID to lastCus
//							//Update trip_num, route_num, pos from nextID to lastCus
//							//Update cost
//							id = nextArr[nextID];
//							if (id < 0) BvioTWCus[nextID] = vioTWCus[nextID];
//							else BvioTWCus[nextID] = BvioTWCus[id] + vioTWCus[nextID];
//
//							id = nextID; preID = predArr[id];
//							while (preID > 0)
//							{
//							   BvioTWCus[preID] = BvioTWCus[id] + vioTWCus[preID];
//							   BCAP[preID] = BCAP[id] + problem->node[preID].capacity;
//							   id = preID; preID = predArr[preID];
//							}
//
//						   id = nextID; preID = predArr[id];
//						   if (preID < 0) 
//						   {
//							   pos[id] = 1;route_num[id] = idVehi; trip_num[id] = idTripi;
//							   FCAP[id] = problem->node[id].capacity;
//							   FvioTWCus[id] = vioTWCus[id];
//							   COSTi += problem->c[assSPi][nextID];
//							   //cout<<"@CostI = "<<COSTi<<"(fC = "<<nextID<<") + ";
//							   preID = id; id = nextArr[id];
//						   }
//						   while (id > 0)
//						   {
//							   route_num[id] = idVehi; trip_num[id] = idTripi;
//							   pos[id] = pos[preID] + 1;
//							   FCAP[id] = FCAP[preID] + problem->node[id].capacity;
//							   FvioTWCus[id] = FvioTWCus[preID] + vioTWCus[id];
//							   COSTi += problem->c[preID][id];
//							   //cout<<problem->c[preID][id]<<"("<<id<<") + ";
//							   preID = id; id = nextArr[id];
//						   }
//						   //preID now points to lastCus:
//						   varvioTWC = seg[idVehi].Trip[idTripi].vioTWC - FvioTWCus[preID];
//						   seg[idVehi].Trip[idTripi].vioTWC = FvioTWCus[preID];
//						   seg[idVehi].Trip[idTripi].endS = depart[preID];
//						   goto Updatei;
//					   }
//					   temp = cStartS - problem->node[nextID].eTW;
//					   if (temp > eps)
//					   {
//							if (vioTWCus[nextID] > eps) 
//							{
//								vioTWCus[nextID] = temp;
//								//Update BvioTWCus from nextID to firstCus
//								//Update BCAP from prei to firstCus (prei may = assSPi)
//								//Update FCAP, FvioTWCus from nextID to lastCus
//								//Update trip_num, route_num, pos from nextID to lastCus
//								//Update cost
//								id = nextArr[nextID];
//								if (id < 0) BvioTWCus[nextID] = vioTWCus[nextID];
//								else BvioTWCus[nextID] = BvioTWCus[id] + vioTWCus[nextID];
//
//								id = nextID; preID = predArr[id];
//								while (preID > 0)
//								{
//								   BvioTWCus[preID] = BvioTWCus[id] + vioTWCus[preID];
//								   BCAP[preID] = BCAP[id] + problem->node[preID].capacity;
//								   id = preID; preID = predArr[preID];
//								}
//								
//								id = nextID; preID = predArr[nextID];
//								if (preID < 0)
//								{
//									route_num[nextID] = idVehi; trip_num[nextID] = idTripi; 
//									pos[nextID] = 1;
//									COSTi = problem->c[assSPi][nextID];
//									//cout<<"#CostI = "<<COSTi<<"(fC = "<<nextID<<") + ";
//									FCAP[nextID] = problem->node[nextID].capacity;
//									FvioTWCus[nextID] = vioTWCus[nextID];
//									preID = nextID; id = nextArr[nextID];
//								}
//
//								while (id > 0)
//								{
//									route_num[id] = idVehi; trip_num[id] = idTripi;
//									pos[id] = pos[preID] + 1;
//									COSTi += problem->c[preID][id];
//								   // cout<<problem->c[preID][id]<<"("<<id<<") + ";
//									FCAP[id] = FCAP[preID] + problem->node[id].capacity;
//									FvioTWCus[id] = FvioTWCus[preID] + vioTWCus[id];
//									preID = id; id = nextArr[id];
//								}
//								//preID now points to lastCus:
//								varvioTWC = seg[idVehi].Trip[idTripi].vioTWC - FvioTWCus[preID];
//								seg[idVehi].Trip[idTripi].vioTWC = FvioTWCus[preID];
//								seg[idVehi].Trip[idTripi].endS = depart[preID];
//								//cout<<"KQ = "<<COSTi<<"; ";
//								goto Updatei;
//							}
//							vioTWCus[nextID] = temp;
//							FvioTWCus[nextID] = FvioTWCus[preID] + temp;
//							cStartS = problem->node[nextID].eTW;
//					   }
//					   else 
//					   {
//							vioTWCus[nextID] = 0;
//							FvioTWCus[nextID] = FvioTWCus[preID];
//					   }
//					   startS[nextID] = cStartS;
//					   cStartS += problem->node[nextID].duration;
//					   depart[nextID] = cStartS;
//					   FCAP[nextID] = FCAP[preID] + problem->node[nextID].capacity;
//					   route_num[nextID] = idVehi; trip_num[nextID] = idTripi;
//					   pos[nextID] = pos[preID] + 1;
//					   COSTi += problem->c[preID][nextID];
//					   //cout<<problem->c[preID][nextID]<<"("<<nextID<<") ++ ";
//					   preID = nextID; nextID = nextArr[nextID];
//				 }//end while (nextID > 0)
//				 seg[idVehi].Trip[idTripi].endS = cStartS;
//				 varvioTWC = FvioTWCus[preID] - seg[idVehi].Trip[idTripi].vioTWC;
//				 seg[idVehi].Trip[idTripi].vioTWC = FvioTWCus[preID];
//				//preID now points to the last cus:
//				 //Update BCAP from prei to firstCus
//				 //Update BvioTWCus from lastCus to firstCus
//				 BvioTWCus[preID] = vioTWCus[preID];
//				 BCAP[preID] = problem->node[preID].capacity;
//				 id = predArr[preID];
//				 while (id > 0)
//				 {
//					 BvioTWCus[id] = BvioTWCus[preID] + vioTWCus[id];
//					 BCAP[id] = BCAP[preID] + problem->node[id].capacity;
//					 preID = id; id = predArr[id];
//				 }
//			 }//not if (idTripi == 0 && sucj == lastCOLDj) 
//			 Updatei:
//			 		UpdateChangeCONNECTAtSP_PickTrip(idVehi, idTripi, varcostpreTi, varvioTWC, varvioCAPi, COSTi); //varcostpreT = 0
//	  }
//	  else  //idVehi.idTripi is empty
//	  {
//		  Update_EmptyTripP(idVehi, idTripi);
//	  }//idTripi empty
//
//	  bool stop = checkVehicle(idVehj);
//	  if (stop)
//	  {
//		  cout<<"STOP AT twoOPTstarCusPTrip of vehj = "<<idVehj<<"; @IT = "<<IT<<endl;
//		  exit(-1);
//	  }
//	  stop = checkVehicle(idVehi);
//	  if (stop)
//	  {
//		  cout<<"STOP AT twoOPTstarCusPTrip of vehi = "<<idVehi<<"; @IT = "<<IT<<endl;
//		  exit(-1);
//	  }
//}
//void Solution::UpdateTripnum(int idVeh, int idTrip)
//{
//    int curCus = seg[idVeh].Trip[idTrip].firstCus;
//    int numC = seg[idVeh].Trip[idTrip].numCus;
//	for (int cc=1;cc<=numC;cc++)
//	{
//		trip_num[curCus] = idTrip;
//		curCus = nextArr[curCus];
//	}
//}


//void Solution::UpdateRouteTripnum(int idVeh, int idTrip)
//{
//    int curCus = seg[idVeh].Trip[idTrip].firstCus;
//    int numC = seg[idVeh].Trip[idTrip].numCus;
//	for (int cc=1;cc<=numC;cc++)
//	{
//		route_num[curCus] = idVeh;
//		trip_num[curCus] = idTrip;
//		curCus = nextArr[curCus];
//	}
//}
//
//
//
//void Solution::UpdateVehicle(int idVeh, int curT, int preC, double cStartS, int varvioCAP, int update_idTrip)
//{
//	//see on 2/12/2013
//	int curC, preT, assSP;
//	double cArrTime, temp, varvioTWSP, varvioTWC, varcost, varfit;
//	//int lastTrip = seg[idVeh].numTrips - 1;
//	bool stop;
//
//	//Update 11/11/2013
//	if (curT == 0)
//	{
//		if (seg[idVeh].Trip[curT].Type == 0 && seg[idVeh].Trip[curT].numCus == 1)
//		{
//			assSP = seg[idVeh].Trip[0].assSP;
//			int id = seg[idVeh].Trip[0].firstCus;
//			startS[id] = problem->startSOneP[id][assSP];
//			depart[id] = startS[id] + problem->node[id].duration;
//			seg[idVeh].Trip[0].endS = depart[id];
//			if (problem->waitingSOneP[id][assSP])
//			{
//				seg[idVeh].Trip[0].waitingS = problem->CWSSP[id][assSP];
//				seg[idVeh].Trip[0].cost = problem->c[0][id] + problem->disCWSSP[id][assSP] + seg[idVeh].Trip[0].connectCost;
//				//cStartS = PDS_MAX(depart[id] + problem->disCWSSP[id][assSP], problem->nodeSP[assSP].sTW1);
//			}
//			else
//			{
//				seg[idVeh].Trip[0].waitingS = NO_WS;
//				seg[idVeh].Trip[0].cost = problem->c[0][id] + problem->c[id][assSP] + seg[idVeh].Trip[0].connectCost;
//				//cStartS = depart[id] + problem->c[id][assSP];
//			}
//			seg[idVeh].Trip[0].fitness = seg[idVeh].Trip[0].cost;
//			vioTWCus[id] = 0; FvioTWCus[id] = 0; BvioTWCus[id] = 0;
//			seg[idVeh].Trip[0].vioTWC = 0; seg[idVeh].Trip[0].vioTWSP = 0;
//			seg[idVeh].Trip[0].feasible = 1;
//			//cStartS += problem->nodeSP[assSP].unload;
//			cStartS = problem->leaveSPOneP[id][assSP];
//			if (PDSDIF(cStartS, seg[idVeh].Trip[0].leaveSP) == 0) goto Update;
//			seg[idVeh].Trip[0].leaveSP = cStartS;
//
//			if (update_idTrip > 0) //not the last pickup trip yet:
//			{
//				preT = 0; curT = 1;
//				if (seg[idVeh].Trip[1].Type == 1) 
//				{
//					int assSP1 = seg[idVeh].Trip[1].assSP;
//					if (assSP == assSP1) //p-d trip
//					{
//						cStartS = seg[idVeh].Trip[0].leaveSP + problem->nodeSP[assSP].load; //it's fine because the first pickup trip has only 1 customer --> not vioTWSP
//						seg[idVeh].Trip[1].leaveSP = cStartS;
//						temp = -seg[idVeh].Trip[1].vioTWSP;
//						seg[idVeh].Trip[1].vioTWSP = 0;
//						seg[idVeh].Trip[1].fitness += (VTWSP * temp);
//						preC = assSP1;
//						//curC = seg[idVeh].Trip[1].firstCus;
//					}
//					else //p - assSP - assSP1 - d
//					{
//						cStartS = seg[idVeh].Trip[0].leaveSP;
//						stop = updateChangeCONNECTAtSP_SPSP(idVeh, 1, 0, cStartS);
//						if (stop) goto Update;
//						preC = assSP1; //curC = seg[idVeh].Trip[1].firstCus;
//					}//end p - assSP - assSP1 - d
//				}
//				else //if(seg[idVeh].Trip[curT].Type == 0 || 2): p - p OR p - C2C
//				{
//					preC = assSP;
//					//curC = seg[idVeh].Trip[1].firstCus;
//				}//end if (seg[idVeh].Trip[curT].Type==0)
//			}
//			else goto Update; //cont = 0; curT is already the last pickup trip
//		}
//		else if (seg[idVeh].Trip[curT].Type == 2 && seg[idVeh].Trip[curT].nextSP > 0 && seg[idVeh].Trip[curT].numCus == 2)
//		{
//			assSP = seg[idVeh].Trip[0].nextSP;
//			int id = seg[idVeh].Trip[0].firstCus;
//			startS[id] = problem->startSOneP[id][assSP];
//			depart[id] = startS[id] + problem->node[id].duration;
//			int idD = seg[idVeh].Trip[0].lastCus;
//			startS[idD] = problem->startSOneP[idD][assSP];
//			depart[idD] = startS[idD] + problem->node[idD].duration;
//
//			seg[idVeh].Trip[0].endS = depart[idD];
//			if (problem->waitingSOneP[id][assSP])
//			{
//				seg[idVeh].Trip[0].waitingS = problem->CWSSP[id][assSP];
//				seg[idVeh].Trip[0].connectCost = problem->disCWSSP[id][assSP];
//				seg[idVeh].Trip[0].cost = problem->c[0][id] + problem->c[id][idD] + problem->disCWSSP[idD][assSP] + seg[idVeh].Trip[0].connectCost;
//				//cStartS = PDS_MAX(depart[id] + problem->disCWSSP[id][assSP], problem->nodeSP[assSP].sTW1);
//			}
//			else
//			{
//				seg[idVeh].Trip[0].waitingS = NO_WS;
//				seg[idVeh].Trip[0].connectCost = problem->c[id][assSP];
//				seg[idVeh].Trip[0].cost = problem->c[0][id] + problem->c[id][idD] + problem->c[idD][assSP] + seg[idVeh].Trip[0].connectCost;
//				//cStartS = depart[id] + problem->c[id][assSP];
//			}
//			seg[idVeh].Trip[0].fitness = seg[idVeh].Trip[0].cost;
//			CAPCus[id] = problem->node[id].capacity; vioCAPCus[id] = 0; FCAP[id] = 0;
//			vioTWCus[id] = 0; FvioTWCus[id] = 0; BvioTWCus[id] = 0;
//			CAPCus[idD] = 0; vioCAPCus[idD] = 0; FCAP[idD] = 0;
//			vioTWCus[idD] = 0; FvioTWCus[idD] = 0; BvioTWCus[idD] = 0;
//			
//			seg[idVeh].Trip[0].vioTWC = 0; seg[idVeh].Trip[0].vioTWSP = 0;
//			seg[idVeh].Trip[0].feasible = 1;
//			//cStartS += problem->nodeSP[assSP].unload;
//			cStartS = problem->leaveSPOneP[id][assSP];
//			if (PDSDIF(cStartS, seg[idVeh].Trip[1].leaveSP) == 0) goto Update;
//			seg[idVeh].Trip[1].leaveSP = cStartS;
//			seg[idVeh].Trip[0].arriveSP = cStartS - problem->nodeSP[assSP].load;
//			preT = 0; curT = 1;
//			temp = -seg[idVeh].Trip[1].vioTWSP;
//			seg[idVeh].Trip[1].vioTWSP = 0;
//			seg[idVeh].Trip[1].fitness += (VTWSP * temp);
//			preC = assSP;
//		}//end if (seg[idVeh].Trip[curT].Type == 2 && seg[idVeh].Trip[curT].nextSP > 0)
//	}//end if (curT == 0)
//
//	do
//	{
//		curC = seg[idVeh].Trip[curT].firstCus;
//		//varvioTWC = 0;
//		if (seg[idVeh].Trip[curT].Type == 1)
//		{
//			while (curC > 0)
//			{
//				cArrTime = cStartS + problem->c[preC][curC];
//				cStartS = PDS_MAX(cArrTime, problem->node[curC].sTW);
//				if (PDSDIF(cStartS, startS[curC]) == 0) //it means vioTWCus[curC] =0 
//				{
//					temp = cStartS - problem->node[curC].eTW;
//					if (temp > eps) vioTWCus[curC] = temp; else vioTWCus[curC] = 0;
//					UpdateFBvioTWCus(idVeh, curT, curC);
//					varvioTWC = FvioTWCus[seg[idVeh].Trip[curT].lastCus] - seg[idVeh].Trip[curT].vioTWC;
//					seg[idVeh].Trip[curT].vioTWC = FvioTWCus[seg[idVeh].Trip[curT].lastCus];
//					seg[idVeh].Trip[curT].fitness += (VTWCUS * varvioTWC);
//					if (seg[idVeh].Trip[curT].vioCAP > 0 || seg[idVeh].Trip[curT].vioTWC > eps || seg[idVeh].Trip[curT].vioTWSP > eps)
//						seg[idVeh].Trip[curT].feasible = 0;
//					else seg[idVeh].Trip[curT].feasible = 1;
//					goto Update;
//				}
//				temp = cStartS - problem->node[curC].eTW;
//				if (temp > eps)
//				{
//					if (vioTWCus[curC] > eps) 
//					{
//						vioTWCus[curC] = temp;
//						UpdateFBvioTWCus(idVeh, curT, curC);
//						varvioTWC = FvioTWCus[seg[idVeh].Trip[curT].lastCus] - seg[idVeh].Trip[curT].vioTWC;
//						seg[idVeh].Trip[curT].vioTWC = FvioTWCus[seg[idVeh].Trip[curT].lastCus];
//						seg[idVeh].Trip[curT].fitness += (VTWCUS * varvioTWC);
//						if (seg[idVeh].Trip[curT].vioCAP > 0 || seg[idVeh].Trip[curT].vioTWC > eps || seg[idVeh].Trip[curT].vioTWSP > eps)
//							seg[idVeh].Trip[curT].feasible = 0;
//						else seg[idVeh].Trip[curT].feasible = 1;
//						goto Update;
//					}
//					vioTWCus[curC] = temp;
//					FvioTWCus[curC] = FvioTWCus[preC] + temp;
//					cStartS = problem->node[curC].eTW;
//				}
//				else 
//				{
//					vioTWCus[curC] = 0;
//					FvioTWCus[curC] = FvioTWCus[preC];
//				}
//				startS[curC] = cStartS;
//				cStartS += problem->node[curC].duration;
//				depart[curC] = cStartS;
//				preC = curC; curC = nextArr[curC];
//			}//end while (curC > 0)
//			seg[idVeh].Trip[curT].endS = depart[preC];
//			varvioTWC = FvioTWCus[preC] - seg[idVeh].Trip[curT].vioTWC;
//			seg[idVeh].Trip[curT].vioTWC = FvioTWCus[preC];
//			seg[idVeh].Trip[curT].fitness += (VTWCUS * varvioTWC);
//			UpdateBvioTWCus(idVeh, curT, preC);
//
//			if (seg[idVeh].Trip[curT].vioTWC > eps || seg[idVeh].Trip[curT].vioCAP > 0 || seg[idVeh].Trip[curT].vioTWSP > eps)
//				seg[idVeh].Trip[curT].feasible = 0;
//			else seg[idVeh].Trip[curT].feasible = 1;
//
//			if (curT < update_idTrip) //not the last trip yet: 
//			{
//				preT = curT; curT++; //preC now points to the last delivery cus of trip preT
//				curC = seg[idVeh].Trip[curT].firstCus;
//				if (seg[idVeh].Trip[curT].Type == 1) // del trip - del trip
//				{
//				    stop = updateChangeCONNECTAtSP_DDORC2CD(preC, idVeh, curT, preT, cStartS);
//					if (stop) goto Update;
//					preC = seg[idVeh].Trip[curT].assSP; 
//				}
//				/*else //del trip - pick trip
//				{
//					curC = seg[idVeh].Trip[curT].firstCus;
//				}*/
//			}//end if (curT < update_idTrip) //not the last delivery trip yet
//			else //last delivery trip
//				break; //cont = 0; already the last trip
//		}
//		else if (seg[idVeh].Trip[curT].Type == 0)
//		{
//			//1.check firstCus curC where preC is the lastCus of previous trip or the assSP of previous delivery trip
//			cArrTime = cStartS + problem->c[preC][curC];
//			cStartS = PDS_MAX(cArrTime, problem->node[curC].sTW);
//			if (PDSDIF(cStartS, startS[curC])==0)
//			{
//				temp = cStartS - problem->node[curC].eTW;
//				if (temp > eps) vioTWCus[curC] = temp; else vioTWCus[curC] = 0;
//				UpdateFBvioTWCus(idVeh, curT, curC);
//				varvioTWC = FvioTWCus[seg[idVeh].Trip[curT].lastCus] - seg[idVeh].Trip[curT].vioTWC;
//				seg[idVeh].Trip[curT].vioTWC = FvioTWCus[seg[idVeh].Trip[curT].lastCus];
//				seg[idVeh].Trip[curT].fitness += (VTWCUS * varvioTWC);
//				if (seg[idVeh].Trip[curT].vioCAP > 0 || seg[idVeh].Trip[curT].vioTWC > eps || seg[idVeh].Trip[curT].vioTWSP > eps)
//					seg[idVeh].Trip[curT].feasible = 0;
//				else seg[idVeh].Trip[curT].feasible = 1;
//				goto Update;
//			}
//			temp = cStartS - problem->node[curC].eTW;
//			if (temp > eps)
//			{
//				if (vioTWCus[curC] > eps)
//				{
//					vioTWCus[curC] = temp;
//					UpdateFBvioTWCus(idVeh, curT, curC);
//					varvioTWC = FvioTWCus[seg[idVeh].Trip[curT].lastCus] - seg[idVeh].Trip[curT].vioTWC;
//					seg[idVeh].Trip[curT].vioTWC = FvioTWCus[seg[idVeh].Trip[curT].lastCus];
//					seg[idVeh].Trip[curT].fitness += (VTWCUS * varvioTWC);
//					if (seg[idVeh].Trip[curT].vioCAP > 0 || seg[idVeh].Trip[curT].vioTWC > eps || seg[idVeh].Trip[curT].vioTWSP > eps)
//						seg[idVeh].Trip[curT].feasible = 0;
//					else seg[idVeh].Trip[curT].feasible = 1;
//
//					goto Update;
//				}
//				vioTWCus[curC] = temp;
//				FvioTWCus[curC] = temp;
//				cStartS = problem->node[curC].eTW;
//			}
//			else
//			{
//				vioTWCus[curC] = 0;
//				FvioTWCus[curC] = 0;
//			}
//			startS[curC] = cStartS;
//			cStartS += problem->node[curC].duration;
//			depart[curC] = cStartS;
//			preC = curC; curC = nextArr[curC];
//
//			//2.check middle and lastCus
//			while (curC > 0)
//			{
//				cArrTime = cStartS + problem->c[preC][curC];
//				cStartS = PDS_MAX(cArrTime, problem->node[curC].sTW);
//				if (PDSDIF(cStartS, startS[curC])==0)
//				{
//					temp = cStartS - problem->node[curC].eTW;
//					if (temp > eps) vioTWCus[curC] = temp; else vioTWCus[curC] = 0;
//					UpdateFBvioTWCus(idVeh, curT, curC);
//					varvioTWC = FvioTWCus[seg[idVeh].Trip[curT].lastCus] - seg[idVeh].Trip[curT].vioTWC;
//					seg[idVeh].Trip[curT].vioTWC = FvioTWCus[seg[idVeh].Trip[curT].lastCus];
//					seg[idVeh].Trip[curT].fitness += (VTWCUS * varvioTWC);
//					if (seg[idVeh].Trip[curT].vioCAP > 0 || seg[idVeh].Trip[curT].vioTWC > eps || seg[idVeh].Trip[curT].vioTWSP > eps)
//						seg[idVeh].Trip[curT].feasible = 0;
//					else seg[idVeh].Trip[curT].feasible = 1;
//					goto Update;
//				}
//				temp = cStartS - problem->node[curC].eTW;
//				if (temp > eps)
//				{
//					if (vioTWCus[curC] > eps)
//					{
//						vioTWCus[curC] = temp;
//						UpdateFBvioTWCus(idVeh, curT, curC);
//						varvioTWC = FvioTWCus[seg[idVeh].Trip[curT].lastCus] - seg[idVeh].Trip[curT].vioTWC;
//						seg[idVeh].Trip[curT].vioTWC = FvioTWCus[seg[idVeh].Trip[curT].lastCus];
//						seg[idVeh].Trip[curT].fitness += (VTWCUS * varvioTWC);
//						if (seg[idVeh].Trip[curT].vioCAP > 0 || seg[idVeh].Trip[curT].vioTWC > eps || seg[idVeh].Trip[curT].vioTWSP > eps)
//							seg[idVeh].Trip[curT].feasible = 0;
//						else seg[idVeh].Trip[curT].feasible = 1;
//
//						goto Update;
//					}
//					vioTWCus[curC] = temp;
//					FvioTWCus[curC] = FvioTWCus[preC] + temp;
//					cStartS = problem->node[curC].eTW;
//				}
//				else
//				{
//					vioTWCus[curC] = 0;
//					FvioTWCus[curC] = FvioTWCus[preC];
//				}
//				startS[curC] = cStartS;
//				cStartS += problem->node[curC].duration;
//				depart[curC] = cStartS;
//				preC = curC; curC = nextArr[curC];
//			} //end while (curC > 0)
//			seg[idVeh].Trip[curT].endS = depart[preC];
//			varvioTWC = FvioTWCus[preC] - seg[idVeh].Trip[curT].vioTWC;
//			seg[idVeh].Trip[curT].vioTWC = FvioTWCus[preC];
//			seg[idVeh].Trip[curT].fitness += (VTWCUS * varvioTWC);
//			//preC now points to lastcus
//			UpdateBvioTWCus(idVeh, curT, preC);
//
//		    stop = calChangeCONNECTAtSP_PickTrip(preC, idVeh, curT, cStartS);
//			if (stop) goto Update;
//			if (curT < update_idTrip) //not the last pickup trip yet:
//			{
//				preT = curT; curT++;
//				assSP = seg[idVeh].Trip[preT].assSP;
//				if (seg[idVeh].Trip[curT].Type == 1) 
//				{
//					int assSP1 = seg[idVeh].Trip[curT].assSP;
//					if (assSP == assSP1) //p-d trip
//					{
//						temp = seg[idVeh].Trip[preT].vioTWSP - seg[idVeh].Trip[curT].vioTWSP;
//						seg[idVeh].Trip[curT].vioTWSP = seg[idVeh].Trip[preT].vioTWSP;
//						seg[idVeh].Trip[curT].fitness += (VTWSP * temp);
//						//Update 16/11/2013
//						if (seg[idVeh].Trip[curT].vioTWSP > eps)
//							cStartS = problem->leaveSP[assSP][1];
//						else	cStartS += problem->nodeSP[assSP].load;
//						seg[idVeh].Trip[curT].leaveSP = cStartS;
//
//						preC = assSP1;
//						curC = seg[idVeh].Trip[curT].firstCus;
//					}
//					else //p - assSP - assSP1 - d
//					{
//						stop = updateChangeCONNECTAtSP_SPSP(idVeh, curT, preT, cStartS);
//						if (stop) goto Update;
//						preC = assSP1; curC = seg[idVeh].Trip[curT].firstCus;
//					}//end p - assSP - assSP1 - d
//				}
//				else //if(seg[idVeh].Trip[curT].Type == 0 || 2): p - p OR p - c2c
//				{
//					preC = assSP;
//					curC = seg[idVeh].Trip[curT].firstCus;
//				}//end if (seg[idVeh].Trip[curT].Type==0)
//			}
//			else break; //cont = 0; curT is already the last pickup trip
//		}//end trip curT is pickup
//		else //curT is C2C
//		{
//			//1.check firstCus curC where preC is the lastCus of previous trip or the assSP of previous pickup trip
//			cArrTime = cStartS + problem->c[preC][curC];
//			cStartS = PDS_MAX(cArrTime, problem->node[curC].sTW);
//			if (PDSDIF(cStartS, startS[curC])==0)
//			{
//				temp = cStartS - problem->node[curC].eTW;
//				if (temp > eps) vioTWCus[curC] = temp; else vioTWCus[curC] = 0;
//				UpdateFBvioTWCus(idVeh, curT, curC);
//				varvioTWC = FvioTWCus[seg[idVeh].Trip[curT].lastCus] - seg[idVeh].Trip[curT].vioTWC;
//				seg[idVeh].Trip[curT].vioTWC = FvioTWCus[seg[idVeh].Trip[curT].lastCus];
//				seg[idVeh].Trip[curT].fitness += (VTWCUS * varvioTWC);
//				if (seg[idVeh].Trip[curT].vioTWC > eps)	seg[idVeh].Trip[curT].feasible = 0;
//				else seg[idVeh].Trip[curT].feasible = 1;
//				goto Update;
//			}
//			temp = cStartS - problem->node[curC].eTW;
//			if (temp > eps)
//			{
//				if (vioTWCus[curC] > eps)
//				{
//					vioTWCus[curC] = temp;
//					UpdateFBvioTWCus(idVeh, curT, curC);
//					varvioTWC = FvioTWCus[seg[idVeh].Trip[curT].lastCus] - seg[idVeh].Trip[curT].vioTWC;
//					seg[idVeh].Trip[curT].vioTWC = FvioTWCus[seg[idVeh].Trip[curT].lastCus];
//					seg[idVeh].Trip[curT].fitness += (VTWCUS * varvioTWC);
//					if (seg[idVeh].Trip[curT].vioTWC > eps)	seg[idVeh].Trip[curT].feasible = 0;
//					else seg[idVeh].Trip[curT].feasible = 1;
//					goto Update;
//				}
//				vioTWCus[curC] = temp;
//				FvioTWCus[curC] = temp;
//				cStartS = problem->node[curC].eTW;
//			}
//			else
//			{
//				vioTWCus[curC] = 0;
//				FvioTWCus[curC] = 0;
//			}
//			startS[curC] = cStartS;
//			cStartS += problem->node[curC].duration;
//			depart[curC] = cStartS;
//			preC = curC; curC = nextArr[curC];
//
//			//2.check middle and lastCus
//			while (curC > 0)
//			{
//				cArrTime = cStartS + problem->c[preC][curC];
//				cStartS = PDS_MAX(cArrTime, problem->node[curC].sTW);
//				if (PDSDIF(cStartS, startS[curC])==0)
//				{
//					temp = cStartS - problem->node[curC].eTW;
//					if (temp > eps) vioTWCus[curC] = temp; else vioTWCus[curC] = 0;
//					UpdateFBvioTWCus(idVeh, curT, curC);
//					varvioTWC = FvioTWCus[seg[idVeh].Trip[curT].lastCus] - seg[idVeh].Trip[curT].vioTWC;
//					seg[idVeh].Trip[curT].vioTWC = FvioTWCus[seg[idVeh].Trip[curT].lastCus];
//					seg[idVeh].Trip[curT].fitness += (VTWCUS * varvioTWC);
//					if (seg[idVeh].Trip[curT].vioTWC > eps)	seg[idVeh].Trip[curT].feasible = 0;
//					else seg[idVeh].Trip[curT].feasible = 1;
//					goto Update;
//				}
//				temp = cStartS - problem->node[curC].eTW;
//				if (temp > eps)
//				{
//					if (vioTWCus[curC] > eps)
//					{
//						vioTWCus[curC] = temp;
//						UpdateFBvioTWCus(idVeh, curT, curC);
//						varvioTWC = FvioTWCus[seg[idVeh].Trip[curT].lastCus] - seg[idVeh].Trip[curT].vioTWC;
//						seg[idVeh].Trip[curT].vioTWC = FvioTWCus[seg[idVeh].Trip[curT].lastCus];
//						seg[idVeh].Trip[curT].fitness += (VTWCUS * varvioTWC);
//						if (seg[idVeh].Trip[curT].vioTWC > eps)	seg[idVeh].Trip[curT].feasible = 0;
//						else seg[idVeh].Trip[curT].feasible = 1;
//
//						goto Update;
//					}
//					vioTWCus[curC] = temp;
//					FvioTWCus[curC] = FvioTWCus[preC] + temp;
//					cStartS = problem->node[curC].eTW;
//				}
//				else
//				{
//					vioTWCus[curC] = 0;
//					FvioTWCus[curC] = FvioTWCus[preC];
//				}
//				startS[curC] = cStartS;
//				cStartS += problem->node[curC].duration;
//				depart[curC] = cStartS;
//				preC = curC; curC = nextArr[curC];
//			} //end while (curC > 0)
//			seg[idVeh].Trip[curT].endS = depart[preC];
//			varvioTWC = FvioTWCus[preC] - seg[idVeh].Trip[curT].vioTWC;
//			seg[idVeh].Trip[curT].vioTWC = FvioTWCus[preC];
//			seg[idVeh].Trip[curT].fitness += (VTWCUS * varvioTWC);
//			//preC now points to lastcus
//			UpdateBvioTWCus(idVeh, curT, preC);
//			if (seg[idVeh].Trip[curT].vioTWC > eps)	seg[idVeh].Trip[curT].feasible = 0;
//			else seg[idVeh].Trip[curT].feasible = 1;
//			if (curT < update_idTrip) //not the last C2C trip yet:
//			{
//				preT = curT; curT++; //preC now points to the last C2C cus of trip preT
//				curC = seg[idVeh].Trip[curT].firstCus;
//				if (seg[idVeh].Trip[preT].nextSP > 1)
//				{
//					stop = updateChangeCONNECTAtSP_DDORC2CD(preC, idVeh, curT, preT, cStartS);
//					if (stop) goto Update;
//					preC = seg[idVeh].Trip[curT].assSP; 
//				}
//				/*else //curT is pickup
//				{
//				}*/
//			}
//			else break;
//		}//end curT is C2C
//	}while (1);
//Update:
//   varcost = -seg[idVeh].cost;
//   varfit = -seg[idVeh].fitness;
//   varvioTWC = -seg[idVeh].vioTWC;
//   varvioTWSP = -seg[idVeh].vioTWSP;
// 
//   seg[idVeh].cost = 0; seg[idVeh].fitness = 0;
//   seg[idVeh].vioTWC = 0; seg[idVeh].vioTWSP = 0;
//   for (int i=0;i<seg[idVeh].numTrips;i++)
//   {
//	   seg[idVeh].cost += seg[idVeh].Trip[i].cost;
//       seg[idVeh].fitness += seg[idVeh].Trip[i].fitness;
//	   seg[idVeh].vioTWC += seg[idVeh].Trip[i].vioTWC;
//	   seg[idVeh].vioTWSP += seg[idVeh].Trip[i].vioTWSP;
//   }
//   seg[idVeh].vioCAP += varvioCAP;
//
//   varcost += seg[idVeh].cost; varfit += seg[idVeh].fitness;
//   cost += varcost; fitness += varfit;
//   varvioTWC += seg[idVeh].vioTWC; varvioTWSP += seg[idVeh].vioTWSP; 
//   vioCAP += varvioCAP; vioTWC += varvioTWC; vioTWSP += varvioTWSP;
//}


//void Solution::UpdateBvioTWCus(int idVeh, int idTrip, int idCus) //when vioTWCus[idCus] is changed
//{
//	//see on 2/12/2013
//	int nextC;
//	if (idCus == seg[idVeh].Trip[idTrip].lastCus) 
//		BvioTWCus[idCus] = vioTWCus[idCus];
//	else
//	{
//		nextC = nextArr[idCus];
//		BvioTWCus[idCus] = BvioTWCus[nextC] + vioTWCus[idCus];
//	}
//	nextC = idCus;
//	int curC = predArr[idCus];
//	while (curC > 0)
//	{
//		BvioTWCus[curC] = BvioTWCus[nextC] + vioTWCus[curC];
//		nextC = curC; curC = predArr[curC];
//	}
//}

//void Solution::UpdateBvioTW_BvioCAPCus(int idVeh, int idTrip, int idCus)
//{
//	int nextC;
//	if (idCus == seg[idVeh].Trip[idTrip].lastCus) 
//	{
//		BvioTWCus[idCus] = vioTWCus[idCus];
//		BCAP[idCus] = vioCAPCus[idCus];
//		//BvioCAPCus[idCus] = vioCAPCus[idCus];
//	}
//	else
//	{
//		nextC = nextArr[idCus];
//		BvioTWCus[idCus] = BvioTWCus[nextC] + vioTWCus[idCus];
//		BCAP[idCus] = BCAP[nextC] + vioCAPCus[idCus];
//		//BvioCAPCus[idCus] = BvioCAPCus[nextC] + vioCAPCus[idCus];
//	}
//	nextC = idCus;
//	int curC = predArr[idCus];
//	while (curC > 0)
//	{
//		BvioTWCus[curC] = BvioTWCus[nextC] + vioTWCus[curC];
//		BCAP[curC] = BCAP[nextC] + vioCAPCus[curC];
//		//BvioCAPCus[curC] = BvioCAPCus[nextC] + vioCAPCus[curC];
//		nextC = curC; curC = predArr[curC];
//	}
//}

//void Solution::UpdateFBvioTWCus(int idVeh, int idTrip, int idCus) //when vioTWCus[idCus] is changed
//{
//	//see on 2/12/2013
//	int nextC;
//	if (idCus == seg[idVeh].Trip[idTrip].lastCus) 
//		BvioTWCus[idCus] = vioTWCus[idCus];
//	else
//	{
//		nextC = nextArr[idCus];
//		BvioTWCus[idCus] = BvioTWCus[nextC] + vioTWCus[idCus];
//	}
//	nextC = idCus;
//	int curC = predArr[idCus];
//	while (curC > 0)
//	{
//		BvioTWCus[curC] = BvioTWCus[nextC] + vioTWCus[curC];
//		nextC = curC; curC = predArr[curC];
//	}
//
//	int preC;
//	if (idCus == seg[idVeh].Trip[idTrip].firstCus) FvioTWCus[idCus] = vioTWCus[idCus];
//	else
//	{
//		preC = predArr[idCus];
//		FvioTWCus[idCus] = FvioTWCus[preC] + vioTWCus[idCus];
//	}
//	preC = idCus;
//	curC = nextArr[idCus];
//	while (curC > 0)
//	{
//		FvioTWCus[curC] = FvioTWCus[preC] + vioTWCus[curC];
//		preC = curC; curC = nextArr[curC];
//	}
//}


//void Solution::UpdateBvioCAPCus(int idVeh, int idTrip, int idCus) //when vioCAPCus[idCus] is changed
//{
//	//Updated 4/12/2013
//	int nextC;
//	if (idCus == seg[idVeh].Trip[idTrip].lastCus) 
//		BCAP[idCus] = vioCAPCus[idCus];//BvioCAPCus[idCus] = vioCAPCus[idCus];
//	else
//	{
//		nextC = nextArr[idCus];
//		BCAP[idCus] = BCAP[nextC] + vioCAPCus[idCus];
//		//BvioCAPCus[idCus] = BvioCAPCus[nextC] + vioCAPCus[idCus];
//	}
//	nextC = idCus;
//	int curC = predArr[idCus];
//	while (curC > 0)
//	{
//		BCAP[curC] = BCAP[nextC] + vioCAPCus[curC];
//		//BvioCAPCus[curC] = BvioCAPCus[nextC] + vioCAPCus[curC];
//		nextC = curC; curC = predArr[curC];
//	}
//}
//
//void Solution::UpdateFBvioCAPCus(int idVeh, int idTrip, int idCus) //when vioTWCus[idCus] is changed
//{
//	//see on 2/12/2013
//	int nextC;
//	if (idCus == seg[idVeh].Trip[idTrip].lastCus) 
//		BCAP[idCus] = vioCAPCus[idCus];
//		//BvioCAPCus[idCus] = vioCAPCus[idCus];
//	else
//	{
//		nextC = nextArr[idCus];
//		BCAP[idCus] = BCAP[nextC] + vioCAPCus[idCus];
//		//BvioCAPCus[idCus] = BvioCAPCus[nextC] + vioCAPCus[idCus];
//	}
//	nextC = idCus;
//	int curC = predArr[idCus];
//	while (curC > 0)
//	{
//		BCAP[curC] = BCAP[nextC] + vioCAPCus[curC];
//		//BvioCAPCus[curC] = BvioCAPCus[nextC] + vioCAPCus[curC];
//		nextC = curC; curC = predArr[curC];
//	}
//
//	int preC;
//	if (idCus == seg[idVeh].Trip[idTrip].firstCus) FCAP[idCus] = vioCAPCus[idCus]; //FvioCAPCus[idCus] = vioCAPCus[idCus];
//	else
//	{
//		preC = predArr[idCus];
//		FCAP[idCus] = FCAP[preC] + vioCAPCus[idCus];
//		//FvioCAPCus[idCus] = FvioCAPCus[preC] + vioCAPCus[idCus];
//	}
//	preC = idCus;
//	curC = nextArr[idCus];
//	while (curC > 0)
//	{
//		FCAP[curC] = FCAP[preC] + vioCAPCus[curC];
//		//FvioCAPCus[curC] = FvioCAPCus[preC] + vioCAPCus[curC];
//		preC = curC; curC = nextArr[curC];
//	}
//}




//void Solution::UpdateArray(int idVeh)
//{
//    	//cout<<"CALL UpdateArray for veh = "<<idVeh<<endl;
//		UpdateDeleteArray(idVeh); 
//		//cout<<"Call UpdateInsertArray"<<endl;
//		UpdateInsertArray(idVeh);
//		//cout<<"Call UpdateMoveCusOneTripArray"<<endl;
//		UpdateMoveCusOneTripArray(idVeh); 
//		//cout<<"Call UpdateMoveCusPOneVehArray"<<endl;
//		UpdateMoveCusPOneVehArray(idVeh); //move cus P between 1 vehicle but different trips
//		//cout<<"Call UpdateMoveCusC2COneVehArray"<<endl;
//		UpdateMoveCusC2COneVehArray(idVeh); //move cus C2C between 1 vehicle but different trips
//
//		//cout<<"Call UpdateExchangeArray"<<endl;
//		UpdateExchangeArray(idVeh);
//		//cout<<"Call UpdatetwoOPTstarArray"<<endl;
//		UpdatetwoOPTstarArray(idVeh);
//		//UpdateMoveSPArray(idVeh);
//}


//void Solution::UpdateDeleteArray(int idVeh)
//{
//	//see on 2/12/2013;
//	int	lastT = seg[idVeh].numTrips-1; 
//	int numC, assSP;
//	int vioCapNEW, vioCapOLD, capOLD, deletednode, idpre, pre_deletednode, nextC, next1;
//	double vioTWCOLD, vioTWCNEW, cArrTime, cStartS, temp, cArrTimeI;
//
//
//		if (lastT==0) //vehicle with only one trip
//		{
//            numC = seg[idVeh].Trip[0].numCus;
//			if (numC ==1) //after delete: vehicle empty
//			{
//				deletednode = seg[idVeh].Trip[0].firstCus;
//				if (seg[idVeh].Trip[0].Type == 1) //delivery trip:
//				{
//					deleteCus[deletednode]->var_vioCAP = 0;
//					deleteCus[deletednode]->var_vioTWC = -seg[idVeh].Trip[0].vioTWC;
//					deleteCus[deletednode]->var_vioTWSP = 0;
//					deleteCus[deletednode]->var_cost = -seg[idVeh].Trip[0].cost;
//					deleteCus[deletednode]->empty = 1;
//					deleteCus[deletednode]->atIT = IT;
//				}
//				else if (seg[idVeh].Trip[0].Type == 0) //pick up trip:
//				{
//					deleteCus[deletednode]->var_vioCAP = 0;
//					deleteCus[deletednode]->var_vioTWSP = 0;
//					deleteCus[deletednode]->var_cost = -seg[idVeh].Trip[0].cost;
//					deleteCus[deletednode]->var_vioTWC = 0;
//					deleteCus[deletednode]->empty = 1;
//					deleteCus[deletednode]->atIT = IT;
//				}
//			}
//			else //vehicle with >=2 customers:
//			{
//				deletednode = seg[idVeh].Trip[0].firstCus;
//				capOLD = seg[idVeh].Trip[0].capacity;
//			    vioCapOLD = seg[idVeh].Trip[0].vioCAP;
//			    vioTWCOLD = seg[idVeh].Trip[0].vioTWC; vioTWCNEW = 0;
//				if (seg[idVeh].Trip[0].Type == 1) //is delivery trip: with >= 2 customers
//				{
//					assSP = seg[idVeh].Trip[0].assSP; 
//					idpre = assSP;cStartS = seg[idVeh].Trip[0].leaveSP;
//					while (deletednode >0)
//					{
//						deleteCus[deletednode]->empty = 0;
//				        pre_deletednode = idpre;
//						//1. update vioCAP
//						vioCapNEW = PDS_MAX(capOLD - problem->node[deletednode].capacity- problem->Q,0);
//					    deleteCus[deletednode]->var_vioCAP = vioCapNEW - vioCapOLD;
//					   //2.update vioTWC at deleted node:
//						nextC = nextArr[deletednode]; 
//						while (nextC > 0)
//						{
//							cArrTime = cStartS + problem->c[idpre][nextC];//arrTime at customer nextC
//							cStartS = PDS_MAX(cArrTime, problem->node[nextC].sTW);
//							temp = cStartS - problem->node[nextC].eTW;
//							if (temp > eps) //if deletion causes vioTW --> vioTW at remaining customers are the same 
//							{
//								vioTWCNEW += temp;
//								if (vioTWCus[nextC] > eps)
//								{
//									vioTWCNEW += (BvioTWCus[nextC] - vioTWCus[nextC]);
//									break;
//								}
//								else cStartS = problem->node[nextC].depart;
//							}
//							else  cStartS += problem->node[nextC].duration; 
//							idpre = nextC; 
//							nextC = nextArr[nextC];
//						}
//						deleteCus[deletednode]->var_vioTWC = vioTWCNEW - vioTWCOLD;   
//						deleteCus[deletednode]->var_vioTWSP = 0;
//						int next1 = nextArr[deletednode];
//						if (next1 >0) //not delete the last cus:
//						    deleteCus[deletednode]->var_cost = problem->c[pre_deletednode][next1] - (problem->c[pre_deletednode][deletednode] + problem->c[deletednode][next1]);
//						else //delete the last cus:
//							deleteCus[deletednode]->var_cost = problem->c[pre_deletednode][0] - (problem->c[pre_deletednode][deletednode] + problem->c[deletednode][0]);
//						//new deletednode:
//						cStartS = depart[deletednode]; vioTWCNEW = FvioTWCus[deletednode];
//						deleteCus[deletednode]->atIT = IT;
//						idpre = deletednode; deletednode = next1;
//					}
//				}
//				else if (seg[idVeh].Trip[0].Type == 0) //is pickup trip: with >=2 customers:
//				{
//					assSP = seg[idVeh].Trip[0].assSP; 
//					if (seg[idVeh].Trip[0].numCus == 2)
//					{
//						//1. Delete the first pickup cus:
//						deleteCus[deletednode]->empty = 0;
//						deleteCus[deletednode]->atIT = IT;
//						//1.1. Update vioCAP
//						vioCapNEW = PDS_MAX(capOLD - problem->node[deletednode].capacity - problem->Q,0);
//						deleteCus[deletednode]->var_vioCAP = vioCapNEW - vioCapOLD;
//						idpre = nextArr[deletednode];
//						double varC = problem->c[0][idpre] - (problem->c[0][deletednode] + problem->c[deletednode][idpre]);
//					   	if (problem->waitingSOneP[idpre][assSP])
//						{
//							if (seg[idVeh].Trip[0].waitingS == NO_WS)
//								varC += (problem->disCWSSP[idpre][assSP] - problem->c[idpre][assSP]);
//						}
//						else
//						{
//							if (seg[idVeh].Trip[0].waitingS != NO_WS)
//								varC += (problem->c[idpre][assSP] - problem->disCWSSP[idpre][assSP]);
//						}
//						deleteCus[deletednode]->var_cost = varC;
//						deleteCus[deletednode]->var_vioTWC = -seg[idVeh].Trip[0].vioTWC;
//						deleteCus[deletednode]->var_vioTWSP = -seg[idVeh].Trip[0].vioTWSP;
//						
//						//2. Delete the last pickup cus:
//						idpre = deletednode; deletednode = nextArr[deletednode];
//						deleteCus[deletednode]->empty = 0;
//						deleteCus[deletednode]->atIT = IT;
//						//2.1. Update vioCAP
//						vioCapNEW = PDS_MAX(capOLD - problem->node[deletednode].capacity - problem->Q,0);
//						deleteCus[deletednode]->var_vioCAP = vioCapNEW - vioCapOLD;
//						varC = -problem->c[idpre][deletednode];
//					    if (seg[idVeh].Trip[0].waitingS == NO_WS)
//							varC -= problem->c[deletednode][assSP];
//						else varC -= problem->disCWSSP[deletednode][assSP];
//						if (problem->waitingSOneP[idpre][assSP])
//							varC += problem->disCWSSP[idpre][assSP];
//						else
//							varC += problem->c[idpre][assSP];
//
//						deleteCus[deletednode]->var_cost = varC;
//						deleteCus[deletednode]->var_vioTWC = -seg[idVeh].Trip[0].vioTWC;
//						deleteCus[deletednode]->var_vioTWSP = -seg[idVeh].Trip[0].vioTWSP;
//					}
//					else //pickup trip > 2 customers; vehicle with only 1 trip
//					{
//						//1. Delete the first pick Cus:
//						deleteCus[deletednode]->empty = 0;
//						deleteCus[deletednode]->atIT = IT;
//						//1.1. Update vioCAP
//						vioCapNEW = PDS_MAX(capOLD - problem->node[deletednode].capacity - problem->Q,0);
//						deleteCus[deletednode]->var_vioCAP = vioCapNEW - vioCapOLD;
//					
//						idpre = nextArr[deletednode]; cStartS = problem->node[idpre].sTW + problem->node[idpre].duration;
//						deleteCus[deletednode]->var_cost = problem->c[0][idpre] - (problem->c[0][deletednode] + problem->c[deletednode][idpre]);
//					
//						//1.3 Update vioTWC at deleted node:
//						nextC = nextArr[idpre];
//						while (nextC > 0)
//						{
//							cArrTime = cStartS + problem->c[idpre][nextC]; //arrTime at customer nextC
//							cStartS = PDS_MAX(cArrTime, problem->node[nextC].sTW);
//							temp = cStartS - problem->node[nextC].eTW;
//							if (temp > eps)
//							{
//								vioTWCNEW += temp;
//								if (vioTWCus[nextC] > eps) //Update 8/11/2013
//								{
//									vioTWCNEW += (BvioTWCus[nextC] - vioTWCus[nextC]);
//									deleteCus[deletednode]->var_vioTWSP = 0;
//									break;
//								}
//								cStartS = problem->node[nextC].depart;
//							}
//							else cStartS += problem->node[nextC].duration; 
//							idpre = nextC; 
//							nextC = nextArr[nextC];
//						}
//						deleteCus[deletednode]->var_vioTWC = vioTWCNEW - vioTWCOLD;
//						if (nextC < 0) // arrival time at sp may change
//						{
//							cArrTime = cStartS + problem->c[idpre][assSP]; //idpre is now the last customer
//							if (PDSINRANGE(cArrTime, problem->nodeSP[assSP].sTW1, problem->nodeSP[assSP].eTW1))
//							{
//								deleteCus[deletednode]->var_vioTWSP = -seg[idVeh].Trip[0].vioTWSP;
//								if (seg[idVeh].Trip[0].waitingS != NO_WS) //before go to sp directly:
//									deleteCus[deletednode]->var_cost += (problem->c[idpre][assSP] - problem->disCWSSP[idpre][assSP]);
//
//							}
//							else
//							{
//								temp = cArrTime - problem->nodeSP[assSP].eTW1;
//								if (temp > eps) //too late to go sp directly: -->before delete also NOT ALWAYS
//								{
//									deleteCus[deletednode]->var_vioTWSP = temp - seg[idVeh].Trip[0].vioTWSP;
//									if (seg[idVeh].Trip[0].waitingS != NO_WS) //before go to sp directly:
//										deleteCus[deletednode]->var_cost += (problem->c[idpre][assSP] - problem->disCWSSP[idpre][assSP]);
//								}
//								else
//								{
//									cArrTimeI = cStartS + problem->disCWSSP[idpre][assSP]; //go through WS:
//									temp = cArrTimeI - problem->nodeSP[assSP].eTW1;
//									if (temp > eps) //too soon for direct, too late for indirect --> vioTWSP and go direct: before may go to sp directly OR same as now
//									{
//										deleteCus[deletednode]->var_vioTWSP = (problem->nodeSP[assSP].sTW1 - cArrTime) - seg[idVeh].Trip[0].vioTWSP;
//										if (seg[idVeh].Trip[0].waitingS != NO_WS) //before go to sp directly:
//											deleteCus[deletednode]->var_cost += (problem->c[idpre][assSP] - problem->disCWSSP[idpre][assSP]);
//									}
//									else //now go through WS:
//									{
//										deleteCus[deletednode]->var_vioTWSP = - seg[idVeh].Trip[0].vioTWSP;
//										if (seg[idVeh].Trip[0].waitingS == NO_WS) //before go to sp directly:
//											deleteCus[deletednode]->var_cost += (problem->disCWSSP[idpre][assSP] - problem->c[idpre][assSP]);
//									}
//								}
//							}
//						}
//						//2. Delete the middle pickup cus:
//						idpre = deletednode; 
//						deletednode = nextArr[deletednode];
//						do
//						{
//							deleteCus[deletednode]->empty = 0;
//							pre_deletednode = idpre;
//							//1. update vioCAP
//							vioCapNEW = PDS_MAX(capOLD - problem->node[deletednode].capacity- problem->Q,0);
//							deleteCus[deletednode]->var_vioCAP = vioCapNEW - vioCapOLD;
//						   //2.update vioTWC at deleted node:
//							cStartS = depart[idpre];
//							vioTWCNEW = FvioTWCus[idpre];
//							nextC = nextArr[deletednode]; 
//							while (nextC > 0)
//							{
//								cArrTime = cStartS + problem->c[idpre][nextC];//arrTime at customer nextC
//								cStartS = PDS_MAX(cArrTime, problem->node[nextC].sTW);
//								temp = cStartS - problem->node[nextC].eTW;
//								if (temp > eps) //if deletion causes vioTW --> vioTW at remaining customers are the same 
//								{
//									vioTWCNEW += temp;
//									if (vioTWCus[nextC] > eps)
//									{
//										vioTWCNEW += (BvioTWCus[nextC] - vioTWCus[nextC]);
//										deleteCus[deletednode]->var_vioTWSP = 0;
//										next1 = nextArr[deletednode];
//										deleteCus[deletednode]->var_cost = problem->c[pre_deletednode][next1] - (problem->c[pre_deletednode][deletednode] + problem->c[deletednode][next1]);
//										break;
//									}
//									cStartS = problem->node[nextC].depart;
//								}
//								else cStartS += problem->node[nextC].duration; 
//								idpre = nextC; 
//								nextC = nextArr[nextC];
//							}
//							deleteCus[deletednode]->var_vioTWC = vioTWCNEW - vioTWCOLD;  
//							if (nextC < 0) //arrival time at sp may change OR delete the last cus:
//							{
//								cArrTime = cStartS + problem->c[idpre][assSP]; //idpre is now the last customer
//								if (PDSINRANGE(cArrTime, problem->nodeSP[assSP].sTW1, problem->nodeSP[assSP].eTW1))
//								{
//									deleteCus[deletednode]->var_vioTWSP = -seg[idVeh].Trip[0].vioTWSP;
//									next1 = nextArr[deletednode];
//									if (next1 > 0)
//									{
//										deleteCus[deletednode]->var_cost = problem->c[pre_deletednode][next1] - (problem->c[pre_deletednode][deletednode] + problem->c[deletednode][next1]);
//										//cout<<"(1)"<<deletednode<<", "<<deleteCus[deletednode]->var_cost<<", ";
//										if (seg[idVeh].Trip[0].waitingS != NO_WS)
//											deleteCus[deletednode]->var_cost += (problem->c[idpre][assSP] - problem->disCWSSP[idpre][assSP]);
//										//cout<<deleteCus[deletednode]->var_cost<<"); ";
//									}
//									else //delete the last cus: now go to sp directly, before also: NOT ALWAYS
//									{
//										deleteCus[deletednode]->var_cost = problem->c[idpre][assSP] - problem->c[idpre][deletednode];// problem->c[idpre][assSP] - (problem->c[idpre][deletednode] + problem->c[deletednode][assSP]); 
//										if (seg[idVeh].Trip[0].waitingS == NO_WS) //before go to sp directly:
//											deleteCus[deletednode]->var_cost -= problem->c[deletednode][assSP];
//										else
//										  deleteCus[deletednode]->var_cost -=  problem->disCWSSP[deletednode][assSP];
//									}
//								}
//								else
//								{
//									temp = cArrTime - problem->nodeSP[assSP].eTW1;
//									if (temp > eps) // too late to go sp directly --> before delete also: NOT ALWAYS Update 7/11/2013
//									{
//										deleteCus[deletednode]->var_vioTWSP = temp - seg[idVeh].Trip[0].vioTWSP;
//										next1 = nextArr[deletednode];
//										if (next1 > 0)
//										{
//											deleteCus[deletednode]->var_cost = problem->c[pre_deletednode][next1] - (problem->c[pre_deletednode][deletednode] + problem->c[deletednode][next1]);
//											//cout<<"(2)"<<deletednode<<", "<<deleteCus[deletednode]->var_cost<<", ";
//											if (seg[idVeh].Trip[0].waitingS != NO_WS)
//												deleteCus[deletednode]->var_cost += (problem->c[idpre][assSP] - problem->disCWSSP[idpre][assSP]);
//											//cout<<deleteCus[deletednode]->var_cost<<"); ";
//										}
//										else //delete the last cus: now too late to go to sp directly, before also: NOT ALWAYS Update 7/11/2013
//										{
//											deleteCus[deletednode]->var_cost = problem->c[idpre][assSP] - problem->c[idpre][deletednode]; 
//											if (seg[idVeh].Trip[0].waitingS == NO_WS) //before go to sp directly:
//												deleteCus[deletednode]->var_cost -= problem->c[deletednode][assSP];
//											else
//											  deleteCus[deletednode]->var_cost -=  problem->disCWSSP[deletednode][assSP];
//										}
//									}
//									else
//									{
//										cArrTimeI = cStartS + problem->disCWSSP[idpre][assSP]; //go through WS:
//										temp = cArrTimeI - problem->nodeSP[assSP].eTW1;
//										if (temp > eps) //too soon for direct, too late for indirect --> vioTWSP and go direct ==> before: go to sp directly feasibility OR the SAME
//										{
//											deleteCus[deletednode]->var_vioTWSP = (problem->nodeSP[assSP].sTW1 - cArrTime) - seg[idVeh].Trip[0].vioTWSP;
//											next1 = nextArr[deletednode];
//											if (next1 > 0)
//											{
//												deleteCus[deletednode]->var_cost = problem->c[pre_deletednode][next1] - (problem->c[pre_deletednode][deletednode] + problem->c[deletednode][next1]);
//												//cout<<"(3)"<<deletednode<<", "<<deleteCus[deletednode]->var_cost<<", ";
//												if (seg[idVeh].Trip[0].waitingS != NO_WS)
//													deleteCus[deletednode]->var_cost += (problem->c[idpre][assSP] - problem->disCWSSP[idpre][assSP]);
//												//cout<<deleteCus[deletednode]->var_cost<<"); ";
//											}
//											else //delete the last cus: before go to sp directly or the SAME NOT ALWAYS
//											{
//												deleteCus[deletednode]->var_cost = problem->c[idpre][assSP] - problem->c[idpre][deletednode];
//												if (seg[idVeh].Trip[0].waitingS == NO_WS) //before go to sp directly:
//													deleteCus[deletednode]->var_cost -= problem->c[deletednode][assSP];
//												else
//												  deleteCus[deletednode]->var_cost -=  problem->disCWSSP[deletednode][assSP];
//											}
//										}
//										else //go through WS:
//										{
//											deleteCus[deletednode]->var_vioTWSP = - seg[idVeh].Trip[0].vioTWSP;
//											next1 = nextArr[deletednode];
//											if (next1 > 0)
//											{
//												deleteCus[deletednode]->var_cost = problem->c[pre_deletednode][next1] - (problem->c[pre_deletednode][deletednode] + problem->c[deletednode][next1]);
//												//cout<<"(4)"<<deletednode<<", "<<deleteCus[deletednode]->var_cost<<", ";
//												if (seg[idVeh].Trip[0].waitingS == NO_WS) //before go to sp directly
//													deleteCus[deletednode]->var_cost += (problem->disCWSSP[idpre][assSP] - problem->c[idpre][assSP]);
//												//cout<<deleteCus[deletednode]->var_cost<<"); ";
//											}
//											else //delete the last cus:
//											{
//												if (seg[idVeh].Trip[0].waitingS == NO_WS) //now go through WS, before go to sp directly
//													deleteCus[deletednode]->var_cost = problem->disCWSSP[idpre][assSP] - (problem->c[idpre][deletednode] + problem->c[deletednode][assSP]);
//												else // now go through WS, before also:
//													deleteCus[deletednode]->var_cost = problem->disCWSSP[idpre][assSP] - (problem->c[idpre][deletednode] + problem->disCWSSP[deletednode][assSP]);
//
//											}
//										}
//									}
//								}
//							}
//     						//new deletednode:
//							deleteCus[deletednode]->atIT = IT;
//							idpre = deletednode; deletednode = next1;
//						}while (deletednode > 0);
//					}//end pickup trip > 2 customers; vehicle with only 1 trip
//				}//end is pickup trip: with >=2 customers: vehicle with only one pickup trip with >= 2 customers
//				else //is C2C trip, with >= 2 customers:
//				{
//					if (seg[idVeh].Trip[0].numCus == 2)
//					{
//						deleteCus[deletednode]->var_vioCAP = 0;
//						deleteCus[deletednode]->var_vioTWSP = 0;
//						deleteCus[deletednode]->var_cost = -seg[idVeh].Trip[0].cost;
//						deleteCus[deletednode]->var_vioTWC = 0;
//						deleteCus[deletednode]->empty = 1;
//						deleteCus[deletednode]->atIT = IT;
//					}
//					else // C2C trip: > 2 customers
//						Update_deleteCusArrayC2C_LastTrip(idVeh,0,0,0);
//				}//end C2C trip, with >= 2 customers
//			}
//		}
//		else //vehicle with more than one trip:
//		{
//			  int numC = seg[idVeh].Trip[0].numCus;
//			  if (seg[idVeh].Trip[0].Type == 1)
//			  {
//				  if (numC == 1) Update_deleteCusArrayD_FirstTrip_Empty(idVeh); //Update 12/11/2013
//				  else Update_deleteCusArrayD_FirstMiddleTrip(idVeh, 0);
//			  }
//			  else if (seg[idVeh].Trip[0].Type == 0)
//			  {
//				  if (numC == 1) Update_deleteCusArrayP_FirstTrip_Empty(idVeh);
//				  else if (numC == 2) Update_deleteCusP_FirstTrip_2Cus(idVeh);
//				  else Update_deleteCusArrayP_FirstMiddleTrip(idVeh, 0);
//			  }
//			  else //if (seg[idVeh].Trip[0].Type == 2)
//			  {
//				  if (numC == 2) Update_deleteCusArrayC2C_FirstTrip_Empty(idVeh);
//				  else if (numC == 4 && seg[idVeh].Trip[0].nextSP > 0) Update_deleteCusArrayC2C_FirstTrip_4Cus_nextD(idVeh);
//				  else Update_deleteCusArrayC2C_FirstMiddleTrip(idVeh,0);
//			  }
//
//			  for (int idTrip = 1; idTrip < lastT; idTrip++)
//			  {
//				  numC = seg[idVeh].Trip[idTrip].numCus;
//				  if (seg[idVeh].Trip[idTrip].Type == 1)
//				  {
//					  if (numC == 1) Update_deleteCusArrayD_MiddleTrip_Empty(idVeh, idTrip);
//					  else Update_deleteCusArrayD_FirstMiddleTrip(idVeh, idTrip);
//				  }
//				  else if (seg[idVeh].Trip[idTrip].Type == 0)
//				  {
//					  if (numC == 1) Update_deleteCusArrayPORC2C_MiddleTrip_Empty(idVeh, idTrip);
//					  else Update_deleteCusArrayP_FirstMiddleTrip(idVeh, idTrip);
//				  }
//				  else //if (seg[idVeh].Trip[idTrip].Type == 2)
//				  {
//					  if (numC == 2) Update_deleteCusArrayPORC2C_MiddleTrip_Empty(idVeh,idTrip);
//					  else Update_deleteCusArrayC2C_FirstMiddleTrip(idVeh, idTrip);
//				  }
//			  }
//
//			  numC = seg[idVeh].Trip[lastT].numCus;
//			  if (seg[idVeh].Trip[lastT].Type == 1)
//			  {
//				  if (numC == 1) Update_deleteCusArrayD_LastTrip_Empty(idVeh, lastT);
//				  else Update_deleteCusArrayD_LastTrip(idVeh, lastT);
//			  }
//			  else if (seg[idVeh].Trip[lastT].Type == 0)
//			  {
//				  if (numC == 1) Update_deleteCusArrayP_LastTrip_Empty(idVeh, lastT);
//				  else Update_deleteCusArrayP_LastTrip(idVeh, lastT);
//			  }
//			  else //if (seg[idVeh].Trip[lastT].Type == 2)
//			  {
//				  if (numC == 2) Update_deleteCusArrayC2C_LastTrip_Empty(idVeh, lastT);
//				  else 
//				  {
//					  int preT = lastT - 1; double cStartS; int lastCSP_preT;
//					  if (seg[idVeh].Trip[preT].Type == 0)
//					  {
//						  lastCSP_preT = seg[idVeh].Trip[preT].assSP;
//						  cStartS = seg[idVeh].Trip[preT].leaveSP;
//					  }
//					  else
//					  {
//						  lastCSP_preT = seg[idVeh].Trip[preT].lastCus;
//						  cStartS = depart[lastCSP_preT];
//					  }
//					  Update_deleteCusArrayC2C_LastTrip(idVeh, lastT,lastCSP_preT,cStartS);
//				  }
//			  }
//		} //end vehicle with more that one trip
//}


//void Solution::Update_deleteCusArrayC2C_FirstTrip_Empty(int idVeh)
//{
//	//5/12/2013
//	int	deletednode = seg[idVeh].Trip[0].firstCus;
//	deleteCus[deletednode]->var_vioCAP = 0;
//
//	double varvioTWC = -seg[idVeh].Trip[0].vioTWC;
//	double varcost = -seg[idVeh].Trip[0].cost;
//	double varvioTWSP, cStartS;
//	int curC = seg[idVeh].Trip[1].firstCus;
//
//
//	if (seg[idVeh].Trip[1].Type == 1) 
//	{
//		int assSP1 = seg[idVeh].Trip[1].assSP;
//		cStartS = problem->leaveSP[assSP1][4]; //load only at sTW2
//		varvioTWSP = -seg[idVeh].Trip[1].vioTWSP;
//		varcost += problem->c[0][assSP1];
//		GoThroughVehicle(idVeh,1, varcost, varvioTWC, varvioTWSP, cStartS, assSP1, curC);
//	}
//	else if (seg[idVeh].Trip[1].Type == 0)
//	{
//	    varvioTWSP = 0;
//		varcost += problem->c[0][curC];
//		GoThroughVehicle_FirstPT(idVeh,1, varcost, varvioTWC, varvioTWSP);
//	}
//	else //if (seg[idVeh].Trip[1].Type == 2)
//	{
//		varvioTWSP = 0;
//		varcost += problem->c[0][curC];
//		GoThroughVehicle_FirstC2C(idVeh,1,varcost,varvioTWC,varvioTWSP);
//	}
//	deleteCus[deletednode]->var_cost = varcost;
//	deleteCus[deletednode]->var_vioTWC = varvioTWC;
//	deleteCus[deletednode]->var_vioTWSP = varvioTWSP;
//	deleteCus[deletednode]->atIT = IT;
//	deleteCus[deletednode]->empty = 0;
//}
//
//bool Solution::cal_deleteCusArrayC2C_FirstTrip_Empty_TillTrip(int idVeh, double &varcost, double &varvioTWC, double &varvioTWSP, double &cStartS, int update_idTrip)
//{
//	//10/12/2013:COPY Update_deleteCusArrayC2C_FirstTrip_Empty
//
//	varvioTWC -= seg[idVeh].Trip[0].vioTWC;
//	varcost -= seg[idVeh].Trip[0].cost;
//	int curC = seg[idVeh].Trip[1].firstCus;
//
//	if (seg[idVeh].Trip[1].Type == 1) 
//	{
//		int assSP1 = seg[idVeh].Trip[1].assSP;
//		cStartS = problem->leaveSP[assSP1][4]; //load only at sTW2
//		varvioTWSP -= seg[idVeh].Trip[1].vioTWSP;
//		varcost += problem->c[0][assSP1];
//		//Quangnn+-
//		return 0;//GoThroughVehicle(idVeh,1,update_idTrip,varcost,varvioTWC,varvioTWSP,cStartS,assSP1,curC);
//	}
//	else if (seg[idVeh].Trip[1].Type == 0)
//	{
//	    //varvioTWSP = 0;
//		varcost += problem->c[0][curC];
//		return GoThroughVehicle_FirstPT(idVeh,1,update_idTrip,varcost,varvioTWC,varvioTWSP,cStartS);
//	}
//	else //if (seg[idVeh].Trip[1].Type == 2)
//	{
//		//varvioTWSP = 0;
//		varcost += problem->c[0][curC];
//		return GoThroughVehicle_FirstC2C(idVeh,1,update_idTrip,varcost,varvioTWC,varvioTWSP,cStartS);
//	}
//}
//
//
//
//void Solution::cal_deleteCusArrayC2C_FirstTrip_Empty_insertNextTrip_LastC(int j, int i, int idVeh, double &varcosti, double &varvioTWCi, double &varcostj, double &varvioTWCj, double &varvioTWSPj, int &varvioCAP)
//{
//	//11/12/2013: COPY cal_deleteCusArrayC2C_FirstTrip_Empty_insertNextTrip_NotLastC
//   //i is the first cus where there is only one ORDER --> delete i and its delID, this trip becomes empty
//  //then insert i after j [the last cus] on the second trip --> after empty the first trip, this second trip becomes the first trip
//
//	varvioTWCi -= seg[idVeh].Trip[0].vioTWC;
//	varcosti -= seg[idVeh].Trip[0].cost;
//	int lastC = seg[idVeh].Trip[1].lastCus;
//	int delID = problem->node[i].delID;
//	double cStartS, temp;
//	int lastT = seg[idVeh].numTrips - 1;
//
//	//insert i and cusDi at the end of the trip (right after j):
//	varcostj += (problem->c[j][i] + problem->c[i][delID]);
//	cStartS = depart[j] + problem->c[j][i];
//	temp = cStartS - problem->node[i].eTW;
//	if (temp > eps)
//	{
//		varvioTWCj += temp;
//		cStartS = problem->node[i].depart;
//	}
//	else cStartS = PDS_MAX(cStartS, problem->node[i].sTW) + problem->node[i].duration;
//	cStartS += problem->c[i][delID];
//	temp = cStartS - problem->node[delID].eTW;
//	if (temp > eps)
//	{
//		varvioTWCj += temp;
//		cStartS = problem->node[delID].depart;
//	}
//	else cStartS = PDS_MAX(cStartS, problem->node[delID].sTW) + problem->node[delID].duration;
//	//dont need to check vioCAP because CapVehCus at customer j = 0
//	if (lastT == 1)
//	{
//		varcostj += (problem->c[delID][0] - problem->c[j][0]);
//	}
//	else //lastT > 1
//	{
//		varcostj -= seg[idVeh].Trip[1].connectCost;
//	    int nextSP = seg[idVeh].Trip[1].nextSP;
//		if (nextSP > 0)
//		{
//			if (calChangeCONNECTAtSP_C2CTrip_LastCChanged(delID,idVeh,1,2,cStartS,varvioTWSPj,varcostj) == 0)
//                GoThroughVehicle(idVeh,2,varcostj,varvioTWCj,varvioTWSPj,cStartS,nextSP,seg[idVeh].Trip[2].firstCus);
//		}
//		else //(idVeh,2) is PTrip OR C2C
//		{
//			int firstC_nextT = seg[idVeh].Trip[2].firstCus;
//			varcostj += (problem->c[delID][firstC_nextT]);
//            GoThroughVehicle(idVeh,2,varcostj,varvioTWCj,varvioTWSPj,cStartS,delID,firstC_nextT);
//		}
//	}//end lastT > 1
//}
//
//
//void Solution::cal_deleteCusArrayC2C_FirstTrip_Empty_insertNextTrip_NotLastC(int j, int i, int idVeh, double &varcosti, double &varvioTWCi, double &varcostj, double &varvioTWCj, double &varvioTWSPj, int &varvioCAPj, int &moveAfter)
//{
//	//11/12/2013: COPY cal_deleteCusArrayC2C_FirstTrip_Empty_insertNextTrip_LastC
//   //i is the first cus where there is only one ORDER --> delete i and its delID, this trip becomes empty
//  //then insert i after j [the last cus] on the second trip --> after empty the first trip, this second trip becomes the first trip
//
//	varvioTWCi -= seg[idVeh].Trip[0].vioTWC;
//	varcosti -= seg[idVeh].Trip[0].cost;
//	int lastT = seg[idVeh].numTrips - 1;
//
//	if (lastT == 1) // is the last trip:
//	{
//		SUBcal_InsertCusC2CIAfterJ_NotLastC_LastTrip(depart[j],CAPCus[j],j,i,idVeh,1,varcostj,varvioTWCj,varvioCAPj,moveAfter);
//	}
//	else
//	{
//		int nextSP = seg[idVeh].Trip[1].nextSP;
//		if (nextSP > 0)
//			SUBcal_InsertCusC2CIAfterJ_NotLastC_NextD(depart[j],CAPCus[j],j,i,idVeh,1,nextSP,varcostj,varvioTWCj,varvioTWSPj,varvioCAPj,moveAfter);
//		else 
//			SUBcal_InsertCusC2CIAfterJ_NotLastC_NextTripPORC2C(depart[j],CAPCus[j],j,i,idVeh,1,varcostj,varvioTWCj,varvioTWSPj,varvioCAPj,moveAfter);
//	}
//}
//
//
//void Solution::Update_deleteCusArrayC2C_FirstTrip_4Cus_nextD(int idVeh)
//{
//	int nextSP = seg[idVeh].Trip[0].nextSP;
//   	int	cusP1 = seg[idVeh].Trip[0].firstCus;
//	int curC = nextArr[cusP1];
//	int cusD1 = problem->node[cusP1].delID;
//	int cusP2, cusD2; double varvioTWC, varcost, cStartS, varvioTWSP;
//	//COPY BY Update_deleteCusC2CTrip_FirstTrip_4Cus_nextD
//
//	cStartS = problem->leaveSP[nextSP][4]; //load only at sTW2
//	if (curC == cusD1) //FirstTripC2C: 1+ 1- 2+ 2-
//	{
//		//1. Delete 1+ 1- in the first C2Ctrip: 1+ 1- 2+ 2-
//		cusP2 = nextArr[cusD1]; cusD2 = nextArr[cusP2];
//		varvioTWC = -seg[idVeh].Trip[0].vioTWC;
//		varcost = problem->c[0][cusP2] - (problem->c[0][cusP1] + problem->c[cusP1][cusD1] + problem->c[cusD1][cusP2]);
//		if (problem->waitingSOneP[cusP2][nextSP])
//		{
//			if (seg[idVeh].Trip[0].waitingS == NO_WS) //before no_WS, now WS
//				varcost += (problem->disCWSSP[cusD2][nextSP] - problem->c[cusD2][nextSP]);
//		}
//		else
//		{
//			if (seg[idVeh].Trip[0].waitingS != NO_WS) //before WS, now NO_WS
//				varcost += (problem->c[cusD2][nextSP] - problem->disCWSSP[cusD2][nextSP]);
//		}
//		//varvioTWSP = -(seg[idVeh].Trip[0].vioTWSP + seg[idVeh].Trip[1].vioTWSP);
//		varvioTWSP = -seg[idVeh].Trip[1].vioTWSP;
//		//varcost += problem->c[0][nextSP];
//		GoThroughVehicle(idVeh,1, varcost, varvioTWC, varvioTWSP, cStartS, nextSP, seg[idVeh].Trip[1].firstCus);
//		deleteCus[cusP1]->var_vioCAP = 0;
//		deleteCus[cusP1]->var_cost = varcost;
//		deleteCus[cusP1]->var_vioTWC = varvioTWC;
//		deleteCus[cusP1]->var_vioTWSP = varvioTWSP;
//		deleteCus[cusP1]->atIT = IT;
//		deleteCus[cusP1]->empty = 0;
//
//		//2. Delete 2+ 2- in the first C2Ctrip: 1+ 1- 2+ 2-
//		varvioTWC = -seg[idVeh].Trip[0].vioTWC;
//		varcost = -(problem->c[cusD1][cusP2] + problem->c[cusP2][cusD2]);
//		if (problem->waitingSOneP[cusP1][nextSP]) varcost += problem->disCWSSP[cusD1][nextSP];
//		else varcost += problem->c[cusD1][nextSP];
//		varcost -= seg[idVeh].Trip[0].connectCost;
//
//		//varvioTWSP = -(seg[idVeh].Trip[0].vioTWSP + seg[idVeh].Trip[1].vioTWSP);
//		varvioTWSP = -seg[idVeh].Trip[1].vioTWSP;
//		//varcost += problem->c[0][nextSP];
//		GoThroughVehicle(idVeh,1, varcost, varvioTWC, varvioTWSP, cStartS, nextSP, seg[idVeh].Trip[1].firstCus);
//		deleteCus[cusP2]->var_vioCAP = 0;
//		deleteCus[cusP2]->var_cost = varcost;
//		deleteCus[cusP2]->var_vioTWC = varvioTWC;
//		deleteCus[cusP2]->var_vioTWSP = varvioTWSP;
//		deleteCus[cusP2]->atIT = IT;
//		deleteCus[cusP2]->empty = 0;
//	}
//	else //firstC2CTrip: 1+ 2+ 2- 1-
//	{
//		cusP2 = curC; cusD2 = nextArr[cusP2];
//		//1. Delete 1+ 1- in the first C2Ctrip: 1+ 2+ 2- 1-
//		varvioTWC = -seg[idVeh].Trip[0].vioTWC;
//		varcost = problem->c[0][cusP2] - (problem->c[0][cusP1] + problem->c[cusP1][cusP2] + problem->c[cusD2][cusD1]);
//		if (problem->waitingSOneP[cusP2][nextSP]) varcost += problem->disCWSSP[cusD2][nextSP];
//		else varcost += problem->c[cusD2][nextSP];
//		varcost -= seg[idVeh].Trip[0].connectCost;
//
//		//varvioTWSP = -(seg[idVeh].Trip[0].vioTWSP + seg[idVeh].Trip[1].vioTWSP);
//		varvioTWSP = -seg[idVeh].Trip[1].vioTWSP;
//		//varcost += problem->c[0][nextSP];
//		GoThroughVehicle(idVeh,1, varcost, varvioTWC, varvioTWSP, cStartS, nextSP, seg[idVeh].Trip[1].firstCus);
//		deleteCus[cusP1]->var_vioCAP = -seg[idVeh].Trip[0].vioCAP;
//		deleteCus[cusP1]->var_cost = varcost;
//		deleteCus[cusP1]->var_vioTWC = varvioTWC;
//		deleteCus[cusP1]->var_vioTWSP = varvioTWSP;
//		deleteCus[cusP1]->atIT = IT;
//		deleteCus[cusP1]->empty = 0;
//
//		//2. Delete 2+ 2- in the first C2Ctrip: 1+ 2+ 2- 1-
//		varvioTWC = -seg[idVeh].Trip[0].vioTWC;
//		varcost = problem->c[cusP1][cusD1] -(problem->c[cusP1][cusP2] + problem->c[cusP2][cusD2] + problem->c[cusD2][cusD1]);
//		if (problem->waitingSOneP[cusP1][nextSP])
//		{
//			if (seg[idVeh].Trip[0].waitingS == NO_WS) //before no_WS, now WS
//				varcost += (problem->disCWSSP[cusD1][nextSP] - problem->c[cusD1][nextSP]);
//		}
//		else
//		{
//			if (seg[idVeh].Trip[0].waitingS != NO_WS) //before WS, now NO_WS
//				varcost += (problem->c[cusD1][nextSP] - problem->disCWSSP[cusD1][nextSP]);
//		}
//		//varvioTWSP = -(seg[idVeh].Trip[0].vioTWSP + seg[idVeh].Trip[1].vioTWSP);
//		varvioTWSP = -seg[idVeh].Trip[1].vioTWSP;
//		//varcost += problem->c[0][nextSP];
//		GoThroughVehicle(idVeh,1, varcost, varvioTWC, varvioTWSP, cStartS, nextSP, seg[idVeh].Trip[1].firstCus);
//		deleteCus[cusP2]->var_vioCAP = -seg[idVeh].Trip[0].vioCAP;
//		deleteCus[cusP2]->var_cost = varcost;
//		deleteCus[cusP2]->var_vioTWC = varvioTWC;
//		deleteCus[cusP2]->var_vioTWSP = varvioTWSP;
//		deleteCus[cusP2]->atIT = IT;
//		deleteCus[cusP2]->empty = 0;
//	}//end firstC2CTrip: 1+ 2+ 2- 1-
//}
//
//bool Solution::cal_deleteCusC2C_FirstTrip_4Cus_nextD_TillTrip(int idVeh, int i, double &varcost, double &varvioTWC, double &varvioTWSP, int varvioCAP, double &cStartS, int update_idTrip)
//{
//	//10/12/2013: COPY Update_deleteCusArrayC2C_FirstTrip_4Cus_nextD(int idVeh)
//	//i is C2CP
//	int nextSP = seg[idVeh].Trip[0].nextSP;
//   	int	cusP1 = seg[idVeh].Trip[0].firstCus;
//	int curC = nextArr[cusP1];
//	int cusD1 = problem->node[cusP1].delID;
//	int cusP2, cusD2; 
//
//	cStartS = problem->leaveSP[nextSP][4]; //load only at sTW2
//	if (curC == cusD1) //FirstTripC2C: 1+ 1- 2+ 2-
//	{
//		cusP2 = nextArr[cusD1]; cusD2 = nextArr[cusP2];
//		if (i == cusP1)	//1. Delete 1+ 1- in the first C2Ctrip: 1+ 1- 2+ 2-
//		{
//			varvioTWC -= seg[idVeh].Trip[0].vioTWC;
//			varcost += (problem->c[0][cusP2] - (problem->c[0][cusP1] + problem->c[cusP1][cusD1] + problem->c[cusD1][cusP2]));
//			if (problem->waitingSOneP[cusP2][nextSP])
//			{
//				if (seg[idVeh].Trip[0].waitingS == NO_WS) //before no_WS, now WS
//					varcost += (problem->disCWSSP[cusD2][nextSP] - problem->c[cusD2][nextSP]);
//			}
//			else
//			{
//				if (seg[idVeh].Trip[0].waitingS != NO_WS) //before WS, now NO_WS
//					varcost += (problem->c[cusD2][nextSP] - problem->disCWSSP[cusD2][nextSP]);
//			}
//			varvioTWSP -= seg[idVeh].Trip[1].vioTWSP;
//			//varcost += problem->c[0][nextSP];
//			//Quangnn+-
//			return 0;//GoThroughVehicle(idVeh,1,update_idTrip,varcost,varvioTWC,varvioTWSP,cStartS,nextSP,seg[idVeh].Trip[1].firstCus);
//		}
//		else //2. Delete 2+ 2- in the first C2Ctrip: 1+ 1- 2+ 2-
//		{
//			//i is cusP2
//			varvioTWC -= seg[idVeh].Trip[0].vioTWC;
//			varcost -= (problem->c[cusD1][cusP2] + problem->c[cusP2][cusD2]);
//			if (problem->waitingSOneP[cusP1][nextSP]) varcost += problem->disCWSSP[cusD1][nextSP];
//			else varcost += problem->c[cusD1][nextSP];
//			varcost -= seg[idVeh].Trip[0].connectCost;
//
//			varvioTWSP -= seg[idVeh].Trip[1].vioTWSP;
//			//varcost += problem->c[0][nextSP];
//			//Quangnn+-
//			return 0;//GoThroughVehicle(idVeh,1,update_idTrip,varcost,varvioTWC,varvioTWSP,cStartS,nextSP,seg[idVeh].Trip[1].firstCus);
//		}
//	}
//	else //firstC2CTrip: 1+ 2+ 2- 1-
//	{
//		cusP2 = curC; cusD2 = nextArr[cusP2];
//		if (i == cusP1) //1. Delete 1+ 1- in the first C2Ctrip: 1+ 2+ 2- 1-
//		{
//			varvioTWC -= seg[idVeh].Trip[0].vioTWC;
//			varcost += (problem->c[0][cusP2] - (problem->c[0][cusP1] + problem->c[cusP1][cusP2] + problem->c[cusD2][cusD1]));
//			if (problem->waitingSOneP[cusP2][nextSP]) varcost += problem->disCWSSP[cusD2][nextSP];
//			else varcost += problem->c[cusD2][nextSP];
//			varcost -= seg[idVeh].Trip[0].connectCost;
//
//			varvioTWSP -= seg[idVeh].Trip[1].vioTWSP;
//			//varcost += problem->c[0][nextSP];
//			//Quangnn+-
//			return 0;//GoThroughVehicle(idVeh,1,update_idTrip, varcost, varvioTWC, varvioTWSP, cStartS, nextSP, seg[idVeh].Trip[1].firstCus);
//		}
//		else //2. Delete 2+ 2- in the first C2Ctrip: 1+ 2+ 2- 1-
//		{
//			varvioTWC -= seg[idVeh].Trip[0].vioTWC;
//    		varcost += (problem->c[cusP1][cusD1] -(problem->c[cusP1][cusP2] + problem->c[cusP2][cusD2] + problem->c[cusD2][cusD1]));
//			if (problem->waitingSOneP[cusP1][nextSP])
//			{
//				if (seg[idVeh].Trip[0].waitingS == NO_WS) //before no_WS, now WS
//					varcost += (problem->disCWSSP[cusD1][nextSP] - problem->c[cusD1][nextSP]);
//			}
//			else
//			{
//				if (seg[idVeh].Trip[0].waitingS != NO_WS) //before WS, now NO_WS
//					varcost += (problem->c[cusD1][nextSP] - problem->disCWSSP[cusD1][nextSP]);
//			}
//			varvioTWSP -= seg[idVeh].Trip[1].vioTWSP;
//			//varcost += problem->c[0][nextSP];
//			//Quangnn+-
//			return 0;//GoThroughVehicle(idVeh,1, update_idTrip, varcost, varvioTWC, varvioTWSP, cStartS, nextSP, seg[idVeh].Trip[1].firstCus);
//		}
//	}//end firstC2CTrip: 1+ 2+ 2- 1-
//}
//
//void Solution::Update_deleteCusC2CTrip_FirstTrip_4Cus_nextD(int idVeh, int pre_deletednode,int deletednode, int next_deletednode, int nextSP,int update_idTrip)
//{
//	//COPY Update_deleteCusArrayC2C_FirstTrip_4Cus_nextD.
//	//15/12/2013: delete deletednode and its delID from first trip of vehicle, and update all information of vehicle after deleteion
//	int delID = problem->node[deletednode].delID;
//	int lastCOLD = seg[idVeh].Trip[0].lastCus;
//	double varcost;
//
//	double varvioTWC = -seg[idVeh].Trip[0].vioTWC;
//	int varvioCAP = -seg[idVeh].Trip[0].vioCAP;
//	seg[idVeh].Trip[0].vioTWC = 0; seg[idVeh].Trip[0].vioCAP = 0;
//
//	if (pre_deletednode < 0)
//	{
//		if (next_deletednode == delID) //FirstTripC2C: [1+ 1-] 2+ 2-
//		{
//			//1. Delete 1+ 1- in the first C2Ctrip: 1+ 1- 2+ 2-
//			int cusP2 = nextArr[delID]; int cusD2 = nextArr[cusP2];
//			startS[cusP2] = problem->startSOneP[cusP2][nextSP];
//			depart[cusP2] = startS[cusP2] + problem->node[cusP2].duration;
//			startS[cusD2] = problem->startSOneP[cusD2][nextSP];
//			depart[cusD2] = startS[cusD2] + problem->node[cusD2].duration;
//			vioTWCus[cusP2] =0; FvioTWCus[cusP2] = 0; BvioTWCus[cusP2] = 0; pos[cusP2] = 1;
//			vioTWCus[cusD2] = 0; FvioTWCus[cusD2] = 0; BvioTWCus[cusD2] = 0; pos[cusD2] = 2;
//			//CAPCus, FCAP,BCAP,FvioCAPCus,BvioCAPCus const
//			seg[idVeh].Trip[0].firstCus = cusP2; predArr[cusP2] = -1;
//
//			varcost = problem->c[0][cusP2] - (problem->c[0][deletednode] + problem->c[deletednode][delID] + problem->c[delID][cusP2]);
//			varcost -= seg[idVeh].Trip[0].connectCost;
//			seg[idVeh].Trip[0].endS = depart[cusD2];
//			//seg[idVeh].Trip[0].feasible = 1;
//			UpdateChangeCONNECTAtSP_C2CTrip(idVeh, 0, 1, nextSP, varcost, 0, varvioTWC, varvioCAP, update_idTrip); //for deleteCusC2C
//		}
//		else //FirstTripC2C: 1+ 2+ 2- 1-
//		{
//			int cusP2 = next_deletednode; int cusD2 = nextArr[cusP2];
//			//1. Delete 1+ 1- in the first C2Ctrip: 1+ 2+ 2- 1-
//			startS[cusP2] = problem->startSOneP[cusP2][nextSP];
//			depart[cusP2] = startS[cusP2] + problem->node[cusP2].duration;
//			startS[cusD2] = problem->startSOneP[cusD2][nextSP];
//			depart[cusD2] = startS[cusD2] + problem->node[cusD2].duration;
//			vioTWCus[cusP2] =0; FvioTWCus[cusP2] = 0; BvioTWCus[cusP2] = 0; pos[cusP2] = 1;
//			vioTWCus[cusD2] = 0; FvioTWCus[cusD2] = 0; BvioTWCus[cusD2] = 0; pos[cusD2] = 2;
//			//CAPCus, FCAP,BCAP,FvioCAPCus,BvioCAPCus:
//			CAPCus[cusP2] = problem->node[cusP2].capacity; /*FCAP[cusP2] = CAPCus[cusP2]; BCAP[cusP2] = 0;*/ 
//			FCAP[cusP2] = 0; BCAP[cusP2] = 0;
//			//FvioCAPCus[cusP2] = 0; BvioCAPCus[cusP2] = 0;
//			CAPCus[cusD2] = 0; /*FCAP[cusD2] = 0; BCAP[cusD2] = -problem->node[cusD2].capacity;*/ 
//			FCAP[cusD2] = 0; BCAP[cusD2] = 0;
//			//FvioCAPCus[cusD2] = 0; BvioCAPCus[cusD2] = 0;
//			seg[idVeh].Trip[0].firstCus = cusP2; predArr[cusP2] = -1;
//			seg[idVeh].Trip[0].lastCus = cusD2; nextArr[cusD2] = -1;
//
//			varcost = problem->c[0][cusP2] - (problem->c[0][deletednode] + problem->c[deletednode][cusP2] + problem->c[cusD2][delID]);
//			varcost -= seg[idVeh].Trip[0].connectCost;
//			seg[idVeh].Trip[0].endS = depart[cusD2];
//			//seg[idVeh].Trip[0].feasible = 1;
//			UpdateChangeCONNECTAtSP_C2CTrip(idVeh, 0, 1, nextSP, varcost, 0, varvioTWC, varvioCAP, update_idTrip); //for deleteCusC2C
//		}//end FirstTripC2C: 1+ 2+ 2- 1-
//	}
//	else //deletednode is not the first cus
//	{
//		int next_delID = nextArr[delID];
//		if (next_delID > 0) //FirstTripC2C: 1+ [2+ 2-] 1-
//		{
//			//2. Delete 2+ 2- in the first C2Ctrip: 1+ 2+ 2- 1-
//			int cusP1 = seg[idVeh].Trip[0].firstCus; int cusD1 = problem->node[cusP1].delID;
//			startS[cusP1] = problem->startSOneP[cusP1][nextSP];
//			depart[cusP1] = startS[cusP1] + problem->node[cusP1].duration;
//			startS[cusD1] = problem->startSOneP[cusD1][nextSP];
//			depart[cusD1] = startS[cusD1] + problem->node[cusD1].duration;
//			vioTWCus[cusP1] = 0; FvioTWCus[cusP1] = 0; BvioTWCus[cusP1] = 0; pos[cusP1] = 1;
//			vioTWCus[cusD1] = 0; FvioTWCus[cusD1] = 0; BvioTWCus[cusD1] = 0; pos[cusD1] = 2;
//			//CAPCus, FCAP,BCAP,FvioCAPCus,BvioCAPCus const
//			FCAP[cusD1] = 0; BCAP[cusP1] = 0;
//			//FvioCAPCus[cusD1] = 0; BvioCAPCus[cusP1] = 0;
//			nextArr[cusP1] = cusD1; predArr[cusD1] = cusP1;
//
//			varcost = problem->c[cusP1][cusD1] -(problem->c[cusP1][deletednode] + problem->c[deletednode][next_deletednode] + problem->c[next_deletednode][cusD1]);
//			varcost -= seg[idVeh].Trip[0].connectCost;
//			seg[idVeh].Trip[0].endS = depart[cusD1];
//			//seg[idVeh].Trip[0].feasible = 1;
//			UpdateChangeCONNECTAtSP_C2CTrip(idVeh, 0, 1, nextSP, varcost, 0, varvioTWC, varvioCAP, update_idTrip); //for deleteCusC2C
//		}
//		else //FirstTripC2C: 1+ 1- [2+ 2-]
//		{
//			//2. Delete 2+ 2- in the first C2Ctrip: 1+ 1- 2+ 2-
//			int cusP1 = seg[idVeh].Trip[0].firstCus; int cusD1 = problem->node[cusP1].delID;
//			seg[idVeh].Trip[0].lastCus = cusD1; nextArr[cusD1] = -1;
//			startS[cusP1] = problem->startSOneP[cusP1][nextSP];
//			depart[cusP1] = startS[cusP1] + problem->node[cusP1].duration;
//			startS[cusD1] = problem->startSOneP[cusD1][nextSP];
//			depart[cusD1] = startS[cusD1] + problem->node[cusD1].duration;
//			vioTWCus[cusP1] =0; FvioTWCus[cusP1] = 0; BvioTWCus[cusP1] = 0; pos[cusP1] = 1;
//			vioTWCus[cusD1] = 0; FvioTWCus[cusD1] = 0; BvioTWCus[cusD1] = 0; pos[cusD1] = 2;
//			//CAPCus, FCAP,BCAP,FvioCAPCus,BvioCAPCus const
//
//			varcost = -(problem->c[pre_deletednode][deletednode] + problem->c[deletednode][next_deletednode]);
//			varcost -= seg[idVeh].Trip[0].connectCost;
//			seg[idVeh].Trip[0].endS = depart[cusD1];
//			//seg[idVeh].Trip[0].feasible = 1;
//			UpdateChangeCONNECTAtSP_C2CTrip(idVeh, 0, 1, nextSP, varcost, 0, varvioTWC, varvioCAP, update_idTrip); //for deleteCusC2C
//		}//end FirstTripC2C: 1+ 1- [2+ 2-]
//	}//END deletednode is not the first cus
//}
//
//
//void Solution::Update_deleteCusArrayC2C_FirstMiddleTrip(int idVeh, int idTrip) //(idVeh, idTrip) > 2 customers
//{
//	//5/12/2013: (idVeh, idTrip) > 2 customers
//	int lastTrip = seg[idVeh].numTrips-1;
//	int lastCSP_preT; 
//	double cStartS;
//	if (idTrip == 0)
//	{
//		lastCSP_preT = 0;
//		cStartS = 0;
//	}
//	else
//	{
//		int preT = idTrip - 1; 
//		if (seg[idVeh].Trip[preT].Type == 0) 
//		{
//			lastCSP_preT = seg[idVeh].Trip[preT].assSP;
//			cStartS = seg[idVeh].Trip[preT].leaveSP;
//		}
//		else 
//		{
//			lastCSP_preT = seg[idVeh].Trip[preT].lastCus;
//			cStartS = depart[lastCSP_preT];
//		}	
//	}
//   
//	int nextC,idpre, pre_deletednode, varvioCAP, CapVehCus, delID;
//	double varvioTWC, cArrTime, temp, varcost, varvioTWSP;
//	bool contTW, contCAP;
//
//	int nextT = idTrip + 1;
//	int firstC_nextT = seg[idVeh].Trip[nextT].firstCus;
//	int lastC = seg[idVeh].Trip[idTrip].lastCus;
//	if (seg[idVeh].Trip[nextT].Type == 1)
//	{
//		//1. Delete the first C2C order: nextT is DTrip
//		int nextSP = seg[idVeh].Trip[nextT].assSP;
//		varvioTWC = 0; varvioCAP = 0; varvioTWSP = 0; 
//		int deletednode = seg[idVeh].Trip[idTrip].firstCus;
//		deleteCus[deletednode]->empty = 0;
//		deleteCus[deletednode]->atIT = IT;
//		delID = problem->node[deletednode].delID; idpre = nextArr[deletednode]; 
//		if (delID == idpre)
//		{
//			nextC = nextArr[delID]; //for sure nextC > 0: preC1 - deletednode - delID - nextC....
//			varcost = problem->c[lastCSP_preT][nextC] - (problem->c[lastCSP_preT][deletednode] + problem->c[deletednode][delID] + problem->c[delID][nextC]);
//			CapVehCus = 0;
//			contCAP = 1; contTW = 1;
//			GoThroughLegC2C(lastCSP_preT,nextC,lastC,cStartS,CapVehCus,varvioCAP,varvioTWC,contCAP,contTW);
//			if (contTW)
//			{
//				//cStartS is now the new depart of lastCus of C2CTrip
//				if (calChangeCONNECTAtSP_C2CTrip(lastC,idVeh,idTrip,nextT,cStartS,varvioTWSP,varcost) == 0)
//                    GoThroughVehicle(idVeh, nextT, varcost, varvioTWC, varvioTWSP, cStartS, nextSP, firstC_nextT);
//			}
//			deleteCus[deletednode]->var_vioTWC = varvioTWC -(vioTWCus[deletednode] + vioTWCus[delID]);
//			deleteCus[deletednode]->var_vioCAP = varvioCAP - (vioCAPCus[deletednode] + vioCAPCus[delID]);
//			deleteCus[deletednode]->var_vioTWSP = varvioTWSP;
//			deleteCus[deletednode]->var_cost = varcost;
//		}
//		else //delID != nextArr[deletednode]: deletednode is the first cus of C2C (nextT is DTrip)
//		{
//			varcost = problem->c[lastCSP_preT][idpre] - (problem->c[lastCSP_preT][deletednode] + problem->c[deletednode][idpre]);
//			CapVehCus = 0;
//			int pre_delID = predArr[delID];
//			contCAP = 1; contTW = 1;
//			GoThroughLegC2C(lastCSP_preT,idpre,pre_delID,cStartS,CapVehCus,varvioCAP,varvioTWC,contCAP,contTW);
//			nextC = nextArr[delID];
//			//because deletednode is the first Order of the trip --> capacity of vehicle at delID = 0:
//			//deleteCus[deletednode]->var_vioCAP = varvioCAP;//varvioCAP = total(vioCAPNEW - vioCAPOLD) from newfirstCus to pred[delID]
//			//deleteCus[deletednode]->var_vioCAP = varvioCAP - (vioCAPCus[deletednode] + vioCAPCus[delID]);//varvioCAP = total(vioCAPNEW - vioCAPOLD) from newfirstCus to pred[delID]
//			if (nextC > 0)
//			{
//				varcost += (problem->c[pre_delID][nextC] - problem->c[pre_delID][delID] - problem->c[delID][nextC]);
//				GoThroughLegC2C_CAP(nextC,lastC,CapVehCus,varvioCAP);
//				deleteCus[deletednode]->var_vioCAP = varvioCAP;//varvioCAP = total(vioCAPNEW - vioCAPOLD) from newfirstCus to pred[delID]
//				//varvioTWSP = 0;
//				idpre = pre_delID;
//				do //now vioTWNEW = total of vioTWCus new from newfirstCustomer of trip to idpre = pred[delID]:
//				{
//					cArrTime = cStartS + problem->c[idpre][nextC]; //arrTime at customer nextC
//					cStartS = PDS_MAX(cArrTime, problem->node[nextC].sTW);
//					temp = cStartS - problem->node[nextC].eTW;
//					if (temp > eps)
//					{
//						varvioTWC += temp; 
//						if (vioTWCus[nextC] > eps) //Update 8/11/2013
//						{
//							varvioTWC -= vioTWCus[nextC]; //till the end of the trip
//							goto Update_FirstC2C;
//						}
//						cStartS = problem->node[nextC].depart;
//					}
//					else
//					{
//						varvioTWC -= vioTWCus[nextC];
//						if (PDSDIF(cStartS,startS[nextC]) == 0) goto Update_FirstC2C;
//						cStartS += problem->node[nextC].duration; 
//					}
//					idpre = nextC; 
//					nextC = nextArr[nextC];
//				}while (nextC > 0);
//				//cStartS is now equal to depart of lastCus of C2C:
//				if (calChangeCONNECTAtSP_C2CTrip(lastC,idVeh,idTrip,nextT,cStartS,varvioTWSP,varcost) == 0)
//                    GoThroughVehicle(idVeh, nextT, varcost, varvioTWC, varvioTWSP, cStartS, nextSP, firstC_nextT);
//				Update_FirstC2C:
//					deleteCus[deletednode]->var_vioTWC = varvioTWC - (vioTWCus[deletednode] + vioTWCus[delID]);
//			}
//			else //delID was the last cus --> now pre_delID is the last cus (nextT is DTrip):
//			{
//				//cStartS is now equal to depart of lastCus of C2C:
//				varcost -= problem->c[pre_delID][delID];
//				varcost -= seg[idVeh].Trip[idTrip].connectCost;
//				deleteCus[deletednode]->var_vioCAP = varvioCAP;//varvioCAP = total(vioCAPNEW - vioCAPOLD) from newfirstCus to pred[delID]
//				if (calChangeCONNECTAtSP_C2CTrip_LastCChanged(pre_delID,idVeh,idTrip,nextT,cStartS,varvioTWSP,varcost) == 0)
//                    GoThroughVehicle(idVeh, nextT, varcost, varvioTWC, varvioTWSP, cStartS, nextSP, firstC_nextT);
//				deleteCus[deletednode]->var_vioTWC = varvioTWC - (vioTWCus[deletednode] + vioTWCus[delID]);
//				deleteCus[deletednode]->var_vioTWSP = varvioTWSP;
//				deleteCus[deletednode]->var_cost = varcost;
//			}//end delID was the last cus --> now pre_delID is the last cus
//		}//end //delID != nextArr[deletednode]: deletednode is the first cus of C2C (lastTrip)
//		deleteCus[deletednode]->atIT = IT;
//
//		//2. Delete the middle C2C order: nextT is DTrip
//		deletednode = nextArr[deletednode];
//		do
//		{
//			while (deletednode > endidC2CP) deletednode = nextArr[deletednode]; //find the next C2CP
//			if (deletednode < 0) break; //finish the trip
//			idpre = predArr[deletednode];
//
//			deleteCus[deletednode]->empty = 0;
//			pre_deletednode = idpre;
//			varvioTWC = 0; varvioCAP = 0; varvioTWSP = 0;
//			nextC = nextArr[deletednode]; delID = problem->node[deletednode].delID;
//			if (delID == nextC) //delID is direct successor of deletednode: nextT is DTrip; deletednode is in the middle of the trip
//			{
//				nextC = nextArr[delID];  
//				if (nextC < 0) // (deletednode and delID) were the last cus of the trip --> now pre_deletednode is the last cus of the trip:
//				{
//					varcost = -(problem->c[pre_deletednode][deletednode] + problem->c[deletednode][delID]);
//					varcost -= seg[idVeh].Trip[idTrip].connectCost;
//					/*
//					if (seg[idVeh].Trip[idTrip].waitingS == NO_WS) varcost -= problem->c[delID][nextSP];
//					else varcost -= problem->disCWSSP[delID][nextSP];*/
//					
//					if (calChangeCONNECTAtSP_C2CTrip_LastCChanged(idpre,idVeh,idTrip,nextT,cStartS,varvioTWSP,varcost) == 0)
//						GoThroughVehicle(idVeh, nextT, varcost, varvioTWC, varvioTWSP, cStartS, nextSP, firstC_nextT);
//					deleteCus[deletednode]->var_vioTWC = varvioTWC - (vioTWCus[deletednode] + vioTWCus[delID]);
//					deleteCus[deletednode]->var_vioTWSP = varvioTWSP;
//					deleteCus[deletednode]->var_cost = varcost;
//					deleteCus[deletednode]->var_vioCAP = 0; //-(vioCAPCus[deletednode] + vioCAPCus[delID]);// FvioCAPCus[pre_deletednode] - seg[idVeh].Trip[idTrip].vioCAP;
//					deleteCus[deletednode]->atIT = IT;
//					break; //finish the trip
//				}
//				else //delID is not the last cus of the trip C2C; delID is direct successor of deletednode; nextT is DTrip
//				{
//					varcost = problem->c[pre_deletednode][nextC] - (problem->c[pre_deletednode][deletednode] + problem->c[deletednode][delID] + problem->c[delID][nextC]);
//					cStartS = depart[pre_deletednode];
//					CapVehCus = CAPCus[pre_deletednode];
//					contCAP = 1; contTW = 1;
//					GoThroughLegC2C(pre_deletednode,nextC,lastC,cStartS,CapVehCus,varvioCAP,varvioTWC,contCAP,contTW);
//					if (contTW) //it means depart[lastCofC2C] has changed
//					{
//						if (calChangeCONNECTAtSP_C2CTrip(lastC,idVeh,idTrip,nextT,cStartS,varvioTWSP,varcost) == 0)
//							GoThroughVehicle(idVeh, nextT, varcost, varvioTWC, varvioTWSP, cStartS, nextSP, firstC_nextT);
//					}
//					deleteCus[deletednode]->var_vioTWC = varvioTWC - (vioTWCus[deletednode] + vioTWCus[delID]);
//					deleteCus[deletednode]->var_vioTWSP = varvioTWSP;
//					deleteCus[deletednode]->var_cost = varcost;
//					deleteCus[deletednode]->var_vioCAP = varvioCAP -(vioCAPCus[deletednode] + vioCAPCus[delID]);
//					deleteCus[deletednode]->atIT = IT;
//				}//end delID is not the last cus of the trip C2C; delID is direct successor of deletednode; nextT is DTrip
//			}
//			else //delID != nextArr[deletednode]: C2CTrip > 2 customers (nextT is DTrip); deletednode is in the middle of trip
//			{
//				varcost = problem->c[pre_deletednode][nextC] - (problem->c[pre_deletednode][deletednode] + problem->c[deletednode][nextC]);
//				cStartS = depart[pre_deletednode];
//				CapVehCus = CAPCus[pre_deletednode];
//				//for sure nextC != delID
//				int pre_delID = predArr[delID];
//				contCAP = 1; contTW = 1;
//				GoThroughLegC2C(pre_deletednode,nextC,pre_delID,cStartS,CapVehCus,varvioCAP,varvioTWC,contCAP,contTW);
//				nextC = nextArr[delID];
//				if (nextC > 0) //checking from nextC till the end of the trip:
//				{
//					varcost += (problem->c[pre_delID][nextC] - problem->c[pre_delID][delID] - problem->c[delID][nextC]);
//					//from nextC till the end of the trip:
//					contCAP = 1; contTW = 1;
//					GoThroughLegC2C(pre_delID,nextC,lastC,cStartS,CapVehCus,varvioCAP,varvioTWC,contCAP,contTW);
//					if (contTW) //depart[lastC_of_C2CTrip] has changed: the case delID != nextArr[deletednode]; nextT is DTrip
//					{
//						if (calChangeCONNECTAtSP_C2CTrip(lastC,idVeh,idTrip,nextT,cStartS,varvioTWSP,varcost) == 0)
//								GoThroughVehicle(idVeh, nextT, varcost, varvioTWC, varvioTWSP, cStartS, nextSP, firstC_nextT);
//					}
//					deleteCus[deletednode]->var_vioTWC = varvioTWC - (vioTWCus[deletednode] + vioTWCus[delID]);
//					deleteCus[deletednode]->var_vioTWSP = varvioTWSP;
//					deleteCus[deletednode]->var_cost = varcost;
//					deleteCus[deletednode]->var_vioCAP = varvioCAP -(vioCAPCus[deletednode] + vioCAPCus[delID]);
//					deleteCus[deletednode]->atIT = IT;
//				}
//				else //delID was the last cus --> now pre_delID is the last cus: the case delID != nextArr[deletednode]; nextT is DTrip
//				{
//					varcost -= (problem->c[pre_delID][delID] + seg[idVeh].Trip[idTrip].connectCost);
//					if (calChangeCONNECTAtSP_C2CTrip_LastCChanged(pre_delID,idVeh,idTrip,nextT,cStartS,varvioTWSP,varcost) == 0)
//						GoThroughVehicle(idVeh, nextT, varcost, varvioTWC, varvioTWSP, cStartS, nextSP, firstC_nextT);
//					deleteCus[deletednode]->var_vioTWC = varvioTWC;
//					deleteCus[deletednode]->var_vioTWSP = varvioTWSP;
//					deleteCus[deletednode]->var_cost = varcost;
//					deleteCus[deletednode]->var_vioCAP =  varvioCAP - vioCAPCus[deletednode]; //because delID was the last cus of the trip --> vioCAPCus[delID] = 0
//					deleteCus[deletednode]->atIT = IT;
//					break; //finish the trip
//				}//end delID was the last cus --> now pre_delID is the last cus
//			}//end delID != nextArr[deletednode]: C2CTrip > 2 customers (nextT is DTrip); deletednode is in the middle of trip
//			//new deletednode:
//			deletednode = nextArr[deletednode];
//		}while (deletednode > 0);
//	}
//	else //if (seg[idVeh].Trip[nextT].Type == 0 || 2)
//	{
//		//1. Delete the first C2C order: nextT is PTrip OR C2C
//		varvioTWC = 0; varvioCAP = 0; varvioTWSP = 0; 
//		int deletednode = seg[idVeh].Trip[idTrip].firstCus;
//		deleteCus[deletednode]->empty = 0;
//		deleteCus[deletednode]->atIT = IT;
//		delID = problem->node[deletednode].delID; idpre = nextArr[deletednode]; 
//		int lastC = seg[idVeh].Trip[idTrip].lastCus;
//
//		if (delID == idpre)
//		{
//			nextC = nextArr[delID]; //for sure nextC > 0: preC1 - deletednode - delID - nextC....
//			varcost = problem->c[lastCSP_preT][nextC] - (problem->c[lastCSP_preT][deletednode] + problem->c[deletednode][delID] + problem->c[delID][nextC]);
//			CapVehCus = 0;
//			contCAP = 1; contTW = 1;
//			GoThroughLegC2C(lastCSP_preT, nextC,lastC,cStartS,CapVehCus,varvioCAP,varvioTWC,contCAP,contTW);
//			if (contTW)
//			{
//				//cStartS is now the new depart of lastCus of C2CTrip
//                GoThroughVehicle(idVeh, nextT, varcost, varvioTWC, varvioTWSP, cStartS, lastC, firstC_nextT);
//			}
//			deleteCus[deletednode]->var_vioTWC = varvioTWC - (vioTWCus[deletednode] + vioTWCus[delID]);
//			deleteCus[deletednode]->var_vioCAP = varvioCAP - (vioCAPCus[deletednode] + vioCAPCus[delID]);
//			deleteCus[deletednode]->var_vioTWSP = varvioTWSP;
//			deleteCus[deletednode]->var_cost = varcost;
//		}
//		else //delID != nextArr[deletednode]: deletednode is the first cus of C2C (nextT is PTrip OR C2C)
//		{
//			varcost = problem->c[lastCSP_preT][idpre] - (problem->c[lastCSP_preT][deletednode] + problem->c[deletednode][idpre]);
//			CapVehCus = 0;
//			int pre_delID = predArr[delID]; //for sure idpre != delID
//			contCAP = 1; contTW = 1;
//			GoThroughLegC2C(lastCSP_preT,idpre,pre_delID,cStartS,CapVehCus,varvioCAP,varvioTWC,contCAP,contTW);
//			//now delID:
//			nextC = nextArr[delID];
//			//because deletednode is the first Order of the trip --> capacity of vehicle at delID = 0:
//			deleteCus[deletednode]->var_vioCAP = varvioCAP;// - (vioCAPCus[deletednode] + vioCAPCus[delID]);//varvioCAP = total(vioCAPNEW - vioCAPOLD) from newfirstCus to pred[delID]
//			if (nextC > 0)
//			{
//				varcost += (problem->c[pre_delID][nextC] - problem->c[pre_delID][delID] - problem->c[delID][nextC]);
//				GoThroughLegC2C_CAP(nextC,lastC,CapVehCus,varvioCAP);
//				//varvioTWSP = 0;
//				idpre = pre_delID;
//				do //now vioTWNEW = total of vioTWCus new from newfirstCustomer of trip to idpre = pred[delID]:
//				{
//					cArrTime = cStartS + problem->c[idpre][nextC]; //arrTime at customer nextC
//					cStartS = PDS_MAX(cArrTime, problem->node[nextC].sTW);
//					temp = cStartS - problem->node[nextC].eTW;
//					if (temp > eps)
//					{
//						varvioTWC += temp; 
//						if (vioTWCus[nextC] > eps) //Update 8/11/2013
//						{
//							varvioTWC -= vioTWCus[nextC]; //till the end of the trip
//							goto Update_FirstC2C_nextPTripORC2C;
//						}
//						cStartS = problem->node[nextC].depart;
//					}
//					else 
//					{
//						varvioTWC -= vioTWCus[nextC];
//						if (PDSDIF(cStartS, startS[nextC]) == 0) goto Update_FirstC2C_nextPTripORC2C;
//						cStartS += problem->node[nextC].duration; 
//					}
//					idpre = nextC; 
//					nextC = nextArr[nextC];
//				}while (nextC > 0);
//				//cStartS is now equal to depart of lastCus of C2C:
//                GoThroughVehicle(idVeh, nextT, varcost, varvioTWC, varvioTWSP, cStartS, lastC, firstC_nextT);
//				Update_FirstC2C_nextPTripORC2C:
//					deleteCus[deletednode]->var_vioTWC = varvioTWC - (vioTWCus[deletednode] + vioTWCus[delID]);
//			}
//			else //delID was the last cus --> now pre_delID is the last cus (nextT is PTrip OR C2C):
//			{
//				//cStartS is now equal to depart of lastCus of C2C:
//				varcost -= (problem->c[pre_delID][delID] + seg[idVeh].Trip[idTrip].connectCost);
//				//varvioTWSP = 0;
//				varcost += problem->c[pre_delID][firstC_nextT];
//                GoThroughVehicle(idVeh, nextT, varcost, varvioTWC, varvioTWSP, cStartS, pre_delID, firstC_nextT);
//				deleteCus[deletednode]->var_vioTWC = varvioTWC - (vioTWCus[deletednode] + vioTWCus[delID]);
//				deleteCus[deletednode]->var_vioTWSP = varvioTWSP;
//				deleteCus[deletednode]->var_cost = varcost;
//			}//end delID was the last cus --> now pre_delID is the last cus
//		}//end //delID != nextArr[deletednode]: deletednode is the first cus of C2C (lastTrip)
//		deleteCus[deletednode]->atIT = IT;
//
//		//2. Delete the middle C2C order: nextT is PTrip OR C2C
//		deletednode = nextArr[deletednode];
//		do
//		{
//			while (deletednode > endidC2CP) deletednode = nextArr[deletednode]; //find the next C2CP
//			if (deletednode < 0) break; //finish the trip
//			idpre = predArr[deletednode];
//
//			deleteCus[deletednode]->empty = 0;
//			pre_deletednode = idpre;
//			varvioTWC = 0; varvioCAP = 0; varvioTWSP = 0;
//			nextC = nextArr[deletednode]; delID = problem->node[deletednode].delID;
//			if (delID == nextC) //delID is direct successor of deletednode: nextT is PTrip OR C2C; deletednode is in the middle of the trip
//			{
//				nextC = nextArr[delID];  
//				if (nextC < 0) // (deletednode and delID) were the last cus of the trip --> now pre_deletednode is the last cus of the trip:
//				{
//					varcost = -(problem->c[pre_deletednode][deletednode] + problem->c[deletednode][delID]);
//					varcost -= seg[idVeh].Trip[idTrip].connectCost;
//					/*
//					if (seg[idVeh].Trip[idTrip].waitingS == NO_WS) varcost -= problem->c[delID][nextSP];
//					else varcost -= problem->disCWSSP[delID][nextSP];*/
//					varcost += problem->c[idpre][firstC_nextT];
//					GoThroughVehicle(idVeh, nextT, varcost, varvioTWC, varvioTWSP, cStartS, idpre, firstC_nextT);
//					deleteCus[deletednode]->var_vioTWC = varvioTWC - (vioTWCus[deletednode] + vioTWCus[delID]);
//					deleteCus[deletednode]->var_vioTWSP = varvioTWSP;
//					deleteCus[deletednode]->var_cost = varcost;
//					deleteCus[deletednode]->var_vioCAP = 0;//FvioCAPCus[pre_deletednode] - vioCapOLD;
//					deleteCus[deletednode]->atIT = IT;
//					break; //finish the trip
//				}
//				else //delID is not the last cus of the trip C2C; delID is direct successor of deletednode; nextT is DTrip
//				{
//					varcost = problem->c[pre_deletednode][nextC] - (problem->c[pre_deletednode][deletednode] + problem->c[deletednode][delID] + problem->c[delID][nextC]);
//					cStartS = depart[pre_deletednode];
//					CapVehCus = CAPCus[pre_deletednode];
//					contTW = 1; contCAP = 1;
//					GoThroughLegC2C(pre_deletednode,nextC,lastC,cStartS,CapVehCus,varvioCAP,varvioTWC,contCAP,contTW);
//					if (contTW) //it means depart[lastCofC2C] has changed
//					{
//						GoThroughVehicle(idVeh, nextT, varcost, varvioTWC, varvioTWSP, cStartS, lastC, firstC_nextT);
//					}
//					deleteCus[deletednode]->var_vioTWC = varvioTWC - (vioTWCus[deletednode] + vioTWCus[delID]);
//					deleteCus[deletednode]->var_vioTWSP = varvioTWSP;
//					deleteCus[deletednode]->var_cost = varcost;
//					deleteCus[deletednode]->var_vioCAP = varvioCAP - (vioCAPCus[deletednode] + vioCAPCus[delID]);
//					deleteCus[deletednode]->atIT = IT;
//				}//end delID is not the last cus of the trip C2C; delID is direct successor of deletednode; nextT is PTrip OR C2C
//			}
//			else //delID != nextArr[deletednode]: C2CTrip > 2 customers (nextT is PTrip OR C2C); deletednode is in the middle of trip
//			{
//				varcost = problem->c[pre_deletednode][nextC] - (problem->c[pre_deletednode][deletednode] + problem->c[deletednode][nextC]);
//				cStartS = depart[pre_deletednode];
//				CapVehCus = CAPCus[pre_deletednode];
//				//for sure nextC != delID
//				int pre_delID = predArr[delID];
//				contCAP = 1; contTW = 1;
//				GoThroughLegC2C(pre_deletednode,nextC,pre_delID,cStartS,CapVehCus,varvioCAP,varvioTWC,contCAP,contTW);
//				//now delID:
//				nextC = nextArr[delID];
//				if (nextC > 0) //checking from nextC till the end of the trip:
//				{
//					varcost += (problem->c[pre_delID][nextC] - problem->c[pre_delID][delID] - problem->c[delID][nextC]);
//					//from nextC till the end of the trip:
//					contCAP = 1; contTW = 1;
//					GoThroughLegC2C(pre_delID,nextC,lastC,cStartS,CapVehCus,varvioCAP,varvioTWC,contCAP,contTW);
//					if (contTW) //depart[lastC_of_C2CTrip] has changed: the case delID != nextArr[deletednode]; nextT is PTrip OR C2C
//					{
//						GoThroughVehicle(idVeh, nextT, varcost, varvioTWC, varvioTWSP, cStartS, lastC, firstC_nextT);
//					}
//					deleteCus[deletednode]->var_vioTWC = varvioTWC - (vioTWCus[deletednode] + vioTWCus[delID]);
//					deleteCus[deletednode]->var_vioTWSP = varvioTWSP;
//					deleteCus[deletednode]->var_cost = varcost;
//					deleteCus[deletednode]->var_vioCAP = varvioCAP - (vioCAPCus[deletednode] + vioCAPCus[delID]);
//					deleteCus[deletednode]->atIT = IT;
//				}
//				else //delID was the last cus --> now pre_delID is the last cus: the case delID != nextArr[deletednode]; nextT is PTrip OR C2C
//				{
//					varcost -= (problem->c[pre_delID][delID] + seg[idVeh].Trip[idTrip].connectCost);
//					varcost += problem->c[pre_delID][firstC_nextT];
//					GoThroughVehicle(idVeh, nextT, varcost, varvioTWC, varvioTWSP, cStartS, pre_delID, firstC_nextT);
//
//					deleteCus[deletednode]->var_vioTWC = varvioTWC - (vioTWCus[deletednode] + vioTWCus[delID]);
//					deleteCus[deletednode]->var_vioTWSP = varvioTWSP;
//					deleteCus[deletednode]->var_cost = varcost;
//					deleteCus[deletednode]->var_vioCAP =  varvioCAP - vioCAPCus[deletednode];// + vioCAPCus[delID]); --delID was the last cus --> vioCAPCus[delID] = 0
//					deleteCus[deletednode]->atIT = IT;
//					break; //finish the trip
//				}//end delID was the last cus --> now pre_delID is the last cus
//			}//end delID != nextArr[deletednode]: C2CTrip > 2 customers (nextT is PTrip OR C2C); deletednode is in the middle of trip
//			//new deletednode:
//			deletednode = nextArr[deletednode];
//		}while (deletednode > 0);
//	}//end if (seg[idVeh].Trip[nextT].Type == 0 || 2)
//
//}
//
//
//bool Solution::cal_deleteCusArrayC2C_FirstMiddleTrip_TillTrip(int idVeh, int idTrip, int deletednode, double &varcost, double &varvioTWC, double &varvioTWSP, int &varvioCAP, double &cStartS, int update_idTrip)
//{
//  /*COPY  void Update_deleteCusArrayC2C_FirstMiddleTrip(int idVeh, int idTrip);
//  //11/12/2013: delete C2CP deletednode and delID of deletednode from (idVeh, idTrip), calculate varcost, varvioTWC, varvioTWSP, varvioCAP till the update_idTrip
//	            return 1 if depart last item of (idVeh, update_idTrip) doesn't change; 0 otherwise [cStartS = depart of it]
//  If idtrip = 0 --> (it has > 2 customers); AND (it is not = 4 customers + nextSP > 0)*/
//
//  int lastCSP_preT, idpre, CapVehCus, nextC;
//  int delID = problem->node[deletednode].delID; idpre = nextArr[deletednode]; 
//  bool contTW, contCAP;
//  int nextSP = seg[idVeh].Trip[idTrip].nextSP; int nextT = idTrip + 1;
//  double temp, cArrTime;
//  int lastC = seg[idVeh].Trip[idTrip].lastCus;
//  int firstC_nextT = seg[idVeh].Trip[nextT].firstCus;
//  int numTrips_update = update_idTrip - idTrip;
//
//  varvioTWC -= (vioTWCus[deletednode] + vioTWCus[delID]);
//
//  if (deletednode == seg[idVeh].Trip[idTrip].firstCus)
//  {
//		if (idTrip == 0)
//		{
//			lastCSP_preT = 0;
//			cStartS = 0;
//		}
//		else
//		{
//			int preT = idTrip - 1; 
//			if (seg[idVeh].Trip[preT].Type == 0) 
//			{
//				lastCSP_preT = seg[idVeh].Trip[preT].assSP;
//				cStartS = seg[idVeh].Trip[preT].leaveSP;
//			}
//			else 
//			{
//				lastCSP_preT = seg[idVeh].Trip[preT].lastCus;
//				cStartS = depart[lastCSP_preT];
//			}	
//		}
//		if (delID == idpre) // deletednode is the first cus; its delID is its direct successor 
//		{
//			nextC = nextArr[delID]; //for sure nextC > 0: preC1 - deletednode - delID - nextC....
//			varcost += (problem->c[lastCSP_preT][nextC] - (problem->c[lastCSP_preT][deletednode] + problem->c[deletednode][delID] + problem->c[delID][nextC]));
//			CapVehCus = 0; contTW = 1; contCAP = 1;
//			GoThroughLegC2C(lastCSP_preT,nextC,lastC,cStartS,CapVehCus,varvioCAP,varvioTWC,contCAP,contTW);
//			//varvioCAP -= (vioCAPCus[deletednode] + vioCAPCus[delID]); don't need because deletednode and delID were the first cus of the trip  
//			
//			if (nextSP > 0) //nextT is dTrip
//			{
//				if (contTW)
//				{
//					//cStartS is now the new depart of lastCus of C2CTrip
//					if (calChangeCONNECTAtSP_C2CTrip(lastC,idVeh,idTrip,nextT,cStartS,varvioTWSP,varcost) == 0)
//					{
//						//cout<<"1) nextSP = "<<nextSP<<"; firstC_nextT = "<<firstC_nextT<<endl;
//						//Quangnn+-
//						return 0;//GoThroughVehicle(idVeh, nextT, numTrips_update, varcost, varvioTWC, varvioTWSP, cStartS, nextSP, firstC_nextT);
//					}
//					else return 1;
//				}
//				else return 1;
//			}
//			else //nextT is C2C or PTrip
//			{
//				if (contTW)
//				{
//					//Quangnn+-
//					return 0;//GoThroughVehicle(idVeh, nextT,numTrips_update, varcost, varvioTWC, varvioTWSP, cStartS, lastC, firstC_nextT);
//				}
//				else return 1;
//			}//end nextT is C2C or PTrip
//		}
//		else // deletednode is the first cus; its delID is NOT its direct successor 
//		{
//			varcost += (problem->c[lastCSP_preT][idpre] - (problem->c[lastCSP_preT][deletednode] + problem->c[deletednode][idpre]));
//			CapVehCus = 0;
//			int pre_delID = predArr[delID]; //forsure idpre != delID
//			contCAP = 1; contTW = 1;
//			GoThroughLegC2C(lastCSP_preT,idpre,pre_delID,cStartS,CapVehCus,varvioCAP,varvioTWC,contCAP,contTW);
//			//now delID:
//			nextC = nextArr[delID];
//			//because deletednode is the first Order of the trip --> capacity of vehicle at delID = 0:
//			//varvioCAP -= (vioCAPCus[deletednode] + vioCAPCus[delID]); //don't need  
//
//			if (nextC > 0)
//			{
//				varcost += (problem->c[pre_delID][nextC] - problem->c[pre_delID][delID] - problem->c[delID][nextC]);
//				GoThroughLegC2C_CAP(nextC,lastC,CapVehCus,varvioCAP);
//				idpre = pre_delID;
//				do //now vioTWNEW = total of vioTWCus new from newfirstCustomer of trip to idpre = pred[delID]:
//				{
//					cArrTime = cStartS + problem->c[idpre][nextC]; //arrTime at customer nextC
//					cStartS = PDS_MAX(cArrTime, problem->node[nextC].sTW);
//					temp = cStartS - problem->node[nextC].eTW;
//					if (temp > eps)
//					{
//						varvioTWC += temp; 
//						if (vioTWCus[nextC] > eps) //Update 8/11/2013
//						{
//							varvioTWC -= vioTWCus[nextC]; //till the end of the trip
//							return 1;
//						}
//						cStartS = problem->node[nextC].depart;
//					}
//					else
//					{
//						varvioTWC -= vioTWCus[nextC];
//						if (PDSDIF(cStartS,startS[nextC]) == 0) return 1;
//						cStartS += problem->node[nextC].duration; 
//					}
//					idpre = nextC; 
//					nextC = nextArr[nextC];
//				}while (nextC > 0);
//				//cStartS is now equal to depart of lastCus of C2C:
//				if (nextSP > 0)
//				{
//					if (calChangeCONNECTAtSP_C2CTrip(lastC,idVeh,idTrip,nextT,cStartS,varvioTWSP,varcost) == 0){
//						//Quangnn+-
//						return 0;//GoThroughVehicle(idVeh,nextT,numTrips_update,varcost, varvioTWC, varvioTWSP, cStartS, nextSP, firstC_nextT);
//					}
//					else return 1;
//				}
//				else{
//					//Quangnn+-
//					return 0;//GoThroughVehicle(idVeh, nextT, numTrips_update, varcost, varvioTWC, varvioTWSP, cStartS, lastC, firstC_nextT);
//				}
//			}
//			else //delID was the last cus --> now pre_delID is the last cus:
//			{
//				//cStartS is now equal to depart of lastCus of C2C:
//				varcost -= problem->c[pre_delID][delID];
//				varcost -= seg[idVeh].Trip[idTrip].connectCost;
//				if (nextSP > 0)
//				{
//					if (calChangeCONNECTAtSP_C2CTrip_LastCChanged(pre_delID,idVeh,idTrip,nextT,cStartS,varvioTWSP,varcost) == 0){
//						//Quangnn+-
//						return 0;//GoThroughVehicle(idVeh, nextT, numTrips_update, varcost, varvioTWC, varvioTWSP, cStartS, nextSP, firstC_nextT);
//					}
//					else return 1;
//				}
//				else
//				{
//					varcost += problem->c[pre_delID][firstC_nextT];
//					//Quangnn+-
//                    return 0;//GoThroughVehicle(idVeh, nextT, numTrips_update, varcost, varvioTWC, varvioTWSP, cStartS, pre_delID, firstC_nextT);
//				}
//			}//end delID was the last cus --> now pre_delID is the last cus
//		}// end deletednode is the first cus; its delID is NOT its direct successor 
//  }
//  else //deletednode is not the first cus of the trip
//  {
//		idpre = predArr[deletednode];
//		nextC = nextArr[deletednode]; 
//		if (delID == nextC) //delID is direct successor of deletednode: deletednode is in the middle/last of the trip
//		{
//				nextC = nextArr[delID];  
//				if (nextC < 0) // (deletednode and delID) were the last cus of the trip --> now idpre is the last cus of the trip:
//				{
//					//dont need to cal varvioCAP
//					varcost = -(problem->c[idpre][deletednode] + problem->c[deletednode][delID]);
//					varcost -= seg[idVeh].Trip[idTrip].connectCost;
//					if (nextSP > 0)
//					{
//						if (calChangeCONNECTAtSP_C2CTrip_LastCChanged(idpre,idVeh,idTrip,nextT,cStartS,varvioTWSP,varcost) == 0){
//						  //Quangnn+-
//							return 0;//GoThroughVehicle(idVeh, nextT, numTrips_update, varcost, varvioTWC, varvioTWSP, cStartS, nextSP, firstC_nextT);
//						}
//						else return 1;
//					}
//					else
//					{
//						varcost += problem->c[idpre][firstC_nextT];
//						//Quangnn+-
//					    return 0;//GoThroughVehicle(idVeh, nextT, numTrips_update, varcost, varvioTWC, varvioTWSP, cStartS, idpre, firstC_nextT);
//					}
//				}
//				else //delID is not the last cus of the trip C2C; delID is direct successor of deletednode; 
//				{
//					varcost = problem->c[idpre][nextC] - (problem->c[idpre][deletednode] + problem->c[deletednode][delID] + problem->c[delID][nextC]);
//					cStartS = depart[idpre];
//					CapVehCus = CAPCus[idpre];
//					contCAP = 1; contTW = 1;
//					GoThroughLegC2C(idpre,nextC,lastC,cStartS,CapVehCus,varvioCAP,varvioTWC,contCAP,contTW);
//					varvioCAP -= (vioCAPCus[deletednode] + vioCAPCus[delID]);
//					if (contTW) //it means depart[lastCofC2C] has changed
//					{
//						if (nextSP > 0)
//						{
//							if (calChangeCONNECTAtSP_C2CTrip(lastC,idVeh,idTrip,nextT,cStartS,varvioTWSP,varcost) == 0){
//							  //Quangnn+-
//								return 0;//GoThroughVehicle(idVeh, nextT, numTrips_update, varcost, varvioTWC, varvioTWSP, cStartS, nextSP, firstC_nextT);
//							}
//							else return 1;
//						}
//						else{
//							//Quangnn+-
//							 return	0;//GoThroughVehicle(idVeh, nextT, numTrips_update, varcost, varvioTWC, varvioTWSP, cStartS, lastC, firstC_nextT);
//						}
//					}
//					else return 1;
//				}//end delID is not the last cus of the trip C2C; delID is direct successor of deletednode; nextT is DTrip
//		}
//		else //delID is NOT direct successor of deletednode: deletednode is in the middle/last of the trip
//		{
//				varcost = problem->c[idpre][nextC] - (problem->c[idpre][deletednode] + problem->c[deletednode][nextC]);
//				cStartS = depart[idpre];
//				CapVehCus = CAPCus[idpre];
//				//for sure nextC != delID
//				int pre_delID = predArr[delID];
//				contCAP = 1; contTW = 1;
//				GoThroughLegC2C(idpre,nextC,pre_delID,cStartS,CapVehCus,varvioCAP,varvioTWC,contCAP,contTW);
//				//now delID:
//				nextC = nextArr[delID];
//				if (nextC > 0) //checking from nextC till the end of the trip:
//				{
//					varcost += (problem->c[pre_delID][nextC] - problem->c[pre_delID][delID] - problem->c[delID][nextC]);
//					//from nextC till the end of the trip:
//					contCAP = 1; contTW = 1;
//					GoThroughLegC2C(pre_delID,nextC,lastC,cStartS,CapVehCus,varvioCAP,varvioTWC,contCAP,contTW);
//					varvioCAP -= (vioCAPCus[deletednode] + vioCAPCus[delID]);
//					if (contTW) //depart[lastC_of_C2CTrip] has changed: the case delID != nextArr[deletednode]; nextT is DTrip
//					{
//						if (nextSP > 0)
//						{
//							if (calChangeCONNECTAtSP_C2CTrip(lastC,idVeh,idTrip,nextT,cStartS,varvioTWSP,varcost) == 0){
//							//Quangnn+-
//								return 0;//GoThroughVehicle(idVeh, nextT,numTrips_update, varcost, varvioTWC, varvioTWSP, cStartS, nextSP, firstC_nextT);
//							}
//							else return 1;
//						}
//						else {
//							//Quangnn+-
//							return 0;//GoThroughVehicle(idVeh, nextT,numTrips_update, varcost, varvioTWC, varvioTWSP, cStartS, lastC, firstC_nextT);
//						}
//					}
//					else return 1;
//				}
//				else //delID was the last cus --> now pre_delID is the last cus: the case delID != nextArr[deletednode]; nextT is DTrip
//				{
//					varvioCAP -= vioCAPCus[deletednode]; //because delID was the last cus of the trip --> vioCAPCus[delID] = 0
//					varcost -= (problem->c[pre_delID][delID] + seg[idVeh].Trip[idTrip].connectCost);
//					if (nextSP > 0)
//					{
//						if (calChangeCONNECTAtSP_C2CTrip_LastCChanged(pre_delID,idVeh,idTrip,nextT,cStartS,varvioTWSP,varcost) == 0){
//						//Quangnn+-
//							return 0;//GoThroughVehicle(idVeh, nextT,numTrips_update, varcost, varvioTWC, varvioTWSP, cStartS, nextSP, firstC_nextT);
//						}
//						else return 1;
//					}
//					else
//					{
//						varcost += problem->c[pre_delID][firstC_nextT];
//						//Quangnn+-
//						return 0;//GoThroughVehicle(idVeh, nextT, numTrips_update, varcost, varvioTWC, varvioTWSP, cStartS, pre_delID, firstC_nextT);
//					}
//				}//end delID was the last cus --> now pre_delID is the last cus
//		}//end delID is NOT direct successor of deletednode: deletednode is in the middle/last of the trip
//  }//end deletednode is not the first cus of the trip
//}
//
//void Solution::Update_deleteCusArrayC2C_LastTrip_Empty(int idVeh, int idTrip)
//{
//	int	deletednode = seg[idVeh].Trip[idTrip].firstCus;
//	int preT = idTrip - 1;
//	deleteCus[deletednode]->empty = 0;
//	deleteCus[deletednode]->var_vioCAP = 0;
//	deleteCus[deletednode]->var_vioTWC = -seg[idVeh].Trip[idTrip].vioTWC;
//	deleteCus[deletednode]->var_vioTWSP = 0;
//	double varcost = -(seg[idVeh].Trip[preT].connectCost + seg[idVeh].Trip[idTrip].cost);
//	if (seg[idVeh].Trip[preT].Type == 0) 
//		varcost += problem->c[seg[idVeh].Trip[preT].assSP][0];
//	else
//		varcost += problem->c[seg[idVeh].Trip[preT].lastCus][0];
//
//	deleteCus[deletednode]->var_cost = varcost;
//	deleteCus[deletednode]->atIT = IT;
//}
//
//void Solution::Update_deleteCusArrayC2C_LastTrip(int idVeh, int idTrip, int lastCSP_preT, double cStartS) //for (idVeh, idTrip) has > 2 customers
//{
//	//11/12/2013
//	//for (idVeh, idTrip) has > 2 customers
//	//double vioTWCOLD = seg[idVeh].Trip[idTrip].vioTWC;
//	//int vioCapOLD = seg[idVeh].Trip[idTrip].vioCAP;
//
//	int nextC,idpre, pre_deletednode, varvioCAP;
//	double varvioTWC;
//	int lastC = seg[idVeh].Trip[idTrip].lastCus;
//
//	//1. Delete the first C2C order:
//	varvioTWC = 0; varvioCAP = 0;
//	int deletednode = seg[idVeh].Trip[idTrip].firstCus;
//	deleteCus[deletednode]->empty = 0;
//	int CapVehCus; 
//	bool contTW, contCAP;
//	int delID = problem->node[deletednode].delID; idpre = nextArr[deletednode]; 
//	if (delID == idpre)
//	{
//		nextC = nextArr[delID]; //for sure nextC > 0: preC1 - deletednode - delID - nextC....
//		deleteCus[deletednode]->var_cost = problem->c[lastCSP_preT][nextC] - (problem->c[lastCSP_preT][deletednode] + problem->c[deletednode][delID] + problem->c[delID][nextC]);
//        CapVehCus = 0; contCAP = 1; contTW = 1;
//		GoThroughLegC2C(lastCSP_preT,nextC,lastC,cStartS,CapVehCus,varvioCAP,varvioTWC,contCAP,contTW);
//		deleteCus[deletednode]->var_vioTWC = varvioTWC - (vioTWCus[deletednode] + vioTWCus[delID]);
//		deleteCus[deletednode]->var_vioCAP = varvioCAP - vioCAPCus[delID]; //dont need vioCAPCus[deletednode] because deletednode is the first cus->vioCAP = 0
//		deleteCus[deletednode]->var_vioTWSP = 0;
//	}
//	else //delID != nextArr[deletednode]: deletednode is the first cus of C2C (lastTrip)
//	{
//		deleteCus[deletednode]->var_cost = problem->c[lastCSP_preT][idpre] - (problem->c[lastCSP_preT][deletednode] + problem->c[deletednode][idpre]);
//		CapVehCus = 0; //idpre != delID
//		int pre_delID = predArr[delID];
//		contCAP = 1; contTW = 1;
//		GoThroughLegC2C(lastCSP_preT,idpre,pre_delID,cStartS,CapVehCus,varvioCAP,varvioTWC,contCAP,contTW);
//		//now delID:
//		nextC = nextArr[delID];
//		if (nextC > 0)
//		{
//			deleteCus[deletednode]->var_cost += (problem->c[pre_delID][nextC] - problem->c[pre_delID][delID] - problem->c[delID][nextC]);
//			//because deletednode is the first Order of the trip --> capacity of vehicle at delID = 0:
//			GoThroughLegC2C(pre_delID,nextC,cStartS,varvioTWC,CapVehCus,varvioCAP);
//			deleteCus[deletednode]->var_vioCAP = varvioCAP - vioCAPCus[delID]; //vioCapNEW - FvioCAPCus[delID]; //vioCapNEW = total of vioCapNew from newfirstCus to pred[delID]
//			deleteCus[deletednode]->var_vioTWSP = 0;
//			deleteCus[deletednode]->var_vioTWC = varvioTWC - (vioTWCus[deletednode] + vioTWCus[delID]);
//		}
//		else //delID was the last cus --> now pre_delID is the last cus:
//		{
//			deleteCus[deletednode]->var_cost += (problem->c[pre_delID][0] - problem->c[pre_delID][delID] - problem->c[delID][0]);
//			deleteCus[deletednode]->var_vioTWC = varvioTWC - (vioTWCus[deletednode] + vioTWCus[delID]);
//			deleteCus[deletednode]->var_vioCAP = varvioCAP - vioCAPCus[delID];
//			deleteCus[deletednode]->var_vioTWSP = 0;
//		}//end delID was the last cus --> now pre_delID is the last cus
//	}//end //delID != nextArr[deletednode]: deletednode is the first cus of C2C (lastTrip)
//	deleteCus[deletednode]->atIT = IT;
//
//	//2. Delete the middle C2C order:
//	deletednode = nextArr[deletednode];
//	do
//	{
//		while (deletednode > endidC2CP) deletednode = nextArr[deletednode]; //find the next C2CP
//		if (deletednode < 0) break; //finish the trip
//		idpre = predArr[deletednode];
//
//		deleteCus[deletednode]->empty = 0;
//		pre_deletednode = idpre;
//		varvioTWC = 0; varvioCAP = 0;
//		//vioTWCNEW = FvioTWCus[idpre];
//		//vioCapNEW = FvioCAPCus[idpre];
//		nextC = nextArr[deletednode]; delID = problem->node[deletednode].delID;
//		if (delID == nextC) //delID is direct successor of deletednode:
//		{
//			nextC = nextArr[delID];  
//			if (nextC < 0) // delID was the last cus of the trip --> now pre_deletednode is the last cus of the trip:
//			{
//				deleteCus[deletednode]->var_cost = problem->c[pre_deletednode][0] - (problem->c[pre_deletednode][deletednode] + problem->c[deletednode][delID] + problem->c[delID][0]);
//				deleteCus[deletednode]->var_vioTWC = varvioTWC - (vioTWCus[deletednode] + vioTWCus[delID]);
//				deleteCus[deletednode]->var_vioCAP = varvioCAP - (vioCAPCus[deletednode] + vioCAPCus[delID]);
//				deleteCus[deletednode]->var_vioTWSP = 0;
//				deleteCus[deletednode]->atIT = IT;
//				break; //finish the trip
//			}
//			else //delID is not the last cus of the trip C2C; delID is direct successor of deletednode
//			{
//				deleteCus[deletednode]->var_cost = problem->c[pre_deletednode][nextC] - (problem->c[pre_deletednode][deletednode] + problem->c[deletednode][delID] + problem->c[delID][nextC]);
//			    cStartS = depart[pre_deletednode];
//				CapVehCus = CAPCus[pre_deletednode];
//				GoThroughLegC2C(pre_deletednode,nextC,cStartS,varvioTWC,CapVehCus,varvioCAP);
//				deleteCus[deletednode]->var_vioTWC = varvioTWC - (vioTWCus[deletednode] + vioTWCus[delID]);
//				deleteCus[deletednode]->var_vioCAP = varvioCAP - (vioCAPCus[deletednode] + vioCAPCus[delID]);
//				deleteCus[deletednode]->var_vioTWSP = 0;
//				deleteCus[deletednode]->atIT = IT;
//			}//delID is not the last cus of the trip C2C; delID is direct successor of deletednode
//		}
//		else //delID != nextArr[deletednode]: lasttrip C2C > 2 customers; deletednode is in the middle of trip
//		{
//			deleteCus[deletednode]->var_cost = problem->c[pre_deletednode][nextC] - (problem->c[pre_deletednode][deletednode] + problem->c[deletednode][nextC]);
//			cStartS = depart[pre_deletednode];
//			CapVehCus = CAPCus[pre_deletednode];
//			//for sure nextC != delID
//			int pre_delID = predArr[delID];
//			contCAP = 1; contTW = 1;
//			GoThroughLegC2C(pre_deletednode,nextC,pre_delID,cStartS,CapVehCus,varvioCAP,varvioTWC,contCAP,contTW);
//			//now delID:
//			nextC = nextArr[delID];
//			if (nextC > 0)
//			{
//				deleteCus[deletednode]->var_cost += (problem->c[pre_delID][nextC] - problem->c[pre_delID][delID] - problem->c[delID][nextC]);
//				deleteCus[deletednode]->var_vioTWSP = 0;
//				//from nextC till the end of the trip:
//				GoThroughLegC2C(pre_delID,nextC,cStartS,varvioTWC,CapVehCus,varvioCAP);
//				deleteCus[deletednode]->var_vioTWC = varvioTWC - (vioTWCus[deletednode] + vioTWCus[delID]);
//				deleteCus[deletednode]->var_vioCAP = varvioCAP - (vioCAPCus[deletednode] + vioCAPCus[delID]);
//				deleteCus[deletednode]->atIT = IT;
//			}
//			else //delID was the last cus --> now pre_delID is the last cus:
//			{
//				deleteCus[deletednode]->var_cost += (problem->c[pre_delID][0] - problem->c[pre_delID][delID] - problem->c[delID][0]);
//				deleteCus[deletednode]->var_vioTWC = varvioTWC - (vioTWCus[deletednode] + vioTWCus[delID]);
//				deleteCus[deletednode]->var_vioCAP = varvioCAP - vioCAPCus[deletednode]; //delID was the last cus
//				deleteCus[deletednode]->var_vioTWSP = 0;
//				deleteCus[deletednode]->atIT = IT;
//			}//end delID was the last cus --> now pre_delID is the last cus
//		}//end delID != nextArr[deletednode]: vehicle with only one trip C2C > 2 customers; deletednode is in the middle of trip
//		//new deletednode:
//		deletednode = nextArr[deletednode];
//	}while (deletednode > 0);
//}
//
//void Solution::cal_deleteCusArrayC2C_LastTrip(int idVeh, int idTrip, int deletednode, double &varcost, double &varvioTWC, int &varvioCAP)
//{
//    //copy void Update_deleteCusArrayC2C_LastTrip(int idVeh, int idTrip, int lastCSP_preT, double cStartS), SUBcal_deleteCusArrayC2C_FromBeginning
//    //idTrip > 0
//   int delID = problem->node[deletednode].delID;
//   varvioTWC -= (vioTWCus[deletednode] + vioTWCus[delID]);
//   varvioCAP -= (vioCAPCus[deletednode] + vioCAPCus[delID]);
//
//   bool contCAP,contTW;
//   double cStartS;
//   int idpre,nextC, CapVehCus;
//   int lastC = seg[idVeh].Trip[idTrip].lastCus;
//
//   if (deletednode == seg[idVeh].Trip[idTrip].firstCus)
//   {
//	   int preT = idTrip - 1; int lastCSP_preT;
//	   if (seg[idVeh].Trip[preT].Type == 0) 
//	   {
//		   lastCSP_preT = seg[idVeh].Trip[preT].assSP;
//		   cStartS = seg[idVeh].Trip[preT].leaveSP;
//	   }
//	   else 
//	   {
//		   lastCSP_preT = seg[idVeh].Trip[preT].lastCus;
//		   cStartS = depart[lastCSP_preT];
//	   }
//	   idpre = nextArr[deletednode]; 
//	   if (delID == idpre)
//	   {
//			nextC = nextArr[delID]; //for sure nextC > 0: preC1 - deletednode - delID - nextC....
//			varcost += (problem->c[lastCSP_preT][nextC] - (problem->c[lastCSP_preT][deletednode] + problem->c[deletednode][delID] + problem->c[delID][nextC]));
//			CapVehCus = 0; 
//			GoThroughLegC2C(lastCSP_preT,nextC,cStartS,varvioTWC,CapVehCus,varvioCAP);
//	   }
//	   else //delID != nextArr[deletednode]: deletednode is the first cus of C2C (lastTrip)
//	   {
//		    varcost += (problem->c[lastCSP_preT][idpre] - (problem->c[lastCSP_preT][deletednode] + problem->c[deletednode][idpre]));
//			CapVehCus = 0; //idpre != delID
//			int pre_delID = predArr[delID];
//			contCAP = 1; contTW = 1;
//			GoThroughLegC2C(lastCSP_preT,idpre,pre_delID,cStartS,CapVehCus,varvioCAP,varvioTWC,contCAP,contTW);
//			//now delID:
//			nextC = nextArr[delID];
//			if (nextC > 0)
//			{
//				varcost += (problem->c[pre_delID][nextC] - problem->c[pre_delID][delID] - problem->c[delID][nextC]);
//				GoThroughLegC2C(pre_delID,nextC,cStartS,varvioTWC,CapVehCus,varvioCAP);
//			}
//			else //delID was the last cus --> now pre_delID is the last cus:
//			{
//				varcost += (problem->c[pre_delID][0] - problem->c[pre_delID][delID] - problem->c[delID][0]);
//			}//end delID was the last cus --> now pre_delID is the last cus
//	   }
//   }//end //delID != nextArr[deletednode]: deletednode is the first cus of C2C (lastTrip)
//   else //deletednode is middle/last cus
//   {
//   		int pre_deletednode = predArr[deletednode];
//		nextC = nextArr[deletednode]; 
//		if (delID == nextC) //delID is direct successor of deletednode:
//		{
//			nextC = nextArr[delID];  
//			if (nextC < 0) // delID was the last cus of the trip --> now pre_deletednode is the last cus of the trip:
//			{
//				varcost += (problem->c[pre_deletednode][0] - (problem->c[pre_deletednode][deletednode] + problem->c[deletednode][delID] + problem->c[delID][0]));
//			}
//			else //delID is not the last cus of the trip C2C; delID is direct successor of deletednode
//			{
//				varcost += (problem->c[pre_deletednode][nextC] - (problem->c[pre_deletednode][deletednode] + problem->c[deletednode][delID] + problem->c[delID][nextC]));
//			    cStartS = depart[pre_deletednode];
//				CapVehCus = CAPCus[pre_deletednode];
//				GoThroughLegC2C(pre_deletednode,nextC,cStartS,varvioTWC,CapVehCus,varvioCAP);
//			}//delID is not the last cus of the trip C2C; delID is direct successor of deletednode
//		}
//		else //delID != nextArr[deletednode]: lasttrip C2C > 2 customers; deletednode is in the middle of trip
//		{
//			varcost += (problem->c[pre_deletednode][nextC] - (problem->c[pre_deletednode][deletednode] + problem->c[deletednode][nextC]));
//			cStartS = depart[pre_deletednode];
//			CapVehCus = CAPCus[pre_deletednode];
//			//for sure nextC != delID
//			int pre_delID = predArr[delID];
//			contCAP = 1; contTW = 1;
//			GoThroughLegC2C(pre_deletednode,nextC,pre_delID,cStartS,CapVehCus,varvioCAP,varvioTWC,contCAP,contTW);
//			//now delID:
//			nextC = nextArr[delID];
//			if (nextC > 0)
//			{
//				varcost += (problem->c[pre_delID][nextC] - problem->c[pre_delID][delID] - problem->c[delID][nextC]);
//				//from nextC till the end of the trip:
//				GoThroughLegC2C(pre_delID,nextC,cStartS,varvioTWC,CapVehCus,varvioCAP);
//			}
//			else //delID was the last cus --> now pre_delID is the last cus:
//			{
//				varcost += (problem->c[pre_delID][0] - problem->c[pre_delID][delID] - problem->c[delID][0]);
//			}//end delID was the last cus --> now pre_delID is the last cus
//		}//end delID != nextArr[deletednode]: vehicle with only one trip C2C > 2 customers; deletednode is in the middle of trip
//   }//end deletednode is middle/last cus
//}
//
//
//void Solution::Update_deleteCusC2C_LastTrip(int idVeh, int idTrip, int pre_deletednode,int deletednode, int next_deletednode) //for (idVeh, idTrip) has > 2 customers
//{
//	//16/12/2013:
//	 //COPY Update_deleteCusArrayC2C_LastTrip
//	//for (idVeh, idTrip) has > 2 customers; idTrip >= 0
//	//last Trip --> don't have varvioTWSP
//
//
//	int delID = problem->node[deletednode].delID;
//	int nextID,preID,CapVehCus,varvioCAP;
//	double cStartS,varcost,varcostpreT,varFIT,varC1,varvioTWC; 
//	int lastC = seg[idVeh].Trip[idTrip].lastCus;
//	if (pre_deletednode < 0) //deletedndoe is the first cus:
//	{
//		if (delID == next_deletednode)//deletednode is the first customer; delID of deletednode is its successor
//		{
//			nextID = nextArr[delID];
//			seg[idVeh].Trip[idTrip].firstCus = nextID; predArr[nextID] = -1;
//			if (idTrip == 0)
//			{
//				preID = 0;cStartS = 0; 
//				varcost = problem->c[0][nextID] - (problem->c[0][deletednode] + problem->c[deletednode][delID] + problem->c[delID][nextID]);
//			}
//			else
//			{
//				int preT = idTrip - 1;
//				if (seg[idVeh].Trip[preT].Type == 0)
//				{
//					preID = seg[idVeh].Trip[preT].assSP;
//					cStartS = seg[idVeh].Trip[preT].leaveSP;
//				}
//				else
//				{
//					preID = seg[idVeh].Trip[preT].lastCus;
//					cStartS = depart[preID];
//				}
//				varcost = -(problem->c[deletednode][delID] + problem->c[delID][nextID]);
//				varcostpreT = problem->c[preID][nextID] - problem->c[preID][deletednode];
//				seg[idVeh].Trip[preT].connectCost = problem->c[preID][nextID];
//				seg[idVeh].Trip[preT].cost += varcostpreT;
//				seg[idVeh].Trip[preT].fitness += varcostpreT;
//			}
//			CapVehCus = 0;
//			UpdateLegC2C_Cus(preID,nextID,lastC,CapVehCus,cStartS,1);
//			seg[idVeh].Trip[idTrip].endS = depart[lastC];
//			//LastC doesn't change --> don't need to update connectCost
//			varvioTWC = FvioTWCus[lastC] - seg[idVeh].Trip[idTrip].vioTWC;
//			varvioCAP = FCAP[lastC] - seg[idVeh].Trip[idTrip].vioCAP;
//			//varvioCAP = FvioCAPCus[lastC] - seg[idVeh].Trip[idTrip].vioCAP;
//			seg[idVeh].Trip[idTrip].vioTWC = FvioTWCus[lastC];
//			seg[idVeh].Trip[idTrip].vioCAP = FCAP[lastC];
//			//seg[idVeh].Trip[idTrip].vioCAP = FvioCAPCus[lastC];
//		}
//		else //deletednode is the first customer; delID of deletednode is not its successor
//		{
//			seg[idVeh].Trip[idTrip].firstCus = next_deletednode; predArr[next_deletednode] = -1;
//			if (idTrip == 0)
//			{
//				preID = 0;cStartS = 0; 
//				varcost = problem->c[0][next_deletednode] - (problem->c[0][deletednode] + problem->c[deletednode][next_deletednode]);
//			}
//			else
//			{
//				int preT = idTrip - 1;
//				if (seg[idVeh].Trip[preT].Type == 0)
//				{
//					preID = seg[idVeh].Trip[preT].assSP;
//					cStartS = seg[idVeh].Trip[preT].leaveSP;
//				}
//				else
//				{
//					preID = seg[idVeh].Trip[preT].lastCus;
//					cStartS = depart[preID];
//				}
//				varcost = -problem->c[deletednode][next_deletednode];
//				varcostpreT = problem->c[preID][next_deletednode] - problem->c[preID][deletednode];
//				seg[idVeh].Trip[preT].connectCost = problem->c[preID][next_deletednode];
//				seg[idVeh].Trip[preT].cost += varcostpreT;
//				seg[idVeh].Trip[preT].fitness += varcostpreT;
//			}
//			//from next_deletednode to pre_delID:
//			CapVehCus = 0; int pre_delID = predArr[delID]; //next_delelednode may = pre_delID
//			UpdateLegC2C_Cus(preID,next_deletednode,pre_delID,CapVehCus,cStartS,1);
//			nextID = nextArr[delID];
//			nextArr[pre_delID] = nextID;
//			if (nextID > 0)
//			{
//				predArr[nextID] = pre_delID;
//         		varcost += (problem->c[pre_delID][nextID] - problem->c[pre_delID][delID] - problem->c[delID][nextID]);
//				UpdateLegC2C_Cus(pre_delID,nextID,lastC,CAPCus[pre_delID],depart[pre_delID],0); //16/12/2013: do we need update CAP HERE ??
//				seg[idVeh].Trip[idTrip].endS = depart[lastC];
//				varvioTWC = FvioTWCus[lastC] - seg[idVeh].Trip[idTrip].vioTWC;
//				varvioCAP = FCAP[lastC] - seg[idVeh].Trip[idTrip].vioCAP;
//				//varvioCAP = FvioCAPCus[lastC] - seg[idVeh].Trip[idTrip].vioCAP;
//				seg[idVeh].Trip[idTrip].vioTWC = FvioTWCus[lastC];
//				seg[idVeh].Trip[idTrip].vioCAP = FCAP[lastC];
//				//seg[idVeh].Trip[idTrip].vioCAP = FvioCAPCus[lastC];
//			}
//			else //delID was the last cus --> now pre_delID is the last cus:
//			{
//				seg[idVeh].Trip[idTrip].lastCus = pre_delID; //nextArr[pre_delID] = -1;
//				varcost += (problem->c[pre_delID][0] - problem->c[pre_delID][delID] - problem->c[delID][0]);
//				seg[idVeh].Trip[idTrip].connectCost = problem->c[pre_delID][0];
//				seg[idVeh].Trip[idTrip].endS = depart[pre_delID];
//				varvioTWC = FvioTWCus[pre_delID] - seg[idVeh].Trip[idTrip].vioTWC;
//				varvioCAP = FCAP[pre_delID] - seg[idVeh].Trip[idTrip].vioCAP;
//				//varvioCAP = FvioCAPCus[pre_delID] - seg[idVeh].Trip[idTrip].vioCAP;
//				seg[idVeh].Trip[idTrip].vioTWC = FvioTWCus[pre_delID];
//				seg[idVeh].Trip[idTrip].vioCAP = FCAP[pre_delID];
//				//seg[idVeh].Trip[idTrip].vioCAP = FvioCAPCus[pre_delID];
//			}
//		}//end deletednode is the first customer; delID of deletednode is not its successor
//	}
//	else //deletednode is not the first cus:
//	{
//		varcostpreT = 0;
//		if (delID == next_deletednode) //deletednode is not the first customer; delID of deletednode is its successor
//		{
//   			nextID = nextArr[delID];
//			nextArr[pre_deletednode] = nextID;
//			if (nextID > 0)
//			{
//				predArr[nextID] = pre_deletednode;
//				varcost = problem->c[pre_deletednode][nextID] - (problem->c[pre_deletednode][deletednode] + problem->c[deletednode][delID] + problem->c[delID][nextID]);
//                UpdateLegC2C_Cus(pre_deletednode,nextID,lastC,CAPCus[pre_deletednode],depart[pre_deletednode],0);
//				seg[idVeh].Trip[idTrip].endS = depart[lastC];
//				varvioTWC = FvioTWCus[lastC] - seg[idVeh].Trip[idTrip].vioTWC;
//				varvioCAP = FCAP[lastC] - seg[idVeh].Trip[idTrip].vioCAP;
//				//varvioCAP = FvioCAPCus[lastC] - seg[idVeh].Trip[idTrip].vioCAP;
//				seg[idVeh].Trip[idTrip].vioTWC = FvioTWCus[lastC];
//				seg[idVeh].Trip[idTrip].vioCAP = FCAP[lastC];
//				//seg[idVeh].Trip[idTrip].vioCAP = FvioCAPCus[lastC];
//			}
//			else //delID was the last cus --> pre_deletednode is now the last cus (deletednode and delID are 2 last cus)
//			{
//				seg[idVeh].Trip[idTrip].lastCus = pre_deletednode; //nextArr[pre_deletednode] = -1;
//				varcost = problem->c[pre_deletednode][0] - (problem->c[pre_deletednode][deletednode] + problem->c[deletednode][delID] + problem->c[delID][0]);
//			    seg[idVeh].Trip[idTrip].connectCost = problem->c[pre_deletednode][0];
//				seg[idVeh].Trip[idTrip].endS = depart[pre_deletednode];
//				seg[idVeh].Trip[idTrip].vioTWC = FvioTWCus[pre_deletednode];
//				seg[idVeh].Trip[idTrip].vioCAP = FCAP[pre_deletednode];
//				varvioTWC = 0; varvioCAP = 0;
//			}
//		}
//		else //deletednode is not the first customer; delID of deletednode is NOT its successor
//		{
//			varcost = problem->c[pre_deletednode][next_deletednode] - (problem->c[pre_deletednode][deletednode] + problem->c[deletednode][next_deletednode]);
//			nextArr[pre_deletednode] = next_deletednode; predArr[next_deletednode] = pre_deletednode;
//			int pre_delID = predArr[delID];
//			UpdateLegC2C_Cus(pre_deletednode,next_deletednode,pre_delID,CAPCus[pre_deletednode],depart[pre_deletednode],0);
//			nextID = nextArr[delID]; nextArr[pre_delID] = nextID;
//			if (nextID > 0)
//			{
//				predArr[nextID] = pre_delID;
//				varcost += (problem->c[pre_delID][nextID] - problem->c[pre_delID][delID] - problem->c[delID][nextID]);
//				UpdateLegC2C_Cus(pre_delID,nextID,lastC,CAPCus[pre_delID],depart[pre_delID],0);
//				seg[idVeh].Trip[idTrip].endS = depart[lastC];
//				varvioTWC = FvioTWCus[lastC] - seg[idVeh].Trip[idTrip].vioTWC;
//				varvioCAP = FCAP[lastC] - seg[idVeh].Trip[idTrip].vioCAP;
//				//varvioCAP = FvioCAPCus[lastC] - seg[idVeh].Trip[idTrip].vioCAP;
//				seg[idVeh].Trip[idTrip].vioTWC = FvioTWCus[lastC];
//				seg[idVeh].Trip[idTrip].vioCAP = FCAP[lastC];
//				//seg[idVeh].Trip[idTrip].vioCAP = FvioCAPCus[lastC];
//			}
//			else //delID was the last cus --> pre_ID is now the last cus
//			{
//				varcost += (problem->c[pre_delID][0] - problem->c[pre_delID][delID] - problem->c[delID][0]);
//				seg[idVeh].Trip[idTrip].lastCus = pre_delID; //nextArr[pre_delID] = -1;
//				seg[idVeh].Trip[idTrip].connectCost = problem->c[pre_delID][0];
//				seg[idVeh].Trip[idTrip].endS = depart[pre_delID];
//				varvioTWC = FvioTWCus[pre_delID] - seg[idVeh].Trip[idTrip].vioTWC;
//				varvioCAP = FCAP[pre_delID] - seg[idVeh].Trip[idTrip].vioCAP;
//				//varvioCAP = FvioCAPCus[pre_delID] - seg[idVeh].Trip[idTrip].vioCAP;
//				seg[idVeh].Trip[idTrip].vioTWC = FvioTWCus[pre_delID];
//				seg[idVeh].Trip[idTrip].vioCAP = FCAP[pre_delID];
//				//seg[idVeh].Trip[idTrip].vioCAP = FvioCAPCus[pre_delID];
//			}
//		}//end deletednode is not the first customer; delID of deletednode is NOT its successor
//	}//end //deletednode is not the first cus
//
//    
//	UpdateBvioTW_BvioCAPCus(idVeh, idTrip, seg[idVeh].Trip[idTrip].lastCus); 
//	varFIT = varcost + VTWCUS * varvioTWC + VCAP * varvioCAP;
//	seg[idVeh].Trip[idTrip].cost += varcost;
//	if (seg[idVeh].Trip[idTrip].vioCAP > 0 || seg[idVeh].Trip[idTrip].vioTWC > eps)
//	{
//		seg[idVeh].Trip[idTrip].feasible = 0;
//		seg[idVeh].Trip[idTrip].fitness += varFIT;
//	}
//	else
//	{
//		seg[idVeh].Trip[idTrip].feasible = 1;
//		seg[idVeh].Trip[idTrip].fitness = seg[idVeh].Trip[idTrip].cost;
//	}
//	varC1 = varcost + varcostpreT;
//	varFIT += varcostpreT;
//	seg[idVeh].cost += varC1; seg[idVeh].fitness += varFIT; seg[idVeh].vioTWC += varvioTWC; seg[idVeh].vioCAP += varvioCAP;
//	cost += varC1; fitness += varFIT;vioTWC += varvioTWC;vioCAP += varvioCAP;
//}
//
//
//void Solution::Update_deleteCusC2C_FirstMiddleTrip(int idVeh, int idTrip, int pre_deletednode, int deletednode, int next_deletednode, int update_idTrip)
//{
//	//16/12/2013: COPY Update_deleteCusArrayC2C_FirstMiddleTrip
//	//lastT > idTrip >= 0
//
//	int delID = problem->node[deletednode].delID;
//	int lastCSP_preT,nextC, preT,varvioCAP;
//	//int lastT = seg[idVeh].numTrips - 1;
//	double cStartS,varvioTWC,varcost,varcostpreT,varFIT,varC1;
//	
//	preT = idTrip - 1; 
//
//	if (idTrip == 0)
//	{
//		lastCSP_preT = 0;
//		cStartS = 0;
//	}
//	else
//	{
//		if (seg[idVeh].Trip[preT].Type == 0) 
//		{
//			lastCSP_preT = seg[idVeh].Trip[preT].assSP;
//			cStartS = seg[idVeh].Trip[preT].leaveSP;
//		}
//		else 
//		{
//			lastCSP_preT = seg[idVeh].Trip[preT].lastCus;
//			cStartS = depart[lastCSP_preT];
//		}	
//	}
//
//	int nextT = idTrip + 1; int nextSP = seg[idVeh].Trip[idTrip].nextSP;
//	int lastC = seg[idVeh].Trip[idTrip].lastCus;
//
//	if (deletednode == seg[idVeh].Trip[idTrip].firstCus)
//	{
//		if (delID == next_deletednode) //deletednode is the first cus; delID is successor of deletednode; 
//		{
//			nextC = nextArr[delID]; //for sure nextC > 0: preC1 - deletednode - delID - nextC....
//			if (idTrip > 0)
//			{
//				varcostpreT = problem->c[lastCSP_preT][nextC] - problem->c[lastCSP_preT][deletednode];
//				seg[idVeh].Trip[preT].connectCost = problem->c[lastCSP_preT][nextC];
//				seg[idVeh].Trip[preT].cost += varcostpreT;
//				seg[idVeh].Trip[preT].fitness += varcostpreT;
//				varcost = -(problem->c[deletednode][delID] + problem->c[delID][nextC]);
//			}
//			else
//			{
//				varcostpreT = 0;
//				varcost = problem->c[lastCSP_preT][nextC] - problem->c[lastCSP_preT][deletednode];
//				varcost -= (problem->c[deletednode][delID] + problem->c[delID][nextC]);
//			}
//			seg[idVeh].Trip[idTrip].firstCus = nextC; predArr[nextC] = -1;
//			UpdateLegC2C_Cus(lastCSP_preT,nextC,lastC,0,cStartS,1);
//			varvioTWC = FvioTWCus[lastC] - seg[idVeh].Trip[idTrip].vioTWC;
//			varvioCAP = FCAP[lastC] - seg[idVeh].Trip[idTrip].vioCAP;
//			//varvioCAP = FvioCAPCus[lastC] - seg[idVeh].Trip[idTrip].vioCAP;
//			seg[idVeh].Trip[idTrip].vioTWC = FvioTWCus[lastC];
//			seg[idVeh].Trip[idTrip].vioCAP = FCAP[lastC];
//			//seg[idVeh].Trip[idTrip].vioCAP = FvioCAPCus[lastC];
//			UpdateBvioTW_BvioCAPCus(idVeh,idTrip,lastC);
//			if (PDSDIF(seg[idVeh].Trip[idTrip].endS, depart[lastC]) == 1)
//			{
//				seg[idVeh].Trip[idTrip].endS = depart[lastC];
//				if (nextSP > 0)
//				{
//					varcost -= seg[idVeh].Trip[idTrip].connectCost; //lastC not changed
//					UpdateChangeCONNECTAtSP_C2CTrip(idVeh,idTrip,nextT,nextSP,varcost,varcostpreT,varvioTWC,varvioCAP,update_idTrip);
//					return;
//				}
//				else  goto UpdateC;
//			}
//			else goto UpdateNC;
//		}
//		else //deletednode is the first cus; delID is NOT successor of deletednode; 
//		{
//			if (idTrip > 0)
//			{
//				varcostpreT = problem->c[lastCSP_preT][next_deletednode] - problem->c[lastCSP_preT][deletednode];
//				seg[idVeh].Trip[preT].connectCost = problem->c[lastCSP_preT][next_deletednode];
//				seg[idVeh].Trip[preT].cost += varcostpreT;
//				seg[idVeh].Trip[preT].fitness += varcostpreT;
//
//				varcost = - (problem->c[deletednode][next_deletednode]);
//			}
//			else
//			{
//				varcostpreT = 0;
//				varcost = problem->c[lastCSP_preT][next_deletednode] - problem->c[lastCSP_preT][deletednode];
//				varcost -= (problem->c[deletednode][next_deletednode]);
//			}
//			int pre_delID = predArr[delID];
//			seg[idVeh].Trip[idTrip].firstCus = next_deletednode; predArr[next_deletednode] = -1;
//			UpdateLegC2C_Cus(lastCSP_preT,next_deletednode,pre_delID,0,cStartS,1);
//			nextC = nextArr[delID]; nextArr[pre_delID] = nextC;
//			if (nextC > 0)
//			{
//				predArr[nextC] = pre_delID;
//				varcost += (problem->c[pre_delID][nextC] - problem->c[pre_delID][delID] - problem->c[delID][nextC]);
//				UpdateLegC2C_Cus(pre_delID,nextC,lastC,CAPCus[pre_delID],depart[pre_delID],0);
//				varvioTWC = FvioTWCus[lastC] - seg[idVeh].Trip[idTrip].vioTWC;
//				varvioCAP = FCAP[lastC] - seg[idVeh].Trip[idTrip].vioCAP;
//				//varvioCAP = FvioCAPCus[lastC] - seg[idVeh].Trip[idTrip].vioCAP;
//				seg[idVeh].Trip[idTrip].vioTWC = FvioTWCus[lastC];
//				seg[idVeh].Trip[idTrip].vioCAP = FCAP[lastC];
//				//seg[idVeh].Trip[idTrip].vioCAP = FvioCAPCus[lastC];
//				UpdateBvioTW_BvioCAPCus(idVeh,idTrip,lastC);
//				if (PDSDIF(seg[idVeh].Trip[idTrip].endS, depart[lastC]) == 1)
//				{
//					seg[idVeh].Trip[idTrip].endS = depart[lastC];
//					if (nextSP > 0)
//					{
//						varcost -= seg[idVeh].Trip[idTrip].connectCost; //lastC not changed
//						UpdateChangeCONNECTAtSP_C2CTrip(idVeh,idTrip,nextT,nextSP,varcost,varcostpreT,varvioTWC,varvioCAP,update_idTrip);
//						return;
//					}
//					else goto UpdateC;
//				}
//				else goto UpdateNC;
//			}
//			else //delID was the last cus --> now pre_delID is the last cus:
//			{
//				seg[idVeh].Trip[idTrip].lastCus = pre_delID;
//				varcost -= (problem->c[pre_delID][delID] + seg[idVeh].Trip[idTrip].connectCost);
//				varvioTWC = FvioTWCus[pre_delID] - seg[idVeh].Trip[idTrip].vioTWC;
//				varvioCAP = FCAP[pre_delID] - seg[idVeh].Trip[idTrip].vioCAP;
//				//varvioCAP = FvioCAPCus[pre_delID] - seg[idVeh].Trip[idTrip].vioCAP;
//				seg[idVeh].Trip[idTrip].vioTWC = FvioTWCus[pre_delID];
//				seg[idVeh].Trip[idTrip].vioCAP = FCAP[pre_delID];
//				//seg[idVeh].Trip[idTrip].vioCAP = FvioCAPCus[pre_delID];
//				UpdateBvioTW_BvioCAPCus(idVeh,idTrip,pre_delID);
//				if (nextSP > 0)
//				{
//					//varcost -= seg[idVeh].Trip[idTrip].connectCost; lastC changed
//					UpdateChangeCONNECTAtSP_C2CTrip(idVeh,idTrip,nextT,nextSP,varcost,varcostpreT,varvioTWC,varvioCAP,update_idTrip);
//					return;
//				}
//				else 
//				{
//					seg[idVeh].Trip[idTrip].connectCost = problem->c[pre_delID][seg[idVeh].Trip[nextT].firstCus];
//					varcost += seg[idVeh].Trip[idTrip].connectCost;
//					goto UpdateC;
//				}
//			}//end delID was the last cus --> now pre_delID is the last cus
//
//		}//end deletednode is the first cus; delID is NOT successor of deletednode
//	}
//	else //deletednode is NOT first cus;
//	{
//		varcostpreT = 0;
//		if (delID == next_deletednode) //deletednode is NOT first cus; delID is its direct successor; 
//		{
//			nextC = nextArr[delID];  nextArr[pre_deletednode] = nextC;
//			if (nextC < 0) // (deletednode and delID) were the last cus of the trip --> now pre_deletednode is the last cus of the trip:
//			{
//				varcost = -(problem->c[pre_deletednode][deletednode] + problem->c[deletednode][delID]);
//				varcost -= seg[idVeh].Trip[idTrip].connectCost;
//				seg[idVeh].Trip[idTrip].lastCus = pre_deletednode;
//				seg[idVeh].Trip[idTrip].endS = depart[pre_deletednode];
//				varvioTWC = FvioTWCus[pre_deletednode] - seg[idVeh].Trip[idTrip].vioTWC;
//				varvioCAP = FCAP[pre_deletednode] - seg[idVeh].Trip[idTrip].vioCAP;
//				//varvioCAP = FvioCAPCus[pre_deletednode] - seg[idVeh].Trip[idTrip].vioCAP;
//				seg[idVeh].Trip[idTrip].vioTWC = FvioTWCus[pre_deletednode];
//				seg[idVeh].Trip[idTrip].vioCAP = FCAP[pre_deletednode];
//				//seg[idVeh].Trip[idTrip].vioCAP = FvioCAPCus[pre_deletednode];
//				UpdateBvioTW_BvioCAPCus(idVeh,idTrip,pre_deletednode);
//				if (nextSP > 0)
//				{
//					//varcost -= seg[idVeh].Trip[idTrip].connectCost; lastC changed
//					UpdateChangeCONNECTAtSP_C2CTrip(idVeh,idTrip,nextT,nextSP,varcost,varcostpreT,varvioTWC,varvioCAP,update_idTrip);
//					return;
//				}
//				else
//				{
//					seg[idVeh].Trip[idTrip].connectCost = problem->c[pre_deletednode][seg[idVeh].Trip[nextT].firstCus];
//					varcost += seg[idVeh].Trip[idTrip].connectCost;
//					goto UpdateC;
//				}
//			}
//			else //delID is not the first cus of the trip C2C; delID is direct successor of deletednode; 
//			{
//				predArr[nextC] = pre_deletednode;
//				varcost = problem->c[pre_deletednode][nextC] - (problem->c[pre_deletednode][deletednode] + problem->c[deletednode][delID] + problem->c[delID][nextC]);
//				UpdateLegC2C_Cus(pre_deletednode,nextC,lastC,CAPCus[pre_deletednode],depart[pre_deletednode],0);
//				varvioTWC = FvioTWCus[lastC] - seg[idVeh].Trip[idTrip].vioTWC;
//				varvioCAP = FCAP[lastC] - seg[idVeh].Trip[idTrip].vioCAP;
//				//varvioCAP = FvioCAPCus[lastC] - seg[idVeh].Trip[idTrip].vioCAP;
//				seg[idVeh].Trip[idTrip].vioTWC = FvioTWCus[lastC];
//				seg[idVeh].Trip[idTrip].vioCAP = FCAP[lastC];
//				//seg[idVeh].Trip[idTrip].vioCAP = FvioCAPCus[lastC];
//				UpdateBvioTW_BvioCAPCus(idVeh,idTrip,lastC);
//				if (PDSDIF(seg[idVeh].Trip[idTrip].endS, depart[lastC]) == 1)
//				{
//					seg[idVeh].Trip[idTrip].endS = depart[lastC];
//					if (nextSP > 0)
//					{
//						varcost -= seg[idVeh].Trip[idTrip].connectCost; //lastC not changed
//						UpdateChangeCONNECTAtSP_C2CTrip(idVeh,idTrip,nextT,nextSP,varcost,varcostpreT,varvioTWC,varvioCAP,update_idTrip);
//						return;
//					}
//					else goto UpdateC;
//				}
//				else goto UpdateNC;
//			}//end delID is not the last cus of the trip C2C; delID is direct successor of deletednode; nextT is DTrip
//		}
//		else //deletednode is NOT first cus, delID is not its direct successor; nextT is DTrip
//		{
//			varcost = problem->c[pre_deletednode][next_deletednode] - (problem->c[pre_deletednode][deletednode] + problem->c[deletednode][next_deletednode]);
//			nextArr[pre_deletednode] = next_deletednode; predArr[next_deletednode] = pre_deletednode;
//            int pre_delID = predArr[delID];
//			UpdateLegC2C_Cus(pre_deletednode,next_deletednode,pre_delID,CAPCus[pre_deletednode],depart[pre_deletednode],0);
//			nextC = nextArr[delID]; nextArr[pre_delID] = nextC; 
//			if (nextC > 0) //checking from nextC till the end of the trip:
//			{
//				varcost += (problem->c[pre_delID][nextC] - problem->c[pre_delID][delID] - problem->c[delID][nextC]);
//				predArr[nextC] = pre_delID;
//				UpdateLegC2C_Cus(pre_delID,nextC,lastC,CAPCus[pre_delID],depart[pre_delID],0);
//
//				varvioTWC = FvioTWCus[lastC] - seg[idVeh].Trip[idTrip].vioTWC;
//				varvioCAP = FCAP[lastC] - seg[idVeh].Trip[idTrip].vioCAP;
//				//varvioCAP = FvioCAPCus[lastC] - seg[idVeh].Trip[idTrip].vioCAP;
//				seg[idVeh].Trip[idTrip].vioTWC = FvioTWCus[lastC];
//				seg[idVeh].Trip[idTrip].vioCAP = FCAP[lastC];
//				//seg[idVeh].Trip[idTrip].vioCAP = FvioCAPCus[lastC];
//				UpdateBvioTW_BvioCAPCus(idVeh,idTrip,lastC);
//				if (PDSDIF(seg[idVeh].Trip[idTrip].endS, depart[lastC]) == 1)
//				{
//					seg[idVeh].Trip[idTrip].endS = depart[lastC];
//					if (nextSP > 0)
//					{
//						varcost -= seg[idVeh].Trip[idTrip].connectCost; //lastC not changed
//						UpdateChangeCONNECTAtSP_C2CTrip(idVeh,idTrip,nextT,nextSP,varcost,varcostpreT,varvioTWC,varvioCAP,update_idTrip);
//					    return;
//					}
//					else goto UpdateC;
//				}
//				else goto UpdateNC;
//			}
//			else //delID was the last cus --> now pre_delID is the last cus: the case delID != nextArr[deletednode]; nextT is DTrip
//			{
//				varcost -= (problem->c[pre_delID][delID] + seg[idVeh].Trip[idTrip].connectCost);
//				seg[idVeh].Trip[idTrip].lastCus = pre_delID; //nextArr[pre_delID] = -1;
//				seg[idVeh].Trip[idTrip].endS = depart[pre_delID];
//				varvioTWC = FvioTWCus[pre_delID] - seg[idVeh].Trip[idTrip].vioTWC;
//				varvioCAP = FCAP[pre_delID] - seg[idVeh].Trip[idTrip].vioCAP;
//				//varvioCAP = FvioCAPCus[pre_delID] - seg[idVeh].Trip[idTrip].vioCAP;
//				seg[idVeh].Trip[idTrip].vioTWC = FvioTWCus[pre_delID];
//				seg[idVeh].Trip[idTrip].vioCAP = FCAP[pre_delID];
//				//seg[idVeh].Trip[idTrip].vioCAP = FvioCAPCus[pre_delID];
//				UpdateBvioTW_BvioCAPCus(idVeh,idTrip,pre_delID);
//				if (nextSP > 0)
//				{
//					//varcost -= seg[idVeh].Trip[idTrip].connectCost; lastC changed
//					UpdateChangeCONNECTAtSP_C2CTrip(idVeh,idTrip,nextT,nextSP,varcost,varcostpreT,varvioTWC,varvioCAP,update_idTrip);
//				    return;
//				}
//				else 
//				{
//					seg[idVeh].Trip[idTrip].connectCost = problem->c[pre_delID][seg[idVeh].Trip[nextT].firstCus];
//					varcost += seg[idVeh].Trip[idTrip].connectCost;				
//					goto UpdateC;
//				}
//			}//end delID was the last cus --> now pre_delID is the last cus
//		}//end deletednode is NOT first cus, delID is not its direct successor; nextT is DTrip
//	}//end deletednode is NOT first cus; nextT is DTrip
//UpdateNC:
//		varFIT = varcost + VTWCUS * varvioTWC + VCAP * varvioCAP;
//		seg[idVeh].Trip[idTrip].cost += varcost;
//		if (seg[idVeh].Trip[idTrip].vioCAP > 0 || seg[idVeh].Trip[idTrip].vioTWC > eps)
//		{
//			seg[idVeh].Trip[idTrip].feasible = 0;
//			seg[idVeh].Trip[idTrip].fitness += varFIT;
//		}
//		else
//		{
//			seg[idVeh].Trip[idTrip].feasible = 1;
//			seg[idVeh].Trip[idTrip].fitness = seg[idVeh].Trip[idTrip].cost;
//		}
//		varC1 = varcost + varcostpreT;
//		varFIT += varcostpreT;
//		seg[idVeh].cost += varC1; seg[idVeh].fitness += varFIT; seg[idVeh].vioTWC += varvioTWC; seg[idVeh].vioCAP += varvioCAP;
//		cost += varC1; fitness += varFIT;vioTWC += varvioTWC;vioCAP += varvioCAP;
//		return;
//
//UpdateC:
//	varFIT = varcost + VTWCUS * varvioTWC + VCAP * varvioCAP;
//	seg[idVeh].Trip[idTrip].cost += varcost;
//	if (seg[idVeh].Trip[idTrip].vioCAP > 0 || seg[idVeh].Trip[idTrip].vioTWC > eps)
//	{
//		seg[idVeh].Trip[idTrip].feasible = 0;
//		seg[idVeh].Trip[idTrip].fitness += varFIT;
//	}
//	else
//	{
//		seg[idVeh].Trip[idTrip].feasible = 1;
//		seg[idVeh].Trip[idTrip].fitness = seg[idVeh].Trip[idTrip].cost;
//	}
//	UpdateVehicle(idVeh, nextT,seg[idVeh].Trip[idTrip].lastCus,seg[idVeh].Trip[idTrip].endS,varvioCAP,update_idTrip);
//}
//
//void Solution::SUBcal_deleteCusArrayC2C_FromBeginning(int preC, bool changed_preT, int idVeh, int idTrip, int deletednode, double &varcost, double &varvioTWC, double &varvioTWSP, int &varvioCAP,double &cStartS, bool &contTW, int &lastCNEW)
//{
//   //11/12/2013: COPY void Update_deleteCusArrayC2C_LastTrip(int idVeh, int idTrip, int lastCSP_preT, double cStartS):
//   //idTrip > 0
//   int delID = problem->node[deletednode].delID; 
//   varvioTWC -= (vioTWCus[deletednode] + vioTWCus[delID]);
//   bool contCAP;
//   double temp;
//   int nextC, CapVehCus;
//   int lastC = seg[idVeh].Trip[idTrip].lastCus;
//
//   if (deletednode == seg[idVeh].Trip[idTrip].firstCus)
//   {
//	   int idpre = nextArr[deletednode]; 
//	   if (delID == idpre) //(deletednode, delID) are the first customers of (idVeh, idTrip)
//	   {
//			nextC = nextArr[delID]; //for sure nextC > 0: preC1 - deletednode - delID - nextC....
//			if (changed_preT)
//			{
//				//preT is C2C: preC == delID
//				varcost -= problem->c[deletednode][delID];
//			    //varcost += (problem->c[preC][nextC] - (problem->c[deletednode][delID] + problem->c[delID][nextC]));
//			}
//			else
//			{
//			   int preT = idTrip - 1; 
//			   if (seg[idVeh].Trip[preT].Type == 0) preC = seg[idVeh].Trip[preT].assSP;
//			   else preC = seg[idVeh].Trip[preT].lastCus;
//			   varcost += (problem->c[preC][nextC] - (problem->c[preC][deletednode] + problem->c[deletednode][delID] + problem->c[delID][nextC]));
//			}
//			CapVehCus = 0; contCAP = 1; contTW = 1;
//			GoThroughLegC2C(preC,nextC,lastC,cStartS,CapVehCus,varvioCAP,varvioTWC,contCAP,contTW);
//			lastCNEW = lastC;
//			//(deletednode, delID) are the first customers --> vioCAPCus[deletednode] = vioCAPCus[delID] = 0
//	   }
//	   else //delID is not direct successor of deletednode; deletednode is the first cus of the trip
//	   {
//		    varvioCAP -= vioCAPCus[delID];
//			if (changed_preT)
//			{
//				//preT is C2C: preC == delID
//				varcost += (problem->c[preC][idpre] - problem->c[deletednode][idpre]);
//			}
//			else
//			{
//			   int preT = idTrip - 1;
//			   if (seg[idVeh].Trip[preT].Type == 0) preC = seg[idVeh].Trip[preT].assSP;
//			   else preC = seg[idVeh].Trip[preT].lastCus;
//			   varcost += (problem->c[preC][idpre] - (problem->c[preC][deletednode] + problem->c[deletednode][idpre]));
//			}
//			CapVehCus = 0;//for sure idpre != delID
//			int pre_delID = predArr[delID];
//			contCAP = 1; contTW = 1;
//			GoThroughLegC2C(preC,idpre,pre_delID,cStartS,CapVehCus,varvioCAP,varvioTWC,contCAP,contTW);
//			//now delID:
//			nextC = nextArr[delID];
//			if (nextC > 0)
//			{
//				varcost += (problem->c[pre_delID][nextC] - problem->c[pre_delID][delID] - problem->c[delID][nextC]);
//				//because deletednode is the first Order of the trip --> capacity of vehicle at delID = 0:
//				contTW = 1; contCAP = 1;
//				GoThroughLegC2C(pre_delID,nextC,lastC,cStartS,CapVehCus,varvioCAP,varvioTWC,contCAP,contTW);
//				lastCNEW = lastC;
//			}
//			else //delID was the last cus --> now pre_delID is the last cus:
//			{
//				lastCNEW = pre_delID;
//				varcost -= problem->c[pre_delID][delID];
//				//varcost += (problem->c[pre_delID][0] - problem->c[pre_delID][delID] - problem->c[delID][0]);
//			}//end delID was the last cus --> now pre_delID is the last cus*/
//	   }//end delID is not direct successor of deletednode; deletednode is the first cus of the trip
//   }
//   else //deletednode is not the first cus
//   {
//	   int curC = seg[idVeh].Trip[idTrip].firstCus;
//	   if (changed_preT)
//		   varcost += problem->c[preC][curC];
//	   else
//	   {
//		   int preT = idTrip - 1;
//		   if (seg[idVeh].Trip[preT].Type == 0) preC = seg[idVeh].Trip[preT].assSP;
//		   else preC = seg[idVeh].Trip[preT].lastCus;
//	   }
//	   varvioCAP -= (vioCAPCus[deletednode] + vioCAPCus[delID]);
//	   double cArrTime;
//	   do
//	   {
//		   cArrTime = cStartS + problem->c[preC][curC];
//           temp = cArrTime - problem->node[curC].eTW;
//		   if (temp > eps)
//		   {
//			   varvioTWC += temp;
//			   if (vioTWCus[curC] > 0)
//			   {
//				   varvioTWC -= vioTWCus[curC];
//				   cStartS = depart[curC];
//				   break;
//			   }
//			   else cStartS = problem->node[curC].depart;
//		   }
//		   else cStartS = PDS_MAX(cArrTime, problem->node[curC].sTW) + problem->node[curC].duration;
//		   preC = curC; curC = nextArr[curC];
//	   }while (curC != deletednode);
//	   //preC now points to predArr[deletednode]:
//  	   nextC = nextArr[deletednode];
//	   if (delID == nextC) //delID is direct successor of deletednode:
//	   {
//			nextC = nextArr[delID];  
//			if (nextC < 0) // delID was the last cus of the trip --> now preC is the last cus of the trip:
//			{
//				lastCNEW = preC;
//				varcost -= (problem->c[preC][deletednode] + problem->c[deletednode][delID]);
//				//varcost += (problem->c[preC][0] - (problem->c[preC][deletednode] + problem->c[deletednode][delID] + problem->c[delID][0]));
//			}
//			else //delID is not the last cus of the trip C2C; delID is direct successor of deletednode
//			{
//				varcost += (problem->c[preC][nextC] - (problem->c[preC][deletednode] + problem->c[deletednode][delID] + problem->c[delID][nextC]));
//			    CapVehCus = CAPCus[preC];
//				contCAP = 1; contTW = 1;
//				GoThroughLegC2C(preC,nextC,lastC,cStartS,CapVehCus,varvioCAP,varvioTWC,contCAP,contTW);
//				lastCNEW = lastC;
//			}//delID is not the last cus of the trip C2C; delID is direct successor of deletednode
//	   }
//	   else //delID != nextArr[deletednode]: lasttrip C2C > 2 customers; deletednode is in the middle of trip
//	   {
//		    varcost += (problem->c[preC][nextC] - problem->c[preC][deletednode] - problem->c[deletednode][nextC]);
//			CapVehCus = CAPCus[preC];
//			int pre_delID = predArr[delID];	//for sure nextC != delID
//			contTW = 1; contCAP = 1;
//			GoThroughLegC2C(preC,nextC,pre_delID,cStartS,CapVehCus, varvioCAP,varvioTWC,contCAP,contTW);
//			//preC points to pre[delID]; now delID:
//			nextC = nextArr[delID];
//			if (nextC > 0)
//			{
//				varcost += (problem->c[pre_delID][nextC] - problem->c[pre_delID][delID] - problem->c[delID][nextC]);
//				//from nextC till the end of the trip:
//				contCAP = 1; contTW = 1;
//				GoThroughLegC2C(pre_delID,nextC,lastC,cStartS,CapVehCus, varvioCAP,varvioTWC,contCAP,contTW);
//				lastCNEW = lastC;
//			}
//			else //delID was the last cus --> now pre_delID is the last cus:
//			{
//				lastCNEW = pre_delID;
//				varcost -= problem->c[pre_delID][delID];
//				//varcost += (problem->c[pre_delID][0] - problem->c[pre_delID][delID] - problem->c[delID][0]);
//			}//end delID was the last cus --> now pre_delID is the last cus
//	   }//end delID != nextArr[deletednode]: lasttrip C2C > 2 customers; deletednode is in the middle of trip
//   }//end deletednode is not the first cus
//}
//
//
//
//
//void Solution::cal_deleteCusArrayC2C_LastTrip_FromBeginning(int preC, bool changed_preT, int idVeh, int idTrip, int deletednode, double &varcost, double &varvioTWC, double &varvioTWSP, int &varvioCAP,double cStartS)
//{
//   //idTrip > 0
//   bool contTW; int lastCNEW;
//   SUBcal_deleteCusArrayC2C_FromBeginning(preC, changed_preT, idVeh, idTrip, deletednode, varcost, varvioTWC, varvioTWSP, varvioCAP,cStartS, contTW,lastCNEW);
//   int lastCOLD = seg[idVeh].Trip[idTrip].lastCus;
//   if (lastCOLD != lastCNEW)
//   {
//	   varcost += (problem->c[lastCNEW][0] - problem->c[lastCOLD][0]);
//   }
//}
//
//void Solution::cal_deleteCusArrayC2C_MiddleTrip_FromBeginning(int preC, bool changed_preT, int idVeh, int idTrip, int deletednode, double &varcost, double &varvioTWC, double &varvioTWSP, int &varvioCAP,double cStartS)
//{
//   //11/12/2013: COPY void Update_deleteCusArrayC2C_LastTrip(int idVeh, int idTrip, int lastCSP_preT, double cStartS):
//   //idTrip > 0
//   bool contTW; int lastCNEW;
//   SUBcal_deleteCusArrayC2C_FromBeginning(preC, changed_preT, idVeh, idTrip, deletednode, varcost, varvioTWC, varvioTWSP, varvioCAP,cStartS, contTW,lastCNEW);
//   int lastCOLD = seg[idVeh].Trip[idTrip].lastCus;
//   int nextT = idTrip + 1;
//   int nextSP = seg[idVeh].Trip[idTrip].nextSP;
//   int firstC_nextT = seg[idVeh].Trip[nextT].firstCus;
//   if (lastCOLD == lastCNEW)
//   {
//	   if (contTW)
//	   {
//		   if (nextSP > 0)
//		   {
//				//cStartS is now the new depart of lastCus of C2CTrip
//				if (calChangeCONNECTAtSP_C2CTrip(lastCOLD,idVeh,idTrip,nextT,cStartS,varvioTWSP,varcost) == 0)
//                    GoThroughVehicle(idVeh, nextT, varcost, varvioTWC, varvioTWSP, cStartS, nextSP, firstC_nextT);
//		   }
//		   else
//		   {
//              GoThroughVehicle(idVeh, nextT, varcost, varvioTWC, varvioTWSP, cStartS, lastCOLD, firstC_nextT);
//		   }
//	   }
//   }
//   else //lastCOLD != lastCNEW
//   {
//       varcost -= seg[idVeh].Trip[idTrip].connectCost; 
//	   if (nextSP > 0)
//	   {
//	     if (calChangeCONNECTAtSP_C2CTrip_LastCChanged(lastCNEW,idVeh,idTrip,nextT,cStartS,varvioTWSP,varcost) == 0)
//             GoThroughVehicle(idVeh, nextT, varcost, varvioTWC, varvioTWSP, cStartS, nextSP, firstC_nextT);
//	   }
//	   else //nextT is PTrip or C2C
//	   {
//		   varcost += problem->c[lastCNEW][firstC_nextT];
//           GoThroughVehicle(idVeh, nextT, varcost, varvioTWC, varvioTWSP, cStartS, lastCNEW, firstC_nextT);
//	   }//end nextT is PTrip or C2C
//   }
//}
//
//
//
//void Solution::SUB_Update_deleteCusC2C_FromBeginning(int idVeh,int idTrip, int deletednode, double &varcostpreT, double &varcost){
//	/*19/12/2013: COPY void SUBcal_deleteCusArrayC2C_FromBeginning:
//   idTrip >= 0 --> idTrip belongs to 0..lastT 
//   NOT: (idTrip = 0, 2 orders, nextSP >0)
//   Called by Update_deleteCusC2C_FirstMiddleTrip_FromBeginning and Update_deleteCusC2C_LastTrip_FromBeginning*/
//
//   int delID = problem->node[deletednode].delID; 
//   int lastC = seg[idVeh].Trip[idTrip].lastCus;
//   int preC, nextC;
//   double cStartS;
//
//   if (deletednode == seg[idVeh].Trip[idTrip].firstCus)
//   {
//	   nextC = nextArr[deletednode]; 
//	   if (delID == nextC) //(deletednode, delID) were the first customers of (idVeh, idTrip)
//	   {
//			nextC = nextArr[delID]; //for sure nextC > 0: preC1 - deletednode - delID - nextC....
//			if (idTrip == 0)
//			{
//				preC = 0;
//				varcost = problem->c[0][nextC] - (problem->c[0][deletednode] + problem->c[deletednode][delID] + problem->c[delID][nextC]);
//			}
//			else //idTrip > 0
//			{
//				int preT = idTrip - 1;
//				if (seg[idVeh].Trip[preT].Type == 0)
//				{
//					preC = seg[idVeh].Trip[preT].assSP;
//					cStartS = seg[idVeh].Trip[preT].leaveSP;
//				}
//				else
//				{
//					preC = seg[idVeh].Trip[preT].lastCus;
//					cStartS = depart[preC];
//				}
//				varcostpreT = problem->c[preC][nextC] - seg[idVeh].Trip[preT].connectCost;
//				seg[idVeh].Trip[preT].connectCost = problem->c[preC][nextC];
//				seg[idVeh].Trip[preT].cost += varcostpreT;
//				seg[idVeh].Trip[preT].fitness += varcostpreT;
//			}//end idTrip > 0
//			seg[idVeh].Trip[idTrip].firstCus = nextC; predArr[nextC] = -1;
//			UpdateLegC2C_Cus(preC,nextC,lastC,0,cStartS,1);
//			//(deletednode, delID) are the first customers --> vioCAPCus[deletednode] = vioCAPCus[delID] = 0
//	   }
//	   else //delID is not direct successor of deletednode; deletednode is the first cus of the trip
//	   {
//		   if (idTrip == 0)
//		   {
//			   preC = 0;
//			   varcostpreT = problem->c[0][nextC] - (problem->c[0][deletednode] + problem->c[deletednode][nextC]);
//		   }
//		   else //idTrip > 0
//		   {
//				int preT = idTrip - 1;
//				if (seg[idVeh].Trip[preT].Type == 0)
//				{
//					preC = seg[idVeh].Trip[preT].assSP;
//					cStartS = seg[idVeh].Trip[preT].leaveSP;
//				}
//				else
//				{
//					preC = seg[idVeh].Trip[preT].lastCus;
//					cStartS = depart[preC];
//				}
//				varcostpreT = problem->c[preC][nextC] - seg[idVeh].Trip[preT].connectCost;
//				seg[idVeh].Trip[preT].connectCost = problem->c[preC][nextC];
//				seg[idVeh].Trip[preT].cost += varcostpreT;
//				seg[idVeh].Trip[preT].fitness += varcostpreT;
//		   }//end idTrip > 0
//		   int pre_delID = predArr[delID]; //for sure nextC != delID
//		   UpdateLegC2C_Cus(preC,nextC,pre_delID,0,cStartS,1);
//		   //now delID:
//		    nextC = nextArr[delID]; nextArr[pre_delID] = nextC;
//			if (nextC > 0)
//			{
//				varcost += (problem->c[pre_delID][nextC] - problem->c[pre_delID][delID] - problem->c[delID][nextC]);
//				predArr[nextC] = pre_delID;
//				UpdateLegC2C_Cus(pre_delID,nextC,lastC,CAPCus[pre_delID],depart[pre_delID],0);
//			}
//			else //delID was the last cus --> now pre_delID is the last cus:
//			{
//				seg[idVeh].Trip[idTrip].lastCus = pre_delID;
//				varcost -= problem->c[pre_delID][delID];
//			}//end delID was the last cus --> now pre_delID is the last cus
//	   }//end delID is not direct successor of deletednode; deletednode is the first cus of the trip
//   }
//   else //deletednode is not the first cus
//   {
//	   //calculate from the beginning:
//	   if (idTrip == 0)
//	   {
//		   preC = 0;
//		   cStartS = 0;
//	   }
//	   else //idTrip > 0
//	   {
//		   int preT = idTrip - 1;
//		   if (seg[idVeh].Trip[preT].Type == 0)
//		   {
//			   preC = seg[idVeh].Trip[preT].assSP;
//			   cStartS = seg[idVeh].Trip[preT].leaveSP;
//		   }
//		   else
//		   {
//			   preC = seg[idVeh].Trip[preT].lastCus;
//			   cStartS = depart[preC];
//		   }
//	   }//end idTrip > 0
//	   int curC = seg[idVeh].Trip[idTrip].firstCus;
//	   int pre_deletednode = predArr[deletednode]; //!= curC fore sure
//	   UpdateLegC2C_Cus(preC,curC,pre_deletednode,0,cStartS,1);
//	   //delete deletednode:
//  	   nextC = nextArr[deletednode];
//	   if (delID == nextC) //delID is direct successor of deletednode:
//	   {
//			nextC = nextArr[delID];  
//			nextArr[pre_deletednode] = nextC;
//			if (nextC < 0) // (deletednode and delID) were the last cus of the trip --> now pre_deletednode is the last cus of the trip:
//			{
//				varcost -= (problem->c[pre_deletednode][deletednode] + problem->c[deletednode][delID]);
//				seg[idVeh].Trip[idTrip].lastCus = pre_deletednode;
//			}
//			else //delID is not the last cus of the trip C2C; delID is direct successor of deletednode
//			{
//				predArr[nextC] = pre_deletednode;
//				varcost += (problem->c[pre_deletednode][nextC] - (problem->c[pre_deletednode][deletednode] + problem->c[deletednode][delID] + problem->c[delID][nextC]));
//				UpdateLegC2C_Cus(pre_deletednode,nextC,lastC,CAPCus[pre_deletednode],depart[pre_deletednode],0);
//			}//delID is not the last cus of the trip C2C; delID is direct successor of deletednode
//	   }
//	   else //delID != nextArr[deletednode]: lasttrip C2C > 2 customers; deletednode is in the middle of trip
//	   {
//		    varcost += (problem->c[pre_deletednode][nextC] - problem->c[pre_deletednode][deletednode] - problem->c[deletednode][nextC]);
//			nextArr[pre_deletednode] = nextC; predArr[nextC] = pre_deletednode;
//			int pre_delID = predArr[delID];
//			UpdateLegC2C_Cus(pre_deletednode,nextC,pre_delID,CAPCus[pre_deletednode],depart[pre_deletednode],0);
//			//delete delID:
//			nextC = nextArr[delID];nextArr[pre_delID] = nextC;
//			if (nextC > 0)
//			{
//				varcost += (problem->c[pre_delID][nextC] - problem->c[pre_delID][delID] - problem->c[delID][nextC]);
//				predArr[nextC] = pre_delID;
//				UpdateLegC2C_Cus(pre_delID,nextC,lastC,CAPCus[pre_delID],depart[pre_delID],0);
//			}
//			else //delID was the last cus --> now pre_delID is the last cus:
//			{
//				varcost -= problem->c[pre_delID][delID];
//				seg[idVeh].Trip[idTrip].lastCus = pre_delID;
//			}//end delID was the last cus --> now pre_delID is the last cus
//	   }//end delID != nextArr[deletednode]: lasttrip C2C > 2 customers; deletednode is in the middle of trip
//   }//end deletednode is not the first cus
//}
//
//
//void Solution::Update_deleteCusC2C_LastTrip_FromBeginning(int idVeh, int idTrip, int deletednode)
//{
//   //19/12/2013: idTrip > 0 COPY cal_deleteCusArrayC2C_LastTrip_FromBeginning
//   int lastCOLD = seg[idVeh].Trip[idTrip].lastCus;
//   double varcostpreT = 0;
//   double varcost;
//   SUB_Update_deleteCusC2C_FromBeginning(idVeh,idTrip,deletednode, varcostpreT,varcost);
//   int lastCNEW = seg[idVeh].Trip[idTrip].lastCus;
//   if (lastCOLD != lastCNEW)
//   {
//	   seg[idVeh].Trip[idTrip].connectCost = problem->c[lastCNEW][0];
//	   varcost += (problem->c[lastCNEW][0] - problem->c[lastCOLD][0]);
//   }
//   seg[idVeh].Trip[idTrip].endS = depart[lastCNEW];
//   int varvioCAP = FCAP[lastCNEW] - seg[idVeh].Trip[idTrip].vioCAP;
//   //int varvioCAP = FvioCAPCus[lastCNEW] - seg[idVeh].Trip[idTrip].vioCAP;
//   double varvioTWC = FvioTWCus[lastCNEW] - seg[idVeh].Trip[idTrip].vioTWC;
//   seg[idVeh].Trip[idTrip].vioCAP = FCAP[lastCNEW];
//   //seg[idVeh].Trip[idTrip].vioCAP = FvioCAPCus[lastCNEW];
//   seg[idVeh].Trip[idTrip].vioTWC = FvioTWCus[lastCNEW];
//
//   double varFIT = varcost + VTWCUS * varvioTWC + VCAP * varvioCAP;
//   seg[idVeh].Trip[idTrip].cost += varcost;
//   if (seg[idVeh].Trip[idTrip].vioCAP > 0 || seg[idVeh].Trip[idTrip].vioTWC > eps)
//   {
//		seg[idVeh].Trip[idTrip].feasible = 0;
//		seg[idVeh].Trip[idTrip].fitness += varFIT;
//   }
//   else
//   {
//		seg[idVeh].Trip[idTrip].feasible = 1;
//		seg[idVeh].Trip[idTrip].fitness = seg[idVeh].Trip[idTrip].cost;
//   }
//	double varC1 = varcost + varcostpreT; varFIT += varcostpreT;
//	seg[idVeh].cost += varC1; seg[idVeh].fitness += varFIT; seg[idVeh].vioTWC += varvioTWC; seg[idVeh].vioCAP += varvioCAP;
//	cost += varC1; fitness += varFIT;vioTWC += varvioTWC;vioCAP += varvioCAP;
//}
//
//
//void Solution::Update_deleteCusC2C_FirstMiddleTrip_FromBeginning(int idVeh, int idTrip, int deletednode)
//{
//	//19/12/2013: idTrip != seg[idVeh].numTrips - 1 COPY cal_deleteCusArrayC2C_MiddleTrip_FromBeginning
//	//Called by deleteCusC2CTrip_FromBeginning
//   int lastCOLD = seg[idVeh].Trip[idTrip].lastCus;
//   double varcostpreT = 0;
//   double varcost,varFIT, varC1;
//   SUB_Update_deleteCusC2C_FromBeginning(idVeh,idTrip,deletednode, varcostpreT,varcost);
//   
//
//   int lastCNEW = seg[idVeh].Trip[idTrip].lastCus;
//   int nextT = idTrip + 1; int lastT = seg[idVeh].numTrips - 1;
//   int nextSP = seg[idVeh].Trip[idTrip].nextSP;
//
//   double varvioTWC = FvioTWCus[lastCNEW] - seg[idVeh].Trip[idTrip].vioTWC;
//   int varvioCAP = FCAP[lastCNEW] - seg[idVeh].Trip[idTrip].vioCAP;
//   //int varvioCAP = FvioCAPCus[lastCNEW] - seg[idVeh].Trip[idTrip].vioCAP;
//   seg[idVeh].Trip[idTrip].vioTWC = FvioTWCus[lastCNEW];
//   seg[idVeh].Trip[idTrip].vioCAP = FCAP[lastCNEW];
//   //seg[idVeh].Trip[idTrip].vioCAP = FvioCAPCus[lastCNEW];
//
//   if (lastCOLD == lastCNEW)
//   {
//	   if (PDSDIF(seg[idVeh].Trip[idTrip].endS, depart[lastCNEW]) == 1) //endS has changed
//	   {
//		    seg[idVeh].Trip[idTrip].endS = depart[lastCNEW];
//			if (nextSP > 0)
//			{
//			   varcost -= seg[idVeh].Trip[idTrip].connectCost;
//			   UpdateChangeCONNECTAtSP_C2CTrip(idVeh,idTrip,nextT,nextSP,varcost,varcostpreT,varvioTWC,varvioCAP,lastT);
//			   return;
//			}
//			else //nextT is PTrip OR C2C; lastC has not changed
//				goto UpdateC_nextPTripORC2C;
//	   }
//	   else goto UpdateNC;
//   }
//   else //lastCOLD != lastCNEW
//   {
//	   seg[idVeh].Trip[idTrip].endS = depart[lastCNEW];
//       varcost -= seg[idVeh].Trip[idTrip].connectCost; 
//	   if (nextSP > 0)
//	   {
//		   UpdateChangeCONNECTAtSP_C2CTrip(idVeh,idTrip,nextT,nextSP,varcost,varcostpreT,varvioTWC,varvioCAP,lastT);
//		   return;
//	   }
//	   else //nextT is PTrip or C2C; not lastTrip
//	   {
//		  seg[idVeh].Trip[idTrip].connectCost = problem->c[lastCNEW][seg[idVeh].Trip[nextT].firstCus];
//		  varcost += seg[idVeh].Trip[idTrip].connectCost;
//		  goto UpdateC_nextPTripORC2C;
//	   }//end nextT is PTrip or C2C; not lastTrip
//   }//end lastCOLD != lastCNEW
//
//UpdateNC:
//	varFIT = varcost + VTWCUS * varvioTWC + VCAP * varvioCAP;
//	seg[idVeh].Trip[idTrip].cost += varcost;
//	if (seg[idVeh].Trip[idTrip].vioCAP > 0 || seg[idVeh].Trip[idTrip].vioTWC > eps)
//	{
//		seg[idVeh].Trip[idTrip].feasible = 0;
//		seg[idVeh].Trip[idTrip].fitness += varFIT;
//	}
//	else
//	{
//		seg[idVeh].Trip[idTrip].feasible = 1;
//		seg[idVeh].Trip[idTrip].fitness = seg[idVeh].Trip[idTrip].cost;
//	}
//	varC1 = varcost + varcostpreT;varFIT += varcostpreT;
//	seg[idVeh].cost += varC1; seg[idVeh].fitness += varFIT; seg[idVeh].vioTWC += varvioTWC; seg[idVeh].vioCAP += varvioCAP;
//	cost += varC1; fitness += varFIT;vioTWC += varvioTWC;vioCAP += varvioCAP;
//    return;
//
//UpdateC_nextPTripORC2C:
//		varFIT = varcost + VTWCUS * varvioTWC + VCAP * varvioCAP;
//		seg[idVeh].Trip[idTrip].cost += varcost;
//		if (seg[idVeh].Trip[idTrip].vioCAP > 0 || seg[idVeh].Trip[idTrip].vioTWC > eps)
//		{
//			seg[idVeh].Trip[idTrip].feasible = 0;
//			seg[idVeh].Trip[idTrip].fitness += varFIT;
//		}
//		else
//		{
//			seg[idVeh].Trip[idTrip].feasible = 1;
//			seg[idVeh].Trip[idTrip].fitness = seg[idVeh].Trip[idTrip].cost;
//		}
//		UpdateVehicle(idVeh, nextT,lastCNEW,seg[idVeh].Trip[idTrip].endS,varvioCAP,lastT);
//}
//
//void Solution::deleteCusC2CTrip(int idVeh, int idTrip, int pre_deletednode, int deletednode, int next_deletednode) //for the trip with > 1 order
//{
//	//Update 15/12/2013: COPY deleteCusC2CTrip_TillTrip
//
//	int nextSP = seg[idVeh].Trip[idTrip].nextSP;
//	seg[idVeh].Trip[idTrip].numCus -= 2;
//	if (idTrip == 0 && seg[idVeh].Trip[idTrip].numCus == 2 && nextSP > 0)
//		Update_deleteCusC2CTrip_FirstTrip_4Cus_nextD(idVeh,pre_deletednode,deletednode,next_deletednode,nextSP,seg[idVeh].numTrips - 1);
//	else
//	{
//		int lastT = seg[idVeh].numTrips - 1;
//		if (idTrip < lastT)
//		   Update_deleteCusC2C_FirstMiddleTrip(idVeh, idTrip, pre_deletednode, deletednode, next_deletednode, seg[idVeh].numTrips - 1);
//		else
//	       Update_deleteCusC2C_LastTrip(idVeh, idTrip, pre_deletednode,deletednode,next_deletednode); 
//		//UpdateBvioTW_BvioCAPCus(idVeh, idTrip, seg[idVeh].Trip[idTrip].lastCus);
//	}
//
//	bool stop = checkVehicle(idVeh);
//	if (stop)
//	{
//		cout<<"CASE1: STOP AT deleteCusC2CTrip @IT = "<<IT<<endl;
//		exit(-1);
//	}
//}
//
//void Solution::deleteCusC2CTrip_TillTrip(int idVeh, int idTrip, int pre_deletednode, int deletednode, int next_deletednode, int update_idTrip) //for the trip with > 1 order
//{
//	//Update 15/12/2013: COPY deleteCusC2CTrip
//
//	int nextSP = seg[idVeh].Trip[idTrip].nextSP;
//	seg[idVeh].Trip[idTrip].numCus -= 2;
//	if (idTrip == 0 && seg[idVeh].Trip[idTrip].numCus == 2 && nextSP > 0)
//		Update_deleteCusC2CTrip_FirstTrip_4Cus_nextD(idVeh,pre_deletednode,deletednode,next_deletednode,nextSP,update_idTrip);
//	else
//	{
//		int lastT = seg[idVeh].numTrips - 1;
//		if (idTrip < lastT)
//		   Update_deleteCusC2C_FirstMiddleTrip(idVeh, idTrip, pre_deletednode, deletednode, next_deletednode,update_idTrip);
//		else
//	       Update_deleteCusC2C_LastTrip(idVeh, idTrip, pre_deletednode,deletednode,next_deletednode); 
//	}
//
//	bool stop = checkVehicle(idVeh);
//	if (stop)
//	{
//		cout<<"CASE1: STOP AT deleteCusC2CTrip @IT = "<<IT<<endl;
//		exit(-1);
//	}
//}
//
//
//void Solution::deleteCusC2CTrip_FromBeginning(int idVeh, int idTrip, int pre_deletednode, int deletednode, int next_deletednode)
//{
//	//for the trip with > 1 order
//	seg[idVeh].Trip[idTrip].numCus -= 2;
//	int nextSP = seg[idVeh].Trip[idTrip].nextSP;
//	if (idTrip == 0 && seg[idVeh].Trip[idTrip].numCus == 2 && nextSP > 0)
//		Update_deleteCusC2CTrip_FirstTrip_4Cus_nextD(idVeh,pre_deletednode,deletednode,next_deletednode,nextSP,seg[idVeh].numTrips - 1);
//	else
//	{
//		int lastT = seg[idVeh].numTrips - 1;
//		if (idTrip < lastT)
//		   Update_deleteCusC2C_FirstMiddleTrip_FromBeginning(idVeh, idTrip, deletednode);
//		else
//	       Update_deleteCusC2C_LastTrip_FromBeginning(idVeh, idTrip, deletednode); 
//	}
//
//}
//
//void Solution::Update_InsertCusC2CTrip_2CusFirstTrip_nextD(int j, int i, int cusDi_insert_After, int idVeh, int idTrip, int nextSP, int update_idTrip)
//{
//	//17/12/2013
//	cout<<"INSIDE Update_InsertCusC2CTrip_2CusFirstTrip_nextD"<<endl;
//	int cusDi = problem->node[i].delID;
//	int curC = seg[idVeh].Trip[idTrip].firstCus;
//	startS[curC] = problem->node[curC].startS_depot;
//	depart[curC] = problem->node[curC].depart_depot;
//	int lastC = seg[idVeh].Trip[idTrip].lastCus;
//	double varcost, varvioTWC; int varvioCAP;
//	int nextT = idTrip + 1;
//	if (curC == j) //1+ i cusDi 1-
//	{
//		cout<<"CASE 1: "<<endl;
//		nextArr[j] = i; predArr[i] = j;
//		Update_InsertCusC2CIAfterJ(j,i,idVeh,idTrip);
//		if (cusDi_insert_After != i)
//		{
//			cout<<"ERROR Update_InsertCusC2CTrip_2CusFirstTrip_nextD: trying to insert C2CD "<<cusDi<<" that doesn't satisfy LIFO"<<endl;
//			cout<<"First c2c trip with 1 order (C2CP, C2CD) = ("<<j<<", "<<lastC<<"); insert C2CP after "<<j<<"; and C2CD after "<<cusDi_insert_After<<endl;
//			exit(-1);
//		}
//		nextArr[i] = cusDi; predArr[cusDi] = i;
//		Update_InsertCusC2CIAfterJ(i,cusDi,idVeh,idTrip);
//		nextArr[cusDi] = lastC; predArr[lastC] = cusDi;
//		UpdateLegC2C_Cus(cusDi,lastC,lastC,CAPCus[cusDi],depart[cusDi],0);
//		varcost = problem->c[j][i] + problem->c[i][cusDi] + problem->c[cusDi][lastC] - problem->c[j][lastC];
//		varvioTWC = FvioTWCus[lastC] - seg[idVeh].Trip[idTrip].vioTWC;
//		varvioCAP = FCAP[lastC] - seg[idVeh].Trip[idTrip].vioCAP;
//		//varvioCAP = FvioCAPCus[lastC] - seg[idVeh].Trip[idTrip].vioCAP;
//		seg[idVeh].Trip[idTrip].vioTWC = FvioTWCus[lastC];
//		seg[idVeh].Trip[idTrip].vioCAP = FCAP[lastC];
//		//seg[idVeh].Trip[idTrip].vioCAP = FvioCAPCus[lastC];
//		if (PDSDIF(seg[idVeh].Trip[idTrip].endS, depart[lastC]) == 0) //endS has changed
//		{
//			 varcost -= seg[idVeh].Trip[idTrip].connectCost;
//		     UpdateChangeCONNECTAtSP_C2CTrip(idVeh,idTrip,nextT,nextSP,varcost,0,varvioTWC,varvioCAP,update_idTrip);
//			 return;
//		}
//		else //endS has not changed
//		{
//			double varFIT = varcost + VTWCUS * varvioTWC + VCAP * varvioCAP;
//			seg[idVeh].Trip[idTrip].cost += varcost;
//			if (seg[idVeh].Trip[idTrip].vioCAP > 0 || seg[idVeh].Trip[idTrip].vioTWC > eps)
//			{
//				seg[idVeh].Trip[idTrip].feasible = 0;
//				seg[idVeh].Trip[idTrip].fitness += varFIT;
//			}
//			else
//			{
//				seg[idVeh].Trip[idTrip].feasible = 1;
//				seg[idVeh].Trip[idTrip].fitness = seg[idVeh].Trip[idTrip].cost;
//			}
//			//varC1 = varcost + varcostpreT;varFIT += varcostpreT;
//			seg[idVeh].cost += varcost; seg[idVeh].fitness += varFIT; seg[idVeh].vioTWC += varvioTWC; seg[idVeh].vioCAP += varvioCAP;
//			cost += varcost; fitness += varFIT;vioTWC += varvioTWC;vioCAP += varvioCAP;
//		}
//	}
//	else //1+ 1- i+ cusDi
//	{
//		cout<<"CASE 2"<<endl;
//		UpdateLegC2C_Cus(curC,lastC,lastC,CAPCus[curC],depart[curC],0);
//		nextArr[lastC] = i; predArr[i] = lastC;
//		Update_InsertCusC2CIAfterJ(lastC,i,idVeh,idTrip);
//		nextArr[i] = cusDi; predArr[cusDi] = i; nextArr[cusDi] = -1;
//		Update_InsertCusC2CIAfterJ(i, cusDi,idVeh,idTrip);
//		varcost = problem->c[lastC][i] + problem->c[i][cusDi] - seg[idVeh].Trip[idTrip].connectCost;
//		seg[idVeh].Trip[idTrip].lastCus = cusDi;
//		seg[idVeh].Trip[idTrip].endS = depart[cusDi];
//		varvioTWC = FvioTWCus[cusDi] - seg[idVeh].Trip[idTrip].vioTWC;
//		varvioCAP = FCAP[cusDi] - seg[idVeh].Trip[idTrip].vioCAP;
//		//varvioCAP = FvioCAPCus[cusDi] - seg[idVeh].Trip[idTrip].vioCAP;
//		seg[idVeh].Trip[idTrip].vioTWC = FvioTWCus[cusDi];
//		seg[idVeh].Trip[idTrip].vioCAP = FCAP[cusDi];
//		//seg[idVeh].Trip[idTrip].vioCAP = FvioCAPCus[cusDi];
//        UpdateChangeCONNECTAtSP_C2CTrip(idVeh,idTrip,nextT,nextSP,varcost,0,varvioTWC,varvioCAP,update_idTrip);
//	} //end 1+ 1- i+ cusDi
//}
//
//void Solution::Update_InsertCusC2CIAfterJ(int j, int i, int idVeh, int idTrip)
//{
//		pos[i] = pos[j] + 1; //insert i after j
//		route_num[i] = idVeh; trip_num[i] = idTrip;
//		double departi = depart[j] + problem->c[j][i];
//		double temp = departi - problem->node[i].eTW;
//		if (temp > eps)
//		{
//			vioTWCus[i] = temp;
//			FvioTWCus[i] = FvioTWCus[j] + temp;
//			startS[i] = problem->node[i].eTW;
//			depart[i] = problem->node[i].depart;
//		}
//		else 
//		{   vioTWCus[i] = 0; FvioTWCus[i] = FvioTWCus[j];
//		    startS[i] = PDS_MAX(departi, problem->node[i].sTW);
//			depart[i] = startS[i] + problem->node[i].duration;
//		}
//
//		CAPCus[i] = CAPCus[j] + problem->node[i].capacity;
//		int tQ = CAPCus[i] - Q;
//		if (tQ > 0) 
//		{
//			CAPCus[i] = Q;
//			vioCAPCus[i] = tQ;
//			FCAP[i] = FCAP[j] + tQ;
//			//FvioCAPCus[i] = FvioCAPCus[j] + tQ;
//		}
//		else
//		{
//			vioCAPCus[i] = 0;
//			FCAP[i] = FCAP[j];
//			//FvioCAPCus[i] = FvioCAPCus[j];
//		}
//}
//void Solution::insertCusC2CTrip(int j, int i, int cusDi_insert_After,int idVeh, int idTrip, int update_idTrip)
//{
//	//16/12/2013: insert i after j and delID of i after cusDi_insert_After on (idVeh, idTrip) and update remaining trips till trip update_idTrip
//	//COPY insertCusC2CTrip_FromBeginning
//	int numCj = seg[idVeh].Trip[idTrip].numCus;
//	seg[idVeh].Trip[idTrip].numCus += 2;
//	int nextSP = seg[idVeh].Trip[idTrip].nextSP;
//
//	//cout<<"INSIDE insertCusC2CTrip: nextSP = "<<nextSP<<"; idVeh = "<<idVeh<<"; idTrip = "<<idTrip<<"; numCj = "<<numCj<<"; j = "<<j<<";i = "<<i<<"; cusDi_insert_After = "<<cusDi_insert_After<<endl;
//	if (idTrip == 0 && numCj == 2 && nextSP > 0)  
//        Update_InsertCusC2CTrip_2CusFirstTrip_nextD(j,i,cusDi_insert_After, idVeh, idTrip,nextSP,update_idTrip);	
//		//stop = SUBcal_InsertCusC2CIAfterJ_2CusFirstTrip_nextD(j,i,idVeh,nextSP,preTi,varcostj,varvioTWCj,varvioTWSPj,varvioCAP,moveAfter,cStartS); //11/12/2013
//	else 
//	{
//		int nextT = idTrip + 1;
//		int lastT = seg[idVeh].numTrips - 1;
//		int cusDi = problem->node[i].delID;
//		int nextj = nextArr[j]; 
//		int lastCOLD = seg[idVeh].Trip[idTrip].lastCus;
//		double varvioTWC,varcost,varFIT;
//		int varvioCAP;
//
//		//1. Insert i after j:
//		nextArr[j] = i; predArr[i] = j;
//		Update_InsertCusC2CIAfterJ(j,i,idVeh,idTrip);
//
//		if (cusDi_insert_After == i) //insert cusDi right after i:
//		{
//			 //insert cusDi right after i:
//			 //cout<<"CASE 2.1 of insertCusC2CTrip"<<endl;
//			 nextArr[i] = cusDi; predArr[cusDi] = i;
//			 nextArr[cusDi] = nextj;
//			 varcost = problem->c[j][i] + problem->c[i][cusDi];
//			 Update_InsertCusC2CIAfterJ(i,cusDi,idVeh,idTrip);
//			 if (nextj > 0) //insert (i and cusDi) in the middle of the trip:
//			 {
//				 //From nexti till the end of the trip:
//				 predArr[nextj] = cusDi;
//				 UpdateLegC2C_Cus(cusDi,nextj,lastCOLD,CAPCus[cusDi],depart[cusDi],0);
//				 varcost += (problem->c[cusDi][nextj] - problem->c[j][nextj]);
//				 varvioTWC = FvioTWCus[lastCOLD] - seg[idVeh].Trip[idTrip].vioTWC;
//				 varvioCAP = FCAP[lastCOLD] - seg[idVeh].Trip[idTrip].vioCAP;
//				 //varvioCAP = FvioCAPCus[lastCOLD] - seg[idVeh].Trip[idTrip].vioCAP;
//				 seg[idVeh].Trip[idTrip].vioTWC = FvioTWCus[lastCOLD];
//				 seg[idVeh].Trip[idTrip].vioCAP = FCAP[lastCOLD];
//				 //seg[idVeh].Trip[idTrip].vioCAP = FvioCAPCus[lastCOLD];
//
//				 if (nextSP > 0) //nextT is DTrip
//				 {
//				    if (PDSDIF(seg[idVeh].Trip[idTrip].endS, depart[lastCOLD]) == 1) //endS has changed
//				    {
//				        seg[idVeh].Trip[idTrip].endS = depart[lastCOLD];
//						varcost -= seg[idVeh].Trip[idTrip].connectCost;
//        				UpdateChangeCONNECTAtSP_C2CTrip(idVeh,idTrip,nextT,nextSP,varcost,0,varvioTWC,varvioCAP,update_idTrip);
//						return;
//				    }
//				    else goto UpdateNC; //endS has not changed
//				 }
//				 else //nextT is lastT or PTripORC2C
//				 {
//					 if (idTrip == lastT)
//					 {
//						 seg[idVeh].Trip[idTrip].endS = depart[lastCOLD];
//						 goto UpdateNC;
//					 }
//					 else //nextT is PTrip OR C2C
//					 {
//						if (PDSDIF(seg[idVeh].Trip[idTrip].endS, depart[lastCOLD]) == 1) //endS has changed
//						{
//							seg[idVeh].Trip[idTrip].endS = depart[lastCOLD];
//        					goto UpdateC_nextPTripORC2C;
//						}
//						else goto UpdateNC; //endS has not changed
//					 } //end nextT is PTrip OR C2C
//				 }//end nextT is lasT or PTripORC2C
//			 }
//			 else //insert (i and cusDi) at the end of the trip
//			 {
//				 seg[idVeh].Trip[idTrip].lastCus = cusDi; //nextArr[cusDi] = -1;
//				 seg[idVeh].Trip[idTrip].endS = depart[cusDi];
//				 varcost -= seg[idVeh].Trip[idTrip].connectCost;
//				 varvioTWC = FvioTWCus[cusDi] - seg[idVeh].Trip[idTrip].vioTWC;
//				 varvioCAP = FCAP[cusDi] - seg[idVeh].Trip[idTrip].vioCAP;
//				 //varvioCAP = FvioCAPCus[cusDi] - seg[idVeh].Trip[idTrip].vioCAP;
//				 seg[idVeh].Trip[idTrip].vioTWC = FvioTWCus[cusDi];
//				 seg[idVeh].Trip[idTrip].vioCAP = FCAP[cusDi];
//				 //seg[idVeh].Trip[idTrip].vioCAP = FvioCAPCus[cusDi];
//				 if (nextSP > 0)
//				 {
//					//varcost -= seg[idVeh].Trip[idTrip].connectCost; //lastC changed
//					UpdateChangeCONNECTAtSP_C2CTrip(idVeh,idTrip,nextT,nextSP,varcost,0,varvioTWC,varvioCAP,update_idTrip);
//					return;
//				 }
//				 else //is last trip OR (nextTrip is PTrip or c2c)
//				 {
//					 if (idTrip == lastT)
//					 {
//						 seg[idVeh].Trip[idTrip].connectCost = problem->c[cusDi][0];
//						 varcost += seg[idVeh].Trip[idTrip].connectCost;
//						 goto UpdateNC;
//					 }
//					 else //nextTrip is PTrip or C2C
//					 {
//						 seg[idVeh].Trip[idTrip].connectCost = problem->c[cusDi][seg[idVeh].Trip[nextT].firstCus];
//						 varcost += seg[idVeh].Trip[idTrip].connectCost;
//						 goto UpdateC_nextPTripORC2C;
//					 }
//				 }
//			 }//end insert (i and cusDi) at the end of the trip
//		}
//		else //not insert cusDi right after i
//		{
//			//cout<<"CASE 2.2 of insertCusC2CTrip"<<endl;
//			nextArr[i] = nextj; predArr[nextj] = i;
//			varcost = problem->c[j][i] + problem->c[i][nextj] - problem->c[j][nextj];
//			//from i to cusDi_insert_After
//			UpdateLegC2C_Cus(i,nextj,cusDi_insert_After,CAPCus[i],depart[i],0);
//			//Insert cusDi after cusDi_insert_After:
//			int nextC = nextArr[cusDi_insert_After];
//			nextArr[cusDi_insert_After] = cusDi; predArr[cusDi] = cusDi_insert_After;
//			nextArr[cusDi] = nextC;
//			varcost += problem->c[cusDi_insert_After][cusDi];
//			Update_InsertCusC2CIAfterJ(cusDi_insert_After,cusDi,idVeh,idTrip);
//
//			if (nextC > 0) //insert (i and cusDi) in the middle of the trip:
//			{
//				 //From nextC till the end of the trip:
//				 predArr[nextC] = cusDi;
//				 UpdateLegC2C_Cus(cusDi,nextC,lastCOLD,CAPCus[cusDi],depart[cusDi],0);
//				 varcost += (problem->c[cusDi][nextC] - problem->c[cusDi_insert_After][nextC]);
//				 varvioTWC = FvioTWCus[lastCOLD] - seg[idVeh].Trip[idTrip].vioTWC;
//				 varvioCAP = FCAP[lastCOLD] - seg[idVeh].Trip[idTrip].vioCAP;
//				 //varvioCAP = FvioCAPCus[lastCOLD] - seg[idVeh].Trip[idTrip].vioCAP;
//				 seg[idVeh].Trip[idTrip].vioTWC = FvioTWCus[lastCOLD];
//				 seg[idVeh].Trip[idTrip].vioCAP = FCAP[lastCOLD];
//				 //seg[idVeh].Trip[idTrip].vioCAP = FvioCAPCus[lastCOLD];
//				 if (nextSP > 0) //nextT is DTrip
//				 {
//				    if (PDSDIF(seg[idVeh].Trip[idTrip].endS, depart[lastCOLD]) == 1) //endS has changed
//				    {
//				        seg[idVeh].Trip[idTrip].endS = depart[lastCOLD];
//						varcost -= seg[idVeh].Trip[idTrip].connectCost;
//        				UpdateChangeCONNECTAtSP_C2CTrip(idVeh,idTrip,nextT,nextSP,varcost,0,varvioTWC,varvioCAP,update_idTrip);
//						return;
//				    }
//				    else goto UpdateNC; //endS has not changed
//				 }
//				 else //nextT is lastT or PTripORC2C
//				 {
//					 if (idTrip == lastT)
//					 {
//						 seg[idVeh].Trip[idTrip].endS = depart[lastCOLD];
//						 goto UpdateNC;
//					 }
//					 else //nextT is PTrip OR C2C
//					 {
//						if (PDSDIF(seg[idVeh].Trip[idTrip].endS, depart[lastCOLD]) == 1) //endS has changed
//						{
//							seg[idVeh].Trip[idTrip].endS = depart[lastCOLD];
//        					goto UpdateC_nextPTripORC2C;
//						}
//						else goto UpdateNC; //endS has not changed
//					 } //end nextT is PTrip OR C2C
//				 }//end nextT is lasT or PTripORC2C
//			}
//			else //cusDi_insert_After was the last cus --> cusDi is now the last cus
//			{
//				seg[idVeh].Trip[idTrip].lastCus = cusDi;
//				seg[idVeh].Trip[idTrip].endS = depart[cusDi];
//				varcost -= seg[idVeh].Trip[idTrip].connectCost;
//				varvioTWC = FvioTWCus[cusDi] - seg[idVeh].Trip[idTrip].vioTWC;
//				varvioCAP = FCAP[cusDi] - seg[idVeh].Trip[idTrip].vioCAP;
//				//varvioCAP = FvioCAPCus[cusDi] - seg[idVeh].Trip[idTrip].vioCAP;
//				seg[idVeh].Trip[idTrip].vioTWC = FvioTWCus[cusDi];
//				seg[idVeh].Trip[idTrip].vioCAP = FCAP[cusDi];
//				//seg[idVeh].Trip[idTrip].vioCAP = FvioCAPCus[cusDi];
//				if (nextSP > 0)
//				{
//					//varcost -= seg[idVeh].Trip[idTrip].connectCost; //lastC changed
//					UpdateChangeCONNECTAtSP_C2CTrip(idVeh,idTrip,nextT,nextSP,varcost,0,varvioTWC,varvioCAP,update_idTrip);
//					return;
//				}
//				else //is last trip OR (nextTrip is PTrip or c2c)
//				{
//					 if (idTrip == lastT)
//					 {
//						 seg[idVeh].Trip[idTrip].connectCost = problem->c[cusDi][0];
//						 varcost += seg[idVeh].Trip[idTrip].connectCost;
//						 goto UpdateNC;
//					 }
//					 else //nextTrip is PTrip or C2C
//					 {
//						 seg[idVeh].Trip[idTrip].connectCost = problem->c[cusDi][seg[idVeh].Trip[nextT].firstCus];
//						 varcost += seg[idVeh].Trip[idTrip].connectCost;
//						 goto UpdateC_nextPTripORC2C;
//					 }
//				 }
//			}
//		}//end not insert cusDi right after i
//		UpdateC_nextPTripORC2C:
//			varFIT = varcost + VTWCUS * varvioTWC + VCAP * varvioCAP;
//			seg[idVeh].Trip[idTrip].cost += varcost;
//			if (seg[idVeh].Trip[idTrip].vioCAP > 0 || seg[idVeh].Trip[idTrip].vioTWC > eps)
//			{
//				seg[idVeh].Trip[idTrip].feasible = 0;
//				seg[idVeh].Trip[idTrip].fitness += varFIT;
//			}
//			else
//			{
//				seg[idVeh].Trip[idTrip].feasible = 1;
//				seg[idVeh].Trip[idTrip].fitness = seg[idVeh].Trip[idTrip].cost;
//			}
//			UpdateVehicle(idVeh, nextT,seg[idVeh].Trip[idTrip].lastCus,seg[idVeh].Trip[idTrip].endS,varvioCAP,update_idTrip);
//			goto CHECK;
//         
//        UpdateNC:
//			varFIT = varcost + VTWCUS * varvioTWC + VCAP * varvioCAP;
//			seg[idVeh].Trip[idTrip].cost += varcost;
//			if (seg[idVeh].Trip[idTrip].vioCAP > 0 || seg[idVeh].Trip[idTrip].vioTWC > eps)
//			{
//				seg[idVeh].Trip[idTrip].feasible = 0;
//				seg[idVeh].Trip[idTrip].fitness += varFIT;
//			}
//			else
//			{
//				seg[idVeh].Trip[idTrip].feasible = 1;
//				seg[idVeh].Trip[idTrip].fitness = seg[idVeh].Trip[idTrip].cost;
//			}
//			//varC1 = varcost + varcostpreT;varFIT += varcostpreT;
//			seg[idVeh].cost += varcost; seg[idVeh].fitness += varFIT; seg[idVeh].vioTWC += varvioTWC; seg[idVeh].vioCAP += varvioCAP;
//			cost += varcost; fitness += varFIT;vioTWC += varvioTWC;vioCAP += varvioCAP;
//	}
//CHECK:
//    UpdateBvioTW_BvioCAPCus(idVeh, idTrip,  seg[idVeh].Trip[idTrip].lastCus);
//	bool stop = checkVehicle(idVeh);
//	if (stop)
//	{
//		cout<<"CASE1: STOP AT insertCusC2CTrip @IT = "<<IT<<endl;
//		exit(-1);
//	}
//}
//
//
//void Solution::insertCusC2CTrip_FromBeginning(int j, int i, int cusDi_insert_After,int idVeh, int idTrip, int update_idTrip)
//{
//	//19/12/2013: insert i after j and delID of i after cusDi_insert_After on (idVeh, idTrip) and update remaining trips till trip update_idTrip
//    // COPY insertCusC2CTrip 
//	int numCj = seg[idVeh].Trip[idTrip].numCus;
//	seg[idVeh].Trip[idTrip].numCus += 2;
//	int nextSP = seg[idVeh].Trip[idTrip].nextSP;
//
//	if (idTrip == 0 && numCj == 2 && nextSP > 0)  
//        Update_InsertCusC2CTrip_2CusFirstTrip_nextD(j,i,cusDi_insert_After, idVeh, idTrip,nextSP, update_idTrip);	
//	else 
//	{
//		int nextT = idTrip + 1;
//		int lastT = seg[idVeh].numTrips - 1;
//		int cusDi = problem->node[i].delID;
//		int nextj = nextArr[j]; 
//		int lastCOLD = seg[idVeh].Trip[idTrip].lastCus;
//		double varvioTWC,varcost,varFIT,cStartS;
//		int varvioCAP; int preC;
//		if (idTrip == 0)
//		{
//			preC = 0; 
//			cStartS = 0;
//		}
//		else
//		{
//			int preT = idTrip - 1;
//			if (seg[idVeh].Trip[preT].Type == 0)
//			{
//				preC = seg[idVeh].Trip[preT].assSP;
//				cStartS = seg[idVeh].Trip[preT].leaveSP;
//			}
//			else
//			{
//				preC = seg[idVeh].Trip[preT].lastCus;
//				cStartS = depart[preC];
//			}
//		}
//		UpdateLegC2C_Cus_Time(preC,seg[idVeh].Trip[idTrip].firstCus,j,0,cStartS,1);
//
//		//1. Insert i after j:
//		nextArr[j] = i; predArr[i] = j;
//		Update_InsertCusC2CIAfterJ(j,i,idVeh,idTrip);
//
//		if (cusDi_insert_After == i) //insert cusDi right after i:
//		{
//			 //insert cusDi right after i:
//			 nextArr[i] = cusDi; predArr[cusDi] = i;
//			 nextArr[cusDi] = nextj;
//			 varcost = problem->c[j][i] + problem->c[i][cusDi];
//			 Update_InsertCusC2CIAfterJ(i,cusDi,idVeh,idTrip);
//			 if (nextj > 0) //insert (i and cusDi) in the middle of the trip:
//			 {
//				 //From nexti till the end of the trip:
//				 predArr[nextj] = cusDi;
//				 UpdateLegC2C_Cus(cusDi,nextj,lastCOLD,CAPCus[cusDi],depart[cusDi],0);
//				 varcost += (problem->c[cusDi][nextj] - problem->c[j][nextj]);
//				 varvioTWC = FvioTWCus[lastCOLD] - seg[idVeh].Trip[idTrip].vioTWC;
//				 varvioCAP = FCAP[lastCOLD] - seg[idVeh].Trip[idTrip].vioCAP;
//				 //varvioCAP = FvioCAPCus[lastCOLD] - seg[idVeh].Trip[idTrip].vioCAP;
//				 seg[idVeh].Trip[idTrip].vioTWC = FvioTWCus[lastCOLD];
//				 seg[idVeh].Trip[idTrip].vioCAP = FCAP[lastCOLD];
//				 //seg[idVeh].Trip[idTrip].vioCAP = FvioCAPCus[lastCOLD];
//
//				 if (nextSP > 0) //nextT is DTrip
//				 {
//				    if (PDSDIF(seg[idVeh].Trip[idTrip].endS, depart[lastCOLD]) == 0) //endS has changed
//				    {
//				        seg[idVeh].Trip[idTrip].endS = depart[lastCOLD];
//						varcost -= seg[idVeh].Trip[idTrip].connectCost;
//        				UpdateChangeCONNECTAtSP_C2CTrip(idVeh,idTrip,nextT,nextSP,varcost,0,varvioTWC,varvioCAP,update_idTrip);
//						return;
//				    }
//				    else goto UpdateNC; //endS has not changed
//				 }
//				 else //nextT is lastT or PTripORC2C
//				 {
//					 if (idTrip == lastT)
//					 {
//						 seg[idVeh].Trip[idTrip].endS = depart[lastCOLD];
//						 goto UpdateNC;
//					 }
//					 else //nextT is PTrip OR C2C
//					 {
//						if (PDSDIF(seg[idVeh].Trip[idTrip].endS, depart[lastCOLD]) == 0) //endS has changed
//						{
//							seg[idVeh].Trip[idTrip].endS = depart[lastCOLD];
//        					goto UpdateC_nextPTripORC2C;
//						}
//						else goto UpdateNC; //endS has not changed
//					 } //end nextT is PTrip OR C2C
//				 }//end nextT is lasT or PTripORC2C
//			 }
//			 else //insert (i and cusDi) at the end of the trip
//			 {
//				 seg[idVeh].Trip[idTrip].lastCus = cusDi; //nextArr[cusDi] = -1;
//				 seg[idVeh].Trip[idTrip].endS = depart[cusDi];
//				 varcost -= seg[idVeh].Trip[idTrip].connectCost;
//				 varvioTWC = FvioTWCus[cusDi] - seg[idVeh].Trip[idTrip].vioTWC;
//				 varvioCAP = FCAP[cusDi] - seg[idVeh].Trip[idTrip].vioCAP;
//				 //varvioCAP = FvioCAPCus[cusDi] - seg[idVeh].Trip[idTrip].vioCAP;
//				 seg[idVeh].Trip[idTrip].vioTWC = FvioTWCus[cusDi];
//				 seg[idVeh].Trip[idTrip].vioCAP = FCAP[cusDi];
//				 //seg[idVeh].Trip[idTrip].vioCAP = FvioCAPCus[cusDi];
//				 if (nextSP > 0)
//				 {
//					//varcost -= seg[idVeh].Trip[idTrip].connectCost; //lastC changed
//					UpdateChangeCONNECTAtSP_C2CTrip(idVeh,idTrip,nextT,nextSP,varcost,0,varvioTWC,varvioCAP,update_idTrip);
//					return;
//				 }
//				 else //is last trip OR (nextTrip is PTrip or c2c)
//				 {
//					 if (idTrip == lastT)
//					 {
//						 seg[idVeh].Trip[idTrip].connectCost = problem->c[cusDi][0];
//						 varcost += seg[idVeh].Trip[idTrip].connectCost;
//						 goto UpdateNC;
//					 }
//					 else //nextTrip is PTrip or C2C
//					 {
//						 seg[idVeh].Trip[idTrip].connectCost = problem->c[cusDi][seg[idVeh].Trip[nextT].firstCus];
//						 varcost += seg[idVeh].Trip[idTrip].connectCost;
//						 goto UpdateC_nextPTripORC2C;
//					 }
//				 }
//			 }//end insert (i and cusDi) at the end of the trip
//		}
//		else //not insert cusDi right after i
//		{
//			varcost = problem->c[j][i] + problem->c[i][nextj] - problem->c[j][nextj];
//			//from i to cusDi_insert_After
//			UpdateLegC2C_Cus(i,nextj,cusDi_insert_After,CAPCus[i],depart[i],0);
//			//Insert cusDi after cusDi_insert_After:
//			int nextC = nextArr[cusDi_insert_After];
//			nextArr[cusDi_insert_After] = cusDi; predArr[cusDi] = cusDi_insert_After;
//			nextArr[cusDi] = nextC;
//			varcost += problem->c[cusDi_insert_After][cusDi];
//			Update_InsertCusC2CIAfterJ(cusDi_insert_After,cusDi,idVeh,idTrip);
//
//			if (nextC > 0) //insert (i and cusDi) in the middle of the trip:
//			{
//				 //From nextC till the end of the trip:
//				 predArr[nextC] = cusDi;
//				 UpdateLegC2C_Cus(cusDi,nextC,lastCOLD,CAPCus[cusDi],depart[cusDi],0);
//				 varcost += (problem->c[cusDi][nextC] - problem->c[cusDi_insert_After][nextC]);
//				 varvioTWC = FvioTWCus[lastCOLD] - seg[idVeh].Trip[idTrip].vioTWC;
//				 varvioCAP = FCAP[lastCOLD] - seg[idVeh].Trip[idTrip].vioCAP;
//				 //varvioCAP = FvioCAPCus[lastCOLD] - seg[idVeh].Trip[idTrip].vioCAP;
//				 seg[idVeh].Trip[idTrip].vioTWC = FvioTWCus[lastCOLD];
//				 seg[idVeh].Trip[idTrip].vioCAP = FCAP[lastCOLD];
//				 //seg[idVeh].Trip[idTrip].vioCAP = FvioCAPCus[lastCOLD];
//				 if (nextSP > 0) //nextT is DTrip
//				 {
//				    if (PDSDIF(seg[idVeh].Trip[idTrip].endS, depart[lastCOLD]) == 0) //endS has changed
//				    {
//				        seg[idVeh].Trip[idTrip].endS = depart[lastCOLD];
//						varcost -= seg[idVeh].Trip[idTrip].connectCost;
//        				UpdateChangeCONNECTAtSP_C2CTrip(idVeh,idTrip,nextT,nextSP,varcost,0,varvioTWC,varvioCAP,update_idTrip);
//						return;
//				    }
//				    else goto UpdateNC; //endS has not changed
//				 }
//				 else //nextT is lastT or PTripORC2C
//				 {
//					 if (idTrip == lastT)
//					 {
//						 seg[idVeh].Trip[idTrip].endS = depart[lastCOLD];
//						 goto UpdateNC;
//					 }
//					 else //nextT is PTrip OR C2C
//					 {
//						if (PDSDIF(seg[idVeh].Trip[idTrip].endS, depart[lastCOLD]) == 0) //endS has changed
//						{
//							seg[idVeh].Trip[idTrip].endS = depart[lastCOLD];
//        					goto UpdateC_nextPTripORC2C;
//						}
//						else goto UpdateNC; //endS has not changed
//					 } //end nextT is PTrip OR C2C
//				 }//end nextT is lasT or PTripORC2C
//			}
//			else //cusDi_insert_After was the last cus --> cusDi is now the last cus
//			{
//				seg[idVeh].Trip[idTrip].lastCus = cusDi;
//				seg[idVeh].Trip[idTrip].endS = depart[cusDi];
//				varcost -= seg[idVeh].Trip[idTrip].connectCost;
//				varvioTWC = FvioTWCus[cusDi] - seg[idVeh].Trip[idTrip].vioTWC;
//				varvioCAP = FCAP[cusDi] - seg[idVeh].Trip[idTrip].vioCAP;
//				//varvioCAP = FvioCAPCus[cusDi] - seg[idVeh].Trip[idTrip].vioCAP;
//				seg[idVeh].Trip[idTrip].vioTWC = FvioTWCus[cusDi];
//				seg[idVeh].Trip[idTrip].vioCAP = FCAP[cusDi];
//				//seg[idVeh].Trip[idTrip].vioCAP = FvioCAPCus[cusDi];
//				if (nextSP > 0)
//				{
//					//varcost -= seg[idVeh].Trip[idTrip].connectCost; //lastC changed
//					UpdateChangeCONNECTAtSP_C2CTrip(idVeh,idTrip,nextT,nextSP,varcost,0,varvioTWC,varvioCAP,update_idTrip);
//					return;
//				}
//				else //is last trip OR (nextTrip is PTrip or c2c)
//				{
//					 if (idTrip == lastT)
//					 {
//						 seg[idVeh].Trip[idTrip].connectCost = problem->c[cusDi][0];
//						 varcost += seg[idVeh].Trip[idTrip].connectCost;
//						 goto UpdateNC;
//					 }
//					 else //nextTrip is PTrip or C2C
//					 {
//						 seg[idVeh].Trip[idTrip].connectCost = problem->c[cusDi][seg[idVeh].Trip[nextT].firstCus];
//						 varcost += seg[idVeh].Trip[idTrip].connectCost;
//						 goto UpdateC_nextPTripORC2C;
//					 }
//				 }
//			}
//		}//end not insert cusDi right after i
//		UpdateC_nextPTripORC2C:
//			varFIT = varcost + VTWCUS * varvioTWC + VCAP * varvioCAP;
//			seg[idVeh].Trip[idTrip].cost += varcost;
//			if (seg[idVeh].Trip[idTrip].vioCAP > 0 || seg[idVeh].Trip[idTrip].vioTWC > eps)
//			{
//				seg[idVeh].Trip[idTrip].feasible = 0;
//				seg[idVeh].Trip[idTrip].fitness += varFIT;
//			}
//			else
//			{
//				seg[idVeh].Trip[idTrip].feasible = 1;
//				seg[idVeh].Trip[idTrip].fitness = seg[idVeh].Trip[idTrip].cost;
//			}
//			UpdateVehicle(idVeh, nextT,seg[idVeh].Trip[idTrip].lastCus,seg[idVeh].Trip[idTrip].endS,varvioCAP,update_idTrip);
//			goto CHECK;
//         
//        UpdateNC:
//			varFIT = varcost + VTWCUS * varvioTWC + VCAP * varvioCAP;
//			seg[idVeh].Trip[idTrip].cost += varcost;
//			if (seg[idVeh].Trip[idTrip].vioCAP > 0 || seg[idVeh].Trip[idTrip].vioTWC > eps)
//			{
//				seg[idVeh].Trip[idTrip].feasible = 0;
//				seg[idVeh].Trip[idTrip].fitness += varFIT;
//			}
//			else
//			{
//				seg[idVeh].Trip[idTrip].feasible = 1;
//				seg[idVeh].Trip[idTrip].fitness = seg[idVeh].Trip[idTrip].cost;
//			}
//			//varC1 = varcost + varcostpreT;varFIT += varcostpreT;
//			seg[idVeh].cost += varcost; seg[idVeh].fitness += varFIT; seg[idVeh].vioTWC += varvioTWC; seg[idVeh].vioCAP += varvioCAP;
//			cost += varcost; fitness += varFIT;vioTWC += varvioTWC;vioCAP += varvioCAP;
//	}
//CHECK:
//	bool stop = checkVehicle(idVeh);
//	if (stop)
//	{
//		cout<<"CASE1: STOP AT insertCusC2CTrip @IT = "<<IT<<endl;
//		exit(-1);
//	}
//}
//
//
//
//void Solution::delete_insertCusC2CTrip(int i, int idTripi, int j, int cusDi_insert_After, int idTripj, int idVeh)
//{
//	//empty idTripi which is before idTripj, (NOT NECCESSARY RIGHT BEFORE), then insert i after j on trip idTripj, then DON TOA and update all remaining trips of idVeh
//   
//    //1. Copy from Update_EmptyTripC2C:
//	int lastTrip = seg[idVeh].numTrips - 1;
//	seg[idVeh].numTrips --;
//	double varvioTWSP, varcost, varFIT;
//
//	int varvioCAP = -seg[idVeh].Trip[idTripi].vioCAP;
//	//seg[idVeh].Trip[idTrip].numCus=0;
//
//	idTripj--;
//	int update_idTrip = idTripj - 1;
//	double cStartSOLD = depart[seg[idVeh].Trip[update_idTrip].lastCus];
//
//	if (idTripj == 0) //first trip becomes empty
//	{
//		//Don toa:
//		for (i=0;i<seg[idVeh].numTrips; i++)
//		{
//			seg[idVeh].Trip[i] = seg[idVeh].Trip[i+1];
//			UpdateTripnum(idVeh,i);
//		}
//		if (seg[idVeh].Trip[0].Type == 1)
//		{
//			//seg[idVeh].Trip[0].coordinate = 0;
//			int assSP = seg[idVeh].Trip[0].assSP;
//			seg[idVeh].Trip[0].leaveSP = problem->leaveSP[assSP][4]; //load only at sTW2
//			varvioTWSP = -seg[idVeh].Trip[0].vioTWSP;
//			seg[idVeh].Trip[0].vioTWSP = 0;
//			varcost = problem->c[0][assSP];
//			seg[idVeh].Trip[0].cost += varcost;
//			varFIT = varcost + VTWSP * varvioTWSP;
//			seg[idVeh].Trip[0].fitness += varFIT;
//			UpdateVehicle(idVeh, 0, assSP, seg[idVeh].Trip[0].leaveSP, varvioCAP, update_idTrip);
//		}
//		else
//		{
//			varcost = problem->c[0][seg[idVeh].Trip[0].firstCus];
//			seg[idVeh].Trip[0].cost += varcost;
//			seg[idVeh].Trip[0].fitness += varcost;
//			//if (seg[idVeh].Trip[0].Type == 2) seg[idVeh].Trip[0].assSP = 0;
//			UpdateVehicle(idVeh, 0, 0, 0, varvioCAP, update_idTrip);
//		}
//	}
//	else //middle/last C2C trip becomes empty
//	{
//		int preT = idTripj - 1;
//		//Don toa:
//		for (i=idTripj;i<seg[idVeh].numTrips; i++)
//		{
//			seg[idVeh].Trip[i] = seg[idVeh].Trip[i+1];
//			UpdateTripnum(idVeh,i);
//		}
//		if (seg[idVeh].Trip[preT].Type == 1)
//		{
//			if (seg[idVeh].Trip[idTripj].Type == 1) //preT is delivery trip, nextTrip is deliverytrip 
//			{
//				//seg[idVeh].Trip[idTrip].coordinate = 0;
//				updateChangeCONNECTAtSP_DDORC2CD(idVeh, idTripj, preT, varvioCAP, update_idTrip); //for Update_EmptyTripD and Update_EmptyTripP: connect deliverytrip(idVeh, preT) with delivery trip (idVeh, nextTrip) where (idVeh, idTrip) is already deleted 
//			}
//			else //preT is delivery trip, nextTrip is (pickup OR C2C)
//			{
//				varcost = -seg[idVeh].Trip[preT].connectCost;
//				seg[idVeh].Trip[preT].connectCost = problem->c[seg[idVeh].Trip[preT].lastCus][seg[idVeh].Trip[idTripj].firstCus];
//			    varcost += seg[idVeh].Trip[preT].connectCost;
//				seg[idVeh].Trip[preT].cost += varcost;
//				seg[idVeh].Trip[preT].fitness += varcost;
//				UpdateVehicle(idVeh, idTripj, seg[idVeh].Trip[preT].lastCus, seg[idVeh].Trip[preT].endS, varvioCAP, update_idTrip);
//			}//end preT is delivery trip, nextTrip is (pickup OR C2C)
//		}
//		else if (seg[idVeh].Trip[preT].Type == 0) //preT is pickup (middle trip becomes empty)
//		{
//			if (seg[idVeh].Trip[idTripj].Type == 1) //preT is pickup trip, nextTrip is delivery (middle trip becomes empty)
//			{
//				if (seg[idVeh].Trip[preT].assSP != seg[idVeh].Trip[idTripj].assSP)
//				{
//				   seg[idVeh].Trip[idTripj].coordinate = 0;
//				   updateChangeCONNECTAtSP_SPSP(idVeh, idTripj, preT, varvioCAP, update_idTrip); //for Update_EmptyTripD and Update_EmptyTripP: connect pickuptrip(idVeh, preT) with delivery trip (idVeh, nextTrip) where (idVeh, idTrip) is already deleted 
//				}
//				else //create new coordinate trip:
//				{
//					seg[idVeh].Trip[idTripj].coordinate = 1;
//                    updateChangeCONNECTAtSP_SameSP(idVeh,idTripj,preT,varvioCAP,update_idTrip);
//				}
//			}
//			else //preT is pickup trip, nextTrip is (pickup OR C2C) (middle trip becomes empty)
//			{
//				varcost = -seg[idVeh].Trip[preT].connectCost;
//				seg[idVeh].Trip[preT].connectCost = problem->c[seg[idVeh].Trip[preT].assSP][seg[idVeh].Trip[idTripj].firstCus];
//			    varcost += seg[idVeh].Trip[preT].connectCost;
//				seg[idVeh].Trip[preT].cost += varcost;
//				seg[idVeh].Trip[preT].fitness += varcost;
//				UpdateVehicle(idVeh, idTripj, seg[idVeh].Trip[preT].assSP, seg[idVeh].Trip[preT].leaveSP, varvioCAP, update_idTrip);
//			}//end preT is pickup trip, nextTrip is pickup (middle trip becomes empty)
//		}//end preT is pickup (middle trip becomes empty)
//		else //preT is C2C
//		{
//			if (seg[idVeh].Trip[idTripj].Type == 1) //preT is C2C trip, nextTrip is deliverytrip 
//			{
//				seg[idVeh].Trip[preT].nextSP = seg[idVeh].Trip[idTripj].assSP;
//				seg[idVeh].Trip[idTripj].coordinate = 0;
//				updateChangeCONNECTAtSP_DDORC2CD(idVeh, idTripj, preT, varvioCAP, update_idTrip); //for Update_EmptyTripD and Update_EmptyTripP: connect deliverytrip(idVeh, preT) with delivery trip (idVeh, nextTrip) where (idVeh, idTrip) is already deleted 
//			}
//			else //if (seg[idVeh].Trip[idTripj].Type == 0 || 2) //preT is C2C trip, nextTrip is pickup OR C2C
//			{
//				//seg[idVeh].Trip[preT].nextSP = -1;
//				varcost = -seg[idVeh].Trip[preT].connectCost;
//				seg[idVeh].Trip[preT].connectCost = problem->c[seg[idVeh].Trip[preT].lastCus][seg[idVeh].Trip[idTripj].firstCus];
//			    varcost += seg[idVeh].Trip[preT].connectCost;
//				seg[idVeh].Trip[preT].cost += varcost;
//				seg[idVeh].Trip[preT].fitness += varcost;
//				UpdateVehicle(idVeh, idTripj, seg[idVeh].Trip[preT].lastCus, seg[idVeh].Trip[preT].endS, varvioCAP, update_idTrip);
//			}
//		}//end preT is C2C (middle trip becomes empty)
//	}//end middle/last pickup trip becomes empty
//
//
//   //2. Insert i after j and cusDi after CusDi_insert_After on idTripj: copy insertCusC2CTrip
//	if (idTripi == idTripj) //idTripj is right after idTripi
//		insertCusC2CTrip_FromBeginning(j, i, cusDi_insert_After, idVeh, idTripj, seg[idVeh].numTrips - 1);
//	else
//	{
//		if (PDSDIF(cStartSOLD, depart[seg[idVeh].Trip[update_idTrip].lastCus]))
//			insertCusC2CTrip_FromBeginning(j,i,cusDi_insert_After,idVeh,idTripj,seg[idVeh].numTrips - 1);
//		else
//			insertCusC2CTrip(j,i,cusDi_insert_After,idVeh,idTripj,seg[idVeh].numTrips - 1);
//	}
//}
//
//void Solution::moveCusC2CTrip_OneTrip(int j, int i, int cusDi_insert_After, int idVeh, int idTrip)
//{
//	//17/12/2013:
//	//i and cusDi, j belong to the same trip (idVeh,idTrip)
//	//now moving customers in this trip: i after j and cusDi after cusDi_insert_After
//	int curC = seg[idVeh].Trip[idTrip].firstCus;
//	int lastC = seg[idVeh].Trip[idTrip].lastCus;
//	int nexti = nextArr[i]; int nextj = nextArr[j];
//	int cusDi = problem->node[i].delID;
//	int next_cusDi = nextArr[cusDi];
//	int nextC, lastCSP_preT,varvioCAP;
//	double cStartS,varcost,varcostpreT,varvioTWC,varFIT,varC1;
//	int nextSP = seg[idVeh].Trip[idTrip].nextSP;
//	int nextT = idTrip + 1; int lastT = seg[idVeh].numTrips - 1;
//	int lastCNEW = -1;
//
//	if (i == curC) //i is the first cus
//	{
//		if (nexti == cusDi) //(1)i and cusDi are 2 first customers:
//		{
//			if (idTrip == 0)
//			{
//				lastCSP_preT = 0;
//				cStartS = 0;
//				varcost = problem->c[0][next_cusDi] - (problem->c[0][i] + problem->c[i][cusDi] + problem->c[cusDi][next_cusDi]);
//				varcostpreT = 0;
//			}
//			else
//			{
//				int preT = idTrip - 1;
//				if (seg[idVeh].Trip[preT].Type == 0)
//				{
//					lastCSP_preT = seg[idVeh].Trip[preT].assSP;
//					cStartS = seg[idVeh].Trip[preT].leaveSP;
//				}
//				else
//				{
//					lastCSP_preT = seg[idVeh].Trip[preT].lastCus;
//					cStartS = depart[lastCSP_preT];
//				}
//				varcostpreT = problem->c[lastCSP_preT][next_cusDi] - seg[idVeh].Trip[preT].connectCost;
//				seg[idVeh].Trip[preT].connectCost = problem->c[lastCSP_preT][next_cusDi];
//				seg[idVeh].Trip[preT].cost += varcostpreT;
//				seg[idVeh].Trip[preT].fitness += varcostpreT;
//
//				varcost = - (problem->c[i][cusDi] + problem->c[cusDi][next_cusDi]);
//			}
//			predArr[next_cusDi] = -1; seg[idVeh].Trip[idTrip].firstCus = next_cusDi;
//			UpdateLegC2C_Cus(lastCSP_preT,next_cusDi,j,0,cStartS,1);
//			//Insert i after j:
//			varcost += problem->c[j][i]; nextArr[j] = i; predArr[i] = j;
//			Update_InsertCusC2CIAfterJ(j,i,idVeh,idTrip);
//			if (cusDi_insert_After == i) //insert cusDi right after i
//			{
//				varcost += problem->c[i][cusDi]; 
//				nextArr[i] = cusDi; predArr[cusDi] = i; nextArr[cusDi] = nextj;
//				Update_InsertCusC2CIAfterJ(i,cusDi,idVeh,idTrip);
//				if (nextj > 0)
//				{
//					predArr[nextj] = cusDi;
//					varcost += (problem->c[cusDi][nextj] - problem->c[j][nextj]);
//					//From nextj till the end of the trip:
//					UpdateLegC2C_Cus(cusDi,nextj,lastC,CAPCus[cusDi],depart[cusDi],0);
//					goto Update_LastC_NC;
//				}
//				else //(i and cusDi) were 2 first cus --> (i, cusDi) are now 2 last cus:
//				{
//					//varcost -= seg[idVeh].Trip[idTrip].connectCost;
//					seg[idVeh].Trip[idTrip].endS = depart[cusDi];
//					seg[idVeh].Trip[idTrip].lastCus = cusDi;
//					varcost -= seg[idVeh].Trip[idTrip].connectCost;
//					lastCNEW = cusDi;
//					goto Update_LastC_C;
//				}//end (i and cusDi) were 2 first cus --> (i, cusDi) are now 2 last cus:
//			}
//			else //not insert cusDi right after i; (i and cusDi) were 2 first cus
//			{
//				varcost += (problem->c[i][nextj] - problem->c[j][nextj]);
//				nextArr[i] = nextj; predArr[nextj] = i;
//				UpdateLegC2C_Cus(i,nextj,cusDi_insert_After,CAPCus[i],depart[i],0);
//				//Insert cusDi after cusDi_insert_After:
//				varcost += problem->c[cusDi_insert_After][cusDi];
//				nextC = nextArr[cusDi_insert_After];
//				nextArr[cusDi_insert_After] = cusDi; predArr[cusDi] = cusDi_insert_After;
//				nextArr[cusDi] = nextC;
//				Update_InsertCusC2CIAfterJ(cusDi_insert_After,cusDi,idVeh,idTrip);
//				if (nextC > 0)
//				{
//					predArr[nextC] = cusDi;
//					varcost += (problem->c[cusDi][nextC] - problem->c[cusDi_insert_After][nextC]);
//
//					//From nextC till the end of the trip:
//					UpdateLegC2C_Cus(cusDi,nextC,lastC,CAPCus[cusDi],depart[cusDi],0);
//					goto Update_LastC_NC;
//				}
//				else //cusDi is now the last cus; not insert cusDi right after i; (i and cusDi) were 2 first cus
//				{
//					seg[idVeh].Trip[idTrip].endS = depart[cusDi];
//					seg[idVeh].Trip[idTrip].lastCus = cusDi;
//					varcost -= seg[idVeh].Trip[idTrip].connectCost;
//					lastCNEW = cusDi;
//					goto Update_LastC_C;
//				}//end //cusDi is now the last cus; not insert cusDi right after i; (i and cusDi) were 2 first cus
//			}//end: not insert cusDi right after i; (i and cusDi) were 2 first cus
//		}
//		else //(2)i is the first, but cusDi is not direct successor of i
//		{
//			if (idTrip == 0)
//			{
//				lastCSP_preT = 0;
//				cStartS = 0;
//				varcost = problem->c[0][nexti] - (problem->c[0][i] + problem->c[i][nexti]);
//				varcostpreT = 0;
//			}
//			else
//			{
//				int preT = idTrip - 1;
//				if (seg[idVeh].Trip[preT].Type == 0)
//				{
//					lastCSP_preT = seg[idVeh].Trip[preT].assSP;
//					cStartS = seg[idVeh].Trip[preT].leaveSP;
//				}
//				else
//				{
//					lastCSP_preT = seg[idVeh].Trip[preT].lastCus;
//					cStartS = depart[lastCSP_preT];
//				}
//				varcostpreT = problem->c[lastCSP_preT][nexti] - seg[idVeh].Trip[preT].connectCost;
//				seg[idVeh].Trip[preT].connectCost = problem->c[lastCSP_preT][nexti];
//				seg[idVeh].Trip[preT].cost += varcostpreT;
//				seg[idVeh].Trip[preT].fitness += varcostpreT;
//
//				varcost = - (problem->c[i][nexti]);
//			}
//			predArr[nexti] = -1; seg[idVeh].Trip[idTrip].firstCus = nexti;
//			int pre_cusDi = predArr[cusDi];
//			int pos_cusDi = pos[cusDi]; int posj = pos[j];
//			if (pos_cusDi < posj)
//			{
//				//From firstC nexti to pre_cusDi
//				UpdateLegC2C_Cus(lastCSP_preT,nexti,pre_cusDi,0,cStartS,1);
//				//Delete cusDi:
//				varcost += (problem->c[pre_cusDi][next_cusDi] - problem->c[pre_cusDi][cusDi] - problem->c[cusDi][next_cusDi]);
//				nextArr[pre_cusDi] = next_cusDi; predArr[next_cusDi] = pre_cusDi;
//				//From next_cusDi to j:
//				UpdateLegC2C_Cus(pre_cusDi,next_cusDi,j,CAPCus[pre_cusDi],depart[pre_cusDi],0);
//				//Insert i after j:
//				varcost += problem->c[j][i]; nextArr[j] = i; predArr[i] = j;
//				Update_InsertCusC2CIAfterJ(j,i,idVeh,idTrip);
//				if (cusDi_insert_After == i) //insert cusDi right after i
//				{
//					varcost += problem->c[i][cusDi]; 
//					nextArr[i] = cusDi; predArr[cusDi] = i; nextArr[cusDi] = nextj;
//					Update_InsertCusC2CIAfterJ(i,cusDi,idVeh,idTrip);
//					if (nextj > 0)
//					{
//						predArr[nextj] = cusDi;
//						varcost += (problem->c[cusDi][nextj] - problem->c[j][nextj]);
//						//From nextj till the end of the trip:
//						UpdateLegC2C_Cus(cusDi,nextj,lastC,CAPCus[cusDi],depart[cusDi],0);
//						goto Update_LastC_NC;
//					}
//					else //i is first cus --> (i, cusDi) are now 2 last cus:
//					{
//						seg[idVeh].Trip[idTrip].endS = depart[cusDi];
//						seg[idVeh].Trip[idTrip].lastCus = cusDi;
//						varcost -= seg[idVeh].Trip[idTrip].connectCost;
//						lastCNEW = cusDi;
//						goto Update_LastC_C;
//					}//end i was first cus --> (i, cusDi) are now 2 last cus:
//				}
//				else //not insert cusDi right after i; i was first cus
//				{
//					varcost += (problem->c[i][nextj] - problem->c[j][nextj]);
//					nextArr[i] = nextj; predArr[nextj] = i;
//					UpdateLegC2C_Cus(i,nextj,cusDi_insert_After,CAPCus[i],depart[i],0);
//					//Insert cusDi after cusDi_insert_After:
//					varcost += problem->c[cusDi_insert_After][cusDi];
//					nextC = nextArr[cusDi_insert_After];
//					nextArr[cusDi_insert_After] = cusDi; predArr[cusDi] = cusDi_insert_After;
//					nextArr[cusDi] = nextC;
//					Update_InsertCusC2CIAfterJ(cusDi_insert_After,cusDi,idVeh,idTrip);
//					if (nextC > 0)
//					{
//						predArr[nextC] = cusDi;
//						varcost += (problem->c[cusDi][nextC] - problem->c[cusDi_insert_After][nextC]);
//
//						//From nextC till the end of the trip:
//						UpdateLegC2C_Cus(cusDi,nextC,lastC,CAPCus[cusDi],depart[cusDi],0);
//						goto Update_LastC_NC;
//					}
//					else //cusDi is now the last cus; not insert cusDi right after i; i was first cus
//					{
//						seg[idVeh].Trip[idTrip].endS = depart[cusDi];
//						seg[idVeh].Trip[idTrip].lastCus = cusDi;
//						varcost -= seg[idVeh].Trip[idTrip].connectCost;
//						lastCNEW = cusDi;
//						goto Update_LastC_C;
//					}//end //cusDi is now the last cus; not insert cusDi right after i; i was first cus
//				}//end: not insert cusDi right after i; i was first cus
//			}
//			else //pos_cusDi > pos_j: i is the first; cusDi is not direct successor of i
//			{
//				if (pos_cusDi == posj)
//				{
//					cout<<"ERROR moveCusC2CTrip_OneTrip: cusDi = "<<cusDi<<"; pos = "<<pos_cusDi<<"; j = "<<j<<"; pos = "<<posj<<endl;
//					exit(-1);
//				}
//				//From nexti to j (note cusDi > j)
//				UpdateLegC2C_Cus(lastCSP_preT,nexti,j,0,cStartS,1);
//				//Insert i after j:
//				varcost += problem->c[j][i]; nextArr[j] = i; predArr[i] = j;
//				Update_InsertCusC2CIAfterJ(j,i,idVeh,idTrip);
//				if (nextj == cusDi)
//				{
//					if (cusDi_insert_After == i) //insert cusDi right after i;
//					{
//						nextArr[i] = cusDi; predArr[cusDi] = i; 
//						varcost += (problem->c[i][cusDi] - problem->c[j][cusDi]);
//						Update_InsertCusC2CIAfterJ(i,cusDi,idVeh,idTrip);
//						//from now on dont have i and cusDi: update till the end of the trip
//						if (next_cusDi > 0) UpdateLegC2C_Cus(cusDi,next_cusDi,lastC,CAPCus[cusDi],depart[cusDi],0);
//						goto Update_LastC_NC;
//					}
//					else
//					{
//						//delete cusDi:
//						varcost += (problem->c[i][next_cusDi]  - problem->c[j][cusDi] - problem->c[cusDi][next_cusDi]);
//						nextArr[i] = next_cusDi; predArr[next_cusDi] = i; //for sure next_cusDi > 0
//						UpdateLegC2C_Cus(i,next_cusDi,cusDi_insert_After,CAPCus[i],depart[i],0);
//						//Insert cusDi after cusDi_insert_After:
//						varcost += (problem->c[cusDi_insert_After][cusDi]);
//						nextC = nextArr[cusDi_insert_After];
//						nextArr[cusDi_insert_After] = cusDi; predArr[cusDi] = cusDi_insert_After;
//						Update_InsertCusC2CIAfterJ(cusDi_insert_After,cusDi,idVeh,idTrip);
//						//Update till the end of the trip:
//						if (nextC > 0)
//						{
//							predArr[nextC] = cusDi;
//							varcost += (problem->c[cusDi][nextC] - problem->c[cusDi_insert_After][nextC]);
//							//From nextC till the end of the trip:
//							UpdateLegC2C_Cus(cusDi,nextC,lastC,CAPCus[cusDi],depart[cusDi],0);
//							goto Update_LastC_NC;
//						}
//						else //cusDi is now the last cus:
//						{
//							seg[idVeh].Trip[idTrip].endS = depart[cusDi];
//							seg[idVeh].Trip[idTrip].lastCus = cusDi;
//							varcost -= seg[idVeh].Trip[idTrip].connectCost;
//							lastCNEW = cusDi;
//							goto Update_LastC_C;
//						}//end cusDi is now the last cus
//					}
//				}
//				else //nextj != cusDi; cusDi > j
//				{
//					if (cusDi_insert_After == i) //insert cusDi right after i; cusDi > j
//					{
//						varcost += (problem->c[i][cusDi] + problem->c[cusDi][nextj] - problem->c[j][nextj]); 
//						nextArr[i] = cusDi; predArr[cusDi] = i; nextArr[cusDi] = nextj; predArr[nextj] = cusDi;
//						Update_InsertCusC2CIAfterJ(i,cusDi,idVeh,idTrip);
//						//for sure nextj > 0: update nextj...pre_cusDi
//						UpdateLegC2C_Cus(cusDi,nextj,pre_cusDi,CAPCus[cusDi],depart[cusDi],0);
//						//Delete cusDi:
//						nextArr[pre_cusDi] = next_cusDi; 
//						if (next_cusDi > 0)
//						{
//						   predArr[next_cusDi] = pre_cusDi;
//						   varcost += (problem->c[pre_cusDi][next_cusDi] - problem->c[pre_cusDi][cusDi] - problem->c[cusDi][next_cusDi]);
//						   //update from next_cusDi till the end
//						   UpdateLegC2C_Cus(pre_cusDi,next_cusDi,lastC,CAPCus[pre_cusDi],depart[pre_cusDi],0);
//						   goto Update_LastC_NC;
//						}
//						else //pre_cusDi is now the last cus:
//						{
//							varcost -= problem->c[pre_cusDi][cusDi];
//							seg[idVeh].Trip[idTrip].endS = depart[pre_cusDi];
//							seg[idVeh].Trip[idTrip].lastCus = pre_cusDi;
//							varcost -= seg[idVeh].Trip[idTrip].connectCost;
//							lastCNEW = pre_cusDi;
//							goto Update_LastC_C;
//						}
//					}
//					else //not insert cusDi right after i; pos_cusDi > posj (i was the first); nextj != cusDi
//					{
//						varcost += (problem->c[i][nextj] - problem->c[j][nextj]);
//						nextArr[i] = nextj; predArr[nextj] = i;
//					
//						int pos_cusDi_insert_After = pos[cusDi_insert_After];
//						if (pos_cusDi_insert_After > pos_cusDi)
//						{
//						   UpdateLegC2C_Cus(i,nextj,pre_cusDi,CAPCus[i],depart[i],0);
//						   //delete cusDi:
//						   nextArr[pre_cusDi] = next_cusDi; predArr[next_cusDi] = pre_cusDi;
//						   varcost += (problem->c[pre_cusDi][next_cusDi] - problem->c[pre_cusDi][cusDi] - problem->c[cusDi][next_cusDi]);
//						   UpdateLegC2C_Cus(pre_cusDi,next_cusDi,cusDi_insert_After,CAPCus[pre_cusDi],depart[pre_cusDi],0);
//						   //Insert cusDi after cusDi_insert_After:
//						   varcost += problem->c[cusDi_insert_After][cusDi];
//						   nextC = nextArr[cusDi_insert_After];
//						   nextArr[cusDi_insert_After] = cusDi; predArr[cusDi] = cusDi_insert_After; nextArr[cusDi] = nextC;
//						   Update_InsertCusC2CIAfterJ(cusDi_insert_After,cusDi,idVeh,idTrip);
//						   if (nextC > 0) //from now on don't exist cusDi
//						   {
//							   predArr[nextC] = cusDi;
//							   varcost += (problem->c[cusDi][nextC] - problem->c[cusDi_insert_After][nextC]);
//							   //Update till the end of the trip:
//							   UpdateLegC2C_Cus(cusDi,nextC,lastC,CAPCus[cusDi],depart[cusDi],0);
//							   goto Update_LastC_NC;
//						   }
//						   else //cusDi is now the last cus:
//						   {
//								seg[idVeh].Trip[idTrip].endS = depart[cusDi];
//								seg[idVeh].Trip[idTrip].lastCus = cusDi;
//								varcost -= seg[idVeh].Trip[idTrip].connectCost;
//								lastCNEW = cusDi;
//								goto Update_LastC_C;
//						   }//end cusDi is now the last cus
//						}
//						else //pos_cusDi_insert_After <= pos_cusDi)
//						{
//							if (pos_cusDi_insert_After == pos_cusDi)
//							{
//								cout<<"ERROR moveCusC2CTrip_OneTrip: j = "<<j<<"; i = "<<i<<"; cusDi = "<<cusDi<<"==??== cusDi_insert_After = "<<cusDi_insert_After<<endl;
//								exit(-1);
//							}
//						    nextC = nextArr[cusDi_insert_After];
//							if (nextC == cusDi) //cusDi is already after cusDi_insert_After
//							{
//								UpdateLegC2C_Cus(i,nextj,lastC,CAPCus[i],depart[i],0);
//								goto Update_LastC_NC;
//							}
//							else //cusDi is NOT already after cusDi_insert_After
//							{
//							    UpdateLegC2C_Cus(i,nextj,cusDi_insert_After,CAPCus[i],depart[i],0);
//							    //Insert cusDi after cusDi_insert_After:
//								varcost += (problem->c[cusDi_insert_After][cusDi] + problem->c[cusDi][nextC] - problem->c[cusDi_insert_After][nextC]);
//								nextArr[cusDi_insert_After] = cusDi; predArr[cusDi] = cusDi_insert_After; 
//								nextArr[cusDi] = nextC; predArr[nextC] = cusDi; //for sure nextC > 0
//								Update_InsertCusC2CIAfterJ(cusDi_insert_After,cusDi,idVeh,idTrip);
//								UpdateLegC2C_Cus(cusDi,nextC,pre_cusDi,CAPCus[cusDi],depart[cusDi],0);
//								//Delete cusDi:
//								nextArr[pre_cusDi] = next_cusDi; 
//								varcost -= problem->c[pre_cusDi][cusDi];
//								if (next_cusDi > 0)
//								{
//									predArr[next_cusDi] = pre_cusDi;
//									varcost += (problem->c[pre_cusDi][next_cusDi] - problem->c[cusDi][next_cusDi]);
//									UpdateLegC2C_Cus(pre_cusDi,next_cusDi,lastC,CAPCus[pre_cusDi],depart[pre_cusDi],0);
//									goto Update_LastC_NC;
//								}
//								else //pre_cusDi is now the last cus
//								{
//									seg[idVeh].Trip[idTrip].endS = depart[pre_cusDi];
//									seg[idVeh].Trip[idTrip].lastCus = pre_cusDi;
//									varcost -= seg[idVeh].Trip[idTrip].connectCost;
//									lastCNEW = pre_cusDi;
//									goto Update_LastC_C;
//								}//end pre_cusDi is now the last cus
//							}//end cusDi is NOT already after cusDi_insert_After
//					    }//end pos_cusDi_insert_After <= pos_cusDi
//					}//end not insert cusDi right after i; pos_cusDi > posj (i was the first); nextj != cusDi
//				}//end nextj != cusDi; pos_cusDi > posj
//			}//end cusDi > j: i is the first; cusDi is not direct successor of i
//		}//end i is the first, but cusDi is not direct successor of i
//	}
//	else //i is not the first cus
//	{
//		varcostpreT = 0; varcost = 0;
//		int posi = pos[i];
//		int posj = pos[j];
//		int prei = predArr[i];
//		int pre_cusDi = predArr[cusDi];
//		int pos_cusDi_insert_After = pos[cusDi_insert_After];
//		int next_cusDi_insert_After = nextArr[cusDi_insert_After];
//		int pos_cusDi = pos[cusDi];
//		if (posi < posj) //i is not the first cus
//		{
//			if (pos_cusDi < posj)
//			{
//				if (nexti == cusDi) //prei - i - cusDi = nexti...j
//				{
//					nextC = nextArr[cusDi];
//					//Delete i and cusDi                 
//					varcost += (problem->c[prei][nextC] - problem->c[prei][i] - problem->c[i][cusDi] - problem->c[cusDi][nextC]);
//					nextArr[prei] = nextC; predArr[nextC] = prei;
//					UpdateLegC2C_Cus(prei,nextC,j,CAPCus[prei],depart[prei],0);
//				}
//				else //cusDi was not direct successor of i: posi < pos_cusDi<posj
//				{
//					//delete i:
//					varcost += (problem->c[prei][nexti] - problem->c[prei][i] - problem->c[i][nexti]);
//					nextArr[prei] = nexti; predArr[nexti] = prei;
//					UpdateLegC2C_Cus(prei,nexti,pre_cusDi,CAPCus[prei],depart[prei],0);
//					//delete cusDi:
//					varcost += (problem->c[pre_cusDi][next_cusDi] - problem->c[pre_cusDi][cusDi] - problem->c[cusDi][next_cusDi]);
//					nextArr[pre_cusDi] = next_cusDi; predArr[next_cusDi] = pre_cusDi;
//					UpdateLegC2C_Cus(pre_cusDi,next_cusDi,j,CAPCus[pre_cusDi],depart[pre_cusDi],0);
//				}//end cusDi was not direct successor of i
//				//Insert i after j:
//				nextArr[j] = i; predArr[i] = j;
//				Update_InsertCusC2CIAfterJ(j,i,idVeh,idTrip);
//				if (cusDi_insert_After == i) //insert cusDi right after i
//				{
//					nextArr[i] = cusDi; predArr[cusDi] = i;
//					nextArr[cusDi] = nextj; predArr[nextj] = cusDi;
//					Update_InsertCusC2CIAfterJ(i,cusDi,idVeh,idTrip);
//					//Update from nextj till the end of the trip:
//					if (nextj > 0)
//					{
//						 varcost += (problem->c[j][i] + problem->c[i][cusDi] + problem->c[cusDi][nextj] - problem->c[j][nextj]);
//					     UpdateLegC2C_Cus(cusDi,nextj,lastC,CAPCus[cusDi],depart[cusDi],0);
//					     goto Update_LastC_NC;
//					}
//					else //j was the last cus; cusDi is now the last cus:
//					{
//						varcost += (problem->c[j][i] + problem->c[i][cusDi] - seg[idVeh].Trip[idTrip].connectCost);
//						seg[idVeh].Trip[idTrip].lastCus = cusDi;
//						seg[idVeh].Trip[idTrip].endS = depart[cusDi];
//						lastCNEW = cusDi;
//						goto Update_LastC_C;
//					}
//				}
//				else //not insert cusDi right after i
//				{
//					varcost += (problem->c[j][i] + problem->c[i][nextj] - problem->c[j][nextj]);
//					nextArr[i] = nextj; predArr[nextj] = i;
//					UpdateLegC2C_Cus(i,nextj,cusDi_insert_After,CAPCus[i],depart[i],0);
//					
//					//insert cusDi after cusDi_insert_After:
//					nextArr[cusDi_insert_After] = cusDi; predArr[cusDi] = cusDi_insert_After;
//					Update_InsertCusC2CIAfterJ(cusDi_insert_After,cusDi,idVeh,idTrip);
//					nextArr[cusDi] = next_cusDi_insert_After;
//					if (next_cusDi_insert_After > 0)
//					{
//						varcost += (problem->c[cusDi_insert_After][cusDi] + problem->c[cusDi][next_cusDi_insert_After] - problem->c[cusDi_insert_After][next_cusDi_insert_After]);
//						predArr[next_cusDi_insert_After] = cusDi;
//						UpdateLegC2C_Cus(cusDi,next_cusDi_insert_After,lastC,CAPCus[cusDi],depart[cusDi],0);
//						goto Update_LastC_NC;
//					}
//					else //cusDi is now the last cus:
//					{
//						varcost += (problem->c[cusDi_insert_After][cusDi] - seg[idVeh].Trip[idTrip].connectCost);
//						seg[idVeh].Trip[idTrip].lastCus = cusDi;
//						seg[idVeh].Trip[idTrip].endS = depart[cusDi];
//						lastCNEW = cusDi;
//						goto Update_LastC_C;
//					}
//				}//end not insert cusDi right after i
//			}
//			else if (pos_cusDi < pos_cusDi_insert_After) // i .... j ... cusDi .... cusDi_insert_After
//			{
//				//delete i:
//				varcost += (problem->c[prei][nexti] - problem->c[prei][i] - problem->c[i][nexti]);
//				nextArr[prei] = nexti; predArr[nexti] = prei;
//				UpdateLegC2C_Cus(prei,nexti,j,CAPCus[prei],depart[prei],0);
//				//insert i after j:
//				Update_InsertCusC2CIAfterJ(j,i,idVeh,idTrip);
//				nextArr[j] = i; predArr[i] = j;
//				if (cusDi_insert_After == i) //insert cusDi right after i: this case can't happen because pos_cusDi < pos_cusDi_insert_After
//				{
//					cout<<"ERROR moveCusC2CTrip_OneTrip: cusDi_insert_After = "<<cusDi_insert_After<<" ==??== i = "<<i<<"; cusDi = "<<cusDi<<endl;
//					cout<<"but pos_cusDi (= "<<pos_cusDi<<") < pos_cusDi_insert_After (= "<<pos_cusDi_insert_After<<")"<<endl;
//					exit(-1);
//				}
//				else //NOT insert cusDi right after i: trip before move: i .... j ... cusDi .... cusDi_insert_After
//				{
//					nextArr[i] = nextj; predArr[nextj] = i;
//					varcost += (problem->c[j][i] + problem->c[i][nextj] - problem->c[j][nextj]);
//					UpdateLegC2C_Cus(i,nextj,pre_cusDi,CAPCus[i],depart[i],0);
//					//delete cusDi:
//					nextArr[pre_cusDi] = next_cusDi; predArr[next_cusDi] = pre_cusDi;
//					varcost += (problem->c[pre_cusDi][next_cusDi] - problem->c[pre_cusDi][cusDi] - problem->c[cusDi][next_cusDi]);
//					UpdateLegC2C_Cus(pre_cusDi,next_cusDi,cusDi_insert_After,CAPCus[pre_cusDi],depart[pre_cusDi],0);
//					//insert cusDi after cusDi_insert_After:
//					Update_InsertCusC2CIAfterJ(cusDi_insert_After,cusDi,idVeh,idTrip);
//					nextArr[cusDi_insert_After] = cusDi; predArr[cusDi] = cusDi_insert_After;
//					nextArr[cusDi] = next_cusDi_insert_After;
//					if (next_cusDi_insert_After > 0)
//					{
//						varcost += (problem->c[cusDi_insert_After][cusDi] + problem->c[cusDi][next_cusDi_insert_After] - problem->c[cusDi_insert_After][next_cusDi_insert_After]);
//						predArr[next_cusDi_insert_After] = cusDi;
//						UpdateLegC2C_Cus(cusDi,next_cusDi_insert_After,lastC,CAPCus[cusDi],depart[cusDi],0);
//						goto Update_LastC_NC;
//					}
//					else //insert cusDi as the last cus
//					{
//						varcost += (problem->c[cusDi_insert_After][cusDi] - seg[idVeh].Trip[idTrip].connectCost);
//						seg[idVeh].Trip[idTrip].lastCus = cusDi;
//						seg[idVeh].Trip[idTrip].endS = depart[cusDi];
//						lastCNEW = cusDi;
//						goto Update_LastC_C;
//					}
//				}//END NOT insert cusDi right after i: trip before move: i .... j ... cusDi .... cusDi_insert_After
//			}
//			else //pos_cusDi >= pos_cusDi_insert_After > posj: trip before move: i...j...cusDi_insert_After...cusDi...
//			{
//				if (pos_cusDi == pos_cusDi_insert_After)
//				{
//					cout<<"ERROR moveCusC2CTrip_OneTrip: j = "<<j<<"; i = "<<i<<"; cusDi = "<<cusDi<<"; pos_cusDi = "<<pos_cusDi<<"; cusDi_insert_After = "<<cusDi_insert_After<<"; pos[cusDi_insert_After] = "<<pos_cusDi_insert_After<<endl;
//					cout<<"but pos_cusDi (= "<<pos_cusDi<<") ==??=="<<pos_cusDi_insert_After<<" > posj=("<<posj<<")"<<endl;
//					exit(-1);
//				}
//				//delete i:
//				varcost += (problem->c[prei][nexti] - problem->c[prei][i] - problem->c[i][nexti]);
//				nextArr[prei] = nexti; predArr[nexti] = prei;
//				UpdateLegC2C_Cus(prei,nexti,j,CAPCus[prei],depart[prei],0);
//				//insert i after j:
//				Update_InsertCusC2CIAfterJ(j,i,idVeh,idTrip);
//				nextArr[j] = i; predArr[i] = j;
//				if (cusDi_insert_After == i) //insert cusDi right after i (cusDi_insert_After==i): trip before move: i...j...cusDi...
//				{
//					//this case can't happen because pos_cusDi > pos_cusDi_insert_After > posj
//					int next_cusDi = nextArr[cusDi];
//					nextArr[i] = cusDi; predArr[cusDi] = i;
//					if (nextj == cusDi)
//					{
//						varcost += (problem->c[j][i] + problem->c[i][cusDi] - problem->c[j][cusDi]);
//						Update_InsertCusC2CIAfterJ(i,cusDi,idVeh,idTrip);
//						if (next_cusDi > 0)
//							UpdateLegC2C_Cus(cusDi,next_cusDi,lastC,CAPCus[cusDi],depart[cusDi],0);
//						else //cusDi is still the last cus
//							seg[idVeh].Trip[idTrip].endS = depart[cusDi];
//						goto Update_LastC_NC;
//					}
//					else
//					{
//						varcost += (problem->c[j][i] + problem->c[i][cusDi] + problem->c[cusDi][nextj] - problem->c[j][nextj]);
//						nextArr[cusDi] = nextj; predArr[nextj] = cusDi;
//						Update_InsertCusC2CIAfterJ(i,cusDi,idVeh,idTrip);
//						//Update from nextj till pre_cusDi:
//						UpdateLegC2C_Cus(cusDi,nextj,pre_cusDi,CAPCus[cusDi],depart[cusDi],0);
//						nextArr[pre_cusDi] = next_cusDi;
//						if (next_cusDi > 0)
//						{
//							varcost += (problem->c[pre_cusDi][next_cusDi] - problem->c[pre_cusDi][cusDi] - problem->c[cusDi][next_cusDi]);
//							predArr[next_cusDi] = pre_cusDi;
//							UpdateLegC2C_Cus(pre_cusDi,next_cusDi,lastC,CAPCus[pre_cusDi],depart[pre_cusDi],0);
//							goto Update_LastC_NC;
//						}
//						else //pre_cusDi is now the last cus
//						{
//							varcost -= (problem->c[pre_cusDi][cusDi] + seg[idVeh].Trip[idTrip].connectCost);
//							seg[idVeh].Trip[idTrip].lastCus = pre_cusDi;
//							seg[idVeh].Trip[idTrip].endS = depart[pre_cusDi];
//							lastCNEW = pre_cusDi;
//							goto Update_LastC_C;
//						}
//					}
//
//				}
//				else //not insert cusDi right after i: trip before move: i...j...cusDi_insert_After...cusDi...
//				{
//					nextArr[i] = nextj; predArr[nextj] = i;
//					varcost += (problem->c[j][i] + problem->c[i][nextj] - problem->c[j][nextj]);
//					if (pre_cusDi == cusDi_insert_After) //cusDi was already after cusDi_insert_After:
//					{
//						UpdateLegC2C_Cus(i,nextj,lastC,CAPCus[i],depart[i],0);
//						goto Update_LastC_NC;
//					}
//					else
//					{
//						UpdateLegC2C_Cus(i,nextj,cusDi_insert_After,CAPCus[i],depart[i],0);
//						//insert cusDi after cusDi_insert_After: fore sure next_cusDi_insert_After > 0 & != cusDi
//						varcost += (problem->c[cusDi_insert_After][cusDi] + problem->c[cusDi][next_cusDi_insert_After] - problem->c[cusDi_insert_After][next_cusDi_insert_After]);
//						nextArr[cusDi_insert_After] = cusDi; predArr[cusDi] = cusDi_insert_After;
//						nextArr[cusDi] = next_cusDi_insert_After; predArr[next_cusDi_insert_After] = cusDi;
//						Update_InsertCusC2CIAfterJ(cusDi_insert_After,cusDi,idVeh,idTrip);
//                        UpdateLegC2C_Cus(cusDi,next_cusDi_insert_After, pre_cusDi,CAPCus[cusDi],depart[cusDi],0);
//						//delete cusDi between preCusDi and nextcusDi:
//						nextArr[pre_cusDi] = next_cusDi; 
//					    if (next_cusDi > 0)
//						{
//							predArr[next_cusDi] = pre_cusDi;
//							varcost += (problem->c[pre_cusDi][next_cusDi] - problem->c[pre_cusDi][cusDi] - problem->c[cusDi][next_cusDi]);
//						    UpdateLegC2C_Cus(pre_cusDi,next_cusDi,lastC,CAPCus[pre_cusDi],depart[pre_cusDi],0);
//							goto Update_LastC_NC;
//						}
//						else //pre_cusDi is now the last cus:
//						{
//							varcost -= (problem->c[pre_cusDi][cusDi] + seg[idVeh].Trip[idTrip].connectCost);
//							seg[idVeh].Trip[idTrip].lastCus = pre_cusDi;
//							seg[idVeh].Trip[idTrip].endS = depart[pre_cusDi];
//							lastCNEW = pre_cusDi;
//							goto Update_LastC_C;
//						}
//					}
//				}//end not insert cusDi right after i: trip before move: i...j...cusDi_insert_After...cusDi...
//			}//end //pos_cusDi >= pos_cusDi_insert_After: trip before move: i...j...cusDi_insert_After...cusDi...
//		}
//		else //posi > posj
//		{
//			//insert i after j: fore sure nextj != i
//			nextArr[j] = i; predArr[i] = j;
//			varcost += (problem->c[j][i]  - problem->c[j][nextj]);
//			Update_InsertCusC2CIAfterJ(j,i,idVeh,idTrip);
//			if (cusDi_insert_After == i) //insert cusDi right after i
//			{
//				nextArr[i] = cusDi; predArr[cusDi] = i; nextArr[cusDi] = nextj; predArr[nextj] = cusDi;
//				varcost += (problem->c[i][cusDi] + problem->c[cusDi][nextj]);
//				Update_InsertCusC2CIAfterJ(i,cusDi,idVeh,idTrip);
//				UpdateLegC2C_Cus(cusDi,nextj,prei,CAPCus[cusDi],depart[cusDi],0);
//				if (nexti == cusDi) //cusDi was direct successor of i:
//				{
//					//delete i and cusDi:
//					nextArr[prei] = next_cusDi;
//					if (next_cusDi > 0)
//					{
//					    predArr[next_cusDi] = prei;
//						varcost += (problem->c[prei][next_cusDi] - (problem->c[prei][i] + problem->c[i][cusDi] + problem->c[cusDi][next_cusDi]));
//					    //Update from next_cusDi till the end of the trip:
//						UpdateLegC2C_Cus(prei,next_cusDi,lastC,CAPCus[prei],depart[prei],0);
//						goto Update_LastC_NC;
//					}
//					else //(i and cusDi) was last cus:
//					{
//					    varcost -= (problem->c[prei][i] + problem->c[i][cusDi] + seg[idVeh].Trip[idTrip].connectCost);
//					    //nextArr[prei] = -1; 
//					    seg[idVeh].Trip[idTrip].lastCus = prei;
//					    seg[idVeh].Trip[idTrip].endS = depart[prei];
//						lastCNEW = prei;
//						goto Update_LastC_C;
//					}//end (i and cusDi) was last cus; posi > posj
//				}
//				else //if (nexti != cusDi) //cusDi was NOT direct successor of i:
//				{
//					//delete i:
//					nextArr[prei] = nexti; predArr[nexti] = prei;
//					varcost += (problem->c[prei][nexti] - problem->c[prei][i] - problem->c[i][nexti]);
//					UpdateLegC2C_Cus(prei,nexti,pre_cusDi,CAPCus[prei],depart[prei],0);
//					//delete cusDi:
//					nextArr[pre_cusDi] = next_cusDi;
//					if (next_cusDi > 0)
//					{
//						varcost += (problem->c[pre_cusDi][next_cusDi] - (problem->c[pre_cusDi][cusDi] + problem->c[cusDi][next_cusDi]));
//                        predArr[next_cusDi] = pre_cusDi;
//						UpdateLegC2C_Cus(pre_cusDi,next_cusDi,lastC,CAPCus[pre_cusDi],depart[pre_cusDi],0);
//						goto Update_LastC_NC;
//					}
//					else //pre_cusDi is now the last cus:
//					{
//						varcost -= (problem->c[pre_cusDi][cusDi] + seg[idVeh].Trip[idTrip].connectCost);
//						seg[idVeh].Trip[idTrip].endS = depart[pre_cusDi];
//						seg[idVeh].Trip[idTrip].lastCus = pre_cusDi;
//						lastCNEW = pre_cusDi;
//						goto Update_LastC_C;
//					}
//				}//end if (nexti != cusDi) //cusDi was NOT direct successor of i
//			}
//			else //not insert cusDi right after i; posi > posj
//			{
//				varcost += problem->c[i][nextj];
//				nextArr[i] = nextj; predArr[nextj] = i;
//				if (pos_cusDi_insert_After < posi)
//				{
//					UpdateLegC2C_Cus(i,nextj,cusDi_insert_After,CAPCus[i],depart[i],0);
//					//insert cusDi:
//					nextC = next_cusDi_insert_After; // >= posi
//					nextArr[cusDi_insert_After] = cusDi; predArr[cusDi] = cusDi_insert_After;
//					Update_InsertCusC2CIAfterJ(cusDi_insert_After,cusDi,idVeh,idTrip);					
//					if (nextC != i)
//					{
//						varcost += (problem->c[cusDi_insert_After][cusDi] + problem->c[cusDi][nextC] - problem->c[cusDi_insert_After][nextC]);
//					    nextArr[cusDi] = nextC; predArr[nextC] = cusDi;
//						UpdateLegC2C_Cus(cusDi,nextC,prei,CAPCus[cusDi],depart[cusDi],0);
//						//Delete i:
//						if (nexti == cusDi) //cusDi was the direct successor of i
//						{
//							nextArr[prei] = next_cusDi;
//							if (next_cusDi > 0)
//							{
//								varcost += (problem->c[prei][next_cusDi] - problem->c[prei][i] - problem->c[i][cusDi] - problem->c[cusDi][next_cusDi]);
//                                predArr[next_cusDi] = prei;
//								UpdateLegC2C_Cus(prei,next_cusDi,lastC,CAPCus[prei],depart[prei],0);
//								goto Update_LastC_NC;
//							}
//							else //(i and cusDi) were the last cus --> prei is now the last cus
//							{
//								//delete i and cusDi
//								varcost -= (problem->c[prei][i] + problem->c[i][cusDi] + seg[idVeh].Trip[idTrip].connectCost);
//								seg[idVeh].Trip[idTrip].lastCus = prei;
//								seg[idVeh].Trip[idTrip].endS = depart[prei];
//								lastCNEW = prei; 
//								goto Update_LastC_C;
//							}//end (i and cusDi) were the last cus --> prei is now the last cus
//						}
//						else //nexti != cusDi
//						{
//							//Delete i:
//							varcost += (problem->c[prei][nexti] - problem->c[prei][i] - problem->c[i][nexti]);
//							nextArr[prei] = nexti;predArr[nexti] = prei;
//							UpdateLegC2C_Cus(prei,nexti,pre_cusDi,CAPCus[prei],depart[prei],0);
//							nextArr[pre_cusDi] = next_cusDi;
//							if (next_cusDi > 0)
//							{
//								//Delete cusDi:
//								varcost += (problem->c[pre_cusDi][next_cusDi] - problem->c[pre_cusDi][cusDi] - problem->c[cusDi][next_cusDi]);
//								predArr[next_cusDi] = pre_cusDi;
//								UpdateLegC2C_Cus(pre_cusDi,next_cusDi,lastC,CAPCus[pre_cusDi],depart[pre_cusDi],0);
//								goto Update_LastC_NC;
//							}
//							else //pre_cusDi is now the last cus
//							{
//								//Delete cusDi:
//								varcost -= (problem->c[pre_cusDi][cusDi] + seg[idVeh].Trip[idTrip].connectCost);
//								seg[idVeh].Trip[idTrip].endS = depart[pre_cusDi];
//								seg[idVeh].Trip[idTrip].lastCus = pre_cusDi;
//								lastCNEW = pre_cusDi;
//								goto Update_LastC_C;
//							}//end pre_cusDi is now the last cus
//						}//end nexti != cusDi
//					}
//					else //next[cusDi_insert_After] == i
//					{
//						if (nexti == cusDi) //was: cusDi_insert_After i cusDi
//						{
//							if (next_cusDi > 0)
//							{
//							   varcost += (problem->c[cusDi_insert_After][cusDi] + problem->c[cusDi_insert_After][i] - problem->c[i][cusDi]);
//							   UpdateLegC2C_Cus(cusDi,next_cusDi,lastC,CAPCus[cusDi],depart[cusDi],0);
//							   goto Update_LastC_NC;
//							}
//							else //(i and cusDi) were the last cus --> cusDi is now the last cus
//							{
//								varcost += (problem->c[cusDi_insert_After][cusDi] - problem->c[cusDi_insert_After][i] - problem->c[i][cusDi]);
//								goto Update_LastC_NC;
//							}
//						}
//						else //if (nexti != cusDi)
//						{
//							nextArr[cusDi] = nexti; predArr[nexti] = cusDi;
//							varcost += (problem->c[cusDi_insert_After][cusDi] + problem->c[cusDi][nexti] - problem->c[cusDi_insert_After][i] - problem->c[i][nexti]);
//							UpdateLegC2C_Cus(cusDi,nexti,pre_cusDi,CAPCus[cusDi],depart[cusDi],0);
//							//delete cusDi:
//							nextArr[pre_cusDi] = next_cusDi;
//							if (next_cusDi > 0)
//							{
//								varcost += (problem->c[pre_cusDi][next_cusDi] - problem->c[pre_cusDi][cusDi] - problem->c[cusDi][next_cusDi]);
//								predArr[next_cusDi] = pre_cusDi;
//								//Update from pre_cusDi till the end of the trip:
//								UpdateLegC2C_Cus(pre_cusDi,next_cusDi,lastC,CAPCus[pre_cusDi],depart[pre_cusDi],0);
//								goto Update_LastC_NC;
//							}
//							else //cusDi was the last cus --> pre_cusDi is now the last cus
//							{
//								varcost -= (problem->c[pre_cusDi][cusDi] + seg[idVeh].Trip[idTrip].connectCost);
//								seg[idVeh].Trip[idTrip].endS = depart[pre_cusDi];
//								seg[idVeh].Trip[idTrip].lastCus = pre_cusDi;
//								lastCNEW = pre_cusDi;
//								goto Update_LastC_C;
//							}
//						}//end //if (nexti != cusDi)
//					}//end next[cusDi_insert_After] == i
//				}
//				else if (pos_cusDi_insert_After < pos_cusDi)
//				{
//					if (pos_cusDi_insert_After == posi)
//					{
//						cout<<"ERROR moveCusC2CTrip_OneTrip: i = "<<i<<"; cusDi_insert_After = "<<cusDi_insert_After<<" has position equal???"<<endl;
//						cout<<"pos[i] = "<<posi<<"; pos[cusDi_insert_After] = "<<pos_cusDi_insert_After<<endl;
//						exit(-1);
//					}
//					else //posi < pos_cusDi_insert_After < pos_cusDi
//					{
//						//From nextj till prei:
//						UpdateLegC2C_Cus(i,nextj,prei,CAPCus[i],depart[i],0);
//						//Delete i:
//						varcost += (problem->c[prei][nexti] - problem->c[prei][i] - problem->c[i][nexti]);
//						nextArr[prei] = nexti; predArr[nexti] = prei;
//						//insert cusDi after insert_After:
//						if (next_cusDi_insert_After == cusDi) //cusDi was already there
//						{
//							UpdateLegC2C_Cus(prei,nexti,lastC,CAPCus[prei],depart[prei],0);
//							goto Update_LastC_NC;
//						}
//						else //.... cusDi_insert_After,next_cusDi_insert_After,....,cusDi,.....
//						{
//							UpdateLegC2C_Cus(prei,nexti,cusDi_insert_After,CAPCus[prei],depart[prei],0);
//							//insert cusDi after cusDi_insert_After:
//							varcost += (problem->c[cusDi_insert_After][cusDi] + problem->c[cusDi][next_cusDi_insert_After] - problem->c[cusDi_insert_After][next_cusDi_insert_After]);
//							nextArr[cusDi_insert_After] = cusDi; predArr[cusDi] = cusDi_insert_After;
//							nextArr[cusDi] = next_cusDi_insert_After; predArr[next_cusDi_insert_After] = cusDi;
//							Update_InsertCusC2CIAfterJ(cusDi_insert_After,cusDi,idVeh,idTrip);
//							UpdateLegC2C_Cus(cusDi,next_cusDi_insert_After,pre_cusDi,CAPCus[cusDi],depart[cusDi],0);
//							//delete cusDi:
//							nextArr[pre_cusDi] = next_cusDi;
//							if (next_cusDi > 0)
//							{
//								varcost += (problem->c[pre_cusDi][next_cusDi] - problem->c[pre_cusDi][cusDi] - problem->c[cusDi][next_cusDi]);
//								predArr[next_cusDi] = pre_cusDi;
//								UpdateLegC2C_Cus(pre_cusDi,next_cusDi,lastC,CAPCus[pre_cusDi],depart[pre_cusDi],0);
//								goto Update_LastC_NC;
//							}
//							else //pre_cusDi is now the last cus
//							{
//								varcost -= (problem->c[pre_cusDi][cusDi] + seg[idVeh].Trip[idTrip].connectCost);
//								seg[idVeh].Trip[idTrip].endS = depart[pre_cusDi];
//								seg[idVeh].Trip[idTrip].lastCus = pre_cusDi;
//								lastCNEW = pre_cusDi;
//								goto Update_LastC_C;
//							}//end //pre_cusDi is now the last cus
//						}
//					}//end posi < pos_cusDi_insert_After < pos_cusDi
//				}
//				else //pos_cusDi_insert_After >= pos_cusDi
//				{
//					if (pos_cusDi_insert_After == pos_cusDi)
//					{
//						cout<<"ERROR moveCusC2CTrip_OneTrip: cusDi = "<<cusDi<<"; cusDi_insert_After = "<<cusDi_insert_After<<" has position equal???"<<endl;
//						cout<<"pos[cusDi] = "<<pos_cusDi<<"; pos[cusDi_insert_After] = "<<pos_cusDi_insert_After<<endl;
//						exit(-1);
//					}
//					//i....cusDi....cusDi_insert_After....
//					UpdateLegC2C_Cus(i,nextj,prei,CAPCus[i],depart[i],0);
//					if (nexti == cusDi)
//					{
//						//i cusDi....cusDi_insert_After....
//						//delete i and cusDi:
//						nextArr[prei] = next_cusDi; predArr[next_cusDi] = prei;//for sure next_cusDi > 0
//						varcost += (problem->c[prei][next_cusDi] - problem->c[prei][i] - problem->c[i][cusDi] - problem->c[cusDi][next_cusDi]);
//						UpdateLegC2C_Cus(prei,next_cusDi,cusDi_insert_After,CAPCus[prei],depart[prei],0);
//					}
//					else //if (nexti != cusDi)
//					{
//						//i....cusDi....cusDi_insert_After....
//						nextArr[prei] = nexti; predArr[nexti] = prei;
//						varcost += (problem->c[prei][nexti] - problem->c[prei][i] - problem->c[i][nexti]);
//						UpdateLegC2C_Cus(prei,nexti,pre_cusDi,CAPCus[prei],depart[prei],0);
//						//delete cusDi:
//						nextArr[pre_cusDi] = next_cusDi; predArr[next_cusDi] = pre_cusDi;
//						varcost += (problem->c[pre_cusDi][next_cusDi] - problem->c[pre_cusDi][cusDi] - problem->c[cusDi][next_cusDi]);
//						UpdateLegC2C_Cus(pre_cusDi,next_cusDi,cusDi_insert_After,CAPCus[pre_cusDi],depart[pre_cusDi],0);
//					}//end if (nexti != cusDi)
//					//insert cusDi after cusDi_insert_After:
//					nextArr[cusDi_insert_After] = cusDi;
//					predArr[cusDi] = cusDi_insert_After; nextArr[cusDi] = next_cusDi_insert_After;
//					Update_InsertCusC2CIAfterJ(cusDi_insert_After,cusDi,idVeh,idTrip);
//					if (next_cusDi_insert_After > 0)
//					{
//						varcost += (problem->c[cusDi_insert_After][cusDi] + problem->c[cusDi][next_cusDi_insert_After] - problem->c[cusDi_insert_After][next_cusDi_insert_After]);
//                        predArr[next_cusDi_insert_After] = cusDi;
//						UpdateLegC2C_Cus(cusDi,next_cusDi_insert_After,lastC,CAPCus[cusDi],depart[cusDi],0);
//						goto Update_LastC_NC;
//					}
//					else //cusDi is now the last cus
//					{
//						varcost += (problem->c[cusDi_insert_After][cusDi] -seg[idVeh].Trip[idTrip].connectCost);
//						seg[idVeh].Trip[idTrip].lastCus = cusDi;
//						seg[idVeh].Trip[idTrip].endS = depart[cusDi];
//						lastCNEW = cusDi;
//						goto Update_LastC_C;
//					}
//				}
//			}//end not insert cusDi right after i; posi > posj
//		}//end posi > posj
//	}//end i is not the first cus
//
//Update_LastC_NC:
//    varvioTWC = FvioTWCus[lastC] - seg[idVeh].Trip[idTrip].vioTWC;
//	varvioCAP = FCAP[lastC] - seg[idVeh].Trip[idTrip].vioCAP;
//	//varvioCAP = FvioCAPCus[lastC] - seg[idVeh].Trip[idTrip].vioCAP;
//	seg[idVeh].Trip[idTrip].vioTWC = FvioTWCus[lastC];
//	seg[idVeh].Trip[idTrip].vioCAP = FCAP[lastC];
//	//seg[idVeh].Trip[idTrip].vioCAP = FvioCAPCus[lastC];
//	if (idTrip == lastT) 
//	{
//		seg[idVeh].Trip[idTrip].endS = depart[lastC];
//		goto UpdateNC;
//	}
//	if (PDSDIF(seg[idVeh].Trip[idTrip].endS, depart[lastC]) == 1) //change endS:
//	{
//		seg[idVeh].Trip[idTrip].endS = depart[lastC];
//		if (nextSP > 0)
//		{
//			varcost -= seg[idVeh].Trip[idTrip].connectCost;
//			UpdateChangeCONNECTAtSP_C2CTrip(idVeh,idTrip,nextT,nextSP,varcost,varcostpreT,varvioTWC,varvioCAP,lastT);
//			return;
//		}
//		else //nextT is PTrip OR C2C; lastC has not changed
//			goto UpdateC_nextPTripORC2C;
//	}
//	else goto UpdateNC;
//
//Update_LastC_C:
//	varvioTWC = FvioTWCus[lastCNEW] - seg[idVeh].Trip[idTrip].vioTWC;
//	varvioCAP = FCAP[lastCNEW] - seg[idVeh].Trip[idTrip].vioCAP;
//	//varvioCAP = FvioCAPCus[lastCNEW] - seg[idVeh].Trip[idTrip].vioCAP;
//	seg[idVeh].Trip[idTrip].vioTWC = FvioTWCus[lastCNEW];
//	seg[idVeh].Trip[idTrip].vioCAP = FCAP[lastCNEW];
//	//seg[idVeh].Trip[idTrip].vioCAP = FvioCAPCus[lastCNEW];
//	if (nextSP > 0)
//	{
//		UpdateChangeCONNECTAtSP_C2CTrip(idVeh,idTrip,nextT,nextSP,varcost,0,varvioTWC,varvioCAP,lastT);
//		return;
//	}
//	else
//	{
//		if (idTrip == lastT) 
//		{
//			seg[idVeh].Trip[idTrip].connectCost = problem->c[lastCNEW][0];
//			varcost += problem->c[lastCNEW][0];
//			goto UpdateNC;
//		}
//		else //nextT is PTrip OR C2C; lastCNEW is now the new last cus
//		{
//			seg[idVeh].Trip[idTrip].connectCost = problem->c[lastCNEW][seg[idVeh].Trip[nextT].firstCus];
//			varcost += seg[idVeh].Trip[idTrip].connectCost;
//			goto UpdateC_nextPTripORC2C;
//		}
//	}
//
//UpdateNC:
//		varFIT = varcost + VTWCUS * varvioTWC + VCAP * varvioCAP;
//		seg[idVeh].Trip[idTrip].cost += varcost;
//		if (seg[idVeh].Trip[idTrip].vioCAP > 0 || seg[idVeh].Trip[idTrip].vioTWC > eps)
//		{
//			seg[idVeh].Trip[idTrip].feasible = 0;
//			seg[idVeh].Trip[idTrip].fitness += varFIT;
//		}
//		else
//		{
//			seg[idVeh].Trip[idTrip].feasible = 1;
//			seg[idVeh].Trip[idTrip].fitness = seg[idVeh].Trip[idTrip].cost;
//		}
//		varC1 = varcost + varcostpreT;varFIT += varcostpreT;
//		seg[idVeh].cost += varC1; seg[idVeh].fitness += varFIT; seg[idVeh].vioTWC += varvioTWC; seg[idVeh].vioCAP += varvioCAP;
//		cost += varC1; fitness += varFIT;vioTWC += varvioTWC;vioCAP += varvioCAP;
//		goto CHECK;
//
//UpdateC_nextPTripORC2C:
//		varFIT = varcost + VTWCUS * varvioTWC + VCAP * varvioCAP;
//		seg[idVeh].Trip[idTrip].cost += varcost;
//		if (seg[idVeh].Trip[idTrip].vioCAP > 0 || seg[idVeh].Trip[idTrip].vioTWC > eps)
//		{
//			seg[idVeh].Trip[idTrip].feasible = 0;
//			seg[idVeh].Trip[idTrip].fitness += varFIT;
//		}
//		else
//		{
//			seg[idVeh].Trip[idTrip].feasible = 1;
//			seg[idVeh].Trip[idTrip].fitness = seg[idVeh].Trip[idTrip].cost;
//		}
//		UpdateVehicle(idVeh, nextT,seg[idVeh].Trip[idTrip].lastCus,seg[idVeh].Trip[idTrip].endS,varvioCAP,lastT);
//CHECK:
//	UpdateBvioTW_BvioCAPCus(idVeh, idTrip, seg[idVeh].Trip[idTrip].lastCus);
//	bool stop = checkVehicle(idVeh);
//	if (stop)
//	{
//		cout<<"STOP AT moveCusC2CTrip_OneTrip @IT = "<<IT<<endl;
//		exit(-1);
//	}
//}
//
//
//void Solution::moveCusC2CTrip_OneVeh(int j, int idTripj, int i, int idTripi, int idVeh, int cusDi_insert_After)
//{
//	//19/12/2013: move cus (i, cusDi) on (idVeh, idTripi) appropriately after cus (j and cusDi_insert_After) on (idVeh,idTripj)  where they are on the same vehicle fromVeh
//   int prei = predArr[i]; int nexti = nextArr[i];
//   if (idTripj < idTripi) // j before i
//   {
//	   //cout<<"j before i"<<endl;
//	   int preTi = idTripi - 1; double cStartSOLD;
//	   if (seg[idVeh].Trip[preTi].Type == 0) cStartSOLD = seg[idVeh].Trip[preTi].leaveSP;
//	   else cStartSOLD = depart[seg[idVeh].Trip[preTi].lastCus];
//
//	   //1. Insert i after j on Trip(idVeh, toTrip) and recalculate all information if neccessary:
//	   insertCusC2CTrip(j,i,cusDi_insert_After,idVeh,idTripj,preTi);
//
//       if (seg[idVeh].Trip[idTripi].numCus == 2)
//	   {
//		   Update_EmptyTripC2C(idVeh, idTripi);
//	   }
//	   else
//	   {
//		   double cStartSNEW;
//		   if (seg[idVeh].Trip[preTi].Type == 0) cStartSNEW = seg[idVeh].Trip[preTi].leaveSP;
//		   else cStartSNEW = depart[seg[idVeh].Trip[preTi].lastCus];
//		   if (PDSDIF(cStartSOLD, cStartSNEW))
//		   {
//				//cout<<"CALL deleteCusPTrip_FromBeginning"<<endl;
//			    deleteCusC2CTrip_FromBeginning(idVeh,idTripi,prei,i,nexti);
//		   }
//		   else
//		   {
//			   //cout<<"CALL deleteCusPTrip"<<endl;
//			   deleteCusC2CTrip(idVeh,idTripi,prei,i,nexti);
//		   }
//		   UpdateBvioTW_BvioCAPCus(idVeh, idTripi, seg[idVeh].Trip[idTripi].lastCus);
//	   }
//	 
//   }
//   else //j after i
//   {
//	   //cout<<"j after i "<<endl;
//	   if (seg[idVeh].Trip[idTripi].numCus == 2)
//	   {
//		   delete_insertCusC2CTrip(i,idTripi, j, cusDi_insert_After, idTripj, idVeh); //empty idTripi which is before idTripj, (NOT NECCESSARY RIGHT BEFORE), then insert i after j on trip idTripj, then DON TOA and update all remaining trips of idVeh
//           UpdateBvioTW_BvioCAPCus(idVeh, idTripj, seg[idVeh].Trip[idTripj].lastCus);
//	   }
//	   else
//	   {
//		   int preTj = idTripj - 1; double cStartSOLD, cStartSNEW;
//		   if (seg[idVeh].Trip[preTj].Type == 0) cStartSOLD = seg[idVeh].Trip[preTj].leaveSP;
//		   else cStartSOLD = depart[seg[idVeh].Trip[preTj].lastCus];
//		   //cout<<"CALL deleteCusPTrip_TillTrip on trip("<<idVeh<<", "<<idTripi<<"): cut at cus "<<i<<"; preTj= "<<preTj<<endl;
//           deleteCusC2CTrip_TillTrip(idVeh,idTripi,prei,i,nexti,preTj); //delete cus i from (idVeh, idTripi) where idTripi > 2 customers; and update remaining trips till trip (idTripj - 1)	
//		   if (seg[idVeh].Trip[preTj].Type == 0) cStartSNEW = seg[idVeh].Trip[preTj].leaveSP;
//		   else cStartSNEW = depart[seg[idVeh].Trip[preTj].lastCus];
//		   if (PDSDIF(cStartSOLD, cStartSNEW))
//		   {
//			   //cout<<"CALL insertCusPTrip_FromBeginning on trip ("<<idVeh<<", "<<idTripj<<"):"<<endl;
//			   insertCusC2CTrip_FromBeginning(j, i, cusDi_insert_After, idVeh, idTripj,seg[idVeh].numTrips - 1);
//		   }
//		   else
//		   {
//			   //cout<<"CALL insertCusPTrip"<<endl; 
//			   insertCusC2CTrip(j,i,cusDi_insert_After,idVeh,idTripj,seg[idVeh].numTrips - 1);//insert i after j on (idVeh, idTripj) and update remaining trips till lastTrip of veh
//		   }
//		   UpdateBvioTW_BvioCAPCus(idVeh, idTripi, seg[idVeh].Trip[idTripi].lastCus);
//		   UpdateBvioTW_BvioCAPCus(idVeh, idTripj, seg[idVeh].Trip[idTripj].lastCus);
//	   }
//   }//end j after i
//	bool stop = checkVehicle(idVeh);
//	if (stop)
//	{
//		cout<<"STOP AT moveCusC2CTrip_OneVeh @IT = "<<IT<<endl;
//		exit(-1);
//	}
//    
//}
//void Solution::exchangeCusC2CTrip_OneTrip(int i, int j, int idVeh, int idTrip)
//{
//		double varcost, varcostpreT, varvioTWC, varFIT,varC1;
//		int varvioCAP, PRE;
//		int prei,nexti,prej,nextj,pre_cusDi,next_cusDi,pre_cusDj,next_cusDj,tt;
//
//		if (pos[i] > pos[j]) {tt=i;i=j;j=tt;} //swap i and j so that i is before j
//		int cusDi = problem->node[i].delID;
//		int cusDj = problem->node[j].delID;
//		int lastCNEW = cusDj;
//		int pos_cusDi = pos[cusDi]; int posj = pos[j];
//
//		int lastC = seg[idVeh].Trip[idTrip].lastCus;
//		int nextSP = seg[idVeh].Trip[idTrip].nextSP;
//		int nextT = idTrip + 1; int lastT = seg[idVeh].numTrips - 1;
//
//		prei = predArr[i]; nexti = nextArr[i];
//		prej = predArr[j]; nextj = nextArr[j];
//		pre_cusDi = predArr[cusDi]; next_cusDi = nextArr[cusDi];
//		pre_cusDj = predArr[cusDj]; next_cusDj = nextArr[cusDj];
//
//		if (prei > 0) 
//		{
//			varcostpreT = 0;
//			varcost = problem->c[prei][j] - problem->c[prei][i];
//			nextArr[prei] = j; predArr[j] = prei;
//			Update_InsertCusC2CIAfterJ(prei,j,idVeh,idTrip);
//		}
//		else 
//		{
//			seg[idVeh].Trip[idTrip].firstCus = j;
//			predArr[j] = -1; pos[j] = 1; 
//			double cStartS;
//			if (idTrip == 0)
//			{
//				prei = 0; cStartS = 0; 
//				varcostpreT = 0;
//				varcost = problem->c[0][j] - problem->c[0][i];
//			}
//			else
//			{
//				int preT = idTrip - 1;
//				if (seg[idVeh].Trip[preT].Type == 0)
//				{
//					prei = seg[idVeh].Trip[preT].assSP;
//					cStartS = seg[idVeh].Trip[preT].leaveSP;
//				}
//				else
//				{
//					prei = seg[idVeh].Trip[preT].lastCus;
//					cStartS = depart[prei];
//				}
//				varcostpreT = problem->c[prei][j] - seg[idVeh].Trip[preT].connectCost;
//				seg[idVeh].Trip[preT].connectCost = problem->c[prei][j];
//				seg[idVeh].Trip[preT].cost += varcostpreT;
//				seg[idVeh].Trip[preT].fitness += varcostpreT;
//				varcost = 0;
//			}
//			double cArrTime = cStartS + problem->c[prei][j];
//			double temp = cArrTime - problem->node[j].eTW;
//			if (temp > eps)
//			{
//				startS[j] = problem->node[j].eTW;
//				depart[j] = problem->node[j].depart;
//				vioTWCus[j] = temp; FvioTWCus[j] = temp; 
//			}
//			else 
//			{
//				startS[j] = PDS_MAX(problem->node[j].sTW, cArrTime);
//				depart[j] = startS[j] + problem->node[j].duration;
//				vioTWCus[j] = 0; FvioTWCus[j] = 0; 
//			}
//			CAPCus[j] = problem->node[j].capacity;
//			vioCAPCus[j] = 0; FCAP[j] = 0;
//		}
//
//		if (pos_cusDi < posj) // (CASE 1) before exchange: ..i..cusDi...j...cusDj....
//		{
//			//Checking from nexti ... pre_cusDi:
//			nextArr[j] = nexti; predArr[nexti] = j;
//			if (nexti != pre_cusDi) //1.1 i... cusDi
//			{
//				varcost += (problem->c[j][nexti] - problem->c[i][nexti]);
//				UpdateLegC2C_Cus(j,nexti,pre_cusDi,CAPCus[j],depart[j],0);
//				varcost += (problem->c[pre_cusDi][cusDj] - problem->c[pre_cusDi][cusDi]);
//				PRE = pre_cusDi;
//			}
//			else //else1.1 i,cusDi,...
//			{
//				varcost += (problem->c[j][cusDj] - problem->c[i][cusDi]);
//				PRE = j;
//			}
//			//Assign cusDj at place of cusDi:
//			nextArr[PRE] = cusDj; predArr[cusDj] = PRE;
//			Update_InsertCusC2CIAfterJ(PRE,cusDj,idVeh,idTrip);
//			if (next_cusDi == j) //1.2   (i...cusDi),j.... OR (i,cusDi),j // before exchange: ..i..cusDi...j...cusDj....
//			{
//				varcost += (problem->c[cusDj][i] - problem->c[cusDi][j]);
//				PRE = cusDj;
//			}
//			else //next_cusDi != j: //1.2   (i...cusDi),next_cusDi,..,j.... OR (i,cusDi),next_cusDi,...,j... // before exchange: ..i..cusDi...j...cusDj....
//			{
//				varcost += (problem->c[cusDj][next_cusDi] - problem->c[cusDi][next_cusDi]);
//				nextArr[cusDj] = next_cusDi; predArr[next_cusDi] = cusDj;
//				UpdateLegC2C_Cus(cusDj,next_cusDi,prej,CAPCus[cusDj],depart[cusDj],0);
//				PRE = prej;
//			}
//			//Assign i at place of j:
//			nextArr[PRE] = i; predArr[i] = PRE;
//			Update_InsertCusC2CIAfterJ(PRE,i,idVeh,idTrip);
//
//			if (nextj != cusDj) //....(j,....,cusDj)...
//			{
//				varcost += (problem->c[i][nextj] - problem->c[j][nextj]);
//				nextArr[i] = nextj; predArr[nextj] = i;
//				UpdateLegC2C_Cus(i,nextj,pre_cusDj,CAPCus[i],depart[i],0);
//				PRE = pre_cusDj;
//			}
//			else //nextj == cusDj: (i...cusDi)....(j,cusDj)... 
//			{
//				varcost += (problem->c[i][cusDi] - problem->c[j][cusDj]);
//				PRE = i;
//			}//end nextj == cusDj: (i...cusDi)....(j,cusDj)
//			//Assign cusDi at place of cusDj:
//			nextArr[PRE] = cusDi; predArr[cusDi] = PRE;
//			Update_InsertCusC2CIAfterJ(PRE,cusDi,idVeh,idTrip);
//
//			if (next_cusDj > 0) //1.4 cusDj was not the last cus
//			{
//				varcost += (problem->c[cusDi][next_cusDj] - problem->c[cusDj][next_cusDj]);
//				nextArr[cusDi] = next_cusDj; predArr[next_cusDj] = cusDi;
//				//lastCus doesn't change:
//				UpdateLegC2C_Cus(cusDi,next_cusDj,lastC,CAPCus[cusDi],depart[cusDi],0);
//				goto Update_LastC_NC_EXCHANGETRIPC2C;
//			}
//			else //cusDi is now the last cus:
//			{
//				varcost -= seg[idVeh].Trip[idTrip].connectCost;
//				nextArr[cusDi] = -1;
//				seg[idVeh].Trip[idTrip].lastCus = cusDi;
//				seg[idVeh].Trip[idTrip].endS = depart[cusDi];
//				lastCNEW = cusDi;
//				goto Update_LastC_C_EXCHANGETRIPC2C;
//			}//end cusDi is now the last cus
//		}
//		else // (CASE 2) before exchange: ...i....j...cusDj...cusDi....
//		{
//			//Checking from nexti ... pre_j:
//			if (nexti != j) //2.1 i,...,j
//			{
//				nextArr[j] = nexti; predArr[nexti] = j;
//				varcost += (problem->c[j][nexti] - problem->c[i][nexti]);
//				UpdateLegC2C_Cus(j,nexti,prej,CAPCus[j],depart[j],0);
//				varcost += (problem->c[prej][i] - problem->c[prej][j]);
//				PRE = prej;
//			}
//			else //else2.1 i,j,...
//			{
//				PRE = j;
//			}
//			//Assign i at place of j:
//			nextArr[PRE] = i; predArr[i] = PRE;
//			Update_InsertCusC2CIAfterJ(PRE,i,idVeh,idTrip);
//			if (nextj == cusDj) //2.2 ...i...j,cusDj,....
//			{
//				nextArr[i] = cusDi; predArr[cusDi] = i;
//				varcost += (problem->c[i][cusDi] - problem->c[j][cusDj]);
//				//Assign cusDi at place of cusDj
//				PRE = i;
//			}
//			else //nextj != cusDj: //...i....j,....,cusDj,....
//			{
//				varcost += (problem->c[i][nextj] - problem->c[j][nextj] + problem->c[pre_cusDj][cusDi] - problem->c[pre_cusDj][cusDj]);
//				nextArr[i] = nextj; predArr[nextj] = i;
//				UpdateLegC2C_Cus(i,nextj,pre_cusDj,CAPCus[i],depart[i],0);
//				PRE = pre_cusDj;
//			}//end nextj != cusDj
//			//Assign cusDi at place of cusDj:
//			nextArr[PRE] = cusDi; predArr[cusDi] = PRE;
//			Update_InsertCusC2CIAfterJ(PRE,cusDi,idVeh,idTrip);
//			if (next_cusDj == cusDi) //2.3 i....j....cusDj,cusDi.....
//			{
//				//varcost += (problem->c[cusDi][cusDj]);
//				//Assign cusDj at place of cusDi
//				PRE = cusDi;
//			}
//			else //else2.3 i....j....cusDj....cusDi.....
//			{
//				nextArr[cusDi] = next_cusDj; predArr[next_cusDj] = cusDi;
//				varcost += (problem->c[cusDi][next_cusDj] - problem->c[cusDj][next_cusDj] + problem->c[pre_cusDi][cusDj] - problem->c[pre_cusDi][cusDi]);
//				UpdateLegC2C_Cus(cusDi,next_cusDj,pre_cusDi,CAPCus[cusDi],depart[cusDi],0);
//				PRE = pre_cusDi;
//			}//end else2.3 
//			//Assign cusDj at place of cusDi:
//			nextArr[PRE] = cusDj; predArr[cusDj] = PRE;
//			Update_InsertCusC2CIAfterJ(PRE,cusDj,idVeh,idTrip);
//			if (next_cusDi > 0) //lastCus doesn't change: i....j....cusDj....cusDi...
//			{
//				nextArr[cusDj] = next_cusDi; predArr[next_cusDi] = cusDj;
//				varcost += (problem->c[cusDj][next_cusDi] - problem->c[cusDi][next_cusDi]);
//				UpdateLegC2C_Cus(cusDj,next_cusDi,lastC,CAPCus[cusDj],depart[cusDj],0);
//				goto Update_LastC_NC_EXCHANGETRIPC2C;
//			}
//			else //cusDj is now the last cus:
//			{
//				varcost -= seg[idVeh].Trip[idTrip].connectCost;
//				nextArr[cusDj] = -1;
//				seg[idVeh].Trip[idTrip].lastCus = cusDj;
//				seg[idVeh].Trip[idTrip].endS = depart[cusDj];
//				lastCNEW = cusDj;
//				goto Update_LastC_C_EXCHANGETRIPC2C;
//			}//end cusDj is now the last cus
//		}//END (CASE 2) before exchange: ...i....j...cusDj...cusDi....
//
//Update_LastC_NC_EXCHANGETRIPC2C:
//    UpdateBvioTW_BvioCAPCus(idVeh,idTrip,seg[idVeh].Trip[idTrip].firstCus);
//    varvioTWC = FvioTWCus[lastC] - seg[idVeh].Trip[idTrip].vioTWC;
//	varvioCAP = FCAP[lastC] - seg[idVeh].Trip[idTrip].vioCAP;
//	//varvioCAP = FvioCAPCus[lastC] - seg[idVeh].Trip[idTrip].vioCAP;
//	seg[idVeh].Trip[idTrip].vioTWC = FvioTWCus[lastC];
//	seg[idVeh].Trip[idTrip].vioCAP = FCAP[lastC];
//	//seg[idVeh].Trip[idTrip].vioCAP = FvioCAPCus[lastC];
//	if (idTrip == lastT) 
//	{
//		seg[idVeh].Trip[idTrip].endS = depart[lastC];
//		goto UpdateNC_EXCHANGETRIPC2C;
//	}  
//	if (PDSDIF(seg[idVeh].Trip[idTrip].endS, depart[lastC]) == 0) //change endS:
//	{
//		seg[idVeh].Trip[idTrip].endS = depart[lastC];
//		if (nextSP > 0)
//		{
//			varcost -= seg[idVeh].Trip[idTrip].connectCost;
//			UpdateChangeCONNECTAtSP_C2CTrip(idVeh,idTrip,nextT,nextSP,varcost,varcostpreT,varvioTWC,varvioCAP,lastT);
//			return;
//		}
//		else //nextT is PTrip OR C2C; lastC has not changed
//			goto UpdateC_nextPTripORC2C_EXCHANGETRIPC2C;
//	}
//	else goto UpdateNC_EXCHANGETRIPC2C;
//
//Update_LastC_C_EXCHANGETRIPC2C:
//	varvioTWC = FvioTWCus[lastCNEW] - seg[idVeh].Trip[idTrip].vioTWC;
//	varvioCAP = FCAP[lastCNEW] - seg[idVeh].Trip[idTrip].vioCAP;
//	//varvioCAP = FvioCAPCus[lastCNEW] - seg[idVeh].Trip[idTrip].vioCAP;
//	seg[idVeh].Trip[idTrip].vioTWC = FvioTWCus[lastCNEW];
//	seg[idVeh].Trip[idTrip].vioCAP = FCAP[lastCNEW];
//	//seg[idVeh].Trip[idTrip].vioCAP = FvioCAPCus[lastCNEW];
//	if (nextSP > 0)
//	{
//		UpdateChangeCONNECTAtSP_C2CTrip(idVeh,idTrip,nextT,nextSP,varcost,0,varvioTWC,varvioCAP,lastT);
//		return;
//	}
//	else
//	{
//		if (idTrip == lastT) 
//		{
//			seg[idVeh].Trip[idTrip].connectCost = problem->c[lastCNEW][0];
//			varcost += problem->c[lastCNEW][0];
//			goto UpdateNC_EXCHANGETRIPC2C;
//		}
//		else //nextT is PTrip OR C2C; lastCNEW is now the new last cus
//		{
//			seg[idVeh].Trip[idTrip].connectCost = problem->c[lastCNEW][seg[idVeh].Trip[nextT].firstCus];
//			varcost += seg[idVeh].Trip[idTrip].connectCost;
//			goto UpdateC_nextPTripORC2C_EXCHANGETRIPC2C;
//		}
//	}
//
//UpdateNC_EXCHANGETRIPC2C:
//		varFIT = varcost + VTWCUS * varvioTWC + VCAP * varvioCAP;
//		seg[idVeh].Trip[idTrip].cost += varcost;
//		if (seg[idVeh].Trip[idTrip].vioCAP > 0 || seg[idVeh].Trip[idTrip].vioTWC > eps)
//		{
//			seg[idVeh].Trip[idTrip].feasible = 0;
//			seg[idVeh].Trip[idTrip].fitness += varFIT;
//		}
//		else
//		{
//			seg[idVeh].Trip[idTrip].feasible = 1;
//			seg[idVeh].Trip[idTrip].fitness = seg[idVeh].Trip[idTrip].cost;
//		}
//		varC1 = varcost + varcostpreT;varFIT += varcostpreT;
//		seg[idVeh].cost += varC1; seg[idVeh].fitness += varFIT; seg[idVeh].vioTWC += varvioTWC; seg[idVeh].vioCAP += varvioCAP;
//		cost += varC1; fitness += varFIT;vioTWC += varvioTWC;vioCAP += varvioCAP;
//		goto CHECK_EXCHANGETRIPC2C;
//
//UpdateC_nextPTripORC2C_EXCHANGETRIPC2C:
//		varFIT = varcost + VTWCUS * varvioTWC + VCAP * varvioCAP;
//		seg[idVeh].Trip[idTrip].cost += varcost;
//		if (seg[idVeh].Trip[idTrip].vioCAP > 0 || seg[idVeh].Trip[idTrip].vioTWC > eps)
//		{
//			seg[idVeh].Trip[idTrip].feasible = 0;
//			seg[idVeh].Trip[idTrip].fitness += varFIT;
//		}
//		else
//		{
//			seg[idVeh].Trip[idTrip].feasible = 1;
//			seg[idVeh].Trip[idTrip].fitness = seg[idVeh].Trip[idTrip].cost;
//		}
//		UpdateVehicle(idVeh, nextT,seg[idVeh].Trip[idTrip].lastCus,seg[idVeh].Trip[idTrip].endS,varvioCAP,lastT);
//CHECK_EXCHANGETRIPC2C:
//    UpdateBvioTW_BvioCAPCus(idVeh,idTrip,seg[idVeh].Trip[idTrip].firstCus);
//	bool stop = checkVehicle(idVeh);
//	if (stop)
//	{
//		cout<<"STOP AT exchangeCusC2CTrip_OneTrip @IT = "<<IT<<endl;
//		exit(-1);
//	}
//
//
//}
//void Solution::exchangeCusC2CTrip_OneVeh(int j, int idTripj, int i, int idTripi, int idVeh)
//{
//}
//void Solution::replaceCusC2CTrip(int delCus, int idVeh, int idTrip, int insCus)
//{
//		double varcost, varcostpreT, varvioTWC, varFIT,varC1;
//		int varvioCAP, PRE,lastCNEW;
//		int pre_delCus = predArr[delCus]; int next_delCus = nextArr[delCus];
//		int delCusD = problem->node[delCus].delID;
//		int pre_delCusD = predArr[delCusD]; int next_delCusD = nextArr[delCusD];
//		int insCusD = problem->node[insCus].delID;
//
//
//		int lastC = seg[idVeh].Trip[idTrip].lastCus;
//		int nextSP = seg[idVeh].Trip[idTrip].nextSP;
//		int nextT = idTrip + 1; int lastT = seg[idVeh].numTrips - 1;
//		if (idTrip == 0 && seg[idVeh].Trip[idTrip].numCus == 2 && nextSP > 0)
//		{
//			if (problem->waitingSOneP[insCus][nextSP])
//			{
//				seg[idVeh].Trip[0].connectCost = problem->disCWSSP[insCusD][nextSP]; 
//				seg[idVeh].Trip[0].waitingS = problem->CWSSP[insCusD][nextSP];
//			}
//			else 
//			{
//				seg[idVeh].Trip[0].connectCost = problem->c[insCusD][nextSP];
//				seg[idVeh].Trip[0].waitingS = NO_WS;
//			}
//			seg[idVeh].Trip[0].cost = problem->c[0][insCus] + problem->c[insCus][insCusD] + seg[idVeh].Trip[0].connectCost;
//			seg[idVeh].Trip[0].fitness = seg[idVeh].Trip[0].fitness;
//			seg[idVeh].Trip[0].firstCus = insCus; seg[idVeh].Trip[0].lastCus = insCusD;
//			predArr[insCus] = -1; nextArr[insCus] = insCusD; predArr[insCusD] = insCus; nextArr[insCusD] = -1;
//			vioTWCus[insCus] = 0; vioCAPCus[insCus] = 0; CAPCus[insCus] = problem->node[insCus].capacity;
//			FvioTWCus[insCus] = 0; FCAP[insCus] = 0;
//			BvioTWCus[insCus] = 0; BCAP[insCus] = 0;
//
//			vioTWCus[insCusD] = 0; vioCAPCus[insCusD] = 0;  CAPCus[insCus] = 0;
//			FvioTWCus[insCusD] = 0; FCAP[insCusD] = 0;
//			BvioTWCus[insCusD] = 0; BCAP[insCusD] = 0;
//
//			startS[insCus] = problem->startSOneP[insCus][nextSP];
//			depart[insCus] = startS[insCus] + problem->node[insCus].duration;
//			startS[insCusD] = problem->startSOneP[insCusD][nextSP];
//			depart[insCusD] = startS[insCusD] + problem->node[insCusD].duration;
//
//			seg[idVeh].Trip[0].arriveSP = problem->leaveSPOneP[insCus][nextSP] - problem->nodeSP[nextSP].load;
//			seg[idVeh].Trip[1].leaveSP = problem->leaveSPOneP[insCus][nextSP];
//			UpdateVehicle(idVeh,1,nextSP,seg[idVeh].Trip[1].leaveSP,0,lastT);
//			goto CHECK_REPLACEC2C;
//		}
//		else
//		{
//			if (pre_delCus > 0) 
//			{
//				varcostpreT = 0;
//				varcost = problem->c[pre_delCus][insCus] - problem->c[pre_delCus][delCus];
//				nextArr[pre_delCus] = insCus; predArr[insCus] = pre_delCus;
//				Update_InsertCusC2CIAfterJ(pre_delCus,insCus,idVeh,idTrip);
//			}
//			else 
//			{
//				seg[idVeh].Trip[0].firstCus = insCus;
//			    predArr[insCus] = -1; pos[insCus] = 1;
//				double cStartS;
//				if (idTrip == 0)
//				{
//				   pre_delCus = 0;
//				   cStartS = 0;
//				   varcostpreT = 0;
//				   varcost = problem->c[0][insCus] - problem->c[0][delCus];
//				}
//				else
//				{
//					int preT = idTrip - 1;
//					if (seg[idVeh].Trip[preT].Type == 0)
//					{
//						pre_delCus = seg[idVeh].Trip[preT].assSP;
//						cStartS = seg[idVeh].Trip[preT].leaveSP;
//					}
//					else // == 1 OR 2
//					{
//						pre_delCus = seg[idVeh].Trip[preT].lastCus;
//						cStartS = depart[pre_delCus];
//					}
//					varcostpreT = problem->c[pre_delCus][insCus] - seg[idVeh].Trip[preT].connectCost;
//					seg[idVeh].Trip[preT].connectCost = problem->c[pre_delCus][insCus];
//					seg[idVeh].Trip[preT].cost += varcostpreT;
//					seg[idVeh].Trip[preT].fitness += varcostpreT;
//					varcost = 0;
//				}
//				double cArrTime = cStartS + problem->c[pre_delCus][insCus];
//				double temp = cArrTime - problem->node[insCus].eTW;
//				if (temp > eps)
//				{
//					startS[insCus] = problem->node[insCus].eTW;
//					depart[insCus] = problem->node[insCus].depart;
//					vioTWCus[insCus] = temp; FvioTWCus[insCus] = temp; 
//				}
//				else 
//				{
//					startS[insCus] = PDS_MAX(problem->node[insCus].sTW, cArrTime);
//					depart[insCus] = startS[insCus] + problem->node[insCus].duration;
//					vioTWCus[insCus] = 0; FvioTWCus[insCus] = 0; 
//				}
//				CAPCus[insCus] = problem->node[insCus].capacity;
//				vioCAPCus[insCus] = 0; FCAP[insCus] = 0;
//			}//pre_delCus < 0
//
//			if (next_delCus == delCusD)
//			{
//				//....delCus,delCusD,....
//				varcost += (problem->c[insCus][insCusD] - problem->c[delCus][delCusD]);
//				//Assign insCusD at place of delCusD:
//				PRE = insCus;
//			}
//			else //delCus != delcusD
//			{
//				nextArr[insCus] = next_delCus; predArr[next_delCus] = insCus;
//				//....delCus....,delCusD....
//				varcost += ((problem->c[insCus][next_delCus] - problem->c[delCus][next_delCus]) + (problem->c[pre_delCusD][insCusD] - problem->c[pre_delCusD][delCusD]));
//                UpdateLegC2C_Cus(insCus,next_delCus,pre_delCusD,CAPCus[insCus],depart[insCus],0);
//				PRE = pre_delCusD;
//			}//end nexti != cusDi
//			//Assign cusDj at place of cusDi:
//			nextArr[PRE] = insCusD; predArr[insCusD] = PRE;
//			Update_InsertCusC2CIAfterJ(PRE,insCusD,idVeh,idTrip);
//			nextArr[insCusD] = next_delCusD;
//
//			if (next_delCusD > 0) //lastCus doesnt change
//			{
//				predArr[next_delCusD] = insCusD;
//				varcost += (problem->c[insCusD][next_delCusD] - problem->c[delCusD][next_delCusD]);
//				UpdateLegC2C_Cus(insCusD,next_delCusD,lastC,CAPCus[insCusD],depart[insCusD],0);
//				goto Update_LastC_NC_REPLACEC2C;
//			}
//			else //delcusD was the last cus--> insCusD is now the last cus
//			{
//				varcost -= seg[idVeh].Trip[idTrip].connectCost;
//				seg[idVeh].Trip[idTrip].endS = depart[insCusD];
//				seg[idVeh].Trip[idTrip].lastCus = insCusD;
//				lastCNEW = insCusD;
//				goto Update_LastC_C_REPLACEC2C;
//			}//end cusDi was the last cus--> cusDj is now the last cus
//		}
//Update_LastC_NC_REPLACEC2C:
//    varvioTWC = FvioTWCus[lastC] - seg[idVeh].Trip[idTrip].vioTWC;
//	varvioCAP = FCAP[lastC] - seg[idVeh].Trip[idTrip].vioCAP;
//	//varvioCAP = FvioCAPCus[lastC] - seg[idVeh].Trip[idTrip].vioCAP;
//	seg[idVeh].Trip[idTrip].vioTWC = FvioTWCus[lastC];
//	seg[idVeh].Trip[idTrip].vioCAP = FCAP[lastC];
//	//seg[idVeh].Trip[idTrip].vioCAP = FvioCAPCus[lastC];
//	if (idTrip == lastT) 
//	{
//		seg[idVeh].Trip[idTrip].endS = depart[lastC];
//		goto UpdateNC_REPLACEC2C;
//	}  
//	if (PDSDIF(seg[idVeh].Trip[idTrip].endS, depart[lastC]) == 1) //change endS:
//	{
//		seg[idVeh].Trip[idTrip].endS = depart[lastC];
//		if (nextSP > 0)
//		{
//			varcost -= seg[idVeh].Trip[idTrip].connectCost;
//			UpdateChangeCONNECTAtSP_C2CTrip(idVeh,idTrip,nextT,nextSP,varcost,varcostpreT,varvioTWC,varvioCAP,lastT);
//			return;
//		}
//		else //nextT is PTrip OR C2C; lastC has not changed
//			goto UpdateC_nextPTripORC2C_REPLACEC2C;
//	}
//	else goto UpdateNC_REPLACEC2C;
//
//Update_LastC_C_REPLACEC2C:
//	varvioTWC = FvioTWCus[lastCNEW] - seg[idVeh].Trip[idTrip].vioTWC;
//	varvioCAP = FCAP[lastCNEW] - seg[idVeh].Trip[idTrip].vioCAP;
//	//varvioCAP = FvioCAPCus[lastCNEW] - seg[idVeh].Trip[idTrip].vioCAP;
//	seg[idVeh].Trip[idTrip].vioTWC = FvioTWCus[lastCNEW];
//	seg[idVeh].Trip[idTrip].vioCAP = FCAP[lastCNEW];
//	//seg[idVeh].Trip[idTrip].vioCAP = FvioCAPCus[lastCNEW];
//	if (nextSP > 0)
//	{
//		UpdateChangeCONNECTAtSP_C2CTrip(idVeh,idTrip,nextT,nextSP,varcost,0,varvioTWC,varvioCAP,lastT);
//		return;
//	}
//	else
//	{
//		if (idTrip == lastT) 
//		{
//			seg[idVeh].Trip[idTrip].connectCost = problem->c[lastCNEW][0];
//			varcost += problem->c[lastCNEW][0];
//			goto UpdateNC_REPLACEC2C;
//		}
//		else //nextT is PTrip OR C2C; lastCNEW is now the new last cus
//		{
//			seg[idVeh].Trip[idTrip].connectCost = problem->c[lastCNEW][seg[idVeh].Trip[nextT].firstCus];
//			varcost += seg[idVeh].Trip[idTrip].connectCost;
//			goto UpdateC_nextPTripORC2C_REPLACEC2C;
//		}
//	}
//
//UpdateNC_REPLACEC2C:
//		varFIT = varcost + VTWCUS * varvioTWC + VCAP * varvioCAP;
//		seg[idVeh].Trip[idTrip].cost += varcost;
//		if (seg[idVeh].Trip[idTrip].vioCAP > 0 || seg[idVeh].Trip[idTrip].vioTWC > eps)
//		{
//			seg[idVeh].Trip[idTrip].feasible = 0;
//			seg[idVeh].Trip[idTrip].fitness += varFIT;
//		}
//		else
//		{
//			seg[idVeh].Trip[idTrip].feasible = 1;
//			seg[idVeh].Trip[idTrip].fitness = seg[idVeh].Trip[idTrip].cost;
//		}
//		varC1 = varcost + varcostpreT;varFIT += varcostpreT;
//		seg[idVeh].cost += varC1; seg[idVeh].fitness += varFIT; seg[idVeh].vioTWC += varvioTWC; seg[idVeh].vioCAP += varvioCAP;
//		cost += varC1; fitness += varFIT;vioTWC += varvioTWC;vioCAP += varvioCAP;
//		goto CHECK_REPLACEC2C;
//
//UpdateC_nextPTripORC2C_REPLACEC2C:
//		varFIT = varcost + VTWCUS * varvioTWC + VCAP * varvioCAP;
//		seg[idVeh].Trip[idTrip].cost += varcost;
//		if (seg[idVeh].Trip[idTrip].vioCAP > 0 || seg[idVeh].Trip[idTrip].vioTWC > eps)
//		{
//			seg[idVeh].Trip[idTrip].feasible = 0;
//			seg[idVeh].Trip[idTrip].fitness += varFIT;
//		}
//		else
//		{
//			seg[idVeh].Trip[idTrip].feasible = 1;
//			seg[idVeh].Trip[idTrip].fitness = seg[idVeh].Trip[idTrip].cost;
//		}
//		UpdateVehicle(idVeh, nextT,seg[idVeh].Trip[idTrip].lastCus,seg[idVeh].Trip[idTrip].endS,varvioCAP,lastT);
//CHECK_REPLACEC2C:
//    UpdateBvioTW_BvioCAPCus(idVeh,idTrip,seg[idVeh].Trip[idTrip].firstCus);
//	bool stop = checkVehicle(idVeh);
//	if (stop)
//	{
//		cout<<"STOP AT replaceCusC2CTrip_OneTrip @IT = "<<IT<<endl;
//		exit(-1);
//	}
//
//}

//void Solution::UpdateInsertArray(int idVeh)
//{
//	//see on 27/11/2013: 
//    //2nd Transform: Insert customers:
//    //cout<<"2. Insert customers between trips: "<<endl;
//    int i,idTrip, nextT, k, curC, nextC,nextSP, insertAfter;
//	double cStartS;
//
//
//	int lastT = seg[idVeh].numTrips - 1;
//	bool doit = 1;
//	int idTrip1 = 0;
//	
//	if (seg[idVeh].Trip[0].Type == 0 && seg[idVeh].Trip[0].numCus == 1)
//	{
//		curC = seg[idVeh].Trip[0].firstCus;
//		int assSP = seg[idVeh].Trip[0].assSP;
//		idTrip1 = 1;
//		if (lastT == 0) //vehicle with only 1 pickup trip with one customer
//		{
//			doit = 0;
//			//curC now points to the last cus:
//			for (k=0; k < problem->node[curC].neighborSize; k++)
//			{
//				i = problem->node[curC].neighborNode[k].id;
//				if (problem->belong[i][assSP])
//				{		
//					SUBcal_InsertCusPIAfterJ_LastC_1CusFirstTrip(curC, i, idVeh, 0, insertCus[curC][k]->var_vioCAP, insertCus[curC][k]->var_cost, insertCus[curC][k]->var_vioTWC, insertCus[curC][k]->var_vioTWSP, cStartS);
//					insertCus[curC][k]->atIT = IT;
//				}
//			}
//		}
//		else
//		{
//			nextT = 1;
//			if (seg[idVeh].Trip[nextT].Type == 1) //idTrip is pickup, nextT is delivery
//			{
//					if (assSP == seg[idVeh].Trip[nextT].assSP) //curC is the not last pickup customer, nextTrip is delivery trip, sameSP
//					{
//							//curC now points to the last cus:
//							for (k=0; k < problem->node[curC].neighborSize; k++)
//							{
//								i = problem->node[curC].neighborNode[k].id;
//								if (problem->belong[i][assSP])
//								{
//									//cout<<"2("<<i<<", "<<assSP<<", "<<problem->belong[i][assSP]<<")"<<endl;
//									cal_InsertCusPIAfterJ_LastC_NextTripD_SameSP_1CusFirstTrip(curC, i, idVeh, 0, insertCus[curC][k]->var_vioCAP, insertCus[curC][k]->var_cost, insertCus[curC][k]->var_vioTWC, insertCus[curC][k]->var_vioTWSP);
//									insertCus[curC][k]->atIT = IT;
//								}
//							}
//					}
//					else //nextTrip is delivery trip, difSP
//					{
//						//curC now points to the last cus:
//						for (k=0; k < problem->node[curC].neighborSize; k++)
//						{
//							i = problem->node[curC].neighborNode[k].id;
//							if (problem->belong[i][assSP])
//							{
//								//cout<<"4("<<i<<", "<<assSP<<", "<<problem->belong[i][assSP]<<")"<<endl;
//								cal_InsertCusPIAfterJ_LastC_NextTripD_DifSP_1CusFirstTrip(curC, i, idVeh, 0, insertCus[curC][k]->var_vioCAP, insertCus[curC][k]->var_cost, insertCus[curC][k]->var_vioTWC, insertCus[curC][k]->var_vioTWSP);
//								insertCus[curC][k]->atIT = IT;
//							}
//						}
//					}
//			}//end idTrip is pickup, nextT is delivery trip
//			else //idTrip is pickup, nextT is (pickup OR C2C)
//			{
//				//curC now points to the last cus
//				for (k=0; k < problem->node[curC].neighborSize; k++)
//				{
//					i = problem->node[curC].neighborNode[k].id;
//					if (problem->belong[i][assSP])
//					{
//						//cout<<"6("<<i<<", "<<assSP<<", "<<problem->belong[i][assSP]<<")"<<endl;
//						cal_InsertCusPIAfterJ_LastC_NextTripPORC2C_1CusFirstTrip(curC, i, idVeh, 0, insertCus[curC][k]->var_vioCAP, insertCus[curC][k]->var_cost, insertCus[curC][k]->var_vioTWC, insertCus[curC][k]->var_vioTWSP);
//						insertCus[curC][k]->atIT = IT;
//					}
//				}
//			}//end idTrip is pickup, nextT is (pickup OR C2C)
//		}
//	}
//	else if (seg[idVeh].Trip[0].Type == 2 && seg[idVeh].Trip[0].numCus == 2)
//	{
//		nextSP = seg[idVeh].Trip[0].nextSP;
//		if (nextSP > 0)
//		{
//			idTrip1 = 1;
//       		curC = seg[idVeh].Trip[0].firstCus;
//			for (k=0; k < problem->node[curC].neighborSize; k++)
//			{
//				i = problem->node[curC].neighborNode[k].id; //for sure i is C2CP
//				if (problem->belong[i][nextSP])
//				{		
//					insertCus[curC][k]->var_cost = 0;insertCus[curC][k]->var_vioTWC = 0; insertCus[curC][k]->var_vioTWSP = 0;insertCus[curC][k]->var_vioCAP = 0;
//					SUBcal_InsertCusC2CIAfterJ_2CusFirstTrip_nextD(curC,i,idVeh,nextSP, lastT,insertCus[curC][k]->var_cost,insertCus[curC][k]->var_vioTWC, insertCus[curC][k]->var_vioTWSP,insertCus[curC][k]->var_vioCAP,insertC2CDAfter[curC][k],cStartS);
//				    insertCus[curC][k]->atIT = IT;
//				}
//			}
//			curC = seg[idVeh].Trip[0].lastCus;
//			for (k=0; k < problem->node[curC].neighborSize; k++)
//			{
//				i = problem->node[curC].neighborNode[k].id; //for sure i is C2CP
//				if (problem->belong[i][nextSP])
//				{		
//					insertCus[curC][k]->var_cost = 0;insertCus[curC][k]->var_vioTWC = 0; insertCus[curC][k]->var_vioTWSP = 0;insertCus[curC][k]->var_vioCAP = 0;
//					SUBcal_InsertCusC2CIAfterJ_2CusFirstTrip_nextD(curC,i,idVeh,nextSP, lastT,insertCus[curC][k]->var_cost,insertCus[curC][k]->var_vioTWC, insertCus[curC][k]->var_vioTWSP,insertCus[curC][k]->var_vioCAP,insertC2CDAfter[curC][k],cStartS);
//				    insertCus[curC][k]->atIT = IT;
//				}
//			}
//		}
//	}
//
//	for (idTrip = idTrip1;idTrip < lastT;idTrip++)
//	{
//		curC = seg[idVeh].Trip[idTrip].firstCus;
//		nextC = nextArr[curC];
//		nextT = idTrip + 1;
//		if (seg[idVeh].Trip[idTrip].Type == 1)
//		{
//			if (seg[idVeh].Trip[nextT].Type == 1) //idTrip is delivery trip, nextT is delivery trip
//			{
//				//cout<<idTrip<<"; caseDD"<<endl;
//				while (nextC > 0)
//				{
//					for (k=0; k < problem->node[curC].neighborSize; k++)
//					{
//						if (nextArr[curC] != problem->node[curC].neighborNode[k].id)
//						{
//							//calculate: insert neighbor #k after curC:
//							cal_InsertCusDIAfterJ_NotLastC_NextTripD(curC, k, idVeh, idTrip);
//						}
//						//else //neighbor k is already after curC 
//					}
//					curC = nextC; nextC = nextArr[curC];
//				}
//				//curC now points to the last cus of delivery trip, nextT is delivery trip
//				for (k=0; k < problem->node[curC].neighborSize; k++)
//					cal_InsertCusDIAfterJ_LastC_NextTripD(curC, k, idVeh, idTrip);
//			}
//			else //idTrip is delivery trip, nextT is (pickup trip OR C2C)
//			{
//				//cout<<idTrip<<"; caseDP"<<endl;
//				while (nextC > 0)
//				{
//					for (k=0; k < problem->node[curC].neighborSize; k++)
//					{
//						if (nextArr[curC] != problem->node[curC].neighborNode[k].id)
//						{
//							//calculate: insert neighbor #k after curC:
//							cal_InsertCusDIAfterJ_NotLastC_NextTripP_OR_C2C(curC,k,idVeh, idTrip);
//						}
//						//else //neighbor k is already after curC
//					}
//					curC = nextC; nextC = nextArr[curC];
//				}
//				//curC now points to the last cus
//				for (k=0; k < problem->node[curC].neighborSize; k++)
//					cal_InsertCusDIAfterJ_LastC_NextTripP_OR_C2C(curC,k,idVeh, idTrip);
//			}//end idTrip is delivery trip, nextT is pickup trip
//		}
//		else if (seg[idVeh].Trip[idTrip].Type == 0) //idTrip is pickup trip
//		{
//			    int assSP = seg[idVeh].Trip[idTrip].assSP;
//				if (seg[idVeh].Trip[nextT].Type == 1) //idTrip is pickup, nextT is delivery
//				{
//						if (assSP == seg[idVeh].Trip[nextT].assSP) //curC is the not last pickup customer, nextTrip is delivery trip, sameSP
//						{
//								while (nextC > 0)
//								{
//									for (k=0; k < problem->node[curC].neighborSize; k++)
//									{
//										i = problem->node[curC].neighborNode[k].id;
//										if (problem->belong[i][assSP])
//											if (nextArr[curC] != i)
//											{
//											   //cout<<"1("<<i<<", "<<assSP<<", "<<problem->belong[i][assSP]<<")"<<endl;
//											   cal_InsertCusPIAfterJ_NotLastC_NextTripD_SameSP_Start(curC, i, idVeh, idTrip, insertCus[curC][k]->var_vioCAP, insertCus[curC][k]->var_cost, insertCus[curC][k]->var_vioTWC, insertCus[curC][k]->var_vioTWSP);
//											   insertCus[curC][k]->atIT = IT;
//											}
//										//else //neighbor k is already after curC
//									}
//									curC = nextC; nextC = nextArr[curC];
//								}
//								//curC now points to the last cus:
//								for (k=0; k < problem->node[curC].neighborSize; k++)
//								{
//									i = problem->node[curC].neighborNode[k].id;
//									if (problem->belong[i][assSP])
//									{
//										//cout<<"2("<<i<<", "<<assSP<<", "<<problem->belong[i][assSP]<<")"<<endl;
//										cal_InsertCusPIAfterJ_LastC_NextTripD_SameSP_Start(curC, i, idVeh, idTrip, insertCus[curC][k]->var_vioCAP, insertCus[curC][k]->var_cost, insertCus[curC][k]->var_vioTWC, insertCus[curC][k]->var_vioTWSP);
//										insertCus[curC][k]->atIT = IT;
//									}
//								}
//						}
//						else //curC is not the last pickup customer, nextTrip is delivery trip, difSP
//						{
//							//cout<<idTrip<<"; casePD-DifSP"<<endl;
//							while (nextC > 0)
//							{
//								for (k=0; k < problem->node[curC].neighborSize; k++)
//								{
//									i = problem->node[curC].neighborNode[k].id;
//									if (problem->belong[i][assSP])
//										if (nextArr[curC] != i)
//										{
//											//cout<<"3("<<i<<", "<<assSP<<", "<<problem->belong[i][assSP]<<")"<<endl;
//										   cal_InsertCusPIAfterJ_NotLastC_NextTripD_DifSP_Start(curC, i, idVeh, idTrip, insertCus[curC][k]->var_vioCAP, insertCus[curC][k]->var_cost, insertCus[curC][k]->var_vioTWC, insertCus[curC][k]->var_vioTWSP);
//										   insertCus[curC][k]->atIT = IT;
//										}
//									//else //neighbor k is already after curC
//								}
//								curC = nextC; nextC = nextArr[curC];
//							}
//							//curC now points to the last cus:
//							for (k=0; k < problem->node[curC].neighborSize; k++)
//							{
//								i = problem->node[curC].neighborNode[k].id;
//								if (problem->belong[i][assSP])
//								{
//									//cout<<"4("<<i<<", "<<assSP<<", "<<problem->belong[i][assSP]<<")"<<endl;
//									cal_InsertCusPIAfterJ_LastC_NextTripD_DifSP_Start(curC, i, idVeh, idTrip, insertCus[curC][k]->var_vioCAP, insertCus[curC][k]->var_cost, insertCus[curC][k]->var_vioTWC, insertCus[curC][k]->var_vioTWSP);
//									insertCus[curC][k]->atIT = IT;
//								}
//							}
//						}
//				}//end idTrip is pickup, nextT is delivery trip
//				else //idTrip is pickup, nextT is (pickup OR C2C)
//				{
//					//cout<<idTrip<<"; casePP"<<endl;
//					while (nextC > 0)
//					{
//						for (k=0; k < problem->node[curC].neighborSize; k++)
//						{
//							i = problem->node[curC].neighborNode[k].id;
//							if (problem->belong[i][assSP])
//								if (nextArr[curC] != i)
//								{
//									//cout<<"5("<<i<<", "<<assSP<<", "<<problem->belong[i][assSP]<<")"<<endl;
//								   cal_InsertCusPIAfterJ_NotLastC_NextTripPORC2C_Start(curC, i, idVeh, idTrip, insertCus[curC][k]->var_vioCAP, insertCus[curC][k]->var_cost, insertCus[curC][k]->var_vioTWC, insertCus[curC][k]->var_vioTWSP);
//								   insertCus[curC][k]->atIT = IT;
//								}
//								//else //neighbor k is already after curC
//						}
//						curC = nextC; nextC = nextArr[curC];
//					}
//					//curC now points to the last cus
//					for (k=0; k < problem->node[curC].neighborSize; k++)
//					{
//						i = problem->node[curC].neighborNode[k].id;
//						if (problem->belong[i][assSP])
//						{
//							//cout<<"6("<<i<<", "<<assSP<<", "<<problem->belong[i][assSP]<<")"<<endl;
//							cal_InsertCusPIAfterJ_LastC_NextTripPORC2C_Start(curC, i, idVeh, idTrip, insertCus[curC][k]->var_vioCAP, insertCus[curC][k]->var_cost, insertCus[curC][k]->var_vioTWC, insertCus[curC][k]->var_vioTWSP);
//							insertCus[curC][k]->atIT = IT;
//						}
//					}
//				}//end idTrip is pickup, nextT is (pickup OR C2C)
//		}//idTrip is pickup trip
//		else //idTrip is C2C; not last trip
//		{
//			if (seg[idVeh].Trip[nextT].Type == 1)
//			{
//				nextSP = seg[idVeh].Trip[idTrip].nextSP;
//				while (nextC > 0) //nextT is DTrip
//				{
//					for (k=0; k < problem->node[curC].neighborSize; k++)
//					{
//						i = problem->node[curC].neighborNode[k].id;
//						if (nextArr[curC] != i && problem->belong[i][nextSP])
//						{
//							insertCus[curC][k]->atIT = IT;
//						    SUBcal_InsertCusC2CIAfterJ_NotLastC_NextD(depart[curC],CAPCus[curC],curC,i,idVeh,idTrip,nextSP,insertCus[curC][k]->var_cost,insertCus[curC][k]->var_vioTWC, insertCus[curC][k]->var_vioTWSP, insertCus[curC][k]->var_vioCAP, insertAfter);
//							insertC2CDAfter[curC][k] = insertAfter;
//							//cout<<"("<<curC<<", "<<i<<") = "<<insertC2CDAfter[curC][k]<<endl; 
//						}
//						//else //neighbor k is already after curC
//					}
//					curC = nextC; nextC = nextArr[curC];
//				}//end while (nextC > 0) //nextT is DTrip
//				//curC now points to the last cus (nextT is DTrip):
//				for (k=0; k < problem->node[curC].neighborSize; k++)
//				{
//					i = problem->node[curC].neighborNode[k].id;
//					if (nextArr[curC] != i)
//						if (problem->belong[i][nextSP])
//						{
//							insertCus[curC][k]->var_cost = 0;
//							insertCus[curC][k]->var_vioTWSP = 0;
//							insertCus[curC][k]->var_vioTWC = 0;
//							cal_InsertCusC2CIAfterJ_LastC_NextD(depart[curC],curC, i, idVeh, idTrip,nextSP,insertCus[curC][k]->var_cost,insertCus[curC][k]->var_vioTWC, insertCus[curC][k]->var_vioTWSP);
//							insertCus[curC][k]->var_vioCAP = 0;
//							insertC2CDAfter[curC][k] = i;
//							insertCus[curC][k]->atIT = IT;
//							//cout<<"("<<curC<<", "<<i<<") = "<<insertC2CDAfter[curC][k]<<endl; 
//						}
//					//else //neighbor k is already after curC
//				}
//			}
//			else if (seg[idVeh].Trip[nextT].Type == 0)
//			{
//				nextSP = seg[idVeh].Trip[nextT].nextSP;
//				while (nextC > 0) //nextT is Ptrip
//				{
//					for (k=0; k < problem->node[curC].neighborSize; k++)
//					{
//						i = problem->node[curC].neighborNode[k].id;
//						if (nextArr[curC] != i && problem->belong[i][nextSP])
//						{
//							insertCus[curC][k]->atIT = IT;
//							SUBcal_InsertCusC2CIAfterJ_NotLastC_NextTripPORC2C(depart[curC],CAPCus[curC],curC,i,idVeh,idTrip,insertCus[curC][k]->var_cost,insertCus[curC][k]->var_vioTWC, insertCus[curC][k]->var_vioTWSP, insertCus[curC][k]->var_vioCAP, insertAfter);
//							insertC2CDAfter[curC][k] = insertAfter;
//							//cout<<"("<<curC<<", "<<i<<") = "<<insertC2CDAfter[curC][k]<<endl; 
//						}
//						//else //neighbor k is already after curC
//					}
//					curC = nextC; nextC = nextArr[curC];
//				}//end while (nextC > 0) //nextT is Ptrip
//				//curC now points to the last cus (nextT is PTrip):
//				for (k=0; k < problem->node[curC].neighborSize; k++)
//				{
//					i = problem->node[curC].neighborNode[k].id;
//					if (nextArr[curC] != i && problem->belong[i][nextSP])
//					{
//						insertCus[curC][k]->var_cost = 0;insertCus[curC][k]->var_vioTWSP = 0;insertCus[curC][k]->var_vioTWC = 0;
//						cal_InsertCusC2CIAfterJ_LastC_NextTripPORC2C(depart[curC],curC,i,idVeh, idTrip,insertCus[curC][k]->var_cost,insertCus[curC][k]->var_vioTWC,insertCus[curC][k]->var_vioTWSP);
//						insertCus[curC][k]->var_vioCAP = 0;
//						insertC2CDAfter[curC][k] = i;
//						insertCus[curC][k]->atIT = IT;
//						//cout<<"("<<curC<<", "<<i<<") = "<<insertC2CDAfter[curC][k]<<endl; 
//					}
//					//else //neighbor k is already after curC
//				}
//			}
//			else //nextT is C2C
//			{
//				while (nextC > 0) //nextT is c2cTrip
//				{
//					for (k=0; k < problem->node[curC].neighborSize; k++)
//					{
//						i = problem->node[curC].neighborNode[k].id;
//						if (nextArr[curC] != i)
//						{
//							insertCus[curC][k]->atIT = IT;
//							SUBcal_InsertCusC2CIAfterJ_NotLastC_NextTripPORC2C(depart[curC],CAPCus[curC],curC,i,idVeh,idTrip,insertCus[curC][k]->var_cost,insertCus[curC][k]->var_vioTWC, insertCus[curC][k]->var_vioTWSP, insertCus[curC][k]->var_vioCAP, insertAfter);
//							insertC2CDAfter[curC][k] = insertAfter;
//							//cout<<"("<<curC<<", "<<i<<") = "<<insertC2CDAfter[curC][k]<<endl; 
//						}
//						//else //neighbor k is already after curC
//					}
//					curC = nextC; nextC = nextArr[curC];
//				}//end while (nextC > 0) //nextT is c2cTrip
//				//curC now points to the last cus (nextT is C2CTrip):
//				for (k=0; k < problem->node[curC].neighborSize; k++)
//				{
//					i = problem->node[curC].neighborNode[k].id;
//					if (nextArr[curC] != i)
//					{
//						insertCus[curC][k]->var_cost = 0;insertCus[curC][k]->var_vioTWSP = 0;insertCus[curC][k]->var_vioTWC = 0;
//						cal_InsertCusC2CIAfterJ_LastC_NextTripPORC2C(depart[curC],curC,i,idVeh, idTrip,insertCus[curC][k]->var_cost,insertCus[curC][k]->var_vioTWC,insertCus[curC][k]->var_vioTWSP);
//						insertCus[curC][k]->var_vioCAP = 0;
//						insertC2CDAfter[curC][k] = i;
//						insertCus[curC][k]->atIT = IT;
//						//cout<<"("<<curC<<", "<<i<<") = "<<insertC2CDAfter[curC][k]<<endl; 
//					}
//					//else //neighbor k is already after curC
//				}
//			}//end nextT is c2c
//		}//end idTrip is c2c; not last trip
//	}
//
//	if (doit)
//	{
//		curC = seg[idVeh].Trip[lastT].firstCus;
//		nextC = nextArr[curC];
//		if (seg[idVeh].Trip[lastT].Type == 1) //LAST TRIP IS delivery trip
//		{
//			//cout<<idTrip<<"; caseLastDT"<<endl;
//			while (nextC > 0)
//			{
//				for (k=0; k < problem->node[curC].neighborSize; k++)
//				{
//					if (nextArr[curC] != problem->node[curC].neighborNode[k].id)
//					{
//						//calculate: insert neighbor #k after curC:
//						cal_InsertCusDIAfterJ_NotLastC_LastTrip(curC, k, idVeh, lastT);
//					}
//					//else //neighbor #k is already after curC 
//				}
//				curC = nextC; nextC = nextArr[curC];
//			}
//			//curC now points to the last cus:
//			for (k=0; k < problem->node[curC].neighborSize; k++)
//				cal_InsertCusDIAfterJ_LastC_LastTrip(curC, k, idVeh, lastT);
//		}
//		else if (seg[idVeh].Trip[lastT].Type == 0) //LAST TRIP IS pickup trip:
//		{
//			//cout<<idTrip<<"; casePT"<<endl;
//			int assSP = seg[idVeh].Trip[lastT].assSP;
//			while (nextC > 0)
//			{
//				for (k=0; k < problem->node[curC].neighborSize; k++)
//				{
//					i = problem->node[curC].neighborNode[k].id;
//					if (problem->belong[i][assSP])
//						if (nextArr[curC] != i)
//						{
//							//cout<<"7("<<i<<", "<<assSP<<", "<<problem->belong[i][assSP]<<")"<<endl;
//							SUBcal_InsertCusPIAfterJ_NotLastC(curC, i, idVeh, lastT, insertCus[curC][k]->var_vioCAP, insertCus[curC][k]->var_cost, insertCus[curC][k]->var_vioTWC, insertCus[curC][k]->var_vioTWSP, cStartS);
//							insertCus[curC][k]->atIT = IT;
//						}
//						//else //neighbor k is already after curC
//				}
//				curC = nextC; nextC = nextArr[curC];
//			}
//			//curC now points to the last cus:
//			for (k=0; k < problem->node[curC].neighborSize; k++)
//			{
//				i = problem->node[curC].neighborNode[k].id;
//				if (problem->belong[i][assSP])
//				{		
//					//cout<<"8("<<i<<", "<<assSP<<", "<<problem->belong[i][assSP]<<")"<<endl;
//					SUBcal_InsertCusPIAfterJ_LastC(curC, i, idVeh, lastT, insertCus[curC][k]->var_vioCAP, insertCus[curC][k]->var_cost, insertCus[curC][k]->var_vioTWC, insertCus[curC][k]->var_vioTWSP, cStartS);
//					insertCus[curC][k]->atIT = IT;
//				}
//			}
//		}//end LAST TRIP IS pickup trip
//		else //last trip is c2c
//		{
//			while (nextC > 0) //not last cus, but last trip
//			{
//				for (k=0; k < problem->node[curC].neighborSize; k++)
//				{
//					i = problem->node[curC].neighborNode[k].id;
//					if (nextArr[curC] != i)
//					{
//						insertCus[curC][k]->atIT = IT;
//						insertCus[curC][k]->var_vioTWSP = 0;
//						SUBcal_InsertCusC2CIAfterJ_NotLastC_LastTrip(depart[curC],CAPCus[curC],curC,i,idVeh,idTrip,insertCus[curC][k]->var_cost,insertCus[curC][k]->var_vioTWC, insertCus[curC][k]->var_vioCAP,insertAfter);
//						insertC2CDAfter[curC][k] = insertAfter;
//						//cout<<"("<<curC<<", "<<i<<") = "<<insertC2CDAfter[curC][k]<<endl; 
//					}
//					//else //neighbor k is already after curC
//				}
//				curC = nextC; nextC = nextArr[curC];
//			}
//			//curC now points to the last cus: last c2ctrip
//			for (k=0; k < problem->node[curC].neighborSize; k++)
//			{
//				i = problem->node[curC].neighborNode[k].id;
//				if (nextArr[curC] != i)
//				{
//					insertCus[curC][k]->var_cost = 0;
//					insertCus[curC][k]->var_vioTWC = 0;
//					cal_InsertCusC2CIAfterJ_LastC_LastTrip(depart[curC],curC, i, idVeh, idTrip,insertCus[curC][k]->var_cost, insertCus[curC][k]->var_vioTWC);
//					
//					insertCus[curC][k]->var_vioTWSP = 0;
//					insertCus[curC][k]->var_vioCAP = 0;
//					insertC2CDAfter[curC][k] = i;
//					insertCus[curC][k]->atIT = IT;
//					//cout<<"("<<curC<<", "<<i<<") = "<<insertC2CDAfter[curC][k]<<endl; 
//				}
//				//else //neighbor k is already after curC
//			}
//		}//end lastTrip is c2c
//	}
//}

//void Solution::UpdateMoveCusOneTripArray(int idVeh)
//{
//	//see on 27/11/2013: 
//	int lastT = seg[idVeh].numTrips - 1;
//	int idTrip, nextT, curC, numC, curC1,j,j1,k, nextSP;
//	double cStartS;
//
//	for (idTrip = 0; idTrip < lastT; idTrip++)
//	{
//		nextT = idTrip + 1;
//		curC = seg[idVeh].Trip[idTrip].firstCus;
//		numC = seg[idVeh].Trip[idTrip].numCus;
//		if (seg[idVeh].Trip[idTrip].Type == 1) //idTrip is delivery trip:
//		{
//			if (seg[idVeh].Trip[nextT].Type == 1) //idTrip is delivery trip, nextTrip is delivery trip
//			{
//				for (j=1; j<numC; j++)
//				{
//					curC1 = nextArr[curC];
//					for (j1=j+2;j1<=numC;j1++)
//					{
//						curC1 = nextArr[curC1];
//						k = problem->node[curC1].neighborOF[curC];
//						if (k != -1) //node curC1 is neighbor of curC
//						{
//						   cal_MoveCusDIAfterJ_oneTrip_NextTripD(curC,k, idVeh, idTrip); //calculate: move neighbor #k after curC:
//					       //cout<<"("<<curC<<", "<<curC1<<"), ";					
//						}
//					}
//					curC1 = curC;
//					for (j1=j-1; j1>=1; j1--)
//					{
//						curC1 = predArr[curC1];
//						k = problem->node[curC1].neighborOF[curC];
//						if (k != -1) //node curC1 is neighbor of curC
//						{
//							cal_MoveCusDIAfterJ_oneTrip_NextTripD(curC,k, idVeh, idTrip); //calculate: move neighbor #k after curC:
//                           //cout<<"("<<curC<<", "<<curC1<<"), ";					
//						}
//					}
//					curC = nextArr[curC];
//				}
//				//curC now points to the last customer
//				curC1 = seg[idVeh].Trip[idTrip].firstCus;
//				for (j=1;j<numC;j++)
//				{
//					k = problem->node[curC1].neighborOF[curC];
//					if (k != -1) //node curC1 is neighbor of curC
//					{
//						cal_MoveCusDIAfterJ_oneTrip_NextTripD(curC,k, idVeh, idTrip); //calculate: move neighbor #k after curC
//                        //cout<<"("<<curC<<", "<<curC1<<"), ";					
//					}
//					curC1 = nextArr[curC1];
//				}
//			}
//			else //idTrip is delivery trip, nextTrip is (pickup trip OR C2C)
//			{
//				for (j=1; j<numC; j++)
//				{
//					curC1 = nextArr[curC];
//					for (j1=j+2;j1<=numC;j1++)
//					{
//						curC1 = nextArr[curC1];
//						k = problem->node[curC1].neighborOF[curC];
//						if (k != -1) //node curC1 is neighbor of curC
//						{
//						   cal_MoveCusDIAfterJ_oneTrip_NextTripPORC2C(curC,k, idVeh, idTrip); //calculate: move neighbor #k after curC:
//					       //cout<<"("<<curC<<", "<<curC1<<"), ";					
//						}
//					}
//					curC1 = curC;
//					for (j1=j-1; j1>=1; j1--)
//					{
//						curC1 = predArr[curC1];
//						k = problem->node[curC1].neighborOF[curC];
//						if (k != -1) //node curC1 is neighbor of curC
//						{
//						   cal_MoveCusDIAfterJ_oneTrip_NextTripPORC2C(curC,k, idVeh, idTrip); //calculate: move neighbor #k after curC:
//                           //cout<<"("<<curC<<", "<<curC1<<"), ";					
//						}
//					}
//					curC = nextArr[curC];
//				}
//				//curC now points to the last customer
//				curC1 = seg[idVeh].Trip[idTrip].firstCus;
//				for (j=1;j<numC;j++)
//				{
//					k = problem->node[curC1].neighborOF[curC];
//					if (k != -1) //node curC1 is neighbor of curC
//					{
//					   cal_MoveCusDIAfterJ_oneTrip_NextTripPORC2C(curC,k, idVeh, idTrip); //calculate: move neighbor #k after curC
//					   //cout<<"("<<curC<<", "<<curC1<<"), ";					
//					}
//					curC1 = nextArr[curC1];
//				}
//			}//end idTrip is delivery trip, nextTrip is (pickup trip OR C2C)
//		}
//		else if (seg[idVeh].Trip[idTrip].Type == 0) //idTrip is pickup trip
//		{
//			if (seg[idVeh].Trip[nextT].Type == 1)
//			{
//				if (seg[idVeh].Trip[idTrip].assSP == seg[idVeh].Trip[nextT].assSP)
//				{
//						for (j=1; j<numC; j++)
//						{
//							curC1 = nextArr[curC];
//							for (j1=j+2;j1<=numC;j1++)
//							{
//								curC1 = nextArr[curC1];
//								k = problem->node[curC1].neighborOF[curC];
//								if (k != -1) //node curC1 is neighbor of curC
//								{
//									cal_MoveCusPIAfterJ_oneTrip_NextTripD_SameSP(curC, curC1, idVeh, idTrip, moveCus[curC][k]->var_cost, moveCus[curC][k]->var_vioTWC, moveCus[curC][k]->var_vioTWSP);
//									moveCus[curC][k]->atIT = IT;
//								}
//							}
//							curC1 = curC;
//							for (j1=j-1; j1>=1; j1--)
//							{
//								curC1 = predArr[curC1];
//								k = problem->node[curC1].neighborOF[curC];
//								if (k != -1) //node curC1 is neighbor of curC
//								{
//									cal_MoveCusPIAfterJ_oneTrip_NextTripD_SameSP(curC, curC1, idVeh, idTrip, moveCus[curC][k]->var_cost, moveCus[curC][k]->var_vioTWC, moveCus[curC][k]->var_vioTWSP);
//									moveCus[curC][k]->atIT = IT;
//								}
//							}
//							curC = nextArr[curC];
//						}
//						//curC now points to the last customer
//						curC1 = seg[idVeh].Trip[idTrip].firstCus;
//						for (j=1;j<numC;j++)
//						{
//							k = problem->node[curC1].neighborOF[curC];
//							if (k != -1) //node curC1 is neighbor of curC
//							{
//								cal_MoveCusPIAfterJ_oneTrip_NextTripD_SameSP(curC, curC1, idVeh, idTrip, moveCus[curC][k]->var_cost, moveCus[curC][k]->var_vioTWC, moveCus[curC][k]->var_vioTWSP);
//								moveCus[curC][k]->atIT = IT;
//							}
//							curC1 = nextArr[curC1];
//						}
//
//				}
//				else //idTrip is pickup, nextTrip is delivery, dif sp
//				{
//						for (j=1; j<numC; j++)
//						{
//							curC1 = nextArr[curC];
//							for (j1=j+2;j1<=numC;j1++)
//							{
//								curC1 = nextArr[curC1];
//								k = problem->node[curC1].neighborOF[curC];
//								if (k != -1) //node curC1 is neighbor of curC
//								{
//									cal_MoveCusPIAfterJ_oneTrip_NextTripD_DifSP(curC, curC1, idVeh, idTrip, moveCus[curC][k]->var_cost, moveCus[curC][k]->var_vioTWC, moveCus[curC][k]->var_vioTWSP);
//									moveCus[curC][k]->atIT = IT;
//								}
//							}
//							curC1 = curC;
//							for (j1=j-1; j1>=1; j1--)
//							{
//								curC1 = predArr[curC1];
//								k = problem->node[curC1].neighborOF[curC];
//								if (k != -1) //node curC1 is neighbor of curC
//								{
//									cal_MoveCusPIAfterJ_oneTrip_NextTripD_DifSP(curC, curC1, idVeh, idTrip, moveCus[curC][k]->var_cost, moveCus[curC][k]->var_vioTWC, moveCus[curC][k]->var_vioTWSP);
//									moveCus[curC][k]->atIT = IT;
//								}
//							}
//							curC = nextArr[curC];
//						}
//						//curC now points to the last customer
//						curC1 = seg[idVeh].Trip[idTrip].firstCus;
//						for (j=1;j<numC;j++)
//						{
//							k = problem->node[curC1].neighborOF[curC];
//							if (k != -1) //node curC1 is neighbor of curC
//							{
//								cal_MoveCusPIAfterJ_oneTrip_NextTripD_DifSP(curC, curC1, idVeh, idTrip, moveCus[curC][k]->var_cost, moveCus[curC][k]->var_vioTWC, moveCus[curC][k]->var_vioTWSP);
//                                moveCus[curC][k]->atIT = IT;
//							}
//							curC1 = nextArr[curC1];
//						}
//				}//end idTrip is pickup, nextTrip is delivery, dif sp
//			}
//			else //idTrip is pickup, nextT is (pickup OR C2C)
//			{
//				for (j=1; j<numC; j++)
//				{
//					curC1 = nextArr[curC];
//					for (j1=j+2;j1<=numC;j1++)
//					{
//						curC1 = nextArr[curC1];
//						k = problem->node[curC1].neighborOF[curC];
//						if (k != -1) //node curC1 is neighbor of curC
//						{
//							cal_MoveCusPIAfterJ_oneTrip_NextTripPORC2C(curC, curC1, idVeh, idTrip, moveCus[curC][k]->var_cost, moveCus[curC][k]->var_vioTWC, moveCus[curC][k]->var_vioTWSP);
//					        moveCus[curC][k]->atIT = IT;
//						}
//					}
//
//					curC1 = curC;
//					for (j1=j-1; j1>=1; j1--)
//					{
//						curC1 = predArr[curC1];
//						k = problem->node[curC1].neighborOF[curC];
//						if (k != -1) //node curC1 is neighbor of curC
//						{
//							cal_MoveCusPIAfterJ_oneTrip_NextTripPORC2C(curC, curC1, idVeh, idTrip, moveCus[curC][k]->var_cost, moveCus[curC][k]->var_vioTWC, moveCus[curC][k]->var_vioTWSP);
//						    moveCus[curC][k]->atIT = IT;
//						}
//					}
//					curC = nextArr[curC];
//				}
//				//curC now points to the last customer
//				curC1 = seg[idVeh].Trip[idTrip].firstCus;
//				for (j=1;j<numC;j++)
//				{
//					k = problem->node[curC1].neighborOF[curC];
//					if (k != -1) //node curC1 is neighbor of curC
//					{
//						cal_MoveCusPIAfterJ_oneTrip_NextTripPORC2C(curC, curC1, idVeh, idTrip, moveCus[curC][k]->var_cost, moveCus[curC][k]->var_vioTWC, moveCus[curC][k]->var_vioTWSP);
//						moveCus[curC][k]->atIT = IT;
//					}
//					curC1 = nextArr[curC1];
//				}
//			}//end idTrip is pickup, nextT is (pickup OR C2C)
//		}//end idTrip is pickup trip
//		else //idTrip is c2c trip; not lastT
//		{
//			nextSP = seg[idVeh].Trip[idTrip].nextSP;
//			if (nextSP > 0) //nextT is DTrip
//			{
//					for (j=1; j<numC; j++)
//					{
//						curC1 = nextArr[curC];
//						for (j1=j+2;j1<=numC;j1++)
//						{
//							curC1 = nextArr[curC1];
//							if (curC1 <= problem->endidC2CP) //curC1 is c2cP
//							{
//								k = problem->node[curC1].neighborOF[curC];
//								if (k != -1) //node curC1 is neighbor of curC
//								{
//									moveCus[curC][k]->var_cost = 0;
//									moveCus[curC][k]->var_vioCAP = 0;
//									moveCus[curC][k]->var_vioTWC = 0;
//									moveCus[curC][k]->var_vioTWSP = 0;
//									cal_MoveCusC2CIAfterJ_oneTrip_NotLastC_nextD(curC,curC1,idVeh,idTrip,nextSP,moveCus[curC][k]->var_cost,moveCus[curC][k]->var_vioTWC,moveCus[curC][k]->var_vioTWSP,moveCus[curC][k]->var_vioCAP,moveC2CDAfter[curC][k]);
//									moveCus[curC][k]->atIT = IT; 
//								}
//							}
//						}
//						curC1 = curC;
//						for (j1=j-1; j1>=1; j1--)
//						{
//							curC1 = predArr[curC1];
//							if (curC1 <= problem->endidC2CP) //curC1 is c2cP
//							{
//								k = problem->node[curC1].neighborOF[curC];
//								if (k != -1) //node curC1 is neighbor of curC
//								{
//									moveCus[curC][k]->var_cost = 0;
//									moveCus[curC][k]->var_vioCAP = 0;
//									moveCus[curC][k]->var_vioTWC = 0;
//									moveCus[curC][k]->var_vioTWSP = 0;
//									cal_MoveCusC2CIAfterJ_oneTrip_NotLastC_nextD(curC,curC1,idVeh,idTrip,nextSP,moveCus[curC][k]->var_cost,moveCus[curC][k]->var_vioTWC,moveCus[curC][k]->var_vioTWSP,moveCus[curC][k]->var_vioCAP,moveC2CDAfter[curC][k]);
//									moveCus[curC][k]->atIT = IT; 
//								}
//							}
//						}
//						curC = nextArr[curC];
//					}
//					//curC now points to the last customer
//					curC1 = seg[idVeh].Trip[idTrip].firstCus;
//					for (j=1;j<numC;j++)
//					{
//						if (curC1 <= problem->endidC2CP) //curC1 is c2cP
//						{
//							k = problem->node[curC1].neighborOF[curC];
//							if (k != -1) //node curC1 is neighbor of curC
//							{
//							   cal_MoveCusC2CIAfterJ_oneTrip_LastC(curC, curC1, k, idVeh, idTrip); //14/12/2013
//							}
//						}
//						curC1 = nextArr[curC1];
//					}
//			}
//			else //nextT is PTrip OR C2CTrip
//			{
//					for (j=1; j<numC; j++)
//					{
//						curC1 = nextArr[curC];
//						for (j1=j+2;j1<=numC;j1++)
//						{
//							curC1 = nextArr[curC1];
//							if (curC1 <= problem->endidC2CP) //curC1 is c2cP
//							{
//								k = problem->node[curC1].neighborOF[curC];
//								if (k != -1) //node curC1 is neighbor of curC
//								{
//									moveCus[curC][k]->var_cost = 0;
//									moveCus[curC][k]->var_vioCAP = 0;
//									moveCus[curC][k]->var_vioTWC = 0;
//									moveCus[curC][k]->var_vioTWSP = 0;
//									//cout<<"cal_MoveCusC2CIAfterJ_oneTrip_NotLastC_NextTripPORC2C"<<endl;
//									cal_MoveCusC2CIAfterJ_oneTrip_NotLastC_NextTripPORC2C(curC,curC1,idVeh,idTrip,moveCus[curC][k]->var_cost,moveCus[curC][k]->var_vioTWC, moveCus[curC][k]->var_vioTWSP,moveCus[curC][k]->var_vioCAP, moveC2CDAfter[curC][k]); 
//									moveCus[curC][k]->atIT = IT; 
//								}
//							}
//						}
//						curC1 = curC;
//						for (j1=j-1; j1>=1; j1--)
//						{
//							curC1 = predArr[curC1];
//							if (curC1 <= problem->endidC2CP) //curC1 is c2cP
//							{
//								k = problem->node[curC1].neighborOF[curC];
//								if (k != -1) //node curC1 is neighbor of curC
//								{
//									moveCus[curC][k]->var_cost = 0;
//									moveCus[curC][k]->var_vioCAP = 0;
//									moveCus[curC][k]->var_vioTWC = 0;
//									moveCus[curC][k]->var_vioTWSP = 0;
//									//cout<<"cal_MoveCusC2CIAfterJ_oneTrip_NotLastC_NextTripPORC2C"<<endl;
//									cal_MoveCusC2CIAfterJ_oneTrip_NotLastC_NextTripPORC2C(curC,curC1,idVeh,idTrip,moveCus[curC][k]->var_cost,moveCus[curC][k]->var_vioTWC, moveCus[curC][k]->var_vioTWSP,moveCus[curC][k]->var_vioCAP, moveC2CDAfter[curC][k]); 
//									moveCus[curC][k]->atIT = IT; 
//								}
//							}
//						}
//						curC = nextArr[curC];
//					}
//					//curC now points to the last customer; nextT is PTrip
//					curC1 = seg[idVeh].Trip[idTrip].firstCus;
//					for (j=1;j<numC;j++)
//					{
//						if (curC1 <= problem->endidC2CP) //curC1 is c2cP
//						{
//							k = problem->node[curC1].neighborOF[curC];
//							if (k != -1) //node curC1 is neighbor of curC
//							{
//							   cal_MoveCusC2CIAfterJ_oneTrip_LastC(curC, curC1, k, idVeh, idTrip); //14/12/2013
//							}
//						}
//						curC1 = nextArr[curC1];
//					}
//			}//end nextT is PTrip OR C2CTrip
//		}//end idTrip is c2c trip
//	}
//
//	//lastTrip:
//		curC = seg[idVeh].Trip[lastT].firstCus;
//		numC = seg[idVeh].Trip[lastT].numCus;
//		if (seg[idVeh].Trip[lastT].Type == 1)
//		{
//			for (j=1; j<numC; j++)
//			{
//				curC1 = nextArr[curC];
//				for (j1=j+2;j1<=numC;j1++)
//				{
//					curC1 = nextArr[curC1];
//					k = problem->node[curC1].neighborOF[curC];
//					if (k != -1) //node curC1 is neighbor of curC
//					   cal_MoveCusDIAfterJ_oneTrip_LastTrip(curC, k, idVeh, idTrip); //calculate: move neighbor #k after curC:
//				}
//				curC1 = curC;
//				for (j1=j-1; j1>=1; j1--)
//				{
//					curC1 = predArr[curC1];
//					k = problem->node[curC1].neighborOF[curC];
//					if (k != -1) //node curC1 is neighbor of curC
//					   cal_MoveCusDIAfterJ_oneTrip_LastTrip(curC, k, idVeh, idTrip); //calculate: move neighbor #k after curC:
//				}
//				curC = nextArr[curC];
//			}
//			//curC now points to the last customer
//			curC1 = seg[idVeh].Trip[idTrip].firstCus;
//			for (j=1;j<numC;j++)
//			{
//				k = problem->node[curC1].neighborOF[curC];
//				if (k != -1) //node curC1 is neighbor of curC
//				   cal_MoveCusDIAfterJ_oneTrip_LastTrip(curC, k, idVeh, idTrip); //calculate: move neighbor #k after curC:
//				curC1 = nextArr[curC1];
//			}
//		}
//		else if (seg[idVeh].Trip[lastT].Type == 0)//lastT is pickup trip
//		{
//			for (j=1; j<numC; j++)
//			{
//				curC1 = nextArr[curC];
//				for (j1=j+2;j1<=numC;j1++)
//				{
//					curC1 = nextArr[curC1];
//					k = problem->node[curC1].neighborOF[curC];
//					if (k != -1) //node curC1 is neighbor of curC
//					{
//						cal_MoveCusPIAfterJ_oneTrip_LastTrip(curC, curC1, idVeh, idTrip, moveCus[curC][k]->var_cost, moveCus[curC][k]->var_vioTWC, moveCus[curC][k]->var_vioTWSP, cStartS);
//						moveCus[curC][k]->atIT = IT;
//					}
//				}
//				curC1 = curC;
//				for (j1=j-1; j1>=1; j1--)
//				{
//					curC1 = predArr[curC1];
//					k = problem->node[curC1].neighborOF[curC];
//					if (k != -1) //node curC1 is neighbor of curC
//					{
//						cal_MoveCusPIAfterJ_oneTrip_LastTrip(curC, curC1, idVeh, idTrip, moveCus[curC][k]->var_cost, moveCus[curC][k]->var_vioTWC, moveCus[curC][k]->var_vioTWSP, cStartS);
//						moveCus[curC][k]->atIT = IT;
//					}
//				}
//				curC = nextArr[curC];
//			}
//			//curC now points to the last customer
//			curC1 = seg[idVeh].Trip[idTrip].firstCus;
//			for (j=1;j<numC;j++)
//			{
//				k = problem->node[curC1].neighborOF[curC];
//				if (k != -1) //node curC1 is neighbor of curC
//				{
//					cal_MoveCusPIAfterJ_oneTrip_LastTrip(curC, curC1, idVeh, idTrip, moveCus[curC][k]->var_cost, moveCus[curC][k]->var_vioTWC, moveCus[curC][k]->var_vioTWSP, cStartS);
//					moveCus[curC][k]->atIT = IT;
//				}
//				curC1 = nextArr[curC1];
//			}
//		}//end lastT is pickup trip
//		else //lastT is c2cTrip
//		{
//			for (j=1; j<numC; j++)
//			{
//				curC1 = nextArr[curC];
//				for (j1=j+2;j1<=numC;j1++)
//				{
//					curC1 = nextArr[curC1];
//					if (curC1 <= problem->endidC2CP) //curC1 is c2cP
//					{
//						k = problem->node[curC1].neighborOF[curC];
//						if (k != -1) //node curC1 is neighbor of curC
//						{
//							moveCus[curC][k]->var_cost = 0;
//							moveCus[curC][k]->var_vioCAP = 0;
//							moveCus[curC][k]->var_vioTWC = 0;
//							//cout<<"cal_MoveCusC2CIAfterJ_oneTrip_LastTrip_NotLastC"<<endl;
//							cal_MoveCusC2CIAfterJ_oneTrip_LastTrip_NotLastC(curC,curC1,idVeh,idTrip,moveCus[curC][k]->var_cost,moveCus[curC][k]->var_vioTWC, moveCus[curC][k]->var_vioCAP, moveC2CDAfter[curC][k]); //14/12/2013
//							moveCus[curC][k]->var_vioTWSP = 0;
//							moveCus[curC][k]->atIT = IT;  
//						}
//					}
//				}
//				curC1 = curC;
//				for (j1=j-1; j1>=1; j1--)
//				{
//					curC1 = predArr[curC1];
//					if (curC1 <= problem->endidC2CP) //curC1 is c2cP
//					{
//						k = problem->node[curC1].neighborOF[curC];
//						if (k != -1) //node curC1 is neighbor of curC
//						{
//							moveCus[curC][k]->var_cost = 0;
//							moveCus[curC][k]->var_vioCAP = 0;
//							moveCus[curC][k]->var_vioTWC = 0;
//							//cout<<"cal_MoveCusC2CIAfterJ_oneTrip_LastTrip_NotLastC"<<endl;
//							cal_MoveCusC2CIAfterJ_oneTrip_LastTrip_NotLastC(curC,curC1,idVeh,idTrip,moveCus[curC][k]->var_cost,moveCus[curC][k]->var_vioTWC, moveCus[curC][k]->var_vioCAP, moveC2CDAfter[curC][k]); //14/12/2013
//							moveCus[curC][k]->var_vioTWSP = 0;
//							moveCus[curC][k]->atIT = IT;  
//						}
//					}
//				}
//				curC = nextArr[curC];
//			}
//			//curC now points to the last customer
//			curC1 = seg[idVeh].Trip[idTrip].firstCus;
//			for (j=1;j<numC;j++)
//			{
//				if (curC1 <= problem->endidC2CP) //curC1 is c2cP
//				{
//					k = problem->node[curC1].neighborOF[curC];
//					if (k != -1) //node curC1 is neighbor of curC
//					{
//					   cal_MoveCusC2CIAfterJ_oneTrip_LastTrip_LastC(curC, curC1, k, idVeh, idTrip);//14/12/2013
//					}
//				}
//				curC1 = nextArr[curC1];
//			}
//		}//lastT is c2cTrip
//}

//void Solution::UpdateMoveCusPOneVehArray(int idVeh)
//{
//	//see on 27/11/2013
//	int idTrip, curC,k,i, assSP;
//     for (idTrip=0;idTrip<seg[idVeh].numTrips; idTrip++)
//		 if (seg[idVeh].Trip[idTrip].Type == 0)
//		 {
//			assSP = seg[idVeh].Trip[idTrip].assSP;
//			curC = seg[idVeh].Trip[idTrip].firstCus;
//			while (curC > 0)
//			{
//				for (k=0; k < problem->node[curC].neighborSize; k++)
//				{
//					i = problem->node[curC].neighborNode[k].id;
//					if (route_num[i] == idVeh && trip_num[i] != idTrip)
//					  if (problem->belong[i][assSP])
//						{
//					       cal_MoveCusPIAfterJ_oneVeh(curC, idTrip, i, trip_num[i], idVeh, moveCus[curC][k]->var_cost, moveCus[curC][k]->var_costi, moveCus[curC][k]->var_costj, moveCus[curC][k]->var_vioTWC, moveCus[curC][k]->var_vioTWCi, moveCus[curC][k]->var_vioTWCj, moveCus[curC][k]->var_vioTWSP, moveCus[curC][k]->var_vioTWSPi, moveCus[curC][k]->var_vioTWSPj, moveCus[curC][k]->var_vioCAP);
//						   moveCus[curC][k]->atIT = IT;
//						}
//				}
//				curC = nextArr[curC];
//			}
//		 }
//}
//void Solution::UpdateMoveCusC2COneVehArray(int idVeh)
//{
//	//Update on 12/1/2014
//	int idTrip, curC, nextC, k,i, nextSP, nextT;
//	int lastT = seg[idVeh].numTrips - 1;
//     for (idTrip=0;idTrip < lastT; idTrip++)
//		 if (seg[idVeh].Trip[idTrip].Type == 2)
//		 {
//			nextSP = seg[idVeh].Trip[idTrip].nextSP;
//			if (nextSP > 0) //nextT is DTrip
//			{
//				curC = seg[idVeh].Trip[idTrip].firstCus;
//				nextC = nextArr[curC];
//				while (nextC > 0)
//				{
//					for (k=0; k < problem->node[curC].neighborSize; k++)
//					{
//						i = problem->node[curC].neighborNode[k].id;
//						if (route_num[i] == idVeh && trip_num[i] != idTrip)
//						  if (problem->belong[i][nextSP])
//							   cal_MoveCusC2CIAfterJ_oneVeh_NotLastC(curC, idTrip, i, trip_num[i], idVeh, k);
//					}
//					curC = nextC; nextC = nextArr[curC];
//				}
//				//curC now points to the lastCus: (nextT is DTrip)
//				for (k=0; k < problem->node[curC].neighborSize; k++)
//				{
//					i = problem->node[curC].neighborNode[k].id;
//					if (route_num[i] == idVeh && trip_num[i] != idTrip)
//					  if (problem->belong[i][nextSP])
//						   cal_MoveCusC2CIAfterJ_oneVeh_LastC(curC, idTrip, i, trip_num[i], idVeh,k); //14/12/2013
//				}
//			}
//			else
//			{
//				nextT = idTrip + 1;
//				if (seg[idVeh].Trip[nextT].Type == 0) //nextT is PTrip
//				{
//					curC = seg[idVeh].Trip[idTrip].firstCus;
//					nextC = nextArr[curC];
//					nextSP = seg[idVeh].Trip[nextT].assSP;
//					while (nextC > 0)
//					{
//						for (k=0; k < problem->node[curC].neighborSize; k++)
//						{
//							i = problem->node[curC].neighborNode[k].id;
//							if (route_num[i] == idVeh && trip_num[i] != idTrip)
//							  if (problem->belong[i][nextSP])
//								   cal_MoveCusC2CIAfterJ_oneVeh_NotLastC(curC, idTrip, i, trip_num[i], idVeh, k);
//						}
//						curC = nextC; nextC = nextArr[curC];
//					}
//					//curC now points to the lastCus: (nextT is DTrip)
//					for (k=0; k < problem->node[curC].neighborSize; k++)
//					{
//						i = problem->node[curC].neighborNode[k].id;
//						if (route_num[i] == idVeh && trip_num[i] != idTrip)
//						  if (problem->belong[i][nextSP])
//							   cal_MoveCusC2CIAfterJ_oneVeh_LastC(curC, idTrip, i, trip_num[i], idVeh,k); //14/12/2013
//					}
//				}
//				else //nextT is C2CTrip
//				{
//					curC = seg[idVeh].Trip[idTrip].firstCus;
//					nextC = nextArr[curC];
//					nextSP = seg[idVeh].Trip[nextT].assSP;
//					while (nextC > 0)
//					{
//						for (k=0; k < problem->node[curC].neighborSize; k++)
//						{
//							i = problem->node[curC].neighborNode[k].id;
//							if (route_num[i] == idVeh && trip_num[i] != idTrip)
//								   cal_MoveCusC2CIAfterJ_oneVeh_NotLastC(curC, idTrip, i, trip_num[i], idVeh, k);
//						}
//						curC = nextC; nextC = nextArr[curC];
//					}
//					//curC now points to the lastCus: (nextT is DTrip)
//					for (k=0; k < problem->node[curC].neighborSize; k++)
//					{
//						i = problem->node[curC].neighborNode[k].id;
//						if (route_num[i] == idVeh && trip_num[i] != idTrip)
//							   cal_MoveCusC2CIAfterJ_oneVeh_LastC(curC, idTrip, i, trip_num[i], idVeh,k); //14/12/2013
//					}
//				}//end nextT is C2CTrip
//			}
//		 }
//     //LAST TRIP:
//	 if (seg[idVeh].Trip[lastT].Type == 2)
//	 {
//		curC = seg[idVeh].Trip[lastT].firstCus;
//		nextC = nextArr[curC];
//		while (nextC > 0)
//		{
//			for (k=0; k < problem->node[curC].neighborSize; k++)
//			{
//				i = problem->node[curC].neighborNode[k].id;
//				if (route_num[i] == idVeh && trip_num[i] != lastT)
//					cal_MoveCusC2CIAfterJ_oneVeh_NotLastC(curC, lastT, i, trip_num[i], idVeh, k);
//			}
//			curC = nextC; nextC = nextArr[curC];
//		}
//		//curC now points to the lastCus: (nextT is DTrip)
//		for (k=0; k < problem->node[curC].neighborSize; k++)
//		{
//			i = problem->node[curC].neighborNode[k].id;
//			if (route_num[i] == idVeh && trip_num[i] != lastT)
//			   cal_MoveCusC2CIAfterJ_oneVeh_LastC(curC, lastT, i, trip_num[i], idVeh,k); //14/12/2013
//		}
//	 }
//
//}

//void Solution::UpdateExchangeArray(int idVeh)
//{
//	//see on 27/11/2013
//	//4th Transform: 
// 	//4.1 Exchange delivery customers:
//	//Recalculate exchange array: 1) exchangeCus[i][its neighbor] where i is in the trip
//	                            //2) exchangeCus[??][i] where i is in the trip
//
//	int curC,k, ii, kk;
//	for (int idTrip = 0; idTrip < seg[idVeh].numTrips; idTrip++)
//	{
//		curC = seg[idVeh].Trip[idTrip].firstCus;
//		if (seg[idVeh].Trip[idTrip].Type == 1)
//		{
//			while (curC > 0)
//			{
//          		for (k=0;k<problem->node[curC].neighborSize; k++)
//				{
//					//calculate: exchange customer curC and its neighbor #k:
//					cal_ExchangeCusDIAndJ(curC,k);
//					exchangeCus[curC][k]->atIT=IT;
//					ii = problem->node[curC].neighborNode[k].id; //exchange customer ii and curC
//					kk = problem->node[curC].neighborOF[ii];
//					if (kk != -1)
//					{
//						exchangeCus[ii][kk]->var_cost = exchangeCus[curC][k]->var_cost;
//						exchangeCus[ii][kk]->var_costi = exchangeCus[curC][k]->var_costi;
//						exchangeCus[ii][kk]->var_costj = exchangeCus[curC][k]->var_costj;
//						exchangeCus[ii][kk]->var_vioCAP = exchangeCus[curC][k]->var_vioCAP;
//						exchangeCus[ii][kk]->var_vioTWC = exchangeCus[curC][k]->var_vioTWC;
//						exchangeCus[ii][kk]->var_vioTWCi = exchangeCus[curC][k]->var_vioTWCi;
//						exchangeCus[ii][kk]->var_vioTWCj = exchangeCus[curC][k]->var_vioTWCj;
//						exchangeCus[ii][kk]->var_vioTWSP = exchangeCus[curC][k]->var_vioTWSP;
//						exchangeCus[ii][kk]->var_vioTWSPi = exchangeCus[curC][k]->var_vioTWSPi;
//						exchangeCus[ii][kk]->var_vioTWSPj = exchangeCus[curC][k]->var_vioTWSPj;
//						exchangeCus[ii][kk]->atIT = IT;
//						//exchangeCus[ii][kk] = exchangeCus[curC][k]; //ii is neighbor kkth of curC					
//					}
//				}
//				//2) exchangeCus[node[curC].beneighbor[#k]][curC] where curC is in the trip
//				 for (k=0; k < problem->node[curC].beNeighborSize; k++)
//				 {
//					   //calculate: exchange:
//						ii = problem->node[curC].beNeighbor[k].id;
//						kk = problem->node[curC].beNeighbor[k].at;
//						if (exchangeCus[ii][kk]->atIT != IT)
//						{
//							cal_ExchangeCusDIAndJ(ii,kk);
//							exchangeCus[ii][kk]->atIT=IT;
//						}
//				 }
//				 curC = nextArr[curC];
//			}
//		}
//		else if (seg[idVeh].Trip[idTrip].Type == 0)//(idVeh, idTrip) is pickup trip
//		{
//			int assSP = seg[idVeh].Trip[idTrip].assSP; int assSP1;
//			while (curC > 0)
//			{
//          		for (k=0;k<problem->node[curC].neighborSize; k++)
//				{
//					//calculate: exchange customer curC and its neighbor #k:
//					ii = problem->node[curC].neighborNode[k].id; //exchange customer ii and curC
//					assSP1 = seg[route_num[ii]].Trip[trip_num[ii]].assSP;
//					if (problem->belong[curC][assSP1] && problem->belong[ii][assSP])
//					{
//						cal_ExchangeCusPIAndJ(curC,k);
//						exchangeCus[curC][k]->atIT = IT;
//						//ii = problem->node[curC].neighborNode[k].id; //exchange customer ii and curC
//						kk = problem->node[curC].neighborOF[ii];
//						if (kk != -1) 
//						{
//							exchangeCus[ii][kk]->var_cost = exchangeCus[curC][k]->var_cost;
//							exchangeCus[ii][kk]->var_costi = exchangeCus[curC][k]->var_costi;
//							exchangeCus[ii][kk]->var_costj = exchangeCus[curC][k]->var_costj;
//							exchangeCus[ii][kk]->var_vioCAP = exchangeCus[curC][k]->var_vioCAP;
//							exchangeCus[ii][kk]->var_vioTWC = exchangeCus[curC][k]->var_vioTWC;
//							exchangeCus[ii][kk]->var_vioTWCi = exchangeCus[curC][k]->var_vioTWCi;
//							exchangeCus[ii][kk]->var_vioTWCj = exchangeCus[curC][k]->var_vioTWCj;
//							exchangeCus[ii][kk]->var_vioTWSP = exchangeCus[curC][k]->var_vioTWSP;
//							exchangeCus[ii][kk]->var_vioTWSPi = exchangeCus[curC][k]->var_vioTWSPi;
//							exchangeCus[ii][kk]->var_vioTWSPj = exchangeCus[curC][k]->var_vioTWSPj;
//							exchangeCus[ii][kk]->atIT = IT;
//						}
//					}
//				}
//				//2) exchangeCus[node[curC].beneighbor[#k]][curC] where curC is in the trip
//				 for (k=0; k < problem->node[curC].beNeighborSize; k++)
//				 {
//					   //calculate: exchange:
//						ii = problem->node[curC].beNeighbor[k].id;
//						assSP1 = seg[route_num[ii]].Trip[trip_num[ii]].assSP;
//						if (problem->belong[curC][assSP1] && problem->belong[ii][assSP])
//						{
//							kk = problem->node[curC].beNeighbor[k].at;
//							if (exchangeCus[ii][kk]->atIT != IT)
//							{
//								cal_ExchangeCusPIAndJ(ii,kk);
//								exchangeCus[ii][kk]->atIT=IT;
//							}
//						}
//
//				 }
//				curC = nextArr[curC];
//			}
//		}//end (idVeh, idTrip) is pickup trip
//		else //(idVeh, idTrip is C2C Trip)
//		{
//			while (curC > 0)
//			{
//				if (curC < problem->startidC2C) //curC is C2CP
//				{
//					//1) exchangeCus[nodeC2C[curC].neighborNodeExchange[#k]][curC] where curC is in the trip
//          			for (k=0;k<problem->nodeC2C[curC].neighborSizeExchange; k++)
//					{
//						//calculate: exchange customer curC and its neighbor #k:
//						ii = problem->nodeC2C[curC].neighborNodeExchange[k].id; //exchange customer ii and curC
//						cal_ExchangeCusC2CIAndJ(curC,k);
//						exchangeCus[curC][k]->atIT = IT;
//						//ii = problem->node[curC].neighborNode[k].id; //exchange customer ii and curC
//						kk = problem->nodeC2C[curC].neighborOF[ii];
//						if (kk != -1) 
//						{
//							exchangeCus[ii][kk]->var_cost = exchangeCus[curC][k]->var_cost;
//							exchangeCus[ii][kk]->var_costi = exchangeCus[curC][k]->var_costi;
//							exchangeCus[ii][kk]->var_costj = exchangeCus[curC][k]->var_costj;
//							exchangeCus[ii][kk]->var_vioCAP = exchangeCus[curC][k]->var_vioCAP;
//							exchangeCus[ii][kk]->var_vioTWC = exchangeCus[curC][k]->var_vioTWC;
//							exchangeCus[ii][kk]->var_vioTWCi = exchangeCus[curC][k]->var_vioTWCi;
//							exchangeCus[ii][kk]->var_vioTWCj = exchangeCus[curC][k]->var_vioTWCj;
//							exchangeCus[ii][kk]->var_vioTWSP = exchangeCus[curC][k]->var_vioTWSP;
//							exchangeCus[ii][kk]->var_vioTWSPi = exchangeCus[curC][k]->var_vioTWSPi;
//							exchangeCus[ii][kk]->var_vioTWSPj = exchangeCus[curC][k]->var_vioTWSPj;
//							exchangeCus[ii][kk]->atIT = IT;
//						}
//					}
//					//2) exchangeCus[nodeC2C[curC].beNeighborExchange[#k]][curC] where curC is in the trip
//					 for (k=0; k < problem->nodeC2C[curC].beNeighborSizeExchange; k++)
//					 {
//						   //calculate: exchange:
//							ii = problem->nodeC2C[curC].beNeighborExchange[k].id;
//							kk = problem->nodeC2C[curC].beNeighborExchange[k].at;
//							if (exchangeCus[ii][kk]->atIT != IT)
//							{
//								cal_ExchangeCusC2CIAndJ(ii,kk);
//								exchangeCus[ii][kk]->atIT=IT;
//							}
//					 }
//				}
//				curC = nextArr[curC];
//			}
//		}//end (idVeh, idTrip is C2C Trip)
//	}
//}


//void Solution::UpdatetwoOPTstarArray(int idVeh)
//{
//	//see on 27/11/2013
//	//5th Transform: 2opt*:
//	//5. Recalculate twoOPTstar array: 1) twoOPTstarCus[i][its neighbor] where i is in the trip
//	                                 //2) twoOPTstarCus[??][i] where i is in the trip
//
//	int nextT, startNeighbor, curC, numC,i,j,k,ii,kk,idVehii, idTripii,nextTripii;
//	int lastT = seg[idVeh].numTrips - 1;
//	
//	for (int idTrip = 0; idTrip < lastT; idTrip++)
//	{
//		nextT = idTrip + 1;
//		curC = seg[idVeh].Trip[idTrip].firstCus;
//		numC = seg[idVeh].Trip[idTrip].numCus;
//		if (seg[idVeh].Trip[idTrip].Type == 1)
//		{
//			if (seg[idVeh].Trip[nextT].Type == 1) //idTrip is delivery, nextT is delivery
//			{
//				for (j=1;j<=numC;j++)
//				{
//					for (k=0;k<problem->node[curC].neighborSize; k++)
//					{
//						  //calculate: exchange customer curC and its neighbor #k:
//						  i = problem->node[curC].neighborNode[k].id;
//						  if (idVeh != route_num[i])
//						  {
//								 cal_twoOPTstarCusDIAndJ(curC,k); //Update 12/11/2013
//						  }
//						  else 
//						  {
//							  //curC has to be placed before its neighbor #k in the current route:
//							  if (nextArr[curC]!= i)
//							  {
//								  startNeighbor = pos[i];
//								  if (j < startNeighbor)
//								  {
//									  //cout<<"1) curC = "<<curC<<"; i = "<<i<<endl;
//									  cal_twoOPTstarCusDIAndJ_oneTrip_NextTripD(curC,k);
//								  }
//							  }
//						  }
// 						  twoOPTstarCus[curC][k]->atIT = IT;
//    				}
//
//					//2. twoOPTstarCus[??][curC] where curC is in the trip
//					 for (k=0; k < problem->node[curC].beNeighborSize; k++)
//					 {
//						  //calculate: 2opt*
//						  ii = problem->node[curC].beNeighbor[k].id;
//						  kk = problem->node[curC].beNeighbor[k].at;
//						  if (twoOPTstarCus[ii][kk]->atIT != IT)
//						  {
//		  						idVehii = route_num[ii]; idTripii = trip_num[ii];
//								nextTripii = idTripii + 1;
//								twoOPTstarCus[ii][kk]->atIT = IT;
//								if (idVeh != idVehii)
//								{
//									cal_twoOPTstarCusDIAndJ(ii,kk);
//								}
//								else //same trip:
//								{
//									if (nextArr[ii] != curC)
//									{
//										startNeighbor = pos[ii];
//										if (startNeighbor < j)
//										{
//										    if (nextTripii == seg[idVehii].numTrips)
//											{
//												cal_twoOPTstarCusDIAndJ_oneTrip_LastTrip(ii, kk);
//											}
//											else if (seg[idVehii].Trip[nextTripii].Type == 1)
//											{
//												  //cout<<"2. ii = "<<ii<<"; curC = "<<curC<<endl;
//												  cal_twoOPTstarCusDIAndJ_oneTrip_NextTripD(ii, kk);
//											}
//											else
//											{
//												  cal_twoOPTstarCusDIAndJ_oneTrip_NextTripPORC2C(ii, kk);
//											}
//										}
//									}
//								}
//						  }//end if (twoOPTstarCus[ii][kk]->atIT != IT)
//					 }//end for k
//					curC = nextArr[curC];
//				}
//			}
//			else //idTrip is delivery, nextT is (pickup OR C2C)
//			{
//				for (j=1;j<=numC;j++)
//				{
//					for (k=0;k<problem->node[curC].neighborSize; k++)
//					{
//						  //calculate: exchange customer curC and its neighbor #k:
//						  i = problem->node[curC].neighborNode[k].id;
//						  if (idVeh != route_num[i])
//						  {
//								 cal_twoOPTstarCusDIAndJ(curC, k);
//						  }
//						  else 
//						  {
//							  //curC has to be placed before its neighbor #k in the current route:
//							  if (nextArr[curC] != i)
//							  {
//								  startNeighbor = pos[i];
//								  if (j < startNeighbor)
//								  {
//									  cal_twoOPTstarCusDIAndJ_oneTrip_NextTripPORC2C(curC,k);
//								  }
//							  }
//
//						  }
// 						  twoOPTstarCus[curC][k]->atIT = IT;
//    				}
//					//2. twoOPTstarCus[??][curC] where curC is in the trip
//					 for (k=0; k < problem->node[curC].beNeighborSize; k++)
//					 {
//						  //calculate: 2opt*
//						  ii = problem->node[curC].beNeighbor[k].id;
//						  kk = problem->node[curC].beNeighbor[k].at;
//						  if (twoOPTstarCus[ii][kk]->atIT != IT)
//						  {
//		  						idVehii = route_num[ii]; idTripii = trip_num[ii];
//								nextTripii = idTripii + 1;
//								twoOPTstarCus[ii][kk]->atIT = IT;
//								if (idVeh != idVehii)
//								{
//									cal_twoOPTstarCusDIAndJ(ii,kk);
//								}
//								else //same trip:
//								{
//									if (nextArr[ii] != curC)
//									{
//										startNeighbor = pos[ii];
//										if (startNeighbor < j)
//										{
//										    if (nextTripii == seg[idVehii].numTrips)
//											{
//												cal_twoOPTstarCusDIAndJ_oneTrip_LastTrip(ii, kk);
//											}
//											else if (seg[idVehii].Trip[nextTripii].Type == 1)
//											{
//												  //cout<<"3. ii = "<<ii<<"; curC = "<<curC<<endl;
//												  cal_twoOPTstarCusDIAndJ_oneTrip_NextTripD(ii, kk);
//											}
//											else
//											{
//												  cal_twoOPTstarCusDIAndJ_oneTrip_NextTripPORC2C(ii, kk);
//											}
//										}
//									}
//								}
//						  }//end if (twoOPTstarCus[ii][kk]->atIT != IT)
//					 }//end for k
//
//					curC = nextArr[curC];
//				}
//			}//end idTrip is delivery, nextT is (pickup OR C2C)
//		}
//		else if (seg[idVeh].Trip[idTrip].Type == 0)//idTrip is pickup
//		{
//			int assSP = seg[idVeh].Trip[idTrip].assSP;
//			for (j=1;j <= numC;j++)
//			{
//				for (k=0;k<problem->node[curC].neighborSize; k++)
//				{
//					  //calculate: exchange customer curC and its neighbor #k:
//					  i = problem->node[curC].neighborNode[k].id;
//					  if (assSP != seg[route_num[i]].Trip[trip_num[i]].assSP)
//						 twoOPTstarCus[curC][k]->var_vioCAP = PDS_INFINITY_INT;
//					  else
//					  {
//						  if (idVeh != route_num[i]) //dif veh, dif trip
//						  {
//							  cal_twoOPTstarCusPIAndJ(curC, k);
//						  }
//						  else //same vehicle
//						  {
//							  if (idTrip == trip_num[i]) //same trip, same vehicle
//							  {
//								  //curC has to be placed before its neighbor #k in the current route:
//								  if (pos[i] > j && nextArr[curC] != i)  cal_twoOPTstarCusPIAndJ_oneTrip(curC,k);
//								  else twoOPTstarCus[curC][k]->var_vioCAP = PDS_INFINITY_INT;
//							  }//end same trip, same vehicle
//						  }//end same vehicle
//					  }
//					  twoOPTstarCus[curC][k]->atIT = IT;
//					  //cout<<"twoOPTstarCus["<<curC<<"]["<<i<<"] = "<<twoOPTstarCus[curC][k]->var_vioCAP<<"; ";
//				}
//
//				//2. twoOPTstarCus[??][curC] where curC is in the trip
//				 for (k=0; k < problem->node[curC].beNeighborSize; k++)
//				 {
//					  //calculate: 2opt*
//					  ii = problem->node[curC].beNeighbor[k].id;
//					  kk = problem->node[curC].beNeighbor[k].at;
//					  if (twoOPTstarCus[ii][kk]->atIT != IT)
//					  {
//							twoOPTstarCus[ii][kk]->atIT = IT;
//	  						idVehii = route_num[ii]; idTripii = trip_num[ii];
//							if (assSP != seg[idVehii].Trip[idTripii].assSP)
//								twoOPTstarCus[ii][kk]->var_vioCAP = PDS_INFINITY_INT;
//							else
//							{
//								 if (idVeh != idVehii) //dif veh, dif trip
//								 {
//									 cal_twoOPTstarCusPIAndJ(ii,kk);
//	 							     //cout<<"["<<ii<<"]["<<curC<<"] = "<<twoOPTstarCus[ii][kk]->var_vioCAP<<"; ";
//								 }
//								 else //same vehicle
//					             {
//									  if (idTrip == idTripii) //same trip, same vehicle
//									  {
//										  //ii has to be placed before its neighbor #kk in the current trip:
//										  if (pos[ii] < j && nextArr[ii] != curC)  cal_twoOPTstarCusPIAndJ_oneTrip(ii,kk);
//										  else twoOPTstarCus[ii][kk]->var_vioCAP = PDS_INFINITY_INT;
//									  }//end same trip, same vehicle
//								}//end same vehicle
//							}
//					  }//end if (twoOPTstarCus[ii][kk]->atIT != IT)
//				 }//end for k
//				curC = nextArr[curC];
//			}
//		}//end idTrip is pickup
//	}
//	
//	//last Trip:
//	curC = seg[idVeh].Trip[lastT].firstCus;
//	numC = seg[idVeh].Trip[lastT].numCus;
//	if (seg[idVeh].Trip[lastT].Type == 1)
//	{
//		for (j = 1; j<= numC; j++)
//		{
//			for (k=0; k< problem->node[curC].neighborSize; k++)
//			{
//				  //calculate: 2opt* customer curC and its neighbor #k:
//				  i = problem->node[curC].neighborNode[k].id;
//				  if (idVeh != route_num[i]) //curC and its neighbor i belong to different vehicles
//				  {
//						 cal_twoOPTstarCusDIAndJ(curC,k);
//				  }
//				  else //curC and i belong to the same trip
//				  {
//					  //curC has to be placed before its neighbor #k in the current route:
//					  if (nextArr[curC] != i)
//					  {
//						  startNeighbor = pos[i];
//						  if (j < startNeighbor)
//						  {
//							  cal_twoOPTstarCusDIAndJ_oneTrip_LastTrip(curC,k);
//						  }
//					  }
//				  }
//				  twoOPTstarCus[curC][k]->atIT = IT;
//			}			
//			//2. twoOPTstarCus[??][curC] where curC is in the trip
//			 for (k=0; k < problem->node[curC].beNeighborSize; k++)
//			 {
//				  //calculate: 2opt*
//				  ii = problem->node[curC].beNeighbor[k].id;
//				  kk = problem->node[curC].beNeighbor[k].at;
//				  if (twoOPTstarCus[ii][kk]->atIT != IT)
//				  {
//  						idVehii = route_num[ii]; idTripii = trip_num[ii];
//						nextTripii = idTripii + 1;
//						twoOPTstarCus[ii][kk]->atIT = IT;
//						if (idVeh != idVehii)
//						{
//							cal_twoOPTstarCusDIAndJ(ii,kk);
//						}
//						else //same trip:
//						{
//							if (nextArr[ii] != curC)
//							{
//								startNeighbor = pos[ii];
//								if (startNeighbor < j)
//								{
//								    if (nextTripii == seg[idVehii].numTrips)
//									{
//										cal_twoOPTstarCusDIAndJ_oneTrip_LastTrip(ii, kk);
//									}
//									else if (seg[idVehii].Trip[nextTripii].Type == 1)
//									{
//										  //cout<<"5. ii = "<<ii<<";curC = "<<curC<<endl;
//										  cal_twoOPTstarCusDIAndJ_oneTrip_NextTripD(ii, kk);
//									}
//									else
//									{
//										  cal_twoOPTstarCusDIAndJ_oneTrip_NextTripPORC2C(ii, kk);
//									}
//								}
//							}
//						}
//				  }//end if (twoOPTstarCus[ii][kk]->atIT != IT)
//			 }//end for k
//			curC = nextArr[curC];
//		}
//	}
//	else if (seg[idVeh].Trip[lastT].Type == 0)//lastT is pickup trip
//	{
//		int assSP = seg[idVeh].Trip[lastT].assSP;
//		for (j=1;j <= numC;j++)
//		{
//			for (k=0;k<problem->node[curC].neighborSize; k++)
//			{
//				  //calculate: exchange customer curC and its neighbor #k:
//				  i = problem->node[curC].neighborNode[k].id;
//				  if (assSP != seg[route_num[i]].Trip[trip_num[i]].assSP)
//					 twoOPTstarCus[curC][k]->var_vioCAP = PDS_INFINITY_INT;
//				  else
//				  {
//					  if (idVeh != route_num[i]) //dif veh, dif trip
//						  cal_twoOPTstarCusPIAndJ(curC, k);
//					  else //same vehicle
//					  {
//						  if (lastT == trip_num[i]) //same trip, same vehicle
//						  {
//							  //curC has to be placed before its neighbor #k in the current route:
//							  if (pos[i] > j && nextArr[curC] != i)  cal_twoOPTstarCusPIAndJ_oneTrip(curC,k);
//							  else twoOPTstarCus[curC][k]->var_vioCAP = PDS_INFINITY_INT;
//						  }//end same trip, same vehicle
//					  }//end same vehicle
//				  }
//				  twoOPTstarCus[curC][k]->atIT = IT;
//				  //cout<<"["<<curC<<"]["<<i<<"] = "<<twoOPTstarCus[curC][k]->var_vioCAP<<"; ";
//			}
//			//2. twoOPTstarCus[??][curC] where curC is in the trip
//			 for (k=0; k < problem->node[curC].beNeighborSize; k++)
//			 {
//				  //calculate: 2opt*
//				  ii = problem->node[curC].beNeighbor[k].id;
//				  kk = problem->node[curC].beNeighbor[k].at;
//				  if (twoOPTstarCus[ii][kk]->atIT != IT)
//				  {
//						twoOPTstarCus[ii][kk]->atIT = IT;
//  						idVehii = route_num[ii]; idTripii = trip_num[ii];
//						if (assSP != seg[idVehii].Trip[idTripii].assSP)
//							 twoOPTstarCus[ii][kk]->var_vioCAP = PDS_INFINITY_INT;
//						else
//						{
//						    if (idVeh != idVehii) //dif veh, dif trip
//							{
//								cal_twoOPTstarCusPIAndJ(ii, kk);
//							   // cout<<"["<<ii<<"]["<<curC<<"] = "<<twoOPTstarCus[ii][kk]->var_vioCAP<<"; ";
//							}
//							else //same vehicle
//							  {
//								  if (lastT == idTripii) //same trip, same vehicle
//								  {
//									  //ii has to be placed before its neighbor #kk in the current trip:
//									  if (pos[ii] < j && nextArr[ii] != curC)  cal_twoOPTstarCusPIAndJ_oneTrip(ii,kk);
//									  else twoOPTstarCus[ii][kk]->var_vioCAP = PDS_INFINITY_INT;
//								  }//end same trip, same vehicle
//							  }//end same vehicle
//						}
//				  }//end if (twoOPTstarCus[ii][kk]->atIT != IT)
//			 }//end for k
//			curC = nextArr[curC];
//		}
//	}//end lastT is pickup trip
//}
//
//void Solution::InsertDeliveryTrip(int idVehM, int idTripM, int assSPM, int idVehI, int assSPI) //insert (idVehM, idTripM) after (idVehI,idTripI) 
//{
//	if (seg[idVehI].numTrips == 0) //Vehicle is empty:
//	{
//		seg[idVehI].numTrips  = 1;
//		seg[idVehI].Trip[0] = seg[idVehM].Trip[idTripM];
//		int lastC = seg[idVehI].Trip[0].lastCus;
//		if (idTripM > 0) 
//		{
//			seg[idVehI].Trip[0].cost += problem->c[0][assSPM];
//			seg[idVehI].Trip[0].fitness += (problem->c[0][assSPM] - VTWSP * seg[idVehI].Trip[0].vioTWSP);
//		}
//		else
//			seg[idVehI].Trip[0].fitness -= (VTWSP * seg[idVehI].Trip[0].vioTWSP);
//		seg[idVehI].Trip[0].vioTWSP = 0;
//        double cStartS = problem->leaveSP[assSPM][4];            
//		subInsertDeliveryTrip(idVehI, 0, -1, cStartS, 0);
//		numVehUsed++;
//		//cout<<"Insert a new vehicle: numVehUsed = "<<numVehUsed<<endl;
//	}
//	else //Vehicle is not empty:
//	{
//		int lastT = seg[idVehI].numTrips - 1;
//		if (assSPI == 0) //insert begin
//		{
//			assSPI = seg[idVehI].Trip[0].assSP;
//			if (assSPM < assSPI) //insert at the beginning:
//			{
//				//cout<<"Solution::InsertDeliveryTrip Insert delivery tripM ("<<idVehM<<", "<<idTripM<<") at the beginning of the vehicle "<<idVehI<<endl;
//				//Don toa:
//				for (int i=seg[idVehI].numTrips;i > 0; i--)
//				{
//					seg[idVehI].Trip[i] = seg[idVehI].Trip[i-1];
//					UpdateTripnum(idVehI,i);
//				}
//				seg[idVehI].Trip[0] = seg[idVehM].Trip[idTripM];
//				seg[idVehI].numTrips++;
//				int lastC = seg[idVehI].Trip[0].lastCus;
//				if (idTripM > 0) 
//				{
//					seg[idVehI].Trip[0].cost += problem->c[0][assSPM];
//					seg[idVehI].Trip[0].fitness += (problem->c[0][assSPM] - VTWSP * seg[idVehI].Trip[0].vioTWSP);
//				}
//				else
//					seg[idVehI].Trip[0].fitness -= (VTWSP * seg[idVehI].Trip[0].vioTWSP);
//				seg[idVehI].Trip[0].vioTWSP = 0;
//				double cStartS = problem->leaveSP[assSPM][4]; 
//				double varcostpreT;
//				if (seg[idVehI].Trip[1].Type)
//					varcostpreT = -problem->c[0][seg[idVehI].Trip[1].assSP];
//				else
//					varcostpreT = -problem->c[0][seg[idVehI].Trip[1].firstCus];
//				
//				seg[idVehI].Trip[1].cost += varcostpreT;
//				seg[idVehI].Trip[1].fitness += varcostpreT;
//				subInsertDeliveryTrip(idVehI,0,1,cStartS,varcostpreT);
//			}
//			else //GOP because assSPM = assSPI
//			{
//				if (seg[idVehI].Trip[0].Type)
//				{
//					//Connect: delcus of (idVehM,idTripM) + delcus of (idVehI,0):
//					//cout<<"Solution::InsertDeliveryTrip GOP TRUOC delcus of tripM("<<idVehM<<", "<<idTripM<<") at the beginning of the vehI "<<idVehI<<endl;
//					insertCusDArraySuc(idVehI, 0, idVehM, idTripM);
//				}
//				else
//				{
//					if (seg[idVehI].Trip[1].coordinate == 0)
//					{
//						cout<<"ERROR Cant not GOP ("<<idVehM<<", "<<idTripM<<", SP = "<<assSPM<<") with deltrip of veh "<<idVehI<<", SP = "<<seg[idVehI].Trip[1].assSP<<endl;
//						cout<<"BECAUSE it's not coordinate trip???"<<endl;
//						showSegment(idVehI);
//						exit(-1);
//					}
//					//cout<<"Solution::InsertDeliveryTrip GOP TRUOC: delcus of tripM("<<idVehM<<", "<<idTripM<<") + del cus of coordinateTripI1 ("<<idVehI<<",1)"<<endl;
//					insertCusDArraySuc(idVehI, 1, idVehM, idTripM);
//				}
//			}//end GOP because assSPM = assSPI
//		}
//		else //insert middle/last
//		{
//			int idTripI; //Insert idTripM after idTripI
//			for (int i=0;i<seg[idVehI].numTrips;i++)
//			{
//				if (assSPI == seg[idVehI].Trip[i].assSP) 
//				{
//					idTripI = i; 
//					break;
//				}
//			}
//			int lastTI = seg[idVehI].numTrips - 1;
//			if (idTripI == lastTI) //insert at the last
//			{
//				if (assSPI == assSPM) 
//				{
//					//cout<<"Solution::InsertDeliveryTrip Insert in the last of vehicle "<<idVehI<<": ";
//					if (seg[idVehI].Trip[idTripI].Type) //GOP: idTripI - d + idTripM - d
//					{
//						//cout<<"GOPSAU: del cus of lastTrip("<<idVehI<<", "<<idTripI<<") + delcus of tripM ("<<idVehM<<", "<<idTripM<<")"<<endl;
//					    //Connect: delcus of (idVehI,idTripI) + delcus of (idVehM, idTripM):
//				    	insertCusDArrayPre(idVehI,idTripI,idVehM,idTripM);
//					}
//					else //CREATE NEW P-D-SAMESP at the end of the veh:
//					{
//						//cout<<"CREATE NEW P-D-SAMESP at the end of vehicle "<<idVehI<<endl;
//						int lastTINEW = seg[idVehI].numTrips;
//						seg[idVehI].Trip[lastTINEW] = seg[idVehM].Trip[idTripM];
//						if (idTripM == 0)
//						{
//							seg[idVehI].Trip[lastTINEW].cost -= problem->c[0][assSPM];
//							seg[idVehI].Trip[lastTINEW].fitness -= problem->c[0][assSPM];
//						}
//						seg[idVehI].numTrips ++;
//						UpdateVehicle_CONNECTAtSP_PD_InsertDT(idVehI,lastTI,-1);
//					}
//				}
//				else //NOT GOP, insert at the last: assSPI < assSPM
//				{
//					if (seg[idVehI].Trip[idTripI].Type)
//					{
//						//cout<<"assSPM > assSPI: Insert delivery tripM ("<<idVehM<<", "<<idTripM<<", SP = "<<assSPM<<") after the last delivery trip of vehicle "<<idVehI<<" (SP = "<<assSPI<<")"<<endl;
//     					int lastTINEW = seg[idVehI].numTrips;
//						seg[idVehI].Trip[lastTINEW] = seg[idVehM].Trip[idTripM];
//						if (idTripM == 0)
//						{
//							seg[idVehI].Trip[lastTINEW].cost -= problem->c[0][assSPM];
//							seg[idVehI].Trip[lastTINEW].fitness -= problem->c[0][assSPM];
//						}
//						seg[idVehI].numTrips ++;
//						UpdateVehicle_CONNECTAtSP_DD_InsertDT(idVehI, lastTI, -1);
// 					}
//					else
//					{
//						//cout<<"assSPM > assSPI: Insert delivery tripM ("<<idVehM<<", "<<idTripM<<") after the last pickup trip of vehicle "<<idVehI<<" (SP = "<<assSPI<<")"<<endl;
//     					int lastTINEW = seg[idVehI].numTrips;
//						seg[idVehI].Trip[lastTINEW] = seg[idVehM].Trip[idTripM];
//						if (idTripM == 0)
//						{
//							seg[idVehI].Trip[lastTINEW].cost -= problem->c[0][assSPM];
//							seg[idVehI].Trip[lastTINEW].fitness -= problem->c[0][assSPM];
//						}
//						seg[idVehI].numTrips ++;
//						UpdateVehicle_CONNECTAtSP_PD_InsertDT(idVehI, lastTI, -1);
//					}
//				}//end NOT GOP, insert at the last
//			}
//			else //insert at the middle
//			{
//				int idTripI1 = idTripI+1;
//				if (assSPM == assSPI)
//				{
//					if (seg[idVehI].Trip[idTripI].Type) //GOP SAU
//					{
//						//GOP SAU: insert del cus of (idVehM, idTripM) after (idVehI, idTripI):
//						//cout<<"Solution::InsertDeliveryTrip GOP SAU: del cus of middle tripI ("<<idVehI<<", "<<idTripI<<") + delcus of tripM ("<<idVehM<<", "<<idTripM<<")"<<endl;
//			    		insertCusDArrayPre(idVehI,idTripI,idVehM,idTripM);
//					}
//					else
//					{
//						if (seg[idVehI].Trip[idTripI1].coordinate)
//						{
//							//GOP SAU: insert del cus of(idVehM, idTripM) before firstdel cus of (idVehI, idTripI1):
//							//cout<<"Solution::InsertDeliveryTrip GOPSAU: delcus of coordinate tripI1 ("<<idVehI<<", "<<idTripI1<<") + del cus of tripM ("<<idVehM<<", "<<idTripM<<")"<<endl;
//							//Connect: delcus of (idVehI,idTripI1) + delcus of (idVehM, idTripM):
//				    		insertCusDArrayPre(idVehI,idTripI1,idVehM,idTripM);
//						}
//						else
//						{
//							//CREATE NEW P-D SAME SP
//							//cout<<"Solution::InsertDeliveryTrip CREATE NEW P-D-SAMESP by inserting DelTripM ("<<idVehM<<", "<<idTripM<<") after the pickup tripI ("<<idVehI<<", "<<idTripI<<")"<<endl;
//							//Don toa:
//							for (int i = seg[idVehI].numTrips;i > idTripI1; i--)
//							{
//								seg[idVehI].Trip[i] = seg[idVehI].Trip[i-1];
//								UpdateTripnum(idVehI,i);
//							}
//							seg[idVehI].Trip[idTripI1] = seg[idVehM].Trip[idTripM];
//							if (idTripM == 0)
//							{
//								seg[idVehI].Trip[idTripI1].cost -= problem->c[0][assSPM];
//								seg[idVehI].Trip[idTripI1].fitness -= problem->c[0][assSPM];
//							}
//
//							seg[idVehI].numTrips++;
//							UpdateVehicle_CONNECTAtSP_PD_InsertDT(idVehI,idTripI,idTripI1+1);
//						}
//					}
//
//				}
//				else //assSPM > assSPI:
//				{
//					int assSPI1 = seg[idVehI].Trip[idTripI1].assSP;
//					if (assSPM < assSPI1)
//					{
//						//cout<<"Solution::InsertDeliveryTrip Insert delivery tripM ("<<idVehM<<", "<<idTripM<<", SP = "<<assSPM<<") in the middle of vehicle "<<idVehI<<" between trips "<<idTripI<<" and "<<idTripI1<<endl;
//						//Don toa:
//						for (int i = seg[idVehI].numTrips;i > idTripI1; i--)
//						{
//							seg[idVehI].Trip[i] = seg[idVehI].Trip[i-1];
//							UpdateTripnum(idVehI,i);
//						}
//						seg[idVehI].Trip[idTripI1] = seg[idVehM].Trip[idTripM];
//						if (idTripM == 0)
//						{
//							seg[idVehI].Trip[idTripI1].cost -= problem->c[0][assSPM];
//							seg[idVehI].Trip[idTripI1].fitness -= problem->c[0][assSPM];
//						}
//						seg[idVehI].numTrips++;
//						if (seg[idVehI].Trip[idTripI].Type)
//						    UpdateVehicle_CONNECTAtSP_DD_InsertDT(idVehI, idTripI, idTripI1+1);
//						else
//							UpdateVehicle_CONNECTAtSP_PD_InsertDT(idVehI, idTripI, idTripI1+1);
//					}
//					else if (assSPM > assSPI1)
//					{
//						//(idTripI1) is coordinate trip
//						if (seg[idVehI].Trip[idTripI1].coordinate == 0)
//						{
//							cout<<"ERROR Solution::InsertDeliveryTrip: Trip ("<<idVehI<<", "<<idTripI1<<") has to be coordinate trip for the case: p-assSPI-dSAMESP where assSPI = assSPI1 < assSPM"<<endl;
//							showSegment(idVehI);
//							exit(-1);
//						}
//						//There are 3 cases:
//						int CASE = 1, idTripI2, idTripI3;
//						idTripI2 = idTripI1 + 1;
//						if (idTripI2 <= lastTI)
//						{
//							int assSPI2 = seg[idVehI].Trip[idTripI2].assSP;
//							if (assSPM == assSPI2)
//							{ 
//								if (seg[idVehI].Trip[idTripI2].Type) CASE = 2;
//								else
//								{
//									if (idTripI2 == lastTI)
//									{
//										cout<<"ERROR Solution::InsertDeliveryTrip: "<<idTripI2<<" can't be the last trip of vehicle "<<idVehI<<endl;
//										exit(-1);
//									}
//									idTripI3 = idTripI2 + 1;
//									if (seg[idVehI].Trip[idTripI3].coordinate == 0)
//									{
//										cout<<"ERROR Solution::InsertDeliveryTrip trip("<<idVehI<<", "<<idTripI3<<") has to be the coordinate trip"<<endl;
//										exit(-1);
//									}
//									CASE = 3;
//								}
//							}
//							//else CASE = 1;
//						}
//						//else CASE = 1;
//						//CASE = 1: insert after the coordinate trip (idVehI, idTripI1)
//						//CASE = 2: gop truoc delivery trip (idVehI, idTripI2)
//						//CASE = 3: GOP truoc coordinate delivery trip (idVehI, idTripI3)
//						if (CASE == 1)
//						{
//							//CASE = 1: insert after the coordinate trip (idVehI, idTripI1)
//							//Don toa:
//							//cout<<"Solution::InsertDeliveryTrip Insert delivery tripM ("<<idVehM<<", "<<idTripM<<", SP = "<<assSPM<<") in the middle after coordinate trip ("<<idVehI<<", "<<idTripI1<<")"<<endl;
//							for (int i = seg[idVehI].numTrips;i > idTripI2; i--)
//							{
//								seg[idVehI].Trip[i] = seg[idVehI].Trip[i-1];
//								UpdateTripnum(idVehI,i);
//							}
//							seg[idVehI].Trip[idTripI2] = seg[idVehM].Trip[idTripM];
//							if (idTripM == 0)
//							{
//								seg[idVehI].Trip[idTripI2].cost -= problem->c[0][assSPM];
//								seg[idVehI].Trip[idTripI2].fitness -= problem->c[0][assSPM];
//							}
//							seg[idVehI].numTrips++;
//							int idTripI3 = idTripI2 + 1;
//							if (idTripI3 < seg[idVehI].numTrips)
//							   UpdateVehicle_CONNECTAtSP_DD_InsertDT(idVehI, idTripI1, idTripI3);
//							else 
//								UpdateVehicle_CONNECTAtSP_DD_InsertDT(idVehI, idTripI1, -1);
//						}
//						else if (CASE == 2)
//						{
//							//CASE = 2:GOP TRUOC: insert del cus of(idVehM, idTripM) before firstdel cus of (idVehI, idTripI2):
//							//cout<<"Solution::InsertDeliveryTrip GOPTRUOC: delcus of tripM ("<<idVehM<<", "<<idTripM<<") + delcus of tripI2 ("<<idVehI<<", "<<idTripI2<<"); ("<<idVehI<<", "<<idTripI1<<") is coordinate"<<endl;
//				    		insertCusDArraySuc(idVehI,idTripI2,idVehM,idTripM);
//						}
//						else
//						{
//							//CASE = 3: GOP truoc coordinate delivery trip (idVehI, idTripI3)
//							//cout<<"Solution::InsertDeliveryTrip GOPTRUOC: del cus of tripM ("<<idVehM<<", "<<idTripM<<") + delcus of coordinate tripI3 ("<<idVehI<<", "<<idTripI3<<"); ("<<idVehI<<", "<<idTripI1<<") is coordinate"<<endl;
//				    		insertCusDArraySuc(idVehI,idTripI3,idVehM,idTripM);
//						}
//					}
//					else //assSPI < assSPM == assSPI1: GOP in the middle
//					{
//						if (seg[idVehI].Trip[idTripI1].Type)
//						{
//							//GOP TRUOC: insert (idVehM, idTripM) before (idVehI, idTripI1)
//							//cout<<"Solution::InsertDeliveryTrip GOP TRUOC: del cus of tripM ("<<idVehM<<", "<<idTripM<<") + delcus of middletripI1 ("<<idVehI<<", "<<idTripI1<<")"<<endl;
//				    		insertCusDArraySuc(idVehI,idTripI1,idVehM,idTripM);
//						}
//						else
//						{
//							int idTripI2 = idTripI1 + 1;
//							if (seg[idVehI].Trip[idTripI2].coordinate==0)
//							{
//								cout<<"ERROR: trip("<<idVehI<<", "<<idTripI2<<") should be coordinate trip with sp = "<<assSPI1<<"; to GOP del cus of tripM ("<<idVehM<<", "<<idTripM<<", SP = "<<assSPM<<")"<<endl;
//								cout<<"CASE assSPI("<<assSPI<<") < assSPM("<<assSPM<<") == assSPI1("<<assSPI1<<")"<<endl;
//								showSegment(idVehI);
//								exit(-1);
//							}
//							//GOP TRUOC: insert (idVehM, idTripM) before (idVehI, idTripI2)
//							//cout<<"Solution::InsertDeliveryTrip GOP TRUOC: del cus of tripM ("<<idVehM<<", "<<idTripM<<") + delcus of middleCOORDINATEtrip ("<<idVehI<<", "<<idTripI2<<")"<<endl;
//				    		insertCusDArraySuc(idVehI,idTripI2,idVehM,idTripM);
//						}
//					}//end assSPI < assSPM == assSPI1: GOP in the middle
//				}
//			}//end insert at the middle
//		}//end insert middle/last
//	}//end //Vehicle is not empty
//}
//
//void Solution::InsertDeliveryTrip_ExchangeSP(int idVeh, int idTripI, int idTripM)  
//{
//	//(idVeh, idTripI) is delivery trip has just been exchanged in the vehicle idVeh
//	int assSPM = seg[idVeh].Trip[idTripI].assSP;
//
//	if (idTripI == 0) //exchange begin
//	{
//		//cout<<"Exchange delivery trip at the beginning of the vehicle "<<idVeh<<endl;
//		if (idTripM > 0) 
//		{
//			seg[idVeh].Trip[0].cost += problem->c[0][assSPM];
//			seg[idVeh].Trip[0].fitness += (problem->c[0][assSPM] - VTWSP * seg[idVeh].Trip[0].vioTWSP);
//		}
//		else
//			seg[idVeh].Trip[0].fitness -= (VTWSP * seg[idVeh].Trip[0].vioTWSP);
//		seg[idVeh].Trip[0].vioTWSP = 0;
//		double cStartS = problem->leaveSP[assSPM][4]; 
//		if (seg[idVeh].numTrips == 1)
//		   subInsertDeliveryTrip(idVeh,0,-1,cStartS,0);//varcostpreT = 0
//		else
//		   subInsertDeliveryTrip(idVeh,0,1,cStartS,0); //varcostpreT = 0
//	}
//	else //exchange middle/last
//	{
//		int preT = idTripI - 1;
//		if (idTripM == 0)
//		{
//			seg[idVeh].Trip[idTripI].cost -= problem->c[0][assSPM];
//			seg[idVeh].Trip[idTripI].fitness -= problem->c[0][assSPM];
//		}
//		int idTripI1 = idTripI + 1;
//		if (idTripI1 == seg[idVeh].numTrips) //exchange last
//		{
//			if (seg[idVeh].Trip[preT].Type)
//			{
//				//cout<<"Exchange delivery trip at the last delivery trip of vehicle "<<idVeh<<endl;
//				UpdateVehicle_CONNECTAtSP_DD_InsertDT(idVeh,preT,-1);
//			}
//			else
//			{
//				//cout<<"Exchange delivery trip at the last pickup trip of vehicle "<<idVeh<<endl;
//				UpdateVehicle_CONNECTAtSP_PD_InsertDT(idVeh, preT, -1);
//			}
//		}
//		else //exchange middle:
//		{
//			if (seg[idVeh].Trip[preT].Type)
//			{
//				//cout<<"Exchange delivery trip in the middle of vehicle "<<idVeh<<", after del trip "<<preT<<endl;
//				UpdateVehicle_CONNECTAtSP_DD_InsertDT(idVeh, preT, idTripI1);
//			}
//			else
//			{
//				//cout<<"Exchange delivery trip in the middle of vehicle "<<idVeh<<", after pick trip "<<preT<<endl;
//				UpdateVehicle_CONNECTAtSP_PD_InsertDT(idVeh, preT, idTripI1);
//			}
//		}//end exchange middle
//	}//end exchange middle/last
//}
//
//
//void Solution::subInsertDeliveryTrip(int idVeh, int idTripI, int nextT, double cStartS, double varcost)
//{
//	int lastC = seg[idVeh].Trip[idTripI].lastCus;
//
//	UpdateRouteTripnum(idVeh, idTripI);
//	if (PDSDIF(cStartS, seg[idVeh].Trip[idTripI].leaveSP))
//	{
//		seg[idVeh].Trip[idTripI].leaveSP = cStartS;
//		double cArrTime, temp;
//		int preC = seg[idVeh].Trip[idTripI].assSP;
//		int curC = seg[idVeh].Trip[idTripI].firstCus;
//		while (curC > 0)
//		{
//			cArrTime = cStartS + problem->c[preC][curC];
//			cStartS = PDS_MAX(cArrTime, problem->node[curC].sTW);
//			if (PDSDIF(cStartS, startS[curC])==0) //it means vioTWCus[curC] =0 
//			{
//				temp = cStartS - problem->node[curC].eTW;
//				if (temp > eps) vioTWCus[curC] = temp; else vioTWCus[curC] = 0;
//				UpdateFBvioTWCus(idVeh, idTripI, curC);
//				double varvioTWC = FvioTWCus[lastC] - seg[idVeh].Trip[idTripI].vioTWC;
//				seg[idVeh].Trip[idTripI].vioTWC = FvioTWCus[lastC];
//				seg[idVeh].Trip[idTripI].fitness += (VTWCUS * varvioTWC);
//				goto Update;
//			}
//			temp = cStartS - problem->node[curC].eTW;
//			if (temp > eps)
//			{
//				if (vioTWCus[curC] > eps) 
//				{
//					vioTWCus[curC] = temp;
//					UpdateFBvioTWCus(idVeh, idTripI, curC);
//					double varvioTWC = FvioTWCus[lastC] - seg[idVeh].Trip[idTripI].vioTWC;
//					seg[idVeh].Trip[idTripI].vioTWC = FvioTWCus[lastC];
//					seg[idVeh].Trip[idTripI].fitness += (VTWCUS * varvioTWC);
//					goto Update;
//				}
//				vioTWCus[curC] = temp;
//				FvioTWCus[curC] = FvioTWCus[preC] + temp;
//				cStartS = problem->node[curC].eTW;
//			}
//			else 
//			{
//				vioTWCus[curC] = 0;
//				FvioTWCus[curC] = FvioTWCus[preC];
//			}
//			startS[curC] = cStartS;
//			cStartS += problem->node[curC].duration;
//			depart[curC] = cStartS;
//			preC = curC; curC = nextArr[curC];
//		}//end while (curC > 0)
//		seg[idVeh].Trip[idTripI].endS = depart[preC];
//		double varvioTWC = FvioTWCus[preC] - seg[idVeh].Trip[idTripI].vioTWC;
//		seg[idVeh].Trip[idTripI].vioTWC = FvioTWCus[preC];
//		seg[idVeh].Trip[idTripI].fitness += (VTWCUS * varvioTWC);
//		UpdateBvioTWCus(idVeh, idTripI, preC);
//	}
//Update:
//	if (seg[idVeh].Trip[idTripI].vioTWC > eps || seg[idVeh].Trip[idTripI].vioCAP > 0 || seg[idVeh].Trip[idTripI].vioTWSP > eps)
//		seg[idVeh].Trip[idTripI].feasible = 0;
//	else seg[idVeh].Trip[idTripI].feasible = 1;
//
//	if (nextT < 0)
//	{
//		seg[idVeh].Trip[idTripI].waitingS = NO_WS;
//		double varcost1 = problem->c[lastC][0] - seg[idVeh].Trip[idTripI].connectCost;
//		seg[idVeh].Trip[idTripI].connectCost = problem->c[lastC][0];
//		seg[idVeh].Trip[idTripI].cost += varcost1;
//		seg[idVeh].Trip[idTripI].fitness += varcost1;
//
//		double varFIT = varcost + seg[idVeh].Trip[idTripI].fitness;
//		varcost += seg[idVeh].Trip[idTripI].cost;
//		seg[idVeh].cost += varcost;
//		seg[idVeh].fitness += varFIT;
//		seg[idVeh].vioCAP += seg[idVeh].Trip[idTripI].vioCAP;
//		seg[idVeh].vioTWC += seg[idVeh].Trip[idTripI].vioTWC;
//		seg[idVeh].vioTWSP += seg[idVeh].Trip[idTripI].vioTWSP;
//		cost += varcost;
//		fitness += varFIT;
//		vioCAP += seg[idVeh].Trip[idTripI].vioCAP;
//		vioTWC += seg[idVeh].Trip[idTripI].vioTWC;
//		vioTWSP += seg[idVeh].Trip[idTripI].vioTWSP;
//	}
//	else
//	{
//		if (seg[idVeh].Trip[nextT].Type)
//		{
//			UpdateVehicle_CONNECTAtSP_DD_InsertDT(idVeh, nextT, idTripI, varcost); 
//		}
//		else
//		{
//			seg[idVeh].Trip[idTripI].waitingS = NO_WS;
//			int firstC_nextT = seg[idVeh].Trip[nextT].firstCus;
//			double varcost1 = problem->c[lastC][firstC_nextT] - seg[idVeh].Trip[idTripI].connectCost;
//			seg[idVeh].Trip[idTripI].connectCost =  problem->c[lastC][firstC_nextT];
//			seg[idVeh].Trip[idTripI].cost += varcost1;
//			seg[idVeh].Trip[idTripI].fitness += varcost1;
//
//			double varfit = varcost + seg[idVeh].Trip[idTripI].fitness;
//			varcost += seg[idVeh].Trip[idTripI].cost;
//			seg[idVeh].cost += varcost;
//			seg[idVeh].fitness += varfit;
//			seg[idVeh].vioCAP += seg[idVeh].Trip[idTripI].vioCAP;
//			seg[idVeh].vioTWC += seg[idVeh].Trip[idTripI].vioTWC;
//			seg[idVeh].vioTWSP += seg[idVeh].Trip[idTripI].vioTWSP;
//			cost += varcost; fitness += varfit;
//			vioCAP += seg[idVeh].Trip[idTripI].vioCAP;
//			vioTWC += seg[idVeh].Trip[idTripI].vioTWC;
//			vioTWSP += seg[idVeh].Trip[idTripI].vioTWSP;
//			UpdateVehicle(idVeh,nextT,lastC,depart[lastC],0, seg[idVeh].numTrips - 1);
//		}
//	}
//
//}
//void Solution::UpdateVehicle_CONNECTAtSP_SPSP_InsertPT(int idVeh, int nextT, int idTripI, double varcostpreT)//for subInsertPickTrip
//{
//	//For Insert Pickup Trip
//	//Calculate the connection from picktrip(idVeh, idTripI) to del trip (idVeh, nextT) and go through vehicle, update all INFORMATION of vehicle idVeh
//    //varcost is variation of cost for the trips before (idVeh, idTripI)
//	int assSPnextT = seg[idVeh].Trip[nextT].assSP;
//	int assSPI = seg[idVeh].Trip[idTripI].assSP;
//
//	double varvioTWSP = -seg[idVeh].Trip[nextT].vioTWSP;
//    double varC = -seg[idVeh].Trip[idTripI].connectCost;
//
//
//	double cStartS;
//	if (assSPI == assSPnextT)
//	{
//		seg[idVeh].Trip[idTripI].connectCost = 0;
//		seg[idVeh].Trip[idTripI].waitingS1 = NO_WS;
//		seg[idVeh].Trip[idTripI].cost += varC;
//		seg[idVeh].Trip[idTripI].fitness += varC;
//
//		double varfit = varcostpreT + seg[idVeh].Trip[idTripI].fitness;
//		double varcost = varcostpreT + seg[idVeh].Trip[idTripI].cost;
//		seg[idVeh].cost += varcost;
//		seg[idVeh].fitness += varfit;
//		seg[idVeh].vioCAP += seg[idVeh].Trip[idTripI].vioCAP;
//		seg[idVeh].vioTWC += seg[idVeh].Trip[idTripI].vioTWC;
//		seg[idVeh].vioTWSP += seg[idVeh].Trip[idTripI].vioTWSP;
//		cost += varcost; fitness += varfit;
//		vioCAP += seg[idVeh].Trip[idTripI].vioCAP;
//		vioTWC += seg[idVeh].Trip[idTripI].vioTWC;
//		vioTWSP += seg[idVeh].Trip[idTripI].vioTWSP;
//
//		seg[idVeh].Trip[nextT].coordinate = 1;
//		seg[idVeh].Trip[nextT].vioTWSP = seg[idVeh].Trip[idTripI].vioTWSP;
//		varvioTWSP += seg[idVeh].Trip[nextT].vioTWSP;
//		double varFITnextT = VTWSP *varvioTWSP;
//		seg[idVeh].Trip[nextT].fitness += varFITnextT;
//
//		if (seg[idVeh].Trip[nextT].vioTWSP > eps)
//			cStartS = problem->leaveSP[assSPI][1]; //load only at eTW2
//		else cStartS = seg[idVeh].Trip[idTripI].leaveSP + problem->nodeSP[assSPI].load;
//		if (PDSDIF(cStartS, seg[idVeh].Trip[nextT].leaveSP))
//		{
//			seg[idVeh].Trip[nextT].leaveSP = cStartS;
//			UpdateVehicle(idVeh, nextT, assSPnextT, cStartS, 0, seg[idVeh].numTrips - 1); //varvioCAP = 0
//		}
//		else
//		{
//			seg[idVeh].fitness += varFITnextT;
//			seg[idVeh].vioTWSP += varvioTWSP;
//			fitness += varFITnextT;
//			vioTWSP += varvioTWSP;
//			if (seg[idVeh].Trip[nextT].vioTWC > eps || seg[idVeh].Trip[nextT].vioCAP > 0 || seg[idVeh].Trip[nextT].vioTWSP > eps)
//				seg[idVeh].Trip[nextT].feasible = 0;
//			else seg[idVeh].Trip[nextT].feasible = 1;
//		}
//	}
//	else //assSPI != assSPnextT
//	{
//		cStartS = seg[idVeh].Trip[idTripI].leaveSP;
//		double cArrTime = cStartS + problem->c[assSPI][assSPnextT];
//		
//		if (PDSINRANGE(cArrTime, problem->nodeSP[assSPnextT].sTW2, problem->nodeSP[assSPnextT].eTW2))
//		{
//			seg[idVeh].Trip[idTripI].connectCost = problem->c[assSPI][assSPnextT];
//			varC += problem->c[assSPI][assSPnextT];
//			seg[idVeh].Trip[idTripI].waitingS1 = NO_WS;
//			seg[idVeh].Trip[idTripI].cost += varC;
//			seg[idVeh].Trip[idTripI].fitness += varC;
//
//			double varfit = varcostpreT + seg[idVeh].Trip[idTripI].fitness;
//			double varcost = varcostpreT + seg[idVeh].Trip[idTripI].cost;
//			seg[idVeh].cost += varcost;
//			seg[idVeh].fitness += varfit;
//			seg[idVeh].vioCAP += seg[idVeh].Trip[idTripI].vioCAP;
//			seg[idVeh].vioTWC += seg[idVeh].Trip[idTripI].vioTWC;
//			seg[idVeh].vioTWSP += seg[idVeh].Trip[idTripI].vioTWSP;
//			cost += varcost; fitness += varfit;
//			vioCAP += seg[idVeh].Trip[idTripI].vioCAP;
//			vioTWC += seg[idVeh].Trip[idTripI].vioTWC;
//			vioTWSP += seg[idVeh].Trip[idTripI].vioTWSP;
//
//			seg[idVeh].Trip[nextT].vioTWSP = 0;
//			seg[idVeh].Trip[nextT].fitness += (VTWSP *varvioTWSP);
//			seg[idVeh].Trip[nextT].leaveSP = cArrTime + problem->nodeSP[assSPnextT].load;
//			UpdateVehicle(idVeh, nextT, assSPnextT, seg[idVeh].Trip[nextT].leaveSP, 0, seg[idVeh].numTrips - 1); //varvioCAP = 0
//		}
//		else
//		{
//			double temp = cArrTime - problem->nodeSP[assSPnextT].eTW2;
//			if (temp > eps)
//			{
//				seg[idVeh].Trip[idTripI].connectCost = problem->c[assSPI][assSPnextT];
//				varC += problem->c[assSPI][assSPnextT];
//				seg[idVeh].Trip[idTripI].waitingS1 = NO_WS;
//				seg[idVeh].Trip[idTripI].cost += varC;
//				seg[idVeh].Trip[idTripI].fitness += varC;
//
//				varvioTWSP += temp;
//				if (seg[idVeh].Trip[nextT].vioTWSP > eps) //before also vioTWSP --> don't need to update all remaining trips
//				{
//					seg[idVeh].Trip[nextT].vioTWSP = temp;
//					double COEFvioTWSP = (VTWSP * varvioTWSP);
//					seg[idVeh].Trip[nextT].fitness +=  COEFvioTWSP;
//
//					double varfit = varcostpreT + seg[idVeh].Trip[idTripI].fitness + COEFvioTWSP;
//					double varcost = varcostpreT + seg[idVeh].Trip[idTripI].cost;
//					varvioTWSP += seg[idVeh].Trip[idTripI].vioTWSP;
//					seg[idVeh].cost += varcost;
//					seg[idVeh].fitness += varfit;
//					seg[idVeh].vioCAP += seg[idVeh].Trip[idTripI].vioCAP;
//					seg[idVeh].vioTWC += seg[idVeh].Trip[idTripI].vioTWC;
//					seg[idVeh].vioTWSP += varvioTWSP;
//					cost += varcost; fitness += varfit;
//					vioCAP += seg[idVeh].Trip[idTripI].vioCAP;
//					vioTWC += seg[idVeh].Trip[idTripI].vioTWC;
//					vioTWSP += varvioTWSP;
//				}
//				else //need to update all remaining trips:
//				{
//					seg[idVeh].Trip[nextT].vioTWSP = temp;
//					double COEFvioTWSP = (VTWSP * varvioTWSP);
//					seg[idVeh].Trip[nextT].fitness +=  COEFvioTWSP;
//
//					double varfit = varcostpreT + seg[idVeh].Trip[idTripI].fitness + COEFvioTWSP;
//					double varcost = varcostpreT + seg[idVeh].Trip[idTripI].cost;
//					varvioTWSP += seg[idVeh].Trip[idTripI].vioTWSP;
//					seg[idVeh].cost += varcost;
//					seg[idVeh].fitness += varfit;
//					seg[idVeh].vioCAP += seg[idVeh].Trip[idTripI].vioCAP;
//					seg[idVeh].vioTWC += seg[idVeh].Trip[idTripI].vioTWC;
//					seg[idVeh].vioTWSP += varvioTWSP;
//					cost += varcost; fitness += varfit;
//					vioCAP += seg[idVeh].Trip[idTripI].vioCAP;
//					vioTWC += seg[idVeh].Trip[idTripI].vioTWC;
//					vioTWSP += varvioTWSP;
//
//					seg[idVeh].Trip[nextT].leaveSP = problem->leaveSP[assSPnextT][1]; //load only at eTW2
//					UpdateVehicle(idVeh, nextT, assSPnextT, seg[idVeh].Trip[nextT].leaveSP, 0, seg[idVeh].numTrips - 1); //varvioCAP = 0
//				}
//			}
//			else
//			{
//				double cArrTimeI = cStartS + problem->disCWSSP[assSPI][assSPnextT];
//				temp = cArrTimeI - problem->nodeSP[assSPnextT].eTW2;
//				if (temp > eps) //too soon to go sp directly, too late to go through WS:
//				{
//					seg[idVeh].Trip[idTripI].connectCost = problem->c[assSPI][assSPnextT];
//					varC += problem->c[assSPI][assSPnextT];
//					seg[idVeh].Trip[idTripI].waitingS1 = NO_WS;
//					seg[idVeh].Trip[idTripI].cost += varC;
//					seg[idVeh].Trip[idTripI].fitness += varC;
//					temp = problem->nodeSP[assSPnextT].sTW2 - cArrTime;
//					varvioTWSP += temp;
//
//					if (seg[idVeh].Trip[nextT].vioTWSP > eps) //before also vioTWSP --> don't need to update all remaining trips
//					{
//						seg[idVeh].Trip[nextT].vioTWSP = temp;
//						double COEFvioTWSP = (VTWSP * varvioTWSP);
//						seg[idVeh].Trip[nextT].fitness +=  COEFvioTWSP;
//
//						double varfit = varcostpreT + seg[idVeh].Trip[idTripI].fitness + COEFvioTWSP;
//						double varcost = varcostpreT + seg[idVeh].Trip[idTripI].cost;
//						varvioTWSP += seg[idVeh].Trip[idTripI].vioTWSP;
//						seg[idVeh].cost += varcost;
//						seg[idVeh].fitness += varfit;
//						seg[idVeh].vioCAP += seg[idVeh].Trip[idTripI].vioCAP;
//						seg[idVeh].vioTWC += seg[idVeh].Trip[idTripI].vioTWC;
//						seg[idVeh].vioTWSP += varvioTWSP;
//						cost += varcost; fitness += varfit;
//						vioCAP += seg[idVeh].Trip[idTripI].vioCAP;
//						vioTWC += seg[idVeh].Trip[idTripI].vioTWC;
//						vioTWSP += varvioTWSP;
//					}
//					else //need to update all remaining trips:
//					{
//						seg[idVeh].Trip[nextT].vioTWSP = temp;
//
//						double COEFvioTWSP = (VTWSP * varvioTWSP);
//						seg[idVeh].Trip[nextT].fitness +=  COEFvioTWSP;
//
//						double varfit = varcostpreT + seg[idVeh].Trip[idTripI].fitness + COEFvioTWSP;
//						double varcost = varcostpreT + seg[idVeh].Trip[idTripI].cost;
//						varvioTWSP += seg[idVeh].Trip[idTripI].vioTWSP;
//						seg[idVeh].cost += varcost;
//						seg[idVeh].fitness += varfit;
//						seg[idVeh].vioCAP += seg[idVeh].Trip[idTripI].vioCAP;
//						seg[idVeh].vioTWC += seg[idVeh].Trip[idTripI].vioTWC;
//						seg[idVeh].vioTWSP += varvioTWSP;
//						cost += varcost; fitness += varfit;
//						vioCAP += seg[idVeh].Trip[idTripI].vioCAP;
//						vioTWC += seg[idVeh].Trip[idTripI].vioTWC;
//						vioTWSP += varvioTWSP;
//
//						seg[idVeh].Trip[nextT].leaveSP = problem->leaveSP[assSPnextT][1]; //load only at eTW2
//						UpdateVehicle(idVeh, nextT, assSPnextT, seg[idVeh].Trip[nextT].leaveSP, 0, seg[idVeh].numTrips - 1); //varvioCAP = 0
//					}
//				}
//				else //go through WS:
//				{
//					seg[idVeh].Trip[idTripI].connectCost = problem->disCWSSP[assSPI][assSPnextT];
//					varC += problem->disCWSSP[assSPI][assSPnextT];
//					seg[idVeh].Trip[idTripI].waitingS1 = problem->CWSSP[assSPI][assSPnextT];
//					seg[idVeh].Trip[idTripI].cost += varC;
//					seg[idVeh].Trip[idTripI].fitness += varC;
//
//					seg[idVeh].Trip[nextT].vioTWSP = 0;
//					double COEFvioTWSP = (VTWSP * varvioTWSP);
//					seg[idVeh].Trip[nextT].fitness +=  COEFvioTWSP;
//
//					double varfit = varcostpreT + seg[idVeh].Trip[idTripI].fitness + COEFvioTWSP;
//					double varcost = varcostpreT + seg[idVeh].Trip[idTripI].cost;
//					varvioTWSP += seg[idVeh].Trip[idTripI].vioTWSP;
//					seg[idVeh].cost += varcost;
//					seg[idVeh].fitness += varfit;
//					seg[idVeh].vioCAP += seg[idVeh].Trip[idTripI].vioCAP;
//					seg[idVeh].vioTWC += seg[idVeh].Trip[idTripI].vioTWC;
//					seg[idVeh].vioTWSP += varvioTWSP;
//					cost += varcost; fitness += varfit;
//					vioCAP += seg[idVeh].Trip[idTripI].vioCAP;
//					vioTWC += seg[idVeh].Trip[idTripI].vioTWC;
//					vioTWSP += varvioTWSP;
//
//					seg[idVeh].Trip[nextT].leaveSP = PDS_MAX(cArrTimeI, problem->nodeSP[assSPnextT].sTW2) + problem->nodeSP[assSPnextT].load;
//					UpdateVehicle(idVeh, nextT, assSPnextT, seg[idVeh].Trip[nextT].leaveSP, 0, seg[idVeh].numTrips - 1); //varvioCAP = 0
//				}
//			}
//		}
//	}//end assSPI != assSPnextT
//}
//
//void Solution::UpdateVehicle_CONNECTAtSP_DD_InsertDT(int idVeh, int nextT, int idTripI, double varcostpreT) //for subInsertDeliveryTrip
//{
//	//For Insert Delivery Trip
//	//Calculate the connection from deltrip(idVeh, idTripI) to del trip (idVeh, nextT) and go through vehicle, update all INFORMATION of vehicle idVeh
//    //varcostpreT is variation of cost for the trips before (idVeh, idTripI)
//
//	int lastCpreT = seg[idVeh].Trip[idTripI].lastCus;
//	int assSPnextT = seg[idVeh].Trip[nextT].assSP;
//	double varvioTWSP = -seg[idVeh].Trip[nextT].vioTWSP;
//    double varC = -seg[idVeh].Trip[idTripI].connectCost;
//
//	double cArrTime = seg[idVeh].Trip[idTripI].endS + problem->c[lastCpreT][assSPnextT];
//	if (PDSINRANGE(cArrTime, problem->nodeSP[assSPnextT].sTW2, problem->nodeSP[assSPnextT].eTW2))
//	{
//		seg[idVeh].Trip[idTripI].connectCost = problem->c[lastCpreT][assSPnextT];
//		varC += problem->c[lastCpreT][assSPnextT];
//		seg[idVeh].Trip[idTripI].waitingS = NO_WS;
//		seg[idVeh].Trip[idTripI].cost += varC;
//		seg[idVeh].Trip[idTripI].fitness += varC;
//
//		double varfit = varcostpreT + seg[idVeh].Trip[idTripI].fitness;
//		double varcost = varcostpreT + seg[idVeh].Trip[idTripI].cost;
//		seg[idVeh].cost += varcost;
//		seg[idVeh].fitness += varfit;
//		seg[idVeh].vioCAP += seg[idVeh].Trip[idTripI].vioCAP;
//		seg[idVeh].vioTWC += seg[idVeh].Trip[idTripI].vioTWC;
//		seg[idVeh].vioTWSP += seg[idVeh].Trip[idTripI].vioTWSP;
//		cost += varcost; fitness += varfit;
//		vioCAP += seg[idVeh].Trip[idTripI].vioCAP;
//		vioTWC += seg[idVeh].Trip[idTripI].vioTWC;
//		vioTWSP += seg[idVeh].Trip[idTripI].vioTWSP;
//		
//		seg[idVeh].Trip[nextT].vioTWSP = 0;
//		seg[idVeh].Trip[nextT].fitness += (VTWSP *varvioTWSP);
//		//before delete: go to sp directly or through WS:
//		seg[idVeh].Trip[nextT].leaveSP = cArrTime + problem->nodeSP[assSPnextT].load;
//		UpdateVehicle(idVeh, nextT, assSPnextT, seg[idVeh].Trip[nextT].leaveSP, 0, seg[idVeh].numTrips - 1); //varvioCAP = 0
//	}
//	else
//	{
//			double temp = cArrTime - problem->nodeSP[assSPnextT].eTW2;
//			if (temp > eps) 
//			{
//				seg[idVeh].Trip[idTripI].connectCost = problem->c[lastCpreT][assSPnextT];
//				varC += problem->c[lastCpreT][assSPnextT];
//				seg[idVeh].Trip[idTripI].waitingS = NO_WS;
//				seg[idVeh].Trip[idTripI].cost += varC;
//				seg[idVeh].Trip[idTripI].fitness += varC;
//
//				varvioTWSP += temp;
//				if (seg[idVeh].Trip[nextT].vioTWSP > eps) //before also vioTWSP --> don't need to update all remaining trips
//				{
//					seg[idVeh].Trip[nextT].vioTWSP = temp;
//					double COEFvioTWSP = (VTWSP * varvioTWSP);
//					seg[idVeh].Trip[nextT].fitness +=  COEFvioTWSP;
//
//					double varfit = varcostpreT + seg[idVeh].Trip[idTripI].fitness + COEFvioTWSP;
//					double varcost = varcostpreT + seg[idVeh].Trip[idTripI].cost;
//					varvioTWSP += seg[idVeh].Trip[idTripI].vioTWSP;
//					seg[idVeh].cost += varcost;
//					seg[idVeh].fitness += varfit;
//					seg[idVeh].vioCAP += seg[idVeh].Trip[idTripI].vioCAP;
//					seg[idVeh].vioTWC += seg[idVeh].Trip[idTripI].vioTWC;
//					seg[idVeh].vioTWSP += varvioTWSP;
//					cost += varcost; fitness += varfit;
//					vioCAP += seg[idVeh].Trip[idTripI].vioCAP;
//					vioTWC += seg[idVeh].Trip[idTripI].vioTWC;
//					vioTWSP += varvioTWSP;
//				}
//				else //need to update all remaining trips:
//				{
//					seg[idVeh].Trip[nextT].vioTWSP = temp;
//					double COEFvioTWSP = (VTWSP * varvioTWSP);
//					seg[idVeh].Trip[nextT].fitness +=  COEFvioTWSP;
//
//					double varfit = varcostpreT + seg[idVeh].Trip[idTripI].fitness + COEFvioTWSP;
//					double varcost = varcostpreT + seg[idVeh].Trip[idTripI].cost;
//					varvioTWSP += seg[idVeh].Trip[idTripI].vioTWSP;
//					seg[idVeh].cost += varcost;
//					seg[idVeh].fitness += varfit;
//					seg[idVeh].vioCAP += seg[idVeh].Trip[idTripI].vioCAP;
//					seg[idVeh].vioTWC += seg[idVeh].Trip[idTripI].vioTWC;
//					seg[idVeh].vioTWSP += varvioTWSP;
//					cost += varcost; fitness += varfit;
//					vioCAP += seg[idVeh].Trip[idTripI].vioCAP;
//					vioTWC += seg[idVeh].Trip[idTripI].vioTWC;
//					vioTWSP += varvioTWSP;
//
//					seg[idVeh].Trip[nextT].leaveSP = problem->leaveSP[assSPnextT][1]; //load only at eTW2
//					UpdateVehicle(idVeh, nextT, assSPnextT, seg[idVeh].Trip[nextT].leaveSP, 0, seg[idVeh].numTrips - 1); //varvioCAP = 0
//				}
//			}
//			else
//			{
//				double cArrTimeI = seg[idVeh].Trip[idTripI].endS + problem->disCWSSP[lastCpreT][assSPnextT];
//				temp = cArrTimeI - problem->nodeSP[assSPnextT].eTW2;
//				if (temp > eps) //too soon to sp directly; too late through WS:
//				{
//					seg[idVeh].Trip[idTripI].connectCost = problem->c[lastCpreT][assSPnextT];
//					varC += problem->c[lastCpreT][assSPnextT];
//					seg[idVeh].Trip[idTripI].waitingS = NO_WS;
//					seg[idVeh].Trip[idTripI].cost += varC;
//					seg[idVeh].Trip[idTripI].fitness += varC;
//
//					//before delete: to sp directly FEA OR INF or through WS:
//					temp = problem->nodeSP[assSPnextT].sTW2 - cArrTime;
//					varvioTWSP += temp;
//					if (seg[idVeh].Trip[nextT].vioTWSP > eps) //before also vioTWSP --> don't need to update all remaining trips
//					{
//						seg[idVeh].Trip[nextT].vioTWSP = temp;
//						double COEFvioTWSP = (VTWSP * varvioTWSP);
//						seg[idVeh].Trip[nextT].fitness +=  COEFvioTWSP;
//
//						double varfit = varcostpreT + seg[idVeh].Trip[idTripI].fitness + COEFvioTWSP;
//						double varcost = varcostpreT + seg[idVeh].Trip[idTripI].cost;
//						varvioTWSP += seg[idVeh].Trip[idTripI].vioTWSP;
//						seg[idVeh].cost += varcost;
//						seg[idVeh].fitness += varfit;
//						seg[idVeh].vioCAP += seg[idVeh].Trip[idTripI].vioCAP;
//						seg[idVeh].vioTWC += seg[idVeh].Trip[idTripI].vioTWC;
//						seg[idVeh].vioTWSP += varvioTWSP;
//						cost += varcost; fitness += varfit;
//						vioCAP += seg[idVeh].Trip[idTripI].vioCAP;
//						vioTWC += seg[idVeh].Trip[idTripI].vioTWC;
//						vioTWSP += varvioTWSP;
//					}
//					else //need to update all remaining trips:
//					{
//						seg[idVeh].Trip[nextT].vioTWSP = temp;
//
//						double COEFvioTWSP = (VTWSP * varvioTWSP);
//						seg[idVeh].Trip[nextT].fitness +=  COEFvioTWSP;
//
//						double varfit = varcostpreT + seg[idVeh].Trip[idTripI].fitness + COEFvioTWSP;
//						double varcost = varcostpreT + seg[idVeh].Trip[idTripI].cost;
//						varvioTWSP += seg[idVeh].Trip[idTripI].vioTWSP;
//						seg[idVeh].cost += varcost;
//						seg[idVeh].fitness += varfit;
//						seg[idVeh].vioCAP += seg[idVeh].Trip[idTripI].vioCAP;
//						seg[idVeh].vioTWC += seg[idVeh].Trip[idTripI].vioTWC;
//						seg[idVeh].vioTWSP += varvioTWSP;
//						cost += varcost; fitness += varfit;
//						vioCAP += seg[idVeh].Trip[idTripI].vioCAP;
//						vioTWC += seg[idVeh].Trip[idTripI].vioTWC;
//						vioTWSP += varvioTWSP;
//
//						seg[idVeh].Trip[nextT].leaveSP = problem->leaveSP[assSPnextT][1]; //load only at eTW2
//						UpdateVehicle(idVeh, nextT, assSPnextT, seg[idVeh].Trip[nextT].leaveSP, 0, seg[idVeh].numTrips - 1); //varvioCAP = 0
//					}
//				}
//				else //through WS:
//				{
//					seg[idVeh].Trip[idTripI].connectCost = problem->disCWSSP[lastCpreT][assSPnextT];
//					varC += problem->disCWSSP[lastCpreT][assSPnextT];
//					seg[idVeh].Trip[idTripI].waitingS = problem->CWSSP[lastCpreT][assSPnextT];
//					seg[idVeh].Trip[idTripI].cost += varC;
//					seg[idVeh].Trip[idTripI].fitness += varC;
//
//					//before delete: to sp directly FEA or INF or through WS:
//					seg[idVeh].Trip[nextT].vioTWSP = 0;
//					double COEFvioTWSP = (VTWSP * varvioTWSP);
//					seg[idVeh].Trip[nextT].fitness +=  COEFvioTWSP;
//
//					double varfit = varcostpreT + seg[idVeh].Trip[idTripI].fitness + COEFvioTWSP;
//					double varcost = varcostpreT + seg[idVeh].Trip[idTripI].cost;
//					varvioTWSP += seg[idVeh].Trip[idTripI].vioTWSP;
//					seg[idVeh].cost += varcost;
//					seg[idVeh].fitness += varfit;
//					seg[idVeh].vioCAP += seg[idVeh].Trip[idTripI].vioCAP;
//					seg[idVeh].vioTWC += seg[idVeh].Trip[idTripI].vioTWC;
//					seg[idVeh].vioTWSP += varvioTWSP;
//					cost += varcost; fitness += varfit;
//					vioCAP += seg[idVeh].Trip[idTripI].vioCAP;
//					vioTWC += seg[idVeh].Trip[idTripI].vioTWC;
//					vioTWSP += varvioTWSP;
//
//					seg[idVeh].Trip[nextT].leaveSP = PDS_MAX(cArrTimeI, problem->nodeSP[assSPnextT].sTW2) + problem->nodeSP[assSPnextT].load;
//					UpdateVehicle(idVeh, nextT, assSPnextT, seg[idVeh].Trip[nextT].leaveSP, 0, seg[idVeh].numTrips - 1); //varvioCAP = 0
//				}
//			}
//		}
//}
//
//void Solution::UpdateVehicle_CONNECTAtSP_DD_InsertDT(int idVehI, int preTI, int nextTI) //for InsertDeliveryTrip
//{
//	int idTripI = preTI + 1;
//	//Insert deltrip (idVehI, idTripI) between deltrip (idVehI, preTI) and pick/del trip (idVehI, nextTI)
//	//If nextTI < 0 --> preTI is the last trip
//
//	int lastCpreT = seg[idVehI].Trip[preTI].lastCus;
//	int assSPI = seg[idVehI].Trip[idTripI].assSP;
//	double varvioTWSP = -seg[idVehI].Trip[idTripI].vioTWSP;
//    double varcost = -seg[idVehI].Trip[preTI].connectCost;
//	double cStartS;
//
//	double cArrTime = seg[idVehI].Trip[preTI].endS + problem->c[lastCpreT][assSPI];
//	if (PDSINRANGE(cArrTime, problem->nodeSP[assSPI].sTW2, problem->nodeSP[assSPI].eTW2))
//	{
//		seg[idVehI].Trip[preTI].connectCost = problem->c[lastCpreT][assSPI];
//		varcost += problem->c[lastCpreT][assSPI];
//		seg[idVehI].Trip[preTI].waitingS = NO_WS;
//		seg[idVehI].Trip[preTI].cost += varcost;
//		seg[idVehI].Trip[preTI].fitness += varcost;
//
//		seg[idVehI].Trip[idTripI].vioTWSP = 0;
//		seg[idVehI].Trip[idTripI].fitness += (VTWSP *varvioTWSP);
//		//before delete: go to sp directly or through WS:
//		cStartS = cArrTime + problem->nodeSP[assSPI].load;
//		subInsertDeliveryTrip(idVehI,idTripI,nextTI,cStartS,varcost);
//	}
//	else
//	{
//			double temp = cArrTime - problem->nodeSP[assSPI].eTW2;
//			if (temp > eps) 
//			{
//				seg[idVehI].Trip[preTI].connectCost = problem->c[lastCpreT][assSPI];
//				varcost += problem->c[lastCpreT][assSPI];
//				seg[idVehI].Trip[preTI].waitingS = NO_WS;
//				seg[idVehI].Trip[preTI].cost += varcost;
//				seg[idVehI].Trip[preTI].fitness += varcost;
//
//				varvioTWSP += temp;
//				seg[idVehI].Trip[idTripI].vioTWSP = temp;
//				seg[idVehI].Trip[idTripI].fitness += (VTWSP *varvioTWSP);
//				cStartS = problem->leaveSP[assSPI][1]; //load at eTW2
//				subInsertDeliveryTrip(idVehI,idTripI,nextTI,cStartS,varcost);
//			}
//			else
//			{
//				double cArrTimeI = seg[idVehI].Trip[preTI].endS + problem->disCWSSP[lastCpreT][assSPI];
//				temp = cArrTimeI - problem->nodeSP[assSPI].eTW2;
//				if (temp > eps) //too soon to sp directly; too late through WS:
//				{
//					seg[idVehI].Trip[preTI].connectCost = problem->c[lastCpreT][assSPI];
//					varcost += problem->c[lastCpreT][assSPI];
//					seg[idVehI].Trip[preTI].waitingS = NO_WS;
//					seg[idVehI].Trip[preTI].cost += varcost;
//					seg[idVehI].Trip[preTI].fitness += varcost;
//
//					//before delete: to sp directly FEA OR INF or through WS:
//					temp = problem->nodeSP[assSPI].sTW2 - cArrTime;
//					varvioTWSP += temp;
//					seg[idVehI].Trip[idTripI].vioTWSP = temp;
//					seg[idVehI].Trip[idTripI].fitness += (VTWSP * varvioTWSP);
//					cStartS = problem->leaveSP[assSPI][1]; //load at eTW2
//					subInsertDeliveryTrip(idVehI,idTripI,nextTI,cStartS,varcost);
//				}
//				else //through WS:
//				{
//					seg[idVehI].Trip[preTI].connectCost = problem->disCWSSP[lastCpreT][assSPI];
//					varcost += problem->disCWSSP[lastCpreT][assSPI];
//					seg[idVehI].Trip[preTI].waitingS = problem->CWSSP[lastCpreT][assSPI];
//					seg[idVehI].Trip[preTI].cost += varcost;
//					seg[idVehI].Trip[preTI].fitness += varcost;
//
//					//before delete: to sp directly FEA or INF or through WS:
//					seg[idVehI].Trip[idTripI].vioTWSP = 0;
//					seg[idVehI].Trip[idTripI].fitness += (VTWSP * varvioTWSP);
//					cStartS = PDS_MAX(cArrTimeI, problem->nodeSP[assSPI].sTW2) + problem->nodeSP[assSPI].load;
//					subInsertDeliveryTrip(idVehI,idTripI,nextTI,cStartS,varcost);
//				}
//			}
//		}
//}
//
//void Solution::UpdateVehicle_CONNECTAtSP_PD_InsertDT(int idVehI, int preTI, int nextTI) //for InsertDeliveryTrip
//{
//	int idTripI = preTI + 1;
//	//Insert deltrip (idVehI, idTripI) between pickuptrip (idVehI, preTI) and pick/del trip (idVehI, nextTI)
//	//If nextTI < 0 --> preTI is the last trip
//
//	int assSPI = seg[idVehI].Trip[idTripI].assSP;
//	int assSPpreT = seg[idVehI].Trip[preTI].assSP;
//	double varcost, cStartS;
//
//	if (assSPI == assSPpreT) //create new p-d same trip
//	{
//		seg[idVehI].Trip[idTripI].coordinate = 1;
//		varcost = -seg[idVehI].Trip[preTI].connectCost;
//		seg[idVehI].Trip[preTI].connectCost = 0;
//		seg[idVehI].Trip[preTI].cost += varcost;
//		seg[idVehI].Trip[preTI].fitness += varcost;
//		seg[idVehI].Trip[preTI].waitingS1 = NO_WS;
//
//		double varvioTWSP = seg[idVehI].Trip[preTI].vioTWSP - seg[idVehI].Trip[idTripI].vioTWSP;
//		seg[idVehI].Trip[idTripI].vioTWSP = seg[idVehI].Trip[preTI].vioTWSP;
//		seg[idVehI].Trip[idTripI].fitness += (VTWSP * varvioTWSP);
//		if (seg[idVehI].Trip[idTripI].vioTWSP > eps) cStartS = problem->leaveSP[assSPI][1]; //load at eTW2
//		else cStartS = seg[idVehI].Trip[preTI].leaveSP + problem->nodeSP[assSPI].load;
//		subInsertDeliveryTrip(idVehI,idTripI, nextTI,cStartS, varcost);
//	}
//	else //p - assSPpreT - assSPI - d
//	{
//		double varvioTWSP = -seg[idVehI].Trip[idTripI].vioTWSP;
//		double varcost = -seg[idVehI].Trip[preTI].connectCost;
//		double cStartS;
//
//		double cArrTime = seg[idVehI].Trip[preTI].leaveSP + problem->c[assSPpreT][assSPI];
//		if (PDSINRANGE(cArrTime, problem->nodeSP[assSPI].sTW2, problem->nodeSP[assSPI].eTW2))
//		{
//			seg[idVehI].Trip[preTI].connectCost = problem->c[assSPpreT][assSPI];
//			varcost += problem->c[assSPpreT][assSPI];
//			seg[idVehI].Trip[preTI].waitingS1 = NO_WS;
//			seg[idVehI].Trip[preTI].cost += varcost;
//			seg[idVehI].Trip[preTI].fitness += varcost;
//
//			seg[idVehI].Trip[idTripI].vioTWSP = 0;
//			seg[idVehI].Trip[idTripI].fitness += (VTWSP *varvioTWSP);
//			//before delete: go to sp directly or through WS:
//			cStartS = cArrTime + problem->nodeSP[assSPI].load;
//			subInsertDeliveryTrip(idVehI,idTripI,nextTI,cStartS,varcost);
//		}
//		else
//		{
//				double temp = cArrTime - problem->nodeSP[assSPI].eTW2;
//				if (temp > eps) 
//				{
//					seg[idVehI].Trip[preTI].connectCost = problem->c[assSPpreT][assSPI];
//					varcost += problem->c[assSPpreT][assSPI];
//					seg[idVehI].Trip[preTI].waitingS1 = NO_WS;
//					seg[idVehI].Trip[preTI].cost += varcost;
//					seg[idVehI].Trip[preTI].fitness += varcost;
//
//					varvioTWSP += temp;
//					seg[idVehI].Trip[idTripI].vioTWSP = temp;
//					seg[idVehI].Trip[idTripI].fitness += (VTWSP *varvioTWSP);
//					cStartS = problem->leaveSP[assSPI][1]; //load at eTW2
//					subInsertDeliveryTrip(idVehI,idTripI,nextTI,cStartS,varcost);
//				}
//				else
//				{
//					double cArrTimeI = seg[idVehI].Trip[preTI].leaveSP + problem->disCWSSP[assSPpreT][assSPI];
//					temp = cArrTimeI - problem->nodeSP[assSPI].eTW2;
//					if (temp > eps) //too soon to sp directly; too late through WS:
//					{
//						seg[idVehI].Trip[preTI].connectCost = problem->c[assSPpreT][assSPI];
//						varcost += problem->c[assSPpreT][assSPI];
//						seg[idVehI].Trip[preTI].waitingS1 = NO_WS;
//						seg[idVehI].Trip[preTI].cost += varcost;
//						seg[idVehI].Trip[preTI].fitness += varcost;
//
//						//before delete: to sp directly FEA OR INF or through WS:
//						temp = problem->nodeSP[assSPI].sTW2 - cArrTime;
//						varvioTWSP += temp;
//						seg[idVehI].Trip[idTripI].vioTWSP = temp;
//						seg[idVehI].Trip[idTripI].fitness += (VTWSP * varvioTWSP);
//						cStartS = problem->leaveSP[assSPI][1]; //load at eTW2
//						subInsertDeliveryTrip(idVehI,idTripI,nextTI,cStartS,varcost);
//					}
//					else //through WS:
//					{
//						seg[idVehI].Trip[preTI].connectCost = problem->disCWSSP[assSPpreT][assSPI];
//						varcost += problem->disCWSSP[assSPpreT][assSPI];
//						seg[idVehI].Trip[preTI].waitingS1 = problem->CWSSP[assSPpreT][assSPI];
//						seg[idVehI].Trip[preTI].cost += varcost;
//						seg[idVehI].Trip[preTI].fitness += varcost;
//
//						//before delete: to sp directly FEA or INF or through WS:
//						seg[idVehI].Trip[idTripI].vioTWSP = 0;
//						seg[idVehI].Trip[idTripI].fitness += (VTWSP * varvioTWSP);
//						cStartS = PDS_MAX(cArrTimeI, problem->nodeSP[assSPI].sTW2) + problem->nodeSP[assSPI].load;
//						subInsertDeliveryTrip(idVehI,idTripI,nextTI,cStartS,varcost);
//					}
//				}
//			}
//	}//end p - assSPpreT - assSPI - d
//}
//
//
//void Solution::insertCusDArrayPre(int idVehI, int idTripI, int idVehM, int idTripM) //assSPI - d + (assSPM - d)
//{
//	//COPY twoOPTstarCusDTrip
//    //insert array of delivery customer in trip (idVehM, idTripM) after the last cus of (idVehI, idTripI)
//
//	 int assSP = seg[idVehI].Trip[idTripI].assSP;
//	 int lastCOLDI = seg[idVehI].Trip[idTripI].lastCus;
//	 int lastCOLDM = seg[idVehM].Trip[idTripM].lastCus;
//	 int firstCM = seg[idVehM].Trip[idTripM].firstCus;
//	 double COSTOLDI = seg[idVehI].Trip[idTripI].cost;
//
//	 //1. vioCAP,capacity:
//	 seg[idVehI].Trip[idTripI].capacity += seg[idVehM].Trip[idTripM].capacity;
//	 int vioCAPNEW = PDS_MAX(seg[idVehI].Trip[idTripI].capacity - problem->Q, 0);
//	 int varvioCAPI = vioCAPNEW - seg[idVehI].Trip[idTripI].vioCAP;
//	 seg[idVehI].Trip[idTripI].vioCAP = vioCAPNEW;
//	 
//	 double cArrTime, cStartS, temp, varvioTWC, varcostI;
//     int id,preID, nextID;
//
//	 //2. Update nextArr, predArr, firstCus, lastCus
//	 nextArr[lastCOLDI] = firstCM; predArr[firstCM] = lastCOLDI;
//	 seg[idVehI].Trip[idTripI].lastCus = lastCOLDM;
//
//	 seg[idVehI].Trip[idTripI].numCus += seg[idVehM].Trip[idTripM].numCus;
//
//	 double COSTI = seg[idVehI].Trip[idTripI].cost + seg[idVehM].Trip[idTripM].cost - seg[idVehI].Trip[idTripI].connectCost - seg[idVehM].Trip[idTripM].connectCost;
//	 if (idTripM == 0) COSTI -= problem->c[0][assSP];
//	 COSTI += (problem->c[lastCOLDI][firstCM] - problem->c[assSP][firstCM]);
//     
//	 //For the trip contain j:
//	 cStartS = depart[lastCOLDI]; preID = lastCOLDI; nextID = firstCM;
//	 int nextTrip = idTripI+1;
//	 if (nextTrip == seg[idVehI].numTrips) //idTripI is the last trip
//	 {
// 		 while (nextID > 0) 
//		 {
//			   cArrTime = cStartS + problem->c[preID][nextID];
//			   cStartS = PDS_MAX(cArrTime, problem->node[nextID].sTW);
//			   if (PDSDIF(cStartS, startS[nextID])==0) //it means varvioTWCus[nextID] = 0 
//			   {
//				   temp = cStartS - problem->node[nextID].eTW;
//				   if (temp > eps) vioTWCus[nextID] = temp;
//				   else vioTWCus[nextID] = 0;
//
//				   //Update BvioTWCus from nextID to firstCus
//					//Update BCAP from lastCOLDi to firstCus
//					//Update FCAP, FvioTWCus from nextID to lastCus
//					//Update trip_num, route_num,pos from nextID to lastCus
//					id = nextArr[nextID];
//					if (id < 0) BvioTWCus[nextID] = vioTWCus[nextID];
//					else BvioTWCus[nextID] = BvioTWCus[id] + vioTWCus[nextID];
//
//				    id = nextID;
//				    while (preID != lastCOLDI)
//				    {
//					   BvioTWCus[preID] = BvioTWCus[id] + vioTWCus[preID];
//					   id = preID; preID = predArr[preID];
//				    }
//
//				   do
//				   {
//					   BvioTWCus[preID] = BvioTWCus[id] + vioTWCus[preID];
//					   BCAP[preID] = BCAP[id] + problem->node[preID].capacity;
//					   id = preID; preID = predArr[preID];
//				   }while (preID > 0);
//				   id = nextID; preID = predArr[id];
//				   do
//				   {
//					   route_num[id] = idVehI; trip_num[id] = idTripI;
//					   pos[id] = pos[preID] + 1;
//					   FCAP[id] = FCAP[preID] + problem->node[id].capacity;
//					   FvioTWCus[id] = FvioTWCus[preID] + vioTWCus[id];
//					   preID = id; id = nextArr[id];
//				   }while (id > 0);
//				   //preID now points to lastCus:
//				   varvioTWC = seg[idVehI].Trip[idTripI].vioTWC - FvioTWCus[preID];
//				   seg[idVehI].Trip[idTripI].vioTWC = FvioTWCus[preID];
//				   seg[idVehI].Trip[idTripI].endS = depart[preID];
//				   goto Update;
//			   }
//			   temp = cStartS - problem->node[nextID].eTW;
//			   if (temp > eps)
//			   {
//					if (vioTWCus[nextID] > eps) 
//					{
//						vioTWCus[nextID] = temp;
//						//Update BvioTWCus from nextID to firstCus
//						//Update BCAP from lastCOLDI to firstCus
//						//Update FCAP, FvioTWCus from nextID to lastCus
//						//Update trip_num, route_num,pos from nextID to lastCus
//						id = nextArr[nextID];
//						if (id < 0) BvioTWCus[nextID] = vioTWCus[nextID];
//						else BvioTWCus[nextID] = BvioTWCus[id] + vioTWCus[nextID];
//
//					    id = nextID;
//					    while (preID != lastCOLDI)
//					    {
//						   BvioTWCus[preID] = BvioTWCus[id] + vioTWCus[preID];
//						   id = preID; preID = predArr[preID];
//					    }
//					    do
//					    {
//						   BvioTWCus[preID] = BvioTWCus[id] + vioTWCus[preID];
//						   BCAP[preID] = BCAP[id] + problem->node[preID].capacity;
//						   id = preID; preID = predArr[preID];
//					    }while (preID > 0);
//					    id = nextID; preID = predArr[id];
//					    do
//					    {
//						   route_num[id] = idVehI; trip_num[id] = idTripI;
//						   pos[id] = pos[preID] + 1;
//						   FCAP[id] = FCAP[preID] + problem->node[id].capacity;
//						   FvioTWCus[id] = FvioTWCus[preID] + vioTWCus[id];
//						   preID = id; id = nextArr[id];
//					    }while (id > 0);
//					    //preID now points to lastCus:
//					    varvioTWC = seg[idVehI].Trip[idTripI].vioTWC - FvioTWCus[preID];
//					    seg[idVehI].Trip[idTripI].vioTWC = FvioTWCus[preID];
//						seg[idVehI].Trip[idTripI].endS = depart[preID];
//						goto Update;
//					}
//					vioTWCus[nextID] = temp;
//					FvioTWCus[nextID] = FvioTWCus[preID] + temp;
//					cStartS = problem->node[nextID].eTW;
//			   }
//			   else 
//			   {
//					vioTWCus[nextID] = 0;
//					FvioTWCus[nextID] = FvioTWCus[preID];
//			   }
//			   startS[nextID] = cStartS;
//			   cStartS += problem->node[nextID].duration;
//			   depart[nextID] = cStartS;
//			   FCAP[nextID] = FCAP[preID] + problem->node[nextID].capacity;
//			   route_num[nextID] = idVehI; trip_num[nextID] = idTripI;
//			   pos[nextID] = pos[preID] + 1;
//			   preID = nextID; nextID = nextArr[nextID];
//		 }
//		 seg[idVehI].Trip[idTripI].endS = cStartS;
//		 varvioTWC = FvioTWCus[preID] - seg[idVehI].Trip[idTripI].vioTWC;
//		 seg[idVehI].Trip[idTripI].vioTWC = FvioTWCus[preID];
//		//preID now points to the last cus:
//		 //seg[idVehj].Trip[idTripj].connectCost = problem->c[preID][0];
//
//		 //Update BCAP from lastCOLDI to firstCus
//		 //Update BvioTWCus from lastCus to firstCus
//		 BvioTWCus[preID] = vioTWCus[preID];
//		 id = predArr[preID];
//		 while (id != lastCOLDI)
//		 {
//			BvioTWCus[id] = BvioTWCus[preID] + vioTWCus[id];
//			preID = id; id = predArr[id];
//		}
//		BvioTWCus[lastCOLDI] = BvioTWCus[preID] + vioTWCus[lastCOLDI];
//		BCAP[lastCOLDI] = BCAP[preID] + problem->node[lastCOLDI].capacity;
//		id = predArr[lastCOLDI]; preID = lastCOLDI;
//		while (id > 0)
//		{
//			BvioTWCus[id] = BvioTWCus[preID] + vioTWCus[id];
//			BCAP[id] = BCAP[preID] + problem->node[id].capacity;
//			preID = id; id = predArr[id];
//		}
//
//		Update:
//		    COSTI += problem->c[lastCOLDM][0];
//			seg[idVehI].Trip[idTripI].connectCost = problem->c[lastCOLDM][0];
//			seg[idVehI].Trip[idTripI].cost = COSTI;
//			varcostI = COSTI - COSTOLDI;
//			double varFIT = varcostI + VCAP * varvioCAPI + VTWCUS * varvioTWC;
//			if (seg[idVehI].Trip[idTripI].vioTWC > eps || seg[idVehI].Trip[idTripI].vioCAP > 0 || seg[idVehI].Trip[idTripI].vioTWSP > eps)
//			{
//				seg[idVehI].Trip[idTripI].feasible = 0;
//				seg[idVehI].Trip[idTripI].fitness +=  varFIT;
//			}
//			else
//			{
//				seg[idVehI].Trip[idTripI].feasible = 1;
//				seg[idVehI].Trip[idTripI].fitness = seg[idVehI].Trip[idTripI].cost;
//			}
//			seg[idVehI].cost += varcostI; seg[idVehI].fitness += varFIT; 
//			seg[idVehI].vioCAP += varvioCAPI; seg[idVehI].vioTWC += varvioTWC;
//			cost += varcostI; fitness += varFIT; vioCAP += varvioCAPI; vioTWC += varvioTWC;
//	 }
//	 else //idTripI is not the last trip
//	 {
// 		 while (nextID > 0) 
//		 {
//			   cArrTime = cStartS + problem->c[preID][nextID];
//			   cStartS = PDS_MAX(cArrTime, problem->node[nextID].sTW);
//			   if (PDSDIF(cStartS, startS[nextID])==0) //it means varvioTWCus[nextID] = 0 
//			   {
//				   temp = cStartS - problem->node[nextID].eTW;
//				   if (temp > eps) vioTWCus[nextID] = temp;
//				   else vioTWCus[nextID] = 0;
//
//				   //Update BvioTWCus from nextID to firstCus
//					//Update BCAP from lastCOLDI to firstCus
//					//Update FCAP, FvioTWCus from nextID to lastCus
//					//Update trip_num, route_num from nextID to lastCus
//					id = nextArr[nextID];
//					if (id < 0) BvioTWCus[nextID] = vioTWCus[nextID];
//					else BvioTWCus[nextID] = BvioTWCus[id] + vioTWCus[nextID];
//
//				    id = nextID;
//				    while (preID != lastCOLDI)
//				    {
//					   BvioTWCus[preID] = BvioTWCus[id] + vioTWCus[preID];
//					   id = preID; preID = predArr[preID];
//				    }
//				   
//				   do
//				   {
//					   BvioTWCus[preID] = BvioTWCus[id] + vioTWCus[preID];
//					   BCAP[preID] = BCAP[id] + problem->node[preID].capacity;
//					   id = preID; preID = predArr[preID];
//				   }while (preID > 0);
//				   id = nextID; preID = predArr[id];
//				   do
//				   {
//					   route_num[id] = idVehI; trip_num[id] = idTripI;
//					   pos[id] = pos[preID] + 1;
//					   FCAP[id] = FCAP[preID] + problem->node[id].capacity;
//					   FvioTWCus[id] = FvioTWCus[preID] + vioTWCus[id];
//					   preID = id; id = nextArr[id];
//				   }while (id > 0);
//				   //preID now points to lastCus:
//				   varvioTWC = seg[idVehI].Trip[idTripI].vioTWC - FvioTWCus[preID];
//				   seg[idVehI].Trip[idTripI].vioTWC = FvioTWCus[preID];
//				   seg[idVehI].Trip[idTripI].endS = depart[preID];
//				   goto Update1;
//			   }
//			   temp = cStartS - problem->node[nextID].eTW;
//			   if (temp > eps)
//			   {
//					if (vioTWCus[nextID] > eps) 
//					{
//						vioTWCus[nextID] = temp;
//						//Update BvioTWCus from nextID to firstCus
//						//Update BCAP from lastCOLDI to firstCus
//						//Update FCAP, FvioTWCus from nextID to lastCus
//						//Update trip_num, route_num fro nextID to lastCus
//		
//						id = nextArr[nextID];
//						if (id < 0) BvioTWCus[nextID] = vioTWCus[nextID];
//						else BvioTWCus[nextID] = BvioTWCus[id] + vioTWCus[nextID];
//
//					    id = nextID;
//					    while (preID != lastCOLDI)
//					    {
//						   BvioTWCus[preID] = BvioTWCus[id] + vioTWCus[preID];
//						   id = preID; preID = predArr[preID];
//					    }
//					    do
//					    {
//						   BvioTWCus[preID] = BvioTWCus[id] + vioTWCus[preID];
//						   BCAP[preID] = BCAP[id] + problem->node[preID].capacity;
//						   id = preID; preID = predArr[preID];
//					    }while (preID > 0);
//					    id = nextID; preID = predArr[id];
//					    do
//					    {
//						   route_num[id] = idVehI; trip_num[id] = idTripI;
//						   pos[id] = pos[preID] + 1;
//						   FCAP[id] = FCAP[preID] + problem->node[id].capacity;
//						   FvioTWCus[id] = FvioTWCus[preID] + vioTWCus[id];
//						   preID = id; id = nextArr[id];
//					    }while (id > 0);
//					    //preID now points to lastCus:
//					    varvioTWC = seg[idVehI].Trip[idTripI].vioTWC - FvioTWCus[preID];
//					    seg[idVehI].Trip[idTripI].vioTWC = FvioTWCus[preID];
//					    seg[idVehI].Trip[idTripI].endS = depart[preID];
//						goto Update1;
//					}
//					vioTWCus[nextID] = temp;
//					FvioTWCus[nextID] = FvioTWCus[preID] + temp;
//					cStartS = problem->node[nextID].eTW;
//			   }
//			   else 
//			   {
//			   	  vioTWCus[nextID] = 0;
//				  FvioTWCus[nextID] = FvioTWCus[preID];
//			   }
//			   startS[nextID] = cStartS;
//			   cStartS += problem->node[nextID].duration;
//			   depart[nextID] = cStartS;
//			   FCAP[nextID] = FCAP[preID] + problem->node[nextID].capacity;
//			   pos[nextID] = pos[preID]+1;
//			   route_num[nextID] = idVehI; trip_num[nextID] = idTripI;
//			   preID = nextID; nextID = nextArr[nextID];
//		 }
//		 seg[idVehI].Trip[idTripI].endS = cStartS;
//		 varvioTWC = FvioTWCus[preID] - seg[idVehI].Trip[idTripI].vioTWC;
//		 seg[idVehI].Trip[idTripI].vioTWC = FvioTWCus[preID];
//		//preID now points to the last cus:
//		 //Update BCAP from lastCOLDI to firstCus
//		 //Update BvioTWCus from lastCus to firstCus
//		 BvioTWCus[preID] = vioTWCus[preID];
//		 id = predArr[preID];
//		 while (id != lastCOLDI)
//		 {
//			BvioTWCus[id] = BvioTWCus[preID] + vioTWCus[id];
//			preID = id; id = predArr[id];
//		}
//		BvioTWCus[lastCOLDI] = BvioTWCus[preID] + vioTWCus[lastCOLDI];
//		BCAP[lastCOLDI] = BCAP[preID] + problem->node[lastCOLDI].capacity;
//		id = predArr[lastCOLDI]; preID = lastCOLDI;
//		while (id > 0)
//		{
//			BvioTWCus[id] = BvioTWCus[preID] + vioTWCus[id];
//			BCAP[id] = BCAP[preID] + problem->node[id].capacity;
//			preID = id; id = predArr[id];
//		}
//
//		Update1:
//		if (seg[idVehI].Trip[idTripI].vioTWSP > eps || seg[idVehI].Trip[idTripI].vioCAP > 0 || seg[idVehI].Trip[idTripI].vioTWC > eps)
//			seg[idVehI].Trip[idTripI].feasible = 0;
//		else
//			seg[idVehI].Trip[idTripI].feasible = 1;
//
//		if (seg[idVehI].Trip[nextTrip].Type) //nextTrip is delivery trip, change the lastCus of the idTrip:
//		{
//			bool stop = updateChangeCONNECTAtSP_DD(lastCOLDM, idVehI, nextTrip, idTripI, varvioCAPI, varvioTWC, COSTI, COSTOLDI);
//			if (stop == 0)
//				UpdateVehicle(idVehI, nextTrip, seg[idVehI].Trip[nextTrip].assSP, seg[idVehI].Trip[nextTrip].leaveSP, varvioCAPI, seg[idVehI].numTrips - 1);
//		}
//		else //nextTrip is pickup, change the lastCus of the idTripI
//		{
//			int firstC_nextT = seg[idVehI].Trip[nextTrip].firstCus;
//			COSTI += problem->c[lastCOLDM][firstC_nextT];
//			seg[idVehI].Trip[idTripI].connectCost = problem->c[lastCOLDM][firstC_nextT];
//			seg[idVehI].Trip[idTripI].cost = COSTI;
//			varcostI = COSTI - COSTOLDI;
//			double varFIT = varcostI + VCAP * varvioCAPI + VTWCUS * varvioTWC;
//			seg[idVehI].Trip[idTripI].fitness += varFIT;
//			UpdateVehicle(idVehI, nextTrip, lastCOLDM, seg[idVehI].Trip[idTripI].endS, varvioCAPI, seg[idVehI].numTrips - 1);
//		}//end nextTrip is pickup, change the lastCus of the idTrip
//	 }//end idTripI is not the last trip
//   	 
//
//	  bool stop = checkVehicle(idVehI);
//	  if (stop)
//	  {
//		  cout<<"STOP AT insertCusDArrayPre of veh = "<<idVehI<<"; @IT = "<<IT<<endl;
//		  exit(-1);
//	  }
//}
//
//
//void Solution::insertCusDArraySuc(int idVehI, int idTripI, int idVehM, int idTripM) //assSPM - d + (assSPI - d)
// {
//	 int firstCM = seg[idVehM].Trip[idTripM].firstCus;
//	 int lastCM = seg[idVehM].Trip[idTripM].lastCus;
//	 int firstCI = seg[idVehI].Trip[idTripI].firstCus;
//	 int lastCI = seg[idVehI].Trip[idTripI].lastCus;
//	 
//	 seg[idVehI].Trip[idTripI].firstCus = firstCM;
//	 seg[idVehI].Trip[idTripI].numCus += seg[idVehM].Trip[idTripM].numCus;
//	 seg[idVehI].Trip[idTripI].capacity += seg[idVehM].Trip[idTripM].capacity;
//
//	 int vioCAPNEW = PDS_MAX(seg[idVehI].Trip[idTripI].capacity - problem->Q, 0);
//	 int varvioCAPI = vioCAPNEW - seg[idVehI].Trip[idTripI].vioCAP;
//	 seg[idVehI].Trip[idTripI].vioCAP = vioCAPNEW;
//
//	 int assSP = seg[idVehI].Trip[idTripI].assSP;
//	 double COSTOLDI = seg[idVehI].Trip[idTripI].cost;
//	 double COSTI = seg[idVehI].Trip[idTripI].cost + seg[idVehM].Trip[idTripM].cost - seg[idVehM].Trip[idTripM].connectCost;
//	 if (idTripM == 0) COSTI -= problem->c[0][assSP];
//	 COSTI += (problem->c[lastCM][firstCI] - problem->c[assSP][firstCI]);
//
//	 double varvioTWC;
//
//
//	 //Update trip_num,route_num for customers in (idVehM, idTripM):
//	 int preID, nextID, id;
//
// 
//	 double cStartS, cArrTime, temp;
//	 if (PDSDIF(seg[idVehI].Trip[idTripI].leaveSP, seg[idVehM].Trip[idTripM].leaveSP))
//	 {
//		 cStartS = seg[idVehI].Trip[idTripI].leaveSP;
//		 //1. Checking for customer in (idVehM, idTripM):
//		 double FvioTWCusT = 0;
//		 preID = assSP; nextID = firstCM;
//		 while (nextID > 0)
//		 {
//			cArrTime = cStartS + problem->c[preID][nextID];
//			cStartS = PDS_MAX(cArrTime, problem->node[nextID].sTW);
//			if (PDSDIF(cStartS, startS[nextID])==0) //it means varvioTWCus[nextID] = 0 
//			{
//			   temp = cStartS - problem->node[nextID].eTW;
//			   if (temp > eps) vioTWCus[nextID] = temp;
//			   else vioTWCus[nextID] = 0;
//
//			   //Update FvioTWCus from nextID to lastCus
//			   //Update route_num, trip_num from nextID to lastCus
//			    if (nextID == firstCM)
//				{
//					route_num[nextID] = idVehI; trip_num[nextID] = idTripI;
//					FvioTWCus[nextID] = vioTWCus[nextID];
//					preID = nextID; id = nextArr[nextID];
//				}
//				else {id = nextID; preID = predArr[id];}
//			    while (id > 0)
//				{
//				   route_num[id] = idVehI;
//				   trip_num[id] = idTripI;
//				   FvioTWCus[id] = FvioTWCus[preID] + vioTWCus[id];
//				   preID = id; id = nextArr[id];
//				}
//				break;
//		    }
//			temp = cStartS - problem->node[nextID].eTW;
//			if (temp > eps)
//			{
//				if (vioTWCus[nextID] > eps) 
//				{
//					vioTWCus[nextID] = temp;
//					//Update FvioTWCus from nextID to lastCus
//					//Update route_num, trip_num from nextID to lastCus
//					if (nextID == firstCM)
//					{
//						route_num[nextID] = idVehI; trip_num[nextID] = idTripI;
//						FvioTWCus[nextID] = vioTWCus[nextID];
//						preID = nextID; id = nextArr[nextID];
//					}
//					else {id = nextID; preID = predArr[id];}
//					while (id > 0)
//					{
//					   route_num[id] = idVehI;
//					   trip_num[id] = idTripI;
//					   FvioTWCus[id] = FvioTWCus[preID] + vioTWCus[id];
//					   preID = id; id = nextArr[id];
//					}
//					break;
//
//				}
//				vioTWCus[nextID] = temp;
//				FvioTWCusT += vioTWCus[nextID];
//				//FvioTWCus[nextID] = FvioTWCus[preID] + temp;
//				cStartS = problem->node[nextID].eTW;
//			}
//			else 
//			{
//				vioTWCus[nextID] = 0;
//				//FvioTWCus[nextID] = FvioTWCus[preID];
//			}
//			startS[nextID] = cStartS;
//		    cStartS += problem->node[nextID].duration;
//		    depart[nextID] = cStartS;
//			route_num[nextID] = idVehI; trip_num[nextID] = idTripI;
//			FvioTWCus[nextID] = FvioTWCusT;			
//	        preID = nextID; nextID = nextArr[nextID];
//		 }//end while (nextID > 0)
//	 }
//	 else
//	 {
//		 nextID = firstCM;
//		 while (nextID > 0)
//		 {
//			 route_num[nextID] = idVehI;
//			 trip_num[nextID] = idTripI;
//			 nextID = nextArr[nextID];
//		 }
//	 }
//
//	    //2.Checking for customers in (idVehI, idTripI):
//	 	 nextArr[lastCM] = firstCI; predArr[firstCI] = lastCM;
//		 cStartS = depart[lastCM];
//		 preID = lastCM; nextID = firstCI;
//		 while (nextID > 0) 
//		 {
//			cArrTime = cStartS + problem->c[preID][nextID];
//			cStartS = PDS_MAX(cArrTime, problem->node[nextID].sTW);
//			if (PDSDIF(cStartS, startS[nextID])==0) //it means varvioTWCus[nextID] = 0 
//			{
//			   temp = cStartS - problem->node[nextID].eTW;
//			   if (temp > eps) vioTWCus[nextID] = temp;
//			   else vioTWCus[nextID] = 0;
//
//			   //Update BvioTWCus from nextID to firstCus
//			   //Update BCAP from lastCM to firstCus
//			   //Update FCAP, FvioTWCus from nextID to lastCus
//			   //Update pos from nextID to lastCus
//				id = nextArr[nextID];
//				if (id < 0) BvioTWCus[nextID] = vioTWCus[nextID];
//				else BvioTWCus[nextID] = BvioTWCus[id] + vioTWCus[nextID];
//
//				id = nextID; preID = predArr[id];
//				while (preID != lastCM)
//				{
//				   BvioTWCus[preID] = BvioTWCus[id] + vioTWCus[preID];
//				   id = preID; preID = predArr[preID];
//				}
//
//				do
//				{
//				   BvioTWCus[preID] = BvioTWCus[id] + vioTWCus[preID];
//				   BCAP[preID] = BCAP[id] + problem->node[preID].capacity;
//				   id = preID; preID = predArr[preID];
//				}while (preID > 0);
//
//				id = nextID; preID = predArr[id];
//			    while (id > 0)
//				{
//				   pos[id] = pos[preID] + 1;
//				   FCAP[id] = FCAP[preID] + problem->node[id].capacity;
//				   FvioTWCus[id] = FvioTWCus[preID] + vioTWCus[id];
//				   preID = id; id = nextArr[id];
//				}
//				//preID now points to lastCus:
//				varvioTWC = seg[idVehI].Trip[idTripI].vioTWC - FvioTWCus[preID];
//				seg[idVehI].Trip[idTripI].vioTWC = FvioTWCus[preID];
//				seg[idVehI].Trip[idTripI].endS = depart[preID];
//				goto Update;
//		    }
//				   
//			temp = cStartS - problem->node[nextID].eTW;
//			if (temp > eps)
//			{
//				if (vioTWCus[nextID] > eps) 
//				{
//					vioTWCus[nextID] = temp;
//					//Update BvioTWCus from nextID to firstCus
//					//Update BCAP from lastCM to firstCus
//					//Update FCAP, FvioTWCus from nextID to lastCus
//					//Update pos from nextID to lastCus
//							
//					id = nextArr[nextID];
//					if (id < 0) BvioTWCus[nextID] = vioTWCus[nextID];
//					else BvioTWCus[nextID] = BvioTWCus[id] + vioTWCus[nextID];
//
//					id = nextID; preID = predArr[id];
//					while (preID != lastCM)
//					{
//					   BvioTWCus[preID] = BvioTWCus[id] + vioTWCus[preID];
//					   BCAP[preID] = BCAP[id] + problem->node[preID].capacity;
//					   id = preID; preID = predArr[preID];
//					}
//					
//					do
//					{
//					   BvioTWCus[preID] = BvioTWCus[id] + vioTWCus[preID];
//					   BCAP[preID] = BCAP[id] + problem->node[preID].capacity;
//					   id = preID; preID = predArr[preID];
//					}while (preID > 0);
//		
//					id = nextID; preID = predArr[nextID];
//					while (id > 0)
//					{
//						pos[id] = pos[preID] + 1;
//						FCAP[id] = FCAP[preID] + problem->node[id].capacity;
//						FvioTWCus[id] = FvioTWCus[preID] + vioTWCus[id];
//						preID = id; id = nextArr[id];
//					}
//					//preID now points to lastCus:
//					varvioTWC = seg[idVehI].Trip[idTripI].vioTWC - FvioTWCus[preID];
//					seg[idVehI].Trip[idTripI].vioTWC = FvioTWCus[preID];
//					seg[idVehI].Trip[idTripI].endS = depart[preID];
//					goto Update;
//				}
//				vioTWCus[nextID] = temp;
//				FvioTWCus[nextID] = FvioTWCus[preID] + temp;
//				cStartS = problem->node[nextID].eTW;
//			}
//			else 
//			{
//				vioTWCus[nextID] = 0;
//				FvioTWCus[nextID] = FvioTWCus[preID];
//			}
//			startS[nextID] = cStartS;
//		    cStartS += problem->node[nextID].duration;
//		    depart[nextID] = cStartS;
//			FCAP[nextID] = FCAP[preID] + problem->node[nextID].capacity;
//	        pos[nextID] = pos[preID] + 1;
//	        preID = nextID; nextID = nextArr[nextID];
//	     }//end while (nextID > 0)
//
//		 seg[idVehI].Trip[idTripI].endS = cStartS;
//		 varvioTWC = FvioTWCus[preID] - seg[idVehI].Trip[idTripI].vioTWC;
//		 seg[idVehI].Trip[idTripI].vioTWC = FvioTWCus[preID];
//		//preID now points to the last cus:
//		//Update BCAP from lastCM to firstCus
//		//Update BvioTWCus from lastCus to firstCus
//		 BvioTWCus[preID] = vioTWCus[preID];
//		 id = predArr[preID];
//		 while (id != lastCM)
//		 {
//			 BvioTWCus[id] = BvioTWCus[preID] + vioTWCus[id];
//			 preID = id; id = predArr[id];
//		 }
//		 do
//		 {
//			 BvioTWCus[id] = BvioTWCus[preID] + vioTWCus[id];
//			 BCAP[id] = BCAP[preID] + problem->node[id].capacity;
//			 preID = id; id = predArr[id];
//		 }while (id > 0);
//
//Update:
//		int nextTrip = idTripI + 1;
//		if (nextTrip == seg[idVehI].numTrips)
//		{
//			//Connect cost doesn't change
//		    seg[idVehI].Trip[idTripI].cost = COSTI;
//			double varcostI = COSTI - COSTOLDI;
//
//			double varFIT = varcostI + VCAP * varvioCAPI + VTWCUS * varvioTWC;
//			if (seg[idVehI].Trip[idTripI].vioTWC > eps || seg[idVehI].Trip[idTripI].vioCAP > 0 || seg[idVehI].Trip[idTripI].vioTWSP > eps)
//			{
//				seg[idVehI].Trip[idTripI].feasible = 0;
//				seg[idVehI].Trip[idTripI].fitness +=  varFIT;
//			}
//			else
//			{
//				seg[idVehI].Trip[idTripI].feasible = 1;
//				seg[idVehI].Trip[idTripI].fitness = seg[idVehI].Trip[idTripI].cost;
//			}
//			seg[idVehI].cost += varcostI; seg[idVehI].fitness += varFIT; 
//			seg[idVehI].vioCAP += varvioCAPI; seg[idVehI].vioTWC += varvioTWC;
//			cost += varcostI; fitness += varFIT; vioCAP += varvioCAPI; vioTWC += varvioTWC;
//	     }
//		else //not the last trip
//		{
//			if (seg[idVehI].Trip[idTripI].vioTWSP > eps || seg[idVehI].Trip[idTripI].vioCAP > 0 || seg[idVehI].Trip[idTripI].vioTWC > eps)
//				seg[idVehI].Trip[idTripI].feasible = 0;
//			else
//				seg[idVehI].Trip[idTripI].feasible = 1;
//		
//			if (seg[idVehI].Trip[nextTrip].Type)
//			{
//				COSTI -= seg[idVehI].Trip[idTripI].connectCost;
//				bool stop = updateChangeCONNECTAtSP_DD(lastCI, idVehI, nextTrip, idTripI, varvioCAPI, varvioTWC, COSTI, COSTOLDI);
//				if (stop == 0)
//					UpdateVehicle(idVehI, nextTrip, seg[idVehI].Trip[nextTrip].assSP, seg[idVehI].Trip[nextTrip].leaveSP, varvioCAPI, seg[idVehI].numTrips - 1);
//			}
//			else //nextTrip is pickup
//			{
//				seg[idVehI].Trip[idTripI].cost = COSTI;
//				double varcostI = COSTI - COSTOLDI;
//				double varFIT = varcostI + VCAP * varvioCAPI + VTWCUS * varvioTWC;
//				seg[idVehI].Trip[idTripI].fitness += varFIT;
//				UpdateVehicle(idVehI, nextTrip, lastCI, seg[idVehI].Trip[idTripI].endS, varvioCAPI, seg[idVehI].numTrips - 1);
//			}//end nextTrip is pickup
//		}//end not the last trip
// }
//
//
//void Solution::insertCusPArrayPre(int idVehI, int idTripI, int idVehM, int idTripM) //copy twoOPTstarCusPTrip
//{
//	//COPY twoOPTstarCusPTrip
//    //insert array of pickup customer in trip (idVehM, idTripM) after the last cus of (idVehI, idTripI)
//
//	 int assSP = seg[idVehI].Trip[idTripI].assSP;
//	 int lastCOLDI = seg[idVehI].Trip[idTripI].lastCus;
//	 int lastCM = seg[idVehM].Trip[idTripM].lastCus;
//	 int firstCM = seg[idVehM].Trip[idTripM].firstCus;
//	 double COSTOLDI = seg[idVehI].Trip[idTripI].cost;
//	 int numCusIOLD = seg[idVehI].Trip[idTripI].numCus;
//
//	 //1. vioCAP,capacity:
//	 seg[idVehI].Trip[idTripI].capacity += seg[idVehM].Trip[idTripM].capacity;
//	 int vioCAPNEW = PDS_MAX(seg[idVehI].Trip[idTripI].capacity - problem->Q, 0);
//	 int varvioCAP = vioCAPNEW - seg[idVehI].Trip[idTripI].vioCAP;
//	 seg[idVehI].Trip[idTripI].vioCAP = vioCAPNEW;
//	 
//	 double cArrTime, cStartS, temp, varvioTWC;
//     int id,preID, nextID;
//
//	 //2. Update nextArr, predArr, firstCus, lastCus
//	 nextArr[lastCOLDI] = firstCM; predArr[firstCM] = lastCOLDI;
//	 seg[idVehI].Trip[idTripI].lastCus = lastCM;
//
//	 seg[idVehI].Trip[idTripI].numCus += seg[idVehM].Trip[idTripM].numCus;
//
//	 double COSTI = seg[idVehI].Trip[idTripI].cost + seg[idVehM].Trip[idTripM].cost - seg[idVehI].Trip[idTripI].connectCost - seg[idVehM].Trip[idTripM].connectCost;
//	 if (idTripM == 0) COSTI -= problem->c[0][firstCM];
//	 COSTI += problem->c[lastCOLDI][firstCM];
//	 if (seg[idVehI].Trip[idTripI].waitingS == NO_WS)
//		 COSTI -= problem->c[lastCOLDI][assSP];
//	 else COSTI -= problem->disCWSSP[lastCOLDI][assSP];
//
//	 if (seg[idVehM].Trip[idTripM].waitingS == NO_WS)
//		 COSTI -= problem->c[lastCM][assSP];
//	 else COSTI -= problem->disCWSSP[lastCM][assSP];
//
//	 if (idTripI==0 && numCusIOLD == 1) //before j is the only one customer in the trip
//	 {
//		 startS[lastCOLDI] = PDS_MAX(problem->c[0][lastCOLDI], problem->node[lastCOLDI].sTW);
//		 depart[lastCOLDI] = startS[lastCOLDI] + problem->node[lastCOLDI].duration;
//	 }
//	 cStartS = depart[lastCOLDI]; preID = lastCOLDI; nextID = firstCM;
// 
//	 while (nextID > 0) 
//	 {
//		   cArrTime = cStartS + problem->c[preID][nextID];
//		   cStartS = PDS_MAX(cArrTime, problem->node[nextID].sTW);
//		   if (PDSDIF(cStartS, startS[nextID])==0) //it means varvioTWCus[nextID] = 0 
//		   {
//			   temp = cStartS - problem->node[nextID].eTW;
//			   if (temp > eps) vioTWCus[nextID] = temp;
//			   else vioTWCus[nextID] = 0;
//
//			   //Update BvioTWCus from nextID to firstCus
//				//Update BCAP from lastCOLDI to firstCus
//				//Update FCAP, FvioTWCus from nextID to lastCus
//				//Update trip_num, route_num, pos from nextID to lastCus
//				id = nextArr[nextID];
//				if (id < 0) BvioTWCus[nextID] = vioTWCus[nextID];
//				else BvioTWCus[nextID] = BvioTWCus[id] + vioTWCus[nextID];
//
//			    id = nextID;
//			    while (preID != lastCOLDI)
//			    {
//				   BvioTWCus[preID] = BvioTWCus[id] + vioTWCus[preID];
//				   id = preID; preID = predArr[preID];
//			    }
//			   
//			   do
//			   {
//				   BvioTWCus[preID] = BvioTWCus[id] + vioTWCus[preID];
//				   BCAP[preID] = BCAP[id] + problem->node[preID].capacity;
//				   id = preID; preID = predArr[preID];
//			   }while (preID > 0);
//			   id = nextID; preID = predArr[id];
//			   do
//			   {
//				   route_num[id] = idVehI; trip_num[id] = idTripI;
//				   pos[id] = pos[preID] + 1;
//				   FCAP[id] = FCAP[preID] + problem->node[id].capacity;
//				   FvioTWCus[id] = FvioTWCus[preID] + vioTWCus[id];
//				   preID = id; id = nextArr[id];
//			   }while (id > 0);
//			   //preID now points to lastCus:
//			   varvioTWC = seg[idVehI].Trip[idTripI].vioTWC - FvioTWCus[preID];
//			   seg[idVehI].Trip[idTripI].vioTWC = FvioTWCus[preID];
//			   seg[idVehI].Trip[idTripI].endS = depart[preID];
//			   goto Update;
//		   }
//		   temp = cStartS - problem->node[nextID].eTW;
//		   if (temp > eps)
//		   {
//				if (vioTWCus[nextID] > eps) 
//				{
//					vioTWCus[nextID] = temp;
//					//Update BvioTWCus from nextID to firstCus
//					//Update BCAP from lastCOLDI to firstCus
//					//Update FCAP, FvioTWCus from nextID to lastCus
//					//Update trip_num, route_num, pos from nextID to lastCus
//					//Update cost
//					id = nextArr[nextID];
//					if (id < 0) BvioTWCus[nextID] = vioTWCus[nextID];
//					else BvioTWCus[nextID] = BvioTWCus[id] + vioTWCus[nextID];
//
//				    id = nextID;
//				    while (preID != lastCOLDI)
//				    {
//					   BvioTWCus[preID] = BvioTWCus[id] + vioTWCus[preID];
//					   id = preID; preID = predArr[preID];
//				    }
//				    do
//				    {
//					   BvioTWCus[preID] = BvioTWCus[id] + vioTWCus[preID];
//					   BCAP[preID] = BCAP[id] + problem->node[preID].capacity;
//					   id = preID; preID = predArr[preID];
//				    }while (preID > 0);
//
//				    id = nextID; preID = predArr[id];
//				    do
//				    {
//					   route_num[id] = idVehI; trip_num[id] = idTripI;
//					   pos[id] = pos[preID] + 1;
//					   FCAP[id] = FCAP[preID] + problem->node[id].capacity;
//					   FvioTWCus[id] = FvioTWCus[preID] + vioTWCus[id];
//					   preID = id; id = nextArr[id];
//				    }while (id > 0);
//				    //preID now points to lastCus:
//				    varvioTWC = seg[idVehI].Trip[idTripI].vioTWC - FvioTWCus[preID];
//				    seg[idVehI].Trip[idTripI].vioTWC = FvioTWCus[preID];
//				    seg[idVehI].Trip[idTripI].endS = depart[preID];
//					goto Update;
//				}
//				vioTWCus[nextID] = temp;
//				FvioTWCus[nextID] = FvioTWCus[preID] + temp;
//				cStartS = problem->node[nextID].eTW;
//		   }
//		   else 
//		   {
//		   	  vioTWCus[nextID] = 0;
//			  FvioTWCus[nextID] = FvioTWCus[preID];
//		   }
//		   startS[nextID] = cStartS;
//		   cStartS += problem->node[nextID].duration;
//		   depart[nextID] = cStartS;
//		   FCAP[nextID] = FCAP[preID] + problem->node[nextID].capacity;
//		   pos[nextID] = pos[preID]+1;
//		   route_num[nextID] = idVehI; trip_num[nextID] = idTripI;
//		   preID = nextID; nextID = nextArr[nextID];
//	 }//end while (nextID > 0)
//
//	 seg[idVehI].Trip[idTripI].endS = cStartS;
//	 varvioTWC = FvioTWCus[preID] - seg[idVehI].Trip[idTripI].vioTWC;
//	 seg[idVehI].Trip[idTripI].vioTWC = FvioTWCus[preID];
//	//preID now points to the last cus:
//	 //Update BCAP from lastCOLDI to firstCus
//	 //Update BvioTWCus from lastCus to firstCus
//	 BvioTWCus[preID] = vioTWCus[preID];
//	 id = predArr[preID];
//	 while (id != lastCOLDI)
//	 {
//			BvioTWCus[id] = BvioTWCus[preID] + vioTWCus[id];
//			preID = id; id = predArr[id];
//	}
//	BvioTWCus[lastCOLDI] = BvioTWCus[preID] + vioTWCus[lastCOLDI];
//	BCAP[lastCOLDI] = BCAP[preID] + problem->node[lastCOLDI].capacity;
//	id = predArr[lastCOLDI]; preID = lastCOLDI;
//	while (id > 0)
//	{
//			BvioTWCus[id] = BvioTWCus[preID] + vioTWCus[id];
//			BCAP[id] = BCAP[preID] + problem->node[id].capacity;
//			preID = id; id = predArr[id];
//	}
//Update:
//	UpdateChangeCONNECTAtSP_PickTrip(idVehI,idTripI,0,varvioTWC,varvioCAP,COSTI); //varcostpreT = 0
//
//	  bool stop = checkVehicle(idVehI);
//	  if (stop)
//	  {
//		  cout<<"STOP AT insertCusPArrayPre of veh = "<<idVehI<<"; @IT = "<<IT<<endl;
//		  exit(-1);
//	  }
//}
//
// void Solution::insertCusPArraySuc(int idVehI, int idTripI, int idVehM, int idTripM) ////p of assSPM  + ( p of assSPI)
// {
//	 int firstCM = seg[idVehM].Trip[idTripM].firstCus;
//	 int lastCM = seg[idVehM].Trip[idTripM].lastCus;
//	 int firstCI = seg[idVehI].Trip[idTripI].firstCus;
//	 int lastCI = seg[idVehI].Trip[idTripI].lastCus;
//	 
//	 seg[idVehI].Trip[idTripI].firstCus = firstCM;
//	 seg[idVehI].Trip[idTripI].numCus += seg[idVehM].Trip[idTripM].numCus;
//	 seg[idVehI].Trip[idTripI].capacity += seg[idVehM].Trip[idTripM].capacity;
//
//	 int vioCAPNEW = PDS_MAX(seg[idVehI].Trip[idTripI].capacity - problem->Q, 0);
//	 int varvioCAPI = vioCAPNEW - seg[idVehI].Trip[idTripI].vioCAP;
//	 seg[idVehI].Trip[idTripI].vioCAP = vioCAPNEW;
//
//	 int assSP = seg[idVehI].Trip[idTripI].assSP;
//	 double COSTOLDI = seg[idVehI].Trip[idTripI].cost;
//
//	 double COSTI = seg[idVehI].Trip[idTripI].cost + seg[idVehM].Trip[idTripM].cost - seg[idVehM].Trip[idTripM].connectCost - seg[idVehI].Trip[idTripI].connectCost;
//	 if (idTripM == 0) COSTI -= problem->c[0][firstCM];
//	 COSTI += problem->c[lastCM][firstCI];
//	 if (seg[idVehM].Trip[idTripM].waitingS == NO_WS)
//		 COSTI -= problem->c[lastCM][assSP];
//	 else COSTI -= problem->disCWSSP[lastCM][assSP];
//
//	 if (seg[idVehI].Trip[idTripI].waitingS == NO_WS)
//		 COSTI -= problem->c[lastCI][assSP];
//	 else COSTI -= problem->disCWSSP[lastCI][assSP];
//
//	 double varcostpreTI;
// 	 int preID, nextID, id;
//	 double cStartS, cArrTime, temp;
//
//	 if (idTripI > 0)
//	 {
//		 int preTI = idTripI - 1;
//		 varcostpreTI = -seg[idVehI].Trip[preTI].connectCost;
//		 if (seg[idVehI].Trip[preTI].Type)
//		 {
//			 preID = seg[idVehI].Trip[preTI].lastCus;
//			 cStartS = depart[preID];
//		 }
//		 else
//		 {
//			 preID = seg[idVehI].Trip[preTI].assSP;
//			 cStartS = seg[idVehI].Trip[preTI].leaveSP;
//		 }
//		 seg[idVehI].Trip[preTI].connectCost = problem->c[preID][firstCM];
//		 varcostpreTI += problem->c[preID][firstCM];
//		 seg[idVehI].Trip[preTI].cost += varcostpreTI;
//		 seg[idVehI].Trip[preTI].fitness += varcostpreTI;
//	 }
//	 else 
//	 {
//		 varcostpreTI = 0;
//		 COSTI += (problem->c[0][firstCM] - problem->c[0][firstCI]);
//		 cStartS = 0;
//		 preID = 0;
//	 }
//
//	 double varvioTWC;
//	 //Update trip_num,route_num for customers in (idVehM, idTripM):
//
//	 //1. Checking for customers in (idVehM, idTripM):
//	 nextID = firstCM;
// 	 cArrTime = cStartS + problem->c[preID][nextID];
//	 cStartS = PDS_MAX(cArrTime, problem->node[nextID].sTW);
//	 temp = cStartS - problem->node[nextID].eTW;
//	 if (temp > eps)
//	 {
//		 vioTWCus[nextID] = temp;
//		 FvioTWCus[nextID] = temp;
//		 cStartS = problem->node[nextID].eTW;
//	 }
//	 else
//	 {
//		 vioTWCus[nextID] = 0;
//		 FvioTWCus[nextID] = 0;
//	 }
//	 startS[nextID] = cStartS;
//	 cStartS += problem->node[nextID].duration;
//	 depart[nextID] = cStartS;
//	 route_num[nextID] = idVehI; trip_num[nextID] = idTripI;
//	 preID = nextID; nextID = nextArr[nextID];
//	
//	 while (nextID > 0) 
//	 {
//		   cArrTime = cStartS + problem->c[preID][nextID];
//		   cStartS = PDS_MAX(cArrTime, problem->node[nextID].sTW);
//		   if (PDSDIF(cStartS, startS[nextID])==0) //it means varvioTWCus[nextID] = 0 
//		   {
//			   temp = cStartS - problem->node[nextID].eTW;
//			   if (temp > eps) vioTWCus[nextID] = temp;
//			   else vioTWCus[nextID] = 0;
//
//				//Update FvioTWCus from nextID to lastCus
//				//Update trip_num, route_num from nextID to lastCus
//			    id = nextID; preID = predArr[id];
//			    while (id > 0)
//			    {
//				   route_num[id] = idVehI; trip_num[id] = idTripI;
//				   FvioTWCus[id] = FvioTWCus[preID] + vioTWCus[id];
//				   preID = id; id = nextArr[id];
//			   }
//			   break;
//		   }
//		   temp = cStartS - problem->node[nextID].eTW;
//		   if (temp > eps)
//		   {
//				if (vioTWCus[nextID] > eps) 
//				{
//					vioTWCus[nextID] = temp;
//					//Update FvioTWCus from nextID to lastCus
//					//Update trip_num, route_num, from nextID to lastCus
//					id = nextID; preID = predArr[nextID];
//					while (id > 0)
//					{
//						route_num[id] = idVehI; trip_num[id] = idTripI;
//						FvioTWCus[id] = FvioTWCus[preID] + vioTWCus[id];
//						preID = id; id = nextArr[id];
//					}
//					break;
//				}
//				vioTWCus[nextID] = temp;
//				FvioTWCus[nextID] = FvioTWCus[preID] + temp;
//				cStartS = problem->node[nextID].eTW;
//		   }
//		   else 
//		   {
//				vioTWCus[nextID] = 0;
//				FvioTWCus[nextID] = FvioTWCus[preID];
//		   }
//		   startS[nextID] = cStartS;
//		   cStartS += problem->node[nextID].duration;
//		   depart[nextID] = cStartS;
//		   route_num[nextID] = idVehI; trip_num[nextID] = idTripI;
//		   preID = nextID; nextID = nextArr[nextID];
//	 }//end while (nextID > 0)
//
//	 cStartS = depart[lastCM];
// 	 nextArr[lastCM] = firstCI; predArr[firstCI] = lastCM;
//	 //2. Checking for customers in (idVehI, idTripI):
//	 preID = lastCM; nextID = firstCI;
//	 while (nextID > 0) 
//	 {
//		   cArrTime = cStartS + problem->c[preID][nextID];
//		   cStartS = PDS_MAX(cArrTime, problem->node[nextID].sTW);
//		   if (PDSDIF(cStartS, startS[nextID])==0) //it means varvioTWCus[nextID] = 0 
//		   {
//			   temp = cStartS - problem->node[nextID].eTW;
//			   if (temp > eps) vioTWCus[nextID] = temp;
//			   else vioTWCus[nextID] = 0;
//
//			   //Update BvioTWCus from nextID to firstCus
//				//Update BCAP from lastCM to firstCus
//				//Update FCAP, FvioTWCus from nextID to lastCus
//				//Update pos from nextID to lastCus
//				id = nextArr[nextID];
//				if (id < 0) BvioTWCus[nextID] = vioTWCus[nextID];
//				else BvioTWCus[nextID] = BvioTWCus[id] + vioTWCus[nextID];
//
//				id = nextID; preID = predArr[id];
//				while (preID != lastCM)
//				{
//				   BvioTWCus[preID] = BvioTWCus[id] + vioTWCus[preID];
//				   id = preID; preID = predArr[preID];
//				}
//
//				do
//				{
//				   BvioTWCus[preID] = BvioTWCus[id] + vioTWCus[preID];
//				   BCAP[preID] = BCAP[id] + problem->node[preID].capacity;
//				   id = preID; preID = predArr[preID];
//				}while (preID > 0);
//
//			    id = nextID; preID = predArr[id];
//			    while (id > 0)
//			    {
//				   pos[id] = pos[preID] + 1;
//				   FCAP[id] = FCAP[preID] + problem->node[id].capacity;
//				   FvioTWCus[id] = FvioTWCus[preID] + vioTWCus[id];
//				   preID = id; id = nextArr[id];
//			    }
//			   //preID now points to lastCus:
//			   varvioTWC = seg[idVehI].Trip[idTripI].vioTWC - FvioTWCus[preID];
//			   seg[idVehI].Trip[idTripI].vioTWC = FvioTWCus[preID];
//			   seg[idVehI].Trip[idTripI].endS = depart[preID];
//			   goto Update;
//		   }
//		   temp = cStartS - problem->node[nextID].eTW;
//		   if (temp > eps)
//		   {
//				if (vioTWCus[nextID] > eps) 
//				{
//					vioTWCus[nextID] = temp;
//					//Update BvioTWCus from nextID to firstCus
//					//Update BCAP from lastCM to firstCus
//					//Update FCAP, FvioTWCus from nextID to lastCus
//					//Update pos from nextID to lastCus
//					id = nextArr[nextID];
//					if (id < 0) BvioTWCus[nextID] = vioTWCus[nextID];
//					else BvioTWCus[nextID] = BvioTWCus[id] + vioTWCus[nextID];
//
//					id = nextID; preID = predArr[id];
//					while (preID != lastCM)
//					{
//					   BvioTWCus[preID] = BvioTWCus[id] + vioTWCus[preID];
//					   id = preID; preID = predArr[preID];
//					}
//					do
//					{
//					   BvioTWCus[preID] = BvioTWCus[id] + vioTWCus[preID];
//					   BCAP[preID] = BCAP[id] + problem->node[preID].capacity;
//					   id = preID; preID = predArr[preID];
//					}while (preID > 0);
//					
//					id = nextID; preID = predArr[nextID];
//					while (id > 0)
//					{
//						pos[id] = pos[preID] + 1;
//						FCAP[id] = FCAP[preID] + problem->node[id].capacity;
//						FvioTWCus[id] = FvioTWCus[preID] + vioTWCus[id];
//						preID = id; id = nextArr[id];
//					}
//					//preID now points to lastCus:
//					varvioTWC = seg[idVehI].Trip[idTripI].vioTWC - FvioTWCus[preID];
//					seg[idVehI].Trip[idTripI].vioTWC = FvioTWCus[preID];
//					seg[idVehI].Trip[idTripI].endS = depart[preID];
//					goto Update;
//				}
//				vioTWCus[nextID] = temp;
//				FvioTWCus[nextID] = FvioTWCus[preID] + temp;
//				cStartS = problem->node[nextID].eTW;
//		   }
//		   else 
//		   {
//				vioTWCus[nextID] = 0;
//				FvioTWCus[nextID] = FvioTWCus[preID];
//		   }
//		   startS[nextID] = cStartS;
//		   cStartS += problem->node[nextID].duration;
//		   depart[nextID] = cStartS;
//		   FCAP[nextID] = FCAP[preID] + problem->node[nextID].capacity;
//		   pos[nextID] = pos[preID] + 1;
//		   preID = nextID; nextID = nextArr[nextID];
//	 }//end while (nextID > 0)
//
//	 seg[idVehI].Trip[idTripI].endS = cStartS;
//	 varvioTWC = FvioTWCus[preID] - seg[idVehI].Trip[idTripI].vioTWC;
//	 seg[idVehI].Trip[idTripI].vioTWC = FvioTWCus[preID];
//	 //preID now points to the last cus:
//	 //Update BCAP from lastCM to firstCus
//	 //Update BvioTWCus from lastCus to firstCus
//	 BvioTWCus[preID] = vioTWCus[preID];
//	 BCAP[preID] = problem->node[preID].capacity;
//	 id = predArr[preID];
//	 while (id != lastCM)
//	 {
//		 BvioTWCus[id] = BvioTWCus[preID] + vioTWCus[id];
//		 preID = id; id = predArr[id];
//	 }
//	 do
//	 {
//		 BvioTWCus[id] = BvioTWCus[preID] + vioTWCus[id];
//		 BCAP[id] = BCAP[preID] + problem->node[id].capacity;
//		 preID = id; id = predArr[id];
//	 }while (id > 0);
//
//Update:
//	UpdateChangeCONNECTAtSP_PickTrip(idVehI,idTripI, varcostpreTI, varvioTWC, varvioCAPI, COSTI);
//
//
//	  bool stop = checkVehicle(idVehI);
//	  if (stop)
//	  {
//		  cout<<"STOP AT insertCusPArraySuc of vehI = "<<idVehI<<"; @IT = "<<IT<<endl;
//		  exit(-1);
//	  }
//
//
// }
//void Solution::InsertPickupTrip(int idVehM, int idTripM, int assSPM, int idVehI, int assSPI) //insert pickup (idVehM, idTripM) after (idVehI,idTripI) 
//{
//	int firstCM = seg[idVehM].Trip[idTripM].firstCus;
//	if (seg[idVehI].numTrips == 0) //Vehicle is empty:
//	{
//		//cout<<"Solution::InsertPickupTrip INSERT PICKUP TRIP ("<<idVehM<<", "<<idTripM<<") into empty vehicle "<<idVehI<<endl;
//		seg[idVehI].numTrips  = 1;
//		seg[idVehI].Trip[0] = seg[idVehM].Trip[idTripM];
//		/*if (idTripM > 0) 
//		{
//			seg[idVehI].Trip[0].cost += problem->c[0][firstCM];
//			seg[idVehI].Trip[0].fitness += problem->c[0][firstCM];
//		}*/
//	    double cStartS = 0;            
//		subInsertPickupTrip(idVehI,0,-1, idTripM,cStartS,0,0);
//		numVehUsed++;
//		//cout<<"Insert a new vehicle: numVehUsed = "<<numVehUsed<<endl;
//	}
//	else //Vehicle is not empty:
//	{
//		if (assSPI == 0) //insert at the begin:
//		{
//			if (seg[idVehI].Trip[0].Type)
//			{
//				//cout<<"Solution::InsertPickupTrip INSERT PICKUP TRIP ("<<idVehM<<", "<<idTripM<<") at the beginning of vehicle "<<idVehI<<", before the first delivery trip"<<endl;
//				//DON TOA:
//				for (int i=seg[idVehI].numTrips;i > 0; i--)
//				{
//					seg[idVehI].Trip[i] = seg[idVehI].Trip[i-1];
//					UpdateTripnum(idVehI,i);
//				}
//				seg[idVehI].Trip[0] = seg[idVehM].Trip[idTripM];
//				seg[idVehI].numTrips++;
//				/*if (idTripM > 0)
//				{
//					seg[idVehI].Trip[0].cost += problem->c[0][firstCM];
//					seg[idVehI].Trip[0].fitness += problem->c[0][firstCM];
//				}*/
//				double varcostpreT;
//				varcostpreT = -problem->c[0][seg[idVehI].Trip[1].assSP];
//				seg[idVehI].Trip[1].cost += varcostpreT;
//				seg[idVehI].Trip[1].fitness += varcostpreT;
//				subInsertPickupTrip(idVehI,0,1,idTripM,0,0,varcostpreT);
//			}
//			else
//			{
//				assSPI = seg[idVehI].Trip[0].assSP;
//				if (assSPM < assSPI)
//				{
//					//cout<<"Solution::InsertPickupTrip INSERT PICKUP TRIP ("<<idVehM<<", "<<idTripM<<") at the beginning of vehicle "<<idVehI<<", before the first pick trip"<<endl;
//					//DON TOA:
//					for (int i=seg[idVehI].numTrips;i > 0; i--)
//					{
//						seg[idVehI].Trip[i] = seg[idVehI].Trip[i-1];
//						UpdateTripnum(idVehI,i);
//					}
//					seg[idVehI].Trip[0] = seg[idVehM].Trip[idTripM];
//					seg[idVehI].numTrips++;
//					/*if (idTripM > 0)
//					{
//						seg[idVehI].Trip[0].cost += problem->c[0][firstCM];
//						seg[idVehI].Trip[0].fitness += problem->c[0][firstCM];
//					}*/
//					double varcostpreT;
//					varcostpreT = -problem->c[0][seg[idVehI].Trip[1].firstCus];
//					seg[idVehI].Trip[1].cost += varcostpreT;
//					seg[idVehI].Trip[1].fitness += varcostpreT;
//					subInsertPickupTrip(idVehI,0,1,idTripM,0,0,varcostpreT);
//				}
//				else //GOP TRUOC: p of assSPM + p of (idVehI,0)
//				{
//					//cout<<"Solution::InsertPickupTrip GOPTRUOC: pick of tripM ("<<idVehM<<", "<<idTripM<<") + pick of firsttrip ("<<idVehI<<",0)"<<endl;
//					insertCusPArraySuc(idVehI, 0, idVehM, idTripM); //assSPM - p + (assSPI - p)
//				}
//			}
//		}
//		else //insert at the middle/last
//		{
//			int idTripI; //Insert idTripM after idTripI
//			for (int i=0;i<seg[idVehI].numTrips;i++)
//			{
//				if (assSPI == seg[idVehI].Trip[i].assSP) 
//				{
//					idTripI = i; 
//					break;
//				}
//			}
//			int lastTI = seg[idVehI].numTrips - 1;
//			double cStartS, varcostpreT; int preC;
//			if (idTripI == lastTI) //insert at the last
//			{
//				if (assSPM > assSPI)
//				{
//					//cout<<"Solution::InsertPickupTrip INSERT pickup trip ("<<idVehM<<", "<<idTripM<<") at the end of vehicle "<<idVehI<<endl;
// 					int lastTINEW = seg[idVehI].numTrips;
//					seg[idVehI].Trip[lastTINEW] = seg[idVehM].Trip[idTripM];
//					seg[idVehI].numTrips ++;
//					varcostpreT = -seg[idVehI].Trip[lastTI].connectCost;
//					if (seg[idVehI].Trip[lastTI].Type) 
//					{
//						preC = seg[idVehI].Trip[lastTI].lastCus;
//						cStartS = depart[preC];
//						seg[idVehI].Trip[lastTI].waitingS = NO_WS;
//					}
//					else
//					{
//						preC = seg[idVehI].Trip[lastTI].assSP;
//						cStartS = seg[idVehI].Trip[lastTI].leaveSP;
//						seg[idVehI].Trip[lastTI].waitingS1 = NO_WS;
//					}
//					seg[idVehI].Trip[lastTI].connectCost = problem->c[preC][firstCM];
//					varcostpreT += problem->c[preC][firstCM];
//					seg[idVehI].Trip[lastTI].cost += varcostpreT;
//					seg[idVehI].Trip[lastTI].fitness += varcostpreT;
//					subInsertPickupTrip(idVehI,lastTINEW,-1,idTripM,cStartS,preC,varcostpreT);
//				}
//				else //assSPM = assSPI: GOP SAU: p of idTripI + p of idTripM
//				{
//					//idTripI should be pickup trip:
//					if (seg[idVehI].Trip[idTripI].Type)
//					{
//						cout<<"ERROR: last trip("<<idVehI<<", "<<idTripI<<") should be pickup trip; so can GOP with pickup trip ("<<idVehM<<", "<<idTripM<<")"<<endl;
//						showSegment(idVehI);
//					}
//					//cout<<"Solution::InsertPickupTrip GOPSAU: pick of lasttrip of vehI "<<idVehI<<" + pick of idTripM ("<<idVehM<<", "<<idTripM<<")"<<endl;
//					insertCusPArrayPre(idVehI,idTripI,idVehM,idTripM);
//				}
//			}
//			else //insert into the middle
//			{
//				if (assSPM == assSPI) //GOP SAU: p of idTripI + p of idTripM
//				{
//					//idTripI should be pickup trip:
//					if (seg[idVehI].Trip[idTripI].Type)
//					{
//						cout<<"ERROR: middle trip("<<idVehI<<", "<<idTripI<<") should be pickup trip; so can GOP with pickup trip ("<<idVehM<<", "<<idTripM<<")"<<endl;
//						showSegment(idVehI);
//					}
//					//cout<<"Solution::InsertPickupTrip GOPSAU: pick of middletripI ("<<idVehI<<", "<<idTripI<<") + pick of idTripM ("<<idVehM<<", "<<idTripM<<")"<<endl;
//					insertCusPArrayPre(idVehI,idTripI,idVehM,idTripM);
//				}
//				else //assSPM > assSPI
//				{
//					int idTripI1 = idTripI + 1;
//					int assSPI1 = seg[idVehI].Trip[idTripI1].assSP;
//					if (assSPM < assSPI1)
//					{
//						//cout<<"Solution::InsertPickupTrip Insert pickup trip ("<<idVehM<<", "<<idTripM<<", SP = "<<assSPM<<") in the middle of vehicle "<<idVehI<<" between trips "<<idTripI<<" and "<<idTripI1<<endl;
//						//Don toa:
//						for (int i = seg[idVehI].numTrips;i > idTripI1; i--)
//						{
//							seg[idVehI].Trip[i] = seg[idVehI].Trip[i-1];
//							UpdateTripnum(idVehI,i);
//						}
//						seg[idVehI].Trip[idTripI1] = seg[idVehM].Trip[idTripM];
//						seg[idVehI].numTrips++;
//						if (seg[idVehI].Trip[idTripI].Type)
//						{
//							preC = seg[idVehI].Trip[idTripI].lastCus;
//							cStartS = depart[preC];
//							seg[idVehI].Trip[idTripI].waitingS = NO_WS;
//						}
//						else
//						{
//							preC = seg[idVehI].Trip[idTripI].assSP;
//							cStartS = seg[idVehI].Trip[idTripI].leaveSP;
//							seg[idVehI].Trip[idTripI].waitingS1 = NO_WS;
//						}
//						varcostpreT = -seg[idVehI].Trip[idTripI].connectCost;
//						seg[idVehI].Trip[idTripI].connectCost = problem->c[preC][firstCM];
//						varcostpreT += problem->c[preC][firstCM];
//						seg[idVehI].Trip[idTripI].cost += varcostpreT;
//						seg[idVehI].Trip[idTripI].fitness += varcostpreT;
//					    /*if (idTripM == 0)
//					    {
//						   seg[idVehI].Trip[idTripI1].cost -= problem->c[0][firstCM];
//						   seg[idVehI].Trip[idTripI1].fitness -= problem->c[0][firstCM];
//						   varcostpreT -= problem->c[0][firstCM];
//					    }*/
//						subInsertPickupTrip(idVehI,idTripI1,idTripI1+1,idTripM, cStartS, preC, varcostpreT);
//					}
//					else if (assSPM > assSPI1)
//					{
//						if (seg[idVehI].Trip[idTripI1].coordinate == 0)
//						{
//							cout<<"ERROR: Trip ("<<idVehI<<", "<<idTripI1<<" has to be coordinate trip for the case p-d-SAMESP(= "<<assSPI1<<"): insert pickTrip ("<<idVehM<<", "<<idTripM<<", sp = "<<assSPM<<") after it"<<endl;
//						    exit(-1);
//						}
//						int CASE = 1;
//						int idTripI2 = idTripI1 + 1;
//						if (idTripI2 <= lastTI)
//						{
//							if (seg[idVehI].Trip[idTripI2].Type == 0)
//							{
//								int assSPI2 = seg[idVehI].Trip[idTripI2].assSP;
//								if (assSPM == assSPI2) CASE = 2;
//							}
//						}
//						//CASE = 1: insert after the coordinate trip (idVehI, idTripI1)
//						//CASE = 2: GOP TRUOC pickup trip (idVehI, idTripI2) where (idVehI, idTripI1) is coordinate
//						if (CASE == 1)
//						{
//							//cout<<"Solution::InsertPickupTrip Insert pickup trip ("<<idVehM<<", "<<idTripM<<", SP = "<<assSPM<<") after the middle coordinate trip ("<<idVehI<<", "<<idTripI1<<")"<<endl;
//							//Don toa:
//							for (int i = seg[idVehI].numTrips;i > idTripI2; i--)
//							{
//								seg[idVehI].Trip[i] = seg[idVehI].Trip[i-1];
//								UpdateTripnum(idVehI,i);
//							}
//							seg[idVehI].Trip[idTripI2] = seg[idVehM].Trip[idTripM];
//							seg[idVehI].numTrips++;
//							preC = seg[idVehI].Trip[idTripI1].lastCus;
//							cStartS = depart[preC];
//							varcostpreT = -seg[idVehI].Trip[idTripI1].connectCost;
//							seg[idVehI].Trip[idTripI1].connectCost = problem->c[preC][firstCM];
//							seg[idVehI].Trip[idTripI1].waitingS = NO_WS;
//							varcostpreT += problem->c[preC][firstCM];
//							seg[idVehI].Trip[idTripI1].cost += varcostpreT;
//							seg[idVehI].Trip[idTripI1].fitness += varcostpreT;
//							/*if (idTripM == 0)
//							{
//							   seg[idVehI].Trip[idTripI2].cost -= problem->c[0][firstCM];
//							   seg[idVehI].Trip[idTripI2].fitness -= problem->c[0][firstCM];
//							   varcostpreT -= problem->c[0][firstCM];
//							}*/
//							int idTripI3 = idTripI2 + 1;
//							if (idTripI3 < seg[idVehI].numTrips)
//							   subInsertPickupTrip(idVehI,idTripI2,idTripI3,idTripM, cStartS, preC, varcostpreT);
//							else
//							   subInsertPickupTrip(idVehI,idTripI2,-1, idTripM,cStartS, preC, varcostpreT);
//
//						}
//						else //CASE = 2
//						{
//							//CASE = 2: GOP TRUOC pickup trip (idVehI, idTripI2) where (idVehI, idTripI1) is coordinate
//							//cout<<"Solution::InsertPickupTrip GOP TRUOC: pick of tripM ("<<idVehM<<", "<<idTripM<<") + pick of tripI2 ("<<idVehI<<", "<<idTripI2<<"); where ("<<idVehI<<", "<<idTripI1<<") is coordinate"<<endl;
//							insertCusPArraySuc(idVehI, idTripI2, idVehM, idTripM); //assSPM - p + (assSPI2 - p)
//						}
//					}
//					else //assSPM = assSPI1: 
//					{
//						if (seg[idVehI].Trip[idTripI1].Type) //create new P-D SAMESP
//						{
//							//cout<<"Solution::InsertPickupTrip CREATE NEW P-D SAMESP: Insert pickup trip ("<<idVehM<<", "<<idTripM<<", SP = "<<assSPM<<") in the middle of vehicle "<<idVehI<<" between trips "<<idTripI<<" and delTrip "<<idTripI1<<endl;
//							//Don toa:
//							for (int i = seg[idVehI].numTrips;i > idTripI1; i--)
//							{
//								seg[idVehI].Trip[i] = seg[idVehI].Trip[i-1];
//								UpdateTripnum(idVehI,i);
//							}
//							seg[idVehI].Trip[idTripI1] = seg[idVehM].Trip[idTripM];
//							seg[idVehI].numTrips++;
//							if (seg[idVehI].Trip[idTripI].Type)
//							{
//								preC = seg[idVehI].Trip[idTripI].lastCus;
//								cStartS = depart[preC];
//								seg[idVehI].Trip[idTripI].waitingS = NO_WS;
//							}
//							else
//							{
//								preC = seg[idVehI].Trip[idTripI].assSP;
//								cStartS = seg[idVehI].Trip[idTripI].leaveSP;
//								seg[idVehI].Trip[idTripI].waitingS1 = NO_WS;
//							}
//							varcostpreT = -seg[idVehI].Trip[idTripI].connectCost;
//							seg[idVehI].Trip[idTripI].connectCost = problem->c[preC][firstCM];
//							varcostpreT += problem->c[preC][firstCM];
//							seg[idVehI].Trip[idTripI].cost += varcostpreT;
//							seg[idVehI].Trip[idTripI].fitness += varcostpreT;
//							subInsertPickupTrip(idVehI,idTripI1,idTripI1+1,idTripM, cStartS, preC, varcostpreT);
//						}
//						else //GOP TRUOC: pick of (idVehM,idTripM) + pick of (idVehI, idTripI1)
//						{
//							//cout<<"Solution::InsertPickupTrip GOP TRUOC: pick of tripM ("<<idVehM<<", "<<idTripM<<") + pick of tripI1 ("<<idVehI<<", "<<idTripI1<<")"<<endl;
//							insertCusPArraySuc(idVehI, idTripI1, idVehM, idTripM); //assSPM - p + (assSPI - p)
//						}
//					}//end assSPM = assSPI1
//				}//end assSPM > assSPI
//			}//end insert the middle
//		}//end insert at the middle/last
//	}//end vehicle is not empty
//}
//
//
//void Solution::InsertPickupTrip_ExchangeSP(int idVeh, int idTripI, int idTripM) //insert pickup (idVehM, idTripM) after (idVehI,idTripI) 
//{
//	int firstCI = seg[idVeh].Trip[idTripI].firstCus;
//
//	if (idTripI == 0) //insert at the begin
//	{
//		//cout<<"Insert pickuptrip at the beginning of vehicle "<<idVeh<<endl;
//		if (seg[idVeh].numTrips == 1)
//		    subInsertPickupTrip(idVeh,0,-1,idTripM,0,0,0);//varcostpreT = 0
//		else
//		    subInsertPickupTrip(idVeh,0,1,idTripM,0,0,0); //varcostpreT = 0
//	}
//	else //insert at the middle/end
//	{
//		int lastT = seg[idVeh].numTrips - 1;
//		int preT = idTripI - 1; int preC; double cStartS;
//		double varcostpreT;
//			varcostpreT = -seg[idVeh].Trip[preT].connectCost;
//			if (seg[idVeh].Trip[preT].Type) 
//			{
//				preC = seg[idVeh].Trip[preT].lastCus;
//				cStartS = depart[preC];
//				seg[idVeh].Trip[preT].waitingS = NO_WS;
//			}
//			else
//			{
//				preC = seg[idVeh].Trip[preT].assSP;
//				cStartS = seg[idVeh].Trip[preT].leaveSP;
//				seg[idVeh].Trip[preT].waitingS1 = NO_WS;
//			}
//			seg[idVeh].Trip[preT].connectCost = problem->c[preC][firstCI];
//			varcostpreT += problem->c[preC][firstCI];
//			seg[idVeh].Trip[preT].cost += varcostpreT;
//			seg[idVeh].Trip[preT].fitness += varcostpreT;
//			if (idTripI == lastT) //insert at the end:
//			{
//				//cout<<"Insert pickuptrip at the end of vehicle "<<idVeh<<endl;
//				subInsertPickupTrip(idVeh,idTripI,-1,idTripM,cStartS,preC,varcostpreT);
//			}
//			else //insert in the middle:
//			{
//				//cout<<"Insert pickuptrip in the middle of vehicle "<<idVeh<<endl;
//				subInsertPickupTrip(idVeh,idTripI,idTripI+1,idTripM, cStartS, preC, varcostpreT);
//			}
//	}//end insert at the middle/end
//}
//
//
//
//
//void Solution::subInsertPickupTrip(int idVeh, int idTripI, int nextT, int idTripM, double cStartS, int preC, double varcostpreT)
//{
//	//Cal information for inserting trip (idVeh,idTripI) = (idVehM, idTripM) before (idVeh, nextT)
//	//if nextT < 0: insert idTripI at the end of vehicle idVeh
//	//cStartS is the time leaving the previous customer(sP) preC of first cus of idTripI
//	//varcost is the variation of cost of previous TRIPS before idTripI of idVeh
//	
//	int	assSP = seg[idVeh].Trip[idTripI].assSP;
//
//	UpdateRouteTripnum(idVeh, idTripI);
//	if (idTripI == 0 && seg[idVeh].Trip[idTripI].numCus == 1)
//	{
//		int id = seg[idVeh].Trip[0].firstCus;
//		startS[id] = problem->startSOneP[id][assSP];
//		depart[id] = startS[id] + problem->node[id].duration;
//		seg[idVeh].Trip[0].endS = depart[id];
//		if (problem->waitingSOneP[id][assSP])
//		{
//		    seg[idVeh].Trip[0].waitingS = problem->CWSSP[id][assSP];
//			seg[idVeh].Trip[0].cost = problem->c[0][id] + problem->disCWSSP[id][assSP] + seg[idVeh].Trip[0].connectCost;
//			//cStartS = PDS_MAX(depart[id] + problem->disCWSSP[id][assSP], problem->nodeSP[assSP].sTW1);
//		}
//		else
//		{
//			seg[idVeh].Trip[0].waitingS = NO_WS;
//			seg[idVeh].Trip[0].cost = problem->c[0][id] + problem->c[id][assSP] + seg[idVeh].Trip[0].connectCost;
//			//cStartS = depart[id] + problem->c[id][assSP];
//		}
//		seg[idVeh].Trip[0].fitness = seg[idVeh].Trip[0].cost;
//		vioTWCus[id] = 0; FvioTWCus[id] = 0; BvioTWCus[id] = 0;
//		seg[idVeh].Trip[0].vioTWC = 0; seg[idVeh].Trip[0].vioTWSP = 0;
//		seg[idVeh].Trip[0].feasible = 1;
//		//cStartS += problem->nodeSP[assSP].unload;
//		cStartS = problem->leaveSPOneP[id][assSP];
//		seg[idVeh].Trip[0].leaveSP = cStartS;
//	}
//	else //not the firstTrip with one customer
//	{
//		int curC = seg[idVeh].Trip[idTripI].firstCus;
//		if (idTripI == 0 && idTripM > 0)
//		{
//			seg[idVeh].Trip[0].cost += problem->c[0][curC];
//			seg[idVeh].Trip[0].fitness += problem->c[0][curC];
//		}
//		else if (idTripI > 0 && idTripM == 0)
//		{
//			seg[idVeh].Trip[idTripI].cost -= problem->c[0][curC];
//			seg[idVeh].Trip[idTripI].fitness -= problem->c[0][curC];
//		}
//
//			//1.check firstCus curC where preC is the lastCus of previous trip or the assSP of previous delivery trip
//			double cArrTime = cStartS + problem->c[preC][curC];
//			double temp, varvioTWC;
//			cStartS = PDS_MAX(cArrTime, problem->node[curC].sTW);
//			if (PDSDIF(cStartS, startS[curC])==0)
//			{
//				temp = cStartS - problem->node[curC].eTW;
//				if (temp > eps) vioTWCus[curC] = temp; else vioTWCus[curC] = 0;
//				UpdateFBvioTWCus(idVeh, idTripI, curC);
//				varvioTWC = FvioTWCus[seg[idVeh].Trip[idTripI].lastCus] - seg[idVeh].Trip[idTripI].vioTWC;
//				seg[idVeh].Trip[idTripI].vioTWC = FvioTWCus[seg[idVeh].Trip[idTripI].lastCus];
//				seg[idVeh].Trip[idTripI].fitness += (VTWCUS * varvioTWC);
//				if (seg[idVeh].Trip[idTripI].vioCAP > 0 || seg[idVeh].Trip[idTripI].vioTWC > eps || seg[idVeh].Trip[idTripI].vioTWSP > eps)
//					seg[idVeh].Trip[idTripI].feasible = 0;
//				else seg[idVeh].Trip[idTripI].feasible = 1;
//				goto Update;
//			}
//			temp = cStartS - problem->node[curC].eTW;
//			if (temp > eps)
//			{
//				if (vioTWCus[curC] > eps)
//				{
//					vioTWCus[curC] = temp;
//					UpdateFBvioTWCus(idVeh, idTripI, curC);
//					varvioTWC = FvioTWCus[seg[idVeh].Trip[idTripI].lastCus] - seg[idVeh].Trip[idTripI].vioTWC;
//					seg[idVeh].Trip[idTripI].vioTWC = FvioTWCus[seg[idVeh].Trip[idTripI].lastCus];
//					seg[idVeh].Trip[idTripI].fitness += (VTWCUS * varvioTWC);
//					if (seg[idVeh].Trip[idTripI].vioCAP > 0 || seg[idVeh].Trip[idTripI].vioTWC > eps || seg[idVeh].Trip[idTripI].vioTWSP > eps)
//						seg[idVeh].Trip[idTripI].feasible = 0;
//					else seg[idVeh].Trip[idTripI].feasible = 1;
//					goto Update;
//				}
//				vioTWCus[curC] = temp;
//				FvioTWCus[curC] = temp;
//				cStartS = problem->node[curC].eTW;
//			}
//			else
//			{
//				vioTWCus[curC] = 0;
//				FvioTWCus[curC] = 0;
//			}
//			startS[curC] = cStartS;
//			cStartS += problem->node[curC].duration;
//			depart[curC] = cStartS;
//			preC = curC; curC = nextArr[curC];
//
//			//2.check middle and lastCus
//			while (curC > 0)
//			{
//				cArrTime = cStartS + problem->c[preC][curC];
//				cStartS = PDS_MAX(cArrTime, problem->node[curC].sTW);
//				if (PDSDIF(cStartS, startS[curC])==0)
//				{
//					temp = cStartS - problem->node[curC].eTW;
//					if (temp > eps) vioTWCus[curC] = temp; else vioTWCus[curC] = 0;
//					UpdateFBvioTWCus(idVeh, idTripI, curC);
//					varvioTWC = FvioTWCus[seg[idVeh].Trip[idTripI].lastCus] - seg[idVeh].Trip[idTripI].vioTWC;
//					seg[idVeh].Trip[idTripI].vioTWC = FvioTWCus[seg[idVeh].Trip[idTripI].lastCus];
//					seg[idVeh].Trip[idTripI].fitness += (VTWCUS * varvioTWC);
//					if (seg[idVeh].Trip[idTripI].vioCAP > 0 || seg[idVeh].Trip[idTripI].vioTWC > eps || seg[idVeh].Trip[idTripI].vioTWSP > eps)
//						seg[idVeh].Trip[idTripI].feasible = 0;
//					else seg[idVeh].Trip[idTripI].feasible = 1;
//					goto Update;
//				}
//				temp = cStartS - problem->node[curC].eTW;
//				if (temp > eps)
//				{
//					if (vioTWCus[curC] > eps)
//					{
//						vioTWCus[curC] = temp;
//						UpdateFBvioTWCus(idVeh, idTripI, curC);
//						varvioTWC = FvioTWCus[seg[idVeh].Trip[idTripI].lastCus] - seg[idVeh].Trip[idTripI].vioTWC;
//						seg[idVeh].Trip[idTripI].vioTWC = FvioTWCus[seg[idVeh].Trip[idTripI].lastCus];
//						seg[idVeh].Trip[idTripI].fitness += (VTWCUS * varvioTWC);
//						if (seg[idVeh].Trip[idTripI].vioCAP > 0 || seg[idVeh].Trip[idTripI].vioTWC > eps || seg[idVeh].Trip[idTripI].vioTWSP > eps)
//							seg[idVeh].Trip[idTripI].feasible = 0;
//						else seg[idVeh].Trip[idTripI].feasible = 1;
//						goto Update;
//					}
//					vioTWCus[curC] = temp;
//					FvioTWCus[curC] = FvioTWCus[preC] + temp;
//					cStartS = problem->node[curC].eTW;
//				}
//				else
//				{
//					vioTWCus[curC] = 0;
//					FvioTWCus[curC] = FvioTWCus[preC];
//				}
//				startS[curC] = cStartS;
//				cStartS += problem->node[curC].duration;
//				depart[curC] = cStartS;
//				preC = curC; curC = nextArr[curC];
//			} //end while (curC > 0)
//			seg[idVeh].Trip[idTripI].endS = depart[preC];
//			varvioTWC = FvioTWCus[preC] - seg[idVeh].Trip[idTripI].vioTWC;
//			seg[idVeh].Trip[idTripI].vioTWC = FvioTWCus[preC];
//			seg[idVeh].Trip[idTripI].fitness += (VTWCUS * varvioTWC);
//			//preC now points to lastcus
//			UpdateBvioTWCus(idVeh, idTripI, preC);
//			calChangeCONNECTAtSP_PickTrip2(preC, idVeh, idTripI, depart[preC]);
//	}//end //not the firstTrip with one customer
//
//Update:
//	cStartS = seg[idVeh].Trip[idTripI].leaveSP; 
//	if (nextT < 0)
//	{
//		seg[idVeh].Trip[idTripI].waitingS1 = NO_WS;
//		double varcost1 =  problem->c[assSP][0] - seg[idVeh].Trip[idTripI].connectCost;
//		seg[idVeh].Trip[idTripI].connectCost = problem->c[assSP][0];
//		seg[idVeh].Trip[idTripI].cost += varcost1;
//		seg[idVeh].Trip[idTripI].fitness += varcost1;
//
//		double varFIT = varcostpreT + seg[idVeh].Trip[idTripI].fitness;
//		double varcost = varcostpreT + seg[idVeh].Trip[idTripI].cost;
//		seg[idVeh].cost += varcost;
//		seg[idVeh].fitness += varFIT;
//		seg[idVeh].vioCAP += seg[idVeh].Trip[idTripI].vioCAP;
//		seg[idVeh].vioTWC += seg[idVeh].Trip[idTripI].vioTWC;
//		seg[idVeh].vioTWSP += seg[idVeh].Trip[idTripI].vioTWSP;
//		cost += varcost;
//		fitness += varFIT;
//		vioCAP += seg[idVeh].Trip[idTripI].vioCAP;
//		vioTWC += seg[idVeh].Trip[idTripI].vioTWC;
//		vioTWSP += seg[idVeh].Trip[idTripI].vioTWSP;
//	}
//	else
//	{
//		if (seg[idVeh].Trip[nextT].Type)
//		{
//			UpdateVehicle_CONNECTAtSP_SPSP_InsertPT(idVeh, nextT, idTripI, varcostpreT);
//		}
//		else
//		{
//			seg[idVeh].Trip[idTripI].waitingS1 = NO_WS;
//			int firstC_nextT = seg[idVeh].Trip[nextT].firstCus;
//			double varcost1 = problem->c[assSP][firstC_nextT] - seg[idVeh].Trip[idTripI].connectCost;
//			seg[idVeh].Trip[idTripI].connectCost =  problem->c[assSP][firstC_nextT];
//			seg[idVeh].Trip[idTripI].cost += varcost1;
//			seg[idVeh].Trip[idTripI].fitness += varcost1;
//
//			double varfit = varcostpreT + seg[idVeh].Trip[idTripI].fitness;
//			double varcost = varcostpreT + seg[idVeh].Trip[idTripI].cost;
//			seg[idVeh].cost += varcost;
//			seg[idVeh].fitness += varfit;
//			seg[idVeh].vioCAP += seg[idVeh].Trip[idTripI].vioCAP;
//			seg[idVeh].vioTWC += seg[idVeh].Trip[idTripI].vioTWC;
//			seg[idVeh].vioTWSP += seg[idVeh].Trip[idTripI].vioTWSP;
//			cost += varcost; fitness += varfit;
//			vioCAP += seg[idVeh].Trip[idTripI].vioCAP;
//			vioTWC += seg[idVeh].Trip[idTripI].vioTWC;
//			vioTWSP += seg[idVeh].Trip[idTripI].vioTWSP;
//			UpdateVehicle(idVeh,nextT,assSP, seg[idVeh].Trip[idTripI].leaveSP,0,seg[idVeh].numTrips - 1); //varvioCAP = 0
//		}
//	}
//
//
//
//}
//
//void Solution::InsertPDTrip(int idVehM, int idTripM, int assSPM, int idVehI, int assSPI) //insert P-D trip (idVehM, idTripM, idTripM+1) after (idVehI,idTripI) 
//{
//	int idTripM1 = idTripM + 1;
//	int firstCM = seg[idVehM].Trip[idTripM].firstCus;
//
//	if (seg[idVehI].numTrips == 0) //Vehicle is empty:
//	{
//		//cout<<"INSERT P-D TRIP ("<<idVehM<<", "<<idTripM<<") into empty vehicle "<<idVehI<<endl;
//		seg[idVehI].numTrips  = 2;
//		seg[idVehI].Trip[0] = seg[idVehM].Trip[idTripM];
//		seg[idVehI].Trip[1] = seg[idVehM].Trip[idTripM1];
//		/*if (idTripM > 0) 
//		{
//			seg[idVehI].Trip[0].cost += problem->c[0][firstCM];
//			seg[idVehI].Trip[0].fitness += problem->c[0][firstCM];
//		}*/
//	    double cStartS = 0;            
//		subInsertPDTrip(idVehI,0,-1, idTripM,cStartS,0,0);
//		numVehUsed++;
//		//cout<<"Insert a new vehicle: numVehUsed = "<<numVehUsed<<endl;
//	}
//	else //Vehicle is not empty:
//	{
//		if (assSPI == 0) //insert at the begin:
//		{
//				//cout<<"INSERT P-D TRIP ("<<idVehM<<", "<<idTripM<<") at the beginning of vehicle "<<idVehI<<endl;
//				//DON TOA:
//				for (int i=seg[idVehI].numTrips+1;i > 0; i--)
//				{
//					seg[idVehI].Trip[i] = seg[idVehI].Trip[i-2];
//					UpdateTripnum(idVehI,i);
//				}
//				seg[idVehI].Trip[0] = seg[idVehM].Trip[idTripM];
//				seg[idVehI].Trip[1] = seg[idVehM].Trip[idTripM1];
//				seg[idVehI].numTrips += 2;
//				//if (idTripM != 0) seg[idVehI].Trip[0].cost += problem->c[0][firstCM];
//				double varcostpreT;
//				if (seg[idVehI].Trip[2].Type)
//				   varcostpreT = -problem->c[0][seg[idVehI].Trip[2].assSP];
//				else
//					varcostpreT =-problem->c[0][seg[idVehI].Trip[2].firstCus];
//				seg[idVehI].Trip[2].cost += varcostpreT;
//				seg[idVehI].Trip[2].fitness += varcostpreT;
//				subInsertPDTrip(idVehI,0,2,idTripM,0,0,varcostpreT);
//		}
//		else //insert at the middle/last
//		{
//			int idTripI; //Insert idTripM after idTripI
//			for (int i=0;i<seg[idVehI].numTrips;i++)
//			{
//				if (assSPI == seg[idVehI].Trip[i].assSP) 
//				{
//					idTripI = i; 
//					break;
//				}
//			}
//			int lastTI = seg[idVehI].numTrips - 1;
//			double cStartS, varcostpreT; int preC;
//			if (idTripI == lastTI) //insert at the last
//			{
//					//cout<<"INSERT P-D trip ("<<idVehM<<", "<<idTripM<<") at the end of vehicle "<<idVehI<<endl;
// 					int lastTINEW = seg[idVehI].numTrips;
//					seg[idVehI].Trip[lastTINEW] = seg[idVehM].Trip[idTripM];
//					seg[idVehI].Trip[lastTINEW+1] = seg[idVehM].Trip[idTripM1];
//					seg[idVehI].numTrips +=2;
//					varcostpreT = -seg[idVehI].Trip[lastTI].connectCost;
//					if (seg[idVehI].Trip[lastTI].Type) 
//					{
//						preC = seg[idVehI].Trip[lastTI].lastCus;
//						cStartS = depart[preC];
//						seg[idVehI].Trip[lastTI].waitingS = NO_WS;
//					}
//					else
//					{
//						preC = seg[idVehI].Trip[lastTI].assSP;
//						cStartS = seg[idVehI].Trip[lastTI].leaveSP;
//						seg[idVehI].Trip[lastTI].waitingS1 = NO_WS;
//					}
//					seg[idVehI].Trip[lastTI].connectCost = problem->c[preC][firstCM];
//					varcostpreT += problem->c[preC][firstCM];
//					seg[idVehI].Trip[lastTI].cost += varcostpreT;
//					seg[idVehI].Trip[lastTI].fitness += varcostpreT;
//					subInsertPDTrip(idVehI,lastTINEW,-1, idTripM,cStartS,preC,varcostpreT);
//			}
//			else //insert into the middle
//			{
//				int idTripI1 = idTripI + 1;
//				int idTripI2 = idTripI + 2;
//				if (seg[idVehI].Trip[idTripI1].coordinate)
//				{
//					//cout<<"Insert P-D trip ("<<idVehM<<", "<<idTripM<<", SP = "<<assSPM<<") after the coordinate trip idTrip1 "<<idTripI1<<endl;
//					//Don toa:
//					int idTripI3 = idTripI2+1;
//					for (int i = seg[idVehI].numTrips+1;i > idTripI3; i--)
//					{
//						seg[idVehI].Trip[i] = seg[idVehI].Trip[i-2];
//						UpdateTripnum(idVehI,i);
//					}
//					seg[idVehI].Trip[idTripI2] = seg[idVehM].Trip[idTripM];
//					seg[idVehI].Trip[idTripI3] = seg[idVehM].Trip[idTripM1];
//					seg[idVehI].numTrips +=2;
//					preC = seg[idVehI].Trip[idTripI1].lastCus;
//					cStartS = depart[preC];
//					seg[idVehI].Trip[idTripI1].waitingS = NO_WS;
//
//					varcostpreT = -seg[idVehI].Trip[idTripI1].connectCost;
//					seg[idVehI].Trip[idTripI1].connectCost = problem->c[preC][firstCM];
//					varcostpreT += problem->c[preC][firstCM];
//					seg[idVehI].Trip[idTripI1].cost += varcostpreT;
//					seg[idVehI].Trip[idTripI1].fitness += varcostpreT;
//					//cout<<"DON TOA XONG"<<endl;
//					int idTripI4 = idTripI3 + 1;
//					if (idTripI4 < seg[idVehI].numTrips)
//					   subInsertPDTrip(idVehI,idTripI2,idTripI4,idTripM,cStartS,preC,varcostpreT);
//					else
//					   subInsertPDTrip(idVehI,idTripI2,-1,idTripM,cStartS,preC,varcostpreT);
//					//cout<<"Insert xong"<<endl;
//				}
//				else
//				{
//					//cout<<"Insert P-D trip ("<<idVehM<<", "<<idTripM<<", SP = "<<assSPM<<") in the middle of vehicle "<<idVehI<<" between trips "<<idTripI<<" and "<<idTripI1<<endl;
//					//Don toa:
//					for (int i = seg[idVehI].numTrips+1;i > idTripI2; i--)
//					{
//						seg[idVehI].Trip[i] = seg[idVehI].Trip[i-2];
//						UpdateTripnum(idVehI,i);
//					}
//					seg[idVehI].Trip[idTripI1] = seg[idVehM].Trip[idTripM];
//					seg[idVehI].Trip[idTripI2] = seg[idVehM].Trip[idTripM1];
//					seg[idVehI].numTrips +=2;
//					if (seg[idVehI].Trip[idTripI].Type)
//					{
//						preC = seg[idVehI].Trip[idTripI].lastCus;
//						cStartS = depart[preC];
//						seg[idVehI].Trip[idTripI].waitingS = NO_WS;
//					}
//					else
//					{
//						preC = seg[idVehI].Trip[idTripI].assSP;
//						cStartS = seg[idVehI].Trip[idTripI].leaveSP;
//						seg[idVehI].Trip[idTripI].waitingS1 = NO_WS;
//					}
//					varcostpreT = -seg[idVehI].Trip[idTripI].connectCost;
//					seg[idVehI].Trip[idTripI].connectCost = problem->c[preC][firstCM];
//					varcostpreT += problem->c[preC][firstCM];
//					seg[idVehI].Trip[idTripI].cost += varcostpreT;
//					seg[idVehI].Trip[idTripI].fitness += varcostpreT;
//					subInsertPDTrip(idVehI,idTripI1,idTripI2+1,idTripM,cStartS,preC,varcostpreT);
//
//				}
//			}//end insert the middle
//		}//end insert at the middle/last
//	}//end vehicle is not empty
//}
//
//
//void Solution::InsertPDTrip_ExchangeSP(int idVeh, int idTripI, int idTripM) //insert P-D trip (idVeh, idTripI, idTripI+1) between (idVehI,preT) and (idVeh, nextT) 
//{
//	//COPY Solution::InsertPDTrip
//	int firstCI = seg[idVeh].Trip[idTripI].firstCus;
//
//	if (idTripI == 0) //insert at the beginning
//	{
//		//cout<<"Exchange P-D TRIP to the beginning of vehicle "<<idVeh<<endl;
//		if (seg[idVeh].numTrips == 2)
//		    subInsertPDTrip(idVeh,0,-1,idTripM,0,firstCI,0); //varcostpreT = 0
//		else
//		    subInsertPDTrip(idVeh,0,2,idTripM,0,firstCI,0); //varcostpreT = 0
//	}
//	else //insert at the middle/last
//	{
//			int preT = idTripI - 1;
//			int idTripI1 = idTripI + 1;
//			int nextT = idTripI1 + 1;
//			double varcostpreT,cStartS;
//			int preC;
//			varcostpreT = -seg[idVeh].Trip[preT].connectCost;
//			if (seg[idVeh].Trip[preT].Type)
//			{
//				preC = seg[idVeh].Trip[preT].lastCus;
//				cStartS = depart[preC];
//				seg[idVeh].Trip[preT].waitingS = NO_WS;
//			}
//			else
//			{
//				preC = seg[idVeh].Trip[preT].assSP;
//				cStartS = seg[idVeh].Trip[preT].leaveSP;
//				seg[idVeh].Trip[preT].waitingS1 = NO_WS;
//			}
//			seg[idVeh].Trip[preT].connectCost = problem->c[preC][firstCI];
//			varcostpreT += problem->c[preC][firstCI];
//			seg[idVeh].Trip[preT].cost += varcostpreT;
//			seg[idVeh].Trip[preT].fitness += varcostpreT;		
//			if (nextT == seg[idVeh].numTrips) //insert at the end of vehicle
//		    {
//				//cout<<"Exchange P-D trip at the end of vehicle "<<idVeh<<endl;
//				subInsertPDTrip(idVeh,idTripI,-1,idTripM,cStartS,preC,varcostpreT);
//			}
//			else //insert in the middle
//			{
//				//cout<<"Exchange P-D trip in the middle of vehicle "<<idVeh<<" between trips "<<preT<<" and "<<nextT<<endl;
//				subInsertPDTrip(idVeh,idTripI,nextT,idTripM,cStartS,preC,varcostpreT);
//		    }//end insert in the middle
//	}
//}
//
//void Solution::subInsertPDTrip(int idVeh, int idTripI, int nextT, int idTripM, double cStartS, int preC, double varcostpreT)
//{
//	//Cal information for inserting trip (idVeh,idTripI) before (idVeh, nextT)
//	//if nextT < 0: insert idTripI at the end of vehicle idVeh
//	//cStartS is the time leaving the previous customer(sP) preC of first cus of idTripI
//	//varcost is the variation of cost of previous TRIPS before idTripI of idVeh
//	
//	int	assSP = seg[idVeh].Trip[idTripI].assSP;
//    int idTripI1 = idTripI + 1;
//	UpdateRouteTripnum(idVeh, idTripI);
//
//	if (idTripI == 0 && seg[idVeh].Trip[idTripI].numCus == 1)
//	{
//		int id = seg[idVeh].Trip[0].firstCus;
//		startS[id] = problem->startSOneP[id][assSP];
//		depart[id] = startS[id] + problem->node[id].duration;
//		seg[idVeh].Trip[0].endS = depart[id];
//		if (problem->waitingSOneP[id][assSP])
//		{
//		    seg[idVeh].Trip[0].waitingS = problem->CWSSP[id][assSP];
//			seg[idVeh].Trip[0].cost = problem->c[0][id] + problem->disCWSSP[id][assSP] + seg[idVeh].Trip[0].connectCost;
//			//cStartS = PDS_MAX(depart[id] + problem->disCWSSP[id][assSP], problem->nodeSP[assSP].sTW1);
//		}
//		else
//		{
//			seg[idVeh].Trip[0].waitingS = NO_WS;
//			seg[idVeh].Trip[0].cost = problem->c[0][id] + problem->c[id][assSP] + seg[idVeh].Trip[0].connectCost;
//			//cStartS = depart[id] + problem->c[id][assSP];
//		}
//		seg[idVeh].Trip[0].fitness = seg[idVeh].Trip[0].cost;
//		vioTWCus[id] = 0; FvioTWCus[id] = 0; BvioTWCus[id] = 0;
//		seg[idVeh].Trip[0].vioTWC = 0; seg[idVeh].Trip[0].vioTWSP = 0;
//		seg[idVeh].Trip[0].feasible = 1;
//		//cStartS += problem->nodeSP[assSP].unload;
//		cStartS = problem->leaveSPOneP[id][assSP];
//		seg[idVeh].Trip[0].leaveSP = cStartS;
//	}
//	else //not the firstTrip with one customer
//	{
//			int curC = seg[idVeh].Trip[idTripI].firstCus;
//			if (idTripI == 0 && idTripM > 0)
//			{
//				seg[idVeh].Trip[0].cost += problem->c[0][curC];
//				seg[idVeh].Trip[0].fitness += problem->c[0][curC];
//			}
//			else if (idTripI > 0 && idTripM == 0)
//			{
//				seg[idVeh].Trip[idTripI].cost -= problem->c[0][curC];
//				seg[idVeh].Trip[idTripI].fitness -= problem->c[0][curC];
//			}
//			//1.check firstCus curC where preC is the lastCus of previous trip or the assSP of previous delivery trip
//			double cArrTime = cStartS + problem->c[preC][curC];
//			double temp, varvioTWC;
//			cStartS = PDS_MAX(cArrTime, problem->node[curC].sTW);
//			if (PDSDIF(cStartS, startS[curC])==0)
//			{
//				temp = cStartS - problem->node[curC].eTW;
//				if (temp > eps) vioTWCus[curC] = temp; else vioTWCus[curC] = 0;
//				UpdateFBvioTWCus(idVeh, idTripI, curC);
//				varvioTWC = FvioTWCus[seg[idVeh].Trip[idTripI].lastCus] - seg[idVeh].Trip[idTripI].vioTWC;
//				seg[idVeh].Trip[idTripI].vioTWC = FvioTWCus[seg[idVeh].Trip[idTripI].lastCus];
//				seg[idVeh].Trip[idTripI].fitness += (VTWCUS * varvioTWC);
//				if (seg[idVeh].Trip[idTripI].vioCAP > 0 || seg[idVeh].Trip[idTripI].vioTWC > eps || seg[idVeh].Trip[idTripI].vioTWSP > eps)
//					seg[idVeh].Trip[idTripI].feasible = 0;
//				else seg[idVeh].Trip[idTripI].feasible = 1;
//				goto Update;
//			}
//			temp = cStartS - problem->node[curC].eTW;
//			if (temp > eps)
//			{
//				if (vioTWCus[curC] > eps)
//				{
//					vioTWCus[curC] = temp;
//					UpdateFBvioTWCus(idVeh, idTripI, curC);
//					varvioTWC = FvioTWCus[seg[idVeh].Trip[idTripI].lastCus] - seg[idVeh].Trip[idTripI].vioTWC;
//					seg[idVeh].Trip[idTripI].vioTWC = FvioTWCus[seg[idVeh].Trip[idTripI].lastCus];
//					seg[idVeh].Trip[idTripI].fitness += (VTWCUS * varvioTWC);
//					if (seg[idVeh].Trip[idTripI].vioCAP > 0 || seg[idVeh].Trip[idTripI].vioTWC > eps || seg[idVeh].Trip[idTripI].vioTWSP > eps)
//						seg[idVeh].Trip[idTripI].feasible = 0;
//					else seg[idVeh].Trip[idTripI].feasible = 1;
//					goto Update;
//				}
//				vioTWCus[curC] = temp;
//				FvioTWCus[curC] = temp;
//				cStartS = problem->node[curC].eTW;
//			}
//			else
//			{
//				vioTWCus[curC] = 0;
//				FvioTWCus[curC] = 0;
//			}
//			startS[curC] = cStartS;
//			cStartS += problem->node[curC].duration;
//			depart[curC] = cStartS;
//			preC = curC; curC = nextArr[curC];
//
//			//2.check middle and lastCus
//			while (curC > 0)
//			{
//				cArrTime = cStartS + problem->c[preC][curC];
//				cStartS = PDS_MAX(cArrTime, problem->node[curC].sTW);
//				if (PDSDIF(cStartS, startS[curC])==0)
//				{
//					temp = cStartS - problem->node[curC].eTW;
//					if (temp > eps) vioTWCus[curC] = temp; else vioTWCus[curC] = 0;
//					UpdateFBvioTWCus(idVeh, idTripI, curC);
//					varvioTWC = FvioTWCus[seg[idVeh].Trip[idTripI].lastCus] - seg[idVeh].Trip[idTripI].vioTWC;
//					seg[idVeh].Trip[idTripI].vioTWC = FvioTWCus[seg[idVeh].Trip[idTripI].lastCus];
//					seg[idVeh].Trip[idTripI].fitness += (VTWCUS * varvioTWC);
//					if (seg[idVeh].Trip[idTripI].vioCAP > 0 || seg[idVeh].Trip[idTripI].vioTWC > eps || seg[idVeh].Trip[idTripI].vioTWSP > eps)
//						seg[idVeh].Trip[idTripI].feasible = 0;
//					else seg[idVeh].Trip[idTripI].feasible = 1;
//					goto Update;
//				}
//				temp = cStartS - problem->node[curC].eTW;
//				if (temp > eps)
//				{
//					if (vioTWCus[curC] > eps)
//					{
//						vioTWCus[curC] = temp;
//						UpdateFBvioTWCus(idVeh, idTripI, curC);
//						varvioTWC = FvioTWCus[seg[idVeh].Trip[idTripI].lastCus] - seg[idVeh].Trip[idTripI].vioTWC;
//						seg[idVeh].Trip[idTripI].vioTWC = FvioTWCus[seg[idVeh].Trip[idTripI].lastCus];
//						seg[idVeh].Trip[idTripI].fitness += (VTWCUS * varvioTWC);
//						if (seg[idVeh].Trip[idTripI].vioCAP > 0 || seg[idVeh].Trip[idTripI].vioTWC > eps || seg[idVeh].Trip[idTripI].vioTWSP > eps)
//							seg[idVeh].Trip[idTripI].feasible = 0;
//						else seg[idVeh].Trip[idTripI].feasible = 1;
//						goto Update;
//					}
//					vioTWCus[curC] = temp;
//					FvioTWCus[curC] = FvioTWCus[preC] + temp;
//					cStartS = problem->node[curC].eTW;
//				}
//				else
//				{
//					vioTWCus[curC] = 0;
//					FvioTWCus[curC] = FvioTWCus[preC];
//				}
//				startS[curC] = cStartS;
//				cStartS += problem->node[curC].duration;
//				depart[curC] = cStartS;
//				preC = curC; curC = nextArr[curC];
//			} //end while (curC > 0)
//			seg[idVeh].Trip[idTripI].endS = depart[preC];
//			varvioTWC = FvioTWCus[preC] - seg[idVeh].Trip[idTripI].vioTWC;
//			seg[idVeh].Trip[idTripI].vioTWC = FvioTWCus[preC];
//			seg[idVeh].Trip[idTripI].fitness += (VTWCUS * varvioTWC);
//			//preC now points to lastcus
//			UpdateBvioTWCus(idVeh, idTripI, preC);
//			calChangeCONNECTAtSP_PickTrip2(preC, idVeh, idTripI, depart[preC]);
//	}//end //not the firstTrip with one customer
//
//Update:
//
//	double varvioTWSP = -seg[idVeh].Trip[idTripI1].vioTWSP;
//	seg[idVeh].Trip[idTripI1].vioTWSP = seg[idVeh].Trip[idTripI].vioTWSP;
//	varvioTWSP += seg[idVeh].Trip[idTripI1].vioTWSP;
//	double COEFvioTWSP = VTWSP * varvioTWSP;
//	seg[idVeh].Trip[idTripI1].fitness += COEFvioTWSP;
//
//	double varFIT = varcostpreT + seg[idVeh].Trip[idTripI].fitness;
//	double varcost = varcostpreT + seg[idVeh].Trip[idTripI].cost;
//	seg[idVeh].cost += varcost;
//	seg[idVeh].fitness += varFIT;
//	seg[idVeh].vioCAP += seg[idVeh].Trip[idTripI].vioCAP;
//	seg[idVeh].vioTWC += seg[idVeh].Trip[idTripI].vioTWC;
//	seg[idVeh].vioTWSP += seg[idVeh].Trip[idTripI].vioTWSP;
//	cost += varcost;
//	fitness += varFIT;
//	vioCAP += seg[idVeh].Trip[idTripI].vioCAP;
//	vioTWC += seg[idVeh].Trip[idTripI].vioTWC;
//	vioTWSP += seg[idVeh].Trip[idTripI].vioTWSP;
//	if (seg[idVeh].Trip[idTripI].vioTWSP > eps)
//		cStartS = problem->leaveSP[assSP][1]; //load at eTW2
//	else cStartS = seg[idVeh].Trip[idTripI].leaveSP + problem->nodeSP[assSP].load; 
//	subInsertDeliveryTrip(idVeh,idTripI1,nextT,cStartS,0); //varcostpreT = 0: because already include before
//}
//void Solution::GoThroughVehicle_InsertDT(int idVehI, int preT, int nextT, int idVehM, int idTripM, double &varcost, double & varvioTWC, double &varvioTWSP)
//{
//	//Insert delivery trip (idVehM, idTripM) into vehicle idVehI between 2 trips preT and nextT:
//	int lastCM = seg[idVehM].Trip[idTripM].lastCus;
//	int assSPM = seg[idVehM].Trip[idTripM].assSP;
//	int curC;
//    double cStartS;
//	bool stop;
//
//	if (preT < 0) //insert idTripM at the beginning of the vehicle:
//	{
//		varcost += problem->c[0][assSPM];
//		
//		if (idTripM == 0) cStartS = depart[lastCM];
//		else 
//		{
//			varvioTWSP -= seg[idVehM].Trip[idTripM].vioTWSP;
//			cStartS = problem->leaveSP[assSPM][4]; //load only at sTW2
//			if (PDSDIF(cStartS, seg[idVehM].Trip[idTripM].leaveSP))
//			{
//				curC = seg[idVehM].Trip[idTripM].firstCus;
//				GoThroughDeliveryTrip(lastCM, assSPM, curC, cStartS, varvioTWC);
//			}
//			else cStartS = depart[lastCM];
//		}
//	}
//	else //preT >= 0
//	{
//		varcost -= seg[idVehI].Trip[preT].connectCost;
//		if (seg[idVehI].Trip[preT].Type)
//		{
//			int lastpreT = seg[idVehI].Trip[preT].lastCus;
//			cStartS = depart[lastpreT];
//			stop = calChangeCONNECTAtSP_DD_LastCChanged(lastpreT, idVehM, idTripM, cStartS, varvioTWSP, varcost);
//			if (stop) cStartS = depart[lastCM];
//			else //cStartS is now the leaving time at sp of (idVehM, idTripM):
//			{
//				if (PDSDIF(cStartS, seg[idVehM].Trip[idTripM].leaveSP))
//				{
//					curC = seg[idVehM].Trip[idTripM].firstCus;
//					GoThroughDeliveryTrip(lastCM, assSPM, curC, cStartS, varvioTWC);
//				}
//				else cStartS = depart[lastCM];
//			}
//		}
//		else //preT is pickup
//		{
//			int assSPpreT = seg[idVehI].Trip[preT].assSP;
//			if (assSPpreT == assSPM) //create new p-d SAMESP
//			{
//				if (seg[idVehI].Trip[preT].vioTWSP > eps)
//				{
//					varvioTWSP += (seg[idVehI].Trip[preT].vioTWSP - seg[idVehM].Trip[idTripM].vioTWSP);
//					cStartS = problem->leaveSP[assSPM][1]; //load only at eTW2
//				}
//				else
//				{
//					cStartS = seg[idVehI].Trip[preT].leaveSP + problem->nodeSP[assSPM].load;
//					varvioTWSP -= seg[idVehM].Trip[idTripM].vioTWSP;
//				}
//				if (PDSDIF(cStartS, seg[idVehM].Trip[idTripM].leaveSP))
//				{
//					curC = seg[idVehM].Trip[idTripM].firstCus;
//					GoThroughDeliveryTrip(lastCM, assSPM, curC, cStartS, varvioTWC);
//				}
//				else cStartS = depart[lastCM];
//			}
//			else // p - assSPpreT - assSMP - d DIF SP
//			{
//				cStartS = seg[idVehI].Trip[preT].leaveSP;
//				stop = calChangeCONNECTAtSP_SPSP_MoveSP(idVehM, idTripM, assSPpreT, cStartS, varvioTWSP, varcost);
//				if (stop) cStartS = depart[lastCM];
//				else
//				{
//					if (PDSDIF(cStartS, seg[idVehM].Trip[idTripM].leaveSP))
//					{
//						curC = seg[idVehM].Trip[idTripM].firstCus;
//						GoThroughDeliveryTrip(lastCM, assSPM, curC, cStartS, varvioTWC);
//					}
//					else cStartS = depart[lastCM];
//				}
//			}
//		}//end preT is pickup
//	}//end preT>=0
//	
//	//cStartS is now the time to leave lastCus of (idVehM, idTripM):
//	if (nextT < 0)
//	{
//		//cout<<"VARCOST HERE = "<<varcost<<endl;
//		varcost += problem->c[lastCM][0];
//	}
//	else //not last trip
//	{
//		int firstC_nextT = seg[idVehI].Trip[nextT].firstCus;
//		if (seg[idVehI].Trip[nextT].Type)
//		{
//			if (nextT == 0)
//				varcost -= problem->c[0][seg[idVehI].Trip[nextT].assSP];
//			stop = calChangeCONNECTAtSP_DD_LastCChanged(lastCM, idVehI, nextT, cStartS, varvioTWSP, varcost);
//			if (stop == 0)
//				GoThroughVehicle(idVehI, nextT, varcost, varvioTWC, varvioTWSP, cStartS, seg[idVehI].Trip[nextT].assSP, firstC_nextT);
//		}
//		else //nextT is pickup:
//		{
//			if (nextT == 0)
//				varcost -= problem->c[0][firstC_nextT];
//			varcost += problem->c[lastCM][firstC_nextT];
//			GoThroughVehicle(idVehI, nextT, varcost, varvioTWC, varvioTWSP, cStartS, lastCM, firstC_nextT);
//		}//end nextT is pickup
//	}//end not last trip
//}
//
//void Solution::GoThroughVehicle_InsertDT_ExchangeSP(int idVehI, int preT, int nextT, int idVehM, int idTripM, double &varcost, double & varvioTWC, double &varvioTWSP)
//{
//	//COPY Solution::GoThroughVehicle_InsertDT
//	//Insert delivery trip (idVehM, idTripM) into vehicle idVehI between 2 trips preT and nextT:
//	int lastCM = seg[idVehM].Trip[idTripM].lastCus;
//	int assSPM = seg[idVehM].Trip[idTripM].assSP;
//	int curC;
//    double cStartS;
//	bool stop;
//
//	varcost -= seg[idVehM].Trip[idTripM].connectCost;
//	if (preT < 0) //insert idTripM at the beginning of the vehicle:
//	{
//		if (idTripM == 0) cStartS = depart[lastCM];
//		else 
//		{
//			varcost += problem->c[0][assSPM];
//			varvioTWSP -= seg[idVehM].Trip[idTripM].vioTWSP;
//			cStartS = problem->leaveSP[assSPM][4]; //load only at sTW2
//			if (PDSDIF(cStartS, seg[idVehM].Trip[idTripM].leaveSP))
//			{
//				curC = seg[idVehM].Trip[idTripM].firstCus;
//				GoThroughDeliveryTrip(lastCM, assSPM, curC, cStartS, varvioTWC);
//			}
//			else cStartS = depart[lastCM];
//		}
//	}
//	else //preT >= 0
//	{
//		varcost -= seg[idVehI].Trip[preT].connectCost;
//		if (seg[idVehI].Trip[preT].Type)
//		{
//			int lastpreT = seg[idVehI].Trip[preT].lastCus;
//			cStartS = depart[lastpreT];
//			stop = calChangeCONNECTAtSP_DD_LastCChanged(lastpreT, idVehM, idTripM, cStartS, varvioTWSP, varcost);
//			if (stop) cStartS = depart[lastCM];
//			else //cStartS is now the leaving time at sp of (idVehM, idTripM):
//			{
//				if (PDSDIF(cStartS, seg[idVehM].Trip[idTripM].leaveSP))
//				{
//					curC = seg[idVehM].Trip[idTripM].firstCus;
//					GoThroughDeliveryTrip(lastCM, assSPM, curC, cStartS, varvioTWC);
//				}
//				else cStartS = depart[lastCM];
//			}
//		}
//		else //preT is pickup
//		{
//			int assSPpreT = seg[idVehI].Trip[preT].assSP;
//			if (assSPpreT == assSPM) //create new p-d SAMESP
//			{
//				if (seg[idVehI].Trip[preT].vioTWSP > eps)
//				{
//					varvioTWSP += (seg[idVehI].Trip[preT].vioTWSP - seg[idVehM].Trip[idTripM].vioTWSP);
//					cStartS = problem->leaveSP[assSPM][1]; //load only at eTW2
//				}
//				else
//				{
//					cStartS = seg[idVehI].Trip[preT].leaveSP + problem->nodeSP[assSPM].load;
//					varvioTWSP -= seg[idVehM].Trip[idTripM].vioTWSP;
//				}
//				if (PDSDIF(cStartS, seg[idVehM].Trip[idTripM].leaveSP))
//				{
//					curC = seg[idVehM].Trip[idTripM].firstCus;
//					GoThroughDeliveryTrip(lastCM, assSPM, curC, cStartS, varvioTWC);
//				}
//				else cStartS = depart[lastCM];
//			}
//			else // p - assSPpreT - assSMP - d DIF SP
//			{
//				cStartS = seg[idVehI].Trip[preT].leaveSP;
//				stop = calChangeCONNECTAtSP_SPSP_MoveSP(idVehM, idTripM, assSPpreT, cStartS, varvioTWSP, varcost);
//				if (stop) cStartS = depart[lastCM];
//				else
//				{
//					if (PDSDIF(cStartS, seg[idVehM].Trip[idTripM].leaveSP))
//					{
//						curC = seg[idVehM].Trip[idTripM].firstCus;
//						GoThroughDeliveryTrip(lastCM, assSPM, curC, cStartS, varvioTWC);
//					}
//					else cStartS = depart[lastCM];
//				}
//			}
//		}//end preT is pickup
//	}//end preT>=0
//	
//	//cStartS is now the time to leave lastCus of (idVehM, idTripM):
//	if (nextT < 0)
//	{
//		//cout<<"VARCOST HERE = "<<varcost<<endl;
//		varcost += problem->c[lastCM][0];
//	}
//	else //not last trip
//	{
//		int firstC_nextT = seg[idVehI].Trip[nextT].firstCus;
//		if (seg[idVehI].Trip[nextT].Type)
//		{
//			if (nextT == 0)
//				varcost -= problem->c[0][seg[idVehI].Trip[nextT].assSP];
//			stop = calChangeCONNECTAtSP_DD_LastCChanged(lastCM, idVehI, nextT, cStartS, varvioTWSP, varcost);
//			if (stop == 0)
//				GoThroughVehicle(idVehI, nextT, varcost, varvioTWC, varvioTWSP, cStartS, seg[idVehI].Trip[nextT].assSP, firstC_nextT);
//		}
//		else //nextT is pickup:
//		{
//			if (nextT == 0)
//				varcost -= problem->c[0][firstC_nextT];
//			varcost += problem->c[lastCM][firstC_nextT];
//			GoThroughVehicle(idVehI, nextT, varcost, varvioTWC, varvioTWSP, cStartS, lastCM, firstC_nextT);
//		}//end nextT is pickup
//	}//end not last trip
//}
//
//
//void Solution::GoThroughVehicle_InsertDT_EmptyVeh_ExchangeSP(int idVehI, int idVehM, int idTripM, double &varcost, double & varvioTWC, double &varvioTWSP)
//{
//	//COPY Solution::GoThroughVehicle_InsertDT_ExchangeSP
//	//Insert delivery trip (idVehM, idTripM) into empty vehicle idVehI:
//	int lastCM = seg[idVehM].Trip[idTripM].lastCus;
//   
//	varcost -= seg[idVehM].Trip[idTripM].connectCost;
//	varcost += problem->c[lastCM][0];
//	
//    if (idTripM > 0) 
//	{
//		int assSPM = seg[idVehM].Trip[idTripM].assSP;
//		varcost += problem->c[0][assSPM];
//		varvioTWSP -= seg[idVehM].Trip[idTripM].vioTWSP;
//		double cStartS = problem->leaveSP[assSPM][4]; //load only at sTW2
//		if (PDSDIF(cStartS, seg[idVehM].Trip[idTripM].leaveSP))
//		{
//			int curC = seg[idVehM].Trip[idTripM].firstCus;
//			GoThroughDeliveryTrip(lastCM, assSPM, curC, cStartS, varvioTWC);
//		}
//	}
//}
//
//
//void Solution::GoThroughVehicle_InsertPT(int idVehI, int preT, int nextT, int idVehM, int idTripM, double &varcost, double & varvioTWC, double &varvioTWSP)
//{
//	//Insert pickup trip (idVehM, idTripM) into vehicle idVehI between 2 trips preT and nextT:
//	//nextT < 0 --> preT is last trip of idVehI
//	int firstCM = seg[idVehM].Trip[idTripM].firstCus;
//	int assSPM = seg[idVehM].Trip[idTripM].assSP;
//    double cStartS;
//	bool stop;
//	double vioTWSPNEW = 0;
//
//	if (preT < 0) //insert idTripM at the beginning of the vehicle:
//	{
//		varcost += problem->c[0][firstCM];
//		if (idTripM == 0) 
//		{
//			cStartS = seg[idVehM].Trip[0].leaveSP;
//			vioTWSPNEW = seg[idVehM].Trip[idTripM].vioTWSP;
//		}
//		else 
//		{
//			if (seg[idVehM].Trip[idTripM].numCus == 1)
//			{
//				if (problem->waitingSOneP[firstCM][assSPM])
//				{
//					if (seg[idVehM].Trip[idTripM].waitingS == NO_WS) //before no_WS, now WS
//						varcost += (problem->disCWSSP[firstCM][assSPM] - problem->c[firstCM][assSPM]);
//				}
//				else
//				{
//					if (seg[idVehM].Trip[idTripM].waitingS != NO_WS) //before WS, now NO_WS
//						varcost += (problem->c[firstCM][assSPM] - problem->disCWSSP[firstCM][assSPM]);
//				}
//				cStartS = problem->leaveSPOneP[firstCM][assSPM];
//				varvioTWC -=seg[idVehM].Trip[idTripM].vioTWC;
//			}
//			else
//			{
//				cStartS = 0;
//				GoThroughPickupTrip(idVehM, idTripM, 0, firstCM, cStartS, varvioTWC, vioTWSPNEW, varcost);
//			}
//		}
//		//cStartS is now the leaving time at sp of (idVehM, idTripM)
//	}
//	else //preT >= 0
//	{
//		varcost -= seg[idVehI].Trip[preT].connectCost;
//		if (seg[idVehI].Trip[preT].Type)
//		{
//			int lastCpreT = seg[idVehI].Trip[preT].lastCus;
//			varcost += problem->c[lastCpreT][firstCM];
//			cStartS = depart[lastCpreT];
//			GoThroughPickupTrip(idVehM, idTripM, lastCpreT, firstCM, cStartS, varvioTWC, vioTWSPNEW, varcost);
//		}
//		else //preT is pickup
//		{
//			int assSPpreT = seg[idVehI].Trip[preT].assSP;
//			varcost += problem->c[assSPpreT][firstCM];
//			cStartS = seg[idVehI].Trip[preT].leaveSP;
//			GoThroughPickupTrip(idVehM, idTripM, assSPpreT, firstCM, cStartS, varvioTWC, vioTWSPNEW, varcost);
//		}//end preT is pickup
//	}//end preT>=0
//	
//	//cStartS is now the time to leave lastCus of (idVehM, idTripM) and vioTWSPNEW is new vioTWSP at (idVehM, idTripM)
//	varvioTWSP += (vioTWSPNEW - seg[idVehM].Trip[idTripM].vioTWSP);
//
//	if (nextT < 0)
//	{
//		varcost += problem->c[assSPM][0];
//	}
//	else //not last trip
//	{
//		int firstC_nextT = seg[idVehI].Trip[nextT].firstCus;
//		if (seg[idVehI].Trip[nextT].Type)
//		{
//			int assSPnextT = seg[idVehI].Trip[nextT].assSP;
//			if (nextT == 0)
//				varcost -= problem->c[0][assSPnextT];
//			if (assSPM == assSPnextT)
//			{
//				varvioTWSP += (vioTWSPNEW - seg[idVehI].Trip[nextT].vioTWSP);
//				if (vioTWSPNEW > eps)
//				{
//					if (seg[idVehI].Trip[nextT].vioTWSP > eps) return; //don't need to do anything
//					else
//						cStartS = problem->leaveSP[assSPnextT][1];//load only at eTW2
//				}
//				else //now not vio
//					cStartS += problem->nodeSP[assSPnextT].load;
//				GoThroughVehicle(idVehI, nextT, varcost, varvioTWC, varvioTWSP, cStartS, assSPnextT, firstC_nextT);
//			}
//			else // p - assSPM - assSPnextT - d : DIF SP
//			{
//				stop = calChangeCONNECTAtSP_SPSP_MoveSP(idVehI, nextT, assSPM, cStartS, varvioTWSP, varcost);
//				if (stop == 0)
//					GoThroughVehicle(idVehI, nextT, varcost, varvioTWC, varvioTWSP, cStartS, assSPnextT, firstC_nextT);
//			}//end  p - assSPM - assSPnextT - d : DIF SP
//		}
//		else //nextT is pickup:
//		{
//			varcost += problem->c[assSPM][firstC_nextT];
//			if (nextT == 0)
//				varcost -= problem->c[0][firstC_nextT];
//			GoThroughVehicle(idVehI, nextT, varcost, varvioTWC, varvioTWSP, cStartS, assSPM, firstC_nextT);
//		}//end nextT is pickup
//	}//end not last trip
//}
//
//void Solution::GoThroughVehicle_InsertPT_ExchangeSP(int idVehI, int preT, int nextT, int idVehM, int idTripM, double &varcost, double & varvioTWC, double &varvioTWSP)
//{
//	//COPY Solution::GoThroughVehicle_InsertPT
//	//Insert pickup trip (idVehM, idTripM) into vehicle idVehI between 2 trips preT and nextT:
//	//nextT < 0 --> preT is last trip of idVehI
//	int firstCM = seg[idVehM].Trip[idTripM].firstCus;
//	int assSPM = seg[idVehM].Trip[idTripM].assSP;
//    double cStartS;
//	bool stop;
//	double vioTWSPNEW = 0;
//
//	varcost -= seg[idVehM].Trip[idTripM].connectCost;
//
//	if (preT < 0) //insert idTripM at the beginning of the vehicle:
//	{
//		if (idTripM == 0) 
//		{
//			cStartS = seg[idVehM].Trip[0].leaveSP;
//			vioTWSPNEW = seg[idVehM].Trip[idTripM].vioTWSP;
//		}
//		else 
//		{
//			varcost += problem->c[0][firstCM];
//			if (seg[idVehM].Trip[idTripM].numCus == 1)
//			{
//				if (problem->waitingSOneP[firstCM][assSPM])
//				{
//					if (seg[idVehM].Trip[idTripM].waitingS == NO_WS) //before no_WS, now WS
//						varcost += (problem->disCWSSP[firstCM][assSPM] - problem->c[firstCM][assSPM]);
//				}
//				else
//				{
//					if (seg[idVehM].Trip[idTripM].waitingS != NO_WS) //before WS, now NO_WS
//						varcost += (problem->c[firstCM][assSPM] - problem->disCWSSP[firstCM][assSPM]);
//				}
//				cStartS = problem->leaveSPOneP[firstCM][assSPM];
//				varvioTWC -=seg[idVehM].Trip[idTripM].vioTWC;
//			}
//			else
//			{
//				cStartS = 0;
//				GoThroughPickupTrip(idVehM, idTripM, 0, firstCM, cStartS, varvioTWC, vioTWSPNEW, varcost);
//			}
//		}
//		//cStartS is now the leaving time at sp of (idVehM, idTripM)
//	}
//	else //preT >= 0
//	{
//		varcost -= seg[idVehI].Trip[preT].connectCost;
//		if (seg[idVehI].Trip[preT].Type)
//		{
//			int lastCpreT = seg[idVehI].Trip[preT].lastCus;
//			varcost += problem->c[lastCpreT][firstCM];
//			cStartS = depart[lastCpreT];
//			GoThroughPickupTrip(idVehM, idTripM, lastCpreT, firstCM, cStartS, varvioTWC, vioTWSPNEW, varcost);
//		}
//		else //preT is pickup
//		{
//			int assSPpreT = seg[idVehI].Trip[preT].assSP;
//			varcost += problem->c[assSPpreT][firstCM];
//			cStartS = seg[idVehI].Trip[preT].leaveSP;
//			GoThroughPickupTrip(idVehM, idTripM, assSPpreT, firstCM, cStartS, varvioTWC, vioTWSPNEW, varcost);
//		}//end preT is pickup
//	}//end preT>=0
//	
//	//cStartS is now the time to leave lastCus of (idVehM, idTripM) and vioTWSPNEW is new vioTWSP at (idVehM, idTripM)
//	varvioTWSP += (vioTWSPNEW - seg[idVehM].Trip[idTripM].vioTWSP);
//
//	if (nextT < 0)
//	{
//		varcost += problem->c[assSPM][0];
//	}
//	else //not last trip
//	{
//		int firstC_nextT = seg[idVehI].Trip[nextT].firstCus;
//		if (seg[idVehI].Trip[nextT].Type)
//		{
//			int assSPnextT = seg[idVehI].Trip[nextT].assSP;
//			if (nextT == 0)
//				varcost -= problem->c[0][assSPnextT];
//			if (assSPM == assSPnextT)
//			{
//				varvioTWSP += (vioTWSPNEW - seg[idVehI].Trip[nextT].vioTWSP);
//				if (vioTWSPNEW > eps)
//				{
//					if (seg[idVehI].Trip[nextT].vioTWSP > eps) return; //don't need to do anything
//					else
//						cStartS = problem->leaveSP[assSPnextT][1];//load only at eTW2
//				}
//				else //now not vio
//					cStartS += problem->nodeSP[assSPnextT].load;
//				GoThroughVehicle(idVehI, nextT, varcost, varvioTWC, varvioTWSP, cStartS, assSPnextT, firstC_nextT);
//			}
//			else // p - assSPM - assSPnextT - d : DIF SP
//			{
//				stop = calChangeCONNECTAtSP_SPSP_MoveSP(idVehI, nextT, assSPM, cStartS, varvioTWSP, varcost);
//				if (stop == 0)
//					GoThroughVehicle(idVehI, nextT, varcost, varvioTWC, varvioTWSP, cStartS, assSPnextT, firstC_nextT);
//			}//end  p - assSPM - assSPnextT - d : DIF SP
//		}
//		else //nextT is pickup:
//		{
//			varcost += problem->c[assSPM][firstC_nextT];
//			if (nextT == 0)
//				varcost -= problem->c[0][firstC_nextT];
//			GoThroughVehicle(idVehI, nextT, varcost, varvioTWC, varvioTWSP, cStartS, assSPM, firstC_nextT);
//		}//end nextT is pickup
//	}//end not last trip
//}
//
//
//void Solution::GoThroughVehicle_InsertPT_EmptyVeh_ExchangeSP(int idVehI, int idVehM, int idTripM, double &varcost, double & varvioTWC, double &varvioTWSP)
//{
//	//COPY GoThroughVehicle_InsertPT_ExchangeSP
//	//Insert pickup trip (idVehM, idTripM) into vehicle idVehI between 2 trips preT and nextT:
//	//nextT < 0 --> preT is last trip of idVehI
//	int firstCM = seg[idVehM].Trip[idTripM].firstCus;
//	int assSPM = seg[idVehM].Trip[idTripM].assSP;
//
//	varcost -= seg[idVehM].Trip[idTripM].connectCost;
//	varcost += problem->c[assSPM][0];
//
//		if (idTripM > 0) 	
//		{
//			varcost += problem->c[0][firstCM];
//			if (seg[idVehM].Trip[idTripM].numCus == 1)
//			{
//				if (problem->waitingSOneP[firstCM][assSPM])
//				{
//					if (seg[idVehM].Trip[idTripM].waitingS == NO_WS) //before no_WS, now WS
//						varcost += (problem->disCWSSP[firstCM][assSPM] - problem->c[firstCM][assSPM]);
//				}
//				else
//				{
//					if (seg[idVehM].Trip[idTripM].waitingS != NO_WS) //before WS, now NO_WS
//						varcost += (problem->c[firstCM][assSPM] - problem->disCWSSP[firstCM][assSPM]);
//				}
//				//cStartS = problem->leaveSPOneP[firstCM][assSPM];
//				varvioTWC -=seg[idVehM].Trip[idTripM].vioTWC;
//				varvioTWSP -= seg[idVehM].Trip[idTripM].vioTWSP;
//			}
//			else
//			{
//				double vioTWSPNEW = 0;
//				double cStartS = 0;
//				GoThroughPickupTrip(idVehM, idTripM, 0, firstCM, cStartS, varvioTWC, vioTWSPNEW, varcost);
//				varvioTWSP += (vioTWSPNEW - seg[idVehM].Trip[idTripM].vioTWSP);
//			}
//		}
//		//cStartS is now the leaving time at sp of (idVehM, idTripM)
//}
//
//
//void Solution::GoThroughVehicle_InsertPDTSAMESP(int idVehI, int preT, int nextT, int idVehM, int idTripM, double &varcost, double & varvioTWC, double &varvioTWSP)
//{
//	//Insert pickup-delivery trip samesp (idVehM, idTripM, idTripM+1) into vehicle idVehI between 2 trips preT and nextT:
//	
//	int idTripM1 = idTripM + 1;
//	int firstCM = seg[idVehM].Trip[idTripM].firstCus;
//	int lastCM = seg[idVehM].Trip[idTripM1].lastCus;
//	int assSPM = seg[idVehM].Trip[idTripM].assSP;
//    double cStartS;
//	bool stop;
//	double vioTWSPNEW = 0;
//
//	if (preT < 0) //insert idTripM at the beginning of the vehicle:
//	{
//		varcost += problem->c[0][firstCM];
//		if (idTripM == 0) cStartS = depart[lastCM];
//		else 
//		{
//			if (seg[idVehM].Trip[idTripM].numCus == 1)
//			{
//				if (problem->waitingSOneP[firstCM][assSPM])
//				{
//					if (seg[idVehM].Trip[idTripM].waitingS == NO_WS) //before no_WS, now WS
//						varcost += (problem->disCWSSP[firstCM][assSPM] - problem->c[firstCM][assSPM]);
//				}
//				else
//				{
//					if (seg[idVehM].Trip[idTripM].waitingS != NO_WS) //before WS, now NO_WS
//						varcost += (problem->c[firstCM][assSPM] - problem->disCWSSP[firstCM][assSPM]);
//				}
//				cStartS = problem->leaveSPOneP[firstCM][assSPM] + problem->nodeSP[assSPM].load; //it's fine because first pickup trip with one customer don't vioTWSP
//				varvioTWSP -= (2*seg[idVehM].Trip[idTripM].vioTWSP);
//				varvioTWC -= seg[idVehM].Trip[idTripM].vioTWC;
//				if (PDSDIF(cStartS, seg[idVehM].Trip[idTripM1].leaveSP))
//				   GoThroughDeliveryTrip(lastCM, assSPM, seg[idVehM].Trip[idTripM1].firstCus, cStartS, varvioTWC);
//				else
//					cStartS = depart[lastCM];
//			}
//			else
//			{
//				cStartS = 0;
//				GoThroughPDTripSAMESP(idVehM, idTripM, 0, firstCM, cStartS, varvioTWC, varvioTWSP, varcost);
//			}
//		}
//		//cStartS is now the leaving time at sp of (idVehM, idTripM1)
//	}
//	else //preT >= 0
//	{
//		varcost -= seg[idVehI].Trip[preT].connectCost;
//		if (seg[idVehI].Trip[preT].Type)
//		{
//			int lastCpreT = seg[idVehI].Trip[preT].lastCus;
//			varcost += problem->c[lastCpreT][firstCM];
//			cStartS = depart[lastCpreT];
//			GoThroughPDTripSAMESP(idVehM, idTripM, lastCpreT, firstCM, cStartS, varvioTWC, varvioTWSP, varcost);
//		}
//		else //preT is pickup
//		{
//			int assSPpreT = seg[idVehI].Trip[preT].assSP;
//			varcost += problem->c[assSPpreT][firstCM];
//			cStartS = seg[idVehI].Trip[preT].leaveSP;
//			GoThroughPDTripSAMESP(idVehM, idTripM, assSPpreT, firstCM, cStartS, varvioTWC, varvioTWSP, varcost);
//		}//end preT is pickup
//	}//end preT>=0
//	
//	//cStartS is now the leaving time at sp of (idVehM, idTripM1)
//
//	if (nextT < 0)
//	{
//		varcost += problem->c[lastCM][0];
//	}
//	else //not last trip
//	{
//		int firstC_nextT = seg[idVehI].Trip[nextT].firstCus;
//		if (seg[idVehI].Trip[nextT].Type)
//		{
//			if (nextT == 0)
//				varcost -= problem->c[0][seg[idVehI].Trip[nextT].assSP];
//			stop = calChangeCONNECTAtSP_DD_LastCChanged(lastCM, idVehI, nextT, cStartS, varvioTWSP, varcost);
//			if (stop == 0)
//				GoThroughVehicle(idVehI, nextT, varcost, varvioTWC, varvioTWSP, cStartS, seg[idVehI].Trip[nextT].assSP, firstC_nextT);
//		}
//		else //nextT is pickup:
//		{
//			if (nextT == 0)
//				varcost -= problem->c[0][firstC_nextT];
//			varcost += problem->c[lastCM][firstC_nextT];
//			GoThroughVehicle(idVehI, nextT, varcost, varvioTWC, varvioTWSP, cStartS, lastCM, firstC_nextT);
//		}//end nextT is pickup
//	}//end not last trip
//}
//
//
//void Solution::GoThroughVehicle_InsertPDTSAMESP_ExchangeSP(int idVehI, int preT, int nextT, int idVehM, int idTripM, double &varcost, double & varvioTWC, double &varvioTWSP)
//{
//	//COPY: Solution::GoThroughVehicle_InsertPDTSAMESP
//	//Insert pickup-delivery trip samesp (idVehM, idTripM, idTripM+1) into vehicle idVehI between 2 trips preT and nextT:
//	
//	int idTripM1 = idTripM + 1;
//	int firstCM = seg[idVehM].Trip[idTripM].firstCus;
//	int lastCM = seg[idVehM].Trip[idTripM1].lastCus;
//	int assSPM = seg[idVehM].Trip[idTripM].assSP;
//    double cStartS;
//	bool stop;
//
//	varcost -= seg[idVehM].Trip[idTripM1].connectCost;
//	if (preT < 0) //insert idTripM at the beginning of the vehicle:
//	{
//		if (idTripM == 0) cStartS = depart[lastCM];
//		else 
//		{
//			varcost += problem->c[0][firstCM];
//			if (seg[idVehM].Trip[idTripM].numCus == 1)
//			{
//				if (problem->waitingSOneP[firstCM][assSPM])
//				{
//					if (seg[idVehM].Trip[idTripM].waitingS == NO_WS) //before no_WS, now WS
//						varcost += (problem->disCWSSP[firstCM][assSPM] - problem->c[firstCM][assSPM]);
//				}
//				else
//				{
//					if (seg[idVehM].Trip[idTripM].waitingS != NO_WS) //before WS, now NO_WS
//						varcost += (problem->c[firstCM][assSPM] - problem->disCWSSP[firstCM][assSPM]);
//				}
//				cStartS = problem->leaveSPOneP[firstCM][assSPM] + problem->nodeSP[assSPM].load; //it's fine because first pickup trip with one customer don't vioTWSP
//				varvioTWSP -= (2*seg[idVehM].Trip[idTripM].vioTWSP);
//				varvioTWC -= seg[idVehM].Trip[idTripM].vioTWC;
//				if (PDSDIF(cStartS, seg[idVehM].Trip[idTripM1].leaveSP))
//				   GoThroughDeliveryTrip(lastCM, assSPM, seg[idVehM].Trip[idTripM1].firstCus, cStartS, varvioTWC);
//				else
//					cStartS = depart[lastCM];
//			}
//			else
//			{
//				cStartS = 0;
//				GoThroughPDTripSAMESP(idVehM, idTripM, 0, firstCM, cStartS, varvioTWC, varvioTWSP, varcost);
//			}
//		}
//		//cStartS is now the leaving time at lastCus of (idVehM, idTripM1)
//	}
//	else //preT >= 0
//	{
//		varcost -= seg[idVehI].Trip[preT].connectCost;
//		if (seg[idVehI].Trip[preT].Type)
//		{
//			int lastCpreT = seg[idVehI].Trip[preT].lastCus;
//			varcost += problem->c[lastCpreT][firstCM];
//			cStartS = depart[lastCpreT];
//			GoThroughPDTripSAMESP(idVehM, idTripM, lastCpreT, firstCM, cStartS, varvioTWC, varvioTWSP, varcost);
//		}
//		else //preT is pickup
//		{
//			int assSPpreT = seg[idVehI].Trip[preT].assSP;
//			varcost += problem->c[assSPpreT][firstCM];
//			cStartS = seg[idVehI].Trip[preT].leaveSP;
//			GoThroughPDTripSAMESP(idVehM, idTripM, assSPpreT, firstCM, cStartS, varvioTWC, varvioTWSP, varcost);
//		}//end preT is pickup
//	}//end preT>=0
//	
//	//cStartS is now the leaving time at lastCus of (idVehM, idTripM1)
//
//	if (nextT < 0)
//	{
//		varcost += problem->c[lastCM][0];
//	}
//	else //not last trip
//	{
//		int firstC_nextT = seg[idVehI].Trip[nextT].firstCus;
//		if (seg[idVehI].Trip[nextT].Type)
//		{
//			if (nextT == 0)
//				varcost -= problem->c[0][seg[idVehI].Trip[nextT].assSP];
//			stop = calChangeCONNECTAtSP_DD_LastCChanged(lastCM, idVehI, nextT, cStartS, varvioTWSP, varcost);
//			if (stop == 0)
//				GoThroughVehicle(idVehI, nextT, varcost, varvioTWC, varvioTWSP, cStartS, seg[idVehI].Trip[nextT].assSP, firstC_nextT);
//		}
//		else //nextT is pickup:
//		{
//			if (nextT == 0)
//				varcost -= problem->c[0][firstC_nextT];
//			varcost += problem->c[lastCM][firstC_nextT];
//			GoThroughVehicle(idVehI, nextT, varcost, varvioTWC, varvioTWSP, cStartS, lastCM, firstC_nextT);
//		}//end nextT is pickup
//	}//end not last trip
//}
//
//
//void Solution::GoThroughVehicle_InsertPDTSAMESP_EmptyVeh_ExchangeSP(int idVehI, int idVehM, int idTripM, double &varcost, double & varvioTWC, double &varvioTWSP)
//{
//	//COPY: Solution::GoThroughVehicle_InsertPDTSAMESP
//	//Insert pickup-delivery trip samesp (idVehM, idTripM, idTripM+1) into empty vehicle idVehI:
//	
//	int idTripM1 = idTripM + 1;
//	int firstCM = seg[idVehM].Trip[idTripM].firstCus;
//	int lastCM = seg[idVehM].Trip[idTripM1].lastCus;
//
//	varcost -= seg[idVehM].Trip[idTripM1].connectCost;
//	varcost += problem->c[lastCM][0];
//
//	if (idTripM > 0)
//	{
//			int assSPM = seg[idVehM].Trip[idTripM].assSP;
//			double cStartS;
//			varcost += problem->c[0][firstCM];
//			if (seg[idVehM].Trip[idTripM].numCus == 1)
//			{
//				if (problem->waitingSOneP[firstCM][assSPM])
//				{
//					if (seg[idVehM].Trip[idTripM].waitingS == NO_WS) //before no_WS, now WS
//						varcost += (problem->disCWSSP[firstCM][assSPM] - problem->c[firstCM][assSPM]);
//				}
//				else
//				{
//					if (seg[idVehM].Trip[idTripM].waitingS != NO_WS) //before WS, now NO_WS
//						varcost += (problem->c[firstCM][assSPM] - problem->disCWSSP[firstCM][assSPM]);
//				}
//				cStartS = problem->leaveSPOneP[firstCM][assSPM] + problem->nodeSP[assSPM].load; //it's fine because first pickup trip with one customer don't vioTWSP
//				varvioTWSP -= (2*seg[idVehM].Trip[idTripM].vioTWSP);
//				varvioTWC -= seg[idVehM].Trip[idTripM].vioTWC;
//				if (PDSDIF(cStartS, seg[idVehM].Trip[idTripM1].leaveSP))
//				   GoThroughDeliveryTrip(lastCM, assSPM, seg[idVehM].Trip[idTripM1].firstCus, cStartS, varvioTWC);
//			}
//			else
//			{
//				cStartS = 0;
//				GoThroughPDTripSAMESP(idVehM, idTripM, 0, firstCM, cStartS, varvioTWC, varvioTWSP, varcost);
//			}
//	}
//}
//
//
//void Solution::GoThroughVehicle_DeleteTrip(int idVeh, int idTrip, double &varcost, double & varvioTWC, double &varvioTWSP)
//{
//	//Delete pickup/delivery trip (idVeh, idTrip);
//	double cStartS;
//
//	if (seg[idVeh].numTrips == 1)
//	{
//		if (seg[idVeh].Trip[0].Type)
//		   varcost -= (problem->c[0][seg[idVeh].Trip[0].assSP] + seg[idVeh].Trip[0].connectCost);
//		else
//		   varcost -= (problem->c[0][seg[idVeh].Trip[0].firstCus] + seg[idVeh].Trip[0].connectCost);
//		//varvioTWC -= seg[idVeh].Trip[0].vioTWC;
//		//varvioTWSP -= seg[idVeh].Trip[0].vioTWSP;
//		return;
//	}
//
//	int lastT = seg[idVeh].numTrips-1;
//	if (idTrip == 0)//delete the first delivery/pickup trip
//	{
//		if (seg[idVeh].Trip[0].Type)
//           varcost -= (problem->c[0][seg[idVeh].Trip[0].assSP] + seg[idVeh].Trip[0].connectCost); 
//		else
//		   varcost -= (problem->c[0][seg[idVeh].Trip[0].firstCus] + seg[idVeh].Trip[0].connectCost); 
//		if (seg[idVeh].Trip[1].Type)
//		{
//			int assSPnextT = seg[idVeh].Trip[1].assSP;
//			varcost += problem->c[0][assSPnextT];
//			varvioTWSP -= seg[idVeh].Trip[1].vioTWSP;
//			cStartS = problem->leaveSP[assSPnextT][4]; //load only at sTW2
//			if (PDSDIF(cStartS, seg[idVeh].Trip[1].leaveSP))
//				GoThroughVehicle(idVeh, 1, varcost, varvioTWC, varvioTWSP, cStartS, assSPnextT, seg[idVeh].Trip[1].firstCus);
//		}
//		else
//		{
//			//(idVeh, 1) is now the first pickup trip:
//			varcost += problem->c[0][seg[idVeh].Trip[1].firstCus];
//			GoThroughVehicle_FirstPT(idVeh, 1, varcost, varvioTWC, varvioTWSP);
//			//cout<<"del first pickTrip of veh "<<idVeh<<": varcostD = "<<varcost<<endl;
//		}
//	}
//	else //delete the middle/last pickup/delivery trip
//	{
//		int preT = idTrip - 1; bool stop;
//		varcost -= (seg[idVeh].Trip[preT].connectCost + seg[idVeh].Trip[idTrip].connectCost);
//		if (idTrip == lastT) //delete the last pickup/delivery trip
//		{
//			if (seg[idVeh].Trip[preT].Type) varcost += problem->c[seg[idVeh].Trip[preT].lastCus][0];
//			else varcost += problem->c[seg[idVeh].Trip[preT].assSP][0];
//		}
//		else //delete the middle pickup/delivery trip
//		{
//			int nextT = idTrip + 1;
//			if (seg[idVeh].Trip[preT].Type)
//			{
//				int lastCpreT = seg[idVeh].Trip[preT].lastCus;
//				cStartS = depart[lastCpreT];
//				if (seg[idVeh].Trip[nextT].Type)
//				{
//					stop = calChangeCONNECTAtSP_DD_LastCChanged(lastCpreT, idVeh, nextT, cStartS, varvioTWSP, varcost);
//					if (stop == 0)
//						GoThroughVehicle(idVeh, nextT, varcost, varvioTWC, varvioTWSP, cStartS, seg[idVeh].Trip[nextT].assSP, seg[idVeh].Trip[nextT].firstCus);
//				}
//				else //preT is delivery, deleted trip is pickup/delivery, nextT is pickup
//				{
//					int firstC_nextT = seg[idVeh].Trip[nextT].firstCus;
//					varcost += problem->c[lastCpreT][firstC_nextT];
//					GoThroughVehicle(idVeh, nextT, varcost, varvioTWC, varvioTWSP, cStartS, lastCpreT, firstC_nextT);
//				}
//			}
//			else //preT is pickup, delete the middle pickup/delivery trip:
//			{
//				int assSPpreT = seg[idVeh].Trip[preT].assSP;
//				cStartS = seg[idVeh].Trip[preT].leaveSP;
//				if (seg[idVeh].Trip[nextT].Type)
//				{
//					stop = calChangeCONNECTAtSP_SPSP_MoveSP(idVeh, nextT, assSPpreT, cStartS, varvioTWSP, varcost);
//					if (stop == 0)
//						GoThroughVehicle(idVeh, nextT, varcost, varvioTWC, varvioTWSP, cStartS, seg[idVeh].Trip[nextT].assSP, seg[idVeh].Trip[nextT].firstCus);
//				}
//				else //preT is pickup, deleted trip is pickup/delivery, nextTrip is pickup
//				{
//					int firstC_nextT = seg[idVeh].Trip[nextT].firstCus;
//					varcost += problem->c[assSPpreT][firstC_nextT];
//					GoThroughVehicle(idVeh, nextT, varcost, varvioTWC, varvioTWSP, cStartS, assSPpreT, firstC_nextT);
//				}
//			}//end preT is pickup, delete the middle pickup/delivery trip
//		}//end delete the middle pickup/delivery trip
//	}//end delete the middle/last pickup/delivery trip
//}
//
//void Solution::GoThroughVehicle_DeletePDTrip(int idVeh, int idTrip, double &varcost, double & varvioTWC, double &varvioTWSP)
//{
//	//Delete pickup-delivery trip (idVeh, idTrip);
//	double cStartS;
//	bool stop;
//	if (seg[idVeh].numTrips == 2)
//	{
//	   varcost -= (problem->c[0][seg[idVeh].Trip[0].firstCus] + seg[idVeh].Trip[1].connectCost);
//	   return;
//	}
//
//	int lastT = seg[idVeh].numTrips-1;
//	if (idTrip == 0)//delete the first delivery-pickup trip
//	{
//	    varcost -= (problem->c[0][seg[idVeh].Trip[0].firstCus] + seg[idVeh].Trip[1].connectCost);
//		if (seg[idVeh].Trip[2].Type)
//		{
//			varcost += problem->c[0][seg[idVeh].Trip[2].assSP];
//			int assSPnextT = seg[idVeh].Trip[2].assSP;
//			varvioTWSP -= seg[idVeh].Trip[2].vioTWSP;
//			cStartS = problem->leaveSP[assSPnextT][4]; //load only at sTW2
//			if (PDSDIF(cStartS, seg[idVeh].Trip[2].leaveSP))
//				GoThroughVehicle(idVeh, 2, varcost, varvioTWC, varvioTWSP, cStartS, assSPnextT, seg[idVeh].Trip[2].firstCus);
//		}
//		else
//		{
//			//(idVeh, 2) is now the first pickup trip:
//			varcost += problem->c[0][seg[idVeh].Trip[2].firstCus];
//			GoThroughVehicle_FirstPT(idVeh, 2, varcost, varvioTWC, varvioTWSP);
//			//cout<<"varcost DEL firstPD of veh "<<idVeh<<" = "<<varcost<<endl;
//		}
//	}
//	else //delete the middle/last pickup-delivery trip
//	{
//		int preT = idTrip - 1; int idTrip1 = idTrip + 1;
//		varcost -= (seg[idVeh].Trip[preT].connectCost + seg[idVeh].Trip[idTrip1].connectCost);
//		if (idTrip1 == lastT) //delete the last p-d trip
//		{
//			if (seg[idVeh].Trip[preT].Type) varcost += problem->c[seg[idVeh].Trip[preT].lastCus][0];
//			else varcost += problem->c[seg[idVeh].Trip[preT].assSP][0];
//		}
//		else //delete the middle pickup-delivery trip
//		{
//			int nextT = idTrip1 + 1;
//			if (seg[idVeh].Trip[preT].Type)
//			{
//				int lastCpreT = seg[idVeh].Trip[preT].lastCus;
//				cStartS = depart[lastCpreT];
//				if (seg[idVeh].Trip[nextT].Type)
//				{
//					stop = calChangeCONNECTAtSP_DD_LastCChanged(lastCpreT, idVeh, nextT, cStartS, varvioTWSP, varcost);
//					if (stop == 0)
//						GoThroughVehicle(idVeh, nextT, varcost, varvioTWC, varvioTWSP, cStartS, seg[idVeh].Trip[nextT].assSP, seg[idVeh].Trip[nextT].firstCus);
//				}
//				else //preT is delivery, deleted trip is pickup-delivery, nextT is pickup
//				{
//					int firstC_nextT = seg[idVeh].Trip[nextT].firstCus;
//					varcost += problem->c[lastCpreT][firstC_nextT];
//					GoThroughVehicle(idVeh, nextT, varcost, varvioTWC, varvioTWSP, cStartS, lastCpreT, firstC_nextT);
//				}
//			}
//			else //preT is pickup, delete the middle pickup-delivery trip:
//			{
//				int assSPpreT = seg[idVeh].Trip[preT].assSP;
//				cStartS = seg[idVeh].Trip[preT].leaveSP;
//				if (seg[idVeh].Trip[nextT].Type)
//				{
//					stop = calChangeCONNECTAtSP_SPSP_MoveSP(idVeh, nextT, assSPpreT, cStartS, varvioTWSP, varcost);
//					if (stop == 0)
//						GoThroughVehicle(idVeh, nextT, varcost, varvioTWC, varvioTWSP, cStartS, seg[idVeh].Trip[nextT].assSP, seg[idVeh].Trip[nextT].firstCus);
//				}
//				else //preT is pickup, deleted trip is pickup/delivery, nextTrip is pickup
//				{
//					int firstC_nextT = seg[idVeh].Trip[nextT].firstCus;
//					varcost += problem->c[assSPpreT][firstC_nextT];
//					GoThroughVehicle(idVeh, nextT, varcost, varvioTWC, varvioTWSP, cStartS, assSPpreT, firstC_nextT);
//				}
//			}//end preT is pickup, delete the middle pickup/delivery trip
//		}//end delete the middle pickup/delivery trip
//	}//end delete the middle/last pickup/delivery trip
//}
//
//void Solution::GoThroughVehicle_CombinePickupPre(int idVehI, int preT, int nextT, int idVehM, int idTripM, double &varcost, double &varvioTWC, double &varvioTWSP)
//{
//	// Combine pickup trip (idVehI, preT) with pickup trip (idVehM, idTripM): pickcus of preT + pickcus of idTripM 
//	int assSP = seg[idVehI].Trip[preT].assSP;
//	int preC = seg[idVehI].Trip[preT].lastCus;
//	int curC = seg[idVehM].Trip[idTripM].firstCus;
//	varcost += problem->c[preC][curC];
//	double cStartS, vioTWSPNEW;
//
//	if (preT == 0 && seg[idVehI].Trip[preT].numCus == 1)
//	{
//		cStartS = PDS_MAX(problem->c[0][preC], problem->node[preC].sTW) + problem->node[preC].duration;
//		if (seg[idVehI].Trip[preT].waitingS == NO_WS)
//			varcost -= problem->c[preC][assSP];
//		else varcost -= problem->disCWSSP[preC][assSP];
//		GoThroughPickupTrip(idVehM, idTripM, preC, curC, cStartS, varvioTWC, vioTWSPNEW, varcost);
//	}
//	else
//	{
//		cStartS = depart[preC];
//		if (seg[idVehI].Trip[preT].waitingS == NO_WS)
//			varcost -= problem->c[preC][assSP];
//		else varcost -= problem->disCWSSP[preC][assSP];
//		//cout<<"CombinePickupPre:("<<idVehM<<", "<<idTripM<<", preC = "<<preC<<", curC = "<<curC<<"; cStartS = "<<cStartS<<"; varcost = "<<varcost<<"; ";
//		GoThroughPickupTrip(idVehM, idTripM, preC, curC, cStartS, varvioTWC, vioTWSPNEW, varcost);
//	}
//
//	//cStartS is now the time to leave lastCus of (idVehM, idTripM) and vioTWSPNEW is new vioTWSP at (idVehM, idTripM)
//	varvioTWSP += (vioTWSPNEW - seg[idVehM].Trip[idTripM].vioTWSP - seg[idVehI].Trip[preT].vioTWSP);
//
//	if (nextT > -1) //not last Trip
//	{
//		int firstC_nextT = seg[idVehI].Trip[nextT].firstCus;
//		if (seg[idVehI].Trip[nextT].Type)
//		{
//			int assSPnextT = seg[idVehI].Trip[nextT].assSP;
//			if (assSP == assSPnextT)
//			{
//				varvioTWSP += (vioTWSPNEW - seg[idVehI].Trip[nextT].vioTWSP);
//				if (vioTWSPNEW > eps)
//				{
//					if (seg[idVehI].Trip[nextT].vioTWSP > eps) return; //don't need to do anything
//					else
//						cStartS = problem->leaveSP[assSPnextT][1];//load only at eTW2
//				}
//				else //now not vio
//					cStartS += problem->nodeSP[assSPnextT].load;
//				GoThroughVehicle(idVehI, nextT, varcost, varvioTWC, varvioTWSP, cStartS, assSPnextT, firstC_nextT);
//			}
//			else // p - assSP - assSPnextT - d : DIF SP
//			{
//				varcost -= seg[idVehI].Trip[preT].connectCost;
//				bool stop = calChangeCONNECTAtSP_SPSP_MoveSP(idVehI, nextT, assSP, cStartS, varvioTWSP, varcost);
//				if (stop == 0)
//					GoThroughVehicle(idVehI, nextT, varcost, varvioTWC, varvioTWSP, cStartS, assSPnextT, firstC_nextT);
//			}//end  p - assSPM - assSPnextT - d : DIF SP
//		}
//		else //nextT is pickup:
//		{
//			//varcost += problem->c[assSPM][firstC_nextT];
//			GoThroughVehicle(idVehI, nextT, varcost, varvioTWC, varvioTWSP, cStartS, assSP, firstC_nextT);
//		}//end nextT is pickup
//	}//end not last trip
//	//cout<<"varcost = "<<varcost<<endl;
//}
//
//
//
//void Solution::GoThroughVehicle_CombinePickupPre_NotAlterPre_ExchangeSP(int idVehI, int preT, int assSP, int nextT, int idVehM, int idTripM, double &varcost, double &varvioTWC, double &varvioTWSP)
//{
//	//GOP SAU: Combine pickup trip (idVehI, preT) + (idVehM, idTripM)
//	//if (nextT < 0) --> preT is the last trip
//
//
//	int preC = seg[idVehI].Trip[preT].lastCus;
//	int curC = seg[idVehM].Trip[idTripM].firstCus;
//	varcost += problem->c[preC][curC];
//	//DIF From GoThroughVehicle_CombinePickupPre: included these cost:
//	varcost -= seg[idVehM].Trip[idTripM].connectCost;
//	if (idTripM==0) varcost -= problem->c[0][curC];
//
//	double cStartS, vioTWSPNEW;
//	if (preT == 0 && seg[idVehI].Trip[preT].numCus == 1)
//	{
//		cStartS = PDS_MAX(problem->c[0][preC], problem->node[preC].sTW) + problem->node[preC].duration;
//		if (seg[idVehI].Trip[preT].waitingS == NO_WS)
//			varcost -= problem->c[preC][assSP];
//		else varcost -= problem->disCWSSP[preC][assSP];
//		GoThroughPickupTrip(idVehM, idTripM, preC, curC, cStartS, varvioTWC, vioTWSPNEW, varcost);
//	}
//	else
//	{
//		cStartS = depart[preC];
//		if (seg[idVehI].Trip[preT].waitingS == NO_WS)
//			varcost -= problem->c[preC][assSP];
//		else varcost -= problem->disCWSSP[preC][assSP];
//		GoThroughPickupTrip(idVehM, idTripM, preC, curC, cStartS, varvioTWC, vioTWSPNEW, varcost);
//	}
//
//	//cStartS is now the time to leave sp of (idVehM, idTripM) and vioTWSPNEW is new vioTWSP at (idVehM, idTripM)
//	varvioTWSP += (vioTWSPNEW - seg[idVehM].Trip[idTripM].vioTWSP - seg[idVehI].Trip[preT].vioTWSP);
//
//	if (nextT > -1) //not last Trip
//	{
//		int firstC_nextT = seg[idVehI].Trip[nextT].firstCus;
//		if (seg[idVehI].Trip[nextT].Type)
//		{
//			int assSPnextT = seg[idVehI].Trip[nextT].assSP;
//			if (assSP == assSPnextT)
//			{
//				varvioTWSP += (vioTWSPNEW - seg[idVehI].Trip[nextT].vioTWSP);
//				if (vioTWSPNEW > eps)
//				{
//					if (seg[idVehI].Trip[nextT].vioTWSP > eps) return; //don't need to do anything
//					else
//						cStartS = problem->leaveSP[assSPnextT][1];//load only at eTW2
//				}
//				else //now not vio
//					cStartS += problem->nodeSP[assSPnextT].load;
//				GoThroughVehicle(idVehI, nextT, varcost, varvioTWC, varvioTWSP, cStartS, assSPnextT, firstC_nextT);
//			}
//			else // p - assSP - assSPnextT - d : DIF SP
//			{
//				varcost -= seg[idVehI].Trip[preT].connectCost;
//				bool stop = calChangeCONNECTAtSP_SPSP_MoveSP(idVehI, nextT, assSP, cStartS, varvioTWSP, varcost);
//				if (stop == 0)
//					GoThroughVehicle(idVehI, nextT, varcost, varvioTWC, varvioTWSP, cStartS, assSPnextT, firstC_nextT);
//			}//end  p - assSPM - assSPnextT - d : DIF SP
//		}
//		else //nextT is pickup:
//		{
//			//varcost += problem->c[assSPM][firstC_nextT];
//			GoThroughVehicle(idVehI, nextT, varcost, varvioTWC, varvioTWSP, cStartS, assSP, firstC_nextT);
//		}//end nextT is pickup
//	}//end not last trip
//}
//
//void Solution::GoThroughVehicle_CombinePickupPre_NotAlterPre_ExchangeSP_PD(int idVehI, int preT, int assSP, int nextT, int idVehM, int idTripM, double &varcost, double &varvioTWC, double &varvioTWSP)
//{
//	//GOP SAU: Combine pickup trip (idVehI, preT) + (idVehM, idTripM) where (idVehM,idTripM1) is coordinate
//	//assSP is sp of (idVehI,preT) = (idVehM,idTripM) = (idVehM,idTripM1)
//	//if (nextT < 0) --> preT is the last trip
//    //COPY Solution::GoThroughVehicle_CombinePickupPre_NotAlterPre_ExchangeSP
//
//	int preC = seg[idVehI].Trip[preT].lastCus;
//	int curC = seg[idVehM].Trip[idTripM].firstCus;
//	varcost += (problem->c[preC][curC] - seg[idVehI].Trip[preT].connectCost);
//	//DIF From GoThroughVehicle_CombinePickupPre: included these cost:
//	int idTripM1 = idTripM + 1;
//	varcost -= seg[idVehM].Trip[idTripM1].connectCost;
//	if (idTripM==0) varcost -= problem->c[0][curC];
//
//	double cStartS, vioTWSPNEW;
//	if (preT == 0 && seg[idVehI].Trip[preT].numCus == 1)
//	{
//		cStartS = PDS_MAX(problem->c[0][preC], problem->node[preC].sTW) + problem->node[preC].duration;
//		if (seg[idVehI].Trip[preT].waitingS == NO_WS)
//			varcost -= problem->c[preC][assSP];
//		else varcost -= problem->disCWSSP[preC][assSP];
//		GoThroughPickupTrip(idVehM, idTripM, preC, curC, cStartS, varvioTWC, vioTWSPNEW, varcost);
//	}
//	else
//	{
//		cStartS = depart[preC];
//		if (seg[idVehI].Trip[preT].waitingS == NO_WS)
//			varcost -= problem->c[preC][assSP];
//		else varcost -= problem->disCWSSP[preC][assSP];
//		GoThroughPickupTrip(idVehM, idTripM, preC, curC, cStartS, varvioTWC, vioTWSPNEW, varcost);
//	}
//
//	//cStartS is now the time to leave sp of (idVehM, idTripM) and vioTWSPNEW is new vioTWSP at (idVehM, idTripM)
//	varvioTWSP += (2*(vioTWSPNEW - seg[idVehM].Trip[idTripM].vioTWSP) - seg[idVehI].Trip[preT].vioTWSP);
//	int lastCM = seg[idVehM].Trip[idTripM1].lastCus;
//	if (vioTWSPNEW > eps)
//	{
//		if (seg[idVehM].Trip[idTripM1].vioTWSP > eps) cStartS = depart[lastCM];
//		else 
//		{
//			cStartS = problem->leaveSP[assSP][1];//load only at eTW2
//		    GoThroughDeliveryTrip(lastCM,assSP,seg[idVehM].Trip[idTripM1].firstCus,cStartS,varvioTWC);
//		}
//	}
//	else 
//	{
//		cStartS += problem->nodeSP[assSP].load;
//	    GoThroughDeliveryTrip(lastCM,assSP,seg[idVehM].Trip[idTripM1].firstCus,cStartS,varvioTWC);
//	}
//
//	//cStartS is now the new depart of lastCM of (idVehM, idTripM1)
//
//	if (nextT == -1)
//	{
//		varcost += problem->c[lastCM][0];
//	}
//	else //not last Trip
//	{
//		int firstC_nextT = seg[idVehI].Trip[nextT].firstCus;
//		if (seg[idVehI].Trip[nextT].Type)
//		{
//			/*if (nextT == 0) nextT has to be > 0
//				varcost -= problem->c[0][seg[idVehI].Trip[nextT].assSP];*/
//			bool stop = calChangeCONNECTAtSP_DD_LastCChanged(lastCM, idVehI, nextT, cStartS, varvioTWSP, varcost);
//			if (stop == 0)
//				GoThroughVehicle(idVehI, nextT, varcost, varvioTWC, varvioTWSP, cStartS, seg[idVehI].Trip[nextT].assSP, firstC_nextT);
//		}
//		else //nextT is pickup:
//		{
//			/*if (nextT == 0) nextT has to be > 0
//				varcost -= problem->c[0][firstC_nextT];*/
//			varcost += problem->c[lastCM][firstC_nextT];
//			GoThroughVehicle(idVehI, nextT, varcost, varvioTWC, varvioTWSP, cStartS, lastCM, firstC_nextT);
//		}//end nextT is pickup
//	}//end not last trip
//}
//
//
//void Solution::GoThroughVehicle_CombinePickupPre_AlterPre_ExchangeSP(int idVehI, int preT, int curT, int assSP, int nextT, int idVehM, int idTripM, double &varcost, double &varvioTWC, double &varvioTWSP)
//{
//	//GOP SAU: Combine pickup trip (idVehI, curT) + (idVehM, idTripM)
//	//if (nextT < 0) --> curT is the last trip
//
//	int firstCM = seg[idVehM].Trip[idTripM].firstCus;
//	varcost -= seg[idVehM].Trip[idTripM].connectCost;
//	if (idTripM==0) varcost -= problem->c[0][firstCM];
//
//	int curC = seg[idVehI].Trip[curT].firstCus; int preC;
//	int lastCI = seg[idVehI].Trip[curT].lastCus;
//
//	double cStartS, cArrTime,temp;
//	if (preT < 0) //curT is now the first trip of the vehicle:
//	{
//		varcost += problem->c[0][curC];
//		cStartS = 0; preC = 0;
//	}
//	else //preT >= 0
//	{
//		varcost -= seg[idVehI].Trip[preT].connectCost;
//		if (seg[idVehI].Trip[preT].Type)
//		{
//			preC = seg[idVehI].Trip[preT].lastCus;
//			cStartS = depart[preC];
//		}
//		else //preT is pickup
//		{
//			preC = seg[idVehI].Trip[preT].assSP;
//			cStartS = seg[idVehI].Trip[preT].leaveSP;
//		}//end preT is pickup
//		varcost += problem->c[preC][curC];
//	}//end preT>=0
//
//	while (curC > 0)
//	{
//		cArrTime = cStartS + problem->c[preC][curC];
//		cStartS = PDS_MAX(cArrTime, problem->node[curC].sTW);
//		temp = cStartS - problem->node[curC].eTW;
//		if (temp > eps)
//		{
//			varvioTWC += (temp - vioTWCus[curC]);
//			if (vioTWCus[curC] > eps)
//			{
//				cStartS = depart[lastCI];
//				break;
//			}
//			cStartS = problem->node[curC].eTW;
//		}
//		else varvioTWC -= vioTWCus[curC];
//		if (PDSDIF(cStartS, startS[curC]) == 0) 
//		{
//			cStartS = depart[lastCI];
//			break;
//		}
//		cStartS += problem->node[curC].duration;
//		preC = curC; curC = nextArr[curC];
//	}//end while (curC > 0)
//	//cStartS is now NEW depart of lastCI
//	if (seg[idVehI].Trip[curT].waitingS == NO_WS)
//		varcost -= problem->c[lastCI][assSP];
//	else varcost -= problem->disCWSSP[lastCI][assSP];
//	double vioTWSPNEW;
//	GoThroughPickupTrip(idVehM,idTripM,lastCI,firstCM,cStartS,varvioTWC,vioTWSPNEW,varcost);
//	//cStartS is now the time to leave lastCus of (idVehM, idTripM) and vioTWSPNEW is new vioTWSP at (idVehM, idTripM)
//	varvioTWSP += (vioTWSPNEW - seg[idVehM].Trip[idTripM].vioTWSP - seg[idVehI].Trip[curT].vioTWSP);
//
//	if (nextT > -1) //not last Trip
//	{
//		int firstC_nextT = seg[idVehI].Trip[nextT].firstCus;
//		if (seg[idVehI].Trip[nextT].Type)
//		{
//			int assSPnextT = seg[idVehI].Trip[nextT].assSP;
//			if (assSP == assSPnextT)
//			{
//				varvioTWSP += (vioTWSPNEW - seg[idVehI].Trip[nextT].vioTWSP);
//				if (vioTWSPNEW > eps)
//				{
//					if (seg[idVehI].Trip[nextT].vioTWSP > eps) return; //don't need to do anything
//					else
//						cStartS = problem->leaveSP[assSPnextT][1];//load only at eTW2
//				}
//				else //now not vio
//					cStartS += problem->nodeSP[assSPnextT].load;
//				GoThroughVehicle(idVehI, nextT, varcost, varvioTWC, varvioTWSP, cStartS, assSPnextT, firstC_nextT);
//			}
//			else // p - assSP - assSPnextT - d : DIF SP
//			{
//				varcost -= seg[idVehI].Trip[curT].connectCost;
//				bool stop = calChangeCONNECTAtSP_SPSP_MoveSP(idVehI, nextT, assSP, cStartS, varvioTWSP, varcost);
//				if (stop == 0)
//					GoThroughVehicle(idVehI, nextT, varcost, varvioTWC, varvioTWSP, cStartS, assSPnextT, firstC_nextT);
//			}//end  p - assSPM - assSPnextT - d : DIF SP
//		}
//		else //nextT is pickup:
//		{
//			//varcost += problem->c[assSP][firstC_nextT];
//			GoThroughVehicle(idVehI, nextT, varcost, varvioTWC, varvioTWSP, cStartS, assSP, firstC_nextT);
//		}//end nextT is pickup
//	}//end not last trip
//}
//
//void Solution::GoThroughVehicle_CombinePickupSuc_AlterPre_ExchangeSP(int idVehI, int preT, int curT, int assSP, int idVehM, int idTripM, double &varcost, double &varvioTWC, double &varvioTWSP)
//{
//	//GOP TRUOC: (idVehM,idTripM) + (idVehI,curT)
//	int firstCM = seg[idVehM].Trip[idTripM].firstCus;
//	int lastCM = seg[idVehM].Trip[idTripM].lastCus;
//	varcost -= seg[idVehM].Trip[idTripM].connectCost;
//	
//	int curC, preC;
//	double cStartS, cArrTime,temp;
//	if (preT < 0) //curT is now the first trip of the vehicle:
//	{
//		if (idTripM > 0) varcost += problem->c[0][firstCM];
//		cStartS = 0; preC = 0;
//	}
//	else //preT >= 0
//	{
//		if (idTripM==0) varcost -= problem->c[0][firstCM];
//		varcost -= seg[idVehI].Trip[preT].connectCost;
//		if (seg[idVehI].Trip[preT].Type)
//		{
//			preC = seg[idVehI].Trip[preT].lastCus;
//			cStartS = depart[preC];
//		}
//		else //preT is pickup
//		{
//			preC = seg[idVehI].Trip[preT].assSP;
//			cStartS = seg[idVehI].Trip[preT].leaveSP;
//		}//end preT is pickup
//		varcost += problem->c[preC][firstCM];
//	}//end preT>=0
//
//	curC = firstCM;
//	while (curC > 0)
//	{
//		cArrTime = cStartS + problem->c[preC][curC];
//		cStartS = PDS_MAX(cArrTime, problem->node[curC].sTW);
//		temp = cStartS - problem->node[curC].eTW;
//		if (temp > eps)
//		{
//			varvioTWC += (temp - vioTWCus[curC]);
//			if (vioTWCus[curC] > eps)
//			{
//				cStartS = depart[lastCM];
//				break;
//			}
//			cStartS = problem->node[curC].eTW;
//		}
//		else varvioTWC -= vioTWCus[curC];
//		if (PDSDIF(cStartS, startS[curC]) == 0) 
//		{
//			cStartS = depart[lastCM];
//			break;
//		}
//		cStartS += problem->node[curC].duration;
//		preC = curC; curC = nextArr[curC];
//	}//end while (curC > 0)
//
//	//cStartS is now NEW depart of lastCM
//	if (seg[idVehM].Trip[idTripM].waitingS == NO_WS)
//		varcost -= problem->c[lastCM][assSP];
//	else varcost -= problem->disCWSSP[lastCM][assSP];
//	double vioTWSPNEW;
//	int firstCI = seg[idVehI].Trip[curT].firstCus;
//	varcost += problem->c[lastCM][firstCI];
//	GoThroughPickupTrip(idVehI,curT,lastCM,firstCI,cStartS,varvioTWC,vioTWSPNEW,varcost);
//	//cStartS is now the time to leave lastCus of (idVehI, curT) and vioTWSPNEW is new vioTWSP at (idVehI, curT)
//	varvioTWSP += (vioTWSPNEW - seg[idVehM].Trip[idTripM].vioTWSP - seg[idVehI].Trip[curT].vioTWSP);
//
//	int nextT = curT + 1;
//	if (nextT < seg[idVehI].numTrips)
//	{
//		int firstC_nextT = seg[idVehI].Trip[nextT].firstCus;
//		if (seg[idVehI].Trip[nextT].Type)
//		{
//			int assSPnextT = seg[idVehI].Trip[nextT].assSP;
//			if (assSP == assSPnextT)
//			{
//				varvioTWSP += (vioTWSPNEW - seg[idVehI].Trip[nextT].vioTWSP);
//				if (vioTWSPNEW > eps)
//				{
//					if (seg[idVehI].Trip[nextT].vioTWSP > eps) return; //don't need to do anything
//					else
//						cStartS = problem->leaveSP[assSPnextT][1];//load only at eTW2
//				}
//				else //now not vio
//					cStartS += problem->nodeSP[assSPnextT].load;
//				GoThroughVehicle(idVehI, nextT, varcost, varvioTWC, varvioTWSP, cStartS, assSPnextT, firstC_nextT);
//			}
//			else // p - assSPM - assSPnextT - d : DIF SP
//			{
//				bool stop = calChangeCONNECTAtSP_SPSP_MoveSP(idVehI, nextT, assSP, cStartS, varvioTWSP, varcost);
//				if (stop == 0)
//					GoThroughVehicle(idVehI, nextT, varcost, varvioTWC, varvioTWSP, cStartS, assSPnextT, firstC_nextT);
//			}//end  p - assSPM - assSPnextT - d : DIF SP
//		}
//		else //nextT is pickup:
//		{
//			//varcost += problem->c[assSP][firstC_nextT];
//			GoThroughVehicle(idVehI, nextT, varcost, varvioTWC, varvioTWSP, cStartS, assSP, firstC_nextT);
//		}//end nextT is pickup
//	}//end not last trip
//
//}
//
//
//void Solution::GoThroughVehicle_CombinePickupSuc(int idVehI, int preT, bool lastT, int nextT, int idVehM, int idTripM, double &varcost, double &varvioTWC, double &varvioTWSP)
//{
//	// Combine pickup trip (idVehM, idTripM) with pickup trip (idVehI, nextT)
//	int curC = seg[idVehM].Trip[idTripM].firstCus;
//	int lastCM = seg[idVehM].Trip[idTripM].lastCus;
//	int preC;
//	double cStartS, cArrTime, temp;
//	if (preT < 0)
//	{
//		varcost += (problem->c[0][curC] - problem->c[0][seg[idVehI].Trip[nextT].firstCus]);
//		cStartS = 0; preC = 0;
//		while (curC > 0)
//		{
//			cArrTime = cStartS + problem->c[preC][curC];
//			cStartS = PDS_MAX(cArrTime, problem->node[curC].sTW);
//			temp = cStartS - problem->node[curC].eTW;
//			if (temp > eps)
//			{
//				varvioTWC += (temp - vioTWCus[curC]);
//				if (vioTWCus[curC] > eps)
//				{
//					cStartS = depart[lastCM];
//					break;
//				}
//				cStartS = problem->node[curC].eTW;
//			}
//			else varvioTWC -= vioTWCus[curC];
//			if (PDSDIF(cStartS, startS[curC]) == 0) 
//			{
//				cStartS = depart[lastCM];
//				break;
//			}
//			cStartS += problem->node[curC].duration;
//			preC = curC; curC = nextArr[curC];
//		}//end while (curC > 0)
//		//cStartS is now NEW depart of lastCM:
//	}
//	else //preT > 0
//	{
//		if (seg[idVehI].Trip[preT].Type)
//		{
//			preC = seg[idVehI].Trip[preT].lastCus;
//			cStartS = depart[preC];
//		}
//		else
//		{
//			preC = seg[idVehI].Trip[preT].assSP;
//			cStartS = seg[idVehI].Trip[preT].leaveSP;
//		}
//		varcost += (problem->c[preC][curC] - seg[idVehI].Trip[preT].connectCost);
//		while (curC > 0)
//		{
//			cArrTime = cStartS + problem->c[preC][curC];
//			cStartS = PDS_MAX(cArrTime, problem->node[curC].sTW);
//			temp = cStartS - problem->node[curC].eTW;
//			if (temp > eps)
//			{
//				varvioTWC += (temp - vioTWCus[curC]);
//				if (vioTWCus[curC] > eps)
//				{
//					cStartS = depart[lastCM];
//					break;
//				}
//				cStartS = problem->node[curC].eTW;
//			}
//			else varvioTWC -= vioTWCus[curC];
//			if (PDSDIF(cStartS, startS[curC]) == 0) 
//			{
//				cStartS = depart[lastCM];
//				break;
//			}
//			cStartS += problem->node[curC].duration;
//			preC = curC; curC = nextArr[curC];
//		}//end while (curC > 0)
//		//cStartS is now NEW depart of lastCM:
//	}//end preT > 0
//	curC = seg[idVehI].Trip[nextT].firstCus;
//	varcost += problem->c[lastCM][curC];
//
//	double vioTWSPNEW;
//
//	GoThroughPickupTrip(idVehI, nextT,lastCM,curC,cStartS,varvioTWC,vioTWSPNEW,varcost);
//	
//	int assSP = seg[idVehM].Trip[idTripM].assSP;
//	if (seg[idVehM].Trip[idTripM].waitingS == NO_WS)
//		varcost -= problem->c[lastCM][assSP];
//	else varcost -= problem->disCWSSP[lastCM][assSP];
//
//	//cStartS is now leaving time of (idVehI, nextT)
//	varvioTWSP += (vioTWSPNEW - seg[idVehM].Trip[idTripM].vioTWSP - seg[idVehI].Trip[nextT].vioTWSP);
//
//	
//	if (!lastT)
//	{
//		int nextT1 = nextT + 1;
//		int firstC_nextT = seg[idVehI].Trip[nextT1].firstCus;
//		if (seg[idVehI].Trip[nextT1].Type)
//		{
//			int assSPnextT = seg[idVehI].Trip[nextT1].assSP;
//			if (assSP == assSPnextT)
//			{
//				varvioTWSP += (vioTWSPNEW - seg[idVehI].Trip[nextT1].vioTWSP);
//				if (vioTWSPNEW > eps)
//				{
//					if (seg[idVehI].Trip[nextT1].vioTWSP > eps) return; //don't need to do anything
//					else
//						cStartS = problem->leaveSP[assSPnextT][1];//load only at eTW2
//				}
//				else //now not vio
//					cStartS += problem->nodeSP[assSPnextT].load;
//				GoThroughVehicle(idVehI, nextT1, varcost, varvioTWC, varvioTWSP, cStartS, assSPnextT, firstC_nextT);
//			}
//			else // p - assSPM - assSPnextT - d : DIF SP
//			{
//				bool stop = calChangeCONNECTAtSP_SPSP_MoveSP(idVehI, nextT1, assSP, cStartS, varvioTWSP, varcost);
//				if (stop == 0)
//					GoThroughVehicle(idVehI, nextT1, varcost, varvioTWC, varvioTWSP, cStartS, assSPnextT, firstC_nextT);
//			}//end  p - assSPM - assSPnextT - d : DIF SP
//		}
//		else //nextT1 is pickup:
//		{
//			//varcost += problem->c[assSPM][firstC_nextT];
//			GoThroughVehicle(idVehI, nextT1, varcost, varvioTWC, varvioTWSP, cStartS, assSP, firstC_nextT);
//		}//end nextT1 is pickup
//	}//end not last trip
//
//
//}
//
//void Solution::GoThroughVehicle_CombineDeliveryPre(int idVehI, int preT, int nextT, int idVehM, int idTripM, double &varcost, double &varvioTWC, double &varvioTWSP)
//{
//	// Combine delivery trip (idVehI, preT) with delivery trip (idVehM, idTripM): delcus of preT + delcus of idTripM 
//	int assSP = seg[idVehI].Trip[preT].assSP;
//	int lastCpreT = seg[idVehI].Trip[preT].lastCus;
//	int curC = seg[idVehM].Trip[idTripM].firstCus;
//	int lastCM = seg[idVehM].Trip[idTripM].lastCus;
//	varcost += (problem->c[lastCpreT][curC] - seg[idVehI].Trip[preT].connectCost - problem->c[assSP][curC]);
//	double cStartS;
//	varvioTWSP -= seg[idVehM].Trip[idTripM].vioTWSP;
//
//	cStartS = depart[lastCpreT];
//	GoThroughDeliveryTrip(lastCM,lastCpreT,curC,cStartS,varvioTWC);
//	//cStartS now is the depart of lastCM:
//
//	if (nextT == -1) //preT is the last trip:
//	{
//		varcost += problem->c[lastCM][0];
//	}
//	else
//	{
//		if (seg[idVehI].Trip[nextT].Type)
//		{
//			int assSP1 = seg[idVehI].Trip[nextT].assSP;
//			/*if (seg[idVehI].Trip[preT].waitingS == NO_WS)
//				varcost -= problem->c[lastCpreT][assSP1];
//			else varcost -= problem->disCWSSP[lastCpreT][assSP1];*/
//			bool stop = calChangeCONNECTAtSP_DD_LastCChanged(lastCM,idVehI,nextT,cStartS,varvioTWSP,varcost); 
//			if (stop == 0)
//				GoThroughVehicle(idVehI,nextT,varcost,varvioTWC,varvioTWSP,cStartS,assSP1,seg[idVehI].Trip[nextT].firstCus);
//		}
//		else //nextT is pickup:
//		{
//			int firstC_nextT = seg[idVehI].Trip[nextT].firstCus;
//			varcost += problem->c[lastCM][firstC_nextT];
//			GoThroughVehicle(idVehI,nextT,varcost,varvioTWC,varvioTWSP,cStartS,lastCM,firstC_nextT);
//		}//end nextT is pickup
//	}
//}
//
//void Solution::GoThroughVehicle_CombineDeliveryPre_AlterPre_ExchangeSP(int idVehI, int preT, int curT, int assSP, int nextT, int idVehM, int idTripM, double &varcost, double &varvioTWC, double &varvioTWSP)
//{
//	// Combine delivery trip (idVehI, curT) with delivery trip (idVehM, idTripM): delcus of curT + delcus of idTripM 
//    double cStartS;
//	varcost -= seg[idVehM].Trip[idTripM].connectCost;
//	if (idTripM == 0) varcost -= problem->c[0][assSP];
//	varvioTWSP -= seg[idVehM].Trip[idTripM].vioTWSP;
//
//	int lastCI = seg[idVehI].Trip[curT].lastCus;
//	int curC;
//
//	if (preT < 0) //insert idTripM at the beginning of the vehicle:
//	{
//		varcost += problem->c[0][assSP];
//		cStartS = problem->leaveSP[assSP][4]; //load only at sTW2
//		if (PDSDIF(cStartS, seg[idVehI].Trip[curT].leaveSP))
//		{
//			int curC = seg[idVehI].Trip[curT].firstCus;
//			GoThroughDeliveryTrip(lastCI, assSP, curC, cStartS, varvioTWC);
//		}
//		else cStartS = depart[lastCI];
//	}
//	else //preT >= 0
//	{
//		varcost -= seg[idVehI].Trip[preT].connectCost;
//		if (seg[idVehI].Trip[preT].Type)
//		{
//			int lastpreT = seg[idVehI].Trip[preT].lastCus;
//			cStartS = depart[lastpreT];
//			bool stop = calChangeCONNECTAtSP_DD_LastCChanged(lastpreT, idVehI, curT, cStartS, varvioTWSP, varcost);
//			if (stop) cStartS = depart[lastCI];
//			else //cStartS is now the leaving time at sp of (idVehI, curT):
//			{
//				if (PDSDIF(cStartS, seg[idVehI].Trip[curT].leaveSP))
//				{
//					int curC = seg[idVehI].Trip[curT].firstCus;
//					GoThroughDeliveryTrip(lastCI, assSP, curC, cStartS, varvioTWC);
//				}
//				else cStartS = depart[lastCI];
//			}
//		}
//		else //preT is pickup: dont need to check the case assSPpreT = assSP
//		{
//			int assSPpreT = seg[idVehI].Trip[preT].assSP;
//			// p - assSPpreT - assSP - d DIF SP
//			
//			cStartS = seg[idVehI].Trip[preT].leaveSP;
//			bool stop = calChangeCONNECTAtSP_SPSP_MoveSP(idVehI,curT,assSPpreT,cStartS,varvioTWSP,varcost);
//			if (stop) cStartS = depart[lastCI];
//			else
//			{
//					if (PDSDIF(cStartS, seg[idVehI].Trip[curT].leaveSP))
//					{
//						curC = seg[idVehI].Trip[curT].firstCus;
//						GoThroughDeliveryTrip(lastCI, assSP, curC, cStartS, varvioTWC);
//					}
//					else cStartS = depart[lastCI];
//			}
//		}//end preT is pickup
//	}//end preT >= 0
//
//	//cStartS is now the NEW depart[lastCI]
//	curC = seg[idVehM].Trip[idTripM].firstCus;
//	int lastCM = seg[idVehM].Trip[idTripM].lastCus;
//	varcost += (problem->c[lastCI][curC] - seg[idVehI].Trip[curT].connectCost - problem->c[assSP][curC]);
//	GoThroughDeliveryTrip(lastCM,lastCI,curC,cStartS,varvioTWC);
//
//	//cStartS now is the depart of lastCM:
//
//	if (nextT == -1) //curT is the last trip:
//	{
//		varcost += problem->c[lastCM][0];
//	}
//	else
//	{
//		if (seg[idVehI].Trip[nextT].Type)
//		{
//			int assSP1 = seg[idVehI].Trip[nextT].assSP;
//			/*if (seg[idVehI].Trip[curT].waitingS == NO_WS)
//				varcost -= problem->c[lastCI][assSP1];
//			else varcost -= problem->disCWSSP[lastCcurT][assSP1];*/
//			bool stop = calChangeCONNECTAtSP_DD_LastCChanged(lastCM,idVehI,nextT,cStartS,varvioTWSP,varcost); 
//			if (stop == 0)
//				GoThroughVehicle(idVehI,nextT,varcost,varvioTWC,varvioTWSP,cStartS,assSP1,seg[idVehI].Trip[nextT].firstCus);
//		}
//		else //nextT is pickup:
//		{
//			int firstC_nextT = seg[idVehI].Trip[nextT].firstCus;
//			varcost += problem->c[lastCM][firstC_nextT];
//			GoThroughVehicle(idVehI,nextT,varcost,varvioTWC,varvioTWSP,cStartS,lastCM,firstC_nextT);
//		}//end nextT is pickup
//	}
//}
//
//void Solution::GoThroughVehicle_CombineDeliveryPre_NotAlterPre_ExchangeSP(int idVehI, int preT, int nextT, int idVehM, int idTripM, double &varcost, double &varvioTWC, double &varvioTWSP)
//{
//	// Combine delivery trip (idVehI, preT) with delivery trip (idVehM, idTripM): delcus of preT + delcus of idTripM 
//	int assSP = seg[idVehI].Trip[preT].assSP;
//	int lastCpreT = seg[idVehI].Trip[preT].lastCus;
//	int curC = seg[idVehM].Trip[idTripM].firstCus;
//	int lastCM = seg[idVehM].Trip[idTripM].lastCus;
//	varcost += (problem->c[lastCpreT][curC] - seg[idVehI].Trip[preT].connectCost - problem->c[assSP][curC] - seg[idVehM].Trip[idTripM].connectCost);
//	if (idTripM == 0) varcost -= problem->c[0][assSP];
//	varvioTWSP -= seg[idVehM].Trip[idTripM].vioTWSP;
//
//	double cStartS = depart[lastCpreT];
//	GoThroughDeliveryTrip(lastCM,lastCpreT,curC,cStartS,varvioTWC);
//	//cStartS now is the depart of lastCM:
//
//	if (nextT == -1) //preT is the last trip:
//	{
//		varcost += problem->c[lastCM][0];
//	}
//	else
//	{
//		if (seg[idVehI].Trip[nextT].Type)
//		{
//			int assSP1 = seg[idVehI].Trip[nextT].assSP;
//			/*if (seg[idVehI].Trip[preT].waitingS == NO_WS)
//				varcost -= problem->c[lastCpreT][assSP1];
//			else varcost -= problem->disCWSSP[lastCpreT][assSP1];*/
//			bool stop = calChangeCONNECTAtSP_DD_LastCChanged(lastCM,idVehI,nextT,cStartS,varvioTWSP,varcost); 
//			if (stop == 0)
//				GoThroughVehicle(idVehI,nextT,varcost,varvioTWC,varvioTWSP,cStartS,assSP1,seg[idVehI].Trip[nextT].firstCus);
//		}
//		else //nextT is pickup:
//		{
//			int firstC_nextT = seg[idVehI].Trip[nextT].firstCus;
//			varcost += problem->c[lastCM][firstC_nextT];
//			GoThroughVehicle(idVehI,nextT,varcost,varvioTWC,varvioTWSP,cStartS,lastCM,firstC_nextT);
//		}//end nextT is pickup
//	}
//}
//
//void Solution::GoThroughVehicle_CombineDeliverySuc(int idVehI, int curT, int assSP, bool lastT, int idVehM, int idTripM, double &varcost, double &varvioTWC, double &varvioTWSP)
//{
//	// Combine delivery trip (idVehM, idTripM) with delivery trip (idVehI, curT) and insert into the vehicle idVehI
//	//assSPM - d + (assSPI - d)
//	int firstCM = seg[idVehM].Trip[idTripM].firstCus;
//	int lastCM = seg[idVehM].Trip[idTripM].lastCus;
//	double cStartS;
//	if (PDSDIF(seg[idVehI].Trip[curT].leaveSP, seg[idVehM].Trip[idTripM].leaveSP))
//	{
//		cStartS = seg[idVehI].Trip[curT].leaveSP;
//		GoThroughDeliveryTrip(lastCM, assSP, firstCM, cStartS, varvioTWC);
// 	}
//	else cStartS = depart[lastCM];
//
//	varvioTWSP -= seg[idVehM].Trip[idTripM].vioTWSP;
//
//	int firstCI = seg[idVehI].Trip[curT].firstCus;
//	int lastCI = seg[idVehI].Trip[curT].lastCus;
//	varcost += (problem->c[lastCM][firstCI] - problem->c[assSP][firstCI]);
//	GoThroughDeliveryTrip(lastCI,lastCM,firstCI,cStartS,varvioTWC);
//
//	//cStartS now is NEW depart[lastCI]
//	if (PDSDIF(depart[lastCI],cStartS))
//	{
//		if (!lastT) //curT is not the last trip:
//		{
//			int nextT = curT + 1;
//			if (seg[idVehI].Trip[nextT].Type)
//			{
//				int assSP1 = seg[idVehI].Trip[nextT].assSP;
//				bool stop = calChangeCONNECTAtSP_DD(lastCI, idVehI,nextT,curT,cStartS,varvioTWSP,varcost);
//				if (stop == 0)
//					GoThroughVehicle(idVehI,nextT,varcost,varvioTWC,varvioTWSP,cStartS,assSP1,seg[idVehI].Trip[nextT].firstCus);
//			}
//			else //nextT is pickup:
//			{
//				int firstC_nextT = seg[idVehI].Trip[nextT].firstCus;
//				GoThroughVehicle(idVehI,nextT,varcost,varvioTWC,varvioTWSP,cStartS,lastCI,firstC_nextT);
//			}//end nextT is pickup
//		}
//
//	}
//
//}
//
//void Solution::GoThroughVehicle_CombineDeliverySuc_AlterPre_ExchangeSP(int idVehI, int preT, int curT, int assSP, int idVehM, int idTripM, double &varcost, double &varvioTWC, double &varvioTWSP)
//{
//	// Combine delivery trip (idVehM, idTripM) with delivery trip (idVehI, curT) and insert into the vehicle idVehI
//	//assSPM - d + (assSPI - d)
//	int firstCM = seg[idVehM].Trip[idTripM].firstCus;
//	int lastCM = seg[idVehM].Trip[idTripM].lastCus;
//	double cStartS;
//
//	varcost -= seg[idVehM].Trip[idTripM].connectCost;
//
//	if (preT < 0) //insert idTripM at the beginning of the vehicle:
//	{
//		if (idTripM == 0) cStartS = depart[lastCM];
//		else 
//		{
//			varcost += problem->c[0][assSP];
//			varvioTWSP -= seg[idVehM].Trip[idTripM].vioTWSP;
//			cStartS = problem->leaveSP[assSP][4]; //load only at sTW2
//			if (PDSDIF(cStartS, seg[idVehM].Trip[idTripM].leaveSP))
//			{
//				int curC = seg[idVehM].Trip[idTripM].firstCus;
//				GoThroughDeliveryTrip(lastCM, assSP, curC, cStartS, varvioTWC);
//			}
//			else cStartS = depart[lastCM];
//		}
//	}
//	else //preT >= 0
//	{
//		varcost -= seg[idVehI].Trip[preT].connectCost;
//		if (idTripM == 0) varcost -= problem->c[0][assSP];
//		if (seg[idVehI].Trip[preT].Type)
//		{
//			int lastpreT = seg[idVehI].Trip[preT].lastCus;
//			cStartS = depart[lastpreT];
//			bool stop = calChangeCONNECTAtSP_DD_LastCChanged(lastpreT, idVehM, idTripM, cStartS, varvioTWSP, varcost);
//			if (stop) cStartS = depart[lastCM];
//			else //cStartS is now the leaving time at sp of (idVehM, idTripM):
//			{
//				if (PDSDIF(cStartS, seg[idVehM].Trip[idTripM].leaveSP))
//				{
//					int curC = seg[idVehM].Trip[idTripM].firstCus;
//					GoThroughDeliveryTrip(lastCM, assSP, curC, cStartS, varvioTWC);
//				}
//				else cStartS = depart[lastCM];
//			}
//		}
//		else //preT is pickup: dont need to check the case assSP = assSPpreT
//		{
//			int assSPpreT = seg[idVehI].Trip[preT].assSP;
//			 // p - assSPpreT - assSP - d DIF SP
//			cStartS = seg[idVehI].Trip[preT].leaveSP;
//			bool stop = calChangeCONNECTAtSP_SPSP_MoveSP(idVehM, idTripM, assSPpreT, cStartS, varvioTWSP, varcost);
//			if (stop) cStartS = depart[lastCM];
//			else
//			{
//				if (PDSDIF(cStartS, seg[idVehM].Trip[idTripM].leaveSP))
//				{
//					int curC = seg[idVehM].Trip[idTripM].firstCus;
//					GoThroughDeliveryTrip(lastCM, assSP, curC, cStartS, varvioTWC);
//				}
//				else cStartS = depart[lastCM];
//			}
//		}//end preT is pickup
//	}//end preT>=0
//
//	int firstCI = seg[idVehI].Trip[curT].firstCus;
//	int lastCI = seg[idVehI].Trip[curT].lastCus;
//	varcost += (problem->c[lastCM][firstCI] - problem->c[assSP][firstCI]);
//	GoThroughDeliveryTrip(lastCI,lastCM,firstCI,cStartS,varvioTWC);
//
//	//cStartS now is NEW depart[lastCI]
//	if (PDSDIF(depart[lastCI],cStartS))
//	{
//		int nextT = curT + 1;
//		if (nextT < seg[idVehI].numTrips) //curT is not the last trip:
//		{
//			if (seg[idVehI].Trip[nextT].Type)
//			{
//				int assSP1 = seg[idVehI].Trip[nextT].assSP;
//				bool stop = calChangeCONNECTAtSP_DD(lastCI, idVehI,nextT,curT,cStartS,varvioTWSP,varcost);
//				if (stop == 0)
//					GoThroughVehicle(idVehI,nextT,varcost,varvioTWC,varvioTWSP,cStartS,assSP1,seg[idVehI].Trip[nextT].firstCus);
//			}
//			else //nextT is pickup:
//			{
//				int firstC_nextT = seg[idVehI].Trip[nextT].firstCus;
//				GoThroughVehicle(idVehI,nextT,varcost,varvioTWC,varvioTWSP,cStartS,lastCI,firstC_nextT);
//			}//end nextT is pickup
//		}
//	}
//
//}
//
//
//
//void Solution::GoThroughVehicle_CombineDeliverySuc_AlterPre_ExchangeSP_PD(int idVehI, int preT, int curT, int assSP, int idVehM, int idTripM, double &varcost, double &varvioTWC, double &varvioTWSP)
//{
//	// Combine P-D trip (idVehM, idTripM,idTripM+1) with delivery trip (idVehI, curT) and insert into the vehicle idVehI
//	//assSPM - d + (assSPI - d)
//
//	//COPY ::GoThroughVehicle_InsertPDTSAMESP_ExchangeSP and ::GoThroughVehicle_CombineDeliverySuc_AlterPre_ExchangeSP
//
//	int idTripM1 = idTripM + 1;
//	int firstCM = seg[idVehM].Trip[idTripM].firstCus;
//	int lastCM = seg[idVehM].Trip[idTripM1].lastCus;
//    double cStartS;
//
//	//COPY ::GoThroughVehicle_InsertPDTSAMESP_ExchangeSP(
//	varcost -= seg[idVehM].Trip[idTripM1].connectCost;
//	if (preT < 0) //insert idTripM at the beginning of the vehicle:
//	{
//		if (idTripM == 0) cStartS = depart[lastCM];
//		else 
//		{
//			varcost += problem->c[0][firstCM];
//			if (seg[idVehM].Trip[idTripM].numCus == 1)
//			{
//				if (problem->waitingSOneP[firstCM][assSP])
//				{
//					if (seg[idVehM].Trip[idTripM].waitingS == NO_WS) //before no_WS, now WS
//						varcost += (problem->disCWSSP[firstCM][assSP] - problem->c[firstCM][assSP]);
//				}
//				else
//				{
//					if (seg[idVehM].Trip[idTripM].waitingS != NO_WS) //before WS, now NO_WS
//						varcost += (problem->c[firstCM][assSP] - problem->disCWSSP[firstCM][assSP]);
//				}
//				cStartS = problem->leaveSPOneP[firstCM][assSP] + problem->nodeSP[assSP].load; //it's fine because first pickup trip with one customer don't vioTWSP
//				varvioTWSP -= (2*seg[idVehM].Trip[idTripM].vioTWSP);
//				varvioTWC -= seg[idVehM].Trip[idTripM].vioTWC;
//				if (PDSDIF(cStartS, seg[idVehM].Trip[idTripM1].leaveSP))
//				   GoThroughDeliveryTrip(lastCM, assSP, seg[idVehM].Trip[idTripM1].firstCus, cStartS, varvioTWC);
//				else
//					cStartS = depart[lastCM];
//			}
//			else
//			{
//				cStartS = 0;
//				GoThroughPDTripSAMESP(idVehM, idTripM, 0, firstCM, cStartS, varvioTWC, varvioTWSP, varcost);
//			}
//		}
//		//cStartS is now the leaving time at lastCus of (idVehM, idTripM1)
//	}
//	else //preT >= 0
//	{
//		varcost -= seg[idVehI].Trip[preT].connectCost;
//		if (seg[idVehI].Trip[preT].Type)
//		{
//			int lastCpreT = seg[idVehI].Trip[preT].lastCus;
//			varcost += problem->c[lastCpreT][firstCM];
//			cStartS = depart[lastCpreT];
//			GoThroughPDTripSAMESP(idVehM, idTripM, lastCpreT, firstCM, cStartS, varvioTWC, varvioTWSP, varcost);
//		}
//		else //preT is pickup
//		{
//			int assSPpreT = seg[idVehI].Trip[preT].assSP;
//			varcost += problem->c[assSPpreT][firstCM];
//			cStartS = seg[idVehI].Trip[preT].leaveSP;
//			GoThroughPDTripSAMESP(idVehM, idTripM, assSPpreT, firstCM, cStartS, varvioTWC, varvioTWSP, varcost);
//		}//end preT is pickup
//	}//end preT>=0
//	
//	//cStartS is now the leaving time at lastCus of (idVehM, idTripM1)
//	//COPY  ::GoThroughVehicle_CombineDeliverySuc_AlterPre_ExchangeSP(
//	int firstCI = seg[idVehI].Trip[curT].firstCus;
//	int lastCI = seg[idVehI].Trip[curT].lastCus;
//	varcost += (problem->c[lastCM][firstCI] - problem->c[assSP][firstCI]);
//	GoThroughDeliveryTrip(lastCI,lastCM,firstCI,cStartS,varvioTWC);
//
//	//cStartS now is NEW depart[lastCI]
//	if (PDSDIF(depart[lastCI],cStartS))
//	{
//		int nextT = curT + 1;
//		if (nextT < seg[idVehI].numTrips) //curT is not the last trip:
//		{
//			if (seg[idVehI].Trip[nextT].Type)
//			{
//				int assSP1 = seg[idVehI].Trip[nextT].assSP;
//				bool stop = calChangeCONNECTAtSP_DD(lastCI, idVehI,nextT,curT,cStartS,varvioTWSP,varcost);
//				if (stop == 0)
//					GoThroughVehicle(idVehI,nextT,varcost,varvioTWC,varvioTWSP,cStartS,assSP1,seg[idVehI].Trip[nextT].firstCus);
//			}
//			else //nextT is pickup:
//			{
//				int firstC_nextT = seg[idVehI].Trip[nextT].firstCus;
//				GoThroughVehicle(idVehI,nextT,varcost,varvioTWC,varvioTWSP,cStartS,lastCI,firstC_nextT);
//			}//end nextT is pickup
//		}
//	}
//
//}
//
//
//void Solution::GoThroughDeliveryTrip(int lastC, int preC, int curC, double &cStartS, double &varvioTWC)
//{
//	double cArrTime, temp;
//	while (curC > 0)
//	{
//		cArrTime = cStartS + problem->c[preC][curC];
//		cStartS = PDS_MAX(cArrTime, problem->node[curC].sTW);
//		temp = cStartS - problem->node[curC].eTW;
//		if (temp > eps)
//		{
//			varvioTWC += (temp - vioTWCus[curC]);
//			if (vioTWCus[curC] > eps) {cStartS = depart[lastC]; break;}
//			cStartS = problem->node[curC].eTW;
//		}
//		else varvioTWC -= vioTWCus[curC];
//		if (PDSDIF(cStartS, startS[curC])==0) {cStartS = depart[lastC]; break;}
//		cStartS += problem->node[curC].duration;
//		preC = curC; curC = nextArr[curC];
//	}//end while (curC > 0)
//}
//
//void Solution::GoThroughPickupTrip(int idVeh, int idTrip, int preC, int curC, double &cStartS, double &varvioTWC, double &vioTWSPNEW, double &varcost)
//{
//	double cArrTime, temp;
//
//	while (curC > 0)
//	{
//		cArrTime = cStartS + problem->c[preC][curC];
//		cStartS = PDS_MAX(cArrTime, problem->node[curC].sTW);
//		temp = cStartS - problem->node[curC].eTW;
//		if (temp > eps)
//		{
//			varvioTWC += (temp - vioTWCus[curC]);
//			if (vioTWCus[curC] > eps)
//			{
//				cStartS = seg[idVeh].Trip[idTrip].leaveSP;
//				vioTWSPNEW = seg[idVeh].Trip[idTrip].vioTWSP;
//				return;
//			}
//			cStartS = problem->node[curC].eTW;
//		}
//		else varvioTWC -= vioTWCus[curC];
//		if (PDSDIF(cStartS, startS[curC]) == 0) 
//		{
//			cStartS = seg[idVeh].Trip[idTrip].leaveSP;
//			vioTWSPNEW = seg[idVeh].Trip[idTrip].vioTWSP;
//			return;
//		}
//		cStartS += problem->node[curC].duration;
//		preC = curC; curC = nextArr[curC];
//	} //end while (curC > 0)
//    calChangeCONNECTAtSP_PickTrip2_1(preC, idVeh, idTrip, cStartS, vioTWSPNEW, varcost);
//}
//
//
//
//void Solution::GoThroughFirstPickupTrip(int idVeh, int idTrip, double &cStartS, double &varvioTWC, double &vioTWSPNEW, double &varcost)
//{
//	int assSP = seg[idVeh].Trip[idTrip].assSP;
//
//	if (seg[idVeh].Trip[idTrip].numCus == 1)
//	{
//		int firstC = seg[idVeh].Trip[idTrip].firstCus;
//		if (problem->waitingSOneP[firstC]) //now go WS
//		{
//			if (seg[idVeh].Trip[idTrip].waitingS == NO_WS) //before NO_WS
//				varcost += (problem->disCWSSP[firstC][assSP] - problem->c[firstC][assSP]);
//		}
//		else
//		{
//			if (seg[idVeh].Trip[idTrip].waitingS != NO_WS) //before go to WS
//				varcost += (problem->c[firstC][assSP] - problem->disCWSSP[firstC][assSP]);
//		}
//		cStartS = problem->leaveSPOneP[firstC][assSP];
//		vioTWSPNEW = 0;
//		varvioTWC -= vioTWCus[firstC];
//	}
//	else //more than 2 customers
//	{
//		cStartS = 0; int preC = 0; int curC = seg[idVeh].Trip[idTrip].firstCus;
//		double cArrTime, temp;
//		while (curC > 0)
//		{
//			cArrTime = cStartS + problem->c[preC][curC];
//			cStartS = PDS_MAX(cArrTime, problem->node[curC].sTW);
//			temp = cStartS - problem->node[curC].eTW;
//			if (temp > eps)
//			{
//				varvioTWC += (temp - vioTWCus[curC]);
//				if (vioTWCus[curC] > eps)
//				{
//					cStartS = seg[idVeh].Trip[idTrip].leaveSP;
//					vioTWSPNEW = seg[idVeh].Trip[idTrip].vioTWSP;
//					return;
//				}
//				cStartS = problem->node[curC].eTW;
//			}
//			else varvioTWC -= vioTWCus[curC];
//			if (PDSDIF(cStartS, startS[curC]) == 0) 
//			{
//				cStartS = seg[idVeh].Trip[idTrip].leaveSP;
//				vioTWSPNEW = seg[idVeh].Trip[idTrip].vioTWSP;
//				return;
//			}
//			cStartS += problem->node[curC].duration;
//			preC = curC; curC = nextArr[curC];
//		} //end while (curC > 0)
//		calChangeCONNECTAtSP_PickTrip2_1(preC, idVeh, idTrip, cStartS, vioTWSPNEW, varcost);
//	}///move than 2 customers 
//}
//
//
//
//
//void Solution::GoThroughPDTripSAMESP(int idVeh, int idTrip, int preC, int curC, double &cStartS, double &varvioTWC, double &varvioTWSP, double &varcost)
//{
//	double cArrTime, temp;
//	int idTrip1 = idTrip + 1;
//	int assSP = seg[idVeh].Trip[idTrip].assSP;
//	int lastC1 = seg[idVeh].Trip[idTrip1].lastCus;
//
//	while (curC > 0)
//	{
//		cArrTime = cStartS + problem->c[preC][curC];
//		cStartS = PDS_MAX(cArrTime, problem->node[curC].sTW);
//		temp = cStartS - problem->node[curC].eTW;
//		if (temp > eps)
//		{
//			varvioTWC += (temp - vioTWCus[curC]);
//			if (vioTWCus[curC] > eps)
//			{
//				cStartS = depart[lastC1];
//				return;
//			}
//			cStartS = problem->node[curC].eTW;
//		}
//		else varvioTWC -= vioTWCus[curC];
//		if (PDSDIF(cStartS, startS[curC]) == 0) 
//		{
//			cStartS = depart[lastC1];
//			return;
//		}
//		cStartS += problem->node[curC].duration;
//		preC = curC; curC = nextArr[curC];
//	} //end while (curC > 0)
//
//	double vioTWSPNEW = 0;
//    calChangeCONNECTAtSP_PickTrip2_1(preC, idVeh, idTrip, cStartS, vioTWSPNEW, varcost);
//
//	//cStartS now is the leaving time at sp of (idVeh, idTrip)
//
//	varvioTWSP += (2*(vioTWSPNEW - seg[idVeh].Trip[idTrip].vioTWSP));
//	if (vioTWSPNEW > eps)
//	{
//		if (seg[idVeh].Trip[idTrip].vioTWSP > eps) //after and before vioTWSP --> dont need to do anything
//		    cStartS = depart[lastC1];
//		else //after vio; before don't vio
//		{
//			cStartS = problem->leaveSP[assSP][1];//load only at eTW2
//			GoThroughDeliveryTrip(lastC1, assSP, seg[idVeh].Trip[idTrip1].firstCus, cStartS, varvioTWC);
//		}
//	}
//	else //after not vio
//	{
//		cStartS += problem->nodeSP[assSP].load;
//		if (PDSDIF(cStartS, seg[idVeh].Trip[idTrip1].leaveSP))
//			GoThroughDeliveryTrip(lastC1, assSP, seg[idVeh].Trip[idTrip1].firstCus, cStartS, varvioTWC);
//		else
//			cStartS = depart[lastC1];
//	}
//}
//
//
//
//bool Solution::calChangeCONNECTAtSP_SPSP_MoveSP(int idVeh, int idTrip, int assSP, double &cStartS, double &varvioTWSP, double &varcost)
//{
//	//calculate variation of varcost, varvioTWSP, cStartS when connecting assSP of pickup trip (idVeh, preT) with assSP1 of delivery trip (idVeh, idTrip)
//	int assSP1 = seg[idVeh].Trip[idTrip].assSP;
//
//	double cArrTime = cStartS + problem->c[assSP][assSP1];
//	if (PDSINRANGE(cArrTime, problem->nodeSP[assSP1].sTW2, problem->nodeSP[assSP1].eTW2))
//	{
//		varvioTWSP -= seg[idVeh].Trip[idTrip].vioTWSP;
//		varcost += problem->c[assSP][assSP1];
//		cStartS = cArrTime + problem->nodeSP[assSP1].load;
//	}
//	else
//	{
//		double temp = cArrTime - problem->nodeSP[assSP1].eTW2;
//		if (temp > eps)
//		{
//			varvioTWSP += (temp - seg[idVeh].Trip[idTrip].vioTWSP);
//			varcost += problem->c[assSP][assSP1];
//			if (seg[idVeh].Trip[idTrip].vioTWSP > eps) return 1;
//			cStartS = problem->leaveSP[assSP1][1]; //load only at eTW2
//		}
//		else
//		{
//			double cArrTimeI = cStartS + problem->disCWSSP[assSP][assSP1];
//			temp = cArrTimeI - problem->nodeSP[assSP1].eTW2;
//			if (temp > eps) //too soon to go sp directly, too late to go through WS:
//			{
//				varvioTWSP += (problem->nodeSP[assSP1].sTW2 - cArrTime - seg[idVeh].Trip[idTrip].vioTWSP);
//				varcost += problem->c[assSP][assSP1];
//				if (seg[idVeh].Trip[idTrip].vioTWSP > eps) return 1;
//				cStartS = problem->leaveSP[assSP1][1]; //load only at eTW2
//			}
//			else //go through WS:
//			{
//				varvioTWSP -= seg[idVeh].Trip[idTrip].vioTWSP;
//				varcost += problem->disCWSSP[assSP][assSP1];
//				cStartS = PDS_MAX(cArrTimeI, problem->nodeSP[assSP1].sTW2) + problem->nodeSP[assSP1].load;
//			}
//		}
//	}
//	return 0;
//}
//
//
//
//
//
//
//bool Solution::moveSPVeh(int assSPM, int idVehM, int assSPI, int idVehI)//move assSPM of idVehM after assSPI of idVehI
//{
//	int idTripM=-1;
//	int moveTripType;//=0: move DeliveryTrip; = 1: move Pickup trip; = 2: move P-D
//	
//	for (int i=0;i<seg[idVehM].numTrips;i++)
//	{
//		if (assSPM == seg[idVehM].Trip[i].assSP) 
//		{
//			idTripM=i; 
//			if (seg[idVehM].Trip[idTripM].Type) moveTripType = 0;
//			else 
//			{
//				int idTripM1 = idTripM + 1;
//				if (idTripM1 < seg[idVehM].numTrips)
//				{
//					if (seg[idVehM].Trip[idTripM1].coordinate) moveTripType = 2;
//					else moveTripType = 1;
//				}
//				else moveTripType = 1;
//			}
//			break;
//		}
//	}
//	if (idTripM==-1) {cout<<"ERROR ON SOLUTION::moveSP"<<endl; exit(-1);}
//
//
//	if (moveTripType == 0)
//	{
//		//1.Insert assSPM after assSPI of idVehI:
//		InsertDeliveryTrip(idVehM, idTripM, assSPM,idVehI, assSPI);
//		//2. Delete assSPM from idVehM:
//		return Update_EmptyTripD(idVehM,idTripM);
//	}
//	else if (moveTripType == 1)
//	{
//		InsertPickupTrip(idVehM,idTripM,assSPM,idVehI,assSPI);
//		return Update_EmptyTripP(idVehM,idTripM);
//	}
//	else
//	{
//		InsertPDTrip(idVehM,idTripM,assSPM,idVehI,assSPI);
//		//cout<<"START moving P-D trip ("<<idVehM<<", "<<idTripM<<")"<<endl;
//		return Update_EmptyTripPD(idVehM,idTripM);
//		//cout<<"Moving xong "<<endl;
//	}
//}
//
////exchange sp si on idVehi with sp sj on idVehj:
//void Solution::exchangeSPVeh(int assSPi, int idVehi, int assSPj, int idVehj)
//{
//	int idTripi=-1;
//	int moveTripTypei;//=0: move DeliveryTrip; = 1: move Pickup trip; = 2: move P-D
//	
//	for (int i=0;i<seg[idVehi].numTrips;i++)
//	{
//		if (assSPi == seg[idVehi].Trip[i].assSP) 
//		{
//			idTripi=i; 
//			if (seg[idVehi].Trip[idTripi].Type) moveTripTypei = 0;
//			else 
//			{
//				int idTripM1 = idTripi + 1;
//				if (idTripM1 < seg[idVehi].numTrips)
//				{
//					if (seg[idVehi].Trip[idTripM1].coordinate) moveTripTypei = 2;
//					else moveTripTypei = 1;
//				}
//				else moveTripTypei = 1;
//			}
//			break;
//		}
//	}
//	if (idTripi==-1) {cout<<"ERROR ON SOLUTION::exchangeSPVeh"<<endl; exit(-1);}
//
//	int idTripj=-1;
//	int moveTripTypej;//=0: move DeliveryTrip; = 1: move Pickup trip; = 2: move P-D
//	
//	for (int i=0;i<seg[idVehj].numTrips;i++)
//	{
//		if (assSPj == seg[idVehj].Trip[i].assSP) 
//		{
//			idTripj=i; 
//			if (seg[idVehj].Trip[idTripj].Type) moveTripTypej = 0;
//			else 
//			{
//				int idTripM1 = idTripj + 1;
//				if (idTripM1 < seg[idVehj].numTrips)
//				{
//					if (seg[idVehj].Trip[idTripM1].coordinate) moveTripTypej = 2;
//					else moveTripTypej = 1;
//				}
//				else moveTripTypej = 1;
//			}
//			break;
//		}
//	}
//	if (idTripj==-1) {cout<<"ERROR ON SOLUTION::exchangeSPVeh"<<endl; exit(-1);}
//
//	int idTripj1 = idTripj + 1;
//	int idTripi1 = idTripi + 1;
//	if (moveTripTypej==2) 
//	{
//	    VRPTrip tripJ = seg[idVehj].Trip[idTripj];
//		VRPTrip tripJ1 = seg[idVehj].Trip[idTripj1];
//		double costDELj = (seg[idVehj].Trip[idTripj].cost + seg[idVehj].Trip[idTripj1].cost);
//		double fitDELj = (seg[idVehj].Trip[idTripj].fitness + seg[idVehj].Trip[idTripj1].fitness);
//		double vioTWCDELj = (seg[idVehj].Trip[idTripj].vioTWC + seg[idVehj].Trip[idTripj1].vioTWC);
//		double vioTWSPDELj = (seg[idVehj].Trip[idTripj].vioTWSP + seg[idVehj].Trip[idTripj1].vioTWSP);
//		int vioCAPDELj = (seg[idVehj].Trip[idTripj].vioCAP + seg[idVehj].Trip[idTripj1].vioCAP);
//		seg[idVehj].cost -= costDELj; seg[idVehj].fitness -= fitDELj;
//		seg[idVehj].vioTWC -= vioTWCDELj; seg[idVehj].vioTWSP -= vioTWSPDELj; seg[idVehj].vioCAP -= vioCAPDELj;
//		cost -= costDELj; fitness -= fitDELj;
//		vioTWC -= vioTWCDELj; vioTWSP -= vioTWSPDELj; vioCAP -= vioCAPDELj;
//		if (moveTripTypei == 2) //moveTripTypei = 2 and moveTripTypej = 2
//		{
//			double costDELi = (seg[idVehi].Trip[idTripi].cost + seg[idVehi].Trip[idTripi1].cost);
//			double fitDELi = (seg[idVehi].Trip[idTripi].fitness + seg[idVehi].Trip[idTripi1].fitness);
//			double vioTWCDELi = (seg[idVehi].Trip[idTripi].vioTWC + seg[idVehi].Trip[idTripi1].vioTWC);
//			double vioTWSPDELi = (seg[idVehi].Trip[idTripi].vioTWSP + seg[idVehi].Trip[idTripi1].vioTWSP);
//			int vioCAPDELi = (seg[idVehi].Trip[idTripi].vioCAP + seg[idVehi].Trip[idTripi1].vioCAP);
//			seg[idVehi].cost -= costDELi; seg[idVehi].fitness -= fitDELi;
//			seg[idVehi].vioTWC -= vioTWCDELi; seg[idVehi].vioTWSP -= vioTWSPDELi; seg[idVehi].vioCAP -= vioCAPDELi;
//			cost -= costDELi; fitness -= fitDELi;
//			vioTWC -= vioTWCDELi; vioTWSP -= vioTWSPDELi; vioCAP -= vioCAPDELi;
//			//CASE 1: Exchange (idVehi, idTripi, idTripi1) with (idVehj, idTripj, idTripj1)
//			seg[idVehj].Trip[idTripj] = seg[idVehi].Trip[idTripi];
//			seg[idVehj].Trip[idTripj1] = seg[idVehi].Trip[idTripi1];
//			InsertPDTrip_ExchangeSP(idVehj, idTripj, idTripi);
//
//			seg[idVehi].Trip[idTripi] = tripJ;
//			seg[idVehi].Trip[idTripi1] = tripJ1;
//			InsertPDTrip_ExchangeSP(idVehi, idTripi, idTripj);
//		}
//		else //moveTripTypei = 0/1 and moveTripTypej = 2
//		{
//			double costDELi = seg[idVehi].Trip[idTripi].cost;
//			double fitDELi = seg[idVehi].Trip[idTripi].fitness;
//			double vioTWCDELi = seg[idVehi].Trip[idTripi].vioTWC;
//			double vioTWSPDELi = seg[idVehi].Trip[idTripi].vioTWSP;
//			int vioCAPDELi = seg[idVehi].Trip[idTripi].vioCAP;
//			seg[idVehi].cost -= costDELi; seg[idVehi].fitness -= fitDELi;
//			seg[idVehi].vioTWC -= vioTWCDELi; seg[idVehi].vioTWSP -= vioTWSPDELi; seg[idVehi].vioCAP -= vioCAPDELi;
//			cost -= costDELi; fitness -= fitDELi;
//			vioTWC -= vioTWCDELi; vioTWSP -= vioTWSPDELi; vioCAP -= vioCAPDELi;
//			//CASE 2: Exchange (idVehi, idTripi) with (idVehj, idTripj, idTripj1)
//			seg[idVehj].Trip[idTripj] = seg[idVehi].Trip[idTripi];
//			//Don toa:
//			int lastTj = seg[idVehj].numTrips - 1;
//			for (int j = idTripj1; j < lastTj; j++)
//			{
//				seg[idVehj].Trip[j] = seg[idVehj].Trip[j+1];
//				UpdateTripnum(idVehj,j);
//			}
//			seg[idVehj].numTrips = lastTj;
//			if (seg[idVehj].Trip[idTripj].Type)
//				InsertDeliveryTrip_ExchangeSP(idVehj,idTripj,idTripi); 
//			else
//			   InsertPickupTrip_ExchangeSP(idVehj, idTripj, idTripi); 
//
//			seg[idVehi].Trip[idTripi] = tripJ;
//			//DON TOA:
//			for (int i = seg[idVehi].numTrips; i > idTripi1; i--)
//			{
//				seg[idVehi].Trip[i] = seg[idVehi].Trip[i-1];
//				UpdateTripnum(idVehi,i);
//			}
//			seg[idVehi].Trip[idTripi1] = tripJ1;
//			seg[idVehi].numTrips += 1;
//			InsertPDTrip_ExchangeSP(idVehi, idTripi, idTripj); 
//		}//end moveTripTypei = 0/1 and moveTripTypej = 2
//	}
//	else //moveTripTypej=0/1
//	{
//	    VRPTrip tripJ = seg[idVehj].Trip[idTripj];
//		double costDELj = seg[idVehj].Trip[idTripj].cost;
//		double fitDELj = seg[idVehj].Trip[idTripj].fitness;
//		double vioTWCDELj = seg[idVehj].Trip[idTripj].vioTWC;
//		double vioTWSPDELj = seg[idVehj].Trip[idTripj].vioTWSP;
//		int vioCAPDELj = seg[idVehj].Trip[idTripj].vioCAP;
//		seg[idVehj].cost -= costDELj; seg[idVehj].fitness -= fitDELj;
//		seg[idVehj].vioTWC -= vioTWCDELj; seg[idVehj].vioTWSP -= vioTWSPDELj; seg[idVehj].vioCAP -= vioCAPDELj;
//		cost -= costDELj; fitness -= fitDELj;
//		vioTWC -= vioTWCDELj; vioTWSP -= vioTWSPDELj; vioCAP -= vioCAPDELj;
//		if (moveTripTypei == 2) //moveTripTypei = 2 and moveTripTypej = 1
//		{
//			double costDELi = (seg[idVehi].Trip[idTripi].cost + seg[idVehi].Trip[idTripi1].cost);
//			double fitDELi = (seg[idVehi].Trip[idTripi].fitness + seg[idVehi].Trip[idTripi1].fitness);
//			double vioTWCDELi = (seg[idVehi].Trip[idTripi].vioTWC + seg[idVehi].Trip[idTripi1].vioTWC);
//			double vioTWSPDELi = (seg[idVehi].Trip[idTripi].vioTWSP + seg[idVehi].Trip[idTripi1].vioTWSP);
//			int vioCAPDELi = (seg[idVehi].Trip[idTripi].vioCAP + seg[idVehi].Trip[idTripi1].vioCAP);
//			seg[idVehi].cost -= costDELi; seg[idVehi].fitness -= fitDELi;
//			seg[idVehi].vioTWC -= vioTWCDELi; seg[idVehi].vioTWSP -= vioTWSPDELi; seg[idVehi].vioCAP -= vioCAPDELi;
//			cost -= costDELi; fitness -= fitDELi;
//			vioTWC -= vioTWCDELi; vioTWSP -= vioTWSPDELi; vioCAP -= vioCAPDELi;
//			//CASE 3: Exchange (idVehi, idTripi, idTripi1) with (idVehj, idTripj)
//			seg[idVehj].Trip[idTripj] = seg[idVehi].Trip[idTripi];
//			//Don toa:
//			for (int j = seg[idVehj].numTrips; j > idTripj1; j--)
//			{
//				seg[idVehj].Trip[j] = seg[idVehj].Trip[j-1];
//				UpdateTripnum(idVehj,j);
//			}
//			seg[idVehj].Trip[idTripj1] = seg[idVehi].Trip[idTripi1];
//			seg[idVehj].numTrips += 1;
//			InsertPDTrip_ExchangeSP(idVehj, idTripj, idTripi);
//
//			seg[idVehi].Trip[idTripi] = tripJ;
//			//Don toa:
//			int lastTi = seg[idVehi].numTrips - 1;
//			for (int i = idTripi1; i < lastTi; i++)
//			{
//				seg[idVehi].Trip[i] = seg[idVehi].Trip[i+1];
//				UpdateTripnum(idVehi,i);
//			}
//			seg[idVehi].numTrips = lastTi;
//			if (seg[idVehi].Trip[idTripi].Type)
//				InsertDeliveryTrip_ExchangeSP(idVehi,idTripi,idTripj); 
//			else
//			   InsertPickupTrip_ExchangeSP(idVehi, idTripi, idTripj); 
//		}
//		else //moveTripTypei = 0/1 and moveTripTypej = 1
//		{
//			double costDELi = seg[idVehi].Trip[idTripi].cost;
//			double fitDELi = seg[idVehi].Trip[idTripi].fitness;
//			double vioTWCDELi = seg[idVehi].Trip[idTripi].vioTWC;
//			double vioTWSPDELi = seg[idVehi].Trip[idTripi].vioTWSP;
//			int vioCAPDELi = seg[idVehi].Trip[idTripi].vioCAP;
//			seg[idVehi].cost -= costDELi; seg[idVehi].fitness -= fitDELi;
//			seg[idVehi].vioTWC -= vioTWCDELi; seg[idVehi].vioTWSP -= vioTWSPDELi; seg[idVehi].vioCAP -= vioCAPDELi;
//			cost -= costDELi; fitness -= fitDELi;
//			vioTWC -= vioTWCDELi; vioTWSP -= vioTWSPDELi; vioCAP -= vioCAPDELi;
//			//CASE 4: Exchange (idVehi, idTripi) with (idVehj, idTripj)
//			seg[idVehj].Trip[idTripj] = seg[idVehi].Trip[idTripi];
//			if (seg[idVehj].Trip[idTripj].Type)
//				InsertDeliveryTrip_ExchangeSP(idVehj,idTripj,idTripi); 
//			else
//			   InsertPickupTrip_ExchangeSP(idVehj, idTripj, idTripi); 
//
//			seg[idVehi].Trip[idTripi] = tripJ;
//			if (seg[idVehi].Trip[idTripi].Type)
//				InsertDeliveryTrip_ExchangeSP(idVehi,idTripi,idTripj); 
//			else
//			   InsertPickupTrip_ExchangeSP(idVehi, idTripi, idTripj); 
//		}//end moveTripTypei = 0/1 and moveTripTypej = 1
//	}//end moveTripTypej=0/1
//
//}
//
//
////-------------------------------------------------- INIT SOLUTION ----------------------------------------------
 /*
void Solution::AssignCusPToSP(int typeofAssCusPToSP)
{
	int TT = problem->endidP + 1;
	int *SPToCusP = new int[TT];

	int i,j;
	for (i=0;i<=nSP;i++) numCusPSP[i] = 0;

	if (typeofAssCusPToSP == 1) //Assign each pickup to its closest sp:
	{
		for (i=startidP;i <= endidP;i++)
		{
			j = problem->node[i].sp[1]; //closest sp of customer i
			SPToCusP[i] = j;
			numCusPSP[j]++; 
			CusPSP[j][numCusPSP[j]] = i;
		}
	}
	else if (typeofAssCusPToSP == 2)
	{
		//Each sp s services a number of its pickup customers closest to it with total demand not exceed the AVG CAP of pick
        int source[PDS_MAX_NUM_SUPPLYPOINTS]; int per[PDS_MAX_NUM_SUPPLYPOINTS];
		for (i=1;i<=nSP;i++) source[i]=i;
		RandPermutation(nSP,source,per);
		int sp, idCus, CAPT;
		for (i=startidP;i<=endidP;i++) SPToCusP[i] = -1;
        for (i=1;i<=nSP;i++)
		{
			sp = per[i]; CAPT = 0;
			for (j=1;j<=problem->numCusPAvailSP[sp];j++)
			{
				idCus = problem->closestPSP[sp][j]; //is pickup cus closest #jth of sp
				//cout<<"idCus = "<<idCus<<";startidP = "<<startidP<<"; endidP = "<<endidP<<endl;
				if (SPToCusP[idCus] == -1) 
				{
				   SPToCusP[idCus]=sp;
				   numCusPSP[sp]++; 
				   CusPSP[sp][numCusPSP[sp]] = idCus;
				   CAPT += problem->node[idCus].capacity;
				   if (CAPT > problem->capDSP[sp]) break;
				}
			}
		}
		for (i=startidP;i<=endidP;i++)
			if (SPToCusP[i]== -1) //pickcus i is not assigned to any sp yet--> need to assign
		    {
				j = problem->node[i].sp[1]; //closest sp of customer i
				SPToCusP[i] = j;
				numCusPSP[j]++; 
				CusPSP[j][numCusPSP[j]] = i;
		    }
      for (i=1;i<=nSP;i++)
	  {
		  cout<<"List cusP of sp "<<i<<": ";
		  for (j=1;j<=numCusPSP[i];j++)
			  cout<<CusPSP[i][j]<<", ";
	      cout<<endl;
	  }
	}
	else
	{
		//Estimate pickup demands based on total delivery demands at each s
        int source[PDS_MAX_NUM_CUSP]; int per[PDS_MAX_NUM_CUSP]; int curCAP[PDS_MAX_NUM_SUPPLYPOINTS];
		int idCus, idS, sp;
		for (i=1;i<=nP;i++) source[i]=i;
		for (i=1;i<=nSP;i++) curCAP[i] = 0;
		RandPermutation(nP,source,per); //create a permutation for pickup cus
		for (i=1;i<=nP;i++)
		{
			idCus = per[i] + nSP;
			if (problem->node[idCus].numSP > 1)
			{
				idS = Rand(1,2); //assign randomly to one of the 2 nearest sp
				sp = problem->node[idCus].sp[idS];
				if (curCAP[sp] + problem->node[idCus].capacity > problem->capDSP[sp]) //if exceed cap:
				{
					if (idS == 1) sp = problem->node[idCus].sp[2];
					else sp = problem->node[idCus].sp[1];
					if (curCAP[sp] + problem->node[idCus].capacity > problem->capDSP[sp]) //if exceed cap--> randomly to any sp
					{
						idS = Rand(1, problem->node[idCus].numSP);
						sp = problem->node[idCus].sp[idS];
					}
				}
			}
			else sp = problem->node[idCus].sp[1];
			curCAP[sp] += problem->node[idCus].capacity;
		    SPToCusP[idCus]=sp;
		    numCusPSP[sp]++; 
		    CusPSP[sp][numCusPSP[sp]] = idCus;
		}
	}
	delete [] SPToCusP;
}
*/
 

//create first pickup trip leaving depot to go to assignSP:
//void Solution::Create_FirstPickupTripLeavingDepot(int assignSP, int &numTrip)
//{
//	//Update 7/11/2013
//
//	int i,j, idCus;
//	double ArrTime, ArrTime1;
//	int goWS, WSIDtemp, WSID;
//
//    //cout<<"Tao vehicle thu "<<idVeh<<endl;
//	seg[numVeh].Trip[0].assSP = assignSP;
//   
//    //1.Insert a pickup customer as the first customer of current trip:
//  
//	 double costMINI = PDS_INFINITY; double temp; int seed=-1;
//	 for (i=1;i<=numCusPSP[assignSP];i++)
//	 {
//		 idCus = CusPSP[assignSP][i];
//		 if (routed[idCus] == 0)
//		 { 
//			 //cout<<"i = "<<i<<"; idCusP = "<<idCus<<"; assSP = "<<assignSP<<endl;
//			 if (problem->waitingSOneP[idCus][assignSP])
//			 {
//				 //cout<<"Co van de ???"<<endl;
//				 temp = problem->c[0][idCus] + problem->disCWSSP[idCus][assignSP];
//				 if (temp < costMINI)
//				 {
//					 seed = idCus;
//					 costMINI = temp;
//					 goWS = problem->CWSSP[idCus][assignSP];
//					 //startSMINI = problem->startSOneP[idCus][assignSP];
//				 }
//			 }
//			 else
//			 {
//				 temp = problem->c[0][idCus] + problem->c[idCus][assignSP];
//				 if (temp < costMINI)
//				 {
//					 seed = idCus;
//					 costMINI = temp;
//					 goWS = NO_WS;
//					 //startSMINI = problem->startSOneP[idCus][assignSP];
//				 }
//			 }
//		 }
//	 }
//
//	 if (seed == -1)
//	 {
//		 cout<<"THERE IS THE CASE CANNOT ROUTE PICKUP CUSTOMERS: "<<endl;
//		 for (i=1;i<=numCusPSP[assignSP];i++)
//		 {
//			 idCus = CusPSP[assignSP][i];
//			 if (routed[idCus]==0)
//				 cout<<"Cus "<<idCus<<" assigned to sp "<<assignSP<<endl;
//		 }
//		 exit(-1);
//	 }
//
//	 routed[seed]=1;  
//	 seg[numVeh].Trip[0].Type = 0;
//     seg[numVeh].Trip[0].firstCus = seed; //id of the first Customer of Leg
//	 seg[numVeh].Trip[0].lastCus = seed; //id of the first Customer of Leg
//	 seg[numVeh].Trip[0].numCus = 1; //#Customers in the leg
//	 seg[numVeh].Trip[0].capacity = problem->node[seed].capacity;
//	 nextArr[seed] = 0; //just correct for initial solution
//	 seg[numVeh].Trip[0].cost = costMINI;
//     seg[numVeh].Trip[0].waitingS = goWS;
//	 //cout<<"CREATE FIRST PICKUP TRIP of veh "<<numVeh<<": "<<seed<<",   WS = "<<goWS<<"; sp = "<<assignSP<<"; cost = "<<costMINI<<endl;
//	 seg[numVeh].Trip[0].feasible = 1;
//	 startS[seed] = problem->startSOneP[seed][assignSP];
//	 depart[seed] = startS[seed] + problem->node[seed].duration;
//	 seg[numVeh].Trip[0].endS = depart[seed];
//	 //cout<<"startS["<<seed<<"] = "<<startS[seed]<<"; depart["<<seed<<"] = "<<depart[seed]<<"; endS = "<<seg[numVeh].Trip[0].endS<<endl;
//	 numCusPRouted[assignSP]++;
//
//
//     // 2. Continue to insert pickup customers:
//     //starting to find pickup customer to insert into the current trip (depot, assignSP):
//     bool cont=true;  
//	 int curC, nextC, preINS, nextINS, insert_after, IDinsert;
//	 double varcost,TOTALTIME,c1, c2, c2OPT;
//
//	 if (numCusPRouted[assignSP] < numCusPSP[assignSP])
//	 {
//		 do
//		 {
//			 insert_after = -1; c2OPT = -PDS_INFINITY;
//			  /*cout<<"numCusP assign to sp"<<assignSP<<" = "<<numCusPSP[assignSP]<<endl;
//			  cout<<"List cusP of sp "<<assignSP<<": ";
//			  for (i=1;i<=numCusPSP[assignSP];i++)
//				  cout<<CusPSP[assignSP][i]<<", ";
//			  cout<<endl;
//			  */
//
//		 	 for (i=1;i<=numCusPSP[assignSP];i++)
//			 {
//					 idCus = CusPSP[assignSP][i];
//					 //cout<<"Checking cusP "<<idCus<<endl;
//					 if (routed[idCus]==0 && seg[numVeh].Trip[0].capacity + problem->node[idCus].capacity < problem->Q)
//					 {
//						 bool ok = 1;
//						 //cout<<"Try with PCus "<<idCus<<endl;
//						 //cout<<"First try to insert at the beginning of the trip:"<<endl;
//						 //1. First try to insert at the beginning of the trip:
//						 nextINS = seg[numVeh].Trip[0].firstCus;
//						 ArrTime = PDS_MAX(problem->c[0][idCus], problem->node[idCus].sTW) + problem->node[idCus].duration + problem->c[idCus][nextINS];
//						 temp = problem->node[nextINS].eTW - ArrTime;
//						 if (temp > 0) 
//						 {
//							 ArrTime = PDS_MAX(ArrTime, problem->node[nextINS].sTW) + problem->node[nextINS].duration;
//							 curC = nextINS; nextC = nextArr[nextINS];
//							 while (nextC > 0)
//							 {
//								 ArrTime += problem->c[curC][nextC];
//								 temp = ArrTime - problem->node[nextC].eTW;
//								 if (temp > eps) {ok = 0; break;} //vioTW at nextC
//								 else
//								 {
//									 ArrTime = PDS_MAX(ArrTime, problem->node[nextC].sTW) + problem->node[nextC].duration;
//									 curC = nextC; nextC = nextArr[curC];
//								 }
//							 }
//							 if (ok) //curC is now pointed to lastC
//							 {
//	                             ArrTime1 = ArrTime + problem->c[curC][assignSP];
//								 temp =  problem->nodeSP[assignSP].eTW1 - ArrTime1;
//								 if (temp > eps) 
//								 {
//									 if (PDSINRANGE(ArrTime1, problem->nodeSP[assignSP].sTW1, problem->nodeSP[assignSP].eTW1))
//										 WSIDtemp = NO_WS;
//									 else
//									 {
//										 ArrTime1 = ArrTime + problem->disCWSSP[curC][assignSP];
//										 temp = ArrTime1 - problem->nodeSP[assignSP].eTW1;
//										 if (temp > eps) ok = 0; //too late to go to sp through WS
//										 else WSIDtemp = problem->CWSSP[curC][assignSP];
//									 }
//									 if (ok)
//									 {
//										 c1 = problem->c[0][idCus] + problem->c[idCus][nextINS] - problem->c[0][nextINS];
//										 if (goWS != WSIDtemp)
//										 {
//											 if (goWS != NO_WS) //before go to WS, after insert don't need to go to WS:
//												 c1 += (problem->c[curC][assignSP] - problem->disCWSSP[curC][assignSP]);
//											 else 
//											 {
//												 c1 += (problem->disCWSSP[curC][assignSP] - problem->c[curC][assignSP]);
//												 /*cout<<"ERROR Create_FirstPickupTripLeavingDepot before insert go to sp, after insert go to WS"<<endl;
//												 cout<<"Trying to insert pickup cus "<<idCus<<" at the beginning of: ";
//												 showTripCost(numVeh,0);
//												 exit(-1);*/
//											 }
//										 }
//										 c2 = problem->c[idCus][assignSP]-c1;
//										 if (c2 > c2OPT) {c2OPT=c2; varcost=c1; IDinsert=idCus; 
//														  insert_after = 0;WSID=WSIDtemp;
//														  TOTALTIME = ArrTime;
//														 } 
//									 }
//								 }							 
//							 }//end if (ok)
//						 }
//						 //else vioTW at first customer of trip
//						
//
//						 //cout<<"Try to insert "<<idCus<<" after each pickup customer j of the trip"<<endl;
//                         //2. try to insert customer idCus after each pickup customer j of the trip:
//						 preINS = seg[numVeh].Trip[0].firstCus;
//						 if (seg[numVeh].Trip[0].numCus == 1)
//						 {
//							  //cout<<"CASE trip has only 1 customer"<<endl;
//							  ArrTime = PDS_MAX(problem->c[0][preINS], problem->node[preINS].sTW) + problem->node[preINS].duration;
//							  ArrTime += problem->c[preINS][idCus];
//							  temp =problem->node[idCus].eTW -  ArrTime;
//							  if (temp > eps)
//							  {
//								  ArrTime = PDS_MAX(ArrTime, problem->node[idCus].sTW) + problem->node[idCus].duration;
//								  ArrTime1 = ArrTime + problem->c[idCus][assignSP];
//								  temp = problem->nodeSP[assignSP].eTW1 - ArrTime1;
//								  if (temp > eps)
//								  {
//									  if (PDSINRANGE(ArrTime1,problem->nodeSP[assignSP].sTW1, problem->nodeSP[assignSP].eTW1))
//									  {
//										  c1 = problem->c[idCus][assignSP];
//										  c1 += problem->c[preINS][idCus];
//										  if (seg[numVeh].Trip[0].waitingS == NO_WS)
//											  c1 -= problem->c[preINS][assignSP];
//										  else c1 -= problem->disCWSSP[preINS][assignSP];
//										  c2 = problem->c[idCus][assignSP]-c1;
//										  if (c2 > c2OPT) {c2OPT=c2; varcost=c1; IDinsert=idCus; 
//														  insert_after = preINS;WSID=NO_WS;
//														  TOTALTIME = ArrTime;} 
//									  }
//									  else
//									  {
//										  ArrTime1 = ArrTime + problem->disCWSSP[idCus][assignSP];
//										  temp = problem->nodeSP[assignSP].eTW1 -  ArrTime1;
//										  if (temp > eps) 
//										  {
//											  c1 = problem->disCWSSP[idCus][assignSP];
//											  c1 += problem->c[preINS][idCus];
//											  if (seg[numVeh].Trip[0].waitingS == NO_WS)
//												  c1 -= problem->c[preINS][assignSP];
//											  else c1 -= problem->disCWSSP[preINS][assignSP];
//											  c2 = problem->c[idCus][assignSP]-c1;
//											  if (c2 > c2OPT) {c2OPT=c2; varcost=c1; IDinsert=idCus; 
//															  insert_after = preINS;WSID=problem->CWSSP[idCus][assignSP];
//															  TOTALTIME = ArrTime;} 
//										  }
//									  }
//								  }
//							  }
//  						 }
//						 else
//						 {
//							 for (j=1;j<=seg[numVeh].Trip[0].numCus;j++)
//							 {
//								ok = 1;
//								ArrTime = depart[preINS] + problem->c[preINS][idCus];
//								temp = problem->node[idCus].eTW -  ArrTime;
//								if (temp > eps)
//								{
//									ArrTime = PDS_MAX(ArrTime, problem->node[idCus].sTW) + problem->node[idCus].duration;
//									//start checking TW from idCus to the end of the trip:
//									curC = idCus; nextC = nextArr[preINS];
//									while (nextC > 0)
//									{
//										ArrTime += problem->c[curC][nextC];
//										temp = ArrTime - problem->node[nextC].eTW;
//										if (temp > eps) {ok = 0;break;} //vioTW at nextC
//										ArrTime = PDS_MAX(ArrTime, problem->node[nextC].sTW) + problem->node[nextC].duration;
//										curC = nextC; nextC = nextArr[nextC];
//									}
//									//now curC point to the last
//									if (ok)
//									{
//										 ArrTime1 = ArrTime + problem->c[curC][assignSP];
//										 temp = problem->nodeSP[assignSP].eTW1 - ArrTime1;
//										 if (temp > eps)
//										 {
//											 if (PDSINRANGE(ArrTime1,problem->nodeSP[assignSP].sTW1, problem->nodeSP[assignSP].eTW1))
//												 WSIDtemp=NO_WS;
//											 else
//											 {
//												  ArrTime1 = ArrTime + problem->disCWSSP[curC][assignSP];
//												  temp = ArrTime1 - problem->nodeSP[assignSP].eTW1;
//												  if (temp > eps) ok=0; //too late to go to sp through WS
//												  else WSIDtemp = problem->CWSSP[curC][assignSP];
//											 }
//											 if (ok)
//											 {
//													 if (j != seg[numVeh].Trip[0].numCus) //nextINS != assignSP								        
//													 {
//														 nextINS = nextArr[preINS];
//														 c1 = problem->c[preINS][idCus] + problem->c[idCus][nextINS] - problem->c[preINS][nextINS];
//														 if (goWS != WSIDtemp)
//														 {
//															 if (goWS != NO_WS) //before go to WS, after insert don't need to go to WS:
//																 c1 += (problem->c[curC][assignSP] - problem->disCWSSP[curC][assignSP]);
//															 else 
//															 {
//																 c1 += (problem->disCWSSP[curC][assignSP] - problem->c[curC][assignSP]);
//																 /*cout<<"ERROR Create_FirstPickupTripLeavingDepot before insert go to sp directly, after insert go to WS"<<endl;
//																 cout<<"Trying to insert pickup "<<idCus<<" after "<<preINS<<": ";
//																 showTripCost(numVeh,0);
//																 exit(-1);*/
//															 }
//														 }
//													 }
//													 else //insert to the end of the leg:
//													 {
//														 c1 = problem->c[preINS][idCus];
//														 if (goWS==NO_WS) //before insert customer idCus, go to sp directly
//														 {
//															 if (WSIDtemp ==NO_WS) c1 += (problem->c[idCus][assignSP] - problem->c[preINS][assignSP]);
//															 else 
//															 {
//																 c1 += (problem->c[preINS][assignSP] - problem->c[idCus][assignSP]);
//																 /*cout<<"Create_FirstPickupTripLeavingDepot  ERROR before insert go to sp directly, after insert need to go to WS"<<endl; 
//																 cout<<"Trying to insert pickup "<<idCus<<" at the end of the trip: ";
//																 showTripCost(numVeh,0);
//																 exit(-1);*/
//															 }
//														 }
//														 else //before insert customer idCus, go to WS:
//														 {
//															 if (WSIDtemp == NO_WS) c1 += (problem->c[idCus][assignSP] - problem->disCWSSP[preINS][assignSP]);
//															 else c1+=(problem->disCWSSP[idCus][assignSP] - problem->disCWSSP[preINS][assignSP]);
//														 }
//													 }
//													 c2 = problem->c[idCus][assignSP]-c1;
//													 if (c2 > c2OPT) {c2OPT=c2; varcost=c1; IDinsert=idCus; 
//																	  insert_after = preINS;WSID=WSIDtemp;
//																	  TOTALTIME = ArrTime;} 
//											 }//else too early to go to sp directly, but go through WS too late
//										} //else vioTW at assignSP
//									}//end if (ok): //everything is fine till last cus
//								}//end else:not vioTW at idCus
//								preINS = nextArr[preINS];
//							 }//end for
//						 }
//					 }//end if routedP[idCus]==0...
//			 }//end for: try all unrouted pickup customers assigned to assignSP
//
//			 if (insert_after!=-1)
//			 {
//				  //cout<<"Insert customer "<<IDinsert<<" after "<<insert_after<<": "<<endl;
//				  if (insert_after == 0)
//				  {
//					  int pre = seg[numVeh].Trip[0].firstCus;
//					  seg[numVeh].Trip[0].firstCus = IDinsert;
//					  nextArr[IDinsert] = pre;
//					  startS[IDinsert] = problem->node[IDinsert].startS_depot; // PDS_MAX(problem->c[0][IDinsert], problem->node[IDinsert].sTW);
//					  depart[IDinsert] = problem->node[IDinsert].depart_depot; //startS[IDinsert] + problem->node[IDinsert].duration;
//					  updateStartSP_FEASIBLETRIP(numVeh,0,IDinsert,nextArr[IDinsert]);
//				  }
//				  else if (insert_after == seg[numVeh].Trip[0].lastCus) //insert at the end of the trip:
//				  {
//					  nextArr[insert_after] = IDinsert;
//					  seg[numVeh].Trip[0].lastCus=IDinsert;
//					  nextArr[IDinsert]=0;
//					  if (insert_after == seg[numVeh].Trip[0].firstCus)
//					  {
//			              startS[insert_after] = problem->node[insert_after].startS_depot; //PDS_MAX(problem->c[0][insert_after], problem->node[insert_after].sTW);
//			              depart[insert_after] = problem->node[insert_after].depart_depot; //startS[insert_after] + problem->node[insert_after].duration;
//						  ArrTime = depart[insert_after] + problem->c[insert_after][IDinsert];
//						  startS[IDinsert] = PDS_MAX(ArrTime, problem->node[IDinsert].sTW);
//						  depart[IDinsert] = startS[IDinsert] + problem->node[IDinsert].duration;
//					  }
//					  else
//					  {
//						  ArrTime = depart[insert_after] + problem->c[insert_after][IDinsert];
//						  startS[IDinsert] = PDS_MAX(ArrTime, problem->node[IDinsert].sTW);
//						  depart[IDinsert] = startS[IDinsert] + problem->node[IDinsert].duration;
//					  }
//					  //cout<<"*************Insert customer "<<IDinsert<<" at the end of the leg: after "<<insert_after<<endl;
//				  }
//				  else //insert at the middile of the leg:
//				  {
//					  int tt=nextArr[insert_after];
//					  nextArr[insert_after]=IDinsert;
//					  nextArr[IDinsert]=tt;
//					  updateStartSP_FEASIBLETRIP(numVeh,0,insert_after,IDinsert);
//					  //cout<<"***********Insert customer "<<IDinsert<<" in the middle of the leg: after "<<insert_after<<endl;
//				  }
//				  seg[numVeh].Trip[0].numCus++;seg[numVeh].Trip[0].waitingS = WSID;
//				  routed[IDinsert]=1;
//				  seg[numVeh].Trip[0].capacity += problem->node[IDinsert].capacity;
//				  goWS = WSID;
//				  seg[numVeh].Trip[0].cost += varcost;
//
//				  seg[numVeh].Trip[0].endS = TOTALTIME;
//				  numCusPRouted[assignSP]++;
//				  if (numCusPRouted[assignSP] == numCusPSP[assignSP]) cont = 0;
//				  checkEndSFirstPT(numVeh);
//			}
//			else cont = 0;  //can't find any customer to insert into the current leg
//		 }while (cont);
//	 } //end if (numCusPRouted[assignSP] < numCusPSP[assignSP])
//     int lastC = seg[numVeh].Trip[0].lastCus;
//	 if (goWS == NO_WS)
//		 ArrTime = seg[numVeh].Trip[0].endS + problem->c[lastC][assignSP];
//	 else
//		 ArrTime = seg[numVeh].Trip[0].endS + problem->disCWSSP[lastC][assignSP];
//	 seg[numVeh].Trip[0].leaveSP = PDS_MAX(ArrTime, problem->nodeSP[assignSP].sTW1) + problem->nodeSP[assignSP].unload;
//	 numTrip++;
//     /*cout<<"The first Pickup trip of Vehicle "<<numVeh<<" has "<<seg[numVeh].Trip[0].numCus<<" Pcustomers; leaveSP = "<<seg[numVeh].Trip[0].leaveSP<<endl;
//	 showTripCus(numVeh,0);*/
//	 /*if (seg[numVeh].Trip[0].numCus == 1)
//	 {
//		 int buon = seg[numVeh].Trip[0].firstCus;
//		 cout<<"StartS["<<buon<<"] = "<<startS[buon]<<"; depart = "<<depart[buon]<<endl;
//		 cout<<"endS = "<<seg[numVeh].Trip[0].endS<<endl;
//	 }*/
//}
//
//bool Solution::CreateC2CTrip_BeforePickupTrip(int idVeh, int idTrip, int assSP, int preC, double depart_preC)
//{
//	//Update 7/11/2013: Create a C2C Trip before pickup trip(idVeh, idTrip): such that all trips are feasible; 
//	//will try to insert C2C right after preC
//
//	double cStartS = depart_preC;
//
//	int idCusP, idCusD;
//	double ArrTime;
//
//	//cout<<"TRYING TO Create C2C trip before PTrip("<<idVeh<<", "<<idTrip<<")"<<endl;
//   
//    //1.Insert a C2C as the first customer of current trip:
//	 double costT;
//	 double costMINI = PDS_INFINITY; double temp; int seed=-1;
//	 bool changedSEED, changed;
//	 int firstC_nextT = seg[idVeh].Trip[idTrip].firstCus;
//	 
//	 for (idCusP = startidC2C;idCusP <= endidC2CP; idCusP ++)
//	 {
//		 if (routed[idCusP] == 0 && problem->belong[idCusP][assSP])
//		 { 
//			 idCusD = problem->node[idCusP].delID;
//			 costT = problem->c[preC][idCusP] + problem->c[idCusP][idCusD] + problem->c[idCusD][firstC_nextT];
//			 if (costT > costMINI) continue;
//			 ArrTime = PDS_MAX(cStartS + problem->c[preC][idCusP], problem->node[idCusP].sTW); 
//			 temp = ArrTime - problem->node[idCusP].eTW;
//			 if (temp > eps) continue;
//			 ArrTime += (problem->node[idCusP].duration + problem->c[idCusP][idCusD]);
//			 temp = ArrTime - problem->node[idCusD].eTW;
//			 if (temp > eps) continue;
//			 ArrTime = PDS_MAX(ArrTime, problem->node[idCusD].sTW) + problem->node[idCusD].duration;
//             bool cont = 0;
//			 changed = 0;
//			 cont = checkPickupTripFeasible_AfterInsertC2C(idCusD,ArrTime,costT,idVeh,idTrip,changed);
//			 if (cont)
//			 {
//				 if (costT < costMINI)
//				 {
//					 seed = idCusP;
//					 costMINI = costT;
//					 changedSEED = changed;
//				 }
//			 }
//		 }
//	 }
//
//	 if (seed == -1)
//	 {
//		 //cout<<"CANNOT insert C2C trip before PTrip("<<idVeh<<", "<<idTrip<<")"<<endl;
//		 return 0;
//	 }
//
//	 idCusD = problem->node[seed].delID;
//	 //cout<<"-->CAN Create C2C trip before PTrip("<<idVeh<<", "<<idTrip<<"): firstC2CD = "<<idCusD<<endl;
//	 routed[seed]=1; routed[idCusD] = 1;
//	 int nextT = idTrip + 1;
//	 seg[idVeh].Trip[nextT] = seg[idVeh].Trip[idTrip];
//	 seg[idVeh].Trip[idTrip].Type = 2;
//	 seg[idVeh].Trip[idTrip].firstCus = seed;
//	 seg[idVeh].Trip[idTrip].lastCus = idCusD;
//	 int preT = idTrip - 1;
//	 if (idTrip == 0)
//	 {
//		 seg[idVeh].Trip[idTrip].cost = problem->c[0][seed] + problem->c[seed][idCusD] + problem->c[idCusD][firstC_nextT];
//	 }
//	 else
//	 {
//		 seg[idVeh].Trip[preT].cost += (problem->c[preC][seed] - seg[idVeh].Trip[preT].connectCost);
//		 seg[idVeh].Trip[preT].connectCost = problem->c[preC][seed];
//		 seg[idVeh].Trip[idTrip].cost = problem->c[seed][idCusD] + problem->c[idCusD][firstC_nextT];
//	 }
//	 seg[idVeh].Trip[idTrip].connectCost = problem->c[idCusD][firstC_nextT];
//	 startS[seed] = PDS_MAX(cStartS + problem->c[preC][seed], problem->node[seed].sTW);
//	 depart[seed] = startS[seed] + problem->node[seed].duration;
//     startS[idCusD] = PDS_MAX(depart[seed] + problem->c[seed][idCusD], problem->node[idCusD].sTW);
//	 depart[idCusD] = startS[idCusD] + problem->node[idCusD].duration;
//
//	 seg[idVeh].Trip[idTrip].numCus = 2;
//	 seg[idVeh].Trip[idTrip].feasible = 1;
//	 seg[idVeh].Trip[idTrip].endS = depart[idCusD];
//	 numCusC2CRouted += 2;
//	 nextArr[seed] = idCusD; nextArr[idCusD] = 0;
//	 pos[seed] = 1; pos[idCusD] = 2;
//	 FCAP[seed] = problem->node[seed].capacity;
//	 FCAP[idCusD] = 0;
//
//	 //STILL NEED to update the cost and WS of (idVeh, nextT):
//	 if (changedSEED) //because this is insertion --> before insert go to sp through WS, after insert go to sp directly
//	 {
//		 seg[idVeh].Trip[nextT].waitingS = NO_WS;
//		 int lastC = seg[idVeh].Trip[nextT].lastCus;
//		 seg[idVeh].Trip[nextT].cost += (problem->c[lastC][assSP] - problem->disCWSSP[lastC][assSP]);
//	 }
//	 //cout<<"CALL updatePTrip_InitSol"<<endl;showTripCost(idVeh,nextT);
//	 //cout<<"seed = "<<seed<<"; idCusD = "<<idCusD<<"; firstC_nextT = "<<firstC_nextT<<endl;*/
//	 updatePTrip_InitSol(idVeh, nextT, idCusD,firstC_nextT,changedSEED);
//
//	 //Now trying to insert more C2C to trip(idVeh,idTrip):
//     if (numCusC2CRouted < problem->nC2C)
//	 {
//		 double costT1, depart_idCusP, costMINI1, costC2C;
//		 int i,j, firstC_C2C, idCus, insert_afterP, insert_afterD, curC, nextC, preINS, nextINS, IDinsert, FCAPT;
//		 double *departTemp = new double[250];
//		 bool cont = 1; bool ok;
//		 do //each loop insert a pair of C2C
//		 {
//			 IDinsert = -1; costMINI = PDS_INFINITY;
//			 firstC_C2C = seg[idVeh].Trip[idTrip].firstCus;
//			 for (idCusP = startidC2C; idCusP <= endidC2CP; idCusP ++)
//			 {
//				 if (routed[idCusP] == 0 && problem->belong[idCusP][assSP])
//				 {
//					 //1. First try to insert at the beginning of the trip:
//					 nextINS = firstC_C2C;
//					 FCAPT = problem->node[idCusP].capacity;
//					 ArrTime = PDS_MAX(depart_preC + problem->c[preC][idCusP], problem->node[idCusP].sTW); 
//					 temp = ArrTime - problem->node[idCusP].eTW;
//					 if (temp > eps) continue;
//					 //Insert idCusP at the beginning of the trip, now find place to insert idCusD
//					 idCusD = problem->node[idCusP].delID;
//					 depart_idCusP = ArrTime + problem->node[idCusP].duration;
//					 //1.1 Insert idCusD right after idCusP: then capacity of vehicle is ok since already ok when inserting idCusP
//					 ArrTime = depart_idCusP + problem->c[idCusP][idCusD];
//					 temp = ArrTime - problem->node[idCusD].eTW;
//					 if (temp > eps) continue;
//					 //cout<<"D rightafter P"<<"; ";
//					 ok = 1;
//					 ArrTime = PDS_MAX(ArrTime, problem->node[idCusD].sTW) + problem->node[idCusD].duration + problem->c[idCusD][firstC_C2C];
//					 costT = problem->c[preC][idCusP] + problem->c[idCusP][firstC_C2C] - problem->c[preC][firstC_C2C];
//					 temp = problem->node[firstC_C2C].eTW - ArrTime;
//						 if (temp > 0) 
//						 {
//							 ArrTime = PDS_MAX(ArrTime, problem->node[nextINS].sTW) + problem->node[nextINS].duration;
//							 curC = nextINS; nextC = nextArr[nextINS];
//							 while (nextC > 0)
//							 {
//								 ArrTime += problem->c[curC][nextC];
//								 temp = ArrTime - problem->node[nextC].eTW;
//								 if (temp > eps) {ok = 0; break;} //vioTW at nextC
//								 else
//								 {
//									 ArrTime = PDS_MAX(ArrTime, problem->node[nextC].sTW) + problem->node[nextC].duration;
//									 curC = nextC; nextC = nextArr[curC];
//								 }
//							 }
//							 if (ok) //curC is now pointed to lastC
//							 {
//								 costC2C = costT + problem->c[idCusP][idCusD] + problem->c[idCusD][nextINS] - problem->c[idCusP][nextINS];
//								 costT1 = costC2C;
//								 changed = 0;
//								 ok = checkPickupTripFeasible_AfterInsertC2C(curC,ArrTime,costT1,idVeh,nextT,changed);
//	                             if (ok)
//								 {
//									 if (costT1 < costMINI)
//									 {
//										 costMINI = costT1;
//										 costMINI1 = costC2C;
//										 IDinsert = idCusP;
//										 insert_afterP = 0;
//										 insert_afterD = idCusP;
//										 changedSEED = changed;
//									 }
//								 }
//							 }//end if (ok)
//						 }//else vioTW at cus nextINS
//						 
//						 //1.2 Find place to insert idCusD from position after nextINS assuming that idCusP is inserted at the beginning of the trip:
//                          ok = checkC2CAndPTripFeasible_AfterInsertC2C(idCusP, depart_idCusP,firstC_C2C,1,departTemp,idVeh,nextT);
//						  if (ok) //TW is ok for all customers in trip C2C and next PTrip(idVeh, nextT) after inserting idCusP to the trip C2C
//						  {
//							 int i = 1; curC = firstC_C2C;
//							 while (i <= seg[idVeh].Trip[idTrip].numCus) //insert idCusD after curC at position i of idTrip
//							 {
//								 //1.2 Insert idCusD right after place i
//								 if (curC < startidC2CD) //curC is a C2CP
//								 {
//									 curC = problem->node[curC].delID;
//									 i = pos[curC];
//								 }
//								 else //curC is a C2CD:
//								 {
//									 idCus = problem->node[curC].pickID;
//									 if (pos[idCus] > 0)
//									 {
//										 //Insert idCusD after curC: check capacity and vioTW
//										 ok = checkCapacity_C2CTrip_InitSol(firstC_C2C, curC,FCAPT);
//										 if (ok)
//										 {
//											 ArrTime = departTemp[i] + problem->c[curC][idCusD];
//											 temp = problem->node[idCusD].eTW - ArrTime;
//											 if (temp > eps)
//											 {
//												 ArrTime = PDS_MAX(ArrTime, problem->node[idCusD].sTW) + problem->node[idCusD].duration;
//												 changed = 0;
//												 costC2C = costT;
//												 ok = checkC2CAndPTripFeasibleCostChange_AfterInsertC2C(idCusD,ArrTime, nextArr[curC], costT1, idVeh,nextT,changed);
//												 if (ok) //it's ok to insert idCusD after curC
//												 {
//													 nextC = nextArr[curC];
//													 if (nextC > 0)
//														costC2C += (problem->c[curC][idCusD] + problem->c[idCusD][nextC] - problem->c[curC][nextC]);
//													 else
//														 costC2C += (problem->c[curC][idCusD] + problem->c[idCusD][firstC_nextT] - problem->c[curC][firstC_nextT]);
//
//													 costT1 += costC2C;
//													 if (costT1 < costMINI)
//													 {	
//														 costMINI = costT1;
//														 costMINI1 = costC2C;
//														 IDinsert = idCusP;
//														 insert_afterP = 0;
//														 insert_afterD = curC;
//														 changedSEED = changed;
//													 }
//												 }
//											 }
//
//										 }//else not ok capacity of vehicle
//										 i ++; curC = nextArr[curC];
//									 }
//									 else break;
//								 }
//							 }
//						  }
//					 //2. Insert idCusP in the middle of the trip
//					 preINS = firstC_C2C;
//					 nextINS = nextArr[preINS];
//                     for (j=1;j<seg[idVeh].Trip[idTrip].numCus;j++) //insert idCusP between preINS and nextINS
//					 {
//						 FCAPT = FCAP[preINS] + problem->node[idCusP].capacity;
//						 if (FCAPT <= problem->Q)
//						 {
//	 						costT = problem->c[preINS][idCusP] + problem->c[idCusP][nextINS] - problem->c[preINS][nextINS];
//							cStartS = depart[preINS] + problem->c[preINS][idCusP];
//							temp = problem->node[idCusP].eTW - cStartS;
//							if (temp > eps)
//							{
//								 depart_idCusP = PDS_MAX(cStartS, problem->node[idCusP].sTW) + problem->node[idCusP].duration;
//								 //2.1 Insert idCusD right after idCusP: don't need to check capacity of vehicle
// 								 ArrTime = PDS_MAX(depart_idCusP + problem->c[idCusP][idCusD], problem->node[idCusD].sTW) + problem->node[idCusD].duration + problem->c[idCusD][nextINS];
//								 temp = problem->node[nextINS].eTW - ArrTime;
//								 if (temp > 0) 
//								 {
//									 ArrTime = PDS_MAX(ArrTime, problem->node[nextINS].sTW) + problem->node[nextINS].duration;
//									 curC = nextINS; nextC = nextArr[nextINS];
//									 ok = 1;
//									 while (nextC > 0)
//									 {
//										 ArrTime += problem->c[curC][nextC];
//										 temp = ArrTime - problem->node[nextC].eTW;
//										 if (temp > eps) {ok = 0; break;} //vioTW at nextC
//										 else
//										 {
//											 ArrTime = PDS_MAX(ArrTime, problem->node[nextC].sTW) + problem->node[nextC].duration;
//											 curC = nextC; nextC = nextArr[curC];
//										 }
//									 }
//									 if (ok) //curC is now pointed to lastC
//									 {
//										 costC2C = costT + problem->c[idCusP][idCusD] + problem->c[idCusD][nextINS] - problem->c[idCusP][nextINS];
//										 changed = 0;
//										 costT1 = costC2C;
//										 ok = checkPickupTripFeasible_AfterInsertC2C(curC,ArrTime,costT1,idVeh,nextT,changed);
//										 if (ok)
//										 {
//											 if (costT1 < costMINI)
//											 {
//												 costMINI = costT1;
//												 costMINI1 = costC2C;
//												 IDinsert = idCusP;
//												 insert_afterP = preINS;
//												 insert_afterD = idCusP;
//												 changedSEED = changed;
//											 }
//										 }
//									 }//end if (ok)
//								 }//else vioTW at cus nextINS
//		 						 //2.2 Find place to insert idCusD from position after nextINS assuming that idCusP is inserted between preINS and nextINS:
//          						 ok = checkC2CAndPTripFeasible_AfterInsertC2C(idCusP,depart_idCusP,nextINS,j+1,departTemp,idVeh,nextT);
//								 if (ok) //TW is ok for all customers in trip C2C and next PTrip(idVeh, nextT) after inserting idCusP to the trip C2C between preINS and nextINS
//								 {
//									 i = j + 1; curC = nextINS;
//									 while (i <= seg[idVeh].Trip[idTrip].numCus) //insert idCusD after curC at position i of idTrip
//									 {
//										 //2.2 Insert idCusD right after place i:
//										 if (curC < startidC2CD) //curC is a C2CP
//										 {
//											 curC = problem->node[curC].delID;
//											 i = pos[curC];
//										 }
//										 else //curC is a C2CD
//										 {
//                                              idCus = problem->node[curC].pickID;
//											  if (pos[idCus] > j)
//											  {
//												  //Insert idCusD after curC: check capacity of vehicle and vioTW
//												  ok = checkCapacity_C2CTrip_InitSol(nextINS,curC, FCAPT);
//												  if (ok)
//												  {
//													  ArrTime = departTemp[i] + problem->c[curC][idCusD];
//													  temp = problem->node[idCusD].eTW - ArrTime;
//													  if (temp > eps)
//													  {
//															 ArrTime = PDS_MAX(ArrTime, problem->node[idCusD].sTW) + problem->node[idCusD].duration;
//															 changed = 0;
//															 costC2C = costT;
//															 ok = checkC2CAndPTripFeasibleCostChange_AfterInsertC2C(idCusD,ArrTime, nextArr[curC],costT1, idVeh,nextT,changed);
//															 if (ok) //it's ok to insert idCusD after curC
//															 {
//																 nextC = nextArr[curC];
//																 if (nextC > 0)
//																	costC2C += (problem->c[curC][idCusD] + problem->c[idCusD][nextC] - problem->c[curC][nextC]);
//																 else
//																	 costC2C += (problem->c[curC][idCusD] + problem->c[idCusD][firstC_nextT] - problem->c[curC][firstC_nextT]);
//
//																 costT1 += costC2C;
//																 if (costT1 < costMINI)
//																 {	
//																	 costMINI = costT1;
//																	 costMINI1 = costC2C;
//																	 IDinsert = idCusP;
//																	 insert_afterP = preINS;
//																	 insert_afterD = curC;
//																	 changedSEED = changed;
//																 }
//															 }
//													  }//else vioTW at idCusD
//												  }//else vio capacity of vehicle
//												  i++; curC = nextArr[curC];
//											  }
//											  else break;
//										 }//end curC is a C2CD
//									 }//end while
//								 }//else TW is NOT ok for all customers in trip C2C and next PTrip(idVeh, nextT) after inserting idCusP to the trip C2C between preINS and nextINS
//							}//else vioTW at idCusP
//						 }//else can't insert between preINS and nextINS due to the capacity of the trip
//						 preINS = nextINS; nextINS = nextArr[preINS];
//					 }//end for j
//
//					 //3. Insert idCusP at the end of the trip C2C: [after preINS] --> dont need to check CAPACITY of vehicle
// 					 cStartS = depart[preINS] + problem->c[preINS][idCusP];
//					 temp = problem->node[idCusP].eTW - cStartS;
//					 if (temp > eps)
//					 {
//								 depart_idCusP = PDS_MAX(cStartS, problem->node[idCusP].sTW) + problem->node[idCusP].duration;
//								 //3.1 Insert idCusD right after idCusP:
// 								 ArrTime = PDS_MAX(depart_idCusP + problem->c[idCusP][idCusD], problem->node[idCusD].sTW) + problem->node[idCusD].duration;
//								 costC2C = problem->c[preINS][idCusP] + problem->c[idCusP][idCusD] + problem->c[idCusD][firstC_nextT] - problem->c[preINS][firstC_nextT];
//								 costT1 = costC2C;
//								 changed = 0;
//								 ok = checkPickupTripFeasible_AfterInsertC2C(idCusD,ArrTime,costT1,idVeh,nextT,changed);
//								 if (ok)
//								 {
//									 if (costT1 < costMINI)
//									 {
//										 costMINI = costT1;
//										 costMINI1 = costC2C;
//										 IDinsert = idCusP;
//										 insert_afterP = preINS;
//										 insert_afterD = idCusP;
//										 changedSEED = changed;
//									 }
//								 }//end if (ok)
//					 }//else vioTW at idCusP
//				 } //else idCusP already routed 
//			 }//end for idCusP: try all unrouted C2C
//			 if (IDinsert != -1)
//			 {
//				 idCusD = problem->node[IDinsert].delID;
//				 //cout<<"Insert C2CP customer "<<IDinsert<<" after "<<insert_afterP<<" and insert C2CD "<<idCusD<<" after "<<insert_afterD<<": "<<endl;
//				 if (insert_afterP == seg[idVeh].Trip[idTrip].lastCus) //insert at the end of the trip:
//				 {
// 					  nextArr[insert_afterP] = IDinsert; 
//					  nextArr[IDinsert] = idCusD; 
//					  seg[idVeh].Trip[idTrip].lastCus = idCusD;nextArr[idCusD] = 0;
//  					  startS[IDinsert] = PDS_MAX(depart[insert_afterP] + problem->c[insert_afterP][IDinsert], problem->node[IDinsert].sTW);
//					  depart[IDinsert] = startS[IDinsert] + problem->node[IDinsert].duration;
//					  FCAP[IDinsert] = problem->node[IDinsert].capacity;
//					  FCAP[idCusD] = 0;
//					  pos[IDinsert] = pos[insert_afterP] + 1; pos[idCusD] = pos[IDinsert] + 1;
//					  startS[idCusD] = PDS_MAX(depart[IDinsert] + problem->c[IDinsert][idCusD], problem->node[idCusD].sTW);
//					  depart[idCusD] = startS[idCusD] + problem->node[idCusD].duration;
//					  updatePTrip_InitSol(idVeh,nextT, idCusD, firstC_nextT,changedSEED);
//				 }
//				 else //not insert at the end of the trip C2C
//				 {
//					 if (insert_afterP == 0)
//					 {
//						 seg[idVeh].Trip[idTrip].firstCus = IDinsert;
//						 nextArr[IDinsert] = firstC_C2C;
//						 startS[IDinsert] = PDS_MAX(depart_preC + problem->c[preC][IDinsert], problem->node[IDinsert].sTW);
//						 depart[IDinsert] = startS[IDinsert] + problem->node[IDinsert].duration;
//						 pos[IDinsert] = 1; FCAP[IDinsert] = problem->node[IDinsert].capacity;
//						 //Update 26/11/2013
//						 if (idTrip > 0)
//						 {
//							 double deltaC = (problem->c[preC][IDinsert] - problem->c[preC][firstC_C2C]);
//							 seg[idVeh].Trip[preT].cost += deltaC;
//							 seg[idVeh].Trip[preT].connectCost = problem->c[preC][IDinsert];
//							 seg[idVeh].Trip[idTrip].cost -= deltaC;
//						 }
//					 }
//					 else //insert in the middle
//					 {
// 						  int tt=nextArr[insert_afterP];
//						  nextArr[insert_afterP]=IDinsert;
//						  nextArr[IDinsert]=tt;
//  						  startS[IDinsert] = PDS_MAX(depart[insert_afterP] + problem->c[insert_afterP][IDinsert], problem->node[IDinsert].sTW);
//						  depart[IDinsert] = startS[IDinsert] + problem->node[IDinsert].duration;
//						  pos[IDinsert] = pos[insert_afterP] + 1; FCAP[IDinsert] = FCAP[insert_afterP] + problem->node[IDinsert].capacity;
//					 }//end insert in the middle
//
//					 if (insert_afterD == IDinsert) //insert idCusD right after idCusP
//					 {
//						 startS[idCusD] = PDS_MAX(depart[IDinsert] + problem->c[IDinsert][idCusD], problem->node[idCusD].sTW);
//						 depart[idCusD] = startS[idCusD] + problem->node[idCusD].duration;
//						 int tt = nextArr[IDinsert];
//						 nextArr[IDinsert] = idCusD; nextArr[idCusD] = tt; 
//						 pos[idCusD] = pos[IDinsert] + 1; 
//						 FCAP[idCusD] = FCAP[IDinsert] + problem->node[idCusD].capacity;
//					 }
//					 else //insert idCusD after insert_afterD:
//					 {
//						 curC = IDinsert; nextC = nextArr[IDinsert];
//						 do
//						 {
//							 startS[nextC] = PDS_MAX(depart[curC] + problem->c[curC][nextC], problem->node[nextC].sTW);
//							 depart[nextC] = startS[nextC] + problem->node[nextC].duration;
//							 pos[nextC] ++; FCAP[nextC] = FCAP[curC] + problem->node[nextC].capacity;
//							 curC = nextC; nextC = nextArr[curC];
//						 }while (curC != insert_afterD);
//						 //Insert idCusD after insert_afterD:
//						 startS[idCusD] = PDS_MAX(depart[insert_afterD] + problem->c[insert_afterD][idCusD], problem->node[idCusD].sTW);
//						 depart[idCusD] = startS[idCusD] + problem->node[idCusD].duration;
//						 nextArr[idCusD] = nextArr[insert_afterD]; nextArr[insert_afterD] = idCusD; 
//						 pos[idCusD] = pos[insert_afterD] + 1; FCAP[idCusD] = FCAP[insert_afterD] + problem->node[idCusD].capacity;
//					 }//end insert idCusD after insert_afterD:
//					 nextC = nextArr[idCusD];
//					 if (nextC > 0)	 updateStartS_pos_FCAP_FEASIBLETRIP(idVeh,idTrip,idCusD,nextC,pos[idCusD]);
//					 else seg[idVeh].Trip[idTrip].lastCus = idCusD;
//					 updatePTrip_InitSol(idVeh, nextT, seg[idVeh].Trip[idTrip].lastCus, firstC_nextT,changedSEED);
//				 }//end not insert at the end of the trip C2C
//
//				  seg[idVeh].Trip[idTrip].numCus +=2; 
//				  routed[IDinsert] = 1; routed[idCusD] = 1;
//				  numCusC2CRouted += 2;
//				  if (numCusC2CRouted == nC2C) cont = 0;
//				  seg[idVeh].Trip[idTrip].cost += costMINI1;
//				  seg[idVeh].Trip[idTrip].endS = depart[seg[idVeh].Trip[idTrip].lastCus];
//				  ok = checkC2C_P_FeasibleTrip_InitSol(idVeh,idTrip, preC, depart_preC,nextT);
//				  if (ok == 0) exit(-1);
//			 } else cont = 0; //can't route any C2C anymore
//		 }while (cont);
//		 delete [] departTemp;
//	 }
//	 return 1;
//
//}
//
//bool Solution::CreateC2CTrip_BeforePickupTrip_Temp(int idVeh, int preT, int preC, double depart_preC, int &idTrip, int value_assign_idTrip, int idTripP, int assSP)
//{
//	//OK 13/11/2013
//	//Update 11/11/2013: Create a C2C Trip between Trip(idVeh, preT) and PTrip(idVeh, idTripP, assSP): such that all trips are feasible; 
//	//will try to insert C2C right after Customer preC
//	//if preC = 0 --> depot and preT doesn't exist
//
//	double cStartS = depart_preC;
//
//	int idCusP, idCusD;
//	double ArrTime;
//
//	//cout<<"@CreateC2CTrip_BeforePickupTrip_Temp: TRYING TO Create C2C trip before Pickup trip("<<idVeh<<", "<<idTripP<<"); after preC = "<<preC<<endl;
//   
//    //1.Insert a C2C as the first customer of current trip:
//	 double costT;
//	 double costMINI = PDS_INFINITY; double temp; int seed=-1;
//	 bool changedSEED, changed;
//	 int firstC_nextT = seg[idVeh].Trip[idTripP].firstCus;
//	 
//	 for (idCusP = startidC2C;idCusP <= endidC2CP; idCusP ++)
//	 {
//		 routedTemp[idCusP] = routed[idCusP];
//		 if (routedTemp[idCusP] == 0 && problem->belong[idCusP][assSP])
//		 { 
//			 idCusD = problem->node[idCusP].delID;
//			 costT = problem->c[preC][idCusP] + problem->c[idCusP][idCusD] + problem->c[idCusD][firstC_nextT];
//			 if (costT > costMINI) continue;
//			 ArrTime = PDS_MAX(cStartS + problem->c[preC][idCusP], problem->node[idCusP].sTW); 
//			 temp = ArrTime - problem->node[idCusP].eTW;
//			 if (temp > eps) continue;
//			 ArrTime += (problem->node[idCusP].duration + problem->c[idCusP][idCusD]);
//			 temp = ArrTime - problem->node[idCusD].eTW;
//			 if (temp > eps) continue;
//			 ArrTime = PDS_MAX(ArrTime, problem->node[idCusD].sTW) + problem->node[idCusD].duration;
//             bool cont = 0;
//			 changed = 0;
//			 cont = checkPickupTripFeasible_AfterInsertC2C_Temp(idCusD,ArrTime,costT,idVeh,idTripP,changed);
//			 if (cont)
//			 {
//				 if (costT < costMINI)
//				 {
//					 seed = idCusP;
//					 costMINI = costT;
//					 changedSEED = changed;
//				 }
//			 }
//		 }
//	 }
//
//	 if (seed == -1)
//	 {
//	 	 //cout<<"Cant create C2CTrip before PTrip("<<idVeh<<", "<<idTripP<<")"<<endl;
//		 return 0;
//	 }
//
//	 idCusD = problem->node[seed].delID;
//	 //cout<<"CAN insert C2C before PTrip("<<idVeh<<", "<<idTripP<<"): firstC2C = ("<<seed<<", "<<idCusD<<")"<<endl;
//	 routedTemp[seed]=1; routedTemp[idCusD] = 1;
//	 idTrip = value_assign_idTrip;
//	 seg[idVeh].Trip[idTrip].Type = 2;
//	 seg[idVeh].Trip[idTrip].firstCus = seed;
//	 seg[idVeh].Trip[idTrip].lastCus = idCusD;
//
//
//	 /*if (preC > 0)
//	 {
//	    seg[idVeh].Trip[preT].cost += (problem->c[preC][seed] - seg[idVeh].Trip[preT].connectCost);
//	    seg[idVeh].Trip[preT].connectCost = problem->c[preC][seed];
//	    seg[idVeh].Trip[idTrip].cost = problem->c[seed][idCusD] + problem->c[idCusD][firstC_nextT];
//	 }
//	 else
//	 {
//		 seg[idVeh].Trip[idTrip].cost = problem->c[preC][seed] + problem->c[seed][idCusD] + problem->c[idCusD][firstC_nextT];
//	 }*/
// 
//	 seg[idVeh].Trip[idTrip].cost = problem->c[preC][seed] + problem->c[seed][idCusD] + problem->c[idCusD][firstC_nextT];
//	 //seg[idVeh].Trip[idTrip].connectCost = problem->c[idCusD][firstC_nextT];
//	 startS[seed] = PDS_MAX(cStartS + problem->c[preC][seed], problem->node[seed].sTW);
//	 depart[seed] = startS[seed] + problem->node[seed].duration;
//     startS[idCusD] = PDS_MAX(depart[seed] + problem->c[seed][idCusD], problem->node[idCusD].sTW);
//	 depart[idCusD] = startS[idCusD] + problem->node[idCusD].duration;
//
//	 seg[idVeh].Trip[idTrip].numCus = 2;
//	 seg[idVeh].Trip[idTrip].feasible = 1;
//	 seg[idVeh].Trip[idTrip].endS = depart[idCusD];
//	 int numCusC2CRoutedTemp = numCusC2CRouted;
//	 numCusC2CRoutedTemp += 2;
//	 nextArrTemp[seed] = idCusD; nextArrTemp[idCusD] = 0;
//	 pos[seed] = 1; pos[idCusD] = 2;
//	 FCAP[seed] = problem->node[seed].capacity;
//	 FCAP[idCusD] = 0;
//	 seg[idVeh].Trip[idTrip].capacity = problem->node[seed].capacity;
//
//	 //STILL NEED to update the cost and WS of (idVeh, nextT):
//	 if (changedSEED) //because this is insertion AND lastCus of the trip doesn't change --> before insert go to sp through WS, after insert go to sp directly
//	 {
//		 seg[idVeh].Trip[idTripP].waitingS = NO_WS;
//		 int lastC = seg[idVeh].Trip[idTripP].lastCus;
//		 seg[idVeh].Trip[idTripP].cost += (problem->c[lastC][assSP] - problem->disCWSSP[lastC][assSP]);
//	 }
//	 //cout<<"endS of PTrip("<<idVeh<<", "<<idTripP<<") = "<<seg[idVeh].Trip[idTripP].endS<<"; depart[idCusD] = "<<depart[idCusD]<<"; ";
//	 updatePTrip_InitSol_Temp(idVeh, idTripP,idCusD,firstC_nextT,changedSEED);
//	 //cout<<"--> Update endS = "<<seg[idVeh].Trip[idTripP].endS<<endl;
//
//	 //Now trying to insert more C2C to trip(idVeh,idTrip):
//     if (numCusC2CRoutedTemp < problem->nC2C)
//	 {
//		 double costT1, depart_idCusP, costMINI1, costC2C;
//		 int i,j, firstC_C2C, idCus, insert_afterP, insert_afterD, curC, nextC, preINS, nextINS, IDinsert, FCAPT;
//		 double *departTemp = new double[250];
//		 bool cont = 1; bool ok;
//		 do //each loop insert a pair of C2C
//		 {
//			 IDinsert = -1; costMINI = PDS_INFINITY;
//			 firstC_C2C = seg[idVeh].Trip[idTrip].firstCus;
//			 for (idCusP = startidC2C; idCusP <= endidC2CP; idCusP ++)
//			 {
//				 if (routedTemp[idCusP] == 0 && problem->belong[idCusP][assSP])
//				 {
//					 idCusD = problem->node[idCusP].delID;
//					 //cout<<"Trying to insert C2C("<<idCusP<<"="<<problem->node[idCusP].id<<", "<<idCusD<<"="<<problem->node[idCusD].id<<"): ";
//					 //cout<<" at the begin of the trip; ";
//					 //1. First try to insert at the beginning of the trip:
//					 FCAPT = problem->node[idCusP].capacity;
//					 ArrTime = PDS_MAX(depart_preC + problem->c[preC][idCusP], problem->node[idCusP].sTW); 
//					 temp = ArrTime - problem->node[idCusP].eTW;
//					 if (temp > eps) continue;
//					 //Insert idCusP at the beginning of the trip, now find place to insert idCusD
//					 depart_idCusP = ArrTime + problem->node[idCusP].duration;
//					 //1.1 Insert idCusD right after idCusP: then capacity of vehicle is ok since already ok when inserting idCusP
//					 ArrTime = depart_idCusP + problem->c[idCusP][idCusD];
//					 temp = ArrTime - problem->node[idCusD].eTW;
//					 if (temp > eps) continue;
//					 //cout<<"D rightafter P"<<"; ";
//					 ok = 1;
//					 ArrTime = PDS_MAX(ArrTime, problem->node[idCusD].sTW) + problem->node[idCusD].duration + problem->c[idCusD][firstC_C2C];
//					 costT = problem->c[preC][idCusP] + problem->c[idCusP][firstC_C2C] - problem->c[preC][firstC_C2C];
//					 temp = problem->node[firstC_C2C].eTW - ArrTime;
//					 if (temp > 0) 
//					 {
//							 ArrTime = PDS_MAX(ArrTime, problem->node[firstC_C2C].sTW) + problem->node[firstC_C2C].duration;
//							 curC = firstC_C2C; nextC = nextArrTemp[firstC_C2C];
//							 while (nextC > 0)
//							 {
//								 ArrTime += problem->c[curC][nextC];
//								 temp = ArrTime - problem->node[nextC].eTW;
//								 if (temp > eps) {ok = 0; break;} //vioTW at nextC
//								 else
//								 {
//									 ArrTime = PDS_MAX(ArrTime, problem->node[nextC].sTW) + problem->node[nextC].duration;
//									 curC = nextC; nextC = nextArrTemp[curC];
//								 }
//							 }
//							 if (ok) //curC is now pointed to lastC
//							 {
//								 costC2C = costT + problem->c[idCusP][idCusD] + problem->c[idCusD][firstC_C2C] - problem->c[idCusP][firstC_C2C];
//								 costT1 = costC2C;
//								 changed = 0;
//								 ok = checkPickupTripFeasible_AfterInsertC2C_Temp(curC,ArrTime,costT1,idVeh,idTripP,changed);
//	                             if (ok)
//								 {
//									 if (costT1 < costMINI)
//									 {
//										 costMINI = costT1;
//										 costMINI1 = costC2C;
//										 IDinsert = idCusP;
//										 insert_afterP = 0;
//										 insert_afterD = idCusP;
//										 changedSEED = changed;
//									 }
//								 }
//							 }//end if (ok)
//						 }//else vioTW at cus nextINS
//						 
//						 //1.2 Find place to insert idCusD from position after nextINS assuming that idCusP is inserted at the beginning of the trip:
//                          ok = checkC2CAndPTripFeasible_AfterInsertC2C_Temp(idCusP, depart_idCusP,firstC_C2C,1,departTemp,idVeh,idTripP);
//						  if (ok) //TW is ok for all customers in trip C2C and next PTrip(idVeh, nextT) after inserting idCusP to the trip C2C
//						  {
//							 int i = 1; curC = firstC_C2C;
//							 while (i <= seg[idVeh].Trip[idTrip].numCus) //insert idCusD after curC at position i of idTrip
//							 {
//								 //cout<<" OR D after "<<curC<<"; ";
//								 //1.2 Insert idCusD right after place i
//								 if (curC < startidC2CD) //curC is a C2CP
//								 {
//									 curC = problem->node[curC].delID;
//									 i = pos[curC];
//								 }
//								 else //curC is a C2CD:
//								 {
//									 idCus = problem->node[curC].pickID;
//									 if (pos[idCus] > 0)
//									 {
//										 //Insert idCusD after curC: check capacity and vioTW
//										 ok = checkCapacity_C2CTrip_InitSol_Temp(firstC_C2C, curC,FCAPT);
//										 if (ok)
//										 {
//											 ArrTime = departTemp[i] + problem->c[curC][idCusD];
//											 temp = problem->node[idCusD].eTW - ArrTime;
//											 if (temp > eps)
//											 {
//												 ArrTime = PDS_MAX(ArrTime, problem->node[idCusD].sTW) + problem->node[idCusD].duration;
//												 changed = 0;
//												 costC2C = costT;
//												 ok = checkC2CAndPTripFeasibleCostChange_AfterInsertC2C_Temp(idCusD,ArrTime, nextArrTemp[curC], costT1, idVeh,idTripP,changed);
//												 if (ok) //it's ok to insert idCusD after curC
//												 {
//													 nextC = nextArrTemp[curC];
//													 if (nextC > 0)
//														costC2C += (problem->c[curC][idCusD] + problem->c[idCusD][nextC] - problem->c[curC][nextC]);
//													 else
//														 costC2C += (problem->c[curC][idCusD] + problem->c[idCusD][firstC_nextT] - problem->c[curC][firstC_nextT]);
//
//													 costT1 += costC2C;
//													 if (costT1 < costMINI)
//													 {	
//														 costMINI = costT1;
//														 costMINI1 = costC2C;
//														 IDinsert = idCusP;
//														 insert_afterP = 0;
//														 insert_afterD = curC;
//														 changedSEED = changed;
//													 }
//												 }
//											 }
//
//										 }//else not ok capacity of vehicle
//										 i ++; curC = nextArrTemp[curC];
//									 }
//									 else break;
//								 }
//								 //cout<<endl;
//							 }
//						  }
//					 //2. Insert idCusP in the middle of the trip
//					 //cout<<" in the middle of the trip: ";
//					 preINS = firstC_C2C;
//					 nextINS = nextArrTemp[preINS];
//                     for (j=1;j<seg[idVeh].Trip[idTrip].numCus;j++) //insert idCusP between preINS and nextINS
//					 {
//						 FCAPT = FCAP[preINS] + problem->node[idCusP].capacity;
//						 if (FCAPT <= problem->Q)
//						 {
//                            //cout<<"P after "<<preINS<<";";
//	 						costT = problem->c[preINS][idCusP] + problem->c[idCusP][nextINS] - problem->c[preINS][nextINS];
//							cStartS = depart[preINS] + problem->c[preINS][idCusP];
//							temp = problem->node[idCusP].eTW - cStartS;
//							if (temp > eps)
//							{
//								 depart_idCusP = PDS_MAX(cStartS, problem->node[idCusP].sTW) + problem->node[idCusP].duration;
//								 //2.1 Insert idCusD right after idCusP: don't need to check capacity of vehicle
// 								 //cout<<" and (D after P; ";
//								 ArrTime = PDS_MAX(depart_idCusP + problem->c[idCusP][idCusD], problem->node[idCusD].sTW) + problem->node[idCusD].duration + problem->c[idCusD][nextINS];
//								 temp = problem->node[nextINS].eTW - ArrTime;
//								 if (temp > 0) 
//								 {
//									 ArrTime = PDS_MAX(ArrTime, problem->node[nextINS].sTW) + problem->node[nextINS].duration;
//									 curC = nextINS; nextC = nextArrTemp[nextINS];
//									 ok = 1;
//									 while (nextC > 0)
//									 {
//										 ArrTime += problem->c[curC][nextC];
//										 temp = ArrTime - problem->node[nextC].eTW;
//										 if (temp > eps) {ok = 0; break;} //vioTW at nextC
//										 else
//										 {
//											 ArrTime = PDS_MAX(ArrTime, problem->node[nextC].sTW) + problem->node[nextC].duration;
//											 curC = nextC; nextC = nextArrTemp[curC];
//										 }
//									 }
//									 if (ok) //curC is now pointed to lastC
//									 {
//										 costC2C = costT + problem->c[idCusP][idCusD] + problem->c[idCusD][nextINS] - problem->c[idCusP][nextINS];
//										 changed = 0;
//										 costT1 = costC2C;
//										 ok = checkPickupTripFeasible_AfterInsertC2C_Temp(curC,ArrTime,costT1,idVeh,idTripP,changed);
//										 if (ok)
//										 {
//											 if (costT1 < costMINI)
//											 {
//												 costMINI = costT1;
//												 costMINI1 = costC2C;
//												 IDinsert = idCusP;
//												 insert_afterP = preINS;
//												 insert_afterD = idCusP;
//												 changedSEED = changed;
//											 }
//										 }
//									 }//end if (ok)
//								 }//else vioTW at cus nextINS
//		 						 //2.2 Find place to insert idCusD from position after nextINS assuming that idCusP is inserted between preINS and nextINS:
//          						 ok = checkC2CAndPTripFeasible_AfterInsertC2C_Temp(idCusP,depart_idCusP,nextINS,j+1,departTemp,idVeh,idTripP);
//								 if (ok) //TW is ok for all customers in trip C2C and next PTrip(idVeh, nextT) after inserting idCusP to the trip C2C between preINS and nextINS
//								 {
//									 i = j + 1; curC = nextINS;
//									 while (i <= seg[idVeh].Trip[idTrip].numCus) //insert idCusD after curC at position i of idTrip
//									 {
//										 //2.2 Insert idCusD right after place i:
//										 //cout<<" OR D after "<<curC<<"; ";
//										 if (curC < startidC2CD) //curC is a C2CP
//										 {
//											 curC = problem->node[curC].delID;
//											 i = pos[curC];
//										 }
//										 else //curC is a C2CD
//										 {
//                                              idCus = problem->node[curC].pickID;
//											  //cout<<"idCusP = "<<idCus<<"; startidC2C = "<<startidC2C<<"; endidC2CP = "<<endidC2CP<<"; j = "<<j<<"; pos = "<<pos[idCus]<<endl;
//											  if (pos[idCus] > j)
//											  {
//												  //Insert idCusD after curC: check capacity of vehicle and vioTW
//												  ok = checkCapacity_C2CTrip_InitSol_Temp(nextINS,curC, FCAPT);
//												  if (ok)
//												  {
//													  ArrTime = departTemp[i] + problem->c[curC][idCusD];
//													  temp = problem->node[idCusD].eTW - ArrTime;
//													  if (temp > eps)
//													  {
//															 ArrTime = PDS_MAX(ArrTime, problem->node[idCusD].sTW) + problem->node[idCusD].duration;
//															 changed = 0;
//															 costC2C = costT;
//															 ok = checkC2CAndPTripFeasibleCostChange_AfterInsertC2C_Temp(idCusD,ArrTime, nextArrTemp[curC],costT1, idVeh,idTripP,changed);
//															 if (ok) //it's ok to insert idCusD after curC
//															 {
//																 nextC = nextArrTemp[curC];
//																 if (nextC > 0)
//																	costC2C += (problem->c[curC][idCusD] + problem->c[idCusD][nextC] - problem->c[curC][nextC]);
//																 else
//																	 costC2C += (problem->c[curC][idCusD] + problem->c[idCusD][firstC_nextT] - problem->c[curC][firstC_nextT]);
//
//																 costT1 += costC2C;
//																 if (costT1 < costMINI)
//																 {	
//																	 costMINI = costT1;
//																	 costMINI1 = costC2C;
//																	 IDinsert = idCusP;
//																	 insert_afterP = preINS;
//																	 insert_afterD = curC;
//																	 changedSEED = changed;
//																 }
//															 }
//													  }//else vioTW at idCusD
//												  }//else vio capacity of vehicle
//												  i++; curC = nextArrTemp[curC];
//											  }
//											  else break;
//										 }//end curC is a C2CD
//									 }//end while
//									// cout<<")"<<endl;
//								 }//else TW is NOT ok for all customers in trip C2C and next PTrip(idVeh, nextT) after inserting idCusP to the trip C2C between preINS and nextINS
//							}//else vioTW at idCusP
//						 }//else can't insert between preINS and nextINS due to the capacity of the trip
//						 preINS = nextINS; nextINS = nextArrTemp[preINS];
//					 }//end for j
//
//					 //3. Insert idCusP at the end of the trip C2C: [after preINS] --> dont need to check CAPACITY of vehicle
//					 //cout<<"at the end of the trip"<<endl;
// 					 cStartS = depart[preINS] + problem->c[preINS][idCusP];
//					 temp = problem->node[idCusP].eTW - cStartS;
//					 if (temp > eps)
//					 {
//								 depart_idCusP = PDS_MAX(cStartS, problem->node[idCusP].sTW) + problem->node[idCusP].duration;
//								 //3.1 Insert idCusD right after idCusP:
// 								 ArrTime = PDS_MAX(depart_idCusP + problem->c[idCusP][idCusD], problem->node[idCusD].sTW) + problem->node[idCusD].duration;
//								 costC2C = problem->c[preINS][idCusP] + problem->c[idCusP][idCusD] + problem->c[idCusD][firstC_nextT] - problem->c[preINS][firstC_nextT];
//								 costT1 = costC2C;
//								 changed = 0;
//								 ok = checkPickupTripFeasible_AfterInsertC2C_Temp(idCusD,ArrTime,costT1,idVeh,idTripP,changed);
//								 if (ok)
//								 {
//									 if (costT1 < costMINI)
//									 {
//										 costMINI = costT1;
//										 costMINI1 = costC2C;
//										 IDinsert = idCusP;
//										 insert_afterP = preINS;
//										 insert_afterD = idCusP;
//										 changedSEED = changed;
//									 }
//								 }//end if (ok)
//					 }//else vioTW at idCusP
//				 } //else idCusP already routed 
//			 }//end for idCusP: try all unrouted C2C
//			 if (IDinsert != -1)
//			 {
//				 idCusD = problem->node[IDinsert].delID;
//				 //cout<<"CreateC2CTrip_BeforePickupTrip_Temp: Insert C2CP customer "<<IDinsert<<" after "<<insert_afterP<<" and insert C2CD "<<idCusD<<" after "<<insert_afterD<<": ";
//				 if (insert_afterP == seg[idVeh].Trip[idTrip].lastCus) //insert at the end of the trip:
//				 {
// 					  nextArrTemp[insert_afterP] = IDinsert; 
//					  nextArrTemp[IDinsert] = idCusD; nextArrTemp[idCusD] = 0;
//					  seg[idVeh].Trip[idTrip].lastCus = idCusD;
//  					  startS[IDinsert] = PDS_MAX(depart[insert_afterP] + problem->c[insert_afterP][IDinsert], problem->node[IDinsert].sTW);
//					  depart[IDinsert] = startS[IDinsert] + problem->node[IDinsert].duration;
//					  FCAP[IDinsert] = problem->node[IDinsert].capacity;
//					  FCAP[idCusD] = 0;
//					  pos[IDinsert] = pos[insert_afterP] + 1; pos[idCusD] = pos[IDinsert] + 1;
//					  startS[idCusD] = PDS_MAX(depart[IDinsert] + problem->c[IDinsert][idCusD], problem->node[idCusD].sTW);
//					  depart[idCusD] = startS[idCusD] + problem->node[idCusD].duration;
//					  updatePTrip_InitSol_Temp(idVeh,idTripP, idCusD, firstC_nextT,changedSEED);
//					  seg[idVeh].Trip[idTrip].cost += costMINI1;
//				 }
//				 else //not insert at the end of the trip C2C
//				 {
//					 if (insert_afterP == 0)
//					 {
//						 /*if (preC > 0)
//						 {
//						    double deltaCost = problem->c[preC][IDinsert] - problem->c[preC][firstC_C2C];
//						    seg[idVeh].Trip[preT].connectCost = problem->c[preC][IDinsert];
//						    seg[idVeh].Trip[preT].cost += deltaCost;
//						    seg[idVeh].Trip[idTrip].cost += (costMINI1 - deltaCost);
//						 }
//						 else seg[idVeh].Trip[idTrip].cost += costMINI1;*/
//						 seg[idVeh].Trip[idTrip].cost += costMINI1;
//						 seg[idVeh].Trip[idTrip].firstCus = IDinsert;
//						 nextArrTemp[IDinsert] = firstC_C2C;
//						 startS[IDinsert] = PDS_MAX(depart_preC + problem->c[preC][IDinsert], problem->node[IDinsert].sTW);
//						 depart[IDinsert] = startS[IDinsert] + problem->node[IDinsert].duration;
//						 pos[IDinsert] = 1;
//						 FCAP[IDinsert] = problem->node[IDinsert].capacity;
//					 }
//					 else //insert in the middle
//					 {
// 						  int tt=nextArrTemp[insert_afterP];
//						  nextArrTemp[insert_afterP]=IDinsert;
//						  nextArrTemp[IDinsert]=tt;
//  						  startS[IDinsert] = PDS_MAX(depart[insert_afterP] + problem->c[insert_afterP][IDinsert], problem->node[IDinsert].sTW);
//						  depart[IDinsert] = startS[IDinsert] + problem->node[IDinsert].duration;
//						  pos[IDinsert] = pos[insert_afterP] + 1;
//						  FCAP[IDinsert] = FCAP[insert_afterP] + problem->node[IDinsert].capacity;
//						  seg[idVeh].Trip[idTrip].cost += costMINI1;
//					 }//end insert in the middle
//
//					 if (insert_afterD == IDinsert) //insert idCusD right after idCusP
//					 {
//						 startS[idCusD] = PDS_MAX(depart[IDinsert] + problem->c[IDinsert][idCusD], problem->node[idCusD].sTW);
//						 depart[idCusD] = startS[idCusD] + problem->node[idCusD].duration;
//						 int tt = nextArrTemp[IDinsert];
//						 nextArrTemp[IDinsert] = idCusD; nextArrTemp[idCusD] = tt; 
//						 pos[idCusD] = pos[IDinsert] + 1;
//						 FCAP[idCusD] = FCAP[IDinsert] + problem->node[idCusD].capacity;
//					 }
//					 else //insert idCusD after insert_afterD:
//					 {
//						 curC = IDinsert; nextC = nextArrTemp[IDinsert];
//						 do
//						 {
//							 startS[nextC] = PDS_MAX(depart[curC] + problem->c[curC][nextC], problem->node[nextC].sTW);
//							 depart[nextC] = startS[nextC] + problem->node[nextC].duration;
//							 pos[nextC] ++; FCAP[nextC] = FCAP[curC] + problem->node[nextC].capacity;
//							 curC = nextC; nextC = nextArrTemp[curC];
//						 }while (curC != insert_afterD);
//						 //Insert idCusD after insert_afterD:
//						 startS[idCusD] = PDS_MAX(depart[insert_afterD] + problem->c[insert_afterD][idCusD], problem->node[idCusD].sTW);
//						 depart[idCusD] = startS[idCusD] + problem->node[idCusD].duration;
//						 nextArrTemp[idCusD] = nextArrTemp[insert_afterD];
//						 nextArrTemp[insert_afterD] = idCusD; 
// 						 pos[idCusD] = pos[insert_afterD] + 1;
//						 FCAP[idCusD] = FCAP[insert_afterD] + problem->node[idCusD].capacity;
//					 }//end insert idCusD after insert_afterD:
//					 nextC = nextArrTemp[idCusD];
//					 if (nextC > 0)	 updateStartS_pos_FCAP_FEASIBLETRIP_Temp(idVeh,idTrip,idCusD,nextC,pos[idCusD]);
//					 else seg[idVeh].Trip[idTrip].lastCus = idCusD;
//					 updatePTrip_InitSol_Temp(idVeh, idTripP, seg[idVeh].Trip[idTrip].lastCus, firstC_nextT,changedSEED);
//				 }//end not insert at the end of the trip C2C
//
//				  seg[idVeh].Trip[idTrip].numCus +=2; 
//				  //cout<<"--> numCus = "<<seg[idVeh].Trip[idTrip].numCus<<endl;
//				  routedTemp[IDinsert] = 1; routedTemp[idCusD] = 1;
//				  numCusC2CRoutedTemp += 2;
//				  if (numCusC2CRoutedTemp == problem->nC2C) cont = 0;
//				  //seg[idVeh].Trip[idTrip].cost += costMINI1;
//				  seg[idVeh].Trip[idTrip].endS = depart[seg[idVeh].Trip[idTrip].lastCus];
//				  seg[idVeh].Trip[idTrip].capacity += problem->node[IDinsert].capacity;
//				  //cout<<"CALL checkC2C_P_FeasibleTrip_InitSol_Temp"<<endl;
//				  ok = checkC2C_P_FeasibleTrip_InitSol_Temp(idVeh,idTrip, preC, depart_preC,idTripP);
//				  //cout<<"DA GOI XONG checkC2C_P_FeasibleTrip_InitSol_Temp"<<endl;
//				  if (ok == 0) exit(-1);
//			 } else cont = 0; //can't route any C2C anymore
//		 }while (cont);
//		 delete [] departTemp;
//	 }
//	 return 1;
//}
//
//
//
//
//
//bool Solution::CreateC2CTrip_BeforeSP_Temp(int idVeh, int preT, int preC, double depart_preC, int &idTrip, int value_assign_idTrip, int endSP)
//{
//	//ok 13/11/2013
//	//Update 11/11/2013: Create a C2C Trip between PreTrip(idVeh, preT) and SP endSP: such that all trips are feasible; 
//	//will try to insert C2C right after customer preC
//    //Note: if (preC == 0) --> insert at the beginning of vehicle [after the depot] --> preT ko co gia tri gi ca vi ko co trip nao o truoc
//
//	double cStartS = depart_preC;
//
//	int idCusP, idCusD;
//	double ArrTime;
//	int type_preT;
//
//	if (preC == 0) 
//	{
//		//cout<<"TRYING TO Create C2C trip at the begin of the vehicle "<<idVeh<<endl;
//		type_preT = 2;
//	}
//	else if (seg[idVeh].Trip[preT].Type == 1)
//	{
//		//cout<<"Trying to create C2C trip between DTrip("<<idVeh<<", "<<preT<<") and SP "<<endSP<<endl;
//		type_preT = 1;
//	}
//	else if (seg[idVeh].Trip[preT].Type == 0)
//	{
//		//cout<<"Trying to create C2C trip between PTrip("<<idVeh<<", "<<preT<<") and SP "<<endSP<<endl;
//		type_preT = 0;
//	}
//    //1.Insert a C2C as the first customer of current trip:
//	 double costT;
//	 double costMINI = PDS_INFINITY; double temp; int seed=-1;
//	 bool goWS, goWSSEED;
//	 
//	 for (idCusP = startidC2C;idCusP <= endidC2CP; idCusP ++)
//	 {
//		 routedTemp[idCusP] = routed[idCusP];
//		 if (routedTemp[idCusP] == 0 && problem->belong[idCusP][endSP])
//		 { 
//			 idCusD = problem->node[idCusP].delID;
//			 costT = problem->c[preC][idCusP] + problem->c[idCusP][idCusD] + problem->c[idCusD][endSP];
//			 if (costT > costMINI) continue;
//			 ArrTime = PDS_MAX(cStartS + problem->c[preC][idCusP], problem->node[idCusP].sTW); 
//			 temp = ArrTime - problem->node[idCusP].eTW;
//			 if (temp > eps) continue;
//			 ArrTime += (problem->node[idCusP].duration + problem->c[idCusP][idCusD]);
//			 temp = ArrTime - problem->node[idCusD].eTW;
//			 if (temp > eps) continue;
//			 ArrTime = PDS_MAX(ArrTime, problem->node[idCusD].sTW) + problem->node[idCusD].duration;
//             bool cont = 0;
//			 cont = checkFeasible_ConnectC2CDToSP(idCusD,ArrTime,costT,endSP,goWS);
//			 if (cont)
//			 {
//				 if (costT < costMINI)
//				 {
//					 seed = idCusP;
//					 costMINI = costT;
//					 goWSSEED = goWS;
//				 }
//			 }
//		 }
//	 }
//
//	 if (seed == -1)
//	 {
//	 	 //cout<<"Cant create C2C "<<endl;
//		 return 0;
//	 }
//
//	 idCusD = problem->node[seed].delID;
//	 routedTemp[seed]=1; routedTemp[idCusD] = 1;
//	 idTrip = value_assign_idTrip;
//	 seg[idVeh].Trip[idTrip].Type = 2;
//	 seg[idVeh].Trip[idTrip].firstCus = seed;
//	 seg[idVeh].Trip[idTrip].lastCus = idCusD;
//
//	 /*seg[idVeh].Trip[preT].connectCost = problem->c[preC][seed];
//	 if (type_preT == 1)
//	 {
//		 if (seg[idVeh].Trip[preT].waitingS == NO_WS)
//			seg[idVeh].Trip[preT].cost += (problem->c[preC][seed] - problem->c[preC][endSP]);
//		 else
//			seg[idVeh].Trip[preT].cost += (problem->c[preC][seed] - problem->disCWSSP[preC][endSP]);
//	 }
//	 else if (type_preT == 0)
//	 {
//		 if (seg[idVeh].Trip[preT].waitingS1 == NO_WS)
//			seg[idVeh].Trip[preT].cost += (problem->c[preC][seed] - problem->c[preC][endSP]);
//		 else
//			seg[idVeh].Trip[preT].cost += (problem->c[preC][seed] - problem->disCWSSP[preC][endSP]);
//	 }
//     if (goWSSEED) 
//	 {
//		 seg[idVeh].Trip[idTrip].cost = problem->c[seed][idCusD] + problem->disCWSSP[idCusD][endSP];
//		 seg[idVeh].Trip[idTrip].waitingS = problem->CWSSP[idCusD][endSP];
//	 }
//	 else
//	 {
//		 seg[idVeh].Trip[idTrip].cost = problem->c[seed][idCusD] + problem->c[idCusD][endSP];
//		 seg[idVeh].Trip[idTrip].waitingS = NO_WS;
//	 }
//	 */
//	 if (type_preT == 1)
//	 {
//		 if (seg[idVeh].Trip[preT].waitingS == NO_WS)
//			 seg[idVeh].Trip[preT].cost -= problem->c[preC][endSP];
//		 else seg[idVeh].Trip[preT].cost -= problem->disCWSSP[preC][endSP];
//	 }
//	 else if (type_preT == 0)
//	 {
//		 if (seg[idVeh].Trip[preT].waitingS1 == NO_WS)
//			 seg[idVeh].Trip[preT].cost -= problem->c[preC][endSP];
//		 else seg[idVeh].Trip[preT].cost -= problem->disCWSSP[preC][endSP];
//	 }
//	 
//     if (goWSSEED) 
//	 {
//		 seg[idVeh].Trip[idTrip].cost = problem->c[preC][seed] + problem->c[seed][idCusD] + problem->disCWSSP[idCusD][endSP];
//		 //seg[idVeh].Trip[idTrip].connectCost = problem->disCWSSP[idCusD][endSP];
//		 seg[idVeh].Trip[idTrip].waitingS = problem->CWSSP[idCusD][endSP];
//	 }
//	 else
//	 {
//		 seg[idVeh].Trip[idTrip].cost = problem->c[preC][seed] + problem->c[seed][idCusD] + problem->c[idCusD][endSP];
//		 //seg[idVeh].Trip[idTrip].connectCost = problem->c[idCusD][endSP];
//		 seg[idVeh].Trip[idTrip].waitingS = NO_WS;
//	 }
//	 startS[seed] = PDS_MAX(cStartS + problem->c[preC][seed], problem->node[seed].sTW);
//	 depart[seed] = startS[seed] + problem->node[seed].duration;
//     startS[idCusD] = PDS_MAX(depart[seed] + problem->c[seed][idCusD], problem->node[idCusD].sTW);
//	 depart[idCusD] = startS[idCusD] + problem->node[idCusD].duration;
//	// cout<<"Can create C2C("<<seed<<", "<<idCusD<<"): cost = "<<seg[idVeh].Trip[idTrip].cost<<"WS = "<<seg[idVeh].Trip[idTrip].waitingS<<"; preC = "<<preC<<endl;
//
//	 seg[idVeh].Trip[idTrip].numCus = 2;
//	 seg[idVeh].Trip[idTrip].feasible = 1;
//	 seg[idVeh].Trip[idTrip].endS = depart[idCusD];
//	 int numCusC2CRoutedTemp = numCusC2CRouted;
//	 numCusC2CRoutedTemp += 2;
//	 nextArrTemp[seed] = idCusD; nextArrTemp[idCusD] = 0;
//	 pos[seed] = 1; pos[idCusD] = 2;
//	 FCAP[seed] = problem->node[seed].capacity;
//	 FCAP[idCusD] = 0;
//	 seg[idVeh].Trip[idTrip].capacity = problem->node[seed].capacity;
//
//	 //Now trying to insert more C2C to trip(idVeh,idTrip):
//     if (numCusC2CRoutedTemp < problem->nC2C)
//	 {
//		 double costT1, depart_idCusP;
//		 int i,j, firstC_C2C, idCus, insert_afterP, insert_afterD, curC, nextC, preINS, nextINS, IDinsert, FCAPT;
//		 double *departTemp = new double[250];
//		 bool cont = 1; bool ok,changeWS,changeWSSEED;
//		 do //each loop insert a pair of C2C
//		 {
//			 IDinsert = -1; costMINI = PDS_INFINITY;
//			 firstC_C2C = seg[idVeh].Trip[idTrip].firstCus;
//			 for (idCusP = startidC2C; idCusP <= endidC2CP; idCusP ++)
//			 {
//				 if (routedTemp[idCusP] == 0 && problem->belong[idCusP][endSP])
//				 {
//					 //1. First try to insert at the beginning of the trip:
//					 FCAPT = problem->node[idCusP].capacity;
//					 ArrTime = PDS_MAX(depart_preC + problem->c[preC][idCusP], problem->node[idCusP].sTW); 
//					 temp = ArrTime - problem->node[idCusP].eTW;
//					 if (temp > eps) continue;
//					 //Insert idCusP at the beginning of the trip, now find place to insert idCusD
//					 idCusD = problem->node[idCusP].delID;
//					 depart_idCusP = ArrTime + problem->node[idCusP].duration;
//					 //1.1 Insert idCusD right after idCusP: then capacity of vehicle is ok since already ok when inserting idCusP
//					 ArrTime = depart_idCusP + problem->c[idCusP][idCusD];
//					 temp = ArrTime - problem->node[idCusD].eTW;
//					 if (temp > eps) continue;
//					 ok = 1;
//					 //cout<<"D rightafter P"<<"; ";
//
//					 ArrTime = PDS_MAX(ArrTime, problem->node[idCusD].sTW) + problem->node[idCusD].duration;
//					 costT = problem->c[preC][idCusP] + problem->c[idCusP][firstC_C2C] - problem->c[preC][firstC_C2C];
//					 costT1 = costT; double buct1 = costT1;
//					 ok = checkC2CTripFeasibleCostChange_AfterInsertC2C_Temp(idCusD,ArrTime, firstC_C2C,costT1,idVeh,idTrip,endSP,changeWS);
//					 if (ok)
//					 {
//						 double buct2 = costT1;
//						 costT1 += (problem->c[idCusP][idCusD] + problem->c[idCusD][firstC_C2C] - problem->c[idCusP][firstC_C2C]);
//						 if (costT1 < costMINI)
//						 {
//							 costMINI = costT1;
//							 IDinsert = idCusP;
//							 insert_afterP = 0;
//							 insert_afterD = idCusP;
//							 changeWSSEED = changeWS;
//							// cout<<"C2CPD together at the first: preC = "<<preC<<"; connect P = "<<buct1<<"; connectSP = "<<(buct2-buct1)<<"; connectD = "<<(costT1-buct2)<<"; deltaCost = "<<costT1<<endl;
//						 }
//					 }
//
//					 /*ArrTime = PDS_MAX(ArrTime, problem->node[idCusD].sTW) + problem->node[idCusD].duration + problem->c[idCusD][firstC_C2C];
//					 costT = problem->c[preC][idCusP] + problem->c[idCusP][firstC_C2C] - problem->c[preC][firstC_C2C];
//
//					 temp = problem->node[firstC_C2C].eTW - ArrTime;
//					 if (temp > 0) 
//					 {
//							 ArrTime = PDS_MAX(ArrTime, problem->node[firstC_C2C].sTW) + problem->node[firstC_C2C].duration;
//							 curC = firstC_C2C; nextC = nextArrTemp[firstC_C2C];
//							 while (nextC > 0)
//							 {
//								 ArrTime += problem->c[curC][nextC];
//								 temp = ArrTime - problem->node[nextC].eTW;
//								 if (temp > eps) {ok = 0; break;} //vioTW at nextC
//								 else
//								 {
//									 ArrTime = PDS_MAX(ArrTime, problem->node[nextC].sTW) + problem->node[nextC].duration;
//									 curC = nextC; nextC = nextArrTemp[curC];
//								 }
//							 }
//							 if (ok) //curC is now pointed to lastC
//							 {
//								 costT1 = costT + problem->c[idCusP][idCusD] + problem->c[idCusD][firstC_C2C] - problem->c[idCusP][firstC_C2C];
//								 //changeWS = 0;
//								 ok = checkFeasibleCostChange_ConnectC2CDToSP(curC,ArrTime,costT1,endSP,seg[idVeh].Trip[idTrip].waitingS, changeWS);
//								 if (ok)
//								 {
//									 if (costT1 < costMINI)
//									 {
//										 costMINI = costT1;
//										 IDinsert = idCusP;
//										 insert_afterP = 0;
//										 insert_afterD = idCusP;
//										 changeWSSEED = changeWS;
//									 }
//								 }
//							 }//end if (ok)
//						 }//else vioTW at cus nextINS*/
//						 
//						 //1.2 Find place to insert idCusD from position after firstC_C2C assuming that idCusP is inserted at the beginning of the trip:
//                          ok = checkC2CTripFeasible_AfterInsertC2C_Temp(idCusP, depart_idCusP,firstC_C2C,1,departTemp,endSP);
//						  if (ok) //TW is ok for all customers in trip C2C and next PTrip(idVeh, nextT) after inserting idCusP to the trip C2C
//						  {
//							 int i = 1; curC = firstC_C2C;
//							 while (i <= seg[idVeh].Trip[idTrip].numCus) //insert idCusD after curC at position i of idTrip
//							 {
//								 //1.2 Insert idCusD right after place i
//								 if (curC < startidC2CD) //curC is a C2CP
//								 {
//									 curC = problem->node[curC].delID;
//									 i = pos[curC];
//								 }
//								 else //curC is a C2CD:
//								 {
//									 idCus = problem->node[curC].pickID;
//									 if (pos[idCus] > 0)
//									 {
//										 //Insert idCusD after curC: check capacity and vioTW
//										 ok = checkCapacity_C2CTrip_InitSol_Temp(firstC_C2C, curC,FCAPT);
//										 if (ok)
//										 {
//											 ArrTime = departTemp[i] + problem->c[curC][idCusD];
//											 temp = problem->node[idCusD].eTW - ArrTime;
//											 if (temp > eps)
//											 {
//												 ArrTime = PDS_MAX(ArrTime, problem->node[idCusD].sTW) + problem->node[idCusD].duration;
//												 costT1 = costT; double buc1 = costT1;
//												 ok = checkC2CTripFeasibleCostChange_AfterInsertC2C_Temp(idCusD,ArrTime, nextArrTemp[curC],costT1,idVeh,idTrip,endSP,changeWS);
//												 if (ok) //it's ok to insert idCusD after curC
//												 {
//													 nextC = nextArrTemp[curC]; double buc2 = costT1;
//													 if (nextC > 0)
//														costT1 += (problem->c[curC][idCusD] + problem->c[idCusD][nextC] - problem->c[curC][nextC]);
//													 else
//														costT1 += problem->c[curC][idCusD];
//
//													 if (costT1 < costMINI)
//													 {	
//														 costMINI = costT1;
//														 IDinsert = idCusP;
//														 insert_afterP = 0;
//														 insert_afterD = curC;
//														 changeWSSEED = changeWS;
//														 //cout<<"cost change at connect cusP = "<<buc1<<" cost change at SP = "<<(buc2-buc1)<<"; cost change to connect cusD = "<<(costT1-buc2)<<"; endSP = "<<endSP<<"; costMINI = "<<costMINI<<endl;
//													 }
//												 }
//											 }
//
//										 }//else not ok capacity of vehicle
//										 i ++; curC = nextArrTemp[curC];
//									 }
//									 else break;
//								 }
//							 }
//						  }
//					 //2. Insert idCusP in the middle of the trip
//					 preINS = firstC_C2C;
//					 nextINS = nextArrTemp[preINS];
//                     for (j=1;j<seg[idVeh].Trip[idTrip].numCus;j++) //insert idCusP between preINS and nextINS
//					 {
//						 FCAPT = FCAP[preINS] + problem->node[idCusP].capacity;
//						 if (FCAPT <= problem->Q)
//						 {
//	 						costT = problem->c[preINS][idCusP] + problem->c[idCusP][nextINS] - problem->c[preINS][nextINS];
//							cStartS = depart[preINS] + problem->c[preINS][idCusP];
//							temp = problem->node[idCusP].eTW - cStartS;
//							if (temp > eps)
//							{
//								 depart_idCusP = PDS_MAX(cStartS, problem->node[idCusP].sTW) + problem->node[idCusP].duration;
//								 //2.1 Insert idCusD right after idCusP: don't need to check capacity of vehicle
//								 ArrTime = PDS_MAX(depart_idCusP + problem->c[idCusP][idCusD], problem->node[idCusD].sTW) + problem->node[idCusD].duration;
//								 costT1 = costT;
//								 ok = checkC2CTripFeasibleCostChange_AfterInsertC2C_Temp(idCusD,ArrTime,nextINS,costT1,idVeh,idTrip,endSP,changeWS);
//							     if (ok) //it's ok to insert idCusD right after idCusP
//								 {
//									 costT1 += (problem->c[idCusP][idCusD] + problem->c[idCusD][nextINS] - problem->c[idCusP][nextINS]);
//									 if (costT1 < costMINI)
//									 {
//										 costMINI = costT1;
//										 IDinsert = idCusP;
//										 insert_afterP = preINS;
//										 insert_afterD = idCusP;
//										 changeWSSEED = changeWS;
//									 }
//								 }
//		 						 //2.2 Find place to insert idCusD from position after nextINS assuming that idCusP is inserted between preINS and nextINS:
//          						 ok = checkC2CTripFeasible_AfterInsertC2C_Temp(idCusP,depart_idCusP,nextINS,j+1,departTemp,endSP);
//								 if (ok) //TW is ok for all customers in trip C2C and next PTrip(idVeh, nextT) after inserting idCusP to the trip C2C between preINS and nextINS
//								 {
//									 i = j + 1; curC = nextINS;
//									 while (i <= seg[idVeh].Trip[idTrip].numCus) //insert idCusD after curC at position i of idTrip
//									 {
//										 //2.2 Insert idCusD right after place i:
//										 if (curC < startidC2CD) //curC is a C2CP
//										 {
//											 curC = problem->node[curC].delID;
//											 i = pos[curC];
//										 }
//										 else //curC is a C2CD
//										 {
//                                              idCus = problem->node[curC].pickID;
//											  if (pos[idCus] > j)
//											  {
//												  //Insert idCusD after curC: check capacity of vehicle and vioTW
//												  ok = checkCapacity_C2CTrip_InitSol_Temp(nextINS,curC, FCAPT);
//												  if (ok)
//												  {
//													  ArrTime = departTemp[i] + problem->c[curC][idCusD];
//													  temp = problem->node[idCusD].eTW - ArrTime;
//													  if (temp > eps)
//													  {
//															 ArrTime = PDS_MAX(ArrTime, problem->node[idCusD].sTW) + problem->node[idCusD].duration;
//															 costT1 = costT;
//															 ok = checkC2CTripFeasibleCostChange_AfterInsertC2C_Temp(idCusD,ArrTime,nextArrTemp[curC],costT1,idVeh,idTrip,endSP,changeWS);
//															 if (ok) //it's ok to insert idCusD after curC
//															 {
//																 nextC = nextArrTemp[curC];
//																 if (nextC > 0)
//																	costT1 += (problem->c[curC][idCusD] + problem->c[idCusD][nextC] - problem->c[curC][nextC]);
//																 else
//																	 costT1 += problem->c[curC][idCusD];
//
//																 if (costT1 < costMINI)
//																 {	
//																	 costMINI = costT1;
//																	 IDinsert = idCusP;
//																	 insert_afterP = preINS;
//																	 insert_afterD = curC;
//																	 changeWSSEED = changeWS;
//																 }
//															 }
//													  }//else vioTW at idCusD
//												  }//else vio capacity of vehicle
//												  i++; curC = nextArrTemp[curC];
//											  }
//											  else break;
//										 }//end curC is a C2CD
//									 }//end while
//								 }//else TW is NOT ok for all customers in trip C2C and next PTrip(idVeh, nextT) after inserting idCusP to the trip C2C between preINS and nextINS
//							}//else vioTW at idCusP
//						 }//else can't insert between preINS and nextINS due to the capacity of the trip
//						 preINS = nextINS; nextINS = nextArrTemp[preINS];
//					 }//end for j
//
//					 //3. Insert idCusP at the end of the trip C2C: [after preINS] --> dont need to check CAPACITY of vehicle
// 					 cStartS = depart[preINS] + problem->c[preINS][idCusP];
//					 temp = problem->node[idCusP].eTW - cStartS;
//					 if (temp > eps)
//					 {
//								 depart_idCusP = PDS_MAX(cStartS, problem->node[idCusP].sTW) + problem->node[idCusP].duration;
//								 //3.1 Insert idCusD right after idCusP:
// 								 ArrTime = PDS_MAX(depart_idCusP + problem->c[idCusP][idCusD], problem->node[idCusD].sTW) + problem->node[idCusD].duration;
//								 costT1 = problem->c[preINS][idCusP] + problem->c[idCusP][idCusD];
//								 ok = checkFeasible_ConnectC2CDToSP_AfterInsertC2C(idCusD,ArrTime,costT1,seg[idVeh].Trip[idTrip].lastCus,endSP,seg[idVeh].Trip[idTrip].waitingS,changeWS); 
//								 if (ok)
//								 {
//									 if (costT1 < costMINI)
//									 {
//										 costMINI = costT1;
//										 IDinsert = idCusP;
//										 insert_afterP = preINS;
//										 insert_afterD = idCusP;
//										 changeWSSEED = changeWS;
//									 }
//								 }//end if (ok)
//					 }//else vioTW at idCusP
//				 } //else idCusP already routed 
//			 }//end for idCusP: try all unrouted C2C
//			 if (IDinsert != -1)
//			 {
//		  
//				 idCusD = problem->node[IDinsert].delID;
//				 //cout<<"Insert C2CP customer "<<IDinsert<<" after "<<insert_afterP<<" and insert C2CD "<<idCusD<<" after "<<insert_afterD<<": "<<endl;
//				 if (insert_afterP == seg[idVeh].Trip[idTrip].lastCus) //insert at the end of the trip:
//				 {
// 					  nextArrTemp[insert_afterP] = IDinsert; 
//					  nextArrTemp[IDinsert] = idCusD; 
//					  seg[idVeh].Trip[idTrip].lastCus = idCusD;nextArrTemp[idCusD] = 0;
//  					  startS[IDinsert] = PDS_MAX(depart[insert_afterP] + problem->c[insert_afterP][IDinsert], problem->node[IDinsert].sTW);
//					  depart[IDinsert] = startS[IDinsert] + problem->node[IDinsert].duration;
//					  FCAP[IDinsert] = problem->node[IDinsert].capacity;
//					  FCAP[idCusD] = 0;
//					  pos[IDinsert] = pos[insert_afterP] + 1; pos[idCusD] = pos[IDinsert] + 1;
//					  startS[idCusD] = PDS_MAX(depart[IDinsert] + problem->c[IDinsert][idCusD], problem->node[idCusD].sTW);
//					  depart[idCusD] = startS[idCusD] + problem->node[idCusD].duration;
//					  seg[idVeh].Trip[idTrip].cost += costMINI;
//					  if (changeWSSEED) //gotoWS:
//						  seg[idVeh].Trip[idTrip].waitingS = problem->CWSSP[idCusD][endSP];
//					  else seg[idVeh].Trip[idTrip].waitingS = NO_WS;
//					  
//				 }
//				 else //not insert at the end of the trip C2C
//				 {
//					 if (insert_afterP == 0)
//					 {
//						 /*if (preC > 0)
//						 {
//							 double deltaCost = problem->c[preC][IDinsert] - problem->c[preC][firstC_C2C];
//							 seg[idVeh].Trip[preT].connectCost = problem->c[preC][IDinsert];
//							 seg[idVeh].Trip[preT].cost += deltaCost;
//							 seg[idVeh].Trip[idTrip].cost += (costMINI - deltaCost);
//						 }
//						 else
//						 {
//							 seg[idVeh].Trip[idTrip].cost += costMINI;
//						 }*/
//						 seg[idVeh].Trip[idTrip].cost += costMINI;
//						 seg[idVeh].Trip[idTrip].firstCus = IDinsert;
//						 nextArrTemp[IDinsert] = firstC_C2C;
//						 startS[IDinsert] = PDS_MAX(depart_preC + problem->c[preC][IDinsert], problem->node[IDinsert].sTW);
//						 depart[IDinsert] = startS[IDinsert] + problem->node[IDinsert].duration;
//						 pos[IDinsert] = 1;
//						 FCAP[IDinsert] = problem->node[IDinsert].capacity;
//					 }
//					 else //insert in the middle
//					 {
// 						  int tt=nextArrTemp[insert_afterP];
//						  nextArrTemp[insert_afterP]=IDinsert;
//						  nextArrTemp[IDinsert]=tt;
//  						  startS[IDinsert] = PDS_MAX(depart[insert_afterP] + problem->c[insert_afterP][IDinsert], problem->node[IDinsert].sTW);
//						  depart[IDinsert] = startS[IDinsert] + problem->node[IDinsert].duration;
//						  pos[IDinsert] = pos[insert_afterP] + 1;
//						  seg[idVeh].Trip[idTrip].cost += costMINI;
//						  FCAP[IDinsert] = FCAP[insert_afterP] + problem->node[IDinsert].capacity;
//					 }//end insert in the middle
//
//					 if (insert_afterD == IDinsert) //insert idCusD right after idCusP
//					 {
//						 startS[idCusD] = PDS_MAX(depart[IDinsert] + problem->c[IDinsert][idCusD], problem->node[idCusD].sTW);
//						 depart[idCusD] = startS[idCusD] + problem->node[idCusD].duration;
//						 int tt = nextArrTemp[IDinsert];
//						 nextArrTemp[IDinsert] = idCusD; nextArrTemp[idCusD] = tt; 
//						 pos[idCusD] = pos[IDinsert] + 1;
//						 FCAP[idCusD] = FCAP[IDinsert] + problem->node[idCusD].capacity;
//					 }
//					 else //insert idCusD after insert_afterD:
//					 {
//						 curC = IDinsert; nextC = nextArrTemp[IDinsert];
//						 do
//						 {
//							 startS[nextC] = PDS_MAX(depart[curC] + problem->c[curC][nextC], problem->node[nextC].sTW);
//							 depart[nextC] = startS[nextC] + problem->node[nextC].duration;
//							 pos[nextC] ++; FCAP[nextC] = FCAP[curC] + problem->node[nextC].capacity;
//							 curC = nextC; nextC = nextArrTemp[curC];
//						 }while (curC != insert_afterD);
//						 //Insert idCusD after insert_afterD:
//						 startS[idCusD] = PDS_MAX(depart[insert_afterD] + problem->c[insert_afterD][idCusD], problem->node[idCusD].sTW);
//						 depart[idCusD] = startS[idCusD] + problem->node[idCusD].duration;
//						 nextArrTemp[idCusD] = nextArrTemp[insert_afterD];
//						 nextArrTemp[insert_afterD] = idCusD; 
//						 pos[idCusD] = pos[insert_afterD] + 1;
//						 FCAP[idCusD] = FCAP[insert_afterD] + problem->node[idCusD].capacity;
//					 }//end insert idCusD after insert_afterD:
//					 nextC = nextArrTemp[idCusD];
//					 if (nextC > 0)
//					 {
//						 updateStartS_pos_FCAP_FEASIBLETRIP_Temp(idVeh,idTrip,idCusD,nextC,pos[idCusD]);
//						 //lastCus of C2C doesn't change
//						 if (changeWSSEED) seg[idVeh].Trip[idTrip].waitingS = NO_WS;
//					 }
//					 else
//					 {
//						 seg[idVeh].Trip[idTrip].lastCus = idCusD;
//						 //lastCus of C2C has changed:
//						 if (changeWSSEED) seg[idVeh].Trip[idTrip].waitingS = problem->CWSSP[idCusD][endSP];
//						 else seg[idVeh].Trip[idTrip].waitingS = NO_WS;
//					 }
//				 }//end not insert at the end of the trip C2C
//
//				  seg[idVeh].Trip[idTrip].numCus +=2; 
//				  //cout<<"Now #customer of C2Ctrip = "<<seg[idVeh].Trip[idTrip].numCus<<endl;
//				  routedTemp[IDinsert] = 1; routedTemp[idCusD] = 1;
//				  numCusC2CRoutedTemp += 2;
//				  if (numCusC2CRoutedTemp == problem->nC2C) cont = 0;
//				  seg[idVeh].Trip[idTrip].capacity += problem->node[IDinsert].capacity;
//				  //seg[idVeh].Trip[idTrip].cost += costMINI1;
//				  seg[idVeh].Trip[idTrip].endS = depart[seg[idVeh].Trip[idTrip].lastCus];
//				  ok = checkC2C_FeasibleTrip_InitSol_Temp(idVeh,idTrip,preC,depart_preC,1,endSP);
//				  if (ok == 0) exit(-1);
//			 } else cont = 0; //can't route any C2C anymore
//		 }while (cont);
//		 delete [] departTemp;
//
//	 }
//	 int lastC2C = seg[idVeh].Trip[idTrip].lastCus;
//	 if (seg[idVeh].Trip[idTrip].waitingS == NO_WS)
//		seg[idVeh].Trip[idTrip].arriveSP = depart[lastC2C] + problem->c[lastC2C][endSP];
//	 else
//        seg[idVeh].Trip[idTrip].arriveSP = PDS_MAX(depart[lastC2C] + problem->disCWSSP[lastC2C][endSP], problem->nodeSP[endSP].sTW2);
//     seg[idVeh].Trip[idTrip].leaveSP = seg[idVeh].Trip[idTrip].leaveSP;	
//	 return 1;
//}
//
//
//
//
//
//
//bool Solution::checkPickupTripFeasible_AfterInsertC2C(int idCusD, double departTime, double &costT, int idVeh, int idTrip, bool &changed_idTrip)
//{
//	//
//	int preC = seg[idVeh].Trip[idTrip].firstCus;
//	double cStartS, ArrTime, temp;
//	cStartS = PDS_MAX(departTime + problem->c[idCusD][preC], problem->node[preC].sTW);
//	//cout<<"idCusD = "<<idCusD<<"; firstCofPTrip = "<<preC<<"; startS = "<<cStartS<<"; [sTW, eTW] = ["<<problem->node[preC].sTW<<", "<<problem->node[preC].eTW<<"]"<<endl;
//	if (PDSDIF(cStartS, startS[preC])==0) 
//	  {/*cout<<"startS of cus "<<preC<<" doesn't change -->ok"<<endl;*/ return 1;}
//	temp = cStartS - problem->node[preC].eTW;
//	if (temp > eps) {/*cout<<"not ok TW at cus "<<preC<<endl; */return 0;}
//    int curC = nextArr[preC];
//	while (curC > 0)
//	{
//		ArrTime = cStartS + problem->node[preC].duration + problem->c[preC][curC];
//		cStartS = PDS_MAX(ArrTime, problem->node[curC].sTW);
//		if (PDSDIF(cStartS, startS[curC])==0) {/*cout<<"startS of cus "<<curC<<" doesn't change -->ok"<<endl;*/ return 1;}
//		temp = cStartS - problem->node[curC].eTW;
//		if (temp > eps) {/*cout<<"not ok TW at cus "<<curC<<endl; */return 0;}
//		//cout<<curC<<"(startS = "<<cStartS<<"); ";
//		preC = curC; curC = nextArr[curC];
//	}
//	//cout<<"--> ok TW of all Pcus"<<endl;
//	//preC now points to the last customers of P(idVeh, idTrip)
//	int assSP = seg[idVeh].Trip[idTrip].assSP;
//	cStartS += problem->node[preC].duration;
//	if (seg[idVeh].Trip[idTrip].waitingS == NO_WS)
//	{
//		//before insert go directly to sp --> after insert still the same
//		ArrTime = cStartS + problem->c[preC][assSP];
//		if (PDSINRANGE(ArrTime, problem->nodeSP[assSP].sTW1, problem->nodeSP[assSP].eTW1)) return 1;
//		return 0;
//	}
//	else
//	{
//		//Before insert, vehicle go to sp through WS:
//		ArrTime = cStartS + problem->c[preC][assSP];
//		if (PDSINRANGE(ArrTime, problem->nodeSP[assSP].sTW1, problem->nodeSP[assSP].eTW1))
//		{
//			costT += (problem->c[preC][assSP] - problem->disCWSSP[preC][assSP]); //after insert go to SP directly
//			changed_idTrip = 1;
//			return 1;
//		}
//		else
//		{
//			temp = ArrTime - problem->nodeSP[assSP].eTW1;
//			if (temp > eps) return 0; //now vioTWSP
//			ArrTime = cStartS + problem->disCWSSP[preC][assSP];
//			temp = ArrTime - problem->nodeSP[assSP].eTW1;
//			if (temp > eps) return 0; //after insert: go to SP directly too soon, go through WS too late
//			return 1; //after insert, still go through WS
//		}
//	}
//}
//
//
//bool Solution::checkPickupTripFeasible_AfterInsertC2C_Temp(int idCusD, double departTime, double &costT, int idVeh, int idTrip, bool &changed_idTrip)
//{
//	int preC = seg[idVeh].Trip[idTrip].firstCus;
//	double cStartS, ArrTime, temp;
//	cStartS = PDS_MAX(departTime + problem->c[idCusD][preC], problem->node[preC].sTW);
//	if (PDSDIF(cStartS, startS[preC])==0) return 1;
//	temp = cStartS - problem->node[preC].eTW;
//	if (temp > eps) return 0;
//    int curC = nextArrTemp[preC];
//	while (curC > 0)
//	{
//		ArrTime = cStartS + problem->node[preC].duration + problem->c[preC][curC];
//		cStartS = PDS_MAX(ArrTime, problem->node[curC].sTW);
//		if (PDSDIF(cStartS, startS[curC])==0) return 1;
//		temp = cStartS - problem->node[curC].eTW;
//		if (temp > eps) return 0;
//		preC = curC; curC = nextArrTemp[curC];
//	}
//	//preC now points to the last customers of P(idVeh, idTrip)
//	int assSP = seg[idVeh].Trip[idTrip].assSP;
//	cStartS += problem->node[preC].duration;
//	if (seg[idVeh].Trip[idTrip].waitingS == NO_WS)
//	{
//		//before insert go directly to sp --> after insert still the same
//		ArrTime = cStartS + problem->c[preC][assSP];
//		if (PDSINRANGE(ArrTime, problem->nodeSP[assSP].sTW1, problem->nodeSP[assSP].eTW1)) return 1;
//		return 0;
//	}
//	else
//	{
//		//Before insert, vehicle go to sp through WS:
//		ArrTime = cStartS + problem->c[preC][assSP];
//		if (PDSINRANGE(ArrTime, problem->nodeSP[assSP].sTW1, problem->nodeSP[assSP].eTW1))
//		{
//			costT += (problem->c[preC][assSP] - problem->disCWSSP[preC][assSP]); //after insert go to SP directly
//			changed_idTrip = 1;
//			return 1;
//		}
//		else
//		{
//			temp = ArrTime - problem->nodeSP[assSP].eTW1;
//			if (temp > eps) return 0; //now vioTWSP
//			ArrTime = cStartS + problem->disCWSSP[preC][assSP];
//			temp = ArrTime - problem->nodeSP[assSP].eTW1;
//			if (temp > eps) return 0; //after insert: go to SP directly too soon, go through WS too late
//			return 1; //after insert, still go through WS
//		}
//	}
//}
//
//bool Solution::checkFeasible_ConnectC2CDToSP_AfterInsertC2C(int lastC, double depart_lastC, double &costT, int lastCOLD, int endSP, int goWS, bool &changeWSORGoWS)
//{
//	//Used by CreateC2CTrip_BetweenDTripandSP_Temp
//	double ArrTime;
//	if (lastCOLD == lastC)
//	{
//		if (goWS == NO_WS)
//		{
//			//before insert go directly to sp --> after insert still the same
//			changeWSORGoWS = 0;
//			ArrTime = depart_lastC + problem->c[lastC][endSP];
//			if (PDSINRANGE(ArrTime, problem->nodeSP[endSP].sTW2, problem->nodeSP[endSP].eTW2)) return 1;
//			return 0;
//		}
//		else
//		{
//			//Before insert, vehicle go to sp through WS:
//			ArrTime = depart_lastC + problem->c[lastC][endSP];
//			if (PDSINRANGE(ArrTime, problem->nodeSP[endSP].sTW2, problem->nodeSP[endSP].eTW2))
//			{
//				costT += (problem->c[lastC][endSP] - problem->disCWSSP[lastC][endSP]); //after insert go to SP directly
//				changeWSORGoWS = 1;
//				return 1;
//			}
//			else
//			{
//				double temp = ArrTime - problem->nodeSP[endSP].eTW2;
//				if (temp > eps) return 0; //now vioTWSP
//				ArrTime = depart_lastC + problem->disCWSSP[lastC][endSP];
//				temp = ArrTime - problem->nodeSP[endSP].eTW1;
//				if (temp > eps) return 0; //after insert: go to SP directly too soon, go through WS too late
//				changeWSORGoWS = 0;
//				return 1; //after insert, still go through WS
//			}
//		}
//
//	}
//	else //lastC of C2C has changed
//	{
//		ArrTime = depart_lastC + problem->c[lastC][endSP];
//		if (PDSINRANGE(ArrTime, problem->nodeSP[endSP].sTW2, problem->nodeSP[endSP].eTW2))
//		{
//			if (goWS == NO_WS)
//			{
//				costT += (problem->c[lastC][endSP] - problem->c[lastCOLD][endSP]);
//			}
//			else 
//			{
//				costT += (problem->c[lastC][endSP] - problem->disCWSSP[lastCOLD][endSP]);
//			}
//			changeWSORGoWS = 0;
//			return 1;
//		}
//		double temp = ArrTime - problem->nodeSP[endSP].eTW2;
//		if (temp > eps) return 0;
//		ArrTime = depart_lastC + problem->disCWSSP[lastC][endSP];
//		temp = ArrTime - problem->nodeSP[endSP].eTW2;
//		if (temp > eps) return 0;
//		if (goWS == NO_WS)
//			costT += (problem->disCWSSP[lastC][endSP] - problem->c[lastCOLD][endSP]);
//		else costT += (problem->disCWSSP[lastC][endSP] - problem->disCWSSP[lastCOLD][endSP]);
//		changeWSORGoWS = 1;
//		return 1;
//	}//end lastC of C2C has changed
//}
//
//
//
//bool Solution::checkC2CAndPTripFeasible_AfterInsertC2C(int curC, double departTime, int nextC, int pos_nextC, double *departTemp, int idVeh, int idTrip)
//{
//	//Update 10/11/2013: check TW at all customers of TRip C2C starting from curC with departureTime and then all customers of next Ptrip(idVeh,idTrip)
//	//if feasible return 1; otherwise return 0
//
//	double cStartS, ArrTime, temp;
//	cStartS = departTime;
//	while (nextC > 0)
//	{
//		ArrTime = cStartS + problem->c[curC][nextC];
//		cStartS = PDS_MAX(ArrTime, problem->node[nextC].sTW);
//		temp = cStartS - problem->node[nextC].eTW;
//		if (temp > eps) return 0;
//		cStartS += problem->node[nextC].duration;
//		departTemp[pos_nextC] = cStartS;
//		pos_nextC++;
//		curC = nextC; nextC = nextArr[curC];
//	}
//	//curC now points to the last customer of trip C2C, now continue checking PTrip
//    nextC = seg[idVeh].Trip[idTrip].firstCus;
//	while (nextC > 0)
//	{
//		ArrTime = cStartS + problem->c[curC][nextC];
//		cStartS = PDS_MAX(ArrTime, problem->node[nextC].sTW);
//		if (PDSDIF(cStartS, startS[nextC])==0) return 1;
//		temp = cStartS - problem->node[nextC].eTW;
//		if (temp > eps) return 0;
//		cStartS += problem->node[nextC].duration;
//		curC = nextC; nextC = nextArr[curC];
//	}
//
//	//curC now points to the last customers of PTrip
//	int assSP = seg[idVeh].Trip[idTrip].assSP;
//	ArrTime = cStartS + problem->c[curC][assSP];
//	if (PDSINRANGE(ArrTime, problem->nodeSP[assSP].sTW1, problem->nodeSP[assSP].eTW1)) return 1;
//
//	temp = ArrTime - problem->nodeSP[assSP].eTW1;
//	if (temp > eps) return 0; //now vioTWSP
//	ArrTime = cStartS + problem->disCWSSP[curC][assSP];
//	temp = ArrTime - problem->nodeSP[assSP].eTW1;
//	if (temp > eps) return 0; //after insert: go to SP directly too soon, go through WS too late
//	return 1; //after insert, still go through WS
//}
//
//
//
//bool Solution::checkC2CAndPTripFeasible_AfterInsertC2C_Temp(int curC, double departTime, int nextC, int pos_nextC, double *departTemp, int idVeh, int idTrip)
//{
//	//Update 10/11/2013: check TW at all customers of TRip C2C starting from curC with departureTime and then all customers of next Ptrip(idVeh,idTrip)
//	//if feasible return 1; otherwise return 0
//
//	double cStartS, ArrTime, temp;
//	cStartS = departTime;
//	while (nextC > 0)
//	{
//		ArrTime = cStartS + problem->c[curC][nextC];
//		cStartS = PDS_MAX(ArrTime, problem->node[nextC].sTW);
//		temp = cStartS - problem->node[nextC].eTW;
//		if (temp > eps) return 0;
//		cStartS += problem->node[nextC].duration;
//		departTemp[pos_nextC] = cStartS;
//		pos_nextC++;
//		curC = nextC; nextC = nextArrTemp[curC];
//	}
//	//curC now points to the last customer of trip C2C, now continue checking PTrip
//    nextC = seg[idVeh].Trip[idTrip].firstCus;
//	while (nextC > 0)
//	{
//		ArrTime = cStartS + problem->c[curC][nextC];
//		cStartS = PDS_MAX(ArrTime, problem->node[nextC].sTW);
//		if (PDSDIF(cStartS, startS[nextC])==0) return 1;
//		temp = cStartS - problem->node[nextC].eTW;
//		if (temp > eps) return 0;
//		cStartS += problem->node[nextC].duration;
//		curC = nextC; nextC = nextArrTemp[curC];
//	}
//
//	//curC now points to the last customers of PTrip
//	int assSP = seg[idVeh].Trip[idTrip].assSP;
//	ArrTime = cStartS + problem->c[curC][assSP];
//	if (PDSINRANGE(ArrTime, problem->nodeSP[assSP].sTW1, problem->nodeSP[assSP].eTW1)) return 1;
//
//	temp = ArrTime - problem->nodeSP[assSP].eTW1;
//	if (temp > eps) return 0; //now vioTWSP
//	ArrTime = cStartS + problem->disCWSSP[curC][assSP];
//	temp = ArrTime - problem->nodeSP[assSP].eTW1;
//	if (temp > eps) return 0; //after insert: go to SP directly too soon, go through WS too late
//	return 1; //after insert, still go through WS
//}
//
//
//
//bool Solution::checkC2CTripFeasible_AfterInsertC2C_Temp(int curC, double departTime, int nextC, int pos_nextC, double *departTemp, int endSP)
//{
//	//Update 10/11/2013: check TW at all customers of TRip C2C starting from curC with departureTime and then all customers of next Ptrip(idVeh,idTrip)
//	//if feasible return 1; otherwise return 0
//
//	double cStartS, ArrTime, temp;
//	cStartS = departTime;
//	while (nextC > 0)
//	{
//		ArrTime = cStartS + problem->c[curC][nextC];
//		cStartS = PDS_MAX(ArrTime, problem->node[nextC].sTW);
//		temp = cStartS - problem->node[nextC].eTW;
//		if (temp > eps) return 0;
//		cStartS += problem->node[nextC].duration;
//		departTemp[pos_nextC] = cStartS;
//		pos_nextC++;
//		curC = nextC; nextC = nextArrTemp[curC];
//	}
//	//curC now points to the last customers of C2CTrip
//	ArrTime = cStartS + problem->c[curC][endSP];
//	if (PDSINRANGE(ArrTime, problem->nodeSP[endSP].sTW2, problem->nodeSP[endSP].eTW2)) return 1;
//	temp = ArrTime - problem->nodeSP[endSP].eTW2;
//	if (temp > eps) return 0; //now vioTWSP
//	ArrTime = cStartS + problem->disCWSSP[curC][endSP];
//	temp = ArrTime - problem->nodeSP[endSP].eTW2;
//	if (temp > eps) return 0; //after insert: go to SP directly too soon, go through WS too late
//	return 1; //after insert, still go through WS
//
//
//}
//
//
//
//
//
//bool Solution::checkC2CVehicleFeasible(int curC, double departTime, int nextC, int pos_nextC, double *departTemp)
//{
//	//Update 10/11/2013: check TW at all customers of TRip C2C starting from curC with departureTime and then all customers of next Ptrip(idVeh,idTrip)
//	//if feasible return 1; otherwise return 0
//
//	double cStartS, ArrTime, temp;
//	cStartS = departTime;
//	while (nextC > 0)
//	{
//		ArrTime = cStartS + problem->c[curC][nextC];
//		cStartS = PDS_MAX(ArrTime, problem->node[nextC].sTW);
//		temp = cStartS - problem->node[nextC].eTW;
//		if (temp > eps) return 0;
//		cStartS += problem->node[nextC].duration;
//		departTemp[pos_nextC] = cStartS;
//		pos_nextC++;
//		curC = nextC; nextC = nextArr[curC];
//	}
//	return 1;
//}
//
//
//
//
//
//
//bool Solution::checkC2CAndPTripFeasibleCostChange_AfterInsertC2C(int curC, double departTime_curC, int nextC, double &costT, int idVeh, int idTrip, bool &changed_idTrip)
//{
//	//Update 10/11/2013: check TW at all customers of TRip C2C starting from curC with departureTime and then all customers of next Ptrip(idVeh,idTrip)
//	//if feasible return 1; otherwise return 0
//	//and calculate the change in cost due to connect to SP of PTrip
//
//	costT = 0;
//	double cStartS, ArrTime, temp;
//	cStartS = departTime_curC;
//	while (nextC > 0)
//	{
//		ArrTime = cStartS + problem->c[curC][nextC];
//		cStartS = PDS_MAX(ArrTime, problem->node[nextC].sTW);
//		temp = cStartS - problem->node[nextC].eTW;
//		if (temp > eps) return 0;
//		cStartS += problem->node[nextC].duration;
//		curC = nextC; nextC = nextArr[curC];
//	}
//	//curC now points to the last customer of trip C2C, now continue checking PTrip
//    nextC = seg[idVeh].Trip[idTrip].firstCus;
//	while (nextC > 0)
//	{
//		ArrTime = cStartS + problem->c[curC][nextC];
//		cStartS = PDS_MAX(ArrTime, problem->node[nextC].sTW);
//		if (PDSDIF(cStartS, startS[nextC])==0) return 1;
//		temp = cStartS - problem->node[nextC].eTW;
//		if (temp > eps) return 0;
//		cStartS += problem->node[nextC].duration;
//		curC = nextC; nextC = nextArr[curC];
//	}
//
//	//curC now points to the last customers of PTrip
//	int assSP = seg[idVeh].Trip[idTrip].assSP;
//	if (seg[idVeh].Trip[idTrip].waitingS == NO_WS)
//	{
//		//before insert go directly to sp --> after insert still the same
//		ArrTime = cStartS + problem->c[curC][assSP];
//		if (PDSINRANGE(ArrTime, problem->nodeSP[assSP].sTW1, problem->nodeSP[assSP].eTW1)) return 1;
//		return 0;
//	}
//	else
//	{
//		//Before insert, vehicle go to sp through WS:
//		ArrTime = cStartS + problem->c[curC][assSP];
//		if (PDSINRANGE(ArrTime, problem->nodeSP[assSP].sTW1, problem->nodeSP[assSP].eTW1))
//		{
//			costT += (problem->c[curC][assSP] - problem->disCWSSP[curC][assSP]); //after insert go to SP directly
//			changed_idTrip = 1;
//			return 1;
//		}
//		else
//		{
//			temp = ArrTime - problem->nodeSP[assSP].eTW1;
//			if (temp > eps) return 0; //now vioTWSP
//			ArrTime = cStartS + problem->disCWSSP[curC][assSP];
//			temp = ArrTime - problem->nodeSP[assSP].eTW1;
//			if (temp > eps) return 0; //after insert: go to SP directly too soon, go through WS too late
//			return 1; //after insert, still go through WS
//		}
//	}
//}
//
//bool Solution::checkC2CTripFeasibleCostChange_AfterInsertC2C_Temp(int curC, double departTime_curC, int nextC, double &costT, int idVeh, int idTrip, int endSP, bool &changeWSORGoWS)
//{
//	//Used by CreateC2CTrip_BetweenDTripandSP_Temp
//
//	//Update 12/11/2013: check TW at all customers of TRip C2C starting from curC with departureTime and at SP endSP
//	//if feasible return 1; otherwise return 0
//	//and calculate the change in cost due to connect to endSP
//
//	double cStartS, ArrTime, temp;
//	cStartS = departTime_curC;
//	int idCusD = curC;
//
//		while (nextC > 0)
//		{
//			ArrTime = cStartS + problem->c[curC][nextC];
//			cStartS = PDS_MAX(ArrTime, problem->node[nextC].sTW);
//			temp = cStartS - problem->node[nextC].eTW;
//			if (temp > eps) return 0;
//			cStartS += problem->node[nextC].duration;
//			curC = nextC; nextC = nextArrTemp[curC];
//		}
//		//curC now points to the last customer of trip C2C, now continue checking PTrip
//		int lastC2C = seg[idVeh].Trip[idTrip].lastCus;
//		if (curC == lastC2C) //lastCus has not changed
//		{
//			if (seg[idVeh].Trip[idTrip].waitingS == NO_WS)
//			{
//				//before insert go directly to sp --> after insert still the same
//				changeWSORGoWS = 0;
//				ArrTime = cStartS + problem->c[curC][endSP];
//				if (PDSINRANGE(ArrTime, problem->nodeSP[endSP].sTW2, problem->nodeSP[endSP].eTW2)) 
//				{
//					//cout<<"idCusD = "<<idCusD<<"; LastCus of C2C NOT changed("<<curC<<"); before go to sp directly --> now has to the same"<<endl;
//					return 1;
//				}
//				return 0;
//			}
//			else
//			{
//				//Before insert, vehicle go to sp through WS:
//				ArrTime = cStartS + problem->c[curC][endSP];
//				if (PDSINRANGE(ArrTime, problem->nodeSP[endSP].sTW2, problem->nodeSP[endSP].eTW2))
//				{
//					//cout<<"idCusD = "<<idCusD<<"; LastCus of C2C NOT changed("<<curC<<"); before go to WS --> now sp directly"<<endl;
//					costT += (problem->c[curC][endSP] - problem->disCWSSP[curC][endSP]); //after insert go to SP directly
//					changeWSORGoWS = 1;
//					return 1;
//				}
//				else
//				{
//					temp = ArrTime - problem->nodeSP[endSP].eTW2;
//					if (temp > eps) return 0; //now vioTWSP
//					ArrTime = cStartS + problem->disCWSSP[curC][endSP];
//					temp = ArrTime - problem->nodeSP[endSP].eTW2;
//					if (temp > eps) return 0; //after insert: go to SP directly too soon, go through WS too late
//					changeWSORGoWS = 0;
//					//cout<<"idCusD = "<<idCusD<<"; LastCus of C2C NOT changed("<<curC<<"); before and after through WS"<<endl;
//					return 1; //after insert, still go through WS
//				}
//			}
//
//		}
//		else //lastCus has changed
//		{
//			ArrTime = cStartS + problem->c[curC][endSP];
//			if (PDSINRANGE(ArrTime, problem->nodeSP[endSP].sTW2, problem->nodeSP[endSP].eTW2))
//			{
//				if (seg[idVeh].Trip[idTrip].waitingS != NO_WS) 
//				{
//					//cout<<"idCusD = "<<idCusD<<"; LastCus of C2C has changed("<<lastC2C<<"-->"<<curC<<"), now go directly to sp, before through WS: ArrTimeNew = "<<ArrTime<<";[sTW2,eTW2] = ["<<problem->nodeSP[endSP].sTW2<<", "<<problem->nodeSP[endSP].eTW2<<"]"<<endl;
//					costT += (problem->c[curC][endSP] - problem->disCWSSP[lastC2C][endSP]);
//				}
//				else
//				{
//					//cout<<"idCusD = "<<idCusD<<"; LastCus of C2C has changed("<<lastC2C<<"-->"<<curC<<"), now and before go directly to sp: ArrTimeNew = "<<ArrTime<<";[sTW2,eTW2] = ["<<problem->nodeSP[endSP].sTW2<<", "<<problem->nodeSP[endSP].eTW2<<"]"<<endl;
//					costT += (problem->c[curC][endSP] - problem->c[lastC2C][endSP]);
//				}
//				changeWSORGoWS = 0;
//				return 1;
//			}
//			else
//			{
//				temp = ArrTime - problem->nodeSP[endSP].eTW2;
//				if (temp > eps) return 0;
//				ArrTime = cStartS + problem->disCWSSP[curC][endSP];
//			    temp = ArrTime - problem->nodeSP[endSP].eTW2;
//				if (temp > eps) return 0;
//				if (seg[idVeh].Trip[idTrip].waitingS != NO_WS) 
//				{
//					//cout<<"idCusD = "<<idCusD<<"; LastCus of C2C has changed("<<lastC2C<<"-->"<<curC<<"), now and before through WS:  ArrTimeNew = "<<ArrTime<<";[sTW2,eTW2] = ["<<problem->nodeSP[endSP].sTW2<<", "<<problem->nodeSP[endSP].eTW2<<"]"<<endl;
//					costT += (problem->disCWSSP[curC][endSP] - problem->disCWSSP[lastC2C][endSP]);
//				}
//				else
//				{
//					//cout<<"idCusD = "<<idCusD<<"; LastCus of C2C has changed("<<lastC2C<<"-->"<<curC<<"), now through WS, before go directly to sp ArrTimeNew = "<<ArrTime<<";[sTW2,eTW2] = ["<<problem->nodeSP[endSP].sTW2<<", "<<problem->nodeSP[endSP].eTW2<<"]"<<endl;
//					costT += (problem->disCWSSP[curC][endSP] - problem->c[lastC2C][endSP]);
//				}
//				changeWSORGoWS = 1;
//				return 1;
//			}
//		}//end lastCus has changed
//}
//
//
//
//
//bool Solution::checkC2CAndPTripFeasibleCostChange_AfterInsertC2C_Temp(int curC, double departTime_curC, int nextC, double &costT, int idVeh, int idTrip, bool &changed_idTrip)
//{
//	//Update 10/11/2013: check TW at all customers of TRip C2C starting from curC with departureTime and then all customers of next Ptrip(idVeh,idTrip)
//	//if feasible return 1; otherwise return 0
//	//and calculate the change in cost due to connect to SP of PTrip
//
//	costT = 0;
//	double cStartS, ArrTime, temp;
//	cStartS = departTime_curC;
//	while (nextC > 0)
//	{
//		ArrTime = cStartS + problem->c[curC][nextC];
//		cStartS = PDS_MAX(ArrTime, problem->node[nextC].sTW);
//		temp = cStartS - problem->node[nextC].eTW;
//		if (temp > eps) return 0;
//		cStartS += problem->node[nextC].duration;
//		curC = nextC; nextC = nextArrTemp[curC];
//	}
//	//curC now points to the last customer of trip C2C, now continue checking PTrip
//    nextC = seg[idVeh].Trip[idTrip].firstCus;
//	while (nextC > 0)
//	{
//		ArrTime = cStartS + problem->c[curC][nextC];
//		cStartS = PDS_MAX(ArrTime, problem->node[nextC].sTW);
//		if (PDSDIF(cStartS, startS[nextC])==0) return 1;
//		temp = cStartS - problem->node[nextC].eTW;
//		if (temp > eps) return 0;
//		cStartS += problem->node[nextC].duration;
//		curC = nextC; nextC = nextArrTemp[curC];
//	}
//
//	//curC now points to the last customers of PTrip
//	int assSP = seg[idVeh].Trip[idTrip].assSP;
//	if (seg[idVeh].Trip[idTrip].waitingS == NO_WS)
//	{
//		//before insert go directly to sp --> after insert still the same
//		ArrTime = cStartS + problem->c[curC][assSP];
//		if (PDSINRANGE(ArrTime, problem->nodeSP[assSP].sTW1, problem->nodeSP[assSP].eTW1)) return 1;
//		return 0;
//	}
//	else
//	{
//		//Before insert, vehicle go to sp through WS:
//		ArrTime = cStartS + problem->c[curC][assSP];
//		if (PDSINRANGE(ArrTime, problem->nodeSP[assSP].sTW1, problem->nodeSP[assSP].eTW1))
//		{
//			costT += (problem->c[curC][assSP] - problem->disCWSSP[curC][assSP]); //after insert go to SP directly
//			changed_idTrip = 1;
//			return 1;
//		}
//		else
//		{
//			temp = ArrTime - problem->nodeSP[assSP].eTW1;
//			if (temp > eps) return 0; //now vioTWSP
//			ArrTime = cStartS + problem->disCWSSP[curC][assSP];
//			temp = ArrTime - problem->nodeSP[assSP].eTW1;
//			if (temp > eps) return 0; //after insert: go to SP directly too soon, go through WS too late
//			return 1; //after insert, still go through WS
//		}
//	}
//}
//
//
//
//bool Solution::checkTripTWC2C_Temp(int curC, double departTime, int nextC, int pos_nextC, double *departTemp)
//{
//	double cStartS = departTime;
//	double temp, ArrTime;
//	while (nextC > 0)
//	{
//		ArrTime = cStartS + problem->c[curC][nextC];
//		temp = ArrTime - problem->node[nextC].eTW;
//		if (temp > eps) return 0;
//		cStartS = PDS_MAX(ArrTime, problem->node[nextC].sTW) + problem->node[nextC].duration;
//		departTemp[pos_nextC] = cStartS; pos_nextC++;
//		curC = nextC; nextC = nextArrTemp[nextC];
//	}
//	return 1;
//}
//
//bool Solution::checkC2C_P_FeasibleTrip_InitSol(int idVeh, int idTrip, int preC, double depart_preC, int nextT) //just checking feasible trip
//{
//	//Check startS, depart, feasibility of capacity, cost, pos
//	int curC = seg[idVeh].Trip[idTrip].firstCus;
//	double costT = 0;
//	if (preC == 0) costT = problem->c[0][curC];
//	int FCAPT = 0;
//
//	double ArrTime = depart_preC + problem->c[preC][curC];
//	double temp = ArrTime - problem->node[curC].eTW;
//	if (temp > eps) {cout<<"ERROR checkC2C_P_FeasibleTrip_InitSol: vioTW at first cus "<<curC<<endl; return 0;}
//	ArrTime = PDS_MAX(ArrTime, problem->node[curC].sTW);
//	if (PDSDIF(ArrTime, startS[curC])) {cout<<"ERROR checkC2C_P_FeasibleTrip_InitSol: tinh sai startS of cus "<<curC<<": correct = "<<ArrTime<<"; wrong = "<<startS[curC]<<endl; return 0;}
//	ArrTime += problem->node[curC].duration;
//	if (PDSDIF(ArrTime, depart[curC])) {cout<<"ERROR checkC2C_P_FeasibleTrip_InitSol: tinh sai depart of cus "<<curC<<": correct = "<<ArrTime<<"; wrong = "<<depart[curC]<<endl; return 0;}
//	FCAPT += problem->node[curC].capacity;
//	if (FCAPT != FCAP[curC]) {cout<<"ERROR checkC2C_P_FeasibleTrip_InitSol: tinh sai FCAP at cus "<<curC<<": correct = "<<FCAPT<<"; field FCAP = "<<FCAP[curC]<<endl; return 0;}
//    if (pos[curC] != 1) {cout<<"ERROR checkC2C_P_FeasibleTrip_InitSol: tinh sai pos at cus "<<curC<<"wrong = "<<pos[curC]<<"; correct = 1"<<endl; return 0;}    
//	//double cStartS = ArrTime;
//	preC = curC; curC = nextArr[curC];
//	int curPos = 1;
//	while (curC > 0)
//	{
//		ArrTime += problem->c[preC][curC];
//		temp = ArrTime - problem->node[curC].eTW;
//		if (temp > eps) {cout<<"ERROR checkC2C_P_FeasibleTrip_InitSol: vioTW at cus "<<curC<<endl; return 0;}
//		ArrTime = PDS_MAX(ArrTime, problem->node[curC].sTW);
//		if (PDSDIF(ArrTime, startS[curC])) {cout<<"ERROR checkC2C_P_FeasibleTrip_InitSol: tinh sai startS of cus "<<curC<<": correct = "<<ArrTime<<"; wrong = "<<startS[curC]<<endl; return 0;}
//		ArrTime += problem->node[curC].duration;
//		if (PDSDIF(ArrTime, depart[curC])) {cout<<"ERROR checkC2C_P_FeasibleTrip_InitSol: tinh sai depart of cus "<<curC<<": correct = "<<ArrTime<<"; wrong = "<<depart[curC]<<endl; return 0;}
//        costT += problem->c[preC][curC];
//		FCAPT += problem->node[curC].capacity;
//		if (FCAPT > problem->Q) {cout<<"ERROR checkC2C_P_FeasibleTrip_InitSol: Exceed capacity at cus "<<curC<<endl; return 0;}
//		if (FCAPT != FCAP[curC]) {cout<<"ERROR checkC2C_P_FeasibleTrip_InitSol: tinh sai FCAP at cus "<<curC<<endl; return 0;}
//		curPos ++;
//		if (pos[curC] != curPos)
//		{  cout<<"ERROR checkC2C_P_FeasibleTrip_InitSol: tinh sai pos at cus "<<curC<<": correct = "<<pos[curC]<<"; wrong = "<<curPos<<endl; return 0;}
//		preC = curC; curC = nextArr[curC];
//	}
//	//preC now points to the last cus:
//	if (nextT > -1) //not the last trip yet
//	{
//		if (seg[idVeh].Trip[nextT].Type == 1)
//		{
//			int assSP = seg[idVeh].Trip[nextT].assSP;
//			ArrTime = depart[preC] + problem->c[preC][assSP];
//			if (PDSINRANGE(ArrTime, problem->nodeSP[assSP].sTW2, problem->nodeSP[assSP].eTW2))
//				costT += problem->c[preC][assSP];
//			else
//			{
//				temp = depart[preC] - problem->nodeSP[assSP].eTW2;
//				if (temp > eps) return 0; //vioTW at SP of DTrip(idVeh, nextT)
//				ArrTime = depart[preC] + problem->disCWSSP[preC][assSP];
//				temp =  ArrTime -  problem->nodeSP[assSP].eTW2;
//				if (temp > eps) return 0;
//				costT += problem->disCWSSP[preC][assSP];
//			}
//		}
//		else if (seg[idVeh].Trip[nextT].Type == 0)
//		{
//			costT += problem->c[preC][seg[idVeh].Trip[nextT].firstCus];
//		}
//	}
//	return 1;
//}
//
//
//bool Solution::checkC2C_P_FeasibleTrip_InitSol_Temp(int idVeh, int idTrip, int preC, double depart_preC, int nextT) //just checking feasible trip
//{
//	//Check startS, depart, feasibility of capacity, cost, pos
//	int curC = seg[idVeh].Trip[idTrip].firstCus;
//	double costT = 0;
//	if (preC == 0) costT = problem->c[0][curC]; 
//	int FCAPT = 0;
//
//	double ArrTime = depart_preC + problem->c[preC][curC];
//	double temp = ArrTime - problem->node[curC].eTW;
//	if (temp > eps) {cout<<"ERROR checkC2C_P_FeasibleTrip_InitSol_Temp: vioTW at first cus "<<curC<<endl; return 0;}
//	ArrTime = PDS_MAX(ArrTime, problem->node[curC].sTW);
//	if (PDSDIF(ArrTime, startS[curC])) {cout<<"ERROR checkC2C_P_FeasibleTrip_InitSol_Temp: tinh sai startS of firstcusP "<<curC<<": correct = "<<ArrTime<<"; wrong = "<<startS[curC]<<endl; return 0;}
//	ArrTime += problem->node[curC].duration;
//	if (PDSDIF(ArrTime, depart[curC])) {cout<<"ERROR checkC2C_P_FeasibleTrip_InitSol_Temp: tinh sai depart of firstcusP "<<curC<<": correct = "<<ArrTime<<"; wrong = "<<depart[curC]<<endl; return 0;}
//	FCAPT += problem->node[curC].capacity;
//	if (FCAPT != FCAP[curC]) {cout<<"ERROR checkC2C_P_FeasibleTrip_InitSol_Temp: tinh sai FCAP at cus "<<curC<<endl; return 0;}
//    if (pos[curC] != 1) {cout<<"ERROR checkC2C_P_FeasibleTrip_InitSol_Temp: tinh sai pos at cus "<<curC<<"wrong = "<<pos[curC]<<"; correct = 1"<<endl; return 0;}    
//	//double cStartS = ArrTime;
//	preC = curC; curC = nextArrTemp[curC];
//	int curPos = 1;
//	while (curC > 0)
//	{
//		ArrTime += problem->c[preC][curC];
//		temp = ArrTime - problem->node[curC].eTW;
//		if (temp > eps) {cout<<"ERROR checkC2C_P_FeasibleTrip_InitSol_Temp: vioTW at cus "<<curC<<endl; return 0;}
//		ArrTime = PDS_MAX(ArrTime, problem->node[curC].sTW);
//		if (PDSDIF(ArrTime, startS[curC])) 
//		{
//			cout<<"ERROR checkC2C_P_FeasibleTrip_InitSol_Temp: tinh sai startS of cus "<<curC<<": correct = "<<ArrTime<<"; wrong = "<<startS[curC]<<endl; 
//			cout<<"depart[preC="<<preC<<"]= "<<depart[preC]<<endl;
//			return 0;
//		}
//		ArrTime += problem->node[curC].duration;
//		if (PDSDIF(ArrTime, depart[curC])) {cout<<"ERROR checkC2C_P_FeasibleTrip_InitSol_Temp: tinh sai depart of cus "<<curC<<": correct = "<<ArrTime<<"; wrong = "<<depart[curC]<<endl; return 0;}
//        costT += problem->c[preC][curC];
//		FCAPT += problem->node[curC].capacity;
//		if (FCAPT > problem->Q) {cout<<"ERROR checkC2C_P_FeasibleTrip_InitSol_Temp: Exceed capacity at cus "<<curC<<endl; return 0;}
//		if (FCAPT != FCAP[curC]) {cout<<"ERROR checkC2C_P_FeasibleTrip_InitSol_Temp: tinh sai FCAP at cus "<<curC<<endl; return 0;}
//		curPos ++;
//		if (pos[curC] != curPos)
//		{  cout<<"ERROR checkC2C_P_FeasibleTrip_InitSol: tinh sai pos at cus "<<curC<<": correct = "<<pos[curC]<<"; wrong = "<<curPos<<endl; return 0;}
//		preC = curC; curC = nextArrTemp[curC];
//	}
//	//preC now points to the last cus:
//	if (nextT > -1) //not the last trip yet
//	{
//		if (seg[idVeh].Trip[nextT].Type == 1)
//		{
//			int assSP = seg[idVeh].Trip[nextT].assSP;
//			ArrTime = depart[preC] + problem->c[preC][assSP];
//			if (PDSINRANGE(ArrTime, problem->nodeSP[assSP].sTW2, problem->nodeSP[assSP].eTW2))
//				costT += problem->c[preC][assSP];
//			else
//			{
//				temp = depart[preC] - problem->nodeSP[assSP].eTW2;
//				if (temp > eps) return 0; //vioTW at SP of DTrip(idVeh, nextT)
//				ArrTime = depart[preC] + problem->disCWSSP[preC][assSP];
//				temp =  ArrTime -  problem->nodeSP[assSP].eTW2;
//				if (temp > eps) return 0;
//				costT += problem->disCWSSP[preC][assSP];
//			}
//		}
//		else if (seg[idVeh].Trip[nextT].Type == 0)
//		{
//			costT += problem->c[preC][seg[idVeh].Trip[nextT].firstCus];
//		}
//	}
//	return 1;
//}
//
//
//
//bool Solution::checkC2C_FeasibleTrip_InitSol_Temp(int idVeh, int idTrip, int preC, double depart_preC, bool Add, int endSP) //just checking feasible trip
//{
//	//Check startS, depart, feasibility of capacity, cost, pos
//	int curC = seg[idVeh].Trip[idTrip].firstCus;
//	double costT = 0;
//	if (Add || preC == 0) costT += problem->c[preC][curC];
//	int FCAPT = 0;
//	//cout<<costT<<"("<<curC<<"); ";
//
//	double ArrTime = depart_preC + problem->c[preC][curC];
//	double temp = ArrTime - problem->node[curC].eTW;
//	if (temp > eps) {cout<<"ERROR checkC2CFeasibleTrip_InitSol_Temp: vioTW at first cus "<<curC<<endl; return 0;}
//	ArrTime = PDS_MAX(ArrTime, problem->node[curC].sTW);
//	if (PDSDIF(ArrTime, startS[curC])) {cout<<"ERROR checkC2CFeasibleTrip_InitSol_Temp: tinh sai startS of cus "<<curC<<": correct = "<<ArrTime<<"; wrong = "<<startS[curC]<<endl; return 0;}
//	ArrTime += problem->node[curC].duration;
//	if (PDSDIF(ArrTime, depart[curC])) {cout<<"ERROR checkC2CFeasibleTrip_InitSol_Temp: tinh sai depart of cus "<<curC<<": correct = "<<ArrTime<<"; wrong = "<<depart[curC]<<endl; return 0;}
//	FCAPT += problem->node[curC].capacity;
//	if (FCAPT != FCAP[curC]) {cout<<"ERROR checkC2CFeasibleTrip_InitSol_Temp: tinh sai FCAP at cus "<<curC<<endl; return 0;}
//    if (pos[curC] != 1) {cout<<"ERROR checkC2CFeasibleTrip_InitSol_Temp: tinh sai pos at cus "<<curC<<"wrong = "<<pos[curC]<<"; correct = 1"<<endl; return 0;}    
//	//double cStartS = ArrTime;
//
//	int nextC = nextArrTemp[curC];
//	int curPos = 1;
//	while (nextC > 0)
//	{
//		ArrTime += problem->c[curC][nextC];
//		temp = ArrTime - problem->node[nextC].eTW;
//		if (temp > eps) {cout<<"ERROR checkC2CFeasibleTrip_InitSol_Temp: vioTW at cus "<<nextC<<endl; return 0;}
//		ArrTime = PDS_MAX(ArrTime, problem->node[nextC].sTW);
//		if (PDSDIF(ArrTime, startS[nextC])) {cout<<"ERROR checkC2CFeasibleTrip_InitSol_Temp: tinh sai startS of cus "<<nextC<<": correct = "<<ArrTime<<"; wrong = "<<startS[nextC]<<endl; return 0;}
//		ArrTime += problem->node[nextC].duration;
//		if (PDSDIF(ArrTime, depart[nextC])) {cout<<"ERROR checkC2CFeasibleTrip_InitSol_Temp: tinh sai depart of cus "<<nextC<<": correct = "<<ArrTime<<"; wrong = "<<depart[nextC]<<endl; return 0;}
//        costT += problem->c[curC][nextC];
//		//cout<<costT<<"("<<nextC<<"); ";
//		FCAPT += problem->node[nextC].capacity;
//		if (FCAPT > problem->Q) {cout<<"ERROR checkC2CFeasibleTrip_InitSol_Temp: Exceed capacity at cus "<<nextC<<endl; return 0;}
//		if (FCAPT != FCAP[nextC]) {cout<<"ERROR checkC2CFeasibleTrip_InitSol_Temp: tinh sai FCAP at cus "<<nextC<<endl; return 0;}
//		curPos ++;
//		if (pos[nextC] != curPos)
//		{  cout<<"ERROR checkC2CFeasibleTrip_InitSol_Temp: tinh sai pos at cus "<<nextC<<": correct = "<<pos[nextC]<<"; wrong = "<<curPos<<endl; return 0;}
//		curC = nextC; nextC = nextArrTemp[curC];
//	}
//
//	//curC now points to the last cus of C2C:
//	if (endSP == 0)
//	{
//		costT += problem->c[curC][0];
//		//cout<<costT<<endl;
//		if (PDSDIF(costT, seg[idVeh].Trip[idTrip].cost)) 
//		{
//			cout<<"ERROR checkC2CFeasibleTrip_InitSol_Temp: tinh sai cost of last C2Ctrip: correct = "<<costT<<"; wrong = "<<seg[idVeh].Trip[idTrip].cost<<endl; 
//			return 0;
//		}
//	}
//	else
//	{
//		double cStartS;
//		cStartS = ArrTime + problem->c[curC][endSP];
//		if (PDSINRANGE(cStartS,problem->nodeSP[endSP].sTW2, problem->nodeSP[endSP].eTW2)) 
//		{
//			costT += problem->c[curC][endSP];
//			//cout<<costT<<endl;
//			if (PDSDIF(costT, seg[idVeh].Trip[idTrip].cost)) 
//			{
//				cout<<"ERROR checkC2CFeasibleTrip_InitSol_Temp: tinh sai cost of notlast C2Ctrip(case directly to SP): correct = "<<costT<<"; wrong = "<<seg[idVeh].Trip[idTrip].cost<<"; field WS = "<<seg[idVeh].Trip[idTrip].waitingS<<"; lastCNEW = "<<curC<<"; endSP = "<<endSP<<endl; 
//				return 0;
//			}
//		}
//		else
//		{
//			double temp = cStartS - problem->nodeSP[endSP].eTW2;
//			if (temp > eps)
//			{
//				cout<<"ERROR checkC2CFeasibleTrip_InitSol_Temp: vioTWSP(case directly to SP): arr = "<<temp<<"; eTW2 of SP = "<<problem->nodeSP[endSP].eTW2<<endl; 
//				return 0;
//			}
//			cStartS = ArrTime + problem->disCWSSP[curC][endSP];
//			temp = cStartS - problem->nodeSP[endSP].eTW2;
//			if (temp > eps)
//			{
//				cout<<"ERROR checkC2CFeasibleTrip_InitSol_Temp: vioTWSP(case through WS): arr = "<<temp<<"; eTW2 of SP = "<<problem->nodeSP[endSP].eTW2<<endl; 
//				return 0;
//			}
//			costT += problem->disCWSSP[curC][endSP];
//			//cout<<costT<<endl;
//			if (PDSDIF(costT, seg[idVeh].Trip[idTrip].cost)) 
//			{
//				cout<<"ERROR checkC2CFeasibleTrip_InitSol_Temp: tinh sai cost of NOTlast C2Ctrip(case through WS): correct = "<<costT<<"; wrong = "<<seg[idVeh].Trip[idTrip].cost<<"; field WS = "<<seg[idVeh].Trip[idTrip].waitingS<<endl; 
//				return 0;
//			}
//		}
//	}
//
//	return 1;
//}
//
//
//
//bool Solution::checkFeasible_ConnectC2CDToSP(int curC, double depart_curC, double &costT, int endSP, bool &goWS)
//{
//	//Check if feasible TW at endSP
//	double ArrTime, temp;
//	ArrTime = depart_curC + problem->c[curC][endSP];
//	temp = ArrTime - problem->nodeSP[endSP].eTW2;
//	if (temp > eps) return 0;
//	if (PDSINRANGE(ArrTime, problem->nodeSP[endSP].sTW2, problem->nodeSP[endSP].eTW2)) 
//	{
//		costT += problem->c[curC][endSP];
//		goWS = 0;
//		return 1;
//	}
//	ArrTime = depart_curC + problem->disCWSSP[curC][endSP];
//	temp = ArrTime - problem->nodeSP[endSP].eTW2;
//	if (temp > eps) return 0;
//	costT += problem->disCWSSP[curC][endSP]; goWS = 1;
//	return 1;
//}
//
//bool Solution::checkCapacity_C2CTrip_InitSol_Temp(int fromC, int tillC, int CAPINS)
//{
//	int nextC = fromC;
//	while (nextC != tillC)
//	{
//		CAPINS += problem->node[nextC].capacity;
//		if (CAPINS > problem->Q) return 0;
//		nextC = nextArrTemp[nextC];
//	}
//	CAPINS += problem->node[tillC].capacity;
//	if (CAPINS > problem->Q) return 0;
//	return 1;
//
//}
//
//bool Solution::checkCapacity_C2CTrip_InitSol(int fromC, int tillC, int CAPINS)
//{
//	int nextC = fromC;
//	while (nextC != tillC)
//	{
//		CAPINS += problem->node[nextC].capacity;
//		if (CAPINS > problem->Q) return 0;
//		nextC = nextArr[nextC];
//	}
//	CAPINS += problem->node[tillC].capacity;
//	if (CAPINS > problem->Q) return 0;
//	return 1;
//
//}
//
//void Solution::CreateVehicle_C2COnly()
//{
//	//Create vehicle with only C2C:
//	int idCusP = startidC2C; int idCusD;
//	double costMINI = PDS_INFINITY; int seed = -1;
//	double costC2C;
//
//	//1. Insert first C2C into the vehicle:
//	for (idCusP = startidC2C; idCusP <= endidC2CP; idCusP++)
//	{
//		if (routed[idCusP] == 0)
//		{
//			 idCusD = problem->node[idCusP].delID;
//			 costC2C = problem->c[0][idCusP] + problem->c[idCusP][idCusD] + problem->c[idCusD][0];
//			 //cout<<"cost to route C2C("<<idCusP<<", "<<idCusD<<") = "<<costC2C<<" = "<<problem->c[0][idCusP]<<" + "<<problem->c[idCusP][idCusD]<<" + "<<problem->c[idCusD][0]<<endl;
//			 if (costC2C < costMINI)
//			 {
//				 seed = idCusP;
//				 costMINI = costC2C;
//			 }
//		}//else idCusP already routed
//	}//end for idCusP
//	if (seed == -1)
//	{
//		cout<<"ERROR why there is still unrouted C2C, but can't routed them"<<endl;
//		cout<<"List C2CP not routed yet: "<<endl;
//		for (idCusP = startidC2C; idCusP <= endidC2CP; idCusP++)
//			if (routed[idCusP] == 0) cout<<idCusP<<"; ";
//		cout<<endl;
//
//		cout<<"List C2CD not routed yet: "<<endl;
//		for (idCusP = startidC2CD; idCusP <= endidC2C; idCusP++)
//			if (routed[idCusP] == 0) cout<<idCusP<<"; ";
//		cout<<endl;
//		cout<<"startidC2C = "<<startidC2C<<"; endidC2CP = "<<endidC2CP<<endl;
//		exit(-1);
//	}
//
//	seg[numVeh].numTrips = 1;
//
//	 //cout<<"Create a vehicle "<<numVeh<<" with only C2C: ";
//	 idCusD = problem->node[seed].delID;
//	 routed[seed]=1; routed[idCusD] = 1;
//	 seg[numVeh].Trip[0].Type = 2;
//	 seg[numVeh].Trip[0].firstCus = seed;
//	 seg[numVeh].Trip[0].lastCus = idCusD;
//	 seg[numVeh].Trip[0].cost = costMINI;
//	 seg[numVeh].Trip[0].connectCost = problem->c[idCusD][0];
//
//	 startS[seed] = problem->node[seed].startS_depot;
//	 depart[seed] = problem->node[seed].depart_depot;
//     startS[idCusD] = PDS_MAX(depart[seed] + problem->c[seed][idCusD], problem->node[idCusD].sTW);
//	 depart[idCusD] = startS[idCusD] + problem->node[idCusD].duration;
//	 seg[numVeh].Trip[0].numCus = 2;
//	 seg[numVeh].Trip[0].feasible = 1;
//	 seg[numVeh].Trip[0].endS = depart[idCusD];
//	 numCusC2CRouted += 2;
//	 nextArr[seed] = idCusD; nextArr[idCusD] = 0;
//	 pos[seed] = 1; pos[idCusD] = 2;
//	 FCAP[seed] = problem->node[seed].capacity;
//	 FCAP[idCusD] = 0;
//	 //cout<<"("<<seed<<"="<<problem->node[seed].id<<", "<<idCusD<<"="<<problem->node[idCusD].id<<"); dis = "<<problem->c[seed][idCusD]<<endl;
//	 //cout<<"C2CP: ("<<startS[seed]<<", "<<depart[seed]<<"); C2CD: ("<<startS[idCusD]<<", "<<depart[idCusD]<<")"<<endl;
//
//	 //Now trying to insert more C2C to trip(idVeh,idTrip):
//     if (numCusC2CRouted < problem->nC2C)
//	 {
//		 double depart_idCusP, costT, ArrTime, temp, cStartS;
//		 int i,j, firstC_C2C, idCus, insert_afterP, insert_afterD, curC, nextC, preINS, nextINS, IDinsert, FCAPT;
//		 double *departTemp = new double[250];
//		 bool cont = 1; bool ok;
//		 do //each loop insert a pair of C2C
//		 {
//			 IDinsert = -1; costMINI = PDS_INFINITY;
//			 firstC_C2C = seg[numVeh].Trip[0].firstCus;
//			 for (idCusP = startidC2C; idCusP <= endidC2CP; idCusP ++)
//			 {
//				 if (routed[idCusP] == 0)
//				 {
//					 idCusD = problem->node[idCusP].delID;
//					 //1. First try to insert at the beginning of the trip:
//					 nextINS = firstC_C2C;
//					 FCAPT = problem->node[idCusP].capacity;
//					 ok = 1;
//					 costT = problem->c[0][idCusP] + problem->c[idCusP][firstC_C2C] - problem->c[0][firstC_C2C];
//					 //Insert idCusP at the beginning of the trip, now find place to insert idCusD
//					 depart_idCusP = PDS_MAX(problem->c[0][idCusP], problem->node[idCusP].sTW) + problem->node[idCusP].duration;
//					 //1.1 Insert idCusD right after idCusP: then capacity of vehicle is ok since already ok when inserting idCusP
// 					 ArrTime = PDS_MAX(depart_idCusP + problem->c[idCusP][idCusD], problem->node[idCusD].sTW) + problem->node[idCusD].duration + problem->c[idCusD][nextINS];
//					 temp = problem->node[nextINS].eTW - ArrTime;
//					 if (temp > 0) 
//					 {
//							 ArrTime = PDS_MAX(ArrTime, problem->node[nextINS].sTW) + problem->node[nextINS].duration;
//							 curC = nextINS; nextC = nextArr[nextINS];
//							 while (nextC > 0)
//							 {
//								 ArrTime += problem->c[curC][nextC];
//								 temp = ArrTime - problem->node[nextC].eTW;
//								 if (temp > eps) {ok = 0; break;} //vioTW at nextC
//								 else
//								 {
//									 ArrTime = PDS_MAX(ArrTime, problem->node[nextC].sTW) + problem->node[nextC].duration;
//									 curC = nextC; nextC = nextArr[curC];
//								 }
//							 }
//							 if (ok) //curC is now pointed to lastC
//							 {
//								 costC2C = costT + problem->c[idCusP][idCusD] + problem->c[idCusD][nextINS] - problem->c[idCusP][nextINS];
//								 if (costC2C < costMINI)
//								 {
//									 costMINI = costC2C;
//									 IDinsert = idCusP;
//									 insert_afterP = 0;
//									 insert_afterD = idCusP;
//								 }
//							 }//end if (ok)
//						 }//else vioTW at cus nextINS
//						 
//						 //1.2 Find place to insert idCusD from position after nextINS assuming that idCusP is inserted at the beginning of the trip:
//                          ok = checkC2CVehicleFeasible(idCusP,depart_idCusP,firstC_C2C,1,departTemp);
//						  if (ok) //TW is ok for all C2C customers after inserting idCusP
//						  {
//							 int i = 1; curC = firstC_C2C;
//							 while (i <= seg[numVeh].Trip[0].numCus) //insert idCusD after curC at position i of idTrip
//							 {
//								 //1.2 Insert idCusD right after place i
//								 if (curC < startidC2CD) //curC is a C2CP
//								 {
//									 curC = problem->node[curC].delID;
//									 i = pos[curC];
//								 }
//								 else //curC is a C2CD:
//								 {
//									 idCus = problem->node[curC].pickID;
//									 if (pos[idCus] > 0)
//									 {
//										 //Insert idCusD after curC: check capacity and vioTW
//										 ok = checkCapacity_C2CTrip_InitSol(firstC_C2C, curC,FCAPT);
//										 if (ok)
//										 {
//											 ArrTime = departTemp[i] + problem->c[curC][idCusD];
//											 temp = problem->node[idCusD].eTW - ArrTime;
//											 if (temp > eps)
//											 {
//												 ArrTime = PDS_MAX(ArrTime, problem->node[idCusD].sTW) + problem->node[idCusD].duration;
//												 nextC = nextArr[curC]; //nextC = 0--> depot
//												 //need to check from nextC till the depot:
//												 ok = 1;
//												 if (nextC > 0)
//												 {
//                                                   int curC1 = idCusD; int nextC1 = nextC;
//												   while (nextC1 > 0)
//												   {
//															 ArrTime = PDS_MAX(ArrTime + problem->c[curC1][nextC1],problem->node[nextC1].sTW);
//															 if (PDSDIF(ArrTime, startS[nextC1])==0) break;
//															 temp = ArrTime - problem->node[nextC1].eTW;
//															 if (temp > eps) {ok = 0; break;} //vioTW at nextC1
//															 ArrTime += problem->node[nextC1].duration;
//															 curC1 = nextC1; nextC1 = nextArr[curC1];
//													}
//												 }
//												 if (ok)
//												 {
//													 costC2C = costT + (problem->c[curC][idCusD] + problem->c[idCusD][nextC] - problem->c[curC][nextC]);
//													 if (costC2C < costMINI)
//													 {	
//														 costMINI = costC2C;
//														 IDinsert = idCusP;
//														 insert_afterP = 0;
//														 insert_afterD = curC;
//													 }
//												 }
//											 }
//										 }//else not ok capacity of vehicle
//										 i ++; curC = nextArr[curC];
//									 }
//									 else break;
//								 }
//							 }
//						  }
//					 //2. Insert idCusP in the middle of the trip
//					 preINS = firstC_C2C;
//					 nextINS = nextArr[preINS];
//                     for (j=1;j<seg[numVeh].Trip[0].numCus;j++) //insert idCusP between preINS and nextINS
//					 {
//						 FCAPT = FCAP[preINS] + problem->node[idCusP].capacity;
//						 if (FCAPT <= problem->Q)
//						 {
//	 						costT = problem->c[preINS][idCusP] + problem->c[idCusP][nextINS] - problem->c[preINS][nextINS];
//							cStartS = depart[preINS] + problem->c[preINS][idCusP];
//							temp = problem->node[idCusP].eTW - cStartS;
//							if (temp > eps)
//							{
//								 depart_idCusP = PDS_MAX(cStartS, problem->node[idCusP].sTW) + problem->node[idCusP].duration;
//								 //2.1 Insert idCusD right after idCusP: don't need to check capacity of vehicle
// 								 ArrTime = PDS_MAX(depart_idCusP + problem->c[idCusP][idCusD], problem->node[idCusD].sTW) + problem->node[idCusD].duration + problem->c[idCusD][nextINS];
//								 temp = problem->node[nextINS].eTW - ArrTime;
//								 if (temp > 0) 
//								 {
//									 ArrTime = PDS_MAX(ArrTime, problem->node[nextINS].sTW) + problem->node[nextINS].duration;
//									 curC = nextINS; nextC = nextArr[nextINS];
//									 ok = 1;
//									 while (nextC > 0)
//									 {
//										 ArrTime += problem->c[curC][nextC];
//										 temp = ArrTime - problem->node[nextC].eTW;
//										 if (temp > eps) {ok = 0; break;} //vioTW at nextC
//										 else
//										 {
//											 ArrTime = PDS_MAX(ArrTime, problem->node[nextC].sTW) + problem->node[nextC].duration;
//											 curC = nextC; nextC = nextArr[curC];
//										 }
//									 }
//									 if (ok) //curC is now pointed to lastC
//									 {
//										 costC2C = costT + problem->c[idCusP][idCusD] + problem->c[idCusD][nextINS] - problem->c[idCusP][nextINS];
//										 if (costC2C < costMINI)
//										 {
//										     costMINI = costC2C;
//											 IDinsert = idCusP;
//											 insert_afterP = preINS;
//											 insert_afterD = idCusP;
//										 }
//									 }//end if (ok)
//								 }//else vioTW at cus nextINS
//		 						 //2.2 Find place to insert idCusD from position after nextINS assuming that idCusP is inserted between preINS and nextINS:
//          						 ok = checkC2CVehicleFeasible(idCusP,depart_idCusP,nextINS,j+1,departTemp);
//								 if (ok) //TW is ok for all C2C customers after inserting idCusP between preINS and nextINS
//								 {
//									 i = j + 1; curC = nextINS;
//									 while (i <= seg[numVeh].Trip[0].numCus) //insert idCusD after curC at position i of idTrip
//									 {
//										 //2.2 Insert idCusD right after place i:
//										 if (curC < startidC2CD) //curC is a C2CP
//										 {
//											 curC = problem->node[curC].delID;
//											 i = pos[curC];
//										 }
//										 else //curC is a C2CD
//										 {
//                                              idCus = problem->node[curC].pickID;
//											  if (pos[idCus] > j)
//											  {
//												  //Insert idCusD after curC: check capacity of vehicle and vioTW
//												  ok = checkCapacity_C2CTrip_InitSol(nextINS,curC, FCAPT);
//												  if (ok)
//												  {
//													  ArrTime = departTemp[i] + problem->c[curC][idCusD];
//													  temp = problem->node[idCusD].eTW - ArrTime;
//													  if (temp > eps)
//													  {
//															 ArrTime = PDS_MAX(ArrTime, problem->node[idCusD].sTW) + problem->node[idCusD].duration;
//															 nextC = nextArr[curC]; int curC1 = idCusD; int nextC1 = nextC;
//															 while (nextC1 > 0)
//															 {
//																 ArrTime = PDS_MAX(ArrTime + problem->c[curC1][nextC1],problem->node[nextC1].sTW);
//																 if (PDSDIF(ArrTime, startS[nextC1])==0) break;
//																 temp = ArrTime - problem->node[nextC1].eTW;
//																 if (temp > eps) {ok = 0; break;} //vioTW at nextC1
//																 ArrTime += problem->node[nextC1].duration;
//																 curC1 = nextC1; nextC1 = nextArr[curC1];
//															 }
//															 if (ok) //it's ok to insert idCusD after curC
//															 {
//																 costC2C = costT + (problem->c[curC][idCusD] + problem->c[idCusD][nextC] - problem->c[curC][nextC]);
//																 if (costC2C < costMINI)
//																 {	
//																	 costMINI = costC2C;																	 
//																	 IDinsert = idCusP;
//																	 insert_afterP = preINS;
//																	 insert_afterD = curC;
//																 }
//															 }
//													  }//else vioTW at idCusD
//												  }//else vio capacity of vehicle
//												  i++; curC = nextArr[curC];
//											  }
//											  else break;
//										 }//end curC is a C2CD
//										 
//									 }//end while
//								 }//else TW is NOT ok for all customers in trip C2C and next PTrip(idVeh, nextT) after inserting idCusP to the trip C2C between preINS and nextINS
//							}//else vioTW at idCusP
//						 }//else can't insert between preINS and nextINS due to the capacity of the trip
//						 preINS = nextINS; nextINS = nextArr[preINS];
//					 }//end for j
//
//					 //3. Insert idCusP at the end of the trip C2C: [after preINS] --> dont need to check CAPACITY of vehicle
//					 //cout<<"Trying to insert ("<<idCusP<<", "<<idCusD<<") at the end of the trip (after "<<preINS<<"): ";
// 					 cStartS = depart[preINS] + problem->c[preINS][idCusP];
//					 temp = problem->node[idCusP].eTW - cStartS;
//					 if (temp > eps)
//					 {
//						 depart_idCusP = PDS_MAX(cStartS, problem->node[idCusP].sTW) + problem->node[idCusP].duration;
//						 //3.1 Insert idCusD right after idCusP:
//						 ArrTime = PDS_MAX(depart_idCusP + problem->c[idCusP][idCusD], problem->node[idCusD].sTW) + problem->node[idCusD].duration;
//						 costC2C = problem->c[preINS][idCusP] + problem->c[idCusP][idCusD] + problem->c[idCusD][0] - problem->c[preINS][0];
//						 if (costC2C < costMINI)
//						 {
//							 costMINI = costC2C;
//							 IDinsert = idCusP;
//							 insert_afterP = preINS;
//							 insert_afterD = idCusP;
//						 }
//						// else cout<<"OK but costC2C = "<<costC2C<<" > costMIN(="<<costMINI<<")"<<endl;
//					 }//else vioTW at idCusP
//					 //else cout<<" vioTW @ idCusP("<<idCusP<<") = "<<temp<<": cStartS = "<<cStartS<<"; dis = "<<problem->c[preINS][idCusP]<<endl;
//				 } //else idCusP already routed 
//			 }//end for idCusP: try all unrouted C2C
//			 if (IDinsert != -1)
//			 {
//				 idCusD = problem->node[IDinsert].delID;
//				// cout<<"Insert C2CP customer "<<IDinsert<<" after "<<insert_afterP<<" and insert C2CD "<<idCusD<<" after "<<insert_afterD<<": "<<endl;
//				 if (insert_afterP == seg[numVeh].Trip[0].lastCus) //insert at the end of the trip:
//				 {
// 					  nextArr[insert_afterP] = IDinsert; 
//					  nextArr[IDinsert] = idCusD; 
//					  seg[numVeh].Trip[0].lastCus = idCusD;nextArr[idCusD] = 0;
//  					  startS[IDinsert] = PDS_MAX(depart[insert_afterP] + problem->c[insert_afterP][IDinsert], problem->node[IDinsert].sTW);
//					  depart[IDinsert] = startS[IDinsert] + problem->node[IDinsert].duration;
//					  FCAP[IDinsert] = problem->node[IDinsert].capacity;
//					  FCAP[idCusD] = 0;
//					  pos[IDinsert] = pos[insert_afterP] + 1; pos[idCusD] = pos[IDinsert] + 1;
//					  startS[idCusD] = PDS_MAX(depart[IDinsert] + problem->c[IDinsert][idCusD], problem->node[idCusD].sTW);
//					  depart[idCusD] = startS[idCusD] + problem->node[idCusD].duration;
//				 }
//				 else //not insert at the end of the trip C2C
//				 {
//					 if (insert_afterP == 0)
//					 {
//						 seg[numVeh].Trip[0].firstCus = IDinsert;
//						 nextArr[IDinsert] = firstC_C2C;
//						 startS[IDinsert] = problem->node[IDinsert].startS_depot;
//						 depart[IDinsert] = problem->node[IDinsert].depart_depot;
//						 pos[IDinsert] = 1; FCAP[IDinsert] = problem->node[IDinsert].capacity;
//					 }
//					 else //insert in the middle
//					 {
// 						  int tt=nextArr[insert_afterP];
//						  nextArr[insert_afterP]=IDinsert;
//						  nextArr[IDinsert]=tt;
//  						  startS[IDinsert] = PDS_MAX(depart[insert_afterP] + problem->c[insert_afterP][IDinsert], problem->node[IDinsert].sTW);
//						  depart[IDinsert] = startS[IDinsert] + problem->node[IDinsert].duration;
//						  pos[IDinsert] = pos[insert_afterP] + 1; 
//						  FCAP[IDinsert] = FCAP[insert_afterP] + problem->node[IDinsert].capacity;
//						  //cout<<"FCAP["<<IDinsert<<"] = FCAP["<<insert_afterP<<"]("<<FCAP[insert_afterP]<<" + cap["<<IDinsert<<"]("<<problem->node[IDinsert].capacity<<" = "<<FCAP[IDinsert];
//						  //cout<<"; FCAP[firstC = "<<firstC_C2C<<"] = "<<FCAP[firstC_C2C]<<endl;
//					 }//end insert in the middle
//
//					 if (insert_afterD == IDinsert) //insert idCusD right after idCusP
//					 {
//						 startS[idCusD] = PDS_MAX(depart[IDinsert] + problem->c[IDinsert][idCusD], problem->node[idCusD].sTW);
//						 depart[idCusD] = startS[idCusD] + problem->node[idCusD].duration;
//						 int tt = nextArr[IDinsert];
//						 nextArr[IDinsert] = idCusD; nextArr[idCusD] = tt; 
//						 pos[idCusD] = pos[IDinsert] + 1; 
//						 FCAP[idCusD] = FCAP[IDinsert] + problem->node[idCusD].capacity;
//					 }
//					 else //insert idCusD after insert_afterD:
//					 {
//						 curC = IDinsert; nextC = nextArr[IDinsert];
//						 do
//						 {
//							 startS[nextC] = PDS_MAX(depart[curC] + problem->c[curC][nextC], problem->node[nextC].sTW);
//							 depart[nextC] = startS[nextC] + problem->node[nextC].duration;
//							 pos[nextC] ++; FCAP[nextC] = FCAP[curC] + problem->node[nextC].capacity;
//							 curC = nextC; nextC = nextArr[curC];
//						 }while (curC != insert_afterD);
//						 //Insert idCusD after insert_afterD:
//						 startS[idCusD] = PDS_MAX(depart[insert_afterD] + problem->c[insert_afterD][idCusD], problem->node[idCusD].sTW);
//						 depart[idCusD] = startS[idCusD] + problem->node[idCusD].duration;
//						 nextArr[idCusD] = nextArr[insert_afterD]; nextArr[insert_afterD] = idCusD; 
//						 pos[idCusD] = pos[insert_afterD] + 1; FCAP[idCusD] = FCAP[insert_afterD] + problem->node[idCusD].capacity;
//					 }//end insert idCusD after insert_afterD:
//					 nextC = nextArr[idCusD];
//					 if (nextC > 0)	 updateStartS_pos_FCAP_FEASIBLETRIP(numVeh,0,idCusD,nextC,pos[idCusD]);
//					 else seg[numVeh].Trip[0].lastCus = idCusD;
//				 }//end not insert at the end of the trip C2C
//
//				  seg[numVeh].Trip[0].numCus +=2; 
//				  //cout<<"Vehicle with only C2C: numCus = "<<seg[numVeh].Trip[0].numCus<<endl;
//				  routed[IDinsert] = 1; routed[idCusD] = 1;
//				  numCusC2CRouted += 2;
//				  if (numCusC2CRouted == nC2C) cont = 0;
//				  seg[numVeh].Trip[0].cost += costMINI;
//				  seg[numVeh].Trip[0].endS = depart[seg[numVeh].Trip[0].lastCus];
//				  seg[numVeh].Trip[0].connectCost = problem->c[seg[numVeh].Trip[0].lastCus][0];
//				  ok = checkC2C_P_FeasibleTrip_InitSol(numVeh,0, 0, 0,-1);
//				  if (ok == 0) exit(-1);
//				  //cout<<"FCAP[firstC="<<seg[numVeh].Trip[0].firstCus<<"] = "<<FCAP[seg[numVeh].Trip[0].firstCus]<<endl;
//			 } else cont = 0; //can't route any C2C anymore
//		 }while (cont);
//		 delete [] departTemp;
//	 }
//	 //showTripCus(numVeh,0);
//}
//
//void Solution::updateStartSP_FEASIBLETRIP_Temp(int idVeh, int idTrip, int preC, int idCus) //update startS array from idCus on feasible trip(idVeh, idTrip): idCus is not the first customer
//{
//	double ArrTime;
//	while (idCus > 0)
//	{
//		ArrTime = depart[preC] + problem->c[preC][idCus];
//		startS[idCus] = PDS_MAX(ArrTime, problem->node[idCus].sTW);
//		depart[idCus] = startS[idCus] + problem->node[idCus].duration;
//		preC = idCus; idCus = nextArrTemp[idCus];
//	}
//}
//
//
//
//void Solution::updateStartSP_FEASIBLETRIP(int idVeh, int idTrip, int preC, int idCus) //update startS array from idCus on feasible trip(idVeh, idTrip): idCus is not the first customer
//{
//	double ArrTime;
//	while (idCus > 0)
//	{
//		ArrTime = depart[preC] + problem->c[preC][idCus];
//		startS[idCus] = PDS_MAX(ArrTime, problem->node[idCus].sTW);
//		depart[idCus] = startS[idCus] + problem->node[idCus].duration;
//		preC = idCus; idCus = nextArr[idCus];
//	}
//}
//
//
//void Solution::updateStartS_pos_FCAP_FEASIBLETRIP(int idVeh, int idTrip, int preC, int idCus, int pre_pos) //update startSP and departP array from idCus on feasible pickup trip(idVeh, idTrip): idCus is not the first customer
//{
//	double ArrTime;
//	while (idCus > 0)
//	{
//		ArrTime = depart[preC] + problem->c[preC][idCus];
//		startS[idCus] = PDS_MAX(ArrTime, problem->node[idCus].sTW);
//		depart[idCus] = startS[idCus] + problem->node[idCus].duration;
//		pre_pos++; pos[idCus] = pre_pos;
//		FCAP[idCus] = FCAP[preC] + problem->node[idCus].capacity;
//		//cout<<"FCAP["<<idCus<<"] = "<<FCAP[idCus]<<"; ";
//		preC = idCus; idCus = nextArr[idCus];
//	}
//	//cout<<endl;
//}
//void Solution::updateStartS_pos_FCAP_FEASIBLETRIP_Temp(int idVeh, int idTrip, int preC, int idCus, int pre_pos) //update startSP and departP array from idCus on feasible pickup trip(idVeh, idTrip): idCus is not the first customer
//{
//	double ArrTime;
//	while (idCus > 0)
//	{
//		ArrTime = depart[preC] + problem->c[preC][idCus];
//		startS[idCus] = PDS_MAX(ArrTime, problem->node[idCus].sTW);
//		depart[idCus] = startS[idCus] + problem->node[idCus].duration;
//		//cout<<"startS[idCus = "<<idCus<<"] = "<<startS[idCus]<<"; [sTW, eTW] = ["<<problem->node[idCus].sTW<<", "<<problem->node[idCus].eTW<<"]; depart[preC="<<preC<<"] = "<<depart[preC]<<"; dis = "<<problem->c[preC][idCus]<<endl;
//		pre_pos++; pos[idCus] = pre_pos;
//		FCAP[idCus] = FCAP[preC] + problem->node[idCus].capacity;
//		preC = idCus; idCus = nextArrTemp[idCus];
//	}
//}
//void Solution::updatePTrip_InitSol(int idVeh, int idTrip, int preC, int idCus, bool changed)
//{
//	//Update startS, depart of all customers, leaveSP in PTrip(idVeh, idTrip)
//	double ArrTime, cStartS;
//
//	//cout<<"Update PTrip("<<idVeh<<", "<<idTrip<<"): ";
//	while (idCus > 0)
//	{
//		ArrTime = depart[preC] + problem->c[preC][idCus];
//		cStartS = PDS_MAX(ArrTime, problem->node[idCus].sTW);
//		if (PDSDIF(cStartS, startS[idCus]) == 0) return; 
//		startS[idCus] = cStartS;
//		depart[idCus] = cStartS + problem->node[idCus].duration;
//		//cout<<idCus<<"(depart = "<<depart[idCus]<<"); ";
//		preC = idCus; idCus = nextArr[idCus];
//	}
//
//	seg[idVeh].Trip[idTrip].endS = depart[preC];
//	//cout<<"endS of trip = "<<depart[preC]<<endl;
//	int assSP = seg[idVeh].Trip[idTrip].assSP;
//	if (changed) //PTrip(idVeh, idTrip) before go through WS now go to sp directly
//	{
//		seg[idVeh].Trip[idTrip].waitingS = NO_WS;
//		seg[idVeh].Trip[idTrip].cost += (problem->c[preC][assSP] - problem->disCWSSP[preC][assSP]);
//		seg[idVeh].Trip[idTrip].leaveSP = depart[preC] + problem->c[preC][assSP] + problem->nodeSP[assSP].unload;
//	}
//	else //still go to SP directly OR still go through WS:
//	{
//		if (seg[idVeh].Trip[idTrip].waitingS == NO_WS)
//		{
//			seg[idVeh].Trip[idTrip].leaveSP = depart[preC] + problem->c[preC][assSP] + problem->nodeSP[assSP].unload;
//		}
//		else
//		{
//			ArrTime = PDS_MAX(depart[preC] + problem->disCWSSP[preC][assSP], problem->nodeSP[assSP].sTW1);
//			seg[idVeh].Trip[idTrip].leaveSP = ArrTime + problem->nodeSP[assSP].unload;
//		}
//	}
//}
//
//
//
//void Solution::updatePTrip_InitSol_Temp(int idVeh, int idTrip, int preC, int idCus, bool changed)
//{
//	//Update startS, depart of all customers, leaveSP in PTrip(idVeh, idTrip)
//	double ArrTime, cStartS;
//
//	while (idCus > 0)
//	{
//		ArrTime = depart[preC] + problem->c[preC][idCus];
//		cStartS = PDS_MAX(ArrTime, problem->node[idCus].sTW);
//		if (PDSDIF(cStartS, startS[idCus]) == 0) return; 
//		startS[idCus] = cStartS;
//		depart[idCus] = cStartS + problem->node[idCus].duration;
//		//cout<<idCus<<"(depart = "<<depart[idCus]<<"); ";
//		preC = idCus; idCus = nextArrTemp[idCus];
//	}
//
//	seg[idVeh].Trip[idTrip].endS = depart[preC];
//	
//	int assSP = seg[idVeh].Trip[idTrip].assSP;
//	if (changed) //PTrip(idVeh, idTrip) before go through WS now go to sp directly
//	{
//		seg[idVeh].Trip[idTrip].waitingS = NO_WS;
//		seg[idVeh].Trip[idTrip].cost += (problem->c[preC][assSP] - problem->disCWSSP[preC][assSP]);
//		seg[idVeh].Trip[idTrip].leaveSP = depart[preC] + problem->c[preC][assSP] + problem->nodeSP[assSP].unload;
//	}
//	else //still go to SP directly OR still go through WS:
//	{
//		if (seg[idVeh].Trip[idTrip].waitingS == NO_WS)
//		{
//			seg[idVeh].Trip[idTrip].leaveSP = depart[preC] + problem->c[preC][assSP] + problem->nodeSP[assSP].unload;
//		}
//		else
//		{
//			ArrTime = PDS_MAX(depart[preC] + problem->disCWSSP[preC][assSP], problem->nodeSP[assSP].sTW1);
//			seg[idVeh].Trip[idTrip].leaveSP = ArrTime + problem->nodeSP[assSP].unload;
//		}
//	}
//}



//int Solution::Create_DeliveryTrip(int startSP, int &numTrip, double leave_startSP, int &nextSP, int typeofseed, int typeofINIT, int valueFEE)
//{
//	 //Create a delivery trip (idVeh, idTrip) of sp startSP where the time to leave startSP is leave_startSP:
//	//returns 0 or 1 or 2: 0: create startSP-d -(C2C)-depot; 
//                         //1: create startSP-d-(C2C)-p-nextSP; 
//                         //2: create startSP-d-(C2C)-nextSP
//
//	   int i,endSP;
//	   int createTrip; //= 0: last delivery trip; = 1: d-p trip; =2: only delivery trip
//	   double feeMIN = PDS_INFINITY;
//       int canRoute = 0; 
//	  // cout<<"Inside Create_DeliveryTrip: startSP = "<<startSP<<", leave_startSP = "<<leave_startSP<<"; numVeh = "<<numVeh<<", numTrip = "<<numTrip<<endl;
//		
//			   for (endSP = startSP+1;endSP<=nSP;endSP++)
//				  if (numCusPRouted[endSP] < numCusPSP[endSP] || numCusDRouted[endSP] < problem->numCusDSP[endSP]) //exist unrouted customers in sj
//					  Init_NewSolomonI1_NewDeliveryTrip(startSP, endSP, numTrip,leave_startSP, feeMIN, nextSP, createTrip, typeofseed,valueFEE,typeofINIT,canRoute);
//
//			   if (canRoute==0) 
//			   {
//				   Init_NewSolomonI1_NewDeliveryTrip(startSP,0, numTrip, leave_startSP, feeMIN, nextSP, createTrip, typeofseed,valueFEE,typeofINIT,canRoute);
//				   /*cout<<"At Create_DeliveryTrip: Create xong last delivery trip cho vehicle "<<numVeh<<": ";
//				   showTripCost(numVeh,numTrip+4);
//				   cout<<"-----------------------------------------------------------------"<<endl;*/
//			   }
//			   seg[numVeh].Trip[numTrip] = seg[numVeh].Trip[numTrip+4]; //bestTrip
//			 
//			   //Update all information for new trip:.....
//			   int curC = seg[numVeh].Trip[numTrip].firstCus;
//			   for (i=1;i<=seg[numVeh].Trip[numTrip].numCus;i++)
//			   {
//					routed[curC]=1;
//					nextArr[curC]=nextArrB[curC];
//					curC = nextArr[curC];
//			   }
//			   nextArr[curC]= 0;
//			   numCusDRouted[startSP] += seg[numVeh].Trip[numTrip].numCus; 
//			   
//			   if (createTrip >0)
//			   {
//					if (createTrip==1) //create trips: s-delivery - pickup - startSP
//					{
//					   //cout<<"Create d-p-startSP"<<endl; showTripCost(numVeh,numTrip);
//					   numTrip = numTrip+1;
//					   seg[numVeh].Trip[numTrip] = seg[numVeh].Trip[numTrip+4]; //bestTrip
//					   if (seg[numVeh].Trip[numTrip].assSP > nSP)
//					   {
//						   cout<<"Create xong mot pickup trip "<<numTrip<<" cho vehicle "<<numVeh<<endl;
//						   cout<<"ERRORRRRRRRRRRRRRRRRRRR: > nSP"<<endl;
//						   exit(-1);
//					   }
//					
//					   //Update all information for new pickup trip:.....
//					   int curC = seg[numVeh].Trip[numTrip].firstCus;
//					   for (i=1;i<=seg[numVeh].Trip[numTrip].numCus;i++)
//					   {
//							routed[curC]=1;
//							nextArr[curC]=nextArrB[curC];
//							curC = nextArr[curC];
//					   }
//					   nextArr[curC]=0;
//   					   showTripCost(numVeh,numTrip);
//					   numCusPRouted[nextSP] += seg[numVeh].Trip[numTrip].numCus; 
//					   int lastC = seg[numVeh].Trip[numTrip].lastCus; double arrTime;
//                       if (seg[numVeh].Trip[numTrip].waitingS == NO_WS)
//					 	   arrTime = seg[numVeh].Trip[numTrip].endS + problem->c[lastC][nextSP];
//					   else
//						   arrTime = seg[numVeh].Trip[numTrip].endS + problem->disCWSSP[lastC][nextSP];
//					   arrTime = PDS_MAX(arrTime, problem->nodeSP[nextSP].sTW1);
//					   seg[numVeh].Trip[numTrip].leaveSP = arrTime + problem->nodeSP[nextSP].unload;
//					   //cout<<"LeaveSP of PTrip("<<numVeh<<", "<<numTrip<<") = "<<seg[numVeh].Trip[numTrip].leaveSP<<"; depart[lastC = "<<lastC<<"] = "<<depart[lastC]<<"; endS = "<<seg[numVeh].Trip[numTrip].endS<<endl;
//				       return 1;
//				   }
//				   else if (createTrip == 2)//create delivery trip only: startSP - del - nextSP --> at nextSP vehicles has to LOAD:
//				   {
//					   //cout<<"Create startSP-D-nextSP"<<endl;showTripCost(numVeh,numTrip);
//					   int lastC = seg[numVeh].Trip[numTrip].lastCus; double arrTime;
//					   if (seg[numVeh].Trip[numTrip].waitingS == NO_WS)
//						   arrTime = seg[numVeh].Trip[numTrip].endS + problem->c[lastC][nextSP];
//					   else arrTime = seg[numVeh].Trip[numTrip].endS + problem->disCWSSP[lastC][nextSP];
//					   arrTime = PDS_MAX(arrTime, problem->nodeSP[nextSP].sTW1);
//					   seg[numVeh].Trip[numTrip].arriveSP = arrTime; 
//					   return 2;
//					   //cout<<"Create only Deltrip("<<numVeh<<", "<<numTrip<<") = "<<seg[numVeh].Trip[numTrip].cost<<endl;
//				   }
//				   else if (createTrip == 3) //create Dtrip + C2C + pTrip - nextSP:
//				   {
//					   //cout<<"Create D-C2C-P-nextSP"<<endl; showTripCost(numVeh,numTrip);
//					   numTrip = numTrip + 1;
//					   seg[numVeh].Trip[numTrip] = seg[numVeh].Trip[numTrip + 4]; //bestTrip
//					   //Update all information for new C2C trip:.....
//					   int curC = seg[numVeh].Trip[numTrip].firstCus;
//					   for (i=1;i<=seg[numVeh].Trip[numTrip].numCus;i++)
//					   {
//							routed[curC]=1;
//							nextArr[curC]=nextArrB[curC];
//							curC = nextArr[curC];
//					   }
//					   nextArr[curC]=0;
//					   numCusC2CRouted += seg[numVeh].Trip[numTrip].numCus; 
//					   //showTripCost(numVeh,numTrip);
//		
//						   numTrip = numTrip+1;
//						   seg[numVeh].Trip[numTrip] = seg[numVeh].Trip[numTrip+4]; //bestTrip
//						   if (seg[numVeh].Trip[numTrip].assSP > nSP)
//						   {
//							   cout<<"Create xong mot pickup trip "<<numTrip<<" cho vehicle "<<numVeh<<endl;
//							   cout<<"ERRORRRRRRRRRRRRRRRRRRR: > nSP"<<endl;
//							   exit(-1);
//						   }
//						
//						   //Update all information for new pickup trip:.....
//						   curC = seg[numVeh].Trip[numTrip].firstCus;
//						   for (i=1;i<=seg[numVeh].Trip[numTrip].numCus;i++)
//						   {
//								routed[curC]=1;
//								nextArr[curC]=nextArrB[curC];
//								curC = nextArr[curC];
//						   }
//						   nextArr[curC]=0;
//						   showTripCost(numVeh,numTrip);
//					   	   numCusPRouted[nextSP] += seg[numVeh].Trip[numTrip].numCus; 
//						   int lastC = seg[numVeh].Trip[numTrip].lastCus; double arrTime;
//						   if (seg[numVeh].Trip[numTrip].waitingS == NO_WS)
//					 		   arrTime = seg[numVeh].Trip[numTrip].endS + problem->c[lastC][nextSP];
//						   else
//							   arrTime = seg[numVeh].Trip[numTrip].endS + problem->disCWSSP[lastC][nextSP];
//						   arrTime = PDS_MAX(arrTime, problem->nodeSP[nextSP].sTW1);
//						   seg[numVeh].Trip[numTrip].leaveSP = arrTime + problem->nodeSP[nextSP].unload;
//						   //cout<<"LeaveSP of PTrip("<<numVeh<<", "<<numTrip<<") = "<<seg[numVeh].Trip[numTrip].leaveSP<<"; depart[lastC = "<<lastC<<"] = "<<depart[lastC]<<"; endS = "<<seg[numVeh].Trip[numTrip].endS<<endl;
//                           return 1;				  
//				   }
//				   else if (createTrip == 4) //create DTrip + C2C + depot
//				   {
//					  // cout<<"Create D-C2C-depot"<<endl;  showTripCost(numVeh,numTrip);
//					   numTrip = numTrip + 1;
//					   seg[numVeh].Trip[numTrip] = seg[numVeh].Trip[numTrip + 4]; //bestTrip
//					   //Update all information for new C2C trip:.....
//					   int curC = seg[numVeh].Trip[numTrip].firstCus;
//					   for (i=1;i<=seg[numVeh].Trip[numTrip].numCus;i++)
//					   {
//							routed[curC]=1;
//							nextArr[curC]=nextArrB[curC];
//							curC = nextArr[curC];
//					   }
//					   nextArr[curC]=0;
//					   numCusC2CRouted += seg[numVeh].Trip[numTrip].numCus; 
//   					   //showTripCost(numVeh,numTrip);
//					   return 0;
//				   }
//				   else if (createTrip == 5) //create DTrip + C2C -nextSP
//				   {
//					   //cout<<"Create D-C2C-nextSP"<<endl;showTripCost(numVeh,numTrip);
//					   numTrip = numTrip + 1;
//					   seg[numVeh].Trip[numTrip] = seg[numVeh].Trip[numTrip + 4]; //bestTrip
//					   //Update all information for new C2C trip:.....
//					   int curC = seg[numVeh].Trip[numTrip].firstCus;
//					   for (i=1;i<=seg[numVeh].Trip[numTrip].numCus;i++)
//					   {
//							routed[curC]=1;
//							nextArr[curC]=nextArrB[curC];
//							curC = nextArr[curC];
//					   }
//					   nextArr[curC]=0;
//					   numCusC2CRouted += seg[numVeh].Trip[numTrip].numCus; 
//   					   //showTripCost(numVeh,numTrip);
//					   int lastC = seg[numVeh].Trip[numTrip].lastCus; double arrTime;
//					   if (seg[numVeh].Trip[numTrip].waitingS == NO_WS)
//						   arrTime = seg[numVeh].Trip[numTrip].endS + problem->c[lastC][nextSP];
//					   else arrTime = seg[numVeh].Trip[numTrip].endS + problem->disCWSSP[lastC][nextSP];
//					   arrTime = PDS_MAX(arrTime, problem->nodeSP[nextSP].sTW2);
//					   seg[numVeh].Trip[numTrip].arriveSP = arrTime; 
//					   //cout<<"arriveSP of C2CTRip("<<numVeh<<", "<<numTrip<<") = "<<arrTime<<endl;
//					   return 2;
//				   }
//				   //numTrip++;
//			   }
//			   else //last trip --> end current vehicle
//			   {
//				   /*cout<<"Last delivery trip ("<<numVeh<<", "<<numTrip<<"): cost = "<<seg[numVeh].Trip[numTrip].cost<<endl;
//				   showTripCost(numVeh,numTrip);*/
//				   return 0;
//			   }
//			   return 0;
//}



//create new leg l(th) for vehicle idVeh(th) according to Solomon I1
//void Solution::Init_NewSolomonI1_NewDeliveryTrip(int startSP, int endSP, int idTrip, double leave_startSP, double &feeMIN, int &nextSP, int &createTrip, int typeofseed, int valueFEE, int typeofINIT, int &canRoute)  //always create feasible leg
//{
//	 int l = idTrip+1;
//	 
//	 int lP=0; int lC2C = 0;
//	 seg[numVeh].Trip[l].assSP = startSP;
//	 seg[numVeh].Trip[l].leaveSP = leave_startSP;
//	 	 
//
//	 //cout<<"----------Init_NewSolomonI1_NewDeliveryTrip: INIT DLEG "<<l<<" of vehicle "<<numVeh<<"(startSP = "<<startSP<<", endSP = "<<endSP<<")"<<endl;
//	 int i,j;
//     int start = problem->startCusDSP[startSP];
//	 int end = problem->endCusDSP[startSP]; //int end = start + problem->numCusSP[startSP]-1;
//     for (i=start;i<=end;i++) routedTemp[i]=routed[i];
//
//     int seed=0, idCus; 
//     
//	 double ArrTime,ArrTime1;
//	 int goWS, goWSMINI, preINS, nextINS,curC,nextC,lastC; 
//	 double temp,startSTemp;
//	 double varcost,c1,c2,c2OPT;
//	 bool ok;
//	 int IDinsert, WSID,WSIDtemp, insert_after;
//	 double costP, costS, costMINI, arrTimeMINI;
//	 double TOTALTIME=0;
//	 //bool dien1 = 0;
//	 if (endSP!=0) //A.not last leg: then should check if it is possible to create pickup trip after this delivery trip
//	 {
//		   costMINI=PDS_INFINITY; goWSMINI=-10;
//           for (i=start;i<=end;i++)
//				 if (!routedTemp[i])
//				 {
//					  ArrTime = leave_startSP + problem->c[startSP][i];
//					  temp = ArrTime - problem->node[i].eTW;
//					  if (temp > eps) continue;
//			          ArrTime = PDS_MAX(ArrTime, problem->node[i].sTW) + problem->node[i].duration;
//					  ArrTime1 = ArrTime + problem->c[i][endSP];
//			          if (PDSINRANGE(ArrTime1, problem->nodeSP[endSP].sTW2, problem->nodeSP[endSP].eTW2)) 
//					  {
//						  goWS=NO_WS;
//						  costS = problem->c[startSP][i] + problem->c[i][endSP];
//					  }
//					  else
//					  {
//                         	temp = ArrTime1 - problem->nodeSP[endSP].eTW2;
//					        if (temp > eps) continue;
//							ArrTime1 = ArrTime + problem->disCWSSP[i][endSP];
//							temp = ArrTime1 - problem->nodeSP[endSP].eTW2;
//							if (temp > eps) continue;
//							goWS = problem->CWSSP[i][endSP];
//							costS = problem->c[startSP][i] + problem->disCWSSP[i][endSP];
//					  }
//					  if (costS < costMINI)
//					  {
//						  seed=i;
//						  costMINI = costS;
//						  goWSMINI = goWS;
//						  arrTimeMINI = ArrTime;
//					  }
//				 }
//				 if (goWSMINI !=-10) //can find seed:
//				 {
//				 	 routedTemp[seed]=1; 
//					 seg[numVeh].Trip[l].firstCus=seed; //id of the first Customer of Leg
//					 seg[numVeh].Trip[l].lastCus=seed; //id of the first Customer of Leg
//					 seg[numVeh].Trip[l].numCus=1; //#Customers in the leg
//					 seg[numVeh].Trip[l].capacity = problem->node[seed].capacity;
//					 seg[numVeh].Trip[l].waitingS = goWSMINI;
//					 nextArrTemp[seed] = 0; //just correct for initial solution
//					 seg[numVeh].Trip[l].cost = costMINI;
//					 seg[numVeh].Trip[l].endS = arrTimeMINI;
//					 seg[numVeh].Trip[l].feasible = 1;
//					 seg[numVeh].Trip[l].Type = 1;
//					 goWS = goWSMINI;
//					 //cout<<"First cus of veh "<<numVeh<<", trip "<<l<<": seed = "<<seed<<endl;
//				 }
//				 else return;
//				//starting to find unrouted delivery customer to insert into the current trip (startSP, endSP):
//				bool cont=true;  
//				do //each loop insert 1 delivery customer
//				{
//					  insert_after=-1; c2OPT = -PDS_INFINITY;
//					  lastC = seg[numVeh].Trip[l].lastCus;
//					  for (idCus=start;idCus<=end;idCus++)
//						   if (routedTemp[idCus]==0 && (seg[numVeh].Trip[l].capacity + problem->node[idCus].capacity <= problem->Q))
//						   {
//								 //1. try to insert at the beginning of the leg:
//								 ok=1; nextINS = seg[numVeh].Trip[l].firstCus;
//								 ArrTime = leave_startSP + problem->c[startSP][idCus];
//								 temp = ArrTime - problem->node[idCus].eTW;
//								 if (temp > eps) continue; //vioTW at customer idCus --> try another idCus
//								 
//								 ArrTime = PDS_MAX(ArrTime, problem->node[idCus].sTW) + problem->node[idCus].duration;
//								 curC = idCus; nextC = seg[numVeh].Trip[l].firstCus;
//								 for (j=1;j<=seg[numVeh].Trip[l].numCus;j++)
//								 {
//											 ArrTime += problem->c[curC][nextC]; 
//											 temp = ArrTime - problem->node[nextC].eTW;
//											 if (temp > eps) {ok=0;break;} //vioTW at customer nextC
//											 else
//											 {
//													 ArrTime = PDS_MAX(ArrTime,problem->node[nextC].sTW) + problem->node[nextC].duration;
//													 curC = nextC; nextC=nextArrTemp[curC];
//											 }
//								}
//                                if (ok)
//								{
//								     ArrTime1 =  ArrTime + problem->c[curC][endSP];
//					    			 temp = problem->nodeSP[endSP].eTW2 - ArrTime1;
//									 if (temp > eps)  //else too late to go to sp directly
//									 {
//										 if (PDSINRANGE(ArrTime1,problem->nodeSP[endSP].sTW2, problem->nodeSP[endSP].eTW2))
//											 WSIDtemp=NO_WS;
//										 else
//										 {
//											  ArrTime1 = ArrTime + problem->disCWSSP[curC][endSP];
//											  temp = ArrTime1 - problem->nodeSP[endSP].eTW2;
//											  if (temp > eps) ok=0; //too late to go to sp through WS
//											  else WSIDtemp = problem->CWSSP[curC][endSP];
//										 }
//                                         if (ok)
//										 {
//										     c1 = problem->c[startSP][idCus] + problem->c[idCus][nextINS] - problem->c[startSP][nextINS];
//										     if (goWS!= WSIDtemp)
//											 {
//												 if (goWS!= NO_WS) //before go to WS, after insert don't need to go to WS:
//												 {
//														 c1 += (problem->c[curC][endSP] - problem->disCWSSP[curC][endSP]);
//												 }
//												 else 
//												 {
//														 cout<<"Solution::Init_NewSolomonI1_NewDeliveryTrip ERROR before insert go to sp, after insert go to WS"<<endl;
//														 cout<<"Trying to insert delivery cus "<<idCus<<" at the beginning of: ";
//														 showTripCostTemp(numVeh,l);
//														 exit(-1);
//												 }
//											 }
//											 c2 = problem->c[startSP][idCus] - c1;
//											 if (c2 > c2OPT) {c2OPT=c2; varcost=c1; IDinsert=idCus; insert_after = 0;WSID=WSIDtemp;
//															  TOTALTIME = ArrTime;
//															 } 
//										 }
//									 }//else too late to go to sp directly			
//								}//end if (ok) else vioTW at a delivery cus
//								 //2. try to insert customer idCus after each delivery customer j of the trip:
//								 preINS = seg[numVeh].Trip[l].firstCus;
//								 ArrTime = leave_startSP + problem->c[startSP][preINS];
//								 for (j=1;j<=seg[numVeh].Trip[l].numCus;j++) 
//								 {
//										 ok=1;
//									     startSTemp = PDS_MAX(ArrTime, problem->node[preINS].sTW);
//										 ArrTime = startSTemp + problem->node[preINS].duration + problem->c[preINS][idCus];
//										 temp = ArrTime - problem->node[idCus].eTW;
//										 if (temp > eps) break; //vioTW at idCus --> don't need to check any j 
//										 ArrTime = PDS_MAX(ArrTime, problem->node[idCus].sTW) + problem->node[idCus].duration;
//										
//										 //start checking TW from i to the end of the leg:
//										 curC = idCus; nextC = nextArrTemp[preINS];
//										 while (nextC > 0)
//										 {
//													 ArrTime += problem->c[curC][nextC]; 
//													 temp = ArrTime - problem->node[nextC].eTW;
//													 if (temp > eps) {ok=0;break;}
//													 else
//													 {
//															 ArrTime = PDS_MAX(ArrTime,problem->node[nextC].sTW) + problem->node[nextC].duration;
//															 curC = nextC; nextC=nextArrTemp[curC];
//													 }
//										 }
//										 if (ok) //now curC point to the lastCus
//										 {
//													 ArrTime1=  ArrTime + problem->c[curC][endSP];
//													 temp = problem->nodeSP[endSP].eTW2 - ArrTime1;
//													 if (temp > eps)//else too late to go to sp directly
//													 {
//														 if (PDSINRANGE(ArrTime1,problem->nodeSP[endSP].sTW2, problem->nodeSP[endSP].eTW2))
//															  WSIDtemp=NO_WS;
//														 else
//														 {
//															  ArrTime1 = ArrTime + problem->disCWSSP[curC][endSP];
//															  temp = ArrTime1 - problem->nodeSP[endSP].eTW2;
//															  if (temp > eps) ok=0; //too late to go to sp through WS
//															  else WSIDtemp = problem->CWSSP[curC][endSP];
//														 }
//                                                         if (ok)
//														 {
//																 if (j != seg[numVeh].Trip[l].numCus)								        
//																 {
//																	 nextINS = nextArrTemp[preINS];
//																	 c1 = problem->c[preINS][idCus] + problem->c[idCus][nextINS] - problem->c[preINS][nextINS];
//																	 if (goWS != WSIDtemp)
//																	 {
//																		 if (goWS != NO_WS) //before go to WS, after insert don't need to go to WS:
//																			 c1 += (problem->c[curC][endSP] - problem->disCWSSP[curC][endSP]);
//																		 else 
//																		 {
//																			 cout<<"Solution::Init_NewSolomonI1_NewDeliveryTrip ERROR before insert go to sp directly, after insert go to WS"<<endl;
//																			 cout<<"Trying to insert "<<idCus<<" after "<<preINS<<": ";
//																			 showTripCostTemp(numVeh,l);
//																			 exit(-1);
//																		 }
//																	 }
//																 }
//																 else //insert to the end of the leg:
//																 {
//																	 c1 = problem->c[preINS][idCus];
//																	 if (goWS==NO_WS) //before insert customer idCus, go to sp directly
//																	 {
//																		 if (WSIDtemp ==NO_WS) c1 += (problem->c[idCus][endSP] - problem->c[preINS][endSP]);
//																		 else 
//																		 {
//																			 cout<<"Solution::Init_NewSolomonI1_NewDeliveryTrip  ERROR before insert go to sp directly, after insert need to go to WS"<<endl; 
//																			 cout<<"Trying to insert "<<idCus<<" at the end of the trip: ";
//																			 showTripCostTemp(numVeh,l);
//																			 exit(-1);
//																		 }
//																	 }
//																	 else //before insert customer idCus, go to WS:
//																	 {
//																		 if (WSIDtemp == NO_WS) c1 += (problem->c[idCus][endSP] - problem->disCWSSP[preINS][endSP]);
//																		 else c1+=(problem->disCWSSP[idCus][endSP] - problem->disCWSSP[preINS][endSP]);
//																	 }
//																 }
//																 c2 = problem->c[startSP][idCus]-c1;
//																 if (c2 > c2OPT) {c2OPT=c2; varcost=c1; IDinsert=idCus; insert_after = preINS;
//																				  WSID=WSIDtemp;TOTALTIME = ArrTime;} 
//														 }//else too soon to go to sp directly, too late to go to sp through WS
//													 }//else too late to go to sp directly
//										}//end if (ok) :else vioTW at one customer of route
//										nextINS = nextArrTemp[preINS];
//										ArrTime = startSTemp + problem->node[preINS].duration + problem->c[preINS][nextINS];
//										preINS = nextINS;
//								 }//end for j
//						   }//end if (!routedDTemp[idCus])
//						   if (insert_after!=-1)
//						   {
//									  //cout<<"Insert customer "<<IDinsert<<" after "<<insert_after<<": ";
//									  if (insert_after == 0)
//									  {
//										  int TEPRE = seg[numVeh].Trip[l].firstCus;
//										  seg[numVeh].Trip[l].firstCus = IDinsert;
//										  nextArrTemp[IDinsert] = TEPRE;
//										  //cout<<"************Insert customer "<<IDinsert<<" beginning of the leg: after "<<insert_after<<"; varcost = "<<varcost<<endl;
//									  }
//									  else if (insert_after == seg[numVeh].Trip[l].lastCus) //insert at the end of the leg:
//									  {
//										  nextArrTemp[insert_after] = IDinsert;
//										  seg[numVeh].Trip[l].lastCus = IDinsert;
//										  nextArrTemp[IDinsert]=0;
//										  //cout<<"*************Insert customer "<<IDinsert<<" at the end of the leg: after "<<insert_after<<endl;
//									  }
//									  else //insert at the middile of the leg:
//									  {
//										  int tt=nextArrTemp[insert_after];
//										  nextArrTemp[insert_after]=IDinsert;
//										  nextArrTemp[IDinsert]=tt;
//										  //cout<<"***********Insert customer "<<IDinsert<<" in the middle of the leg: after "<<insert_after<<endl;
//									  }
//									  seg[numVeh].Trip[l].numCus++;seg[numVeh].Trip[l].waitingS = WSID;
//									  routedTemp[IDinsert]=1;
//									  seg[numVeh].Trip[l].capacity += problem->node[IDinsert].capacity;
//									  goWS = WSID;
//									  seg[numVeh].Trip[l].cost += varcost;
//									  seg[numVeh].Trip[l].endS = TOTALTIME;
//							 }
//							 else cont=false; //can't find any customer to insert into the current leg
//				}while (cont);
//
//
//				//Checking if can route pickup customers:
//				if (numCusPRouted[endSP] < numCusPSP[endSP]) //endSP still exists unrouted pickup customers
//				{
//					//cout<<"-->1. Route pickup customers assigned to endSP = "<<endSP<<"; after DTrip("<<numVeh<<", "<<l<<")"<<endl;
//					if (seg[numVeh].Trip[l].waitingS != NO_WS) //from last delivery customer has to go to sp endSP through WS, then can insert pickup customer between them:
//					{
//						
//                        for (i=1;i<=numCusPSP[endSP];i++)
//						{
//							idCus = CusPSP[endSP][i];
//							routedTemp[idCus] = routed[idCus];                       
//						}
//						int lastD = seg[numVeh].Trip[l].lastCus;
//					    costMINI = PDS_INFINITY; seed = -1;
//						//P1.Insert first pickup customer:
//						for (i=1;i<=numCusPSP[endSP];i++)
//						{
//							idCus = CusPSP[endSP][i];
//							if (routedTemp[idCus]==0)
//							{
//							    ArrTime = seg[numVeh].Trip[l].endS + problem->c[lastD][idCus];
//								temp = ArrTime - problem->node[idCus].eTW;
//								if (temp > eps) continue; //vioTW at idCus--> try another idCus
//								ArrTime = PDS_MAX(ArrTime, problem->node[idCus].sTW) + problem->node[idCus].duration;
//								ArrTime1 = ArrTime + problem->c[idCus][endSP];
//								if (PDSINRANGE(ArrTime1, problem->nodeSP[endSP].sTW1, problem->nodeSP[endSP].eTW1)) 
//								{
//									  goWS=NO_WS;
//									  costP = problem->c[lastD][idCus] + problem->c[idCus][endSP];
//								}
//								else
//								{
//										temp = ArrTime1 - problem->nodeSP[endSP].eTW1;
//										if (temp > eps) continue;
//										ArrTime1 = ArrTime + problem->disCWSSP[idCus][endSP];
//										temp = ArrTime1 - problem->nodeSP[endSP].eTW1;
//										if (temp > eps) continue;
//										goWS = problem->CWSSP[idCus][endSP];
//										costP = problem->c[lastD][idCus] + problem->disCWSSP[idCus][endSP];
//								}
//								if (costP < costMINI)
//								{
//									  seed=idCus;
//									  costMINI = costP;
//									  goWSMINI = goWS;
//									  TOTALTIME = ArrTime;
//								}
//							}
//						}//end for
//     				    if (seed != -1) //can insert pickup customer after delivery
//						{
//								 routedTemp[seed]=1; lP = l+2; 
//								 seg[numVeh].Trip[lP].Type = 0;
//								 seg[numVeh].Trip[lP].assSP = endSP;
//								 seg[numVeh].Trip[lP].firstCus = seed; //id of the first Customer of Leg
//								 seg[numVeh].Trip[lP].lastCus = seed; //id of the first Customer of Leg
//								 seg[numVeh].Trip[lP].numCus = 1; //#Customers in the leg
//								 seg[numVeh].Trip[lP].capacity = problem->node[seed].capacity;
//								 seg[numVeh].Trip[lP].waitingS = goWSMINI;
//								 nextArrTemp[seed] = 0; //just correct for initial solution
//								 seg[numVeh].Trip[lP].cost = costMINI - problem->c[lastD][seed];
//								 seg[numVeh].Trip[l].connectCost = problem->c[lastD][seed];
//								 if (seg[numVeh].Trip[l].waitingS == NO_WS)
//								    seg[numVeh].Trip[l].cost += (problem->c[lastD][seed] - problem->c[lastD][endSP]);
//								 else
//									 seg[numVeh].Trip[l].cost += (problem->c[lastD][seed] - problem->disCWSSP[lastD][endSP]);
//								 startS[seed] = PDS_MAX(seg[numVeh].Trip[l].endS + problem->c[lastD][seed], problem->node[seed].sTW);
//								 depart[seed] = TOTALTIME;
//								 seg[numVeh].Trip[lP].endS = TOTALTIME;
//								 seg[numVeh].Trip[lP].feasible = 1;
//								 seg[numVeh].Trip[lP].Type = 0;
//								 
//								 goWS = goWSMINI;
//
//								 // P2. Continue to insert pickup customers:
//			  					 //starting to find customer to insert into the current trip (startSP, endSP):
//								 bool cont=true;  
//								 do //each loop insert 1 pickup customer
//								 {
//									  insert_after=-1; varcost = PDS_INFINITY;
//									  int lastCP = seg[numVeh].Trip[lP].lastCus;  
//									  for (i=1;i<=numCusPSP[endSP];i++)
//									  {
//											  idCus = CusPSP[endSP][i];
//											  if (!routedTemp[idCus]  && (seg[numVeh].Trip[lP].capacity + problem->node[idCus].capacity <= problem->Q))
//											  {
//												    //1. try to insert pickup idCus at the beginning of the trip:
//													ok=1; nextINS = seg[numVeh].Trip[lP].firstCus;
//													ArrTime = seg[numVeh].Trip[l].endS + problem->c[lastD][idCus];
//													temp = ArrTime - problem->node[idCus].eTW;
//													if (temp > eps) continue; //check another idCus
//													ArrTime = PDS_MAX(ArrTime, problem->node[idCus].sTW) + problem->node[idCus].duration;
//													curC = idCus; nextC = seg[numVeh].Trip[lP].firstCus;
//													while (nextC > 0)
//													{
//														ArrTime += problem->c[curC][nextC];
//														temp = ArrTime - problem->node[nextC].eTW;
//														if (temp > eps) {ok=0;break;} //vioTW at customer nextC
//														else
//														{
//															ArrTime = PDS_MAX(ArrTime, problem->node[nextC].sTW) + problem->node[nextC].duration;
//															curC = nextC; nextC = nextArrTemp[curC];
//														}
//													}
//                                                    if (ok) //curC now points to last pick of trip (numVeh, lP)
//													{
//														ArrTime1 = ArrTime + problem->c[curC][endSP];
//														temp = problem->nodeSP[endSP].eTW1 - ArrTime1;
//														if (temp > eps) //else too late to go to sp directly
//														{
//															 if (PDSINRANGE(ArrTime1,problem->nodeSP[endSP].sTW1, problem->nodeSP[endSP].eTW1))
//																 WSIDtemp = NO_WS;
//															 else
//															 {
//																  ArrTime1 = ArrTime + problem->disCWSSP[curC][endSP];
//																  temp = ArrTime1 - problem->nodeSP[endSP].eTW1;
//																  if (temp > eps) ok=0; //too late to go to sp through WS
//																  else WSIDtemp = problem->CWSSP[curC][endSP];
//															 }
//															 if (ok) //ok to insert idCus at beginning of trip lP
//															 {
//																 c1 = problem->c[lastD][idCus] + problem->c[idCus][nextINS] - problem->c[lastD][nextINS];
//																 if (goWS != WSIDtemp)
//																 {
//																	if (goWS != NO_WS) //before go to WS, after insert don't need to go to WS:
//																		c1 += (problem->c[lastCP][endSP] - problem->disCWSSP[lastCP][endSP]);
//																	else 
//																	{
//																		cout<<"Init_NewSolomonI1_NewDeliveryTrip: ERROR before insert pickup customer go to sp, after insert go to WS "<<WSIDtemp<<endl;
//																		cout<<"Trying to insert pickup cus "<<idCus<<" at the beginning of the: ";
//																		showTripCostTemp(numVeh,lP);
//																		cout<<"lastD = "<<lastD<<endl;
//																		exit(-1);
//																	}
//																}
//																if (c1 < varcost) {varcost=c1; IDinsert=idCus; insert_after = 0;
//																				   WSID=WSIDtemp;TOTALTIME = ArrTime;}  
//															 }
//														}//end if (temp > eps) //else too late to go to sp directly
//													}//end if(ok) else vioTW at some pickup cus
//													
//													//2. Try to insert idCus after each customer j of the trip:
//											        preINS = seg[numVeh].Trip[lP].firstCus; 
//												    ArrTime = seg[numVeh].Trip[l].endS + problem->c[lastD][preINS];
//												   	for (j=1;j<=seg[numVeh].Trip[lP].numCus;j++)
//											        {
//												   		 ok=1;
//														 startSTemp = PDS_MAX(ArrTime, problem->node[preINS].sTW);
//														 ArrTime = startSTemp + problem->node[preINS].duration + problem->c[preINS][idCus];
//														 temp = ArrTime - problem->node[idCus].eTW;
//														 if (temp > eps) break; //vioTW at idCus --> don't need to check any j 
//														 ArrTime = PDS_MAX(ArrTime, problem->node[idCus].sTW) + problem->node[idCus].duration;
//														 //start checking TW from idCus to the end of the leg:
//														 curC = idCus; nextC = nextArrTemp[preINS];
//														 while (nextC > 0)
//														 {
//															 ArrTime += problem->c[curC][nextC]; 
//															 temp = ArrTime - problem->node[nextC].eTW;
//															 if (temp > eps) {ok=0;break;}
//															 else
//															 {
//																 ArrTime = PDS_MAX(ArrTime,problem->node[nextC].sTW) + problem->node[nextC].duration;
//																 curC = nextC; nextC=nextArrTemp[curC];
//															 }
//														 }
//												
//											   			 if (ok) //curC is now pointed to last cus of pickup trip
//														 {
//														         ArrTime1=  ArrTime + problem->c[curC][endSP];
//																 temp = problem->nodeSP[endSP].eTW1 - ArrTime1;
//																 if (temp > eps)//else too late to go to sp directly
//																 {
//																	 if (PDSINRANGE(ArrTime1,problem->nodeSP[endSP].sTW1, problem->nodeSP[endSP].eTW1))
//																		  WSIDtemp=NO_WS;
//																	 else
//																	 {
//																		  ArrTime1 = ArrTime + problem->disCWSSP[curC][endSP];
//																		  temp = ArrTime1 - problem->nodeSP[endSP].eTW1;
//																		  if (temp > eps) ok=0; //too late to go to sp through WS
//																		  else WSIDtemp = problem->CWSSP[curC][endSP];
//																	 }
//																	 if (ok)
//																	 {
//																			 if (j != seg[numVeh].Trip[lP].numCus)								        
//																			 {
//																				 nextINS = nextArrTemp[preINS];
//																				 c1 = problem->c[preINS][idCus] + problem->c[idCus][nextINS] - problem->c[preINS][nextINS];
//																				 if (goWS != WSIDtemp)
//																				 {
//																					 if (goWS != NO_WS) //before go to WS, after insert don't need to go to WS:
//																						 c1 += (problem->c[curC][endSP] - problem->disCWSSP[curC][endSP]);
//																					 else 
//																					 {
//																						 cout<<"Init_NewSolomonI1_NewDeliveryTrip( ERROR before insert go to sp directly, after insert go to WS"<<endl;
//																						 cout<<"Trying to insert pickup "<<idCus<<" after "<<preINS<<": ";
//																						 showTripCostTemp(numVeh,lP);
//																						 exit(-1);
//																					 }
//																				 }
//																			 }
//																			 else //insert to the end of the trip:
//																			 {
//																				 c1 = problem->c[preINS][idCus];
//																				 if (goWS==NO_WS) //before insert customer idCus, go to sp directly
//																				 {
//																					 if (WSIDtemp ==NO_WS) c1 += (problem->c[idCus][endSP] - problem->c[preINS][endSP]);
//																					 else 
//																					 {
//																						 cout<<"Solution::Init_NewSolomonI1_NewDeliveryTrip(  ERROR before insert go to sp directly, after insert need to go to WS"<<endl; 
//																						 cout<<"Trying to insert pickup "<<idCus<<" at the end of the pickup trip: ";
//																						 showTripCostTemp(numVeh,lP);
//																						 exit(-1);
//																					 }
//																				 }
//																				 else //before insert customer idCus, go to WS:
//																				 {
//																					 if (WSIDtemp == NO_WS) c1 += (problem->c[idCus][endSP] - problem->disCWSSP[preINS][endSP]);
//																					 else c1+=(problem->disCWSSP[idCus][endSP] - problem->disCWSSP[preINS][endSP]);
//																				 }
//																			 }
//																			 if (c1 < varcost) {varcost=c1; IDinsert=idCus; insert_after = preINS;WSID=WSIDtemp;TOTALTIME = ArrTime;} 
//																	 }//else too soon to go to sp directly, too late to go to sp through WS
//																 }//else too late to go to sp directly													 						
//														 }//end if (ok) :else vioTW at one customer of route
//											  			 nextINS = nextArrTemp[preINS];
//														 ArrTime = startSTemp + problem->node[preINS].duration + problem->c[preINS][nextINS];
//														 preINS = nextINS;
//												  }//end for (j=1;j<=seg[numVeh].Trip[lP].numCus;j++)
//											  }//end if of each pickup customer: if (!routedPTemp[i] && (seg[numVeh].Trip[lP].capacity + problem->nodeP[i].capacity <= problem->Q))
//									  }//end for
//									  // Now take the best insertion position:
//									  if (insert_after!=-1)
//									  {
//	   										  //cout<<"Insert customer "<<IDinsert<<" after "<<insert_after<<endl;
//											  if (insert_after == 0)
//											  {
//												  int pre = seg[numVeh].Trip[lP].firstCus;
//												  seg[numVeh].Trip[lP].firstCus = IDinsert;
//												  nextArrTemp[IDinsert] = pre;
//												  double deltaCost = problem->c[lastD][IDinsert] - problem->c[lastD][pre];
//												  seg[numVeh].Trip[l].cost += deltaCost;
//												  seg[numVeh].Trip[l].connectCost = problem->c[lastD][IDinsert];
//												  startS[IDinsert] = PDS_MAX(seg[numVeh].Trip[l].endS + problem->c[lastD][IDinsert], problem->node[IDinsert].sTW);
//												  depart[IDinsert] = startS[IDinsert] + problem->node[IDinsert].duration;
//												  updateStartSP_FEASIBLETRIP_Temp(numVeh,lP,IDinsert,pre);
//												  //cout<<"************Insert customer "<<IDinsert<<" beginning of the leg: after delivery cus "<<insert_after<<"; varcost = "<<varcost<<endl;
//												  //cout<<"/endS = "<<TOTALTIME<<"; goWS = "<<WSID<<"; (sTW,eTW)= ("<<problem->nodeD[endSPID].sTW<<", "<<problem->nodeD[endSPID].eTW<<")"<<endl;
//											  }
//											  else if (insert_after == seg[numVeh].Trip[lP].lastCus) //insert at the end of the leg:
//											  {
//												  nextArrTemp[insert_after] = IDinsert;
//												  seg[numVeh].Trip[lP].lastCus = IDinsert;
//												  nextArrTemp[IDinsert]= 0;
//												  ArrTime = depart[insert_after] + problem->c[insert_after][IDinsert];
//												  startS[IDinsert] = PDS_MAX(ArrTime, problem->node[IDinsert].sTW);
//												  depart[IDinsert] = startS[IDinsert] + problem->node[IDinsert].duration;
//												  //cout<"*************Insert customer "<<IDinsert<<" at the end of the leg: after "<<insert_after<<"; varcost = "<<varcost<<endl;
//												  //cout<<"endS = "<<TOTALTIME<<"; goWS = "<<WSID<<"; (sTW,eTW)= ("<<problem->nodeD[endSPID].sTW<<", "<<problem->nodeD[endSPID].eTW<<")"<<endl;
//											  }
//											  else //insert at the middile of the leg:
//											  {
//												  int tt=nextArrTemp[insert_after];
//												  nextArrTemp[insert_after]=IDinsert;
//												  nextArrTemp[IDinsert]=tt;
//												  updateStartSP_FEASIBLETRIP_Temp(numVeh,lP,insert_after,IDinsert);
//												  //cout<<"***********Insert customer "<<IDinsert<<" in the middle of the leg: after "<<insert_after<<"; varcost = "<<varcost<<endl;
//												  //cout<<"endS = "<<TOTALTIME<<"; goWS = "<<WSID<<"; (sTW,eTW)= ("<<problem->nodeD[endSPID].sTW<<", "<<problem->nodeD[endSPID].eTW<<")"<<endl;
//											  }
//											  seg[numVeh].Trip[lP].numCus++;seg[numVeh].Trip[lP].waitingS = WSID;
//											  routedTemp[IDinsert]=1;
//											  seg[numVeh].Trip[lP].capacity += problem->node[IDinsert].capacity;
//											  goWS = WSID;
//											  seg[numVeh].Trip[lP].cost += varcost;
//											  seg[numVeh].Trip[lP].fitness += varcost;
//											  //showTripCostTemp(numVeh,lP);
//											  seg[numVeh].Trip[lP].endS =  TOTALTIME;
//											  
//									   }//end  if (insert_after != -1)
//								       else cont = false; //cannot find any pickup customer to insert into the current trip
//								 }while (cont);//end do each loop insert 1 pickup customer
//
//								 seg[numVeh].Trip[l].connectCost = problem->c[seg[numVeh].Trip[l].lastCus][seg[numVeh].Trip[lP].firstCus];
//								 //cout<<"connectCost @ init_newSolomonI1_NewLeg = "<<seg[numVeh].Trip[l].connectCost<<"; costESP = "<<seg[numVeh].Trip[l].cost;
//								 if (seg[numVeh].Trip[l].waitingS == NO_WS)
//									 seg[numVeh].Trip[l].cost += (seg[numVeh].Trip[l].connectCost - problem->c[seg[numVeh].Trip[l].lastCus][endSP]);
//								 else seg[numVeh].Trip[l].cost += (seg[numVeh].Trip[l].connectCost - problem->disCWSSP[seg[numVeh].Trip[l].lastCus][endSP]);
//								 //cout<<"; cost inc connectCost = "<<seg[numVeh].Trip[l].cost<<endl;
//								 seg[numVeh].Trip[l].waitingS = NO_WS;
//								 seg[numVeh].Trip[lP].cost -= seg[numVeh].Trip[l].connectCost;
//
//								 //Update 11/11/2013: Try to insert C2C between DTrip(numVeh, l) and PTrip(numVeh, lP):
//								 if (numCusC2CRouted < problem->nC2C)
//								 {
//									 //cout<<"-->2. Insert C2C between DTrip("<<numVeh<<", "<<l<<") and PTrip("<<numVeh<<", "<<lP<<")"<<endl;
//									 int lastC_DTrip = seg[numVeh].Trip[l].lastCus;
//									 int firstC_PTrip = seg[numVeh].Trip[lP].firstCus;
//									 double depart_lastC_DTrip = seg[numVeh].Trip[l].endS;
//									 ArrTime = depart_lastC_DTrip + problem->c[lastC_DTrip][firstC_PTrip];
//									 temp = problem->node[firstC_PTrip].sTW - ArrTime;
//									 if (temp > 0) 
//									 {
//										 //Create C2CTrip between DTrip(numVeh, l) and PTrip(numVeh,lP):
//										 CreateC2CTrip_BeforePickupTrip_Temp(numVeh,l,lastC_DTrip,depart_lastC_DTrip,lC2C,l+1,lP,endSP);
//									 }//else can't insert C2C between  DTrip(numVeh, l) and PTrip(numVeh, lP)
//								 }//else can't insert C2C between  DTrip(numVeh, l) and PTrip(numVeh, lP)
//						}//end if (seed != -1)
//						else
//						{
//							//cout<<"-->1. Although exists unrouted pickup customers of endSP "<<endSP<<", can't create pickup trip"<<endl;
//	                        if (numCusDRouted[endSP] >= problem->numCusDSP[endSP]) return; //doesnot exist any unrouted delivery customer in endSP --> don't create this delivery trip, otherwise will create: [startSP - d - endSP - p] or [startSP-d-endSP-endSP1]: mean: does nothing at endSP				   	
//							//Update 11/11/2013: insert C2C between DTrip(numVeh,l) and SP[endSP]:
//							int lastD = seg[numVeh].Trip[l].lastCus;
//							double depart_lastD = seg[numVeh].Trip[l].endS;
//							//cout<<"-->1.1. Try to insert C2C after DTrip("<<numVeh<<", "<<l<<") before endSP = "<<endSP<<endl;
//							bool create = CreateC2CTrip_BeforeSP_Temp(numVeh,l,lastD,depart_lastD,lC2C,l+1,endSP);
//							//seg[numVeh].Trip[l].connectCost = problem->disDWSSP[seg[numVeh].Trip[l].lastCus][endSP];
//						}
//					} //end  if (WS != NO_WS)
//			   	    else
//					{
//                        if (numCusDRouted[endSP] >= problem->numCusDSP[endSP]) return; //doesnot exist any unrouted delivery customer in endSP --> don't create this delivery trip, otherwise will create: [startSP - d - endSP - p] or [startSP-d-endSP-endSP1]: mean: does nothing at endSP				   	
//						seg[numVeh].Trip[l].connectCost = problem->c[seg[numVeh].Trip[l].lastCus][endSP];
//					}
//				}//end if (numCusPRouted[endSP] < numCusPSP[endSP]): endSP still exists unrouted pickup customers
//				else //not exist any unrouted pickup customers --> just create delivery trip: startSP - d - endSP:
//				{
//					if (seg[numVeh].Trip[l].waitingS == NO_WS)
//					{
//						//cout<<"--> 1.JUST CREATE DELIVERY TRIP ("<<numVeh<<", "<<l<<"): startSP = "<<startSP<<", endSP = "<<endSP<<endl;
//						seg[numVeh].Trip[l].connectCost = problem->c[seg[numVeh].Trip[l].lastCus][endSP];
//					}
//					else
//					{
//						//Update 11/11/2013: insert C2C between DTrip(numVeh,l) and SP[endSP]:
//						int lastD = seg[numVeh].Trip[l].lastCus;
//						double depart_lastD = seg[numVeh].Trip[l].endS;
//						//cout<<"-->1. Try to insert C2C after DTrip("<<numVeh<<", "<<l<<") before endSP = "<<endSP<<endl;
//						bool create = CreateC2CTrip_BeforeSP_Temp(numVeh,l,lastD,depart_lastD,lC2C,l+1,endSP);
//						//seg[numVeh].Trip[l].connectCost = problem->disCWSSP[seg[numVeh].Trip[l].lastCus][endSP];
//					}
//				}//end just create delivery trip: startSP - d - endSP
//
//
//	 }
//	 else //B.last leg of segment
//	 {
//			 double costMINI=PDS_INFINITY;
//			 for (idCus=start;idCus<=end;idCus++)
//			 {
//				 if (!routedTemp[idCus])
//				 {
//					  double cc = problem->c[startSP][idCus] + problem->c[idCus][0];
//					  if (cc < costMINI)
//					  {
//						  costMINI = cc;
//						  seed=idCus;
//					  }
//				 }
//			 }
//
//		     routedTemp[seed]=1;
//			 seg[numVeh].Trip[l].firstCus=seed; //id of the first Customer of Leg
//			 seg[numVeh].Trip[l].lastCus=seed; //id of the first Customer of Leg
//			 seg[numVeh].Trip[l].numCus=1; //#Customers in the leg
//			 seg[numVeh].Trip[l].capacity = problem->node[seed].capacity;
//			 nextArrTemp[seed]= 0; //just correct for initial solution
//			 seg[numVeh].Trip[l].cost = costMINI;
//			 seg[numVeh].Trip[l].feasible = 1;
//			 seg[numVeh].Trip[l].Type = 1;
//			 seg[numVeh].Trip[l].waitingS=NO_WS; seg[numVeh].Trip[l].connectCost = 0;
//			 seg[numVeh].Trip[l].endS = PDS_MAX(leave_startSP + problem->c[startSP][seed], problem->node[seed].sTW) + problem->node[seed].duration;
//			 //cout<<" insert firstD "<<seed<<": endS = "<<seg[numVeh].Trip[l].endS<<" = "<<leave_startSP<<" + "<<problem->c[startSP][seed]<<"; "<<problem->node[seed].sTW<<endl;
//			 bool cont=true;
//			 do //each loop insert 1 delivery customer
//			 {
//				 insert_after=-1;c2OPT = -PDS_INFINITY; lastC = seg[numVeh].Trip[l].lastCus;
//				 for (idCus=start;idCus<=end;idCus++)
//				 {
//					 if (!routedTemp[idCus] && (seg[numVeh].Trip[l].capacity + problem->node[idCus].capacity <= problem->Q))
//					 {
//						         //1. try to insert at the beginning of the leg:
//								 ok=1; nextINS = seg[numVeh].Trip[l].firstCus;
//								 ArrTime = leave_startSP + problem->c[startSP][idCus];
//								 temp = ArrTime - problem->node[idCus].eTW;
//								 if (temp > eps) continue; //vioTW at customer idCus --> try another idCus
//								 
//								 ArrTime = PDS_MAX(ArrTime, problem->node[idCus].sTW) + problem->node[idCus].duration;
//								 curC = idCus; nextC = seg[numVeh].Trip[l].firstCus;
//								 for (j=1;j<=seg[numVeh].Trip[l].numCus;j++)
//								 {
//											 ArrTime += problem->c[curC][nextC]; 
//											 temp = ArrTime - problem->node[nextC].eTW;
//											 if (temp > eps) {ok=0;break;} //vioTW at customer nextC
//											 else
//											 {
//													 ArrTime = PDS_MAX(ArrTime,problem->node[nextC].sTW) + problem->node[nextC].duration;
//													 curC = nextC; nextC=nextArrTemp[curC];
//											 }
//								}
//								if (ok)
//							    {
//							         c1 = problem->c[startSP][idCus] + problem->c[idCus][nextINS] - problem->c[startSP][nextINS];
//									 c2 = problem->c[startSP][idCus] - c1;
//								     if (c2 > c2OPT) {c2OPT=c2; varcost=c1; IDinsert=idCus; insert_after = 0;TOTALTIME = ArrTime;/*time to service last customer*/} 
//							    }
//								//2. try to insert customer idCus after each delivery customer j of the trip:
//                                 preINS = seg[numVeh].Trip[l].firstCus;
//								 ArrTime = leave_startSP + problem->c[startSP][preINS];
//								 for (j=1;j<=seg[numVeh].Trip[l].numCus;j++) 
//								 {
//										 ok=1;nextINS = nextArrTemp[preINS];
//									     startSTemp = PDS_MAX(ArrTime, problem->node[preINS].sTW);
//										 ArrTime = startSTemp + problem->node[preINS].duration + problem->c[preINS][idCus];
//										 temp = ArrTime - problem->node[idCus].eTW;
//										 if (temp > eps) break; //vioTW at idCus --> don't need to check any j 
//										 ArrTime = PDS_MAX(ArrTime, problem->node[idCus].sTW) + problem->node[idCus].duration;
//										
//										 //start checking TW from i to the end of the leg:
//										 curC = idCus; nextC = nextINS;
//										 while (nextC > 0)
//										 {
//													 ArrTime += problem->c[curC][nextC]; 
//													 temp = ArrTime - problem->node[nextC].eTW;
//													 if (temp > eps) {ok=0;break;}
//													 else
//													 {
//															 ArrTime = PDS_MAX(ArrTime,problem->node[nextC].sTW) + problem->node[nextC].duration;
//															 curC = nextC; nextC=nextArrTemp[curC];
//													 }
//										 }
//										if (ok) //now curC point to the lastCus
//								        {  
//											if (curC == idCus) //insert idCus at the end of trip:
//											   c1 = problem->c[preINS][idCus] + problem->c[idCus][0] - problem->c[preINS][0];
//											else
//											   c1 = problem->c[preINS][idCus] + problem->c[idCus][nextINS] - problem->c[preINS][nextINS];
//										    c2 = problem->c[idCus][startSP]-c1;
//									        if (c2 > c2OPT) {c2OPT=c2; varcost=c1;IDinsert=idCus; insert_after = preINS; TOTALTIME = ArrTime;} 
//								        }
//										ArrTime = startSTemp + problem->node[preINS].duration + problem->c[preINS][nextINS];
//										preINS = nextINS;
//								 }//end for j
//					 }//end if (!routedDTemp[idCus] && (seg[numVeh].Trip[l].capacity + problem->nodeD[idCus].capacity <= problem->Q))
//				 }//end for (idCus=start;idCus<=end;idCus++)
//				 if (insert_after!=-1)
//			     {
//					  //cout<<"For lastDTrip: Insert customer "<<IDinsert<<" after "<<insert_after<<": ";
//					  if (insert_after == 0)
//					  {
//						  int pre = seg[numVeh].Trip[l].firstCus;
//						  seg[numVeh].Trip[l].firstCus = IDinsert;
//						  nextArrTemp[IDinsert] = pre;
//						  //cout<<"begin of trip; ";
//					  }
//					  else if (insert_after == seg[numVeh].Trip[l].lastCus) //insert at the end of the leg:
//					  {
//		                  nextArrTemp[insert_after] = IDinsert;
//						  seg[numVeh].Trip[l].lastCus=IDinsert;
//						  nextArrTemp[IDinsert]=0;
//						  //cout<<" end of trip; ";
//					  }
//					  else //insert at the middile of the leg:
//					  {
//						  int tt = nextArrTemp[insert_after];
//						  nextArrTemp[insert_after] = IDinsert;
//						  nextArrTemp[IDinsert] = tt;
//						  //cout<<"middle of trip; ";
//					  }
//					  seg[numVeh].Trip[l].numCus++;seg[numVeh].Trip[l].waitingS = NO_WS;
//					  routedTemp[IDinsert] = 1;
//					  seg[numVeh].Trip[l].capacity += problem->node[IDinsert].capacity;
//					  seg[numVeh].Trip[l].endS = TOTALTIME;
//					  //cout<<"TotalTime = "<<TOTALTIME<<endl;
//					  seg[numVeh].Trip[l].cost += varcost;
//			     }
//			     else cont=false; //can't find any customer to insert into the current leg
//			 }while (cont);//end do
//
//
//             //Insert C2C after last DTrip(numVeh,l):
//			 if (numCusC2CRouted < problem->nC2C)
//			 {
//				 double depart_preC = seg[numVeh].Trip[l].endS;
//				 int preC = seg[numVeh].Trip[l].lastCus;
//				 int idCusP, idCusD; 
//                 //First C2C:
//				 costMINI=PDS_INFINITY; double cc;
//				 int seed = -1;
//				 //cout<<"Trying to insert C2C after last Dtrip of ("<<numVeh<<", "<<l<<"): endS = "<<depart_preC<<": ";
//				 for (idCusP = startidC2C; idCusP <= endidC2CP;idCusP++)
//				 {
//					 routedTemp[idCusP] = routed[idCusP];
//					 if (routedTemp[idCusP] == 0)
//					 {
//						 ArrTime = depart_preC + problem->c[preC][idCusP];
//						 temp = ArrTime - problem->node[idCusP].eTW;
//						 if (temp > eps) continue;
//						 idCusD = problem->node[idCusP].delID;
//						 //??Co can check vioTW@ idCusD; hay du lieu da luon dam bao nen ko can check????
//						 cc = problem->c[preC][idCusP] + problem->c[idCusP][idCusD] + problem->c[idCusD][0];
//						 if (cc < costMINI)
//					     { 
//						    costMINI = cc;
//						    seed=idCusP;
//					     }
//					 }
//				 }
//				 //if (seed == -1) cout<<"can't find any C2CP to insert"<<endl;
//				 if (seed != -1)
//				 {
//					 lC2C = l + 1;
//					 idCusD = problem->node[seed].delID;
//					 //cout<<" --> can insert C2C("<<seed<<", "<<idCusD<<")"<<endl;
//					 seg[numVeh].Trip[lC2C].firstCus=seed; //id of the first Customer of Leg
//					 seg[numVeh].Trip[lC2C].lastCus= idCusD; //id of the last Customer of Leg
//					 seg[numVeh].Trip[lC2C].numCus = 2; //#Customers in the leg
//					 nextArrTemp[seed]= idCusD; //just correct for initial solution
//					 routedTemp[seed]=1;routedTemp[idCusD] = 1;
//                     nextArrTemp[idCusD] = 0; pos[seed] = 1; pos[idCusD] = 2;	
//					 FCAP[seed] = problem->node[seed].capacity; FCAP[idCusD] = 0;
//					 seg[numVeh].Trip[lC2C].cost = costMINI - problem->c[preC][seed];
//					 seg[numVeh].Trip[lC2C].feasible = 1;
//					 seg[numVeh].Trip[lC2C].Type = 2;
//					 seg[numVeh].Trip[lC2C].waitingS = NO_WS; 
//					 startS[seed] = PDS_MAX(depart_preC + problem->c[preC][seed], problem->node[seed].sTW);
//					 depart[seed] = startS[seed] + problem->node[seed].duration;
//					 startS[idCusD] = PDS_MAX(depart[seed] + problem->c[seed][idCusD], problem->node[idCusD].sTW);
//					 depart[idCusD] = startS[idCusD] + problem->node[idCusD].duration;
//					 seg[numVeh].Trip[lC2C].endS = depart[idCusD];
//					 /*TOTALTIME = PDS_MAX(depart_preC + problem->c[preC][seed], problem->node[seed].sTW) + problem->node[seed].duration + problem->c[seed][idCusD];
//					 seg[numVeh].Trip[lC2C].endS = PDS_MAX(TOTALTIME, problem->node[idCusD].sTW) + problem->node[idCusD].duration;
//					 */
//					 //seg[numVeh].Trip[l].connectCost = problem->c[preC][seed];
//					 seg[numVeh].Trip[l].cost += (problem->c[preC][seed] - problem->c[preC][0]);
//					 seg[numVeh].Trip[lC2C].capacity = problem->node[seed].capacity;
//                     int numCusC2CRoutedTemp = numCusC2CRouted + 2;
//					 //Now trying to insert more C2C to trip(numVeh,lC2C):
//					 if (numCusC2CRoutedTemp < problem->nC2C)
//					 {
//						 cont = 1; int firstC_C2C,FCAPT, insert_afterP, insert_afterD; 
//						 double depart_idCusP, costT1,costT;
//						 double *departTemp = new double[250];
//				 		 do //each loop insert a pair of C2C
//						 {
//							 IDinsert = -1; costMINI = PDS_INFINITY;
//							 firstC_C2C = seg[numVeh].Trip[lC2C].firstCus;
//							 for (idCusP = startidC2C; idCusP <= endidC2CP; idCusP ++)
//							 {
//								 if (routedTemp[idCusP] == 0)
//								 {
//									 //1. First try to insert at the beginning of the trip:
//									 FCAPT = problem->node[idCusP].capacity;
//									 ArrTime = PDS_MAX(depart_preC + problem->c[preC][idCusP], problem->node[idCusP].sTW); 
//									 temp = ArrTime - problem->node[idCusP].eTW;
//									 if (temp > eps) continue;
//									 //Insert idCusP at the beginning of the trip, now find place to insert idCusD
//									 //1.1 Insert idCusD right after idCusP: then capacity of vehicle is ok since already ok when inserting idCusP
//									 idCusD = problem->node[idCusP].delID;
//									 depart_idCusP = ArrTime + problem->node[idCusP].duration;
//									 ArrTime = depart_idCusP + problem->c[idCusP][idCusD];
//
//									 temp = ArrTime - problem->node[idCusD].eTW;
//									 if (temp > eps) continue;
//									 //cout<<"D rightafter P"<<"; ";
//									 ok = 1;
//									 ArrTime = PDS_MAX(ArrTime, problem->node[idCusD].sTW) + problem->node[idCusD].duration + problem->c[idCusD][firstC_C2C];
//									 costT = problem->c[preC][idCusP] + problem->c[idCusP][firstC_C2C] - problem->c[preC][firstC_C2C];
//									 temp = problem->node[firstC_C2C].eTW - ArrTime;
//									 if (temp > 0) 
//									 {
//										 ArrTime = PDS_MAX(ArrTime, problem->node[firstC_C2C].sTW) + problem->node[firstC_C2C].duration;
//										 curC = firstC_C2C; nextC = nextArrTemp[firstC_C2C];
//										 while (nextC > 0)
//										 {
//											 ArrTime += problem->c[curC][nextC];
//											 temp = ArrTime - problem->node[nextC].eTW;
//											 if (temp > eps) {ok = 0; break;} //vioTW at nextC
//											 else
//											 {
//												 ArrTime = PDS_MAX(ArrTime, problem->node[nextC].sTW) + problem->node[nextC].duration;
//												 curC = nextC; nextC = nextArrTemp[curC];
//											 }
//										 }
//										 if (ok) //curC is now pointed to lastC
//										 {
//											 costT1 = costT + problem->c[idCusP][idCusD] + problem->c[idCusD][firstC_C2C] - problem->c[idCusP][firstC_C2C];
//											 if (costT1 < costMINI)
//											 {
//												 costMINI = costT1;
//												 IDinsert = idCusP;
//												 insert_afterP = 0;
//												 insert_afterD = idCusP;
//											 }
//										 }//end if (ok)
//									 }//else vioTW at firstC_C2C
//			 						 //1.2 Find place to insert idCusD from position after firstC_C2C assuming that idCusP is inserted at the beginning of the trip:
//                                      ok = checkTripTWC2C_Temp(idCusP, depart_idCusP,firstC_C2C,1,departTemp);
//									  if (ok) //TW is ok for all customers in trip C2C after inserting idCusP at the beginning of the trip
//									  {
//										  i = 1; curC = firstC_C2C;
//										  while (i <= seg[numVeh].Trip[lC2C].numCus) //insert idCusD after curC at position i of lC2C
//							              {
//											  //1.2 Insert idCusD right after place i
//											 if (curC < startidC2CD) //curC is a C2CP
//											 {
//												 curC = problem->node[curC].delID;
//												 i = pos[curC];
//											 }
//											 else //curC is a C2CD:
//											 {
//												 idCus = problem->node[curC].pickID;
//												 if (pos[idCus] > 0)
//												 {
//													 //Insert idCusD after curC: check capacity and vioTW
//													 ok = checkCapacity_C2CTrip_InitSol_Temp(firstC_C2C, curC,FCAPT);
//													 if (ok)
//													 {
//														 ArrTime = departTemp[i] + problem->c[curC][idCusD];
//														 temp = problem->node[idCusD].eTW - ArrTime;
//														 if (temp > eps)
//														 {
//															 ArrTime = PDS_MAX(ArrTime, problem->node[idCusD].sTW) + problem->node[idCusD].duration;
//															 costT1 = costT;
//															 nextC = nextArrTemp[curC];
//															 if (nextC > 0)
//															 {
//                                                                   //Update 26/11/2013: need to check vioTW till the end of trip:
//																   int curC1 = idCusD; int nextC1 = nextC;
//																   ok = 1;
//																   do
//																   {
//																 		ArrTime = PDS_MAX(ArrTime + problem->c[curC1][nextC1], problem->node[nextC1].sTW);
//																		if (PDSDIF(ArrTime, startS[nextC1])==0) break;
//																		temp = ArrTime - problem->node[nextC1].eTW;
//																		if (temp > eps) {ok = 0; break;}
//																		ArrTime += problem->node[nextC1].duration;
//																		curC1 = nextC1; nextC1 = nextArrTemp[nextC1];
//																   }while (nextC1 > 0);
//																   if (ok)
//																   {
//																      costT1 += (problem->c[curC][idCusD] + problem->c[idCusD][nextC] - problem->c[curC][nextC]);
//																	  if (costT1 < costMINI)
//																	  {	
//																		 costMINI = costT1;
//																		 IDinsert = idCusP;
//																		 insert_afterP = 0;
//																		 insert_afterD = curC;
//																	  }															
//																   }
//															 }
//															 else
//															 {
//																 costT1 += (problem->c[curC][idCusD] + problem->c[idCusD][0] - problem->c[curC][0]);
//																 if (costT1 < costMINI)
//																 {	
//																	 costMINI = costT1;
//																	 IDinsert = idCusP;
//																	 insert_afterP = 0;
//																	 insert_afterD = curC;
//																 }
//															 }
//														 }//else vioTW at idCusD
//													 }//else not ok capacity of vehicle
//													 i ++; curC = nextArrTemp[curC];
//												 }
//												 else break;
//											 }//end curC is a C2CD
//										  }//end while
//									  }//else TW is NOT ok for all customers in trip C2C after inserting idCusP at the beginning of the trip
//									 
//									 //2. Try to insert in the middle of the trip
//									 preINS = firstC_C2C;
//									 nextINS = nextArrTemp[preINS];
//									 double cStartS;
//									 for (j=1;j<seg[numVeh].Trip[lC2C].numCus;j++) //insert idCusP between preINS and nextINS
//									 {
//										 FCAPT = FCAP[preINS] + problem->node[idCusP].capacity;
//										 if (FCAPT <= problem->Q)
//										 {
//	 										costT = problem->c[preINS][idCusP] + problem->c[idCusP][nextINS] - problem->c[preINS][nextINS];
//											cStartS = depart[preINS] + problem->c[preINS][idCusP];
//											temp = problem->node[idCusP].eTW - cStartS;
//											if (temp > eps)
//											{
//												 depart_idCusP = PDS_MAX(cStartS, problem->node[idCusP].sTW) + problem->node[idCusP].duration;
//												 //2.1 Insert idCusD right after idCusP: don't need to check capacity of vehicle
// 												 ArrTime = PDS_MAX(depart_idCusP + problem->c[idCusP][idCusD], problem->node[idCusD].sTW) + problem->node[idCusD].duration + problem->c[idCusD][nextINS];
//												 temp = problem->node[nextINS].eTW - ArrTime;
//												 if (temp > 0) 
//												 {
//													 ArrTime = PDS_MAX(ArrTime, problem->node[nextINS].sTW) + problem->node[nextINS].duration;
//													 curC = nextINS; nextC = nextArrTemp[nextINS];
//													 ok = 1;
//													 while (nextC > 0)
//													 {
//														 ArrTime += problem->c[curC][nextC];
//														 temp = ArrTime - problem->node[nextC].eTW;
//														 if (temp > eps) {ok = 0; break;} //vioTW at nextC
//														 else
//														 {
//															 ArrTime = PDS_MAX(ArrTime, problem->node[nextC].sTW) + problem->node[nextC].duration;
//															 curC = nextC; nextC = nextArrTemp[curC];
//														 }
//													 }
//													 if (ok) //curC is now pointed to lastC
//													 {
//														 costT1 = costT + problem->c[idCusP][idCusD] + problem->c[idCusD][nextINS] - problem->c[idCusP][nextINS];
//														 if (costT1 < costMINI)
//														 {
//															 costMINI = costT1;
//															 IDinsert = idCusP;
//															 insert_afterP = preINS;
//															 insert_afterD = idCusP;
//														 }
//													 }//end if (ok)
//												 }//else vioTW at cus nextINS
//		 										 //2.2 Find place to insert idCusD from position after nextINS assuming that idCusP is inserted between preINS and nextINS:
//          										 
//												 ok = checkTripTWC2C_Temp(idCusP,depart_idCusP,nextINS,j+1,departTemp);
//												 if (ok) //TW is ok for all customers in trip C2C after inserting idCusP to the trip C2C between preINS and nextINS
//												 {
//													 i = j + 1; curC = nextINS;
//													 while (i <= seg[numVeh].Trip[lC2C].numCus) //insert idCusD after curC at position i of lC2C
//													 {
//														 //2.2 Insert idCusD right after place i:
//														 if (curC < startidC2CD) //curC is a C2CP
//														 {
//															 curC = problem->node[curC].delID;
//															 i = pos[curC];
//														 }
//														 else //curC is a C2CD
//														 {
//															  idCus = problem->node[curC].pickID;
//															  if (pos[idCus] > j)
//															  {
//																  //Insert idCusD after curC: check capacity of vehicle and vioTW
//																  ok = checkCapacity_C2CTrip_InitSol_Temp(nextINS,curC, FCAPT);
//																  if (ok)
//																  {
//																	  ArrTime = departTemp[i] + problem->c[curC][idCusD];
//																	  temp = problem->node[idCusD].eTW - ArrTime;
//																	  if (temp > eps)
//																	  {
//																			 ArrTime = PDS_MAX(ArrTime, problem->node[idCusD].sTW) + problem->node[idCusD].duration;
//																			 costT1 = costT;
//																			 nextC = nextArrTemp[curC];
//																			 if (nextC > 0)
//																			 {
//																				//Update 26/11/2013: need to check vioTW till the end of trip:
//																				 int curC1 = idCusD; int nextC1 = nextC;
//																				 ok = 1;
//																				 do
//																				 {
//																					ArrTime = PDS_MAX(ArrTime + problem->c[curC1][nextC1], problem->node[nextC1].sTW);
//																					if (PDSDIF(ArrTime, startS[nextC1])==0) break;
//																					temp = ArrTime - problem->node[nextC1].eTW;
//																					if (temp > eps) {ok = 0; break;}
//																					ArrTime += problem->node[nextC1].duration;
//																					curC1 = nextC1; nextC1 = nextArrTemp[nextC1];
//																				 }while (nextC1 > 0);
//																				 if (ok)
//																				 {
//																					 costT1 += (problem->c[curC][idCusD] + problem->c[idCusD][nextC] - problem->c[curC][nextC]);
//																					 if (costT1 < costMINI)
//																					 {	
//																						 costMINI = costT1;
//																						 IDinsert = idCusP;
//																						 insert_afterP = preINS;
//																						 insert_afterD = curC;
//																					 }
//																				 }
//																			 }
//																			 else
//																			 {
//																				 costT1 += (problem->c[curC][idCusD] + problem->c[idCusD][0] - problem->c[curC][0]);
//																				 if (costT1 < costMINI)
//																				 {	
//																					 costMINI = costT1;
//																					 IDinsert = idCusP;
//																					 insert_afterP = preINS;
//																					 insert_afterD = curC;
//																				 }
//																			 }
//																	  }//else vioTW at idCusD
//																  }//else vio capacity of vehicle
//																  i++; curC = nextArrTemp[curC];
//															  }
//															  else break;
//														 }//end curC is a C2CD
//													 }//end while
//												 }//else TW is NOT ok for all customers in trip C2C after inserting idCusP to the trip C2C between preINS and nextINS
//											}//else vioTW at idCusP
//										 }//else can't insert between preINS and nextINS due to the capacity of the trip
//										 preINS = nextINS; nextINS = nextArrTemp[preINS];
//									 }//end for j
//
//									 //3. Try to insert at the end of the trip
//									 cStartS = depart[preINS] + problem->c[preINS][idCusP];
//									 temp = problem->node[idCusP].eTW - cStartS;
//									 if (temp > eps)
//									 {
//										 depart_idCusP = PDS_MAX(cStartS, problem->node[idCusP].sTW) + problem->node[idCusP].duration;
//										 //3.1 Insert idCusD right after idCusP:
//										 ArrTime = PDS_MAX(depart_idCusP + problem->c[idCusP][idCusD], problem->node[idCusD].sTW) + problem->node[idCusD].duration;
//										 costT1 = problem->c[preINS][idCusP] + problem->c[idCusP][idCusD] + problem->c[idCusD][0] - problem->c[preINS][0];
//									 	 if (costT1 < costMINI)
//										 {
//											 costMINI = costT1;
//											 IDinsert = idCusP;
//											 insert_afterP = preINS;
//											 insert_afterD = idCusP;
//										 }
//									 }//else vioTW at idCusP
//								 }//else idCusP already routed
//							 }//end for idCusP
//							 if (IDinsert != -1)
//							 {
//								 idCusD = problem->node[IDinsert].delID;
//								 //cout<<"Init_NewSolomonI1_NewDeliveryTrip: Insert C2CP customer "<<IDinsert<<" after "<<insert_afterP<<" and insert C2CD "<<idCusD<<" after "<<insert_afterD<<": "<<endl;
//								 if (insert_afterP == seg[numVeh].Trip[lC2C].lastCus) //insert at the end of the trip:
//								 {
// 									  nextArrTemp[insert_afterP] = IDinsert; 
//									  nextArrTemp[IDinsert] = idCusD; 
//									  seg[numVeh].Trip[lC2C].lastCus = idCusD;nextArrTemp[idCusD] = 0;
//  									  startS[IDinsert] = PDS_MAX(depart[insert_afterP] + problem->c[insert_afterP][IDinsert], problem->node[IDinsert].sTW);
//									  depart[IDinsert] = startS[IDinsert] + problem->node[IDinsert].duration;
//									  FCAP[IDinsert] = problem->node[IDinsert].capacity;
//									  FCAP[idCusD] = 0;
//									  pos[IDinsert] = pos[insert_afterP] + 1; pos[idCusD] = pos[IDinsert] + 1;
//									  startS[idCusD] = PDS_MAX(depart[IDinsert] + problem->c[IDinsert][idCusD], problem->node[idCusD].sTW);
//									  depart[idCusD] = startS[idCusD] + problem->node[idCusD].duration;
//								 }
//								 else //not insert at the end of the trip C2C
//								 {
//									 if (insert_afterP == 0)
//									 {
//										 double deltaCost = problem->c[preC][IDinsert] - problem->c[preC][firstC_C2C];
//										 //seg[numVeh].Trip[l].connectCost = problem->c[preC][IDinsert];
//										 seg[numVeh].Trip[l].cost += deltaCost;
//										 costMINI -= deltaCost;
//										 seg[numVeh].Trip[lC2C].firstCus = IDinsert;
//										 nextArrTemp[IDinsert] = firstC_C2C;
//										 startS[IDinsert] = PDS_MAX(depart_preC + problem->c[preC][IDinsert], problem->node[IDinsert].sTW);
//										 depart[IDinsert] = startS[IDinsert] + problem->node[IDinsert].duration;
//										 pos[IDinsert] = 1;FCAP[IDinsert] = problem->node[IDinsert].capacity;
//									 }
//									 else //insert in the middle
//									 {
// 										  int tt=nextArrTemp[insert_afterP];
//										  nextArrTemp[insert_afterP]=IDinsert;
//										  nextArrTemp[IDinsert]=tt;
//  										  startS[IDinsert] = PDS_MAX(depart[insert_afterP] + problem->c[insert_afterP][IDinsert], problem->node[IDinsert].sTW);
//										  depart[IDinsert] = startS[IDinsert] + problem->node[IDinsert].duration;
//										  pos[IDinsert] = pos[insert_afterP] + 1;
//										  FCAP[IDinsert] = FCAP[insert_afterP] + problem->node[IDinsert].capacity;
//									 }//end insert in the middle
//
//									 if (insert_afterD == IDinsert) //insert idCusD right after idCusP
//									 {
//										 startS[idCusD] = PDS_MAX(depart[IDinsert] + problem->c[IDinsert][idCusD], problem->node[idCusD].sTW);
//										 depart[idCusD] = startS[idCusD] + problem->node[idCusD].duration;
//										 int tt = nextArrTemp[IDinsert];
//										 nextArrTemp[IDinsert] = idCusD; nextArrTemp[idCusD] = tt; 
//										 pos[idCusD] = pos[IDinsert] + 1;
//				 						 FCAP[idCusD] = FCAP[IDinsert] + problem->node[idCusD].capacity;
//									 }
//									 else //insert idCusD after insert_afterD:
//									 {
//										 curC = IDinsert; nextC = nextArrTemp[IDinsert];
//										 do
//										 {
//											 startS[nextC] = PDS_MAX(depart[curC] + problem->c[curC][nextC], problem->node[nextC].sTW);
//											 depart[nextC] = startS[nextC] + problem->node[nextC].duration;
//											 pos[nextC] ++; FCAP[nextC] = FCAP[curC] + problem->node[nextC].capacity;
//											 curC = nextC; nextC = nextArrTemp[curC];
//										 }while (curC != insert_afterD);
//										 //Insert idCusD after insert_afterD:
//										 startS[idCusD] = PDS_MAX(depart[insert_afterD] + problem->c[insert_afterD][idCusD], problem->node[idCusD].sTW);
//										 depart[idCusD] = startS[idCusD] + problem->node[idCusD].duration;
//										 nextArrTemp[idCusD] = nextArrTemp[insert_afterD];
//										 nextArrTemp[insert_afterD] = idCusD; 
//										 pos[idCusD] = pos[insert_afterD] + 1;
//										 FCAP[idCusD] = FCAP[insert_afterD] + problem->node[idCusD].capacity;
//									 }//end insert idCusD after insert_afterD:
//									 nextC = nextArrTemp[idCusD];
//									 if (nextC > 0)
//									 {
//										 //cout<<"Init_NewSolomonI1_NewDeliveryTrip: call updateStartS_pos_FCAP_FEASIBLETRIP_Temp"<<endl;
//										 updateStartS_pos_FCAP_FEASIBLETRIP_Temp(numVeh,lC2C,idCusD,nextC,pos[idCusD]);
//									 }
//									 else seg[numVeh].Trip[lC2C].lastCus = idCusD;
//								 }//end not insert at the end of the trip C2C
//
//								  seg[numVeh].Trip[lC2C].numCus +=2; 
//								  routedTemp[IDinsert] = 1; routedTemp[idCusD] = 1;
//								  numCusC2CRoutedTemp += 2;
//								  if (numCusC2CRoutedTemp == nC2C) cont = 0;
//								  seg[numVeh].Trip[lC2C].cost += costMINI;
//								  seg[numVeh].Trip[lC2C].endS = depart[seg[numVeh].Trip[lC2C].lastCus];
//								  seg[numVeh].Trip[lC2C].capacity += problem->node[IDinsert].capacity;
//							 	  ok = checkC2C_FeasibleTrip_InitSol_Temp(numVeh,lC2C, preC, depart_preC,0,0);
//								  if (ok == 0) exit(-1);
//							 } else cont = 0; //can't route any C2C anymore
//						 }while (cont);
//						 delete [] departTemp;
//					 }//else all C2C are routed
//				 }//else can't create C2C
//			 }//end if (numCusC2CRouted < problem->nC2C)
//	}//end else //B.last leg of segment
//
//	//CalCost of the leg: //seg[numVeh].leg[l].calCost();
//	double fee;
//    if (typeofINIT == 1)
//	{
//			if (endSP==0)
//			{
//				if (lC2C == 0)	fee = seg[numVeh].Trip[l].cost/seg[numVeh].Trip[l].capacity;
//				else fee = (seg[numVeh].Trip[l].cost + seg[numVeh].Trip[lC2C].cost) / (seg[numVeh].Trip[l].capacity + seg[numVeh].Trip[lC2C].capacity);
//			}
//			else
//			{
//				if (lP == 0) //only delivery customer: startSP - delivery - endSP
//				{
//					if (lC2C == 0)
//					{
//				       fee = (problem->nodeSP[endSP].sTW2 - seg[numVeh].Trip[l].endS)/seg[numVeh].Trip[l].capacity;
//				       fee *= seg[numVeh].Trip[l].cost;
//					}
//					else
//					{
//						fee = (problem->nodeSP[endSP].sTW2 - seg[numVeh].Trip[lC2C].endS)/(seg[numVeh].Trip[l].capacity + seg[numVeh].Trip[lC2C].capacity);
//						fee *= (seg[numVeh].Trip[l].cost + seg[numVeh].Trip[lC2C].cost);
//					}
//				}
//				else //create startSP-delivery - pickup-endSP
//				{
//					if (lC2C == 0)
//					{
//						fee = (problem->nodeSP[endSP].sTW1 - seg[numVeh].Trip[lP].endS)/(seg[numVeh].Trip[l].capacity + seg[numVeh].Trip[lP].capacity);
//						//seg[numVeh].Trip[l].cost += (problem->c[seg[numVeh].Trip[l].lastCus][seg[numVeh].Trip[lP].firstCus] - problem->disDWSSP[seg[numVeh].Trip[l].lastCus][endSP]);
//						//seg[numVeh].Trip[lP].cost -= problem->c[seg[numVeh].Trip[l].lastCus][seg[numVeh].Trip[lP].firstCus];
//						fee *= (seg[numVeh].Trip[l].cost + seg[numVeh].Trip[lP].cost);
//					}
//					else
//					{
//						fee = (problem->nodeSP[endSP].sTW1 - seg[numVeh].Trip[lP].endS)/(seg[numVeh].Trip[l].capacity + seg[numVeh].Trip[lC2C].capacity + seg[numVeh].Trip[lP].capacity);
//						fee *= (seg[numVeh].Trip[l].cost + seg[numVeh].Trip[lC2C].cost +  seg[numVeh].Trip[lP].cost);
//					}
//				}
//			}
//	}
//	else if (typeofINIT == 2)
//	{
//			if (endSP==0)
//			{
//				if (lC2C == 0)	fee = seg[numVeh].Trip[l].cost/seg[numVeh].Trip[l].capacity;
//				else fee = (seg[numVeh].Trip[l].cost + seg[numVeh].Trip[lC2C].cost) / (seg[numVeh].Trip[l].capacity + seg[numVeh].Trip[lC2C].capacity);
//			}
//			else
//			{
//				if (lP == 0) //only delivery customer: startSP - delivery - endSP
//				{
//					if (lC2C == 0)
//					{
//						fee = valueFEE*((problem->nodeSP[endSP].sTW2 - seg[numVeh].Trip[l].endS)/seg[numVeh].Trip[l].capacity);
//					    fee += seg[numVeh].Trip[l].cost;
//					}
//					else
//					{
//						fee = valueFEE*((problem->nodeSP[endSP].sTW2 - seg[numVeh].Trip[lC2C].endS)/ (seg[numVeh].Trip[l].capacity) + seg[numVeh].Trip[lC2C].capacity);
//					    fee += (seg[numVeh].Trip[l].cost + seg[numVeh].Trip[lC2C].cost);
//					}
//				}
//				else //create startSP-delivery - pickup-endSP
//				{
//					if (lC2C == 0)
//					{
//				       fee = valueFEE*(problem->nodeSP[endSP].sTW1 - seg[numVeh].Trip[lP].endS)/(seg[numVeh].Trip[l].capacity + seg[numVeh].Trip[lP].capacity);
//					   fee += (seg[numVeh].Trip[l].cost + seg[numVeh].Trip[lP].cost);
//					}
//					else
//					{
//				       fee = valueFEE*(problem->nodeSP[endSP].sTW1 - seg[numVeh].Trip[lP].endS)/(seg[numVeh].Trip[l].capacity + seg[numVeh].Trip[lC2C].capacity + seg[numVeh].Trip[lP].capacity);
//					   fee += (seg[numVeh].Trip[l].cost + seg[numVeh].Trip[lC2C].cost + seg[numVeh].Trip[lP].cost);
//					}
//				}
//			}
//	}
//
//	if (feeMIN > fee)
//	{
//		    feeMIN=fee; int ll = l+3;
//			seg[numVeh].Trip[ll] = seg[numVeh].Trip[l];
//			//cout<<"Update best del cost of ("<<numVeh<<", "<<ll<<") = "<<seg[numVeh].Trip[ll].cost<<" huhuhu = "<<seg[numVeh].Trip[l].cost<<endl;
//			curC = seg[numVeh].Trip[l].firstCus;
//			while (curC >0)
//			{
//				nextArrB[curC] = nextArrTemp[curC];
//				curC = nextArrB[curC];
//			}
//			if (lC2C != 0)
//			{
//				curC = seg[numVeh].Trip[lC2C].firstCus;
//				ll = ll + 1;
//				seg[numVeh].Trip[ll] = seg[numVeh].Trip[lC2C];
//				while (curC > 0)
//				{
//					nextArrB[curC] = nextArrTemp[curC];
//					curC = nextArrB[curC];
//				}
//			}
//			if (lP !=0)
//			{
//				curC = seg[numVeh].Trip[lP].firstCus;
//				seg[numVeh].Trip[lP].duration = seg[numVeh].Trip[lP].endS - seg[numVeh].Trip[ll].endS - problem->c[seg[numVeh].Trip[ll].lastCus][curC];
//				ll ++;
//				seg[numVeh].Trip[ll] = seg[numVeh].Trip[lP];
//				//cout<<"Update d-p trip: costD("<<numVeh<<", "<<(ll-1)<<") = "<<seg[numVeh].Trip[ll-1].cost<<"; Pcost("<<numVeh<<", "<<ll<<") = "<<seg[numVeh].Trip[lP].cost<<endl;
//				while (curC > 0)
//				{
//					nextArrB[curC] = nextArrTemp[curC];
//					curC = nextArrB[curC];
//				}
//				if (lC2C != 0) createTrip = 3; //create d-c2c-p trips 	
//				else createTrip = 1; //create d-p trips
//			} 
//			else 
//			{
//				if (endSP == 0)
//				{
//					if (lC2C != 0) createTrip = 4; //create last (Dtrip + C2C)
//					else createTrip = 0; //create last delivery trip
//				}
//				else  
//				{
//					if (lC2C != 0) createTrip = 5; //create only (DTrip + C2C) -- endSP
//					else createTrip = 2; //create only d trips
//				}
//			}
//		    canRoute = 1; nextSP = endSP;
//	}
//}
//
//
//int Solution::Create_PickupTrip(int idTrip_departSP,int departSP, int &numTrip, double leave_departSP, int &nextSP, int typeofseed, int typeofINIT, int valueFEE)
//{
//	//Create a pickup trip (idVeh, idTrip) that leaves sp departSP where the time to leave departSP is leave_departSP:
//    int endSP;
//	int canRoute = 0;
//	double feeMIN = PDS_INFINITY;
//    bool NULLTrip = 0;
//
//	int idTrip = numTrip+3; //for storing temporary trip during call Init_NewSolomonI1_NewPickupTrip
//	for (endSP=departSP+1; endSP<=nSP;endSP++)
//	  if (numCusPRouted[endSP] < numCusPSP[endSP] || numCusDRouted[endSP] < problem->numCusDSP[endSP]) //exist unrouted customers in sj
//		  Init_NewSolomonI1_NewPickupTrip(idTrip_departSP,departSP, endSP, idTrip,leave_departSP, nextSP, feeMIN, NULLTrip, typeofseed,valueFEE,typeofINIT,canRoute);
// 
//	if (canRoute==0) return 0; //p-departSP is already last trip
//
//	int idB;
//	if (NULLTrip) //p -departSP (-- nextSP)  Note: thing in () is what be created
//	{
//		idB = idTrip + 1;
//		seg[numVeh].Trip[numTrip].connectCost = seg[numVeh].Trip[idB].cost;
//		seg[numVeh].Trip[numTrip].cost += seg[numVeh].Trip[numTrip].connectCost;
//		seg[numVeh].Trip[numTrip].waitingS1 = seg[numVeh].Trip[idB].waitingS;
//		seg[numVeh].Trip[numTrip].arriveSP = seg[numVeh].Trip[idB].leaveSP;
//		//cout<<"CREATING p -departSP (-- nextSP): picktrip("<<numVeh<<", "<<numTrip<<") = "<<seg[numVeh].Trip[numTrip].cost<<endl;
//		return 2;
//	}
//	else 
//	{
//		if (canRoute == 1) //only C2C: p - departSP - (C2C - nextSP)
//		{
//			int preT = numTrip;
//			numTrip ++;  idB = idTrip+1;
//			seg[numVeh].Trip[numTrip] = seg[numVeh].Trip[idB]; //best trip is C2C
//			   
//			//Update all information for new trip:.....
//			int curC = seg[numVeh].Trip[numTrip].firstCus;
//			   
//			seg[numVeh].Trip[preT].connectCost = problem->c[departSP][curC];
//			seg[numVeh].Trip[preT].cost += seg[numVeh].Trip[preT].connectCost;
//			seg[numVeh].Trip[numTrip].cost -= seg[numVeh].Trip[preT].connectCost;
//			  
//			while (curC > 0)
//			{
//				routed[curC]=1;
//				nextArr[curC]=nextArrB[curC];
//				curC = nextArr[curC];
//			}
//			curC = seg[numVeh].Trip[numTrip].lastCus;
//			numCusC2CRouted += seg[numVeh].Trip[numTrip].numCus; 	
//			double ArrTime;
//			if (seg[numVeh].Trip[numTrip].waitingS == NO_WS)
//				 ArrTime = seg[numVeh].Trip[numTrip].endS + problem->c[curC][nextSP];
//			else
//			     ArrTime = seg[numVeh].Trip[numTrip].endS + problem->disCWSSP[curC][nextSP];
//			seg[numVeh].Trip[numTrip].leaveSP = PDS_MAX(ArrTime, problem->nodeSP[nextSP].sTW2);
//			seg[numVeh].Trip[numTrip].arriveSP = seg[numVeh].Trip[numTrip].leaveSP;
//			return 2;
//		}
//		else if (canRoute == 2) //only P: p - departSP - (p - nextSP)
//		{
//			   int preT = numTrip;
//			   numTrip++; idB = idTrip + 2;
//			   seg[numVeh].Trip[numTrip] = seg[numVeh].Trip[idB]; //bestTrip is pickup: 
//			   //cout<<"Create pickup trip ("<<numVeh<<", "<<numTrip<<"): assSP = "<<seg[numVeh].Trip[numTrip].assSP<<endl;
//			  
//			   //Update all information for new trip:.....
//			   int curC = seg[numVeh].Trip[numTrip].firstCus;
//			   
//			   seg[numVeh].Trip[preT].connectCost = problem->c[departSP][curC];
//			   seg[numVeh].Trip[preT].cost += seg[numVeh].Trip[preT].connectCost;
//			   seg[numVeh].Trip[numTrip].cost -= seg[numVeh].Trip[preT].connectCost;
//			   //cout<<"CORRECT COST of pickuptrip("<<numVeh<<", "<<preT<<") = "<<seg[numVeh].Trip[preT].cost<<"; ???nextP cost = "<<seg[numVeh].Trip[numTrip].cost<<endl;
//			  
//			   while (curC > 0)
//			   {
//					routed[curC]=1;
//					nextArr[curC]=nextArrB[curC];
//					curC = nextArr[curC];
//			   }
//			   curC = seg[numVeh].Trip[numTrip].lastCus;
//			   //nextArrP[curC]= 0;
//
//			   numCusPRouted[nextSP] += seg[numVeh].Trip[numTrip].numCus; 	
//			   double ArrTime;
//			   //cout<<"curC = "<<curC<<"; nextSP = "<<nextSP<<endl;
//			   if (seg[numVeh].Trip[numTrip].waitingS == NO_WS)
//				 ArrTime = seg[numVeh].Trip[numTrip].endS + problem->c[curC][nextSP];
//			   else
//				 ArrTime = seg[numVeh].Trip[numTrip].endS + problem->disCWSSP[curC][nextSP];
//			   ArrTime = PDS_MAX(ArrTime, problem->nodeSP[nextSP].sTW1);
//			   seg[numVeh].Trip[numTrip].leaveSP = ArrTime + problem->nodeSP[nextSP].unload;
//			   return 1;
//
//		}
//		else if (canRoute == 3) //create both C2C and P: p - departSP - (C2C - p - nextSP)
//		{
//			int preT = numTrip;
//			numTrip ++;  idB = idTrip+1;
//			seg[numVeh].Trip[numTrip] = seg[numVeh].Trip[idB]; //best trip is C2C
//			   
//			//Update all information for new C2Ctrip:.....
//			int curC = seg[numVeh].Trip[numTrip].firstCus;
//			   
//			seg[numVeh].Trip[preT].connectCost = problem->c[departSP][curC];
//			seg[numVeh].Trip[preT].cost += seg[numVeh].Trip[preT].connectCost;
//			seg[numVeh].Trip[numTrip].cost -= seg[numVeh].Trip[preT].connectCost;
//			  
//			while (curC > 0)
//			{
//				routed[curC]=1;
//				nextArr[curC]=nextArrB[curC];
//				curC = nextArr[curC];
//			}
//			
//			int lastC = seg[numVeh].Trip[numTrip].lastCus;
//			numCusC2CRouted += seg[numVeh].Trip[numTrip].numCus; 	
//
//			//Update PTrip
//			idB++; preT = numTrip; numTrip++;
//			seg[numVeh].Trip[numTrip] = seg[numVeh].Trip[idB]; //bestTrip is pickup: 
//			  
//			//Update all information for new Ptrip:.....
//			curC = seg[numVeh].Trip[numTrip].firstCus;
//			seg[numVeh].Trip[preT].connectCost = problem->c[lastC][curC];
//			  
//			while (curC > 0)
//			{
//					routed[curC]=1;
//					nextArr[curC]=nextArrB[curC];
//					curC = nextArr[curC];
//			}
//			curC = seg[numVeh].Trip[numTrip].lastCus;
//			
//			numCusPRouted[nextSP] += seg[numVeh].Trip[numTrip].numCus; 	
//			double ArrTime;
//			if (seg[numVeh].Trip[numTrip].waitingS == NO_WS)
//				 ArrTime = seg[numVeh].Trip[numTrip].endS + problem->c[curC][nextSP];
//			else
//				 ArrTime = seg[numVeh].Trip[numTrip].endS + problem->disCWSSP[curC][nextSP];
//			ArrTime = PDS_MAX(ArrTime, problem->nodeSP[nextSP].sTW1);
//			seg[numVeh].Trip[numTrip].leaveSP = ArrTime + problem->nodeSP[nextSP].unload;
//			return 1;
//		}
//		return -1;
//	}
//}
//
//void Solution::Init_NewSolomonI1_NewPickupTrip(int idTrip_departSP, int departSP, int endSP, int idTrip, double leave_departSP, int &nextSP, double &feeMIN, bool &NULLTrip, int typeofseed, int valueFEE, int typeofINIT, int &canRoute)
//{
//	bool emptyTrip = 0;
//	double ArrTime, temp;
//	int lC2C = -1, lP = -1;
//	//When calling this procedure, the vehicle already has: ...p-departSP --> call this procedure
//	//to create a trip connecting departSP to endSP:
//	//Create: (1) departSP - p - endSP OR (2) departSP - C2C - p - endSP OR (3) departSP - endSP OR (4) departSP - C2C - endSP
//	
//	//cout<<"Solution::Init_NewSolomonI1_NewPickupTrip departSP = "<<departSP<<"; endSP = "<<endSP<<"; leave_departSP = "<<leave_departSP<<"; eTW = "<<problem->nodeSP[endSP].eTW1<<endl;
//
//	if (numCusPRouted[endSP] < numCusPSP[endSP])
//	{
//			int i, idCus, seed, insert_after, preINS, nextINS, curC, nextC; 
//			int goWS, goWSMINI, WSIDtemp, IDinsert;
//			double startSTemp, ArrTime1, costP, TOTALTIME, varcost,c1;
//			for (i=1;i<=numCusPSP[endSP];i++)
//			{
//				idCus = CusPSP[endSP][i];
//				routedTemp[idCus] = routed[idCus];                       
//			}
//			double costMINI = PDS_INFINITY; seed = -1;
//			//P1.Insert first pickup customer:
//			for (i=1;i<=numCusPSP[endSP];i++)
//			{
//				idCus = CusPSP[endSP][i];
//				if (routedTemp[idCus]==0)
//				{
//					ArrTime = leave_departSP + problem->c[departSP][idCus];
//					temp = ArrTime - problem->node[idCus].eTW;
//					if (temp > eps) continue; //vioTW at idCus--> try another idCus
//					ArrTime = PDS_MAX(ArrTime, problem->node[idCus].sTW) + problem->node[idCus].duration;
//					ArrTime1 = ArrTime + problem->c[idCus][endSP];
//					if (PDSINRANGE(ArrTime1, problem->nodeSP[endSP].sTW1, problem->nodeSP[endSP].eTW1)) 
//					{
//						  goWS=NO_WS;
//						  costP = problem->c[departSP][idCus] + problem->c[idCus][endSP];
//					}
//					else
//					{
//						temp = ArrTime1 - problem->nodeSP[endSP].eTW1;
//						if (temp > eps) continue;
//						ArrTime1 = ArrTime + problem->disCWSSP[idCus][endSP];
//						temp = ArrTime1 - problem->nodeSP[endSP].eTW1;
//						if (temp > eps) continue;
//						goWS = problem->CWSSP[idCus][endSP];
//						costP = problem->c[departSP][idCus] + problem->disCWSSP[idCus][endSP];
//					}
//					if (costP < costMINI)
//					{
//						  seed=idCus;
//						  costMINI = costP;
//						  goWSMINI = goWS;
//						  TOTALTIME = ArrTime;
//					}
//				}
//			}//end for
//     		if (seed != -1) //can insert pickup customer 
//			{
//				routedTemp[seed]=1; lP = idTrip;
//				seg[numVeh].Trip[idTrip].Type = 0;
//				seg[numVeh].Trip[idTrip].assSP = endSP;
//				//cout<<"Pickup seed = "<<seed<<": ASSSP = "<<seg[numVeh].Trip[idTrip].assSP<<endl;
//				seg[numVeh].Trip[idTrip].firstCus = seed; //id of the first Customer of Leg
//				seg[numVeh].Trip[idTrip].lastCus = seed; //id of the first Customer of Leg
//				seg[numVeh].Trip[idTrip].numCus = 1; //#Customers in the leg
//				seg[numVeh].Trip[idTrip].capacity = problem->node[seed].capacity;
//				seg[numVeh].Trip[idTrip].waitingS = goWSMINI;
//				nextArrTemp[seed] = 0; //just correct for initial solution
//				seg[numVeh].Trip[idTrip].cost = costMINI;
//				seg[numVeh].Trip[idTrip].endS = TOTALTIME;
//				seg[numVeh].Trip[idTrip].feasible = 1;
//			    goWS = goWSMINI;
//	
//				// P2. Continue to insert pickup customers:
//				//starting to find customer to insert into the current trip (startSP, endSP):
//				bool cont=true;  
//				int WSID;
//				do //each loop insert 1 pickup customer
//				{
//				    insert_after=-1; varcost = PDS_INFINITY;
//				    int lastCP = seg[numVeh].Trip[idTrip].lastCus;  
//					bool ok; 
//					for (i=1;i<=numCusPSP[endSP];i++)
//					{
//					   idCus = CusPSP[endSP][i];
//					   if (!routedTemp[idCus]  && (seg[numVeh].Trip[idTrip].capacity + problem->node[idCus].capacity <= problem->Q))
//					   {
//						    //1. try to insert pickup idCus at the beginning of the trip:
//							ok=1; nextINS = seg[numVeh].Trip[idTrip].firstCus;
//							ArrTime = leave_departSP + problem->c[departSP][idCus];
//							temp = ArrTime - problem->node[idCus].eTW;
//							if (temp > eps) continue; //check another idCus
//							ArrTime = PDS_MAX(ArrTime, problem->node[idCus].sTW) + problem->node[idCus].duration;
//							curC = idCus; nextC = seg[numVeh].Trip[idTrip].firstCus;
//							while (nextC > 0)
//							{
//								ArrTime += problem->c[curC][nextC];
//								temp = ArrTime - problem->node[nextC].eTW;
//								if (temp > eps) {ok=0;break;} //vioTW at customer nextC
//								else
//								{
//									ArrTime = PDS_MAX(ArrTime, problem->node[nextC].sTW) + problem->node[nextC].duration;
//									curC = nextC; nextC = nextArrTemp[curC];
//								}
//							}
//                            if (ok) //curC now points to last pick of trip (numVeh, l)
//							{
//								ArrTime1 = ArrTime + problem->c[curC][endSP];
//								temp = problem->nodeSP[endSP].eTW1 - ArrTime1;
//								if (temp > eps) //else too late to go to sp directly
//								{
//								   if (PDSINRANGE(ArrTime1,problem->nodeSP[endSP].sTW1, problem->nodeSP[endSP].eTW1))
//									 WSIDtemp = NO_WS;
//								   else
//								   {
//									  ArrTime1 = ArrTime + problem->disCWSSP[curC][endSP];
//									  temp = ArrTime1 - problem->nodeSP[endSP].eTW1;
//									  if (temp > eps) ok=0; //too late to go to sp through WS
//									  else WSIDtemp = problem->CWSSP[curC][endSP];
//								   }
//								   if (ok) //ok to insert idCus at beginning of trip l
//								   {
//								 	  c1 = problem->c[departSP][idCus] + problem->c[idCus][nextINS] - problem->c[departSP][nextINS];
//					                  if (goWS != WSIDtemp)
//									  {
//									  	if (goWS != NO_WS) //before go to WS, after insert don't need to go to WS:
//											c1 += (problem->c[lastCP][endSP] - problem->disCWSSP[lastCP][endSP]);
//										else 
//										{
//											    cout<<"Solution::Init_NewSolomonI1_NewPickupTrip ERROR before insert pickup customer go to sp, after insert go to WS "<<WSIDtemp<<endl;
//												cout<<"Trying to insert pickup cus "<<idCus<<" at the beginning: ";
//												showTripCostTemp(numVeh,idTrip);
//												cout<<"After sp: "<<departSP<<endl;
//												exit(-1);
//										}
//									 }
//									 if (c1 < varcost) {varcost=c1; IDinsert=idCus; insert_after = 0;
//														WSID=WSIDtemp;TOTALTIME = ArrTime;}  
//														}
//								  }//end if (temp > eps) //else too late to go to sp directly
//							}//end if(ok) else vioTW at some pickup cus
//													
//							//2. Try to insert idCus after each customer j of the trip:
//							preINS = seg[numVeh].Trip[idTrip].firstCus; 
//							ArrTime = leave_departSP + problem->c[departSP][preINS];
//							for (int j=1;j<=seg[numVeh].Trip[idTrip].numCus;j++)
//							{
//								ok=1;
//								startSTemp = PDS_MAX(ArrTime, problem->node[preINS].sTW);
//								ArrTime = startSTemp + problem->node[preINS].duration + problem->c[preINS][idCus];
//								temp = ArrTime - problem->node[idCus].eTW;
//								if (temp > eps) break; //vioTW at idCus --> don't need to check any j 
//								ArrTime = PDS_MAX(ArrTime, problem->node[idCus].sTW) + problem->node[idCus].duration;
//								//start checking TW from idCus to the end of the leg:
//								curC = idCus; nextC = nextArrTemp[preINS];
//								while (nextC > 0)
//								{
//									 ArrTime += problem->c[curC][nextC]; 
//									 temp = ArrTime - problem->node[nextC].eTW;
//									 if (temp > eps) {ok=0;break;}
//									 else
//									 {
//										 ArrTime = PDS_MAX(ArrTime,problem->node[nextC].sTW) + problem->node[nextC].duration;
//								    	 curC = nextC; nextC=nextArrTemp[curC];
//									 }
//							    }
//								if (ok) //curC is now pointed to last cus of pickup trip
//								{
//								     ArrTime1=  ArrTime + problem->c[curC][endSP];
//									 temp = problem->nodeSP[endSP].eTW1 - ArrTime1;
//									 if (temp > eps)//else too late to go to sp directly
//									 {
//									     if (PDSINRANGE(ArrTime1,problem->nodeSP[endSP].sTW1, problem->nodeSP[endSP].eTW1))
//											  WSIDtemp=NO_WS;
//										 else
//										 {
//											  ArrTime1 = ArrTime + problem->disCWSSP[curC][endSP];
//											  temp = ArrTime1 - problem->nodeSP[endSP].eTW1;
//											  if (temp > eps) ok=0; //too late to go to sp through WS
//											  else WSIDtemp = problem->CWSSP[curC][endSP];
//										 }
//										 if (ok)
//										 {
//											 if (j != seg[numVeh].Trip[idTrip].numCus)								        
//											 {
//												 nextINS = nextArrTemp[preINS];
//												 c1 = problem->c[preINS][idCus] + problem->c[idCus][nextINS] - problem->c[preINS][nextINS];
//												 if (goWS != WSIDtemp)
//												 {
//													 if (goWS != NO_WS) //before go to WS, after insert don't need to go to WS:
//														 c1 += (problem->c[curC][endSP] - problem->disCWSSP[curC][endSP]);
//													 else 
//													 {
//														 cout<<"Solution::Init_NewSolomonI1_NewPickupTrip ERROR before insert go to sp directly, after insert go to WS"<<endl;
//														 cout<<"Trying to insert pickup "<<idCus<<" after "<<preINS<<": ";
//														 showTripCostTemp(numVeh,idTrip);
//														 exit(-1);
//													 }
//												 }
//											 }
//											 else //insert to the end of the trip:
//											 {
//												 c1 = problem->c[preINS][idCus];
//												 if (goWS==NO_WS) //before insert customer idCus, go to sp directly
//												 {
//													 if (WSIDtemp ==NO_WS) c1 += (problem->c[idCus][endSP] - problem->c[preINS][endSP]);
//													 else 
//													 {
//														 cout<<"Solution::Init_NewSolomonI1_NewPickupTrip  ERROR before insert go to sp directly, after insert need to go to WS"<<endl; 
//														 cout<<"Trying to insert pickup "<<idCus<<" at the end of the pickup trip: ";
//														 showTripCostTemp(numVeh,idTrip);
//														 exit(-1);
//													 }
//												 }
//												 else //before insert customer idCus, go to WS:
//												 {
//												     if (WSIDtemp == NO_WS) c1 += (problem->c[idCus][endSP] - problem->disCWSSP[preINS][endSP]);
//													 else c1+=(problem->disCWSSP[idCus][endSP] - problem->disCWSSP[preINS][endSP]);
//												 }
//											 }
//											 if (c1 < varcost) {varcost=c1; IDinsert=idCus; insert_after = preINS;WSID=WSIDtemp;TOTALTIME = ArrTime;} 
//										 }//else too soon to go to sp directly, too late to go to sp through WS
//									 }//else too late to go to sp directly													 						
//								 }//end if (ok) :else vioTW at one customer of route
//								 nextINS = nextArrTemp[preINS];
//								 ArrTime = startSTemp + problem->node[preINS].duration + problem->c[preINS][nextINS];
//								 preINS = nextINS;
//							}//end for (j=1;j<=seg[numVeh].Trip[lP].numCus;j++)
//					   }//end if of each pickup customer: if (!routedPTemp[i] && (seg[numVeh].Trip[lP].capacity + problem->nodeP[i].capacity <= problem->Q))
//				    }//end for
//				    // Now take the best insertion position:
//					  if (insert_after!=-1)
//					  {
//							  //cout<<"Insert customer "<<IDinsert<<" after "<<insert_after<<endl;
//							  if (insert_after == 0)
//							  {
//								  int pre = seg[numVeh].Trip[idTrip].firstCus;
//								  seg[numVeh].Trip[idTrip].firstCus = IDinsert;
//								  nextArrTemp[IDinsert] = pre;
//								  //cout<<"************Insert customer "<<IDinsert<<" beginning of the leg: after delivery cus "<<insert_after<<"; varcost = "<<varcost<<endl;
//								  //cout<<"/endS = "<<TOTALTIME<<"; goWS = "<<WSID<<"; (sTW,eTW)= ("<<problem->nodeD[endSPID].sTW<<", "<<problem->nodeD[endSPID].eTW<<")"<<endl;
//							  }
//							  else if (insert_after == seg[numVeh].Trip[idTrip].lastCus) //insert at the end of the leg:
//							  {
//								  nextArrTemp[insert_after] = IDinsert;
//								  seg[numVeh].Trip[idTrip].lastCus = IDinsert;
//								  nextArrTemp[IDinsert]= 0;
//								  //cout<<"*************Insert customer "<<IDinsert<<" at the end of the leg: after "<<insert_after<<"; varcost = "<<varcost<<endl;
//								  //cout<<"endS = "<<TOTALTIME<<"; goWS = "<<WSID<<"; (sTW,eTW)= ("<<problem->nodeD[endSPID].sTW<<", "<<problem->nodeD[endSPID].eTW<<")"<<endl;
//							  }
//							  else //insert at the middile of the leg:
//							  {
//								  int tt=nextArrTemp[insert_after];
//								  nextArrTemp[insert_after]=IDinsert;
//								  nextArrTemp[IDinsert]=tt;
//								  //cout<<"***********Insert customer "<<IDinsert<<" in the middle of the leg: after "<<insert_after<<"; varcost = "<<varcost<<endl;
//								  //cout<<"endS = "<<TOTALTIME<<"; goWS = "<<WSID<<"; (sTW,eTW)= ("<<problem->nodeD[endSPID].sTW<<", "<<problem->nodeD[endSPID].eTW<<")"<<endl;
//							  }
//							  seg[numVeh].Trip[idTrip].numCus++;seg[numVeh].Trip[idTrip].waitingS = WSID;
//							  routedTemp[IDinsert]=1;
//							  seg[numVeh].Trip[idTrip].capacity += problem->node[IDinsert].capacity;
//							  goWS = WSID;
//							  seg[numVeh].Trip[idTrip].cost += varcost;
//							  seg[numVeh].Trip[idTrip].endS =  TOTALTIME;
//					   }//end  if (insert_after != -1)
//				       else cont = false; //cannot find any pickup customer to insert into the current trip
//			    }while (cont);//end do each loop insert 1 pickup customer
//				//Try to create C2C between SP: departSP and this PTrip(numVeh, idTrip):
//			    CreateC2CTrip_BeforePickupTrip_Temp(numVeh,idTrip_departSP,departSP,leave_departSP,lC2C,idTrip-1,idTrip,endSP);
//			}//end if (seed != -1)
//			else
//			{
//				/*cout<<"CANNOT create pickup trip connect these sp ("<<departSP<<", "<<endSP<<") even still have "<<(numCusPSP[endSP] - numCusPRouted[endSP])<<" unrouted pickup customers"<<endl;*/
//				if (numCusDRouted[endSP] < problem->numCusDSP[endSP]) //create empty trip departSP (unload) - endSP
//				{
//					//Try to create C2C trip between 2SP: departSP - endSP
//                    bool create = CreateC2CTrip_BeforeSP_Temp(numVeh,idTrip_departSP,departSP,leave_departSP,lC2C,idTrip-1,endSP);
//					if (create == 0) //can;t create C2C:
//					{
//						emptyTrip = 1;
//						ArrTime = seg[numVeh].Trip[idTrip-3].leaveSP + problem->c[departSP][endSP];
//						if (PDSINRANGE(ArrTime, problem->nodeSP[endSP].sTW2, problem->nodeSP[endSP].eTW2))
//						{
//							seg[numVeh].Trip[idTrip].leaveSP = ArrTime;
//							seg[numVeh].Trip[idTrip].waitingS = NO_WS;
//							seg[numVeh].Trip[idTrip].cost = problem->c[departSP][endSP];
//						}
//						else
//						{
//							temp = ArrTime - problem->nodeSP[endSP].eTW2;
//							if (temp > eps) return;
//							ArrTime = seg[numVeh].Trip[idTrip-3].leaveSP + problem->disCWSSP[departSP][endSP];
//							temp = ArrTime - problem->nodeSP[endSP].eTW2;
//							if (temp > eps) return;
//							seg[numVeh].Trip[idTrip].leaveSP = PDS_MAX(ArrTime, problem->nodeSP[endSP].sTW2);
//							seg[numVeh].Trip[idTrip].waitingS = problem->CWSSP[departSP][endSP];
//							seg[numVeh].Trip[idTrip].cost = problem->disCWSSP[departSP][endSP];
//						}
//
//					}
//				}
//				else return;
//			}
//	}
//	else //empty trip: departSP (unload) - endSP
//	{
//		//therefore: numCusDRouted[endSP] < problem->numCusDSP[endSP]:
//		//Try to create C2CTrip between 2SP: departSP-endSP:
//        bool create = CreateC2CTrip_BeforeSP_Temp(numVeh,idTrip_departSP,departSP,leave_departSP,lC2C,idTrip-1,endSP);
//		if (create == 0)
//		{
//			//cout<<"trying to create empty trip connecting SP "<<departSP<<" and SP "<<endSP<<": ";
//			emptyTrip = 1;
//			ArrTime = seg[numVeh].Trip[idTrip-3].leaveSP + problem->c[departSP][endSP];
//			if (PDSINRANGE(ArrTime, problem->nodeSP[endSP].sTW2, problem->nodeSP[endSP].eTW2))
//			{
//				seg[numVeh].Trip[idTrip].leaveSP = ArrTime;
//				seg[numVeh].Trip[idTrip].waitingS = NO_WS;
//				seg[numVeh].Trip[idTrip].cost = problem->c[departSP][endSP];
//				//cout<<"ok directly"<<endl;
//			}
//			else
//			{
//				temp = ArrTime - problem->nodeSP[endSP].eTW2;
//				if (temp > eps) return;
//				ArrTime = seg[numVeh].Trip[idTrip-3].leaveSP + problem->disCWSSP[departSP][endSP];
//				temp = ArrTime - problem->nodeSP[endSP].eTW2;
//				if (temp > eps) return;
//				seg[numVeh].Trip[idTrip].leaveSP = PDS_MAX(ArrTime, problem->nodeSP[endSP].sTW2);
//				seg[numVeh].Trip[idTrip].waitingS = problem->CWSSP[departSP][endSP];
//				seg[numVeh].Trip[idTrip].cost = problem->disCWSSP[departSP][endSP];
//				//cout<<"ok throughWS"<<endl;
//			}
//		}
//	}
//
//	double fee;
//    if (typeofINIT==1)
//	{
//			if (emptyTrip)
//				fee = Q*seg[numVeh].Trip[idTrip].cost;
//			else
//			{
//				if (lC2C != -1 && lP != -1) //Can create (C2C + P):
//				{
//				   fee = (problem->nodeSP[endSP].sTW1 - seg[numVeh].Trip[idTrip].endS) / (seg[numVeh].Trip[lC2C].capacity + seg[numVeh].Trip[idTrip].capacity);
//				   fee *= (seg[numVeh].Trip[lC2C].cost + seg[numVeh].Trip[idTrip].cost);
//				}
//				else if (lC2C == -1) //can create only P:
//				{
//				   fee = (problem->nodeSP[endSP].sTW1 - seg[numVeh].Trip[idTrip].endS) / seg[numVeh].Trip[idTrip].capacity;
//				   fee *= seg[numVeh].Trip[idTrip].cost;
//				}
//				else //can create only C2C
//				{
//				   fee = (problem->nodeSP[endSP].sTW2 - seg[numVeh].Trip[lC2C].endS) / seg[numVeh].Trip[lC2C].capacity;
//				   fee *= seg[numVeh].Trip[lC2C].cost;
//				}
//			}
//	}
//	else if (typeofINIT==2)
//	{
//			if (emptyTrip)
//				fee = Q*seg[numVeh].Trip[idTrip].cost;
//			else
//			{
//				if (lC2C != -1 && lP != -1)
//				{
//				   fee = valueFEE*((problem->nodeSP[endSP].sTW1 - seg[numVeh].Trip[idTrip].endS)/(seg[numVeh].Trip[lC2C].capacity + seg[numVeh].Trip[idTrip].capacity));
//				   fee += (seg[numVeh].Trip[lC2C].cost + seg[numVeh].Trip[idTrip].cost);
//				}
//				else if (lC2C == -1) //can create only P:
//				{
//				   fee = valueFEE*((problem->nodeSP[endSP].sTW1 - seg[numVeh].Trip[idTrip].endS)/seg[numVeh].Trip[idTrip].capacity);
//				   fee += seg[numVeh].Trip[idTrip].cost;
//				}
//				else //create only C2C:
//				{
//				   fee = valueFEE*((problem->nodeSP[endSP].sTW2 - seg[numVeh].Trip[lC2C].endS)/seg[numVeh].Trip[lC2C].capacity);
//				   fee += seg[numVeh].Trip[lC2C].cost;
//				}
//			}
//	}
//
//	if (feeMIN > fee)
//	{
//		    feeMIN=fee; NULLTrip = emptyTrip;
//			int ll; canRoute = 0;
//			if (emptyTrip)
//			{
//				//cout<<"CREATE EMPTY TRIP CONNECTING 2 SP "<<departSP<<" and "<<endSP<<endl;
//				canRoute = 2;
//			}
//			if (lC2C != -1)
//			{
//				ll = idTrip + 1;
//				seg[numVeh].Trip[ll] = seg[numVeh].Trip[lC2C];
//				int curC = seg[numVeh].Trip[lC2C].firstCus;
//				while (curC >0)
//				{
//					nextArrB[curC] = nextArrTemp[curC];
//					curC = nextArrB[curC];
//				}
//				seg[numVeh].Trip[ll].Type = 2; canRoute = 1;
//			}
//			if (lP != -1)
//			{
//				ll = idTrip + 2; if (lC2C == -1) canRoute = 2; else canRoute = 3;
//				seg[numVeh].Trip[ll] = seg[numVeh].Trip[idTrip];
//				int curC = seg[numVeh].Trip[idTrip].firstCus;
//				while (curC >0)
//				{
//					nextArrB[curC] = nextArrTemp[curC];
//					curC = nextArrB[curC];
//				}
//				seg[numVeh].Trip[ll].Type = 0;
//			}
//		    nextSP = endSP;
//	}
//}
//
//
//
//
///********************************************* CALCULATE INFORMATION *****************************************/
//
//void Solution::calCostFromBeginning() //cal from the beginning, don't use calCostTripP, calCostTripD:
//{
//	int idVeh, idTrip,curC, nextC, nextTrip;
//	double cTemp=0; double bucT, costV;
//	//cout<<"=====================   INSIDE calCostFromBeginning ==================="<<endl;
//	for (idVeh=0;idVeh<numVeh;idVeh++)
//	{
//		bucT = cTemp; costV = cTemp;
//		if (seg[idVeh].Trip[0].Type==1) cTemp += problem->c[0][seg[idVeh].Trip[0].assSP];
//		else cTemp += problem->c[0][seg[idVeh].Trip[0].firstCus];
//		bool SAI = 0;
//        for (idTrip=0;idTrip<seg[idVeh].numTrips;idTrip++)
//		{
//			if (seg[idVeh].Trip[idTrip].Type==1) //delivery trip
//			{
//				curC = seg[idVeh].Trip[idTrip].firstCus;
//				cTemp += problem->c[seg[idVeh].Trip[idTrip].assSP][curC];
//				nextC = nextArr[curC];
//				while (nextC > 0)
//				{
//					cTemp += problem->c[curC][nextC];
//					curC = nextC; nextC = nextArr[nextC];
//				}
//				nextTrip = idTrip+1;
//				if (nextTrip < seg[idVeh].numTrips)
//				{
//					if (seg[idVeh].Trip[nextTrip].Type==1) //next trip is delivery trip --> delivery trip - delivery trip:
//					{
//						if (seg[idVeh].Trip[idTrip].waitingS == NO_WS) 
//							 cTemp += problem->c[curC][seg[idVeh].Trip[nextTrip].assSP];
//						else cTemp += problem->disCWSSP[curC][seg[idVeh].Trip[nextTrip].assSP];
//					}
//					else//next trip is pickup trip OR C2C --> delivery trip - pickup trip (OR c2c):
//	                    cTemp += problem->c[curC][seg[idVeh].Trip[nextTrip].firstCus];
//				}
//				else cTemp += problem->c[curC][0];
//				bucT = cTemp - bucT;
//				if (PDSDIF(bucT, seg[idVeh].Trip[idTrip].cost))
//				{
//					cout<<"ERROR cost of Del trip("<<idVeh<<", "<<idTrip<<"): costCorrect = "<<bucT<<"; wrong = "<<seg[idVeh].Trip[idTrip].cost<<endl;
//				    SAI = 1;
//				}
//				bucT = cTemp;
//			}
//			else if (seg[idVeh].Trip[idTrip].Type==0) //pickup trip
//			{
//				curC = seg[idVeh].Trip[idTrip].firstCus;
//				nextC = nextArr[curC];
//				//cout<<"First cus = "<<curC<<"; numC = "<<seg[idVeh].Trip[idTrip].numCus<<";nextC = "<<nextC<<"; ";
//				while (nextC > 0)
//				{
//					cTemp += problem->c[curC][nextC];
//					curC = nextC; nextC = nextArr[nextC];
//				}
//				//cout<<"CurC =  "<<curC<<"; sp = "<<seg[idVeh].Trip[idTrip].assSP<<endl;
//				if (seg[idVeh].Trip[idTrip].waitingS == NO_WS) 
//					cTemp += problem->c[curC][seg[idVeh].Trip[idTrip].assSP];
//				else cTemp += problem->disCWSSP[curC][seg[idVeh].Trip[idTrip].assSP];
//				
//				nextTrip = idTrip + 1;
//				if (nextTrip < seg[idVeh].numTrips)
//				{
//					if (seg[idVeh].Trip[nextTrip].Type==0 || seg[idVeh].Trip[nextTrip].Type == 2) //next trip is pickup trip OR C2C --> pickup trip - pickup trip (OR c2c):
//					{
//						cTemp += problem->c[seg[idVeh].Trip[idTrip].assSP][seg[idVeh].Trip[nextTrip].firstCus];
//					   // cout<<"firstC = "<<seg[idVeh].Trip[nextTrip].firstCus<<"; assSP = "<<seg[idVeh].Trip[idTrip].assSP<<"; dis = "<<problem->cPSP[seg[idVeh].Trip[nextTrip].firstCus][seg[idVeh].Trip[idTrip].assSP]<<"; ";
//					}
//					else if (seg[idVeh].Trip[nextTrip].assSP != seg[idVeh].Trip[idTrip].assSP) //next trip is NULL trip --> pickup - SP - SP':
//					{
//				        if (seg[idVeh].Trip[idTrip].waitingS1 == NO_WS)
//							cTemp += problem->c[seg[idVeh].Trip[idTrip].assSP][seg[idVeh].Trip[nextTrip].assSP];
//						else
//						  cTemp += problem->disCWSSP[seg[idVeh].Trip[idTrip].assSP][seg[idVeh].Trip[nextTrip].assSP];
//					}
//				}
//				else cTemp += problem->c[seg[idVeh].Trip[idTrip].assSP][0];
//				bucT = cTemp - bucT;
//				if (PDSDIF(bucT, seg[idVeh].Trip[idTrip].cost))
//				{
//					cout<<"ERROR cost of Ptrip("<<idVeh<<", "<<idTrip<<"): costCorrect = "<<bucT<<"; wrong = "<<seg[idVeh].Trip[idTrip].cost<<endl;
//                    SAI = 1; 
//				}
//				bucT = cTemp;
//			}
//			else //C2C trip
//			{
//				curC = seg[idVeh].Trip[idTrip].firstCus;
//				nextC = nextArr[curC];
//				//cout<<"First cus = "<<curC<<"; numC = "<<seg[idVeh].Trip[idTrip].numCus<<";nextC = "<<nextC<<"; ";
//				while (nextC > 0)
//				{
//					cTemp += problem->c[curC][nextC];
//					curC = nextC; nextC = nextArr[nextC];
//				}
//			
//				nextTrip = idTrip + 1;
//				if (nextTrip < seg[idVeh].numTrips)
//				{
//					if (seg[idVeh].Trip[nextTrip].Type==0) //next trip is pickup trip --> C2C - pickup trip:
//					{
//						cTemp += problem->c[curC][seg[idVeh].Trip[nextTrip].firstCus];
//					}
//					else if (seg[idVeh].Trip[nextTrip].Type == 1) //next trip is delivery trip --> C2C - (SP-d):
//					{
//				        if (seg[idVeh].Trip[idTrip].waitingS == NO_WS)
//							cTemp += problem->c[curC][seg[idVeh].Trip[nextTrip].assSP];
//						else
//						  cTemp += problem->disCWSSP[curC][seg[idVeh].Trip[nextTrip].assSP];
//					}
//					else cout<<"ERROR: curTrip is C2C, nextTrip is also C2C"<<endl;
//				}
//				else cTemp += problem->c[curC][0];
//				bucT = cTemp - bucT;
//				if (PDSDIF(bucT, seg[idVeh].Trip[idTrip].cost))
//				{
//					SAI = 1;
//					cout<<"ERROR cost of C2Ctrip("<<idVeh<<", "<<idTrip<<"): costCorrect = "<<bucT<<"; wrong = "<<seg[idVeh].Trip[idTrip].cost<<endl;
//				}
//				bucT = cTemp;
//			}
//		}
//		/*if (SAI == 0) 
//		{
//			costV = cTemp - costV;
//			cout<<" COST OK WITH VEHICLE "<<idVeh<<": cost = "<<costV<<endl;
//		}*/
//	}
//   	cost = cTemp;
//}


//void Solution::CalInfromationTripD(int idVeh, int idTrip) 
//{
//	int startSP = seg[idVeh].Trip[idTrip].assSP; 
//   	int nextTrip = idTrip + 1;
//
//	double cArrTime, cArrTimeI;
//	int curC, nextC;
//	int i;
//	double temp, tempC;
//
//    //Update coordinate, leaveSP, 
//	//Update predArrD, route_numD, trip_numD, posD, 
//	//startSD, departD, waitTimeD, FvioTWCusD, vioTWCusD, vioCAP, vioTWSP
//	//FCAPD, BCAPD
//	//connectCost, cost, fitness, leaveSP,  endS,waitingS, arriveSP (if avail:SP-d-SP)
//
//	if (idTrip==0)
//	{
//		seg[idVeh].Trip[idTrip].coordinate = 0;
//		seg[idVeh].Trip[idTrip].leaveSP = problem->leaveSP[startSP][4]; //just load
//		seg[idVeh].Trip[idTrip].vioTWSP = 0;
//		tempC = problem->c[0][startSP];
//	}
//	else tempC =0 ;
//
//
//		//Create predArr:
//		curC = seg[idVeh].Trip[idTrip].firstCus;
//		predArr[curC]=-1;
//		route_num[curC] = idVeh; trip_num[curC] = idTrip; pos[curC] = 1;
//
//		//Update startS and waitTime for each customer:
//    	cArrTime = seg[idVeh].Trip[idTrip].leaveSP + problem->c[startSP][curC];
//		vioTWCus[curC] = PDS_MAX(0, cArrTime - problem->node[curC].eTW);
//		FvioTWCus[curC] = vioTWCus[curC];
//        if (vioTWCus[curC] > eps)
//		{
//			startS[curC] = problem->node[curC].eTW;
//			depart[curC] = problem->node[curC].eTW + problem->node[curC].duration;
//		}
//		else
//		{
//		    startS[curC] = PDS_MAX(cArrTime, problem->node[curC].sTW);
//		    depart[curC] = startS[curC] + problem->node[curC].duration;
//		}
//		FCAP[curC] = problem->node[curC].capacity;
//		nextC = nextArr[curC];
//		tempC += problem->c[startSP][curC];
//		//cout<<"CurCost = "<<tempC<<endl;
//		
//		int numC = seg[idVeh].Trip[idTrip].numCus; 
//		for (i=2;i<=numC;i++)
//		{
//			predArr[nextC] = curC; route_num[nextC] = idVeh; trip_num[nextC] = idTrip;
//			pos[nextC] = i; FCAP[nextC] = FCAP[curC] + problem->node[nextC].capacity;
//			cArrTime = depart[curC] + problem->c[curC][nextC];
//			vioTWCus[nextC] = PDS_MAX(0, cArrTime - problem->node[nextC].eTW);
//            if (vioTWCus[nextC] > eps)
//			{
//				FvioTWCus[nextC] = FvioTWCus[curC] + vioTWCus[nextC];
//				startS[nextC] = problem->node[nextC].eTW;
//				depart[nextC] = problem->node[nextC].depart;
//			}
//			else
//			{
//			    FvioTWCus[nextC] = FvioTWCus[curC];
//				startS[nextC] = PDS_MAX(cArrTime, problem->node[nextC].sTW);
//			    depart[nextC] = startS[nextC] + problem->node[nextC].duration;
//			}
//			tempC += problem->c[curC][nextC];
//			curC = nextC; nextC=nextArr[curC];
//		}
//		nextArr[curC] = -1;
//
//		if (PDSDIF(depart[curC], seg[idVeh].Trip[idTrip].endS))
//		{
//			cout<<"ERROR CalInfromationTripD("<<idVeh<<", "<<idTrip<<"): correct endS = "<<depart[curC]<<"; wrong from init sol= "<<seg[idVeh].Trip[idTrip].endS<<"; leave_startSP = "<<seg[idVeh].Trip[idTrip].leaveSP<<endl;
//			exit(-1);
//		}
//		seg[idVeh].Trip[idTrip].endS = depart[curC];
//		seg[idVeh].Trip[idTrip].vioTWC = FvioTWCus[curC];
//		seg[idVeh].Trip[idTrip].vioCAP = PDS_MAX(FCAP[curC] - Q,0);
//
//		if (nextTrip < seg[idVeh].numTrips) //idTrip is not the last trip
//		{
//			if (seg[idVeh].Trip[nextTrip].Type == 1) //next trip is delivery trip
//			{	
//				seg[idVeh].Trip[nextTrip].coordinate = 0;
//				int nextSP = seg[idVeh].Trip[nextTrip].assSP;
//				cArrTime = depart[curC] + problem->c[curC][nextSP];
//				if (PDSINRANGE(cArrTime, problem->nodeSP[nextSP].sTW2, problem->nodeSP[nextSP].eTW2))
//				{
//					if (seg[idVeh].Trip[idTrip].waitingS != NO_WS)
//					{	cout<<"Solution::CalInfromationTripD("<<idVeh<<", "<<idTrip<<") ERRROR: correct: noWS, wrong from init sol: waitS = "<<seg[idVeh].Trip[idTrip].waitingS<<endl;exit(-1);}
//					seg[idVeh].Trip[idTrip].waitingS = NO_WS;
//					seg[idVeh].Trip[idTrip].connectCost = problem->c[curC][nextSP];
//					seg[idVeh].Trip[idTrip].arriveSP = cArrTime;
//
//					seg[idVeh].Trip[nextTrip].leaveSP = cArrTime + problem->nodeSP[nextSP].load;
//					seg[idVeh].Trip[nextTrip].vioTWSP = 0;
//				}
//				else
//				{
//					temp = cArrTime - problem->nodeSP[nextSP].eTW2;
//					if (temp > eps) //too late to go to sp directly:
//					{
//						if (seg[idVeh].Trip[idTrip].waitingS != NO_WS)
//						{	cout<<"Solution::CalInfromationTripD("<<idVeh<<", "<<idTrip<<" ERRROR: correct: noWS, wrong from init sol: waitS = "<<seg[idVeh].Trip[idTrip].waitingS<<endl;exit(-1);}
//						seg[idVeh].Trip[idTrip].waitingS = NO_WS;
//						seg[idVeh].Trip[idTrip].connectCost = problem->c[curC][nextSP];
//						seg[idVeh].Trip[idTrip].arriveSP = problem->nodeSP[nextSP].eTW2;
//
//						seg[idVeh].Trip[nextTrip].leaveSP = problem->leaveSP[nextSP][1]; //just load at eTW2
//						seg[idVeh].Trip[nextTrip].vioTWSP = temp;
//					}
//					else // too soon to go to sp directly:
//					{
//						cArrTimeI = depart[curC] + problem->disCWSSP[curC][nextSP];
//						temp = cArrTimeI - problem->nodeSP[nextSP].eTW2;
//						if (temp > eps) // too soon to go to sp directly, too late to go through WS: --> go to sp directly INFEASIBILITY
//						{
//							if (seg[idVeh].Trip[idTrip].waitingS != NO_WS)
//							{	cout<<"Solution::CalInfromationTripD("<<idVeh<<", "<<idTrip<<") ERRROR: correct: NO_WS, wrong from init sol: waitS = "<<seg[idVeh].Trip[idTrip].waitingS<<endl;exit(-1);}
//							seg[idVeh].Trip[idTrip].waitingS = NO_WS;
//							seg[idVeh].Trip[idTrip].connectCost = problem->c[curC][nextSP];
//							seg[idVeh].Trip[idTrip].arriveSP = problem->nodeSP[nextSP].eTW2;
//
//							seg[idVeh].Trip[nextTrip].leaveSP = problem->leaveSP[nextSP][1]; //just load at eTW2
//							seg[idVeh].Trip[nextTrip].vioTWSP = problem->nodeSP[nextSP].sTW2 - cArrTime;
//						}
//						else //go to sp through WS: feasibility
//						{
//							if (seg[idVeh].Trip[idTrip].waitingS != problem->CWSSP[curC][nextSP])
//							{	cout<<"Solution::CalInfromationTripD("<<idVeh<<", "<<idTrip<<") ERRROR: correct: "<<problem->CWSSP[curC][nextSP]<<", wrong from init sol: waitS = "<<seg[idVeh].Trip[idTrip].waitingS<<endl;exit(-1);}
//
//							seg[idVeh].Trip[idTrip].waitingS = problem->CWSSP[curC][nextSP];
//							seg[idVeh].Trip[idTrip].connectCost = problem->disCWSSP[curC][nextSP];
//							seg[idVeh].Trip[idTrip].arriveSP = PDS_MAX(cArrTimeI, problem->nodeSP[nextSP].sTW2);
//						
//							seg[idVeh].Trip[nextTrip].leaveSP = seg[idVeh].Trip[idTrip].arriveSP + problem->nodeSP[nextSP].load; //just load
//							seg[idVeh].Trip[nextTrip].vioTWSP = 0;
//						}
//					}
//				}
//				//seg[idVeh].Trip[idTrip].arriveSP = PDS_MAX(depart[curC] + seg[idVeh].Trip[idTrip].connectCost, problem->nodeSP[startSP].sTW2);
//			}
//			else  //next trip is pickup trip / C2C trip
//			{
//				seg[idVeh].Trip[nextTrip].coordinate = 0;
//				seg[idVeh].Trip[idTrip].waitingS = NO_WS;
//				seg[idVeh].Trip[idTrip].connectCost = problem->c[curC][seg[idVeh].Trip[nextTrip].firstCus];
//			}
//		}
//		else seg[idVeh].Trip[idTrip].connectCost = problem->c[curC][0]; //lastTrip --> connectCost = dis(lastCus, depot)
//		tempC += seg[idVeh].Trip[idTrip].connectCost;
//		seg[idVeh].Trip[idTrip].cost = tempC;
//
//		
//		seg[idVeh].Trip[idTrip].fitness = tempC + COEFCAP * seg[idVeh].Trip[idTrip].vioCAP + COEFTWC * seg[idVeh].Trip[idTrip].vioTWC + COEFTWSP * seg[idVeh].Trip[idTrip].vioTWSP;
//	 
//		int lC = seg[idVeh].Trip[idTrip].lastCus; int BCTemp=0; double BvioTWTemp = 0;
//		for (int kk=1; kk <= numC; kk++)
//		{
//		   BCTemp += problem->node[lC].capacity;
//		   BCAP[lC] = BCTemp;
//		   BvioTWTemp += vioTWCus[lC];
//		   BvioTWCus[lC] = BvioTWTemp;
//		   lC = predArr[lC];
//		}
//}
//


//void Solution::checkEndSFirstPT(int idVeh) 
//{
//	int assSP = seg[idVeh].Trip[0].assSP; 
//
//	double cArrTime;
//	int curC, nextC; double departT;
//	int i;
//
//	curC = seg[idVeh].Trip[0].firstCus;
//
//
//	cArrTime = PDS_MAX(problem->c[0][curC], problem->node[curC].sTW);
//	//Update startS and waitTime for each customer:
//	double vioTWCT = PDS_MAX(0, cArrTime - problem->node[curC].eTW);
//	if (vioTWCT > eps) departT = problem->node[curC].depart;
//	else departT = PDS_MAX(cArrTime, problem->node[curC].sTW) + problem->node[curC].duration;
//	nextC = nextArr[curC];
//
//
//		
//	int numC = seg[idVeh].Trip[0].numCus; 
//	for (i=2;i<=numC;i++)
//	{
//		cArrTime = departT + problem->c[curC][nextC];
//		vioTWCT = PDS_MAX(0, cArrTime - problem->node[nextC].eTW);
//        if (vioTWCT > eps)
//			departT = problem->node[nextC].depart;
//		else
//			departT = PDS_MAX(cArrTime, problem->node[nextC].sTW) + problem->node[nextC].duration;
//		curC = nextC; nextC=nextArr[curC];
//	}
//
//	if (PDSDIF(departT, seg[idVeh].Trip[0].endS))
//	{
//		cout<<"ERROR checkEndSFirstPT("<<idVeh<<"): correct endS = "<<departT<<"; wrong from init sol= "<<seg[idVeh].Trip[0].endS<<endl;
//		cout<<"depart[lastC = "<<curC<<"] = "<<departT<<"; c(0, lastC) = "<<problem->c[0][curC]<<"; c(lastC, sp) = "<<problem->c[curC][assSP]<<",c(lastC, WS, sp) = "<<problem->disCWSSP[curC][assSP]<<endl;
//		cout<<"[sTW,eTW] of cus = ["<<problem->node[curC].sTW<<", "<<problem->node[curC].eTW<<"], dur = "<<problem->node[curC].duration<<endl;
//		cout<<"sp[sTW1, eTW1] = ["<<problem->nodeSP[assSP].sTW1<<", "<<problem->nodeSP[assSP].eTW1<<"]"<<endl;
//		showTripCus(idVeh, 0);
//		exit(-1);
//   }
//}
//void Solution::CalInfromationTripP(int idVeh, int idTrip) 
//{
//	int assSP = seg[idVeh].Trip[idTrip].assSP; 
//   	int nextTrip = idTrip + 1;
//
//	double cArrTime, cArrTimeI;
//	int curC, nextC;
//	int i;
//	double temp, tempC;
//
//	//Update predArrP, route_numP, trip_numP, posP, 
//	//startSP, departP, waitTimeP, vioTWCusP
//	//endS, leaveSP, arriveSP (if avail:SP-d-SP)
//	//FCAPP, BCAPP
//	//connectCost, cost, fitness, vioTWSP, vioTWC, vioCAP, FvioTWC
//
//	//Create predArr:
//	curC = seg[idVeh].Trip[idTrip].firstCus;
//	predArr[curC]=-1;
//	route_num[curC] = idVeh; trip_num[curC] = idTrip; pos[curC] = 1;
//
//	if (idTrip==0)
//	{
//		/*cArrTime = problem->node[curC].sTW + problem->node[curC].duration + problem->c[curC][assSP];
//        if (PDSINRANGE(cArrTime, problem->nodeSP[assSP].sTW1, problem->nodeSP[assSP].eTW1))
//	        cArrTime = problem->node[curC].sTW;
//		else
//		{
//			 cArrTime = problem->node[curC].sTW + problem->node[curC].duration + problem->disCWSSP[curC][assSP];
//			 double temp = cArrTime - problem->nodeSP[assSP].eTW1;
//			 if (temp > eps)
//				 cArrTime = problem->nodeSP[assSP].eTW1 - problem->node[curC].duration - problem->c[curC][assSP];
//			 else
//		       cArrTime = problem->node[curC].sTW;
//		}*/
//		if (seg[idVeh].Trip[idTrip].numCus == 1)
//		{
//			/*cout<<"P("<<idVeh<<", "<<idTrip<<"): numC = 1; ";
//		    tempC = problem->c[0][curC];
//			cArrTime = PDS_MAX(problem->c[0][curC], problem->node[curC].sTW);
//			double ArrTime = cArrTime + problem->node[curC].duration + problem->c[curC][assSP];
//			if (!PDSINRANGE(ArrTime, problem->nodeSP[assSP].sTW1, problem->nodeSP[assSP].eTW1))
//			{
//				 //Arrive here means: ArrTime < sTW1
//				 double cArrTime1 = problem->nodeSP[assSP].sTW1 - problem->c[curC][assSP] - problem->node[curC].duration;
//				 if (PDSINRANGE(cArrTime1, problem->node[curC].sTW, problem->node[curC].eTW))
//				 {
//					cArrTime = cArrTime1;
//					cout<<"cArrTime = "<<cArrTime<<endl;
//					seg[idVeh].Trip[0].waitingS = NO_WS;
//				 }
//				 else
//				 {			 
//					 ArrTime = cArrTime + problem->node[curC].duration + problem->disCWSSP[curC][assSP];
//				     double tt = ArrTime - problem->nodeSP[assSP].eTW1;
//				     if (tt > eps) //too soon to sp directly, too late through WS:
//					 { 
//						 cout<<"EXIT: vioTWCus "<<curC<<" arrive at sp "<<assSP<<endl;
//						 exit(-1);
//					 }
//					 else
//					 {
//						 cout<<"through wS: tt = "<<tt<<"; cArrTime = "<<cArrTime<<"; ArrTime = "<<ArrTime<<"; eTW1 = "<<problem->nodeSP[assSP].eTW1<<endl;
//	     				 seg[idVeh].Trip[0].waitingS = problem->CWSSP[curC][assSP];
//					 }
//				 }
//			}
//			else 
//			{
//				cout<<"go to sp directly"<<endl;
//				seg[idVeh].Trip[0].waitingS = NO_WS;
//			}*/
//			tempC = problem->c[0][curC];
//			vioTWCus[curC] = 0;
//			FvioTWCus[curC] = vioTWCus[curC];
//			startS[curC] = problem->startSOneP[curC][assSP];
//			depart[curC] = startS[curC] + problem->node[curC].duration;
//			FCAP[curC] = problem->node[curC].capacity;
//		}
//		else
//		{
//			cArrTime = PDS_MAX(problem->c[0][curC], problem->node[curC].sTW);
//		    tempC = problem->c[0][curC];
//			//Update startS and waitTime for each customer:
//			vioTWCus[curC] = PDS_MAX(0, cArrTime - problem->node[curC].eTW);
//			FvioTWCus[curC] = vioTWCus[curC];
//			if (vioTWCus[curC] > eps)
//			{
//					startS[curC] = problem->node[curC].eTW;
//					depart[curC] = startS[curC] + problem->node[curC].duration;
//			}
//			else
//			{
//					startS[curC] = PDS_MAX(cArrTime, problem->node[curC].sTW);
//					depart[curC] = startS[curC] + problem->node[curC].duration;
//			}
//			FCAP[curC] = problem->node[curC].capacity;
//			nextC = nextArr[curC];
//		}
//	}
//	else
//	{
//		tempC = 0;
//	    int preT = idTrip - 1;
//		if (seg[idVeh].Trip[preT].Type == 0)
//			cArrTime = seg[idVeh].Trip[preT].leaveSP + problem->c[seg[idVeh].Trip[preT].assSP][curC];
//		else //if (seg[idVeh].Trip[preT].Type == 1 || 2)
//		    cArrTime = seg[idVeh].Trip[preT].endS + problem->c[seg[idVeh].Trip[preT].lastCus][curC];
//		//Update startS and waitTime for each customer:
//		vioTWCus[curC] = PDS_MAX(0, cArrTime - problem->node[curC].eTW);
//		FvioTWCus[curC] = vioTWCus[curC];
//		if (vioTWCus[curC] > eps)
//		{
//				startS[curC] = problem->node[curC].eTW;
//				depart[curC] = startS[curC] + problem->node[curC].duration;
//		}
//		else
//		{
//				startS[curC] = PDS_MAX(cArrTime, problem->node[curC].sTW);
//				depart[curC] = startS[curC] + problem->node[curC].duration;
//		}
//		FCAP[curC] = problem->node[curC].capacity;
//		//cout<<curC<<"(depart = "<<depart[curC]<<"); ";
//		nextC = nextArr[curC];
//	}
//
//
//
//		
//		int numC = seg[idVeh].Trip[idTrip].numCus; 
//		for (i=2;i<=numC;i++)
//		{
//			predArr[nextC] = curC; route_num[nextC] = idVeh; trip_num[nextC] = idTrip;
//			pos[nextC] = i; FCAP[nextC] = FCAP[curC] + problem->node[nextC].capacity;
//			cArrTime = depart[curC] + problem->c[curC][nextC];
//			vioTWCus[nextC] = PDS_MAX(0, cArrTime - problem->node[nextC].eTW);
//            if (vioTWCus[nextC] > eps)
//			{
//				FvioTWCus[nextC] = FvioTWCus[curC] + vioTWCus[nextC];
//				startS[nextC] = problem->node[nextC].eTW;
//				depart[nextC] = problem->node[nextC].depart;
//				//cout<<nextC<<"(depart = "<<depart[nextC]<<", vio ="<<vioTWCus[nextC]<<", eTW = "<<problem->node[nextC].eTW<<"); ";
//			}
//			else
//			{
//			    FvioTWCus[nextC] = FvioTWCus[curC];
//				startS[nextC] = PDS_MAX(cArrTime, problem->node[nextC].sTW);
//			    depart[nextC] = startS[nextC] + problem->node[nextC].duration;
//				//cout<<nextC<<"(depart = "<<depart[nextC]<<", vio=0); ";
//			}
//			tempC += problem->c[curC][nextC];
//			curC = nextC; nextC=nextArr[curC];
//		}
//		nextArr[curC] = -1;
//		//cout<<endl;
//
//		if (PDSDIF(depart[curC], seg[idVeh].Trip[idTrip].endS))
//		{
//			cout<<"ERROR CalInfromationTripP("<<idVeh<<", "<<idTrip<<"): correct endS = "<<depart[curC]<<"; wrong from init sol= "<<seg[idVeh].Trip[idTrip].endS<<endl;
//			cout<<"depart[lastC = "<<curC<<"] = "<<depart[curC]<<"; c(0, lastC) = "<<problem->c[0][curC]<<"; c(lastC, sp) = "<<problem->c[curC][assSP]<<",c(lastC, WS, sp) = "<<problem->disCWSSP[curC][assSP]<<endl;
//			cout<<"[sTW,eTW] of cus = ["<<problem->node[curC].sTW<<", "<<problem->node[curC].eTW<<"], dur = "<<problem->node[curC].duration<<endl;
//			cout<<"sp[sTW1, eTW1] = ["<<problem->nodeSP[assSP].sTW1<<", "<<problem->nodeSP[assSP].eTW1<<"]"<<endl;
//			showTripCus(idVeh, idTrip);
//			exit(-1);
//		}
//
//		seg[idVeh].Trip[idTrip].endS = depart[curC];
//		seg[idVeh].Trip[idTrip].vioTWC = FvioTWCus[curC];
//		seg[idVeh].Trip[idTrip].vioCAP = PDS_MAX(FCAP[curC] - Q,0);
//
//		cArrTime = depart[curC] + problem->c[curC][assSP];
//		if (PDSINRANGE(cArrTime, problem->nodeSP[assSP].sTW1, problem->nodeSP[assSP].eTW1))
//		{
//			seg[idVeh].Trip[idTrip].vioTWSP = 0;
//			if (seg[idVeh].Trip[idTrip].waitingS != NO_WS)
//			{	
//				cout<<"Solution::CalInfromationTripP("<<idVeh<<", "<<idTrip<<")ERRROR: correct: NO_WS, wrong from init sol: waitS = "<<seg[idVeh].Trip[idTrip].waitingS<<endl;
//                cout<<"numC = "<<seg[idVeh].Trip[idTrip].numCus<<"; endS = "<<depart[curC]<<"; lastC = "<<curC<<"; assSP = "<<assSP<<"; disD = "<<problem->c[curC][assSP]<<"; sTW = "<<problem->nodeSP[assSP].sTW1<<"; eTW = "<<problem->nodeSP[assSP].eTW1<<endl; 			
//				cout<<"arrTime= "<<cArrTime<<endl;
//				exit(-1);
//			}
//
//			seg[idVeh].Trip[idTrip].waitingS = NO_WS;
//			tempC += problem->c[curC][assSP];
//			seg[idVeh].Trip[idTrip].leaveSP = cArrTime + problem->nodeSP[assSP].unload;
//		}
//		else
//		{
//			temp = cArrTime - problem->nodeSP[assSP].eTW1;
//			if (temp > eps) //too late to go sp directly
//			{
//				seg[idVeh].Trip[idTrip].vioTWSP = temp;
//				if (seg[idVeh].Trip[idTrip].waitingS != NO_WS)
//				{	
//					cout<<"Solution::CalInfromationTripP("<<idVeh<<", "<<idTrip<<") ERRROR: correct: NO_WS, wrong from init sol: waitS = "<<seg[idVeh].Trip[idTrip].waitingS<<endl;
//					cout<<"numC = "<<seg[idVeh].Trip[idTrip].numCus<<"; endS = "<<depart[curC]<<"; lastC = "<<curC<<"; assSP = "<<assSP<<"; disD = "<<problem->c[curC][assSP]<<"; sTW = "<<problem->nodeSP[assSP].sTW1<<"; eTW = "<<problem->nodeSP[assSP].eTW1<<endl; 			
//					cout<<"arrTime= "<<cArrTime<<"-->vioTWSP = "<<seg[idVeh].Trip[idTrip].vioTWSP<<endl;
//		
//					exit(-1);
//				}
//
//				seg[idVeh].Trip[idTrip].waitingS = NO_WS;
//				tempC += problem->c[curC][assSP];
//				seg[idVeh].Trip[idTrip].leaveSP = problem->leaveSP[assSP][0];
//			}
//			else
//			{
//				cArrTimeI = depart[curC] + problem->disCWSSP[curC][assSP];
//				temp = cArrTimeI - problem->nodeSP[assSP].eTW1;
//				if (temp > eps) //go to sp directly: unfeasibility (too soon to go to sp directly, too late to go through WS)
//				{
//					seg[idVeh].Trip[idTrip].vioTWSP = problem->nodeSP[assSP].sTW1 - cArrTime;
//					if (seg[idVeh].Trip[idTrip].waitingS != NO_WS)
//					{	cout<<"Solution::CalInfromationTripP("<<idVeh<<", "<<idTrip<<") ERRROR: correct: NO_WS; wrong from init sol: waitS = "<<seg[idVeh].Trip[idTrip].waitingS<<"; endS = "<<seg[idVeh].Trip[idTrip].endS<<"; startS = "<< depart[seg[idVeh].Trip[idTrip-1].lastCus]<<endl;exit(-1);}
//
//					seg[idVeh].Trip[idTrip].waitingS = NO_WS;
//					tempC += problem->c[curC][assSP];
//					seg[idVeh].Trip[idTrip].leaveSP = problem->leaveSP[assSP][0]; //unload only at eTW1
//				}
//				else //go through WS: feasibility
//				{
//					seg[idVeh].Trip[idTrip].vioTWSP = 0;
//					if (seg[idVeh].Trip[idTrip].waitingS != problem->CWSSP[curC][assSP])
//					{	cout<<"Solution::CalInfromationTripP("<<idVeh<<", "<<idTrip<<") ERRROR: correct: "<<problem->CWSSP[curC][assSP]<<", wrong from init sol: waitS = "<<seg[idVeh].Trip[idTrip].waitingS<<"; endS = "<<seg[idVeh].Trip[idTrip].endS<<"; startS = "<< depart[seg[idVeh].Trip[idTrip-1].lastCus]<<endl;exit(-1);}
//					seg[idVeh].Trip[idTrip].waitingS = problem->CWSSP[curC][assSP];
//					tempC += problem->disCWSSP[curC][assSP];
//					seg[idVeh].Trip[idTrip].leaveSP = PDS_MAX(cArrTimeI, problem->nodeSP[assSP].sTW1) + problem->nodeSP[assSP].unload;		
//				}
//			}
//		}
//
//		if (nextTrip < seg[idVeh].numTrips) //idTrip is not the last trip
//		{
//			if (seg[idVeh].Trip[nextTrip].Type ==1) //next trip is delivery trip
//			{	
//				int nextSP = seg[idVeh].Trip[nextTrip].assSP;
//				if (nextSP == assSP)
//				{
//				    seg[idVeh].Trip[idTrip].connectCost = 0;
//				    seg[idVeh].Trip[nextTrip].coordinate = 1; 
//					seg[idVeh].Trip[nextTrip].leaveSP = seg[idVeh].Trip[idTrip].leaveSP + problem->nodeSP[nextSP].load;
//					seg[idVeh].Trip[nextTrip].vioTWSP = seg[idVeh].Trip[idTrip].vioTWSP;
//				}
//				else
//				{
//					seg[idVeh].Trip[nextTrip].coordinate = 0; 
//					cArrTime = seg[idVeh].Trip[idTrip].leaveSP + problem->c[assSP][nextSP];
//					if (PDSINRANGE(cArrTime, problem->nodeSP[nextSP].sTW2, problem->nodeSP[nextSP].eTW2))
//					{
//						seg[idVeh].Trip[idTrip].connectCost = problem->c[assSP][nextSP];
//						seg[idVeh].Trip[idTrip].waitingS1 = NO_WS;
//						seg[idVeh].Trip[idTrip].arriveSP = cArrTime;
//
//						seg[idVeh].Trip[nextTrip].vioTWSP = 0;
//						seg[idVeh].Trip[nextTrip].leaveSP = cArrTime + problem->nodeSP[nextSP].load; //just load
//					}
//					else
//					{
//						temp = cArrTime - problem->nodeSP[nextSP].eTW2;
//						if (temp > eps) //too late to go to sp directly:
//						{
//							seg[idVeh].Trip[idTrip].connectCost = problem->c[assSP][nextSP];
//							seg[idVeh].Trip[idTrip].waitingS1 = NO_WS;
//							seg[idVeh].Trip[idTrip].arriveSP = cArrTime;
//
//							seg[idVeh].Trip[nextTrip].vioTWSP = temp;
//							seg[idVeh].Trip[nextTrip].leaveSP = problem->leaveSP[nextSP][1]; //just load
//						}
//						else
//						{
//							cArrTimeI = seg[idVeh].Trip[idTrip].leaveSP + problem->disCWSSP[assSP][nextSP];
//							temp = cArrTimeI - problem->nodeSP[nextSP].eTW2;
//							if (temp > eps) //too soon to go to sp directly, too late to go sp through WS:
//							{
//								seg[idVeh].Trip[idTrip].connectCost = problem->c[assSP][nextSP];
//								seg[idVeh].Trip[idTrip].waitingS1 = NO_WS;
//								seg[idVeh].Trip[idTrip].arriveSP = problem->nodeSP[nextSP].sTW2;
//
//								seg[idVeh].Trip[nextTrip].vioTWSP = problem->nodeSP[nextSP].sTW2 - cArrTime;
//								seg[idVeh].Trip[nextTrip].leaveSP = problem->leaveSP[nextSP][1]; //just load
//							}
//							else //go to sp through WS: feasibility:
//							{
//								seg[idVeh].Trip[idTrip].connectCost = problem->disCWSSP[assSP][nextSP];
//								seg[idVeh].Trip[idTrip].waitingS1 = problem->CWSSP[assSP][nextSP];
//								seg[idVeh].Trip[idTrip].arriveSP = PDS_MAX(cArrTimeI, problem->nodeSP[nextSP].sTW2);
//
//								seg[idVeh].Trip[idTrip].vioTWSP = 0;
//								seg[idVeh].Trip[nextTrip].leaveSP = seg[idVeh].Trip[idTrip].arriveSP + problem->nodeSP[nextSP].load; //just load
//							}
//						}
//					}
//				}
//			}
//			else //if (seg[idVeh].Trip[nextTrip].Type == 0 || 2) //next trip is pickup trip ||c2c
//			{
//				seg[idVeh].Trip[idTrip].connectCost = problem->c[assSP][seg[idVeh].Trip[nextTrip].firstCus];
//				if (seg[idVeh].Trip[nextTrip].Type == 0) seg[idVeh].Trip[nextTrip].assSP = assSP;
//			}
//		}
//		else seg[idVeh].Trip[idTrip].connectCost = problem->c[assSP][0]; //last pickup trip
//
//		tempC += seg[idVeh].Trip[idTrip].connectCost;
//		seg[idVeh].Trip[idTrip].cost = tempC;
//
//		
//		seg[idVeh].Trip[idTrip].fitness = tempC + COEFCAP * seg[idVeh].Trip[idTrip].vioCAP + COEFTWC * seg[idVeh].Trip[idTrip].vioTWC + COEFTWSP * seg[idVeh].Trip[idTrip].vioTWSP;
//	 
//		int lC = seg[idVeh].Trip[idTrip].lastCus; int BCTemp=0; double BvioTWTemp = 0;
//		for (int kk=1; kk <= numC; kk++)
//		{
//		   BCTemp += problem->node[lC].capacity;
//		   BCAP[lC] = BCTemp;
//		   BvioTWTemp += vioTWCus[lC];
//		   BvioTWCus[lC] = BvioTWTemp;
//		   lC = predArr[lC];
//		}
//}




//void Solution::CalInfromationTripC2C(int idVeh, int idTrip) 
//{
//   	int nextTrip = idTrip + 1;
//
//	double cArrTime, cArrTimeI;
//	int curC, nextC;
//	int i;
//	double temp, tempC;
//
//	//Update predArr, route_num, trip_num, pos, 
//	//startSP, depart, waitTime, vioTWCus, CAPCus
//	//endS, leaveSP, arriveSP (if avail:SP-d-SP)
//	//FCAP, BCAP
//	//connectCost, cost, fitness, vioTWSP, vioTWC, vioCAP, FvioTWC
//
//	//Create predArr:
//	curC = seg[idVeh].Trip[idTrip].firstCus;
//	predArr[curC]=-1;
//	route_num[curC] = idVeh; trip_num[curC] = idTrip; pos[curC] = 1;
//
//	if (idTrip==0)
//	{
//		if (seg[idVeh].numTrips > 1)
//		{
//			if (seg[idVeh].Trip[1].Type == 1)  seg[idVeh].Trip[0].nextSP = seg[idVeh].Trip[1].assSP;
//			else seg[idVeh].Trip[0].nextSP = -1;
//		}
//		else seg[idVeh].Trip[0].nextSP = 0;
//		tempC = problem->c[0][curC];
//
//		if (seg[idVeh].Trip[0].numCus == 2 && seg[idVeh].Trip[0].nextSP > 0)
//		{
//			startS[curC] = problem->startSOneP[curC][seg[idVeh].Trip[0].nextSP];
//			depart[curC] = startS[curC] + problem->node[curC].duration;
//			vioTWCus[curC] = 0; FvioTWCus[curC] = 0; 
//			vioCAPCus[curC] = 0; FCAP[curC] = 0; //FvioCAPCus[curC] = 0;
//			/*CAPCus[curC] = problem->node[curC].capacity;
//			int delID = problem->node[curC].delID;
//			startS[delID] = problem->startSOneP[delID][seg[idVeh].Trip[0].nextSP];
//			depart[delID] = startS[delID] + problem->node[delID].duration;
//			vioTWCus[delID] = 0; FvioTWCus[delID] = 0; CAPCus[delID] = 0;*/
//		}
//		else
//		{
//			cArrTime = PDS_MAX(problem->c[0][curC], problem->node[curC].sTW);
//			//Update startS and waitTime for each customer:
//			vioTWCus[curC] = PDS_MAX(0, cArrTime - problem->node[curC].eTW);
//			FvioTWCus[curC] = vioTWCus[curC]; 
//			vioCAPCus[curC] = 0; FCAP[curC] = 0; //FvioCAPCus[curC] = 0;
//			if (vioTWCus[curC] > eps)
//			{
//					startS[curC] = problem->node[curC].eTW;
//					depart[curC] = startS[curC] + problem->node[curC].duration;
//			}
//			else
//			{
//					startS[curC] = PDS_MAX(cArrTime, problem->node[curC].sTW);
//					depart[curC] = startS[curC] + problem->node[curC].duration;
//			}
//		}
//		CAPCus[curC] = problem->node[curC].capacity;
//		nextC = nextArr[curC];
//		seg[idVeh].Trip[0].assSP = 0;
//	}
//	else //idTrip > 0
//	{
//		tempC = 0;
//	    int preT = idTrip - 1;
//		if (seg[idVeh].Trip[preT].Type == 0)
//		{
//			cArrTime = seg[idVeh].Trip[preT].leaveSP + problem->c[seg[idVeh].Trip[preT].assSP][curC];
//			seg[idVeh].Trip[idTrip].assSP = seg[idVeh].Trip[preT].assSP;
//		}
//		else //if (seg[idVeh].Trip[preT].Type == 1 || 2)
//		{
//		    cArrTime = depart[seg[idVeh].Trip[preT].lastCus] + problem->c[seg[idVeh].Trip[preT].lastCus][curC];
//			seg[idVeh].Trip[idTrip].assSP = -1;
//		}
//		//else//cout<<"ERROR CalInfromationTripC2C: preT is C2C, curT is C2C"<<endl;
//		
//		//Update startS and waitTime for each customer:
//		vioTWCus[curC] = PDS_MAX(0, cArrTime - problem->node[curC].eTW);
//		FvioTWCus[curC] = vioTWCus[curC];
//		if (vioTWCus[curC] > eps)
//		{
//				startS[curC] = problem->node[curC].eTW;
//				depart[curC] = startS[curC] + problem->node[curC].duration;
//		}
//		else
//		{
//				startS[curC] = PDS_MAX(cArrTime, problem->node[curC].sTW);
//				depart[curC] = startS[curC] + problem->node[curC].duration;
//		}
//		CAPCus[curC] = problem->node[curC].capacity;
//		vioCAPCus[curC] = 0; FCAP[curC] = 0; //FvioCAPCus[curC] = 0;
//		nextC = nextArr[curC];
//	}
//
//
//
//		int tQ;
//		int numC = seg[idVeh].Trip[idTrip].numCus; 
//		for (i=2;i<=numC;i++)
//		{
//			predArr[nextC] = curC; route_num[nextC] = idVeh; trip_num[nextC] = idTrip;
//			pos[nextC] = i; 
//			CAPCus[nextC] = CAPCus[curC] + problem->node[nextC].capacity;
//			tQ = CAPCus[nextC] - Q;
//			if (tQ > 0) 
//			{
//				vioCAPCus[nextC] = tQ;
//				CAPCus[nextC] = Q;
//				FCAP[nextC] = FCAP[curC] + tQ;
//				//FvioCAPCus[nextC] = FvioCAPCus[curC] + tQ;
//			}
//			else
//			{
//				vioCAPCus[nextC] = 0;
//				FCAP[nextC] = FCAP[curC];
//				//FvioCAPCus[nextC] = FvioCAPCus[curC];
//			}
//			cArrTime = depart[curC] + problem->c[curC][nextC];
//			vioTWCus[nextC] = PDS_MAX(0, cArrTime - problem->node[nextC].eTW);
//            if (vioTWCus[nextC] > eps)
//			{
//				FvioTWCus[nextC] = FvioTWCus[curC] + vioTWCus[nextC];
//				startS[nextC] = problem->node[nextC].eTW;
//				depart[nextC] = problem->node[nextC].depart;
//			}
//			else
//			{
//			    FvioTWCus[nextC] = FvioTWCus[curC];
//				startS[nextC] = PDS_MAX(cArrTime, problem->node[nextC].sTW);
//			    depart[nextC] = startS[nextC] + problem->node[nextC].duration;
//			}
//			tempC += problem->c[curC][nextC];
//			curC = nextC; nextC=nextArr[curC];
//		}
//		nextArr[curC] = -1;
//
//		if (PDSDIF(depart[curC], seg[idVeh].Trip[idTrip].endS))
//		{
//			cout<<"ERROR CalInfromationTripC2C("<<idVeh<<", "<<idTrip<<"): correct endS = "<<depart[curC]<<"; wrong from init sol= "<<seg[idVeh].Trip[idTrip].endS<<endl;
//			showTripCus(idVeh, idTrip);
//			exit(-1);
//		}
//
//		seg[idVeh].Trip[idTrip].endS = depart[curC];
//		seg[idVeh].Trip[idTrip].vioTWC = FvioTWCus[curC];
//		seg[idVeh].Trip[idTrip].vioCAP = FCAP[curC];
//		//seg[idVeh].Trip[idTrip].vioCAP = FvioCAPCus[curC];
//
//		if (nextTrip < seg[idVeh].numTrips) //idTrip is not the last trip
//		{
//			if (seg[idVeh].Trip[nextTrip].Type == 1) //next trip is delivery trip
//			{	
//				int nextSP = seg[idVeh].Trip[nextTrip].assSP;
//				seg[idVeh].Trip[idTrip].nextSP = nextSP;
//				cArrTime = depart[curC] + problem->c[curC][nextSP];
//				if (PDSINRANGE(cArrTime, problem->nodeSP[nextSP].sTW2, problem->nodeSP[nextSP].eTW2))
//				{
//					if (seg[idVeh].Trip[idTrip].waitingS != NO_WS)
//					{	cout<<"Solution::CalInfromationTripC2C("<<idVeh<<", "<<idTrip<<") ERRROR: correct: noWS, wrong from init sol: waitS = "<<seg[idVeh].Trip[idTrip].waitingS<<endl;exit(-1);}
//					seg[idVeh].Trip[idTrip].waitingS = NO_WS;
//					seg[idVeh].Trip[idTrip].connectCost = problem->c[curC][nextSP];
//					seg[idVeh].Trip[idTrip].arriveSP = cArrTime;
//
//					seg[idVeh].Trip[nextTrip].leaveSP = cArrTime + problem->nodeSP[nextSP].load;
//					seg[idVeh].Trip[nextTrip].vioTWSP = 0;
//				}
//				else
//				{
//					temp = cArrTime - problem->nodeSP[nextSP].eTW2;
//					if (temp > eps) //too late to go to sp directly:
//					{
//						if (seg[idVeh].Trip[idTrip].waitingS != NO_WS)
//						{	cout<<"Solution::CalInfromationTripC2C("<<idVeh<<", "<<idTrip<<" ERRROR: correct: noWS, wrong from init sol: waitS = "<<seg[idVeh].Trip[idTrip].waitingS<<endl;exit(-1);}
//						seg[idVeh].Trip[idTrip].waitingS = NO_WS;
//						seg[idVeh].Trip[idTrip].connectCost = problem->c[curC][nextSP];
//						seg[idVeh].Trip[idTrip].arriveSP = problem->nodeSP[nextSP].eTW2;
//
//						seg[idVeh].Trip[nextTrip].leaveSP = problem->leaveSP[nextSP][1]; //just load
//						seg[idVeh].Trip[nextTrip].vioTWSP = temp;
//					}
//					else // too soon to go to sp directly:
//					{
//						cArrTimeI = depart[curC] + problem->disCWSSP[curC][nextSP];
//						temp = cArrTimeI - problem->nodeSP[nextSP].eTW2;
//						if (temp > eps) // too soon to go to sp directly, too late to go through WS: --> go to sp directly INFEASIBILITY
//						{
//							if (seg[idVeh].Trip[idTrip].waitingS != NO_WS)
//							{	cout<<"Solution::CalInfromationTripC2C("<<idVeh<<", "<<idTrip<<") ERRROR: correct: NO_WS, wrong from init sol: waitS = "<<seg[idVeh].Trip[idTrip].waitingS<<endl;exit(-1);}
//							seg[idVeh].Trip[idTrip].waitingS = NO_WS;
//							seg[idVeh].Trip[idTrip].connectCost = problem->c[curC][nextSP];
//							seg[idVeh].Trip[idTrip].arriveSP = problem->nodeSP[nextSP].eTW2;
//
//							seg[idVeh].Trip[nextTrip].leaveSP = problem->leaveSP[nextSP][1]; //just load
//							seg[idVeh].Trip[nextTrip].vioTWSP = problem->nodeSP[nextSP].sTW2 - cArrTime;
//						}
//						else //go to sp through WS: feasibility
//						{
//							if (seg[idVeh].Trip[idTrip].waitingS != problem->CWSSP[curC][nextSP])
//							{	cout<<"Solution::CalInfromationTripC2C("<<idVeh<<", "<<idTrip<<") ERRROR: correct: "<<problem->CWSSP[curC][nextSP]<<", wrong from init sol: waitS = "<<seg[idVeh].Trip[idTrip].waitingS<<endl;exit(-1);}
//
//							seg[idVeh].Trip[idTrip].waitingS = problem->CWSSP[curC][nextSP];
//							seg[idVeh].Trip[idTrip].connectCost = problem->disCWSSP[curC][nextSP];
//						
//							seg[idVeh].Trip[idTrip].arriveSP = PDS_MAX(cArrTimeI, problem->nodeSP[nextSP].sTW2);
//							seg[idVeh].Trip[nextTrip].leaveSP =  seg[idVeh].Trip[idTrip].arriveSP + problem->nodeSP[nextSP].load; //just load
//							seg[idVeh].Trip[nextTrip].vioTWSP = 0;
//						}
//					}
//				}
//				//seg[idVeh].Trip[idTrip].arriveSP = PDS_MAX(depart[curC] + seg[idVeh].Trip[idTrip].connectCost, problem->nodeSP[nextSP].sTW2);
//			}
//			else //if (seg[idVeh].Trip[nextTrip].Type == 0 || 2) //next trip is pickup trip
//			{
//				seg[idVeh].Trip[idTrip].waitingS = NO_WS;
//				seg[idVeh].Trip[idTrip].connectCost = problem->c[curC][seg[idVeh].Trip[nextTrip].firstCus];
//				seg[idVeh].Trip[idTrip].nextSP = -1;
//			}
//			//else cout<<"ERROR CalInfromationTripC2C: curT is C2C; nextTrip is C2C"<<endl;
//		}
//		else seg[idVeh].Trip[idTrip].connectCost = problem->c[curC][0]; //lastTrip --> connectCost = dis(lastCus, depot)
//		tempC += seg[idVeh].Trip[idTrip].connectCost;
//		seg[idVeh].Trip[idTrip].cost = tempC;
//		if (seg[idVeh].Trip[idTrip].assSP > 0)
//		{
//			if (seg[idVeh].Trip[idTrip].nextSP > 0) seg[idVeh].Trip[idTrip].coordinate = 1;
//			else seg[idVeh].Trip[idTrip].coordinate = 2;
//		}
//		else
//		{
//			if (seg[idVeh].Trip[idTrip].nextSP > 0) seg[idVeh].Trip[idTrip].coordinate = 3;
//			else seg[idVeh].Trip[idTrip].coordinate = 0;
//		}
//		
//		seg[idVeh].Trip[idTrip].fitness = tempC + COEFCAP * seg[idVeh].Trip[idTrip].vioCAP + COEFTWC * seg[idVeh].Trip[idTrip].vioTWC + COEFTWSP * seg[idVeh].Trip[idTrip].vioTWSP;
//	 
//		int lC = seg[idVeh].Trip[idTrip].lastCus; int BCTemp=0; double BvioTWTemp = 0;
//		int BvioCAPTemp = 0;
//		for (int kk=1; kk <= numC; kk++)
//		{
//		   BvioCAPTemp += vioCAPCus[lC];
//		   BCAP[lC] = BvioCAPTemp;
//		   //BvioCAPCus[lC] = BvioCAPTemp;
//		   BvioTWTemp += vioTWCus[lC];
//		   BvioTWCus[lC] = BvioTWTemp;
//		   lC = predArr[lC];
//		}
//}
//



//void Solution::calFitCostSumTrip()
//{
//	double cTemp = 0;
//	double fTemp = 0;
//	for (int i = 0;i <numVeh;i++)
//		for (int j=0;j<seg[i].numTrips;j++)
//		{
//           cTemp += seg[i].Trip[j].cost;
//		   fTemp += seg[i].Trip[j].fitness;
//		}
//	cost = cTemp;
//	fitness = fTemp + F*numVehUsed;
//}


//void Solution::UpdateCostFitnessFeasible()
//{
//	int i,j; cost=0; fitness=0; 
//	vioCAPC=0; vioTWCC=0; vioTWSPC=0; //Current
//	feasible=1; int numT, numTT=0; 
//	bool stop, buon = false;
//
//	for (i=0;i<numVeh;i++)
//	{
//		seg[i].vioCAP = 0; seg[i].vioTWC = 0; seg[i].vioTWSP = 0;
//		seg[i].cost = 0; seg[i].fitness = 0;
//		numT = seg[i].numTrips;
//		numTT += numT;
//		for (j=0;j<numT;j++)
//		{
//			seg[i].cost += seg[i].Trip[j].cost;
//			seg[i].fitness += seg[i].Trip[j].fitness;
//			if (seg[i].Trip[j].fitness < eps)
//			{
//				cout<<"ERROR fitness of trip ("<<i<<", "<<j<<") = "<<seg[i].Trip[j].fitness<<" < 0 "<<endl;
//				buon = true;
//			}
//			if (!seg[i].Trip[j].feasible)
//			{
//				seg[i].feasible = 0;
//				feasible=0; 
//				seg[i].vioCAP += seg[i].Trip[j].vioCAP;
//				seg[i].vioTWC += seg[i].Trip[j].vioTWC;
//				seg[i].vioTWSP += seg[i].Trip[j].vioTWSP;
//			}
//			if (seg[i].Trip[j].Type == 1)
//			{
//				stop = checkTripD_ALLFIELDS(i,j);
//				if (stop) {cout<<"Solution::UpdateCostFitnessFeasible() Exit after call checkTripD_ALLFIELDS("<<i<<", "<<j<<")..................."; exit(-1);}
//			}
//			else if (seg[i].Trip[j].Type == 0)
//			{
//				stop  = checkTripP_ALLFIELDS(i,j);
//				if (stop) {cout<<"Solution::UpdateCostFitnessFeasible() Exit after checkTripP_ALLFIELDS("<<i<<", "<<j<<")..................."; exit(-1);}
//			}
//			else
//			{
//				stop = checkTripC2C_ALLFIELDS(i,j);
//				if (stop) {cout<<"Solution::UpdateCostFitnessFeasible() Exit after call checkTripD_ALLFIELDS("<<i<<", "<<j<<")..................."; exit(-1);}
//			}
//
//		}
//		cost += seg[i].cost; fitness += seg[i].fitness;
//		vioCAPC += seg[i].vioCAP; vioTWCC += seg[i].vioTWC;vioTWSPC += seg[i].vioTWSP; 
//	}
//	vioCAP = vioCAPC; vioTWC = vioTWCC; vioTWSP = vioTWSPC; //of Solution
//	fitness += (F*numVehUsed);
//	numTrips = numTT;
//	//if (buon) {showSolution(); cout<<"ERRORRRRRRRRRRRRRR FIT < 0"<<endl;exit(-1);}
//}

//void Solution::UpdateCostFitnessFeasible1()
//{
//	int i,j; cost=0; fitness=0; 
//	vioCAPC=0; vioTWCC=0; vioTWSPC=0; //Current
//	feasible=1; int numT; 
//	for (i=0;i<numVeh;i++)
//	{
//		seg[i].vioCAP = 0; seg[i].vioTWC = 0; seg[i].vioTWSP = 0;
//		seg[i].cost = 0; seg[i].fitness = 0;
//		numT = seg[i].numTrips;
//		for (j=0;j<numT;j++)
//		{
//			seg[i].cost += seg[i].Trip[j].cost;
//			if (!seg[i].Trip[j].feasible)
//			{
//				seg[i].feasible = 0;
//				feasible=0; 
//				seg[i].vioCAP += seg[i].Trip[j].vioCAP;
//				seg[i].vioTWC += seg[i].Trip[j].vioTWC;
//				seg[i].vioTWSP += seg[i].Trip[j].vioTWSP;
//				seg[i].Trip[j].fitness = seg[i].Trip[j].cost + VCAP * seg[i].Trip[j].vioCAP + VTWCUS * seg[i].Trip[j].vioTWC + VTWSP * seg[i].Trip[j].vioTWSP; 
//			}
//			seg[i].fitness += seg[i].Trip[j].fitness;
//		}
//		cost += seg[i].cost; fitness += seg[i].fitness;
//		vioCAPC += seg[i].vioCAP; vioTWCC += seg[i].vioTWC;vioTWSPC += seg[i].vioTWSP; 
//	}
//	vioCAP = vioCAPC; vioTWC = vioTWCC; vioTWSP = vioTWSPC; //of Solution
//	fitness += (F*numVehUsed);
//}
//void Solution::UpdatePos(int idVeh, int idTrip)
//{
//	int i, curC = seg[idVeh].Trip[idTrip].firstCus;
//	for (i=1; i<= seg[idVeh].Trip[idTrip].numCus; i++)
//	{
//		pos[curC] = i;
//		curC = nextArr[curC];
//	}
//}

//bool Solution::checkCapacity_C2CTrip(int curC, int CAPINS)
//{
//	int FCAPT = FCAP[curC] + CAPINS;
//	if (FCAPT > problem->Q) return 0;
//
//	if (curC < problem->startidC2CD) //curC is C2CP
//	{
//		int idCusD = problem->node[curC].delID;
//		int nextC = nextArr[curC];
//		while (nextC != idCusD)
//		{
//			FCAPT += problem->node[nextC].capacity;
//			if (FCAPT > problem->Q) return 0;
//			nextC = nextArr[nextC];
//		}
//	}
//	else //curC is C2CD
//	{
//		int nextC = nextArr[curC];
//		while (nextC < problem->startidC2CD)
//		{
//			FCAPT += problem->node[nextC].capacity;
//			if (FCAPT > problem->Q) return 0;
//			nextC = nextArr[nextC];
//		}
//	}
//	return 1;
//}
//
////------------------------------------------- SHOW SOLUTION-------------------------------//
//void Solution::showTripCostTemp(int idVeh, int idTrip)
//{
//	int i;
//	if (seg[idVeh].Trip[idTrip].Type==1) //delivery trip
//	{
//		cout<<"SP = "<<seg[idVeh].Trip[idTrip].assSP<<": ";
//		int firstCus= seg[idVeh].Trip[idTrip].firstCus;
//	    int lastCus = seg[idVeh].Trip[idTrip].lastCus;
//		i=firstCus;
//		while (i!=lastCus)
//		{
//				cout<<i<<", ";
//				i = nextArrTemp[i];
//		}
//		cout<<lastCus<<endl;
//	}
//	else //pickup trip:
//	{
//		int firstCus= seg[idVeh].Trip[idTrip].firstCus;
//	    int lastCus = seg[idVeh].Trip[idTrip].lastCus;
//		i=firstCus;
//		while (i!=lastCus)
//		{
//				cout<<i<<", ";
//				i = nextArrTemp[i];
//		}
//		cout<<lastCus<<", ";
//		if (seg[idVeh].Trip[idTrip].waitingS != NO_WS) cout<<"("<<seg[idVeh].Trip[idTrip].waitingS<<"), ";
//		cout<<" sp = "<<seg[idVeh].Trip[idTrip].assSP<<endl;
//	}
//}
//
//void Solution::showTripCost(int idVeh, int idTrip)
//{
//	int i;
//	if (seg[idVeh].Trip[idTrip].Type==1) //delivery trip
//	{
//		if (seg[idVeh].Trip[idTrip].coordinate)
//		  cout<<"CORDelivery trip("<<seg[idVeh].Trip[idTrip].feasible<<"): sp = "<<seg[idVeh].Trip[idTrip].assSP<<", cap = "<<seg[idVeh].Trip[idTrip].capacity<<", cost = "<<seg[idVeh].Trip[idTrip].cost<<", connectCost = "<<seg[idVeh].Trip[idTrip].connectCost<<" (numC = "<<seg[idVeh].Trip[idTrip].numCus<<"): ";
//		else
//		  cout<<"NOTCORDelivery trip ("<<seg[idVeh].Trip[idTrip].feasible<<"): sp = "<<seg[idVeh].Trip[idTrip].assSP<<", cap = "<<seg[idVeh].Trip[idTrip].capacity<<", cost = "<<seg[idVeh].Trip[idTrip].cost<<", connectCost = "<<seg[idVeh].Trip[idTrip].connectCost<<" (numC = "<<seg[idVeh].Trip[idTrip].numCus<<"): ";
//		int firstCus= seg[idVeh].Trip[idTrip].firstCus;
//	    int lastCus = seg[idVeh].Trip[idTrip].lastCus;
//		i=firstCus;
//		for (int ii = 1; ii<=seg[idVeh].Trip[idTrip].numCus; ii++)
//		{
//			cout<<i<<", ";
//			i = nextArr[i];
//		}
//		int nextTrip = idTrip+1;
//		if (seg[idVeh].numTrips == nextTrip) cout<<" depot"<<endl;
//		else
//			if (seg[idVeh].Trip[nextTrip].Type)
//			{
//				if (seg[idVeh].Trip[idTrip].waitingS != NO_WS) cout<<" (WS = "<<seg[idVeh].Trip[idTrip].waitingS<<")"<<endl;
//				else cout<<endl;
//			}
//			else cout<<" pickcus = "<<seg[idVeh].Trip[nextTrip].firstCus<<endl;
//	}
//	else if (seg[idVeh].Trip[idTrip].Type == 0)//pickup trip:
//	{
//		cout<<"Pickup trip ("<<idVeh<<", "<<idTrip<<", fea = "<<seg[idVeh].Trip[idTrip].feasible<<"): cap  = "<<seg[idVeh].Trip[idTrip].capacity<<", cost = "<<seg[idVeh].Trip[idTrip].cost<<", connectCost =  "<<seg[idVeh].Trip[idTrip].connectCost<<"; endS = "<<seg[idVeh].Trip[idTrip].endS<<": ";
//		int firstCus= seg[idVeh].Trip[idTrip].firstCus;
//	    int lastCus = seg[idVeh].Trip[idTrip].lastCus;
//		i=firstCus;
//		for (int ii = 1; ii<=seg[idVeh].Trip[idTrip].numCus; ii++)
//		{
//			cout<<i<<", ";
//			i = nextArr[i];
//		}
//		if (seg[idVeh].Trip[idTrip].waitingS != NO_WS) cout<<"("<<seg[idVeh].Trip[idTrip].waitingS<<"), ";
//		cout<<" sp = "<<seg[idVeh].Trip[idTrip].assSP<<endl;
//		//cout<<"BUON WS = "<<seg[idVeh].Trip[idTrip].waitingS<<"; vioCAP = "<<seg[idVeh].Trip[idTrip].vioCAP<<"; vioTWSP = "<<seg[idVeh].Trip[idTrip].vioTWSP<<"; fea = "<<seg[idVeh].Trip[idTrip].feasible<<"; lastC = "<<seg[idVeh].Trip[idTrip].lastCus<<"; endS = "<<seg[idVeh].Trip[idTrip].endS<<"; connectCost = "<<seg[idVeh].Trip[idTrip].connectCost<<"; dur = "<<seg[idVeh].Trip[idTrip].duration<<endl;
//
//	}
//	else //C2CTrip
//	{
//		cout<<"C2C trip ("<<idVeh<<", "<<idTrip<<", fea = "<<seg[idVeh].Trip[idTrip].feasible<<"): cost = "<<seg[idVeh].Trip[idTrip].cost<<", connectCost =  "<<seg[idVeh].Trip[idTrip].connectCost<<": ";
//		int firstCus= seg[idVeh].Trip[idTrip].firstCus;
//	    int lastCus = seg[idVeh].Trip[idTrip].lastCus;
//		i=firstCus;
//		for (int ii = 1; ii<=seg[idVeh].Trip[idTrip].numCus; ii++)
//		{
//			cout<<i<<", ";
//			i = nextArr[i];
//		}
//		cout<<endl;
//	}
//}
//
//
//void Solution::showTripCus(int idVeh, int idTrip)
//{
//	int i;
//	if (seg[idVeh].Trip[idTrip].Type==1) //delivery trip
//	{
//		int firstCus= seg[idVeh].Trip[idTrip].firstCus;
//	    int lastCus = seg[idVeh].Trip[idTrip].lastCus;
//		i=firstCus;
//		while (i!=lastCus)
//		{
//				cout<<i<<"("<<depart[i]<<"), ";
//				i = nextArr[i];
//		}
//		cout<<lastCus;
//		int nextTrip = idTrip+1;
//		if (seg[idVeh].numTrips == nextTrip) cout<<", depot"<<endl;
//		else
//			if (seg[idVeh].Trip[nextTrip].Type)
//			{
//				if (seg[idVeh].Trip[idTrip].waitingS != NO_WS) cout<<", (WS = "<<seg[idVeh].Trip[idTrip].waitingS<<")"<<endl;
//				else cout<<endl;
//			}
//			else cout<<", pickcus = "<<seg[idVeh].Trip[nextTrip].firstCus<<endl;
//	}
//	else if (seg[idVeh].Trip[idTrip].Type==0)//pickup trip:
//	{
//		int firstCus= seg[idVeh].Trip[idTrip].firstCus;
//		i=firstCus;
//		while (i > 0)
//		{
//				cout<<i<<"("<<depart[i]<<"), ";
//				i = nextArr[i];
//		}
//		if (seg[idVeh].Trip[idTrip].waitingS != NO_WS) cout<<"("<<seg[idVeh].Trip[idTrip].waitingS<<"), ";
//		cout<<" sp = "<<seg[idVeh].Trip[idTrip].assSP<<endl;
//	}
//	else if (seg[idVeh].Trip[idTrip].Type==2)//C2C trip:
//	{
//		int firstCus= seg[idVeh].Trip[idTrip].firstCus;
//		i=firstCus;
//		while (i > 0)
//		{
//			if (i <= problem->endidC2CP) cout<<i<<", ";
//			else cout<<i<<"(p = "<<problem->node[i].pickID<<"), ";
//			i = nextArr[i];
//		}
//		cout<<endl;
//	}
//}
//
//
//
//
//
//void Solution::showTripCusTW(int idVeh, int idTrip)
//{
//	int i;
//	if (seg[idVeh].Trip[idTrip].Type==1) //delivery trip
//	{
//		int firstCus= seg[idVeh].Trip[idTrip].firstCus;
//	    int lastCus = seg[idVeh].Trip[idTrip].lastCus;
//		i=firstCus;
//		while (i!=lastCus)
//		{
//				cout<<i<<"("<<depart[i]<<"), ";
//				i = nextArr[i];
//		}
//		cout<<lastCus;
//		int nextTrip = idTrip+1;
//		if (seg[idVeh].numTrips == nextTrip) cout<<", depot"<<endl;
//		else
//			if (seg[idVeh].Trip[nextTrip].Type)
//			{
//				if (seg[idVeh].Trip[idTrip].waitingS != NO_WS) cout<<", (WS = "<<seg[idVeh].Trip[idTrip].waitingS<<")"<<endl;
//				else cout<<endl;
//			}
//			else cout<<", pickcus = "<<seg[idVeh].Trip[nextTrip].firstCus<<endl;
//	}
//	else if (seg[idVeh].Trip[idTrip].Type==0)//pickup trip:
//	{
//		int firstCus= seg[idVeh].Trip[idTrip].firstCus;
//		i=firstCus;
//		while (i > 0)
//		{
//				cout<<i<<"("<<depart[i]<<"), ";
//				i = nextArr[i];
//		}
//		if (seg[idVeh].Trip[idTrip].waitingS != NO_WS) cout<<"("<<seg[idVeh].Trip[idTrip].waitingS<<"), ";
//		cout<<" sp = "<<seg[idVeh].Trip[idTrip].assSP<<endl;
//	}
//	else if (seg[idVeh].Trip[idTrip].Type==2)//C2C trip:
//	{
//		int firstCus= seg[idVeh].Trip[idTrip].firstCus;
//		i=firstCus;
//		cout<<"(numC = "<<seg[idVeh].Trip[idTrip].numCus<<") TripvioTWC = "<<seg[idVeh].Trip[idTrip].vioTWC<<": ";
//		while (i > 0)
//		{
//			if (i <= problem->endidC2CP) cout<<i<<"(vioTW = "<<vioTWCus[i]<<", startS = "<<startS[i]<<", depart = "<<depart[i]<<"), ";
//			else cout<<i<<"(p = "<<problem->node[i].pickID<<", vioTW = "<<vioTWCus[i]<<", startS = "<<startS[i]<<", depart = "<<depart[i]<<"), ";
//			i = nextArr[i];
//		}
//		cout<<endl;
//	}
//}
//
//
//
//
//void Solution::showTripCusvioTW_C2C(int idVeh, int idTrip)
//{
//	int i;
//	int firstCus= seg[idVeh].Trip[idTrip].firstCus;
//	i=firstCus;
//	cout<<"(numC = "<<seg[idVeh].Trip[idTrip].numCus<<") TripvioTWC = "<<seg[idVeh].Trip[idTrip].vioTWC<<": ";
//	while (i > 0)
//	{
//		if (i <= problem->endidC2CP) cout<<i<<"(vioTW = "<<vioTWCus[i]<<"), ";
//		else cout<<i<<"(p = "<<problem->node[i].pickID<<", vioTW = "<<vioTWCus[i]<<"), ";
//		i = nextArr[i];
//	}
//	cout<<endl;
//}
//
//
//
//
//void Solution::showTripCusCAP(int idVeh, int idTrip)
//{
//	int i;
//	if (seg[idVeh].Trip[idTrip].Type==1) //delivery trip
//	{
//		int firstCus= seg[idVeh].Trip[idTrip].firstCus;
//	    int lastCus = seg[idVeh].Trip[idTrip].lastCus;
//		i=firstCus;
//		while (i!=lastCus)
//		{
//				cout<<i<<"("<<depart[i]<<"), ";
//				i = nextArr[i];
//		}
//		cout<<lastCus;
//		int nextTrip = idTrip+1;
//		if (seg[idVeh].numTrips == nextTrip) cout<<", depot"<<endl;
//		else
//			if (seg[idVeh].Trip[nextTrip].Type)
//			{
//				if (seg[idVeh].Trip[idTrip].waitingS != NO_WS) cout<<", (WS = "<<seg[idVeh].Trip[idTrip].waitingS<<")"<<endl;
//				else cout<<endl;
//			}
//			else cout<<", pickcus = "<<seg[idVeh].Trip[nextTrip].firstCus<<endl;
//	}
//	else if (seg[idVeh].Trip[idTrip].Type==0)//pickup trip:
//	{
//		int firstCus= seg[idVeh].Trip[idTrip].firstCus;
//		i=firstCus;
//		while (i > 0)
//		{
//				cout<<i<<"("<<depart[i]<<"), ";
//				i = nextArr[i];
//		}
//		if (seg[idVeh].Trip[idTrip].waitingS != NO_WS) cout<<"("<<seg[idVeh].Trip[idTrip].waitingS<<"), ";
//		cout<<" sp = "<<seg[idVeh].Trip[idTrip].assSP<<endl;
//	}
//	else if (seg[idVeh].Trip[idTrip].Type==2)//C2C trip:
//	{
//		cout<<"numCus = "<<seg[idVeh].Trip[idTrip].numCus<<"(vioCAP = "<<FCAP[seg[idVeh].Trip[idTrip].lastCus]<<"):   ";
//		int firstCus= seg[idVeh].Trip[idTrip].firstCus;
//		i=firstCus;
//		while (i > 0)
//		{
//			if (i <= problem->endidC2CP) cout<<i<<"(vioCAP = "<<vioCAPCus[i]<<"; CAPCus = "<<CAPCus[i]<<"), ";
//			else cout<<i<<"(p = "<<problem->node[i].pickID<<", vioCAP = "<<vioCAPCus[i]<<"; CAPCus = "<<CAPCus[i]<<"), ";
//			i = nextArr[i];
//		}
//		cout<<endl;
//	}
//}
//
//
//
//
//
//void Solution::showSolution()
//{
//   int i,j,curC;
//   cout<<fitness<<"   "<<cost<<"   "<<numVehUsed<<"   numVehINIT = "<<numVeh<<endl;
//   for (i=0;i<numVeh;i++)
//   {
//       cout<<seg[i].numTrips<<endl;
//	   for (j=0;j<seg[i].numTrips;j++)
//	   {
//		   if (seg[i].Trip[j].Type == 1)
//		   {
//			   cout<<i<<"   "<<j<<"   1\t"<<seg[i].Trip[j].fitness<<" \t "<<seg[i].Trip[j].cost<<" \t "<<seg[i].Trip[j].capacity<<" \t "<<seg[i].Trip[j].leaveSP<<" \t "<<seg[i].Trip[j].numCus<<" \t";
//			   cout<<seg[i].Trip[j].assSP<<"\t";
//			   curC = seg[i].Trip[j].firstCus;
//			   while (curC > 0)
//			   {
//				   cout<<curC<<"\t";
//				   curC = nextArr[curC];
//			   }
//			   cout<<seg[i].Trip[j].waitingS<<endl;
//		   }
//		   else if (seg[i].Trip[j].Type == 0)
//		   {
//			   cout<<i<<"   "<<j<<"   0\t"<<seg[i].Trip[j].fitness<<" \t "<<seg[i].Trip[j].cost<<" \t "<<seg[i].Trip[j].capacity<<" \t "<<seg[i].Trip[j].leaveSP<<" \t "<<seg[i].Trip[j].numCus<<" \t";
//			   curC = seg[i].Trip[j].firstCus;
//			   
//			   while (curC > 0)
//			   {
//				   cout<<curC<<"\t";
//				   if (curC > endidP)
//			     	   cout<<"ERROR: idCusP = "<<curC<<" exceed limit = "<<endidP<<endl;
//			   	   curC = nextArr[curC];
//			   }
//			   cout<<seg[i].Trip[j].waitingS<<"\t ";
//			   cout<<seg[i].Trip[j].assSP<<endl;
//		   }
//		   else
//		   {
//			   int nextT = j + 1;
//			   if (nextT < seg[i].numTrips)
//			   {
//				   if (seg[i].Trip[nextT].Type)
//				   {
//					   cout<<i<<"   "<<j<<"   2\t"<<seg[i].Trip[j].fitness<<" \t "<<seg[i].Trip[j].cost<<" \t "<<seg[i].Trip[j].arriveSP<<" \t "<<seg[i].Trip[j].numCus<<" \t";
//					   curC = seg[i].Trip[j].firstCus;
//					   while (curC > 0)
//					   {
//						   cout<<curC<<"\t";
//						   curC = nextArr[curC];
//					   }
//					   cout<<seg[i].Trip[j].waitingS<<"\t";
//					   cout<<seg[i].Trip[nextT].assSP<<endl;
//				   }
//				   else
//				   {
//					   cout<<i<<"   "<<j<<"   2\t"<<seg[i].Trip[j].fitness<<" \t "<<seg[i].Trip[j].cost<<" \t "<<seg[i].Trip[j].endS<<" \t "<<seg[i].Trip[j].numCus<<" \t";
//					   curC = seg[i].Trip[j].firstCus;
//					   while (curC > 0)
//					   {
//						   cout<<curC<<"\t";
//						   curC = nextArr[curC];
//					   }
//					   cout<<seg[i].Trip[j].waitingS<<endl;
//				   }
//			   }
//			   else
//			   {
//				   cout<<i<<"   "<<j<<"   2\t"<<seg[i].Trip[j].fitness<<" \t "<<seg[i].Trip[j].cost<<" \t "<<seg[i].Trip[j].endS<<" \t "<<seg[i].Trip[j].numCus<<" \t";
//				   cout<<seg[i].Trip[j].assSP<<"\t";
//				   curC = seg[i].Trip[j].firstCus;
//				   while (curC > 0)
//				   {
//					   cout<<curC<<"\t";
//					   curC = nextArr[curC];
//				   }
//				   cout<<seg[i].Trip[j].waitingS<<endl;
//			   }
//		   }
//	   }
//   }
//   cout<<fitness<<"   "<<cost<<"   "<<numVehUsed<<endl;
//}
//
//
//void Solution::showSolutionTempToCheck()
//{
//   int i,j,curC;
//    int nCM=0, VM,TM;
//  
//   cout<<fitness<<"   "<<cost<<"   "<<numVehUsed<<"   numVehINIT = "<<numVeh<<endl;
//   for (i=0;i<numVeh;i++)
//   {
//       cout<<seg[i].numTrips<<endl;
//	   for (j=0;j<seg[i].numTrips;j++)
//	   {
//   		   if (seg[i].Trip[j].numCus > nCM) {nCM = seg[i].Trip[j].numCus; VM = i; TM = j;}
//		   if (seg[i].Trip[j].Type == 1)
//		   {
//			   cout<<i<<"   "<<j<<" DTrip:\t"<<seg[i].Trip[j].fitness<<" \t "<<seg[i].Trip[j].cost<<" \t "<<seg[i].Trip[j].capacity<<" \t "<<seg[i].Trip[j].leaveSP<<" \t (nCus ="<<seg[i].Trip[j].numCus<<") \t";
//			   cout<<"SP = "<<seg[i].Trip[j].assSP<<"\t";
//			   curC = seg[i].Trip[j].firstCus;
//			   while (curC > 0)
//			   {
//				   cout<<curC<<"\t"; //cout<<problem->node[curC].id<<"\t";
//				   curC = nextArr[curC];
//			   }
//			   cout<<"("<<seg[i].Trip[j].waitingS<<")"<<endl;
//		   }
//		   else if (seg[i].Trip[j].Type == 0)
//		   {
//			   cout<<i<<"   "<<j<<"   PTrip:\t"<<seg[i].Trip[j].fitness<<" \t "<<seg[i].Trip[j].cost<<" \t "<<seg[i].Trip[j].capacity<<" \t "<<seg[i].Trip[j].leaveSP<<" \t (nCus ="<<seg[i].Trip[j].numCus<<") \t";
//			   curC = seg[i].Trip[j].firstCus;
//			   
//			   while (curC > 0)
//			   {
//				   cout<<curC<<"\t"; //cout<<problem->node[curC].id<<"\t";
//				   if (curC > endidP)
//			     	   cout<<"ERROR: idCusP = "<<curC<<" exceed limit = "<<endidP<<endl;
//			   	   curC = nextArr[curC];
//			   }
//			   cout<<"("<<seg[i].Trip[j].waitingS<<")\t ";
//			   cout<<"SP = "<<seg[i].Trip[j].assSP<<endl;
//		   }
//		   else
//		   {
//			   int nextT = j + 1;
//			   if (nextT < seg[i].numTrips)
//			   {
//				   if (seg[i].Trip[nextT].Type)
//				   {
//					   cout<<i<<"   "<<j<<"   C2C\t"<<seg[i].Trip[j].fitness<<" \t "<<seg[i].Trip[j].cost<<" \t "<<seg[i].Trip[j].arriveSP<<" \t (nCus = "<<seg[i].Trip[j].numCus<<") \t";
//					   curC = seg[i].Trip[j].firstCus;
//					   while (curC > 0)
//					   {
//						   cout<<curC<<"\t"; //cout<<problem->node[curC].id<<"\t";
//						   curC = nextArr[curC];
//					   }
//					   cout<<"("<<seg[i].Trip[j].waitingS<<")\t";
//					   cout<<"SP = "<<seg[i].Trip[nextT].assSP<<endl;
//				   }
//				   else
//				   {
//					   cout<<i<<"   "<<j<<"   C2C\t"<<seg[i].Trip[j].fitness<<" \t "<<seg[i].Trip[j].cost<<" \t "<<seg[i].Trip[j].endS<<" \t (nCus = "<<seg[i].Trip[j].numCus<<") \t";
//					   curC = seg[i].Trip[j].firstCus;
//					   while (curC > 0)
//					   {
//						   cout<<curC<<"\t"; //cout<<problem->node[curC].id<<"\t";
//						   curC = nextArr[curC];
//					   }
//					   cout<<"("<<seg[i].Trip[j].waitingS<<")"<<endl;
//				   }
//			   }
//			   else
//			   {
//				   cout<<i<<"   "<<j<<"   C2C\t"<<seg[i].Trip[j].fitness<<" \t "<<seg[i].Trip[j].cost<<" \t "<<seg[i].Trip[j].endS<<" \t (nCus = "<<seg[i].Trip[j].numCus<<") \t";
//				   curC = seg[i].Trip[j].firstCus;
//				   while (curC > 0)
//				   {
//					   cout<<curC<<"\t"; //cout<<problem->node[curC].id<<"\t";
//					   curC = nextArr[curC];
//				   }
//				   cout<<"("<<seg[i].Trip[j].waitingS<<")"<<endl;
//			   }
//		   }
//	   }
//   }
//   cout<<fitness<<"   "<<cost<<"   "<<numVehUsed<<endl;
//   if (seg[VM].Trip[TM].Type == 1)
//	   cout<<"DTrip("<<VM<<", "<<TM<<") has maxCus = "<<nCM<<endl;
//   if (seg[VM].Trip[TM].Type == 0)
//	   cout<<"PTrip("<<VM<<", "<<TM<<") has maxCus = "<<nCM<<endl;
//   else
//	   cout<<"C2CTrip("<<VM<<", "<<TM<<") has maxCus = "<<nCM<<endl;
//
//}
//
//
//
//void Solution::showSegment(int idVeh)
//{
//	int j, curC;
//
//       cout<<seg[idVeh].vioTWSP<<"    "<<seg[idVeh].vioTWC<<"    "<<seg[idVeh].cost<<"     "<<seg[idVeh].numTrips<<endl;
//	   for (j=0;j<seg[idVeh].numTrips;j++)
//	   {
//		   if (seg[idVeh].Trip[j].Type==1)
//		   {
//			   cout<<idVeh<<"   "<<j<<"   1\t"<<seg[idVeh].Trip[j].feasible<<"\t"<<seg[idVeh].Trip[j].vioTWC<<"\t"<<seg[idVeh].Trip[j].vioTWSP<<"\t"<<seg[idVeh].Trip[j].leaveSP<<"\t"<<seg[idVeh].Trip[j].endS<<"\t"<<seg[idVeh].Trip[j].fitness<<" \t "<<seg[idVeh].Trip[j].cost<<" \t "<<seg[idVeh].Trip[j].capacity<<" \t (nCus = "<<seg[idVeh].Trip[j].numCus<<") \t";
//			   cout<<seg[idVeh].Trip[j].assSP<<"\t";
//			   curC = seg[idVeh].Trip[j].firstCus;
//			   while (curC > 0)
//			   {
//				   cout<<curC<<" ("<<vioTWCus[curC]<<", "<<depart[curC]<<")\t";//cout<<curC<<" ("<<vioTWCus[curC]<<", "<<FvioTWCus[curC]<<")\t";
//				   curC = nextArr[curC];
//			   }
//			   cout<<seg[idVeh].Trip[j].waitingS<<"; (Connect = "<<seg[idVeh].Trip[j].connectCost<<")"<<endl;
//		   }
//		   else if (seg[idVeh].Trip[j].Type == 0)
//		   {
//			   cout<<idVeh<<"   "<<j<<"   0\t"<<seg[idVeh].Trip[j].feasible<<"\t"<<seg[idVeh].Trip[j].vioTWC<<"\t"<<seg[idVeh].Trip[j].vioTWSP<<"\t"<<seg[idVeh].Trip[j].leaveSP<<"\t"<<seg[idVeh].Trip[j].endS<<"\t"<<seg[idVeh].Trip[j].fitness<<" \t "<<seg[idVeh].Trip[j].cost<<" \t "<<seg[idVeh].Trip[j].capacity<<" \t (nCus = "<<seg[idVeh].Trip[j].numCus<<") \t";
//			   curC = seg[idVeh].Trip[j].firstCus;
//			   while (curC > 0)
//			   {
//				   cout<<curC<<" ("<<vioTWCus[curC]<<", "<<depart[curC]<<")\t";//cout<<curC<<" ("<<vioTWCus[curC]<<", "<<FvioTWCus[curC]<<")\t";
//				   curC = nextArr[curC];
//			   }
//			   cout<<seg[idVeh].Trip[j].waitingS<<"\t";
//			   cout<<seg[idVeh].Trip[j].assSP<<"; (Connect = "<<seg[idVeh].Trip[j].connectCost<<")"<<endl;
//		   }
//		   else 
//		   {
//			   cout<<idVeh<<"   "<<j<<"   2\t"<<seg[idVeh].Trip[j].feasible<<"\t"<<seg[idVeh].Trip[j].vioCAP<<"\t"<<seg[idVeh].Trip[j].vioTWC<<"\t"<<seg[idVeh].Trip[j].endS<<"\t"<<seg[idVeh].Trip[j].fitness<<" \t "<<seg[idVeh].Trip[j].cost<<" \t (nCus = "<<seg[idVeh].Trip[j].numCus<<") \t";
//			   curC = seg[idVeh].Trip[j].firstCus;
//			   while (curC > 0)
//			   {
//				   //cout<<curC<<" (vioTW = "<<vioTWCus[curC]<<", startS = "<<startS[curC]<<", depart = "<<depart[curC]<<")\t";//cout<<curC<<" ("<<vioTWCus[curC]<<", "<<FvioTWCus[curC]<<")\t";
//				   cout<<curC<<" (vioCAP = "<<vioCAPCus[curC]<<"; CAPCus = "<<CAPCus[curC]<<"; FCAP = "<<FCAP[curC]<<"; vioTW = "<<vioTWCus[curC]<<", startS = "<<startS[curC]<<", depart = "<<depart[curC]<<")\t";//cout<<curC<<" ("<<vioTWCus[curC]<<", "<<FvioTWCus[curC]<<")\t";
//				   //cout<<curC<<" (vioCAP = "<<vioCAPCus[curC]<<", CAPCus = "<<CAPCus[curC]<<")\t";//cout<<curC<<" ("<<vioTWCus[curC]<<", "<<FvioTWCus[curC]<<")\t";
//				   curC = nextArr[curC];
//			   }
//			   int nextT = j + 1;
//			   if (nextT < seg[idVeh].numTrips)
//			   {   if (seg[idVeh].Trip[nextT].Type == 0)
//				   {
//					   cout<<" (connect = "<<seg[idVeh].Trip[j].connectCost<<")"<<endl;
//				   }
//				   else
//				   {
//					   cout<<seg[idVeh].Trip[j].waitingS<<"\t";
//					   cout<<seg[idVeh].Trip[j].assSP<<"; (Connect = "<<seg[idVeh].Trip[j].connectCost<<")"<<endl;
//				   }
//			   }
//		   }
//	   }
// }
//
////------------------------------------------- CHECK SOLUTION ----------------------------------//
//bool Solution::checkSolution()
//{
//	int i,j; bool correct = 1;
//	int numVehUsedT = 0;
//	double costSegT, costT=0;
//
//	checkUsed = new bool[totalNODE1];
//	for (i=1;i<=totalNODE;i++) checkUsed[i] = 0;
//	cout<<".................... CHECKSOLUTION........................"<<endl;
//	
//
//	for (i=0;i<numVeh;i++)
//	{
//        if (seg[i].numTrips >0)
//		{
//			numVehUsedT ++; costSegT = 0;
//			for (j=0;j<seg[i].numTrips;j++)
//			{
//				if (seg[i].Trip[j].Type == 1)
//				{
//					//cout<<"Check Dtrip("<<i<<", "<<j<<")"<<endl;
//					correct = checkTripD_checkSolution(i,j);
//					if (correct == 0) 
//					{
//						cout<<"AT Solution::checkSolution: there is error on delivery trip "<<j<<" of vehicle "<<i<<endl;				
//						showTripCost(i,j);
//						cout<<" --------------------------- VEHICLE "<<i<<" -----------------------------------"<<endl;
//						showSegment(i);
//						exit(-1);
//					}
//				}
//				else if (seg[i].Trip[j].Type == 2)
//				{
//					//cout<<"Check C2Ctrip("<<i<<", "<<j<<")"<<endl;
//					correct = checkTripC2C_checkSolution(i,j);
//					if (correct == 0) 
//					{
//						cout<<"AT Solution::checkSolution: there is error on C2C trip "<<j<<" of vehicle "<<i<<endl;				
//						showTripCost(i,j);
//						cout<<" --------------------------- VEHICLE "<<i<<" -----------------------------------"<<endl;
//						showSegment(i);
//						exit(-1);
//					}
//				}
//				else
//				{
//					//Checking tat ca cac thuoc tinh cua tripP:
//					//cout<<"Check Ptrip("<<i<<", "<<j<<")"<<endl;
//					correct = checkTripP_checkSolution(i,j);
//					if (correct == 0) 
//					{
//						cout<<"AT Solution::checkSolution: there is error on pickup trip ("<<i<<", "<<j<<")"<<endl;
//						showTripCost(i,j);
//						exit(-1);
//					}
//					//else cout<<"PICKUP Trip ("<<i<<", "<<j<<", assSP = "<<seg[i].Trip[j].assSP<<") ok after checkTripP_ML_checkSolution"<<endl;
//				}//end (i,j) is pickup trip
//				costSegT += seg[i].Trip[j].cost;
//			}//end for (j=0;j<seg[i].numTrips;j++)
//			if (PDSDIF(costSegT, seg[i].cost))
//			{
//				cout<<"AT Solution::checkSolution: there is error on total cost of vehicle "<<i<<": correct = "<<costSegT<<"; wrong = "<<seg[i].cost<<endl;				
//				exit(-1);
//			}
//			costT += costSegT;
//		}//end if (seg[i].numTrips >0) 
//   }
//   if (numVehUsedT != numVehUsed)
//   {
//		cout<<"ERROR: numVehUsed correct = "<<numVehUsedT<<"; wrong = "<<numVehUsed<<endl;
//		correct = 0;
//   }
//   if (PDSDIF(costT, cost))
//   {
//	    cout<<"ERROR: cost of solution: correct = "<<costT<<"; wrong = "<<cost<<endl;
//		correct = 0;
//   }
//
//	for (i=startidP;i<= endidP;i++) 
//		if (checkUsed[i] == 0)
//		{
//			cout<<"ERROR: pickup customer "<<i<<"(id="<<problem->node[i].id<<") not routed yet"<<endl;
//			correct = 0;
//		}
//
//	for (i=startidD;i<=totalNODE;i++) 
//		if (checkUsed[i] == 0)
//		{
//			cout<<"ERROR: delivery customer "<<i<<"(id = "<<problem->node[i].id<<") not routed yet"<<endl;
//			correct = 0;
//		}
//
//	for (i=startidC2C;i<=endidC2C;i++) 
//		if (checkUsed[i] == 0)
//		{
//			cout<<"ERROR: C2C customer "<<i<<"(id = "<<problem->node[i].id<<") not routed yet"<<endl;
//			correct = 0;
//		}
//	delete [] checkUsed;
//	return correct;
//}
//
//bool Solution::checkTripD_checkSolution(int idVeh, int idTrip) //just checking field of trip; for FEASIBLE TRIP ONLY
//{
//	//see on 27/11/2013
//	bool correct = 1;
//	double cTemp = 0; 
//	int assSP = seg[idVeh].Trip[idTrip].assSP;
//	double leaveSPT, vioTWSPT, cArrTime,temp;
//	int i;
//
//	int buon = seg[idVeh].Trip[idTrip].firstCus;
//	int nbuon = 0;
//	while (buon > 0)
//	{
//		if (buon < startidD)
//		{
//			cout<<"ERROR checkTripD_checkSolution("<<idVeh<<", "<<idTrip<<") cus = "<<buon<<" < startidD(="<<problem->startidC2CD<<")"<<endl;
//			showTripCus(idVeh, idTrip);
//			exit(-1);
//		}
//		else if (buon > endidD)
//		{
//			cout<<"ERROR checkTripD_checkSolution("<<idVeh<<", "<<idTrip<<") cus = "<<buon<<" > endidD(="<<problem->endidD<<")"<<endl;
//			showTripCus(idVeh, idTrip);
//			exit(-1);
//		}
//		nbuon++;
//		buon = nextArr[buon];
//	}
//	if (nbuon != seg[idVeh].Trip[idTrip].numCus)
//	{
//		cout<<"ERROR checkTripD_checkSolution("<<idVeh<<", "<<idTrip<<") numCus: correct = "<<nbuon<<"; wrong = "<<seg[idVeh].Trip[idTrip].numCus<<endl;
//	    showTripCus(idVeh, idTrip);
//		exit(-1);
//	}
//
//	if (idTrip == 0)
//	{
//		if (PDSDIF(seg[idVeh].Trip[0].leaveSP, problem->leaveSP[seg[idVeh].Trip[0].assSP][4]))
//		{
//			cout<<"ERROR checkTripD_checkSolution("<<idVeh<<", "<<idTrip<<") LeaveSP: correct = "<<problem->leaveSP[seg[idVeh].Trip[0].assSP][4]<<"; wrong = "<<seg[idVeh].Trip[0].leaveSP<<endl;
//			correct = 0;
//		}
//		if (seg[idVeh].Trip[idTrip].coordinate==1)
//		{
//			cout<<"ERROR checkTripD_checkSolution("<<idVeh<<", "<<idTrip<<"): correct = NOT coordinate, but coordinate field = "<<seg[idVeh].Trip[idTrip].coordinate<<endl;
//			correct = 0;
//		}			 
//		cTemp += problem->c[0][assSP];
//	}
//	else
//	{
//		 int preT = idTrip - 1; 
//		 if (seg[idVeh].Trip[preT].Type == 0)
//		 {
//			 int assSPpreT = seg[idVeh].Trip[preT].assSP;
//			 if (assSPpreT == assSP)
//			 {
//				 cArrTime = seg[idVeh].Trip[preT].leaveSP - problem->nodeSP[assSP].unload;
//				 if (seg[idVeh].Trip[idTrip].coordinate==0)
//				 {
//					 cout<<"ERROR: checkTripD_checkSolution("<<idVeh<<", "<<idTrip<<"): correct = coordinate, but field coordinate = "<<seg[idVeh].Trip[idTrip].coordinate<<endl;
//					 correct = 0;
//				 }			 
//			 }
//			 else
//			 {
//				 if (seg[idVeh].Trip[preT].waitingS1 == NO_WS)
//	 				cArrTime = seg[idVeh].Trip[preT].leaveSP + problem->c[assSPpreT][assSP];
//				 else cArrTime = seg[idVeh].Trip[preT].leaveSP + problem->disCWSSP[assSPpreT][assSP];
//				 if (seg[idVeh].Trip[idTrip].coordinate==1)
//				 {
//					 cout<<"ERROR: checkTripD_checkSolution("<<idVeh<<", "<<idTrip<<"): correct = NOTcoordinate, but field coordinate = "<<seg[idVeh].Trip[idTrip].coordinate<<endl;
//					 correct = 0;
//				 }			 
//			 }
//			 temp = cArrTime - problem->nodeSP[assSP].eTW2;
//			 if (temp > eps)
//			 {
//				 vioTWSPT = temp;
//				 leaveSPT = problem->nodeSP[assSP].eTW2 + problem->nodeSP[assSP].load;
//			 }
//			 else
//			 {
//				 leaveSPT = PDS_MAX(cArrTime, problem->nodeSP[assSP].sTW2) + problem->nodeSP[assSP].load;
//				 vioTWSPT = 0;
//			 }
//			 if (assSPpreT == assSP && vioTWSPT == 0) leaveSPT += problem->nodeSP[assSP].unload;
//		 }
//		 else //if (seg[idVeh].Trip[preT].Type == 1 || 2)
//		 {
//			 int lastCpreT = seg[idVeh].Trip[preT].lastCus;
//			 if (seg[idVeh].Trip[preT].waitingS == NO_WS)
//	 			cArrTime = depart[lastCpreT] + problem->c[lastCpreT][assSP];
//			 else cArrTime = depart[lastCpreT] + problem->disCWSSP[lastCpreT][assSP];
//			 temp = cArrTime - problem->nodeSP[assSP].eTW2;
//			 if (temp > eps) 
//			 {
//				 vioTWSPT = temp;
//				 leaveSPT = problem->nodeSP[assSP].eTW2;
//			 }
//			 else
//			 {
//				 leaveSPT = PDS_MAX(cArrTime, problem->nodeSP[assSP].sTW2);
//				 vioTWSPT = 0;
//			 }
//			 if (PDSDIF(leaveSPT, seg[idVeh].Trip[preT].arriveSP))
//			 {
//				 cout<<"ERROR: checkTripD_checkSolution: error of preT is Del/C2C Trip("<<idVeh<<", "<<preT<<"): correct arriveSP =  "<<leaveSPT<<"; but field arriveSP = "<<seg[idVeh].Trip[preT].arriveSP<<endl;
//				 correct = 0;
//			 }
//			 leaveSPT += problem->nodeSP[assSP].load;
//			 if (seg[idVeh].Trip[idTrip].coordinate==1)
//			 {
//				 cout<<"ERROR: checkTripD_checkSolution("<<idVeh<<", "<<idTrip<<"): correct =  NOT coordinate, but field coordinate = "<<seg[idVeh].Trip[idTrip].coordinate<<endl;
//				 correct = 0;
//			 }			 
//		 }
//		 if (PDSDIF(leaveSPT, seg[idVeh].Trip[idTrip].leaveSP))
//		 {
//			cout<<"ERRROR checkTripD_checkSolution("<<idVeh<<", "<<idTrip<<"): leaveSP at sp "<<assSP<<": correct = "<<leaveSPT<<"; wrong = "<<seg[idVeh].Trip[idTrip].leaveSP<<endl;
//			cout<<"VioTWSP = "<<seg[idVeh].Trip[idTrip].vioTWSP<<endl;
//			 cout<<"SP = "<<assSP<<"; [sTW2, eTW2] = "<<problem->nodeSP[assSP].sTW2<<", "<<problem->nodeSP[assSP].eTW2<<"]"<<endl;
//			correct = 0;
//		 }
//		 if (PDSDIF(vioTWSPT, seg[idVeh].Trip[idTrip].vioTWSP))
//		 {
//			 cout<<"ERRROR checkTripD_checkSolution("<<idVeh<<", "<<idTrip<<"): vioTWSP at sp "<<assSP<<": correct = "<<temp<<";Field vioTWSP = "<<seg[idVeh].Trip[idTrip].vioTWSP<<endl;
//			 cout<<"SP = "<<assSP<<"; [sTW2, eTW2] = "<<problem->nodeSP[assSP].sTW2<<", "<<problem->nodeSP[assSP].eTW2<<"]"<<endl;
//			 correct = 0;
//		}
//		if (vioTWSPT > eps)
//		{
//			 cout<<"ERRROR checkTripD_checkSolution("<<idVeh<<", "<<idTrip<<"): feasible delivery trip but vioTWSP at sp "<<assSP<<" = "<<vioTWSPT<<"; Field vioTWSP = "<<seg[idVeh].Trip[idTrip].vioTWSP<<endl;
//			 cout<<"SP = "<<assSP<<"; [sTW2, eTW2] = "<<problem->nodeSP[assSP].sTW2<<", "<<problem->nodeSP[assSP].eTW2<<"]"<<endl;
//			 correct = 0;
//		}
//	}
//	if (correct)
//	{
//		int preC  = assSP;
//		int curC = seg[idVeh].Trip[idTrip].firstCus;
//		double endS = seg[idVeh].Trip[idTrip].leaveSP;
//		int CAPT = 0; double vioTWCT;
//
//		for (i=1;i <= seg[idVeh].Trip[idTrip].numCus;i++)
//		{
//			CAPT += problem->node[curC].capacity; 
//			cTemp += problem->c[preC][curC];
//			checkUsed[curC] = 1;
//			//if (curC < startidD) cout<<"ERROR delivery customer curC = "<<curC<<endl;
//			endS += problem->c[preC][curC];
//			vioTWCT = PDS_MAX(endS - problem->node[curC].eTW, 0);
//			if (pos[curC] != i)
//			{
//				correct = 0;
//				cout<<"ERROR checkTripD_checkSolution("<<idVeh<<", "<<idTrip<<") pos["<<curC<<"]: correct = "<<i<<"; wrong = "<<pos[curC]<<endl;
//			}
//			if (route_num[curC] != idVeh)
//			{
//				correct = 0;
//				cout<<"ERROR checkTripD_checkSolution("<<idVeh<<", "<<idTrip<<") route_num["<<curC<<"]: correct = "<<idVeh<<"; wrong = "<<route_num[curC]<<endl;
//			}
//			if (trip_num[curC] != idTrip)
//			{
//				correct = 0;
//				cout<<"ERROR checkTripD_checkSolution("<<idVeh<<", "<<idTrip<<") trip_num["<<curC<<"]: correct = "<<idTrip<<"; wrong = "<<trip_num[curC]<<endl;
//			}
//
//			if (FCAP[curC] != CAPT)
//			{
//				correct = 0;
//				cout<<"ERROR checkTripD_checkSolution("<<idVeh<<", "<<idTrip<<") FCAP["<<curC<<"]: correct = "<<CAPT<<"; wrong = "<<FCAP[curC]<<endl;
//			}
//
//			if (PDSDIF(vioTWCT, vioTWCus[curC])) 
//			{
//				correct = 0;
//				cout<<"ERROR checkTripD_checkSolution("<<idVeh<<", "<<idTrip<<") vioTWCus["<<curC<<"]: correct = "<<vioTWCT<<"; field vioTWCus wrong = "<<vioTWCus[curC]<<endl;
//			}
//			if (vioTWCT > eps)
//			{
//				endS = problem->node[curC].eTW;
//				cout<<"ERROR checkTripD_checkSolution("<<idVeh<<", "<<idTrip<<"): FEASIBLE delivery trip but vioTWCus["<<curC<<"] = "<<vioTWCT<<"; vioTWC = "<<seg[idVeh].Trip[idTrip].vioTWC<<endl;
//			    correct = 0;
//			}
//			else endS = PDS_MAX(endS, problem->node[curC].sTW);
//			if (PDSDIF(endS, startS[curC]))
//			{
//				correct = 0;
//				cout<<"ERROR checkTripD_checkSolution("<<idVeh<<", "<<idTrip<<"): startS["<<curC<<"]: correct = "<<endS<<"; field startS wrong = "<<startS[curC]<<endl;
//			}
//			
//			endS += problem->node[curC].duration;
//			if (PDSDIF(endS, depart[curC]))
//			{
//				correct = 0;
//				cout<<"ERROR checkTripD_checkSolution("<<idVeh<<", "<<idTrip<<"): depart["<<curC<<"]: correct = "<<endS<<"; field depart wrong = "<<depart[curC]<<endl;
//			}
//			preC = curC; curC = nextArr[curC];
//		}
//
//		//preC now points to lastCus
//		if (seg[idVeh].Trip[idTrip].lastCus != preC)
//		{
//			correct = 0;
//			cout<<"ERROR checkTripD_checkSolution("<<idVeh<<", "<<idTrip<<"): lastCus: correct = "<<preC<<"; field lastCus wrong = "<<seg[idVeh].Trip[idTrip].lastCus<<endl;
//		}
//
//		if (CAPT != seg[idVeh].Trip[idTrip].capacity)
//		{
//			cout<<"ERROR checkTripD_checkSolution("<<idVeh<<", "<<idTrip<<") CAP of trip: correct = "<<CAPT<<"; wrong = "<<seg[idVeh].Trip[idTrip].capacity<<endl;
//			correct = 0;
//		}
//		else
//		{
//			int vioCAPT = PDS_MAX(CAPT - problem->Q, 0);
//			if (vioCAPT != seg[idVeh].Trip[idTrip].vioCAP)
//			{
//				correct = 0;
//				cout<<"ERROR checkTripD_checkSolution("<<idVeh<<", "<<idTrip<<") vioCAP: wrong = "<<seg[idVeh].Trip[idTrip].vioCAP<<"; correct = "<<vioCAPT<<endl;
//			}
//			if (vioCAPT > 0)
//			{
//				correct = 0;
//				cout<<"ERROR checkTripD_checkSolution("<<idVeh<<", "<<idTrip<<"): FEASIBLE DELIVERY TRIP but vioCAP = "<<vioCAPT<<endl;
//			}
//
//		}
//
//		double costBetweenCusOnly = seg[idVeh].Trip[idTrip].cost - seg[idVeh].Trip[idTrip].connectCost;
//		if (PDSDIF(costBetweenCusOnly, cTemp))
//		{
//			correct = 1;
//			cout<<"ERROR checkTripD_checkSolution("<<idVeh<<", "<<idTrip<<") total cost between customers only: wrong = "<<costBetweenCusOnly<<"; correct = "<<cTemp<<endl;
//		    cout<<"Field ConnectCost = "<<seg[idVeh].Trip[idTrip].connectCost<<endl;
//		}
//
//		if (PDSDIF(seg[idVeh].Trip[idTrip].endS, endS)==0)
//		{
//				int nextTrip = idTrip + 1;
//				if (nextTrip < seg[idVeh].numTrips) // not last Trip
//				{
//					if (seg[idVeh].Trip[nextTrip].Type == 0) //next trip is pickup trip:
//					{
//						 cTemp += problem->c[preC][seg[idVeh].Trip[nextTrip].firstCus];
//						 if (PDSDIF(problem->c[preC][seg[idVeh].Trip[nextTrip].firstCus],seg[idVeh].Trip[idTrip].connectCost))
//						 {
//							 cout<<"ERROR checkTripD_checkSolution("<<idVeh<<", "<<idTrip<<"): Connectcost: correct = "<<problem->c[preC][seg[idVeh].Trip[nextTrip].firstCus]<<"; error = "<<seg[idVeh].Trip[idTrip].connectCost<<endl;
//							 cout<<"CASE: "<<assSP<<" - DELIVERY TRIP - PICKUP TRIP"<<endl;
//							 correct = 0;
//						 }
//					 	 if (seg[idVeh].Trip[idTrip].waitingS != NO_WS)
//						 {
//							 cout<<"ERROR checkTripD_checkSolution("<<idVeh<<", "<<idTrip<<"): Waiting station: correct = noWS"<<"; wrong = "<<seg[idVeh].Trip[idTrip].waitingS<<endl;
//							 cout<<"CASE: "<<assSP<<" - DELIVERY TRIP - PICKUP TRIP"<<endl;
//							 correct = 0;
//						}
//					}
//					else if (seg[idVeh].Trip[nextTrip].Type == 2) //next trip is C2C:
//					{
//						 cTemp += problem->c[preC][seg[idVeh].Trip[nextTrip].firstCus];
//						 if (PDSDIF(problem->c[preC][seg[idVeh].Trip[nextTrip].firstCus],seg[idVeh].Trip[idTrip].connectCost))
//						 {
//							 cout<<"ERROR checkTripD_checkSolution("<<idVeh<<", "<<idTrip<<"): Connectcost: correct = "<<problem->c[preC][seg[idVeh].Trip[nextTrip].firstCus]<<"; error = "<<seg[idVeh].Trip[idTrip].connectCost<<endl;
//							 cout<<"CASE: SP="<<assSP<<" - DELIVERY TRIP - C2C TRIP"<<endl;
//							 correct = 0;
//						 }
//					 	 if (seg[idVeh].Trip[idTrip].waitingS != NO_WS)
//						 {
//							 cout<<"ERROR checkTripD_checkSolution("<<idVeh<<", "<<idTrip<<"): Waiting station: correct = noWS"<<"; wrong = "<<seg[idVeh].Trip[idTrip].waitingS<<endl;
//							 cout<<"CASE: SP = "<<assSP<<" - DELIVERY TRIP - C2C TRIP"<<endl;
//							 correct = 0;
//						}
//					}
//					else //next trip is delivery trip:
//					{
//						 int endSP = seg[idVeh].Trip[nextTrip].assSP;
//						 double cArrTime = endS + problem->c[preC][endSP];
//						 if (PDSINRANGE(cArrTime, problem->nodeSP[endSP].sTW2, problem->nodeSP[endSP].eTW2))
//						 {
//							 cTemp +=  problem->c[preC][endSP];
//
//							 if (PDSDIF(problem->c[preC][endSP],seg[idVeh].Trip[idTrip].connectCost))
//							 {
//								 cout<<"ERROR checkTripD_checkSolution("<<idVeh<<", "<<idTrip<<"): Connectcost : correct = "<<problem->c[preC][endSP]<<"; error = "<<seg[idVeh].Trip[idTrip].connectCost<<endl;
//								 cout<<"CASE: "<<assSP<<" - DELIVERY TRIP - sp = "<<(endSP)<<" - DELIVERY TRIP"<<endl;
//								 correct = 0;
//							 }
//							 if (seg[idVeh].Trip[idTrip].waitingS != NO_WS)
//							 {
//								 cout<<"ERROR checkTripD_checkSolution("<<idVeh<<", "<<idTrip<<"): Waiting station: correct = noWS"<<"; wrong = "<<seg[idVeh].Trip[idTrip].waitingS<<endl;
//								 cout<<"CASE: "<<assSP<<" - DELIVERY TRIP - sp = "<<(endSP)<<" - DELIVERY TRIP"<<endl;
//								 correct = 0;
//							 }
//							 if (seg[idVeh].Trip[nextTrip].vioTWSP > eps)
//							 {
//								 cout<<"ERROR checkTripD_checkSolution("<<idVeh<<", "<<idTrip<<"): vioTWSP : correct = 0; wrong = "<<seg[idVeh].Trip[nextTrip].vioTWSP<<endl;
//								 cout<<"CASE: "<<assSP<<" - DELIVERY TRIP - sp = "<<(endSP)<<" - DELIVERY TRIP"<<endl;
//								 correct = 0;
//							 }
//							 if (PDSDIF(cArrTime,seg[idVeh].Trip[idTrip].arriveSP))
//							 {
//								 cout<<"ERROR checkTripD_checkSolution("<<idVeh<<", "<<idTrip<<"): arriveSP : correct = "<<cArrTime<<"; but field arriveSP = "<<seg[idVeh].Trip[idTrip].arriveSP<<endl;
//								 cout<<"CASE: "<<assSP<<" - DELIVERY TRIP - sp = "<<(endSP)<<" - DELIVERY TRIP"<<endl;
//								 correct = 0;
//							 }
//
//						 }
//						 else
//						 {
//							  temp = cArrTime - problem->nodeSP[endSP].eTW2;
//							  if (temp > eps)
//							  {
//								  if (PDSDIF(problem->c[preC][endSP],seg[idVeh].Trip[idTrip].connectCost))
//								  {
//									 cout<<"ERROR checkTripD_checkSolution("<<idVeh<<", "<<idTrip<<"): Connectcost : correct = "<<problem->c[preC][endSP]<<"; error = "<<seg[idVeh].Trip[idTrip].connectCost<<endl;
//									 cout<<"CASE: "<<assSP<<" - DELIVERY TRIP - sp = "<<(endSP)<<" - DELIVERY TRIP; exceed eTW2"<<endl;
//									 correct = 0;
//								  }
//								  if (seg[idVeh].Trip[idTrip].waitingS != NO_WS)
//								  {
//									 cout<<"ERROR checkTripD_checkSolution("<<idVeh<<", "<<idTrip<<"): Waiting station: correct = noWS"<<"; wrong = "<<seg[idVeh].Trip[idTrip].waitingS<<endl;
//									 cout<<"CASE: "<<assSP<<" - DELIVERY TRIP - sp = "<<(endSP)<<" - DELIVERY TRIP; exceed eTW2"<<endl;
//									 correct = 0;
//								  }
//
//								  if (PDSDIF(temp, seg[idVeh].Trip[nextTrip].vioTWSP))
//								  {
//									  cout<<"ERROR checkTripD_checkSolution("<<idVeh<<", "<<idTrip<<"): vioTWSP : correct = "<<temp<<"; wrong = "<<seg[idVeh].Trip[nextTrip].vioTWSP<<endl;
//									  cout<<"CASE: "<<assSP<<" - DELIVERY TRIP - sp = "<<(endSP)<<" - DELIVERY TRIP; exceed eTW2"<<endl;
//									  correct = 0;
//								  }
//								  if (temp > eps)
//								  {
//									  cout<<"ERROR checkTripD_checkSolution("<<idVeh<<", "<<idTrip<<"): feasible trip but vioTWSP = "<<temp<<endl;
//									  cout<<"CASE: "<<assSP<<" - DELIVERY TRIP - sp = "<<(endSP)<<" - DELIVERY TRIP; exceed eTW2"<<endl;
//									  correct = 0;
//								  }
//								  if (PDSDIF(problem->nodeSP[endSP].eTW2,seg[idVeh].Trip[idTrip].arriveSP))
//								  {
//									 cout<<"ERROR checkTripD_checkSolution("<<idVeh<<", "<<idTrip<<"): arriveSP : correct = "<<problem->nodeSP[endSP].eTW2<<"; but field arriveSP = "<<seg[idVeh].Trip[idTrip].arriveSP<<endl;
//									 cout<<"CASE: "<<assSP<<" - DELIVERY TRIP - sp = "<<(endSP)<<" - DELIVERY TRIP"<<endl;
//									 correct = 0;
//								  }
//
//	  							  cTemp +=  problem->c[preC][endSP];
//							  }
//							  else
//							  {
//								  double cArrTimeI = endS + problem->disCWSSP[preC][endSP];
//								  temp = cArrTimeI - problem->nodeSP[endSP].eTW2;
//								  if (temp > eps)
//								  {
//									  if (PDSDIF(problem->c[preC][endSP],seg[idVeh].Trip[idTrip].connectCost))
//									  {
//										 cout<<"ERROR checkTripD_checkSolution("<<idVeh<<", "<<idTrip<<"): Connectcost : correct = "<<problem->c[preC][endSP]<<"; error = "<<seg[idVeh].Trip[idTrip].connectCost<<endl;
//										 cout<<"CASE: "<<assSP<<" - DELIVERY TRIP - sp = "<<(endSP)<<" - DELIVERY TRIP; too soon to sp directly; too late through WS"<<endl;
//										 correct = 0;
//									  }
//									  if (seg[idVeh].Trip[idTrip].waitingS != NO_WS)
//									  {
//										 cout<<"ERROR checkTripD_checkSolution("<<idVeh<<", "<<idTrip<<"): Waiting station: correct = noWS"<<"; wrong = "<<seg[idVeh].Trip[idTrip].waitingS<<endl;
//										 cout<<"CASE: "<<assSP<<" - DELIVERY TRIP - sp = "<<(endSP)<<" - DELIVERY TRIP; too soon to sp directly; too late through WS"<<endl;
//										 correct = 0;
//									  }
//									  if (PDSDIF(problem->nodeSP[endSP].eTW2,seg[idVeh].Trip[idTrip].arriveSP))
//									  {
//										 cout<<"ERROR checkTripD_checkSolution("<<idVeh<<", "<<idTrip<<"): arriveSP : correct = "<<problem->nodeSP[endSP].eTW2<<"; but field arriveSP = "<<seg[idVeh].Trip[idTrip].arriveSP<<endl;
//										 cout<<"CASE: "<<assSP<<" - DELIVERY TRIP - sp = "<<(endSP)<<" - DELIVERY TRIP"<<endl;
//										 correct = 0;
//									  }
//
//									  temp = problem->nodeSP[endSP].sTW2 - cArrTime;
//									  if (PDSDIF(temp, seg[idVeh].Trip[nextTrip].vioTWSP))
//									  {
//										  cout<<"ERROR checkTripD_checkSolution("<<idVeh<<", "<<idTrip<<"): vioTWSP : correct = "<<temp<<"; wrong = "<<seg[idVeh].Trip[nextTrip].vioTWSP<<endl;
//										 cout<<"CASE: "<<assSP<<" - DELIVERY TRIP - sp = "<<(endSP)<<" - DELIVERY TRIP; too soon to sp directly; too late through WS"<<endl;
//										  correct = 0;
//									  }
//									  
//									  cout<<"ERROR checkTripD_checkSolution("<<idVeh<<", "<<idTrip<<"): feasible delivery trip but vioTWSP = "<<temp<<endl;
//									  cout<<"CASE: "<<assSP<<" - DELIVERY TRIP - sp = "<<(endSP)<<" - DELIVERY TRIP; too soon to sp directly; too late through WS"<<endl;
//									  correct = 0;
//									  cTemp +=  problem->c[preC][endSP];
//								  }
//								  else //through WS:
//								  {
//									  if (PDSDIF(problem->disCWSSP[preC][endSP],seg[idVeh].Trip[idTrip].connectCost))
//									  {
//										 cout<<"ERROR checkTripD_checkSolution("<<idVeh<<", "<<idTrip<<"): Connectcost : correct = "<<problem->disCWSSP[preC][endSP]<<"; error = "<<seg[idVeh].Trip[idTrip].connectCost<<endl;
//										 cout<<"CASE: "<<assSP<<" - DELIVERY TRIP - sp = "<<(endSP)<<" - DELIVERY TRIP; through WS"<<endl;
//										 correct = 0;
//									  }
//									  if (seg[idVeh].Trip[idTrip].waitingS != problem->CWSSP[preC][endSP])
//									  {
//										  cout<<"ERROR checkTripD_checkSolution("<<idVeh<<", "<<idTrip<<"): Waiting station: correct = "<<problem->CWSSP[preC][endSP]<<"; wrong = "<<seg[idVeh].Trip[idTrip].waitingS<<endl;
//										  cout<<"CASE: "<<assSP<<" - DELIVERY TRIP - sp = "<<(endSP)<<" - DELIVERY TRIP; through WS"<<endl;
//										  correct = 0;
//									  }
//
//									  if (seg[idVeh].Trip[nextTrip].vioTWSP > eps)
//									  {
//										  cout<<"ERROR checkTripD_checkSolution("<<idVeh<<", "<<idTrip<<"): vioTWSP : correct = 0; wrong = "<<seg[idVeh].Trip[nextTrip].vioTWSP<<endl;
//										  cout<<"CASE: "<<assSP<<" - DELIVERY TRIP - sp = "<<(endSP)<<" - DELIVERY TRIP; through WS"<<endl;
//										  correct = 0;
//									  }
//									  cTemp += problem->disCWSSP[preC][endSP];
//									  cArrTime = PDS_MAX(cArrTimeI, problem->nodeSP[endSP].sTW2);
//									  if (PDSDIF(cArrTime,seg[idVeh].Trip[idTrip].arriveSP))
//									  { 
//										 cout<<"ERROR checkTripD_checkSolution("<<idVeh<<", "<<idTrip<<"): arriveSP : correct = "<<cArrTime<<"; but field arriveSP = "<<seg[idVeh].Trip[idTrip].arriveSP<<endl;
//										 cout<<"CASE: "<<assSP<<" - DELIVERY TRIP - (WS) sp = "<<(endSP)<<" - DELIVERY TRIP"<<endl;
//										 correct = 0;
//									  }
//								  }//end through WS
//							  }
//						 }
//					}
//				}
//				else //the lastTrip
//				{
//					if (PDSDIF(seg[idVeh].Trip[idTrip].connectCost, problem->c[preC][0]))
//					{
//						cout<<"ERROR checkTripD_checkSolution("<<idVeh<<", "<<idTrip<<"): connectCost of the last delivery Trip: correct = "<<problem->c[preC][0]<<"; wrong = "<<seg[idVeh].Trip[idTrip].connectCost<<endl;
//						correct = 0;
//					}
//					cTemp += problem->c[preC][0];
//				}//end the lastTrip
//				if (PDSDIF(cTemp,seg[idVeh].Trip[idTrip].cost))
//				{
//					 cout<<"ERROR checkTripD_checkSolution("<<idVeh<<", "<<idTrip<<") cost: correct = "<<cTemp<<"; error = "<<seg[idVeh].Trip[idTrip].cost<<endl;
//					 correct = 0;
//				}
//				//Checking BCAP:
//				curC = seg[idVeh].Trip[idTrip].lastCus; int BCAPT = 0; double BvioTWCusT = 0;
//				do
//				{
//					BCAPT += problem->node[curC].capacity;
//					BvioTWCusT += vioTWCus[curC];
//					if  (BCAP[curC] != BCAPT)
//					{
//						correct = 0;
//						cout<<"ERROR checkTripD_checkSolution("<<idVeh<<", "<<idTrip<<"): BCAP["<<curC<<"]: wrong = "<<BCAP[curC]<<"; correct = "<<BCAPT<<endl;
//					}
//					if  (PDSDIF(BvioTWCusT, BvioTWCus[curC]))
//					{
//						correct = 0;
//						cout<<"ERROR checkTripD_checkSolution("<<idVeh<<", "<<idTrip<<"): BvioTWCus["<<curC<<"]: wrong = "<<BvioTWCus[curC]<<"; correct = "<<BvioTWCusT<<endl;
//					}
//					curC = predArr[curC];
//				}while (curC > 0);
//		}
//		else 
//		{
//			cout<<"ERROR checkTripD_checkSolution("<<idVeh<<", "<<idTrip<<"): endS: correct = "<<endS<<"; wrong = "<<seg[idVeh].Trip[idTrip].endS<<endl;
//			correct = 0;
//		}
//	}
//	return correct;
//}
//
//
//
//
//bool Solution::checkTripP_checkSolution(int idVeh, int idTrip) //just checking field of trip; for FEASIBLE TRIP only
//{
//	//see on 27//11/2013
//	bool correct = 1;
//	double cTemp = 0; 
//
//	int assSP = seg[idVeh].Trip[idTrip].assSP;
//	int preC = seg[idVeh].Trip[idTrip].firstCus;
//	int curC, i;
//	double endS, cArrTime, cArrTimeI, temp;
//	curC = seg[idVeh].Trip[idTrip].firstCus;
//	int CAPT = 0; double vioTWCT;
//
//	int buon = seg[idVeh].Trip[idTrip].firstCus;
//	int nbuon = 0;
//	bool chan = 0;
//	while (buon > 0)
//	{
//		nbuon++;
//		if (buon > endidP) 
//		{
//			cout<<"ERROR checkTripP_checkSolution("<<idVeh<<", "<<idTrip<<") cus exceed ID = "<<buon<<" > "<<endidP<<endl;
//			chan = 1;
//		}
//		if (buon < startidP) 
//		{
//			cout<<"ERROR checkTripP_checkSolution("<<idVeh<<", "<<idTrip<<") cus smaller ID = "<<buon<<" < "<<startidP<<endl;
//		}
//		if (problem->belong[buon][assSP] != 1)
//		{
//			cout<<"ERROR checkTripP_checkSolution("<<idVeh<<", "<<idTrip<<") cus "<<buon<<" CANNOT assign to sp "<<assSP<<endl;
//			cout<<"List available sp of cus "<<buon<<":  ";
//			for (i = 1; i<= problem->node[buon].numSP; i++)
//				cout<<problem->node[buon].sp[i]<<",  ";
//			cout<<endl;
//			chan = 1;
//		}
//		buon = nextArr[buon];
//	}
//	if (chan)
//	{
//	    showTripCus(idVeh, idTrip);
//		exit(-1);
//	}
//
//	if (nbuon != seg[idVeh].Trip[idTrip].numCus)
//	{
//		cout<<"ERROR checkTripP_checkSolution("<<idVeh<<", "<<idTrip<<") numCus: correct = "<<nbuon<<"; wrong = "<<seg[idVeh].Trip[idTrip].numCus<<endl;
//        showTripCus(idVeh, idTrip);
//		exit(-1);
//	}
//
//	if (idTrip == 0)
//	{
//		if (seg[idVeh].Trip[idTrip].numCus == 1)
//		{
//			endS = problem->startSOneP[curC][assSP];
//			cTemp = problem->c[0][curC];
//			CAPT += problem->node[curC].capacity; 
//			checkUsed[curC] = 1;
//			if (pos[curC] != 1)
//			{
//				correct = 0;
//				cout<<"ERROR checkTripP_checkSolution("<<idVeh<<", "<<idTrip<<") pos["<<curC<<"]: correct = 1; wrong = "<<pos[curC]<<endl;
//			}
//			if (route_num[curC] != idVeh)
//			{
//				correct = 0;
//				cout<<"ERROR checkTripP_checkSolution("<<idVeh<<", "<<idTrip<<") route_num["<<curC<<"]: correct = "<<idVeh<<"; wrong = "<<route_num[curC]<<endl;
//			}
//			if (trip_num[curC] != idTrip)
//			{
//				correct = 0;
//				cout<<"ERROR checkTripP_checkSolution("<<idVeh<<", "<<idTrip<<") trip_num["<<curC<<"]: correct = "<<idTrip<<"; wrong = "<<trip_num[curC]<<endl;
//			}
//
//			if (FCAP[curC] != CAPT)
//			{
//				correct = 0;
//				cout<<"ERROR checkTripP_checkSolution("<<idVeh<<", "<<idTrip<<") FCAP["<<curC<<"]: correct = "<<CAPT<<"; wrong = "<<FCAP[curC]<<endl;
//			}
//
//			if (PDSDIF(endS, startS[curC]))
//			{
//				correct = 0;
//				cout<<"ERROR checkTripP_checkSolution("<<idVeh<<", "<<idTrip<<"): startS["<<curC<<"]: wrong = "<<startS[curC]<<"; correct = "<<endS<<endl;
//			}
//			
//			endS += problem->node[curC].duration;
//			if (PDSDIF(endS, depart[curC]))
//			{
//				correct = 0;
//				cout<<"ERROR checkTripP_checkSolution("<<idVeh<<", "<<idTrip<<"): depart["<<curC<<"]: wrong = "<<depart[curC]<<"; correct = "<<endS<<endl;
//			}
//			preC = curC;
//		}
//		else //numCus >= 2
//		{
//			endS = PDS_MAX(problem->c[0][curC], problem->node[curC].sTW);
//			cTemp = problem->c[0][curC];
//			CAPT += problem->node[curC].capacity; 
//			checkUsed[curC] = 1;
//			if (pos[curC] != 1)
//			{
//				correct = 0;
//				cout<<"ERROR checkTripP_checkSolution("<<idVeh<<", "<<idTrip<<") pos["<<curC<<"]: correct = 1; wrong = "<<pos[curC]<<endl;
//			}
//			if (route_num[curC] != idVeh)
//			{
//				correct = 0;
//				cout<<"ERROR checkTripP_checkSolution("<<idVeh<<", "<<idTrip<<") route_num["<<curC<<"]: correct = "<<idVeh<<"; wrong = "<<route_num[curC]<<endl;
//			}
//			if (trip_num[curC] != idTrip)
//			{
//				correct = 0;
//				cout<<"ERROR checkTripP_checkSolution("<<idVeh<<", "<<idTrip<<") trip_num["<<curC<<"]: correct = "<<idTrip<<"; wrong = "<<trip_num[curC]<<endl;
//			}
//
//			if (FCAP[curC] != CAPT)
//			{
//				correct = 0;
//				cout<<"ERROR checkTripP_checkSolution("<<idVeh<<", "<<idTrip<<") FCAP["<<curC<<"]: correct = "<<CAPT<<"; wrong = "<<FCAP[curC]<<endl;
//			}
//
//			if (PDSDIF(endS, startS[curC]))
//			{
//				correct = 0;
//				cout<<"ERROR checkTripP_checkSolution("<<idVeh<<", "<<idTrip<<"): startS["<<curC<<"]: wrong = "<<startS[curC]<<"; correct = "<<endS<<endl;
//			}
//			
//			endS += problem->node[curC].duration;
//			if (PDSDIF(endS, depart[curC]))
//			{
//				correct = 0;
//				cout<<"ERROR checkTripP_checkSolution("<<idVeh<<", "<<idTrip<<"): depart["<<curC<<"]: wrong = "<<depart[curC]<<"; correct = "<<endS<<endl;
//			}
//
//			preC = curC; curC = nextArr[curC];
//			for (i=2;i<=seg[idVeh].Trip[idTrip].numCus;i++)
//			{
//					CAPT += problem->node[curC].capacity; 
//					cTemp += problem->c[preC][curC];
//					endS += problem->c[preC][curC];
//					//if (curC > endidP) cout<<"ERROR pickup customer curC = "<<curC<<endl;
//
//					checkUsed[curC] = 1;
//					vioTWCT = PDS_MAX(endS - problem->node[curC].eTW, 0);
//					if (pos[curC] != i)
//					{
//						correct = 0;
//						cout<<"ERROR checkTripP_checkSolution("<<idVeh<<", "<<idTrip<<") pos["<<curC<<"]: correct = "<<i<<"; wrong = "<<pos[curC]<<endl;
//					}
//					if (route_num[curC] != idVeh)
//					{
//						correct = 0;
//						cout<<"ERROR checkTripP_checkSolution("<<idVeh<<", "<<idTrip<<") route_num["<<curC<<"]: correct = "<<idVeh<<"; wrong = "<<route_num[curC]<<endl;
//					}
//					if (trip_num[curC] != idTrip)
//					{
//						correct = 0;
//						cout<<"ERROR checkTripP_checkSolution("<<idVeh<<", "<<idTrip<<") trip_num["<<curC<<"]: correct = "<<idTrip<<"; wrong = "<<trip_num[curC]<<endl;
//					}
//
//					if (FCAP[curC] != CAPT)
//					{
//						correct = 0;
//						cout<<"ERROR checkTripP_checkSolution("<<idVeh<<", "<<idTrip<<") FCAP["<<curC<<"]: correct = "<<CAPT<<"; wrong = "<<FCAP[curC]<<endl;
//					}
//
//					if (PDSDIF(vioTWCT, vioTWCus[curC])) 
//					{
//						correct = 0;
//						cout<<"ERROR checkTripP_checkSolution("<<idVeh<<", "<<idTrip<<"): vioTWCus["<<curC<<"]: wrong = "<<vioTWCus[curC]<<"; correct = "<<vioTWCT<<endl;
//					}
//					if (vioTWCT > eps)
//					{
//						endS = problem->node[curC].eTW;
//						cout<<"ERROR checkTripP_checkSolution("<<idVeh<<", "<<idTrip<<"): feasible pickup trip but vioTWCus["<<curC<<"] = "<<vioTWCT<<endl;
//						correct = 0;
//					}
//					else endS = PDS_MAX(endS, problem->node[curC].sTW);
//
//					if (PDSDIF(endS, startS[curC]))
//					{
//						correct = 0;
//						cout<<"ERROR checkTripP_checkSolution("<<idVeh<<", "<<idTrip<<"): startS["<<curC<<"]: wrong = "<<startS[curC]<<"; correct = "<<endS<<endl;
//					}
//					
//					endS += problem->node[curC].duration;
//					if (PDSDIF(endS, depart[curC]))
//					{
//						correct = 0;
//						cout<<"ERROR checkTripP_checkSolution("<<idVeh<<", "<<idTrip<<"): depart["<<curC<<"]: wrong = "<<depart[curC]<<"; correct = "<<endS<<endl;
//					}
//					preC = curC; curC = nextArr[curC];
//			}
//		}//end numCus > 2
//	}
//	else
//	{
//		int preT = idTrip - 1;
//		if (seg[idVeh].Trip[preT].Type == 0)
//		{
//			preC = seg[idVeh].Trip[preT].assSP;
//			endS = seg[idVeh].Trip[preT].leaveSP;
//		}
//		else
//		{
//			preC = seg[idVeh].Trip[preT].lastCus;
//			endS = depart[preC];
//		}
//		cTemp =-problem->c[preC][curC];
//		for (i=1;i<=seg[idVeh].Trip[idTrip].numCus;i++)
//		{
//				CAPT += problem->node[curC].capacity; 
//				cTemp += problem->c[preC][curC];
//				endS += problem->c[preC][curC];
//				//if (curC > endidP) cout<<"ERROR pickup customer curC = "<<curC<<endl;
//
//				checkUsed[curC] = 1;
//				vioTWCT = PDS_MAX(endS - problem->node[curC].eTW, 0);
//				if (pos[curC] != i)
//				{
//					correct = 0;
//					cout<<"ERROR checkTripP_checkSolution("<<idVeh<<", "<<idTrip<<") pos["<<curC<<"]: correct = "<<i<<"; wrong = "<<pos[curC]<<endl;
//				}
//				if (route_num[curC] != idVeh)
//				{
//					correct = 0;
//					cout<<"ERROR checkTripP_checkSolution("<<idVeh<<", "<<idTrip<<") route_num["<<curC<<"]: correct = "<<idVeh<<"; wrong = "<<route_num[curC]<<endl;
//				}
//				if (trip_num[curC] != idTrip)
//				{
//					correct = 0;
//					cout<<"ERROR checkTripP_checkSolution("<<idVeh<<", "<<idTrip<<") trip_num["<<curC<<"]: correct = "<<idTrip<<"; wrong = "<<trip_num[curC]<<endl;
//				}
//
//				if (FCAP[curC] != CAPT)
//				{
//					correct = 0;
//					cout<<"ERROR checkTripP_checkSolution("<<idVeh<<", "<<idTrip<<") FCAP["<<curC<<"]: correct = "<<CAPT<<"; wrong = "<<FCAP[curC]<<endl;
//				}
//
//				if (PDSDIF(vioTWCT, vioTWCus[curC])) 
//				{
//					correct = 0;
//					cout<<"ERROR checkTripP_checkSolution("<<idVeh<<", "<<idTrip<<"): vioTWCus["<<curC<<"]: wrong = "<<vioTWCus[curC]<<"; correct = "<<vioTWCT<<endl;
//				}
//				if (vioTWCT > eps)
//				{
//					endS = problem->node[curC].eTW;
//					cout<<"ERROR checkTripP_checkSolution("<<idVeh<<", "<<idTrip<<"): feasible pickup trip but vioTWCus["<<curC<<"] = "<<vioTWCT<<endl;
//					correct = 0;
//				}
//				else endS = PDS_MAX(endS, problem->node[curC].sTW);
//
//				if (PDSDIF(endS, startS[curC]))
//				{
//					correct = 0;
//					cout<<"ERROR checkTripP_checkSolution("<<idVeh<<", "<<idTrip<<"): startS["<<curC<<"]: wrong = "<<startS[curC]<<"; correct = "<<endS<<endl;
//				}
//				
//				endS += problem->node[curC].duration;
//				if (PDSDIF(endS, depart[curC]))
//				{
//					correct = 0;
//					cout<<"ERROR checkTripP_checkSolution("<<idVeh<<", "<<idTrip<<"): depart["<<curC<<"]: wrong = "<<depart[curC]<<"; correct = "<<endS<<endl;
//				}
//				preC = curC; curC = nextArr[curC];
//		}
//	}
//
//	//preC now points to lastCus
//	if (seg[idVeh].Trip[idTrip].lastCus != preC)
//	{
//		correct = 0;
//		cout<<"ERROR checkTripP_checkSolution("<<idVeh<<", "<<idTrip<<"): lastCus: correct = "<<preC<<"; field lastCus wrong = "<<seg[idVeh].Trip[idTrip].lastCus<<endl;
//	}
//
//
//	if (CAPT != seg[idVeh].Trip[idTrip].capacity)
//	{
//		cout<<"ERROR checkTripP_checkSolution("<<idVeh<<", "<<idTrip<<"): cap of trip: correct = "<<CAPT<<"; wrong = "<<seg[idVeh].Trip[idTrip].capacity<<endl;
//		correct = 0;
//	}
//	else
//	{
//		int vioCAPT = PDS_MAX(CAPT - problem->Q, 0);
//		if (vioCAPT != seg[idVeh].Trip[idTrip].vioCAP)
//		{
//			correct = 0;
//			cout<<"ERROR checkTripP_checkSolution("<<idVeh<<", "<<idTrip<<"): vioCAP: wrong = "<<seg[idVeh].Trip[idTrip].vioCAP<<"; correct = "<<vioCAPT<<endl;
//		}
//		if (vioCAPT > 0)
//		{
//			correct = 0;
//			cout<<"ERROR checkTripP_checkSolution("<<idVeh<<", "<<idTrip<<"): feasible pickup trip but vioCAP = "<<vioCAPT<<endl;
//		}
//
//	}
//
//		if (PDSDIF(seg[idVeh].Trip[idTrip].endS, endS)==0)
//		{
//			cArrTime = endS + problem->c[preC][assSP];
//			if (PDSINRANGE(cArrTime, problem->nodeSP[assSP].sTW1, problem->nodeSP[assSP].eTW1))
//			{
//				cTemp += problem->c[preC][assSP];
//				if (seg[idVeh].Trip[idTrip].waitingS != NO_WS)
//				{
//					cout<<"ERROR checkTripP_checkSolution("<<idVeh<<", "<<idTrip<<"): correct waitingS = NO_WS; wrong = "<<seg[idVeh].Trip[idTrip].waitingS<<endl;
//					correct = 0;
//				}
//				if (seg[idVeh].Trip[idTrip].vioTWSP > eps)
//				{
//					cout<<"ERROR checkTripP_checkSolution("<<idVeh<<", "<<idTrip<<"): correct vioTWSP = 0; wrong = "<<seg[idVeh].Trip[idTrip].vioTWSP<<endl;
//					correct = 0;
//				}
//				endS = cArrTime + problem->nodeSP[assSP].unload;
//			}
//			else
//			{
//				temp = cArrTime - problem->nodeSP[assSP].eTW1;
//				if (temp > eps)
//				{
//					if (seg[idVeh].Trip[idTrip].waitingS != NO_WS)
//						cout<<"ERROR checkTripP_checkSolution("<<idVeh<<", "<<idTrip<<"): correct waitingS = NO_WS; wrong = "<<seg[idVeh].Trip[idTrip].waitingS<<endl;
//					if (PDSDIF(temp, seg[idVeh].Trip[idTrip].vioTWSP))
//						cout<<"ERROR checkTripP_checkSolution("<<idVeh<<", "<<idTrip<<"): correct vioTWSP = "<<temp<<"; wrong = "<<seg[idVeh].Trip[idTrip].vioTWSP<<endl;
//					
//					cout<<"ERROR checkTripP_checkSolution("<<idVeh<<", "<<idTrip<<"): feasible pickup trip but vioTWSP = "<<temp<<endl;
//					cout<<"CASE exceed eTW1 of sp "<<assSP<<"; eTW1 = "<<problem->nodeSP[assSP].eTW1<<"; cArrTime = "<<cArrTime<<endl;
//					correct = 0;
//					endS = problem->leaveSP[assSP][0]; //unload at eTW1
//					cTemp += problem->c[preC][assSP];
//				}
//				else
//				{
//					double cArrTimeI = endS + problem->disCWSSP[preC][assSP];
//					temp = cArrTimeI - problem->nodeSP[assSP].eTW1;
//					if (temp > eps)
//					{
//						temp = cArrTime - problem->nodeSP[assSP].sTW1;
//						if (PDSDIF(temp, seg[idVeh].Trip[idTrip].vioTWSP))
//							cout<<"ERROR checkTripP_checkSolution("<<idVeh<<", "<<idTrip<<"): correct vioTWSP = "<<temp<<"; wrong = "<<seg[idVeh].Trip[idTrip].vioTWSP<<endl;
//						if (seg[idVeh].Trip[idTrip].waitingS != NO_WS)
//							cout<<"ERROR checkTripP_checkSolution("<<idVeh<<", "<<idTrip<<"): correct waitingS = NO_WS; wrong = "<<seg[idVeh].Trip[idTrip].waitingS<<endl;
//
//						cout<<"ERROR checkTripP_checkSolution("<<idVeh<<", "<<idTrip<<"): feasible pickup trip but vioTWSP = "<<temp<<endl;
//						cout<<"CASE too soon to go sp directly; too late through WS: cArrTimeD = "<<cArrTime<<"; cArrTimeIndirectly = "<<cArrTimeI<<"; eTW1 = "<<problem->nodeSP[assSP].eTW1<<endl;
//						correct = 0;
//						endS = problem->leaveSP[assSP][0]; //unload at eTW1
//						cTemp += problem->c[preC][assSP];
//					}
//					else
//					{
//						cTemp += problem->disCWSSP[preC][assSP];
//						if (seg[idVeh].Trip[idTrip].waitingS != problem->CWSSP[preC][assSP])
//						{
//							cout<<"ERROR checkTripP_checkSolution("<<idVeh<<", "<<idTrip<<"): correct waitingS = "<<problem->CWSSP[preC][assSP]<<"; wrong = "<<seg[idVeh].Trip[idTrip].waitingS<<endl;
//							cout<<"LastCus of trip = "<<preC<<" !=? "<<seg[idVeh].Trip[idTrip].lastCus<<endl;
//							cout<<"CASE to go through WS"<<endl;
//							correct = 0;
//						}
//						if (seg[idVeh].Trip[idTrip].vioTWSP > eps)
//						{
//							cout<<"ERROR checkTripP_checkSolution("<<idVeh<<", "<<idTrip<<"): correct vioTWSP = 0; wrong = "<<seg[idVeh].Trip[idTrip].vioTWSP<<endl;
//							cout<<"CASE to go through WS"<<endl;
//							correct = 0;
//						}
//						endS = PDS_MAX(cArrTimeI, problem->nodeSP[assSP].sTW1) + problem->nodeSP[assSP].unload;
//					}
//				}
//			}
//			if (correct)
//			{
//				double costT = seg[idVeh].Trip[idTrip].cost - seg[idVeh].Trip[idTrip].connectCost;
//				if (PDSDIF(cTemp, costT))
//				{
//					cout<<"ERROR checkTripP_checkSolution("<<idVeh<<", "<<idTrip<<"): cost (between cus and SP, exclude connectCost): correct = "<<cTemp<<"; wrong = "<<costT<<endl;
//					correct = 0;
//				}
//				else
//				{
//					int lastT = seg[idVeh].numTrips - 1;
//					if (idTrip == lastT)
//					{
//						if (PDSDIF(endS,seg[idVeh].Trip[idTrip].leaveSP))
//						{
//							cout<<"ERROR checkTripP_checkSolution("<<idVeh<<", "<<idTrip<<"): leaveSP correct = "<<endS<<"; wrong = "<<seg[idVeh].Trip[idTrip].leaveSP<<endl;
//							cout<<"CASE: last pickup trip"<<endl;
//							correct = 0;
//						}
//
//						if (PDSDIF(problem->c[assSP][0], seg[idVeh].Trip[idTrip].connectCost))
//						{
//							cout<<"ERROR checkTripP_checkSolution("<<idVeh<<", "<<idTrip<<"): Connectcost: correct = "<<problem->c[assSP][0]<<"; wrong = "<<seg[idVeh].Trip[idTrip].connectCost<<endl;
//							cout<<"CASE last pickup trip"<<endl;
//							correct = 0;
//						}
//						if (seg[idVeh].Trip[idTrip].waitingS1 != NO_WS)
//						{
//							cout<<"ERROR checkTripP_checkSolution("<<idVeh<<", "<<idTrip<<"): waitingS1 = NO_WS; wrong = "<<seg[idVeh].Trip[idTrip].waitingS1<<endl;
//							cout<<"CASE last pickup trip"<<endl;
//							correct = 0;
//						}
//						cTemp += problem->c[assSP][0];
//					}
//					else //not lastTrip
//					{
//						int nextT = idTrip + 1;
//						if (seg[idVeh].Trip[nextT].Type == 1)
//						{
//							int assSP1 = seg[idVeh].Trip[nextT].assSP;
//							if (assSP1 == assSP)
//							{
//								/*if (PDSDIF(endS,seg[idVeh].Trip[idTrip].leaveSP))
//								{
//									cout<<"ERROR checkTripP_checkSolution("<<idVeh<<", "<<idTrip<<"): leaveSP correct = "<<endS<<"; wrong = "<<seg[idVeh].Trip[idTrip].leaveSP<<endl;
//									cout<<"CASE: p - d: sameSP"<<endl;
//									correct = 0;
//								}*/
//
//								if (seg[idVeh].Trip[idTrip].connectCost > eps)
//								{
//									cout<<"ERROR checkTripP_checkSolution("<<idVeh<<", "<<idTrip<<"): Connectcost : correct = 0; wrong = "<<seg[idVeh].Trip[idTrip].connectCost<<endl;
//									cout<<"CASE: p - d: sameSP"<<endl;
//									correct = 0;
//								}
//								if (seg[idVeh].Trip[idTrip].waitingS1 != NO_WS)
//								{
//									cout<<"ERROR checkTripP_checkSolution("<<idVeh<<", "<<idTrip<<"): waitingS1: correct = NO_WS; wrong = "<<seg[idVeh].Trip[idTrip].waitingS1<<endl;
//									cout<<"CASE: p - d: sameSP"<<endl;
//									correct = 0;
//								}
//								if (seg[idVeh].Trip[nextT].vioTWSP > eps)
//								{
//									cout<<"ERROR checkTripP_checkSolution("<<idVeh<<", "<<idTrip<<"): wrong vioTWSP of nextDelivery trip: correct = 0; wrong = "<<seg[idVeh].Trip[nextT].vioTWSP<<endl;
//									cout<<"CASE: p - d: sameSP"<<endl;
//									correct = 0;
//								}
//							}
//							else
//							{
//								cArrTime = endS + problem->c[assSP][assSP1];
//								if (PDSINRANGE(cArrTime, problem->nodeSP[assSP1].sTW2, problem->nodeSP[assSP1].eTW2))
//								{
//									cTemp += problem->c[assSP][assSP1];
//									if (seg[idVeh].Trip[idTrip].waitingS1 != NO_WS)
//									{
//										cout<<"ERROR checkTripP_checkSolution("<<idVeh<<", "<<idTrip<<"): correct waitingS1 = NO_WS; wrong = "<<seg[idVeh].Trip[idTrip].waitingS1<<endl;
//										cout<<"CASE: p - d: difSP"<<endl;
//										correct = 0;
//									}
//									if (PDSDIF(seg[idVeh].Trip[idTrip].connectCost,problem->c[assSP][assSP1]))
//									{
//										cout<<"ERROR checkTripP_checkSolution("<<idVeh<<", "<<idTrip<<"): correct = "<<problem->c[assSP][assSP1]<<"; wrong = "<<seg[idVeh].Trip[idTrip].connectCost<<endl;
//										cout<<"CASE: p - d: difSP"<<endl;
//										correct = 0;
//									}
//									if (seg[idVeh].Trip[nextT].vioTWSP > eps)
//									{
//										cout<<"ERROR checkTripP_checkSolution("<<idVeh<<", "<<idTrip<<"): wrong vioTWSP of nextDelivery trip: correct = 0; wrong = "<<seg[idVeh].Trip[nextT].vioTWSP<<endl;
//										cout<<"CASE: p - d: difSP"<<endl;
//										correct = 0;
//									}
//								}
//								else
//								{
//									temp = cArrTime - problem->nodeSP[assSP1].eTW2;
//									if (temp > eps)
//									{
//										  cTemp += problem->c[assSP][assSP1];
//										  if (seg[idVeh].Trip[idTrip].waitingS1 != NO_WS)
//												cout<<"ERROR checkTripP_checkSolution("<<idVeh<<", "<<idTrip<<"): correct waitingS1 = NO_WS; wrong = "<<seg[idVeh].Trip[idTrip].waitingS1<<endl;
//										  if (PDSDIF(seg[idVeh].Trip[idTrip].connectCost,problem->c[assSP][assSP1]))
//												cout<<"ERROR checkTripP_checkSolution("<<idVeh<<", "<<idTrip<<"): correct = "<<problem->c[assSP][assSP1]<<"; wrong = "<<seg[idVeh].Trip[idTrip].connectCost<<endl;
//										  if (PDSDIF(temp, seg[idVeh].Trip[nextT].vioTWSP))
//											cout<<"ERROR checkTripP_checkSolution("<<idVeh<<", "<<idTrip<<"): wrong vioTWSP of nextDelivery trip: correct = "<<temp<<"; wrong = "<<seg[idVeh].Trip[nextT].vioTWSP<<endl;
//
//										  cout<<"ERROR checkTripP_checkSolution("<<idVeh<<", "<<idTrip<<"): FEASIBLE (p-d trips) but vioTWSP of nextDelivery trip = "<<seg[idVeh].Trip[nextT].vioTWSP<<endl;
//										  cout<<"CASE: p - d: difSP; exceed eTW2 of sp"<<endl;
//										  correct = 0;
//									}
//									else
//									{
//										cArrTimeI = endS + problem->disCWSSP[assSP][assSP1];
//										temp = cArrTimeI - problem->nodeSP[assSP1].eTW2;
//										if (temp > eps)
//										{
//											  cTemp += problem->c[assSP][assSP1];
//											  temp = problem->nodeSP[assSP1].sTW2 - cArrTimeI;
//											  if (seg[idVeh].Trip[idTrip].waitingS1 != NO_WS)
//											  		cout<<"ERROR checkTripP_checkSolution("<<idVeh<<", "<<idTrip<<"): correct waitingS1 = NO_WS; wrong = "<<seg[idVeh].Trip[idTrip].waitingS1<<endl;
//											  if (PDSDIF(seg[idVeh].Trip[idTrip].connectCost,problem->c[assSP][assSP1]))
//													cout<<"ERROR checkTripP_checkSolution("<<idVeh<<", "<<idTrip<<"): correct = "<<problem->c[assSP][assSP1]<<"; wrong = "<<seg[idVeh].Trip[idTrip].connectCost<<endl;
//											  if (PDSDIF(temp, seg[idVeh].Trip[nextT].vioTWSP))
//												cout<<"ERROR checkTripP_checkSolution("<<idVeh<<", "<<idTrip<<"): wrong vioTWSP of nextDelivery trip: correct = "<<temp<<"; wrong = "<<seg[idVeh].Trip[nextT].vioTWSP<<endl;
//											  
//											  cout<<"ERROR checkTripP_checkSolution("<<idVeh<<", "<<idTrip<<"): FEASIBLE (p-d trips) but vioTWSP of nextDelivery trip = "<<seg[idVeh].Trip[nextT].vioTWSP<<endl;
//											  cout<<"CASE: p - d: difSP; too soon to sp directly; too late through WS"<<endl;
//											  correct = 0;
//										}
//										else
//										{
//											cTemp += problem->disCWSSP[assSP][assSP1];
//											if (seg[idVeh].Trip[idTrip].waitingS1 != problem->CWSSP[assSP][assSP1])
//											{
//												cout<<"ERROR checkTripP_checkSolution("<<idVeh<<", "<<idTrip<<"): correct waitingS1 = "<<problem->CWSSP[assSP][assSP1]<<"; wrong = "<<seg[idVeh].Trip[idTrip].waitingS1<<endl;
//												cout<<"CASE: p - d: difSP; through WS"<<endl;
//												correct = 0;
//											}
//											if (PDSDIF(seg[idVeh].Trip[idTrip].connectCost,problem->disCWSSP[assSP][assSP1]))
//											{
//												cout<<"ERROR checkTripP_checkSolution("<<idVeh<<", "<<idTrip<<"): correct = "<<problem->disCWSSP[assSP][assSP1]<<"; wrong = "<<seg[idVeh].Trip[idTrip].connectCost<<endl;
//												cout<<"CASE: p - d: difSP; through WS"<<endl;
//												correct = 0;
//											}
//											if (seg[idVeh].Trip[nextT].vioTWSP > eps)
//										    {
//											    cout<<"ERROR checkTripP_checkSolution("<<idVeh<<", "<<idTrip<<"): wrong vioTWSP of nextDelivery trip: correct = 0; wrong = "<<seg[idVeh].Trip[nextT].vioTWSP<<endl;
//											    cout<<"CASE: p - d: difSP; through WS"<<endl;
//											    correct = 0;
//										    }
//										}
//									}
//								}
//							}
//						}
//						else if (seg[idVeh].Trip[nextT].Type == 2) //nextTrip is C2C
//						{
//							if (PDSDIF(endS,seg[idVeh].Trip[idTrip].leaveSP))
//							{
//								cout<<"ERROR checkTripP_checkSolution("<<idVeh<<", "<<idTrip<<"): leaveSP correct = "<<endS<<"; wrong = "<<seg[idVeh].Trip[idTrip].leaveSP<<endl;
//								cout<<"CASE: p - C2C"<<endl;
//								correct = 0;
//							}
//							if (PDSDIF(problem->c[assSP][seg[idVeh].Trip[nextT].firstCus],seg[idVeh].Trip[idTrip].connectCost))
//							{
//								cout<<"ERROR checkTripP_checkSolution("<<idVeh<<", "<<idTrip<<"):ConnectCost correct = "<<problem->c[assSP][seg[idVeh].Trip[nextT].firstCus]<<"; wrong = "<<seg[idVeh].Trip[idTrip].connectCost<<endl;
//								cout<<"CASE: p - C2C"<<endl;
//								correct = 0;
//							}
//							cTemp += problem->c[assSP][seg[idVeh].Trip[nextT].firstCus];
//						}
//						else //nextTrip is pickup trip
//						{
//							if (PDSDIF(endS,seg[idVeh].Trip[idTrip].leaveSP))
//							{
//								cout<<"ERROR checkTripP_checkSolution("<<idVeh<<", "<<idTrip<<"): leaveSP correct = "<<endS<<"; wrong = "<<seg[idVeh].Trip[idTrip].leaveSP<<endl;
//								cout<<"CASE: p - p"<<endl;
//								correct = 0;
//							}
//							if (PDSDIF(problem->c[assSP][seg[idVeh].Trip[nextT].firstCus],seg[idVeh].Trip[idTrip].connectCost))
//							{
//								cout<<"ERROR checkTripP_checkSolution("<<idVeh<<", "<<idTrip<<"):ConnectCost correct = "<<problem->c[assSP][seg[idVeh].Trip[nextT].firstCus]<<"; wrong = "<<seg[idVeh].Trip[idTrip].connectCost<<endl;
//								cout<<"CASE: p - p"<<endl;
//								correct = 0;
//							}
//							cTemp += problem->c[assSP][seg[idVeh].Trip[nextT].firstCus];
//						}
//						if (PDSDIF(cTemp, seg[idVeh].Trip[idTrip].cost))
//						{
//							cout<<"ERROR checkTripP_checkSolution("<<idVeh<<", "<<idTrip<<"):cost correct = "<<cTemp<<"; wrong = "<<seg[idVeh].Trip[idTrip].cost<<endl;
//							correct = 0;
//						}
//					}//end not lastTrip
//				}//end not wrong on cost between customers and sp (exclude connectCost)
//			}//end if (correct)
//		}
//		else 
//		{
//			cout<<"ERROR checkTripP_checkSolution("<<idVeh<<", "<<idTrip<<"): endS : correct = "<<endS<<"; wrong = "<<seg[idVeh].Trip[idTrip].endS<<endl;
//			correct = 0;
//		}
//		//Checking BCAP, BvioTWCus:
//		curC = seg[idVeh].Trip[idTrip].lastCus; int BCAPT = 0; double BvioTWCusT = 0;
//		do
//		{
//			BCAPT += problem->node[curC].capacity;
//			BvioTWCusT += vioTWCus[curC];
//			if  (BCAP[curC] != BCAPT)
//			{
//				correct = 0;
//				cout<<"ERROR checkTripP_checkSolution("<<idVeh<<", "<<idTrip<<"): BCAP["<<curC<<"]: wrong = "<<BCAP[curC]<<"; correct = "<<BCAPT<<endl;
//			}
//			if  (PDSDIF(BvioTWCusT, BvioTWCus[curC]))
//			{
//				correct = 0;
//				cout<<"ERROR checkTripP_checkSolution("<<idVeh<<", "<<idTrip<<"): BvioTWCus["<<curC<<"]: wrong = "<<BvioTWCus[curC]<<"; correct = "<<BvioTWCusT<<endl;
//			}
//			curC = predArr[curC];
//		}while (curC > 0);
//		return correct;
//}
//
//
//bool Solution::checkTripC2C_checkSolution(int idVeh, int idTrip) //just checking field of trip; for FEASIBLE TRIP only
//{
//	//see on 4/12/2013
//	bool correct = 1;
//	double cTemp = 0; 
//
//	int preC = seg[idVeh].Trip[idTrip].firstCus;
//	int curC, i;
//	double endS, cArrTime,temp;
//	curC = seg[idVeh].Trip[idTrip].firstCus;
//	int CAPVehCus = 0; double vioTWCT;
//
//	int buon = seg[idVeh].Trip[idTrip].firstCus;
//	int nbuon = 0;
//	bool chan = 0;
//	while (buon > 0)
//	{
//		nbuon++;
//		if (buon > endidC2C) 
//		{
//			cout<<"ERROR checkTripC2C_checkSolution("<<idVeh<<", "<<idTrip<<") cus exceed ID = "<<buon<<" > "<<endidC2C<<endl;
//			chan = 1;
//		}
//		if (buon < startidC2C) 
//		{
//			cout<<"ERROR checkTripC2C_checkSolution("<<idVeh<<", "<<idTrip<<") cus smaller ID = "<<buon<<" < "<<startidC2C<<endl;
//		}
//		buon = nextArr[buon];
//	}
//	if (chan)
//	{
//	    showTripCus(idVeh, idTrip);
//		exit(-1);
//	}
//
//	if (nbuon != seg[idVeh].Trip[idTrip].numCus)
//	{
//		cout<<"ERROR checkTripC2C_checkSolution("<<idVeh<<", "<<idTrip<<") numCus: correct = "<<nbuon<<"; wrong = "<<seg[idVeh].Trip[idTrip].numCus<<endl;
//        showTripCus(idVeh, idTrip);
//		exit(-1);
//	}
//
//	if (idTrip == 0)
//	{
//			if (seg[idVeh].Trip[0].numCus == 2 && seg[idVeh].Trip[0].nextSP > 0)
//				endS = problem->startSOneP[curC][seg[idVeh].Trip[0].nextSP];
//			else 
//				endS = PDS_MAX(problem->c[0][curC], problem->node[curC].sTW);
//			
//			cTemp = problem->c[0][curC];
//			CAPVehCus = problem->node[curC].capacity; 
//			checkUsed[curC] = 1;
//			if (pos[curC] != 1)
//			{
//				correct = 0;
//				cout<<"ERROR checkTripC2C_checkSolution("<<idVeh<<", "<<idTrip<<") pos["<<curC<<"]: correct = 1; wrong = "<<pos[curC]<<endl;
//			}
//			if (route_num[curC] != idVeh)
//			{
//				correct = 0;
//				cout<<"ERROR checkTripC2C_checkSolution("<<idVeh<<", "<<idTrip<<") route_num["<<curC<<"]: correct = "<<idVeh<<"; wrong = "<<route_num[curC]<<endl;
//			}
//			if (trip_num[curC] != idTrip)
//			{
//				correct = 0;
//				cout<<"ERROR checkTripC2C_checkSolution("<<idVeh<<", "<<idTrip<<") trip_num["<<curC<<"]: correct = "<<idTrip<<"; wrong = "<<trip_num[curC]<<endl;
//			}
//
//			if (CAPCus[curC] != CAPVehCus)
//			{
//				correct = 0;
//				cout<<"ERROR checkTripC2C_checkSolution("<<idVeh<<", "<<idTrip<<") CAPCus["<<curC<<"]: correct = "<<CAPVehCus<<"; wrong = "<<CAPCus[curC]<<endl;
//			}
//			if (vioCAPCus[curC] != 0)
//			{
//				correct = 0;
//				cout<<"ERROR checkTripC2C_checkSolution("<<idVeh<<", "<<idTrip<<") vioCAPCus["<<curC<<"]: correct = 0; wrong = "<<vioCAPCus[curC]<<endl;
//			}
//
//			if (FCAP[curC] != 0)
//			{
//				correct = 0;
//				cout<<"ERROR checkTripC2C_checkSolution("<<idVeh<<", "<<idTrip<<") FvioCAPCus["<<curC<<"]: correct = 0; wrong = "<<FCAP[curC]<<endl;
//			}
//			/*if (FvioCAPCus[curC] != 0)
//			{
//				correct = 0;
//				cout<<"ERROR checkTripC2C_checkSolution("<<idVeh<<", "<<idTrip<<") FvioCAPCus["<<curC<<"]: correct = 0; wrong = "<<FvioCAPCus[curC]<<endl;
//			}*/
//
//			if (PDSDIF(endS, startS[curC]))
//			{
//				correct = 0;
//				cout<<"ERROR checkTripC2C_checkSolution("<<idVeh<<", "<<idTrip<<"): startS["<<curC<<"]: wrong = "<<startS[curC]<<"; correct = "<<endS<<endl;
//			}
//			
//			endS += problem->node[curC].duration;
//			if (PDSDIF(endS, depart[curC]))
//			{
//				correct = 0;
//				cout<<"ERROR checkTripC2C_checkSolution("<<idVeh<<", "<<idTrip<<"): depart["<<curC<<"]: wrong = "<<depart[curC]<<"; correct = "<<endS<<endl;
//			}
//
//			preC = curC; curC = nextArr[curC]; int vioCAPCT;
//			for (i=2;i<=seg[idVeh].Trip[idTrip].numCus;i++)
//			{
//					cTemp += problem->c[preC][curC];
//					endS += problem->c[preC][curC];
//					//if (curC > endidP) cout<<"ERROR pickup customer curC = "<<curC<<endl;
//
//					checkUsed[curC] = 1;
//					vioTWCT = PDS_MAX(endS - problem->node[curC].eTW, 0); 
//					CAPVehCus += problem->node[curC].capacity;
//					vioCAPCT = PDS_MAX(CAPVehCus - Q, 0); 
//
//					if (pos[curC] != i)
//					{
//						correct = 0;
//						cout<<"ERROR checkTripC2C_checkSolution("<<idVeh<<", "<<idTrip<<") pos["<<curC<<"]: correct = "<<i<<"; wrong = "<<pos[curC]<<endl;
//					}
//					if (route_num[curC] != idVeh)
//					{
//						correct = 0;
//						cout<<"ERROR checkTripC2C_checkSolution("<<idVeh<<", "<<idTrip<<") route_num["<<curC<<"]: correct = "<<idVeh<<"; wrong = "<<route_num[curC]<<endl;
//					}
//					if (trip_num[curC] != idTrip)
//					{
//						correct = 0;
//						cout<<"ERROR checkTripC2C_checkSolution("<<idVeh<<", "<<idTrip<<") trip_num["<<curC<<"]: correct = "<<idTrip<<"; wrong = "<<trip_num[curC]<<endl;
//					}
//
//					if (PDSDIF(vioTWCT, vioTWCus[curC])) 
//					{
//						correct = 0;
//						cout<<"ERROR checkTripC2C_checkSolution("<<idVeh<<", "<<idTrip<<"): vioTWCus["<<curC<<"]: wrong = "<<vioTWCus[curC]<<"; correct = "<<vioTWCT<<endl;
//					}
//					if (vioTWCT > eps)
//					{
//						endS = problem->node[curC].eTW;
//						cout<<"ERROR checkTripC2C_checkSolution("<<idVeh<<", "<<idTrip<<"): feasible C2C trip but vioTWCus["<<curC<<"] = "<<vioTWCT<<endl;
//						correct = 0;
//					}
//					else endS = PDS_MAX(endS, problem->node[curC].sTW);
//
//					if (vioCAPCT != vioCAPCus[curC])
//					{
//						correct = 0;
//						cout<<"ERROR checkTripC2C_checkSolution("<<idVeh<<", "<<idTrip<<"): vioCAPCus["<<curC<<"]: wrong = "<<vioCAPCus[curC]<<"; correct = "<<vioCAPCT<<endl;
//					}
//					if (vioCAPCT > 0)
//					{
//						CAPVehCus = Q;
//						cout<<"ERROR checkTripC2C_checkSolution("<<idVeh<<", "<<idTrip<<"): feasible C2C trip but vioCAPCus["<<curC<<"] = "<<vioCAPCT<<endl;
//						correct = 0;
//					}
//
//					if (PDSDIF(endS, startS[curC]))
//					{
//						correct = 0;
//						cout<<"ERROR checkTripC2C_checkSolution("<<idVeh<<", "<<idTrip<<"): startS["<<curC<<"]: wrong = "<<startS[curC]<<"; correct = "<<endS<<endl;
//					}
//					
//					endS += problem->node[curC].duration;
//					if (PDSDIF(endS, depart[curC]))
//					{
//						correct = 0;
//						cout<<"ERROR checkTripC2C_checkSolution("<<idVeh<<", "<<idTrip<<"): depart["<<curC<<"]: wrong = "<<depart[curC]<<"; correct = "<<endS<<endl;
//					}
//					preC = curC; curC = nextArr[curC];
//			}
//	}
//	else //idTrip > 0
//	{
//		int preT = idTrip - 1;
//		if (seg[idVeh].Trip[preT].Type == 0)
//		{
//			preC = seg[idVeh].Trip[preT].assSP;
//			endS = seg[idVeh].Trip[preT].leaveSP;
//		}
//		else
//		{
//			preC = seg[idVeh].Trip[preT].lastCus;
//			endS = depart[preC];
//		}
//		cTemp =-problem->c[preC][curC]; int vioCAPCT;
//		for (i=1;i<=seg[idVeh].Trip[idTrip].numCus;i++)
//		{
//				cTemp += problem->c[preC][curC];
//				endS += problem->c[preC][curC];
//
//				checkUsed[curC] = 1;
//				vioTWCT = PDS_MAX(endS - problem->node[curC].eTW, 0);
//				CAPVehCus += problem->node[curC].capacity;
//				vioCAPCT = PDS_MAX(CAPVehCus - Q,0);
//				if (pos[curC] != i)
//				{
//					correct = 0;
//					cout<<"ERROR checkTripC2C_checkSolution("<<idVeh<<", "<<idTrip<<") pos["<<curC<<"]: correct = "<<i<<"; wrong = "<<pos[curC]<<endl;
//				}
//				if (route_num[curC] != idVeh)
//				{
//					correct = 0;
//					cout<<"ERROR checkTripC2C_checkSolution("<<idVeh<<", "<<idTrip<<") route_num["<<curC<<"]: correct = "<<idVeh<<"; wrong = "<<route_num[curC]<<endl;
//				}
//				if (trip_num[curC] != idTrip)
//				{
//					correct = 0;
//					cout<<"ERROR checkTripC2C_checkSolution("<<idVeh<<", "<<idTrip<<") trip_num["<<curC<<"]: correct = "<<idTrip<<"; wrong = "<<trip_num[curC]<<endl;
//				}
//
//				if (CAPCus[curC] != CAPVehCus)
//				{
//					correct = 0;
//					cout<<"ERROR checkTripC2C_checkSolution("<<idVeh<<", "<<idTrip<<") CAPCus["<<curC<<"]: correct = "<<CAPVehCus<<"; wrong = "<<CAPCus[curC]<<endl;
//				}
//
//				if (PDSDIF(vioTWCT, vioTWCus[curC])) 
//				{
//					correct = 0;
//					cout<<"ERROR checkTripC2C_checkSolution("<<idVeh<<", "<<idTrip<<"): vioTWCus["<<curC<<"]: wrong = "<<vioTWCus[curC]<<"; correct = "<<vioTWCT<<endl;
//				}
//				if (vioTWCT > eps)
//				{
//					endS = problem->node[curC].eTW;
//					cout<<"ERROR checkTripC2C_checkSolution("<<idVeh<<", "<<idTrip<<"): feasible pickup trip but vioTWCus["<<curC<<"] = "<<vioTWCT<<endl;
//					correct = 0;
//				}
//				else endS = PDS_MAX(endS, problem->node[curC].sTW);
//
//				if (vioCAPCT != vioCAPCus[curC])
//				{
//					correct = 0;
//					cout<<"ERROR checkTripC2C_checkSolution("<<idVeh<<", "<<idTrip<<"): vioCAPCus["<<curC<<"]: wrong = "<<vioCAPCus[curC]<<"; correct = "<<vioCAPCT<<endl;
//				}
//				if (vioCAPCT > 0)
//				{
//					CAPVehCus = Q;
//					cout<<"ERROR checkTripC2C_checkSolution("<<idVeh<<", "<<idTrip<<"): feasible C2C trip but vioCAPCus["<<curC<<"] = "<<vioCAPCT<<endl;
//					correct = 0;
//				}
//
//				if (PDSDIF(endS, startS[curC]))
//				{
//					correct = 0;
//					cout<<"ERROR checkTripC2C_checkSolution("<<idVeh<<", "<<idTrip<<"): startS["<<curC<<"]: wrong = "<<startS[curC]<<"; correct = "<<endS<<endl;
//				}
//				
//				endS += problem->node[curC].duration;
//				if (PDSDIF(endS, depart[curC]))
//				{
//					correct = 0;
//					cout<<"ERROR checkTripC2C_checkSolution("<<idVeh<<", "<<idTrip<<"): depart["<<curC<<"]: wrong = "<<depart[curC]<<"; correct = "<<endS<<endl;
//				}
//				preC = curC; curC = nextArr[curC];
//		}
//	}
//
//	//preC now points to lastCus
//	if (seg[idVeh].Trip[idTrip].lastCus != preC)
//	{
//		correct = 0;
//		cout<<"ERROR checkTripC2C_checkSolution("<<idVeh<<", "<<idTrip<<"): lastCus: correct = "<<preC<<"; field lastCus wrong = "<<seg[idVeh].Trip[idTrip].lastCus<<endl;
//	}
//
//
//	if (PDSDIF(seg[idVeh].Trip[idTrip].endS, endS)==0)
//	{
//		int nextT = idTrip + 1;
//		int nextSP = seg[idVeh].Trip[idTrip].nextSP;
//		if (nextT < seg[idVeh].numTrips)
//		{
//			if (seg[idVeh].Trip[nextT].Type == 1)
//			{
//				int assSP = seg[idVeh].Trip[nextT].assSP;
//				if (nextSP != assSP)
//				{
//					cout<<"ERROR checkTripC2C_checkSolution("<<idVeh<<", "<<idTrip<<"): correct nextSP = "<<assSP<<"; wrong field nextSP = "<<nextSP<<endl;
//					correct = 0;
//				}
//				cArrTime = endS + problem->c[preC][assSP];
//				double connectTemp;
//				if (PDSINRANGE(cArrTime, problem->nodeSP[assSP].sTW2, problem->nodeSP[assSP].eTW2))
//				{
//					connectTemp = problem->c[preC][assSP];
//					//cTemp += problem->c[preC][assSP];
//					if (seg[idVeh].Trip[idTrip].waitingS != NO_WS)
//					{
//						cout<<"ERROR checkTripC2C_checkSolution("<<idVeh<<", "<<idTrip<<"): correct waitingS = NO_WS; wrong = "<<seg[idVeh].Trip[idTrip].waitingS<<endl;
//						correct = 0;
//					}
//					endS = cArrTime;// + problem->nodeSP[assSP].load;
//					if (PDSDIF(endS, seg[idVeh].Trip[idTrip].arriveSP))
//					{
//						cout<<"ERROR checkTripC2C_checkSolution("<<idVeh<<", "<<idTrip<<"): correct arriveSP = "<<endS<<"; but field arriveSP = "<<seg[idVeh].Trip[idTrip].arriveSP<<endl;
//						cout<<"CASE C2C - SP - D: directly to sp"<<endl;
//						correct = 0;
//					}
//				}
//				else
//				{
//					temp = cArrTime - problem->nodeSP[assSP].eTW2;
//					if (temp > eps)
//					{
//						if (seg[idVeh].Trip[idTrip].waitingS != NO_WS)
//							cout<<"ERROR checkTripC2C_checkSolution("<<idVeh<<", "<<idTrip<<"): correct waitingS = NO_WS; wrong = "<<seg[idVeh].Trip[idTrip].waitingS<<endl;
//						
//						cout<<"ERROR checkTripC2C_checkSolution("<<idVeh<<", "<<idTrip<<"): feasible pickup trip but vioTWSP = "<<temp<<endl;
//						cout<<"CASE exceed eTW2 of sp "<<assSP<<"; eTW2 = "<<problem->nodeSP[assSP].eTW2<<"; cArrTime = "<<cArrTime<<endl;
//						correct = 0;
//						endS = problem->nodeSP[assSP].eTW2; //problem->leaveSP[assSP][1]; //load at eTW2
//						connectTemp = problem->c[preC][assSP];
//						//cTemp += problem->c[preC][assSP];
//						if (PDSDIF(endS, seg[idVeh].Trip[idTrip].arriveSP))
//						{
//							cout<<"ERROR checkTripC2C_checkSolution("<<idVeh<<", "<<idTrip<<"): correct arriveSP = "<<endS<<"; but field arriveSP = "<<seg[idVeh].Trip[idTrip].arriveSP<<endl;
//							cout<<"CASE C2C - SP - D: too late to sp directly"<<endl;
//							correct = 0;
//						}
//
//					}
//					else
//					{
//						double cArrTimeI = endS + problem->disCWSSP[preC][assSP];
//						temp = cArrTimeI - problem->nodeSP[assSP].eTW2;
//						if (temp > eps)
//						{
//							temp = cArrTime - problem->nodeSP[assSP].sTW2;
//							if (PDSDIF(temp, seg[idVeh].Trip[nextT].vioTWSP))
//								cout<<"ERROR checkTripC2C_checkSolution("<<idVeh<<", "<<nextT<<"): correct vioTWSP = "<<temp<<"; wrong = "<<seg[idVeh].Trip[nextT].vioTWSP<<endl;
//							if (seg[idVeh].Trip[idTrip].waitingS != NO_WS)
//								cout<<"ERROR checkTripC2C_checkSolution("<<idVeh<<", "<<idTrip<<"): correct waitingS = NO_WS; wrong = "<<seg[idVeh].Trip[idTrip].waitingS<<endl;
//
//							cout<<"ERROR checkTripC2C_checkSolution("<<idVeh<<", "<<idTrip<<"): feasible pickup trip but vioTWSP = "<<temp<<endl;
//							cout<<"CASE too soon to go sp directly; too late through WS: cArrTimeD = "<<cArrTime<<"; cArrTimeIndirectly = "<<cArrTimeI<<"; eTW2 = "<<problem->nodeSP[assSP].eTW2<<endl;
//							correct = 0;
//							endS = problem->nodeSP[assSP].eTW2; //problem->leaveSP[assSP][1]; //load at eTW2
//							//cTemp += problem->c[preC][assSP];
//							connectTemp = problem->c[preC][assSP];
//							if (PDSDIF(endS, seg[idVeh].Trip[idTrip].arriveSP))
//							{
//								cout<<"ERROR checkTripC2C_checkSolution("<<idVeh<<", "<<idTrip<<"): correct arriveSP = "<<endS<<"; but field arriveSP = "<<seg[idVeh].Trip[idTrip].arriveSP<<endl;
//								cout<<"CASE C2C - SP - D: too soon to sp directly; too late through wS"<<endl;
//								correct = 0;
//							}
//
//						}
//						else
//						{
//							connectTemp = problem->disCWSSP[preC][assSP];
//							//cTemp += problem->disCWSSP[preC][assSP];
//							if (seg[idVeh].Trip[idTrip].waitingS != problem->CWSSP[preC][assSP])
//							{
//								cout<<"ERROR checkTripC2C_checkSolution("<<idVeh<<", "<<idTrip<<"): correct waitingS = "<<problem->CWSSP[preC][assSP]<<"; wrong = "<<seg[idVeh].Trip[idTrip].waitingS<<endl;
//								cout<<"LastCus of trip = "<<preC<<" !=? "<<seg[idVeh].Trip[idTrip].lastCus<<endl;
//								cout<<"CASE to go through WS"<<endl;
//								correct = 0;
//							}
//							if (seg[idVeh].Trip[nextT].vioTWSP > eps)
//							{
//								cout<<"ERROR checkTripC2C_checkSolution("<<idVeh<<", "<<idTrip<<"): correct vioTWSP = 0; wrong = "<<seg[idVeh].Trip[nextT].vioTWSP<<endl;
//								cout<<"CASE to go through WS"<<endl;
//								correct = 0;
//							}
//							endS = PDS_MAX(cArrTimeI, problem->nodeSP[assSP].sTW2);// + problem->nodeSP[assSP].load;
//							if (PDSDIF(endS, seg[idVeh].Trip[idTrip].arriveSP))
//							{
//								cout<<"ERROR checkTripC2C_checkSolution("<<idVeh<<", "<<idTrip<<"): correct arriveSP = "<<endS<<"; but field arriveSP = "<<seg[idVeh].Trip[idTrip].arriveSP<<endl;
//								cout<<"CASE C2C - SP - D: through WS"<<endl;
//								correct = 0;
//							}
//
//						}
//					}
//				}
//				/*if (PDSDIF(seg[idVeh].Trip[idTrip].arriveSP, endS))
//				{
//					cout<<"ERROR checkTripC2C_checkSolution("<<idVeh<<", "<<idTrip<<"):arriveSP correct = "<<cTemp<<"; but field arriveSP = "<<seg[idVeh].Trip[idTrip].arriveSP<<endl;
//					cout<<"CASE: C2C - SP-d"<<endl;
//					correct = 0;
//				}*/
//				if (correct)
//				{
//					double costT = seg[idVeh].Trip[idTrip].cost - seg[idVeh].Trip[idTrip].connectCost;
//					if (PDSDIF(cTemp, costT))
//					{
//						cout<<"ERROR checkTripC2C_checkSolution("<<idVeh<<", "<<idTrip<<"): cost (between cusC2C, exclude connectCost): correct = "<<cTemp<<"; wrong = "<<costT<<endl;
//						cout<<"Case C2C-SP-d"<<endl;
//						correct = 0;
//					}
//					else
//					{
//						if (PDSDIF(seg[idVeh].Trip[idTrip].connectCost, connectTemp))
//						{
//							cout<<"ERROR checkTripC2C_checkSolution("<<idVeh<<", "<<idTrip<<"):ConnectCost correct = "<<connectTemp<<"; wrong = "<<seg[idVeh].Trip[idTrip].connectCost<<endl;
//							cout<<"CASE: C2C - SP-d"<<endl;
//							correct = 0;
//						}
//						cTemp += connectTemp;
//						if (PDSDIF(cTemp, seg[idVeh].Trip[idTrip].cost))
//						{
//							cout<<"ERROR checkTripC2C_checkSolution("<<idVeh<<", "<<idTrip<<"):cost correct = "<<cTemp<<"; wrong = "<<seg[idVeh].Trip[idTrip].cost<<endl;
//							cout<<"CASE: C2C - SP-d"<<endl;
//							correct = 0;
//						}
//
//					}//end not wrong on cost between customers and sp (exclude connectCost)
//				}//end if (correct)
//			}
//			else //nextT is pickup trip / OR C2C
//			{
//				if (nextSP >= 0)
//				{
//					cout<<"ERROR checkTripC2C_checkSolution("<<idVeh<<", "<<idTrip<<"): nextTrip is pickup trip; but field nextSP = "<<nextSP<<endl;
//					correct = 0;
//				}
//				double costT = seg[idVeh].Trip[idTrip].cost - seg[idVeh].Trip[idTrip].connectCost;
//				if (PDSDIF(cTemp, costT))
//				{
//					cout<<"ERROR checkTripC2C_checkSolution("<<idVeh<<", "<<idTrip<<"): cost (between cusC2C, exclude connectCost): correct = "<<cTemp<<"; wrong = "<<costT<<endl;
//					cout<<"CASE: C2C - p(or C2C)"<<endl;
//					correct = 0;
//				}
//				else
//				{
//					int firstC_nextT = seg[idVeh].Trip[nextT].firstCus;
//					if (PDSDIF(seg[idVeh].Trip[idTrip].connectCost, problem->c[preC][firstC_nextT]))
//					{
//						cout<<"ERROR checkTripC2C_checkSolution("<<idVeh<<", "<<idTrip<<"):ConnectCost correct = "<<problem->c[preC][firstC_nextT]<<"; wrong = "<<seg[idVeh].Trip[idTrip].connectCost<<endl;
//						cout<<"CASE: C2C - p(orC2C)"<<endl;
//						correct = 0;
//					}
//					cTemp += problem->c[preC][firstC_nextT];
//					if (PDSDIF(cTemp, seg[idVeh].Trip[idTrip].cost))
//					{
//						cout<<"ERROR checkTripC2C_checkSolution("<<idVeh<<", "<<idTrip<<"):cost correct = "<<cTemp<<"; wrong = "<<seg[idVeh].Trip[idTrip].cost<<endl;
//						cout<<"CASE: C2C - p(orC2C)"<<endl;
//						correct = 0;
//					}
//				}
//			}//end nextT is pickup trip: idTrip is C2C- nextT is pick
//		}
//		else // idTrip is last C2C
//		{
//				if (nextSP != 0)
//				{
//					cout<<"ERROR checkTripC2C_checkSolution("<<idVeh<<", "<<idTrip<<"): last C2C trip; but field nextSP = "<<nextSP<<"; (correct should = 0)"<<endl;
//					correct = 0;
//				}
//				double costT = seg[idVeh].Trip[idTrip].cost - seg[idVeh].Trip[idTrip].connectCost;
//				if (PDSDIF(cTemp, costT))
//				{
//					cout<<"ERROR checkTripC2C_checkSolution("<<idVeh<<", "<<idTrip<<"): cost (between cusC2C, exclude connectCost to depot): correct = "<<cTemp<<"; wrong = "<<costT<<endl;
//					cout<<"CASE: C2C - depot"<<endl;
//					correct = 0;
//				}
//				else
//				{
//					if (PDSDIF(seg[idVeh].Trip[idTrip].connectCost, problem->c[preC][0]))
//					{
//						cout<<"ERROR checkTripC2C_checkSolution("<<idVeh<<", "<<idTrip<<"):ConnectCost correct = "<<problem->c[preC][0]<<"; wrong = "<<seg[idVeh].Trip[idTrip].connectCost<<endl;
//						cout<<"CASE: C2C - depot"<<endl;
//						correct = 0;
//					}
//					cTemp += problem->c[preC][0];
//					if (PDSDIF(cTemp, seg[idVeh].Trip[idTrip].cost))
//					{
//						cout<<"ERROR checkTripC2C_checkSolution("<<idVeh<<", "<<idTrip<<"):cost correct = "<<cTemp<<"; wrong = "<<seg[idVeh].Trip[idTrip].cost<<endl;
//						cout<<"CASE: C2C - depot"<<endl;
//						correct = 0;
//					}
//				}
//		}//end // idTrip is last C2C
//
//	}
//	else 
//	{
//		cout<<"ERROR checkTripC2C_checkSolution("<<idVeh<<", "<<idTrip<<"): endS : correct = "<<endS<<"; wrong = "<<seg[idVeh].Trip[idTrip].endS<<endl;
//		correct = 0;
//	}
//
//	//Checking BvioTWCus, BvioCAPCus:
//	curC = seg[idVeh].Trip[idTrip].lastCus; double BvioTWCusT = 0; int BvioCAPCusT = 0;
//	do
//	{
//		BvioTWCusT += vioTWCus[curC]; BvioCAPCusT += vioCAPCus[curC];
//		if  (BCAP[curC] != BvioCAPCusT)
//		{
//			correct = 0;
//			cout<<"ERROR checkTripC2C_checkSolution("<<idVeh<<", "<<idTrip<<"): BvioCAPCus["<<curC<<"]: wrong = "<<BCAP[curC]<<"; correct = "<<BvioCAPCusT<<endl;
//		}
//
//		/*if  (BvioCAPCus[curC] != BvioCAPCusT)
//		{
//			correct = 0;
//			cout<<"ERROR checkTripC2C_checkSolution("<<idVeh<<", "<<idTrip<<"): BvioCAPCus["<<curC<<"]: wrong = "<<BvioCAPCus[curC]<<"; correct = "<<BvioCAPCusT<<endl;
//		}*/
//
//		if  (PDSDIF(BvioTWCusT, BvioTWCus[curC]))
//		{
//			correct = 0;
//			cout<<"ERROR checkTripC2C_checkSolution("<<idVeh<<", "<<idTrip<<"): BvioTWCus["<<curC<<"]: wrong = "<<BvioTWCus[curC]<<"; correct = "<<BvioTWCusT<<endl;
//		}
//		curC = predArr[curC];
//	}while (curC > 0);
//
//	/*Checking BCAP, BvioTWCus, BvioCAPCus:
//	curC = seg[idVeh].Trip[idTrip].lastCus; int BCAPT = 0; double BvioTWCusT = 0; int BvioCAPCusT = 0;
//	do
//	{
//		BCAPT += problem->node[curC].capacity;
//		BvioTWCusT += vioTWCus[curC]; BvioCAPCusT += vioCAPCus[curC];
//		if  (BCAP[curC] != BCAPT)
//		{
//			correct = 0;
//			cout<<"ERROR checkTripC2C_checkSolution("<<idVeh<<", "<<idTrip<<"): BCAP["<<curC<<"]: wrong = "<<BCAP[curC]<<"; correct = "<<BCAPT<<endl;
//		}
//		if  (BvioCAPCus[curC] != BvioCAPCusT)
//		{
//			correct = 0;
//			cout<<"ERROR checkTripC2C_checkSolution("<<idVeh<<", "<<idTrip<<"): BvioCAPCus["<<curC<<"]: wrong = "<<BvioCAPCus[curC]<<"; correct = "<<BvioCAPCusT<<endl;
//		}
//
//		if  (PDSDIF(BvioTWCusT, BvioTWCus[curC]))
//		{
//			correct = 0;
//			cout<<"ERROR checkTripC2C_checkSolution("<<idVeh<<", "<<idTrip<<"): BvioTWCus["<<curC<<"]: wrong = "<<BvioTWCus[curC]<<"; correct = "<<BvioTWCusT<<endl;
//		}
//		curC = predArr[curC];
//	}while (curC > 0);*/
//
//	if (IsLIFO(idVeh,idTrip) == 0) 
//	{
//		correct = 0;
//		cout<<"Trip error: "; showTripCus(idVeh,idTrip);
//	}
//	return correct;
//}
//
//
//
//bool Solution::checkTripD_ALLFIELDS(int idVeh, int idTrip) //just checking field of trip; for both FEASIBLE and INFEASIBLE TRIP
//{
//	//see on 27/11/2013
//	bool stop = 0;
//	double cTemp = 0; 
//	int assSP = seg[idVeh].Trip[idTrip].assSP;
//	double leaveSPT, vioTWSPT, cArrTime,temp;
//	int i;
//
//	int buon = seg[idVeh].Trip[idTrip].firstCus;
//	int nbuon = 0;
//	while (buon > 0)
//	{
//		nbuon++;
//		buon = nextArr[buon];
//	}
//	if (nbuon != seg[idVeh].Trip[idTrip].numCus)
//	{
//		stop = 1;
//		cout<<"ERROR checkTripD_ALLFIELDS("<<idVeh<<", "<<idTrip<<") numCus: correct = "<<nbuon<<"; wrong = "<<seg[idVeh].Trip[idTrip].numCus<<endl;
//	    showTripCus(idVeh, idTrip);
//		exit(-1);
//	}
//
//	bool feaT;
//	if (seg[idVeh].Trip[idTrip].vioCAP > 0 || seg[idVeh].Trip[idTrip].vioTWC > eps || seg[idVeh].Trip[idTrip].vioTWSP > eps)
//		feaT = 0;
//	else feaT = 1;
//	if (seg[idVeh].Trip[idTrip].feasible != feaT)
//	{
//		stop = 1;
//		cout<<"ERROR checkTripD_ALLFIELDS("<<idVeh<<", "<<idTrip<<") feasible: correct = "<<feaT<<"; wrong fieldfeasible = "<<seg[idVeh].Trip[idTrip].feasible<<endl;
//	}
//
//	if (idTrip == 0)
//	{
//		if (PDSDIF(seg[idVeh].Trip[0].leaveSP, problem->leaveSP[seg[idVeh].Trip[0].assSP][4]))
//		{
//				cout<<"ERROR checkTripD_ALLFIELDS("<<idVeh<<", "<<idTrip<<") LeaveSP: correct = "<<problem->leaveSP[seg[idVeh].Trip[0].assSP][4]<<"; wrong = "<<seg[idVeh].Trip[0].leaveSP<<endl;
//				stop = 1;
//		}
//		if (seg[idVeh].Trip[idTrip].coordinate == 1)
//		{
//				 cout<<"ERROR checkTripD_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): correct = NOT coordinate, but coordinate field = "<<seg[idVeh].Trip[idTrip].coordinate<<endl;
//				 stop = 1;
//		}			 
//		cTemp += problem->c[0][assSP];
//	}
//	else
//	{
//		 int preT = idTrip - 1; 
//		 if (seg[idVeh].Trip[preT].Type == 0)
//		 {
//			 int assSPpreT = seg[idVeh].Trip[preT].assSP;
//			 if (assSPpreT == assSP) 
//			 {
//				 cArrTime = seg[idVeh].Trip[preT].leaveSP - problem->nodeSP[assSP].unload;
//				 if (seg[idVeh].Trip[idTrip].coordinate == 0)
//				 {
//					 cout<<"ERROR: checkTripD_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): correct = coordinate, but field coordinate = "<<seg[idVeh].Trip[idTrip].coordinate<<endl;
//					 stop = 1;
//				 }	
//				 if (PDSDIF(seg[idVeh].Trip[preT].vioTWSP, seg[idVeh].Trip[idTrip].vioTWSP))
//				 {
//					 cout<<"ERRROR checkTripD_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): vioTWSP at sp "<<assSP<<" of preT = "<<seg[idVeh].Trip[preT].vioTWSP<<" != vioTWSP at sp of idTrip "<<seg[idVeh].Trip[idTrip].vioTWSP<<endl;
//					 cout<<"CASE p-d same SP "<<assSP<<endl;
//					 stop = 1;
//				}
//			 }
//			 else //preT is pickup trip, dif SP
//			 {
//				 if (seg[idVeh].Trip[idTrip].coordinate==1)
//				 {
//					 cout<<"ERROR: checkTripD_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): correct = NOTcoordinate, but field coordinate = "<<seg[idVeh].Trip[idTrip].coordinate<<endl;
//					 stop = 1;
//				 }	
//				 cArrTime = seg[idVeh].Trip[preT].leaveSP + problem->c[assSPpreT][assSP];
//				 int goWS;
//				 if (PDSINRANGE(cArrTime, problem->nodeSP[assSP].sTW2, problem->nodeSP[assSP].eTW2))
//				 {
//					 vioTWSPT = 0;
//					 leaveSPT = PDS_MAX(cArrTime, problem->nodeSP[assSP].sTW2) + problem->nodeSP[assSP].load;
//					 goWS = NO_WS;
//				 }
//				 else
//				 {
//					 temp = cArrTime - problem->nodeSP[assSP].eTW2;
//					 if (temp > eps)
//					 {
//						 vioTWSPT = temp;  goWS = NO_WS;
//						 leaveSPT = problem->leaveSP[assSP][1]; //load only at eTW2
//					 }
//					 else
//					 {
//						 double cArrTimeI = seg[idVeh].Trip[preT].leaveSP + problem->disCWSSP[assSPpreT][assSP];
//						 temp = cArrTimeI - problem->nodeSP[assSP].eTW2;
//						 if (temp > eps)
//						 {
//							 vioTWSPT = problem->nodeSP[assSP].sTW2 - cArrTime;
//							 goWS = NO_WS;
//							 leaveSPT = problem->leaveSP[assSP][1]; //load only at eTW2
//						 }
//						 else
//						 {
//							 vioTWSPT = 0;
//							 leaveSPT = PDS_MAX(cArrTimeI, problem->nodeSP[assSP].sTW2) + problem->nodeSP[assSP].load;
//	 						 goWS = problem->CWSSP[assSPpreT][assSP];
//						 }
//					 }
//				 }
//				 if (seg[idVeh].Trip[preT].waitingS1 != goWS)
//				 {
//					 cout<<"ERROR: checkTripD_ALLFIELDS: pickup trip("<<idVeh<<", "<<preT<<"): WS1 correct = "<<goWS<<"; but field waitingS1 = "<<seg[idVeh].Trip[preT].waitingS1<<endl;
//					 stop = 1;
//				 }			 
//		 
//				 if (PDSDIF(leaveSPT, seg[idVeh].Trip[idTrip].leaveSP))
//				 {
//					cout<<"ERRROR checkTripD_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): leaveSP at sp "<<assSP<<": correct = "<<leaveSPT<<"; wrong = "<<seg[idVeh].Trip[idTrip].leaveSP<<endl;
//					cout<<"[sTW, eTW] of sp("<<assSP<<") = ["<<problem->nodeSP[assSP].sTW2<<", "<<problem->nodeSP[assSP].eTW2<<"]"<<endl;
//					cout<<"CASE trip "<<preT<<" is pickup trip, dif SP"<<endl;
//					stop = 1;
//				 }
//				 if (PDSDIF(vioTWSPT, seg[idVeh].Trip[idTrip].vioTWSP))
//				 {
//					 cout<<"ERRROR checkTripD_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): vioTWSP at sp "<<assSP<<": correct = "<<temp<<";Field vioTWSP = "<<seg[idVeh].Trip[idTrip].vioTWSP<<endl;
//					 cout<<"CASE trip "<<preT<<" is pickup trip, dif SP"<<endl;
//					 stop = 1;
//				}
//
//			 }//end preT is pickup trip, dif SP
//		 }
//		 else //if (seg[idVeh].Trip[preT].Type == 1 || 2)
//		 {
//			 int lastCpreT = seg[idVeh].Trip[preT].lastCus;
//			 int goWS;
//			 cArrTime = depart[lastCpreT] + problem->c[lastCpreT][assSP];
//			 if (PDSINRANGE(cArrTime, problem->nodeSP[assSP].sTW2, problem->nodeSP[assSP].eTW2))
//			 {
//				 vioTWSPT = 0;
//				 leaveSPT = PDS_MAX(cArrTime, problem->nodeSP[assSP].sTW2) + problem->nodeSP[assSP].load;
//				 goWS = NO_WS;
//			 }
//			 else
//			 {
//				 temp = cArrTime - problem->nodeSP[assSP].eTW2;
//				 if (temp > eps)
//				 {
//					 vioTWSPT = temp;  goWS = NO_WS;
//					 leaveSPT = problem->nodeSP[assSP].eTW2 + problem->nodeSP[assSP].load;
//				 }
//				 else
//				 {
//					 double cArrTimeI = depart[lastCpreT] + problem->disCWSSP[lastCpreT][assSP];
//					 temp = cArrTimeI - problem->nodeSP[assSP].eTW2;
//					 if (temp > eps)
//					 {
//						 vioTWSPT = problem->nodeSP[assSP].sTW2 - cArrTime;
//						 goWS = NO_WS;
//						 leaveSPT = problem->nodeSP[assSP].eTW2 + problem->nodeSP[assSP].load;
//					 }
//					 else
//					 {
//						 vioTWSPT = 0;
//						 leaveSPT = PDS_MAX(cArrTimeI, problem->nodeSP[assSP].sTW2) + problem->nodeSP[assSP].load;
//	 					 goWS = problem->CWSSP[lastCpreT][assSP];
//					 }
//				 }
//			 }
//			 if (seg[idVeh].Trip[preT].waitingS != goWS)
//			 {
//				 cout<<"ERROR: checkTripD_ALLFIELDS("<<idVeh<<", "<<preT<<"): WS correct = "<<goWS<<"; but field waitingS = "<<seg[idVeh].Trip[preT].waitingS<<endl;
//				 stop = 1;
//			 }			 
//			 if (seg[idVeh].Trip[idTrip].coordinate==1)
//			 {
//				 cout<<"ERROR: checkTripD_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): correct =  NOT coordinate, but field coordinate = "<<seg[idVeh].Trip[idTrip].coordinate<<endl;
//				 stop = 1;
//			 }			 
//			 if (PDSDIF(leaveSPT, seg[idVeh].Trip[idTrip].leaveSP))
//			 {
//				cout<<"ERRROR checkTripD_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): leaveSP at sp "<<assSP<<": correct = "<<leaveSPT<<"; wrong = "<<seg[idVeh].Trip[idTrip].leaveSP<<endl;
//				cout<<"[sTW, eTW] of sp("<<assSP<<") = ["<<problem->nodeSP[assSP].sTW2<<", "<<problem->nodeSP[assSP].eTW2<<"]"<<endl;
//				cout<<"CASE pretrip "<<preT<<" is delivery trip/C2Ctrip"<<endl;
//				stop = 1;
//			 }
//			 if (PDSDIF(vioTWSPT, seg[idVeh].Trip[idTrip].vioTWSP))
//			 {
//				 cout<<"ERRROR checkTripD_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): vioTWSP at sp "<<assSP<<": correct = "<<temp<<";Field vioTWSP = "<<seg[idVeh].Trip[idTrip].vioTWSP<<endl;
//				 cout<<"CASE pretrip "<<preT<<" is delivery/C2C trip"<<endl;
//				 stop = 1;
//			}
//		 }
//	}
//	if (stop == 0)
//	{
//		int preC  = assSP;
//		int curC = seg[idVeh].Trip[idTrip].firstCus;
//		double endS = seg[idVeh].Trip[idTrip].leaveSP;
//		int CAPT = 0; double vioTWCT, FvioTWCT = 0;
//
//		for (i=1;i <= seg[idVeh].Trip[idTrip].numCus;i++)
//		{
//			CAPT += problem->node[curC].capacity; 
//			cTemp += problem->c[preC][curC];
//			endS += problem->c[preC][curC];
//			//vioTWCT = PDS_MAX(endS - problem->node[curC].eTW, 0);
//			vioTWCT = endS - problem->node[curC].eTW;
//			if (vioTWCT > eps) 	FvioTWCT += vioTWCT;
//			else vioTWCT = 0;
//			if  (pos[curC] != i)
//			{
//				stop = 1;
//				cout<<"ERROR checkTripD_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): pos["<<curC<<"]: wrong = "<<pos[curC]<<"; correct = "<<i<<endl;
//			}
//			if  (curC < startidD)
//			{
//				stop = 1;
//				cout<<"ERROR checkTripD_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): cus smaller ID = "<<curC<<" < "<<startidD<<endl;
//			}
//			if  (curC > endidD)
//			{
//				stop = 1;
//				cout<<"ERROR checkTripD_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): cus exceed ID = "<<curC<<" > "<<endidD<<endl;
//			}
//			if (route_num[curC] != idVeh)
//			{
//				stop = 1;
//				cout<<"ERROR checkTripD_ALLFIELDS("<<idVeh<<", "<<idTrip<<") route_num["<<curC<<"]: correct = "<<idVeh<<"; wrong = "<<route_num[curC]<<endl;
//			}
//			if (trip_num[curC] != idTrip)
//			{
//				stop = 1;
//				cout<<"ERROR checkTripD_ALLFIELDS("<<idVeh<<", "<<idTrip<<") trip_num["<<curC<<"]: correct = "<<idTrip<<"; wrong = "<<trip_num[curC]<<endl;
//			}
//
//			if  (FCAP[curC] != CAPT)
//			{
//				stop = 1;
//				cout<<"ERROR checkTripD_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): FCAP["<<curC<<"]: wrong = "<<FCAP[curC]<<"; correct = "<<CAPT<<endl;
//			}
//			if (PDSDIF(vioTWCT, vioTWCus[curC])) 
//			{
//				stop = 1;
//				cout<<"ERROR checkTripD_ALLFIELDS("<<idVeh<<", "<<idTrip<<") vioTWCus["<<curC<<"]: correct = "<<vioTWCT<<"; field vioTWCus wrong = "<<vioTWCus[curC]<<endl;
//			}
//			if (PDSDIF(FvioTWCT, FvioTWCus[curC])) 
//			{
//				stop = 1;
//				cout<<"ERROR checkTripD_ALLFIELDS("<<idVeh<<", "<<idTrip<<") FvioTWCus["<<curC<<"]: correct = "<<FvioTWCT<<"; field FvioTWCus wrong = "<<FvioTWCus[curC]<<endl;
//			}
//			if (vioTWCT > eps)
//				endS = problem->node[curC].eTW;
//			else endS = PDS_MAX(endS, problem->node[curC].sTW);
//			if (PDSDIF(endS, startS[curC]))
//			{
//				stop = 1;
//				cout<<"ERROR checkTripD_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): startS["<<curC<<"]: correct = "<<endS<<"; field startS wrong = "<<startS[curC]<<endl;
//			}
//			
//			endS += problem->node[curC].duration;
//			if (PDSDIF(endS, depart[curC]))
//			{
//				stop = 1;
//				cout<<"ERROR checkTripD_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): depart["<<curC<<"]: correct = "<<endS<<"; field depart wrong = "<<depart[curC]<<endl;
//			}
//			preC = curC; curC = nextArr[curC];
//		}
//
//		if (CAPT != seg[idVeh].Trip[idTrip].capacity)
//		{
//			cout<<"ERROR checkTripD_ALLFIELDS("<<idVeh<<", "<<idTrip<<") CAP of trip: correct = "<<CAPT<<"; wrong = "<<seg[idVeh].Trip[idTrip].capacity<<endl;
//			stop = 1;
//		}
//		else
//		{
//			int vioCAPT = PDS_MAX(CAPT - problem->Q, 0);
//			if (vioCAPT != seg[idVeh].Trip[idTrip].vioCAP)
//			{
//				stop = 1;
//				cout<<"ERROR checkTripD_ALLFIELDS("<<idVeh<<", "<<idTrip<<") vioCAP: wrong = "<<seg[idVeh].Trip[idTrip].vioCAP<<"; correct = "<<vioCAPT<<endl;
//			}
//		}
//
//		double costBetweenCusOnly = seg[idVeh].Trip[idTrip].cost - seg[idVeh].Trip[idTrip].connectCost;
//		if (PDSDIF(costBetweenCusOnly, cTemp))
//		{
//			stop = 1;
//			cout<<"ERROR checkTripD_ALLFIELDS("<<idVeh<<", "<<idTrip<<") total cost between customers only: wrong = "<<costBetweenCusOnly<<"; correct = "<<cTemp<<endl;
//		    cout<<"Field ConnectCost = "<<seg[idVeh].Trip[idTrip].connectCost<<endl;
//		}
//
//		if (PDSDIF(seg[idVeh].Trip[idTrip].endS, endS)==0)
//		{
//				int nextTrip = idTrip + 1;
//				if (nextTrip < seg[idVeh].numTrips) // not last Trip
//				{
//					if (seg[idVeh].Trip[nextTrip].Type == 1) //next trip is delivery trip:
//					{
//						 int endSP = seg[idVeh].Trip[nextTrip].assSP;
//						 double cArrTime = endS + problem->c[preC][endSP];
//						 if (PDSINRANGE(cArrTime, problem->nodeSP[endSP].sTW2, problem->nodeSP[endSP].eTW2))
//						 {
//							 cTemp +=  problem->c[preC][endSP];
//
//							 if (PDSDIF(problem->c[preC][endSP],seg[idVeh].Trip[idTrip].connectCost))
//							 {
//								 cout<<"ERROR checkTripD_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): Connectcost : correct = "<<problem->c[preC][endSP]<<"; error = "<<seg[idVeh].Trip[idTrip].connectCost<<endl;
//								 cout<<"CASE: "<<assSP<<" - DELIVERY TRIP - sp = "<<(endSP)<<" - DELIVERY TRIP"<<endl;
//								 stop = 1;
//							 }
//							 if (seg[idVeh].Trip[idTrip].waitingS != NO_WS)
//							 {
//								 cout<<"ERROR checkTripD_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): Waiting station: correct = noWS"<<"; wrong = "<<seg[idVeh].Trip[idTrip].waitingS<<endl;
//								 cout<<"CASE: "<<assSP<<" - DELIVERY TRIP - sp = "<<(endSP)<<" - DELIVERY TRIP"<<endl;
//								 stop = 1;
//							 }
//							 if (seg[idVeh].Trip[nextTrip].vioTWSP > eps)
//							 {
//								 cout<<"ERROR checkTripD_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): vioTWSP : correct = 0; wrong = "<<seg[idVeh].Trip[nextTrip].vioTWSP<<endl;
//								 cout<<"CASE: "<<assSP<<" - DELIVERY TRIP - sp = "<<(endSP)<<" - DELIVERY TRIP"<<endl;
//								 stop = 1;
//							 }
//							 if (PDSDIF(cArrTime,seg[idVeh].Trip[idTrip].arriveSP))
//							 {
//								 cout<<"ERROR checkTripD_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): arriveSP : correct = "<<cArrTime<<"; but field arriveSP = "<<seg[idVeh].Trip[idTrip].arriveSP<<endl;
//								 cout<<"CASE: "<<assSP<<" - DELIVERY TRIP - sp = "<<(endSP)<<" - DELIVERY TRIP"<<endl;
//								 stop = 1;
//							 }
//
//						 }
//						 else
//						 {
//							  temp = cArrTime - problem->nodeSP[endSP].eTW2;
//							  if (temp > eps)
//							  {
//								  if (PDSDIF(problem->c[preC][endSP],seg[idVeh].Trip[idTrip].connectCost))
//								  {
//									 cout<<"ERROR checkTripD_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): Connectcost : correct = "<<problem->c[preC][endSP]<<"; error = "<<seg[idVeh].Trip[idTrip].connectCost<<endl;
//									 cout<<"CASE: "<<assSP<<" - DELIVERY TRIP - sp = "<<(endSP)<<" - DELIVERY TRIP; exceed eTW2"<<endl;
//									 stop = 1;
//								  }
//								  if (seg[idVeh].Trip[idTrip].waitingS != NO_WS)
//								  {
//									 cout<<"ERROR checkTripD_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): Waiting station: correct = noWS"<<"; wrong = "<<seg[idVeh].Trip[idTrip].waitingS<<endl;
//									 cout<<"CASE: "<<assSP<<" - DELIVERY TRIP - sp = "<<(endSP)<<" - DELIVERY TRIP; exceed eTW2"<<endl;
//									 stop = 1;
//								  }
//
//								  if (PDSDIF(temp, seg[idVeh].Trip[nextTrip].vioTWSP))
//								  {
//									  cout<<"ERROR checkTripD_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): vioTWSP : correct = "<<temp<<"; wrong = "<<seg[idVeh].Trip[nextTrip].vioTWSP<<endl;
//									  cout<<"CASE: "<<assSP<<" - DELIVERY TRIP - sp = "<<(endSP)<<" - DELIVERY TRIP; exceed eTW2"<<endl;
//									  stop = 1;
//								  }
//								  if (PDSDIF(problem->nodeSP[endSP].eTW2,seg[idVeh].Trip[idTrip].arriveSP))
//								  {
//									 cout<<"ERROR checkTripD_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): arriveSP : correct = "<<problem->nodeSP[endSP].eTW2<<"; but field arriveSP = "<<seg[idVeh].Trip[idTrip].arriveSP<<endl;
//									 cout<<"CASE: "<<assSP<<" - DELIVERY TRIP - sp = "<<(endSP)<<" - DELIVERY TRIP: exceed eTW2"<<endl;
//									 stop = 1;
//								  }
//
//	  							  cTemp +=  problem->c[preC][endSP];
//							  }
//							  else
//							  {
//								  double cArrTimeI = endS + problem->disCWSSP[preC][endSP];
//								  temp = cArrTimeI - problem->nodeSP[endSP].eTW2;
//								  if (temp > eps)
//								  {
//									  if (PDSDIF(problem->c[preC][endSP],seg[idVeh].Trip[idTrip].connectCost))
//									  {
//										 cout<<"ERROR checkTripD_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): Connectcost : correct = "<<problem->c[preC][endSP]<<"; error = "<<seg[idVeh].Trip[idTrip].connectCost<<endl;
//										 cout<<"CASE: "<<assSP<<" - DELIVERY TRIP - sp = "<<(endSP)<<" - DELIVERY TRIP; too soon to sp directly; too late through WS"<<endl;
//										 stop = 1;
//									  }
//									  if (seg[idVeh].Trip[idTrip].waitingS != NO_WS)
//									  {
//										 cout<<"ERROR checkTripD_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): Waiting station: correct = noWS"<<"; wrong = "<<seg[idVeh].Trip[idTrip].waitingS<<endl;
//										 cout<<"CASE: "<<assSP<<" - DELIVERY TRIP - sp = "<<(endSP)<<" - DELIVERY TRIP; too soon to sp directly; too late through WS"<<endl;
//										 stop = 1;
//									  }
//
//									  temp = problem->nodeSP[endSP].sTW2 - cArrTime;
//
//									  if (PDSDIF(temp, seg[idVeh].Trip[nextTrip].vioTWSP))
//									  {
//										  cout<<"ERROR checkTripD_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): vioTWSP : correct = "<<temp<<"; wrong = "<<seg[idVeh].Trip[nextTrip].vioTWSP<<endl;
//										  cout<<"CASE: "<<assSP<<" - DELIVERY TRIP - sp = "<<(endSP)<<" - DELIVERY TRIP; too soon to sp directly; too late through WS"<<endl;
//										  stop = 1;
//									  }
//	  								  cTemp +=  problem->c[preC][endSP];
//									  if (PDSDIF(problem->nodeSP[endSP].eTW2,seg[idVeh].Trip[idTrip].arriveSP))
//									  {
//										 cout<<"ERROR checkTripD_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): arriveSP : correct = "<<problem->nodeSP[endSP].eTW2<<"; but field arriveSP = "<<seg[idVeh].Trip[idTrip].arriveSP<<endl;
//										 cout<<"CASE: "<<assSP<<" - DELIVERY TRIP - sp = "<<(endSP)<<" - DELIVERY TRIP: too soon to sp directly; too late through WS"<<endl;
//										 stop = 1;
//									  }
//								  }
//								  else //through WS:
//								  {
//									  if (PDSDIF(problem->disCWSSP[preC][endSP],seg[idVeh].Trip[idTrip].connectCost))
//									  {
//										 cout<<"ERROR checkTripD_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): Connectcost : correct = "<<problem->disCWSSP[preC][endSP]<<"; error = "<<seg[idVeh].Trip[idTrip].connectCost<<endl;
//										 cout<<"CASE: "<<assSP<<" - DELIVERY TRIP - sp = "<<(endSP)<<" - DELIVERY TRIP; through WS"<<endl;
//										 stop = 1;
//									  }
//									  if (seg[idVeh].Trip[idTrip].waitingS != problem->CWSSP[preC][endSP])
//									  {
//										  cout<<"ERROR checkTripD_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): Waiting station: correct = "<<problem->CWSSP[preC][endSP]<<"; wrong = "<<seg[idVeh].Trip[idTrip].waitingS<<endl;
//										  cout<<"CASE: "<<assSP<<" - DELIVERY TRIP - sp = "<<(endSP)<<" - DELIVERY TRIP; through WS"<<endl;
//										  stop = 1;
//									  }
//
//									  if (seg[idVeh].Trip[nextTrip].vioTWSP > eps)
//									  {
//										  cout<<"ERROR checkTripD_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): vioTWSP : correct = 0; wrong = "<<seg[idVeh].Trip[nextTrip].vioTWSP<<endl;
//										  cout<<"CASE: "<<assSP<<" - DELIVERY TRIP - sp = "<<(endSP)<<" - DELIVERY TRIP; through WS"<<endl;
//										  stop = 1;
//									  }
//									  cTemp += problem->disCWSSP[preC][endSP];
//									  cArrTime = PDS_MAX(cArrTimeI, problem->nodeSP[endSP].sTW2);
//									  if (PDSDIF(cArrTime,seg[idVeh].Trip[idTrip].arriveSP))
//									  {
//										 cout<<"ERROR checkTripD_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): arriveSP : correct = "<<cArrTime<<"; but field arriveSP = "<<seg[idVeh].Trip[idTrip].arriveSP<<endl;
//										 cout<<"CASE: "<<assSP<<" - DELIVERY TRIP - sp = "<<(endSP)<<" - DELIVERY TRIP: through WS"<<endl;
//										 stop = 1;
//									  }
//								  }//end through WS
//							  }
//						 }
//					}
//					else //next trip is pickup/C2C trip:
//					{
//						 cTemp += problem->c[preC][seg[idVeh].Trip[nextTrip].firstCus];
//						 if (PDSDIF(problem->c[preC][seg[idVeh].Trip[nextTrip].firstCus],seg[idVeh].Trip[idTrip].connectCost))
//						 {
//							 cout<<"ERROR checkTripD_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): Connectcost: correct = "<<problem->c[preC][seg[idVeh].Trip[nextTrip].firstCus]<<"; error = "<<seg[idVeh].Trip[idTrip].connectCost<<endl;
//							 cout<<"CASE: "<<assSP<<" - DELIVERY TRIP - PICKUP/C2C TRIP"<<endl;
//							 stop = 1;
//						 }
//					 	 if (seg[idVeh].Trip[idTrip].waitingS != NO_WS)
//						 {
//							 cout<<"ERROR checkTripD_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): Waiting station: correct = noWS"<<"; wrong = "<<seg[idVeh].Trip[idTrip].waitingS<<endl;
//							 cout<<"CASE: "<<assSP<<" - DELIVERY TRIP - PICKUP/C2C TRIP"<<endl;
//							 stop = 1;
//						}
//					}//end next trip is pickup/C2C trip
//				}
//				else //the lastTrip
//				{
//					if (PDSDIF(seg[idVeh].Trip[idTrip].connectCost, problem->c[preC][0]))
//					{
//						cout<<"ERROR checkTripD_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): connectCost of the last delivery Trip: correct = "<<problem->c[preC][0]<<"; wrong = "<<seg[idVeh].Trip[idTrip].connectCost<<endl;
//						stop = 1;
//					}
//					cTemp += problem->c[preC][0];
//				}//end the lastTrip
//				if (PDSDIF(cTemp,seg[idVeh].Trip[idTrip].cost))
//				{
//					 cout<<"ERROR checkTripD_ALLFIELDS("<<idVeh<<", "<<idTrip<<") cost: correct = "<<cTemp<<"; error = "<<seg[idVeh].Trip[idTrip].cost<<endl;
//					 stop = 1;
//				}
//				//Checking BCAP, BvioTWCus:
//				curC = seg[idVeh].Trip[idTrip].lastCus; int BCAPT = 0; double BvioTWCUST = 0;
//				do
//				{
//					BCAPT += problem->node[curC].capacity;
//					BvioTWCUST += vioTWCus[curC];
//					if  (BCAP[curC] != BCAPT)
//					{
//						stop = 1;
//						cout<<"ERROR checkTripD_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): BCAP["<<curC<<"]: wrong = "<<BCAP[curC]<<"; correct = "<<BCAPT<<endl;
//					}
//					if (PDSDIF(BvioTWCUST, BvioTWCus[curC]))
//					{
//						stop = 1;
//						cout<<"ERROR checkTripD_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): BvioTWCus["<<curC<<"]: wrong = "<<BvioTWCus[curC]<<"; correct = "<<BvioTWCUST<<endl;
//					}
//					curC = predArr[curC];
//				}while (curC > 0);
//		}
//		else 
//		{
//			cout<<"ERROR checkTripD_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): endS: correct = "<<endS<<"; wrong = "<<seg[idVeh].Trip[idTrip].endS<<endl;
//			stop = 1;
//		}
//	}
//	if (stop)
//	{
//		cout<<"Delivery TRIP ERROR: "; showTripCost(idVeh, idTrip);
//	    cout<<" ----------------------- VEHCILE "<<idVeh<<" -------------------------"<<endl;
//		showSegment(idVeh);
//	}
//	return stop;
//	//if (correct == 0) exit(-1);
//}
//
//
//bool Solution::checkTripP_ALLFIELDS(int idVeh, int idTrip) //just checking field of trip; for both FEASIBLE and INFEASIBLE TRIP
//{
//	//see on 27/11/2013
//	bool stop = 0;
//	double cTemp = 0; 
//
//	int assSP = seg[idVeh].Trip[idTrip].assSP;
//	int preC = seg[idVeh].Trip[idTrip].firstCus;
//	int curC, i;
//	double endS, cArrTime, cArrTimeI, temp;
//	curC = seg[idVeh].Trip[idTrip].firstCus;
//	int CAPT = 0; double vioTWCT =0; double FvioTWCT=0;
//
//	int buon = seg[idVeh].Trip[idTrip].firstCus;
//	int nbuon = 0;
//	bool chan = 0;
//	while (buon > 0)
//	{
//		nbuon++;
//		if (buon > endidP) 
//		{
//			cout<<"ERROR checkTripP_ALLFIELDS("<<idVeh<<", "<<idTrip<<") cus exceed ID = "<<buon<<" > "<<endidP<<endl;
//			chan = 1;
//		}
//		if (buon < startidP) 
//		{
//			cout<<"ERROR checkTripP_ALLFIELDS("<<idVeh<<", "<<idTrip<<") cus smaller ID = "<<buon<<" < "<<startidP<<endl;
//			chan = 1;
//		}		
//		if (problem->belong[buon][assSP] != 1)
//		{
//			cout<<"ERROR checkTripP_ALLFIELDS("<<idVeh<<", "<<idTrip<<") cus "<<buon<<" CANNOT assign to sp "<<assSP<<endl;
//			cout<<"List available sp of cus "<<buon<<":  ";
//			for (i = 1; i<= problem->node[buon].numSP; i++)
//				cout<<problem->node[buon].sp[i]<<",  ";
//			cout<<endl;
//			chan = 1;
//		}
//		buon = nextArr[buon];
//	}
//	if (chan)
//	{
//	    showTripCus(idVeh, idTrip);
//		exit(-1);
//	}
//	if (nbuon != seg[idVeh].Trip[idTrip].numCus)
//	{
//		stop = 1;
//		cout<<"ERROR checkTripP_ALLFIELDS("<<idVeh<<", "<<idTrip<<") numCus: correct = "<<nbuon<<"; wrong = "<<seg[idVeh].Trip[idTrip].numCus<<endl;
//	    showTripCus(idVeh, idTrip);
//		exit(-1);
//	}
//
//	bool feaT;
//	if (seg[idVeh].Trip[idTrip].vioCAP > 0 || seg[idVeh].Trip[idTrip].vioTWC > eps || seg[idVeh].Trip[idTrip].vioTWSP > eps)
//		feaT = 0;
//	else feaT = 1;
//	if (seg[idVeh].Trip[idTrip].feasible != feaT)
//	{
//		stop = 1;
//		cout<<"ERROR checkTripP_ALLFIELDS("<<idVeh<<", "<<idTrip<<") feasible: correct = "<<feaT<<"; wrong fieldfeasible = "<<seg[idVeh].Trip[idTrip].feasible<<endl;
//	}
//	if (idTrip == 0)
//	{
//		if (seg[idVeh].Trip[idTrip].numCus == 1)
//		{
//			cTemp = problem->c[0][curC];
//			CAPT += problem->node[curC].capacity; 
//			endS = problem->startSOneP[curC][assSP];
//			//checkUsed[curC] = 1;
//			if (pos[curC] != 1)
//			{
//				stop = 1;
//				cout<<"ERROR checkTripP_ALLFIELDS("<<idVeh<<", "<<idTrip<<") pos["<<curC<<"]: correct = 1; wrong = "<<pos[curC]<<endl;
//			}
//			if (route_num[curC] != idVeh)
//			{
//				stop = 1;
//				cout<<"ERROR checkTripP_ALLFIELDS("<<idVeh<<", "<<idTrip<<") route_num["<<curC<<"]: correct = "<<idVeh<<"; wrong = "<<route_num[curC]<<endl;
//			}
//			if (trip_num[curC] != idTrip)
//			{
//				stop = 1;
//				cout<<"ERROR checkTripP_ALLFIELDS("<<idVeh<<", "<<idTrip<<") trip_num["<<curC<<"]: correct = "<<idTrip<<"; wrong = "<<trip_num[curC]<<endl;
//			}
//			if  (FCAP[curC] != CAPT)
//			{
//				stop = 1;
//				cout<<"ERROR checkTripP_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): FCAP["<<curC<<"]: wrong = "<<FCAP[curC]<<"; correct = "<<CAPT<<endl;
//			}
//			if (PDSDIF(endS, startS[curC]))
//			{
//				stop = 1;
//				cout<<"ERROR checkTripP_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): startS["<<curC<<"]: wrong = "<<startS[curC]<<"; correct = "<<endS<<endl;
//			}
//			
//			endS += problem->node[curC].duration;
//			if (PDSDIF(endS, depart[curC]))
//			{
//				stop = 1;
//				cout<<"ERROR checkTripP_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): depart["<<curC<<"]: wrong = "<<depart[curC]<<"; correct = "<<endS<<endl;
//			}
//			preC = curC;
//			if (seg[idVeh].Trip[idTrip].lastCus != curC)
//			{
//				stop = 1;
//				cout<<"ERROR checkTripP_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): lastCus: wrong = "<<seg[idVeh].Trip[idTrip].lastCus<<"; correct = "<<curC<<endl;
//			}
//		}
//		else //numCus >= 2
//		{
//			endS = PDS_MAX(problem->c[0][curC], problem->node[curC].sTW);
//			cTemp = problem->c[0][curC];
//			CAPT += problem->node[curC].capacity; 
//			//checkUsed[curC] = 1;
//			if (pos[curC] != 1)
//			{
//				stop = 1;
//				cout<<"ERROR checkTripP_ALLFIELDS("<<idVeh<<", "<<idTrip<<") pos["<<curC<<"]: correct = 1; wrong = "<<pos[curC]<<endl;
//			}
//			if (route_num[curC] != idVeh)
//			{
//				stop = 1;
//				cout<<"ERROR checkTripP_ALLFIELDS("<<idVeh<<", "<<idTrip<<") route_num["<<curC<<"]: correct = "<<idVeh<<"; wrong = "<<route_num[curC]<<endl;
//			}
//			if (trip_num[curC] != idTrip)
//			{
//				stop = 1;
//				cout<<"ERROR checkTripP_ALLFIELDS("<<idVeh<<", "<<idTrip<<") trip_num["<<curC<<"]: correct = "<<idTrip<<"; wrong = "<<trip_num[curC]<<endl;
//			}
//
//			if (PDSDIF(endS, startS[curC]))
//			{
//				stop = 1;
//				cout<<"ERROR checkTripP_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): startS["<<curC<<"]: wrong = "<<startS[curC]<<"; correct = "<<endS<<endl;
//			}
//			
//			if  (FCAP[curC] != CAPT)
//			{
//				stop = 1;
//				cout<<"ERROR checkTripP_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): FCAP["<<curC<<"]: wrong = "<<FCAP[curC]<<"; correct = "<<CAPT<<endl;
//			}
//			endS += problem->node[curC].duration;
//			if (PDSDIF(endS, depart[curC]))
//			{
//				stop = 1;
//				cout<<"ERROR checkTripP_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): depart["<<curC<<"]: wrong = "<<depart[curC]<<"; correct = "<<endS<<endl;
//			}
//
//
//			preC = curC; curC = nextArr[curC];
//			for (i=2;i<=seg[idVeh].Trip[idTrip].numCus;i++)
//			{
//					CAPT += problem->node[curC].capacity; 
//					cTemp += problem->c[preC][curC];
//					endS += problem->c[preC][curC];
//					//vioTWCT = PDS_MAX(endS - problem->node[curC].eTW, 0);
//					vioTWCT = endS - problem->node[curC].eTW;
//					if (vioTWCT > eps)	FvioTWCT += vioTWCT;
//					else vioTWCT = 0;
//					if  (pos[curC] != i)
//					{
//						stop = 1;
//						cout<<"ERROR checkTripP_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): pos["<<curC<<"]: wrong = "<<pos[curC]<<"; correct = "<<i<<endl;
//					}
//					if (route_num[curC] != idVeh)
//					{
//						stop = 1;
//						cout<<"ERROR checkTripP_ALLFIELDS("<<idVeh<<", "<<idTrip<<") route_num["<<curC<<"]: correct = "<<idVeh<<"; wrong = "<<route_num[curC]<<endl;
//					}
//					if (trip_num[curC] != idTrip)
//					{
//						stop = 1;
//						cout<<"ERROR checkTripP_ALLFIELDS("<<idVeh<<", "<<idTrip<<") trip_num["<<curC<<"]: correct = "<<idTrip<<"; wrong = "<<trip_num[curC]<<endl;
//					}
//
//					if  (FCAP[curC] != CAPT)
//					{
//						stop = 1;
//						cout<<"ERROR checkTripP_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): FCAP["<<curC<<"]: wrong = "<<FCAP[curC]<<"; correct = "<<CAPT<<endl;
//					}
//
//					if (PDSDIF(vioTWCT, vioTWCus[curC])) 
//					{
//						stop = 1;
//						cout<<"ERROR checkTripP_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): vioTWCus["<<curC<<"]: wrong = "<<vioTWCus[curC]<<"; correct = "<<vioTWCT<<endl;
//					}
//					if (PDSDIF(FvioTWCT, FvioTWCus[curC])) 
//					{
//						stop = 1;
//						cout<<"ERROR checkTripP_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): FvioTWCus["<<curC<<"]: wrong = "<<FvioTWCus[curC]<<"; correct = "<<FvioTWCT<<endl;
//					}			
//					if (vioTWCT > eps)
//						endS = problem->node[curC].eTW;
//					else endS = PDS_MAX(endS, problem->node[curC].sTW);
//
//					if (PDSDIF(endS, startS[curC]))
//					{
//						stop = 1;
//						cout<<"ERROR checkTripP_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): startS["<<curC<<"]: wrong = "<<startS[curC]<<"; correct = "<<endS<<endl;
//					}
//					
//					endS += problem->node[curC].duration;
//					if (PDSDIF(endS, depart[curC]))
//					{
//						stop = 1;
//						cout<<"ERROR checkTripP_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): depart["<<curC<<"]: wrong = "<<depart[curC]<<"; correct = "<<endS<<endl;
//					}
//					preC = curC; curC = nextArr[curC];
//			}
//		}//end numCus >= 2
//
//	}
//	else
//	{
//		int preT = idTrip - 1; double endSBUON;
//		if (seg[idVeh].Trip[preT].Type == 0)
//		{
//			preC = seg[idVeh].Trip[preT].assSP;
//			endS = seg[idVeh].Trip[preT].leaveSP;
//		}
//		else //if (seg[idVeh].Trip[preT].Type == 1 || 2)
//		{
//			preC = seg[idVeh].Trip[preT].lastCus;
//			endS = depart[preC]; 
//		}
//		endSBUON = endS; int preCBUON = preC;
//		cTemp =-problem->c[preC][curC];
//		FvioTWCT = 0;
//		for (i=1;i<=seg[idVeh].Trip[idTrip].numCus;i++)
//		{
//				CAPT += problem->node[curC].capacity; 
//				cTemp += problem->c[preC][curC];
//				endS += problem->c[preC][curC];
//				vioTWCT = endS - problem->node[curC].eTW;
//				//vioTWCT = PDS_MAX(endS - problem->node[curC].eTW, 0);
//				if (vioTWCT > eps) 	FvioTWCT += vioTWCT;
//				else vioTWCT = 0;
//				if  (pos[curC] != i)
//				{
//					stop = 1;
//					cout<<"ERROR checkTripP_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): pos["<<curC<<"]: wrong = "<<pos[curC]<<"; correct = "<<i<<endl;
//				}
//				if (route_num[curC] != idVeh)
//				{
//					stop = 1;
//					cout<<"ERROR checkTripP_ALLFIELDS("<<idVeh<<", "<<idTrip<<") route_num["<<curC<<"]: correct = "<<idVeh<<"; wrong = "<<route_num[curC]<<endl;
//				}
//				if (trip_num[curC] != idTrip)
//				{
//					stop = 1;
//					cout<<"ERROR checkTripP_ALLFIELDS("<<idVeh<<", "<<idTrip<<") trip_num["<<curC<<"]: correct = "<<idTrip<<"; wrong = "<<trip_num[curC]<<endl;
//				}
//
//				if  (FCAP[curC] != CAPT)
//				{
//					stop = 1;
//					cout<<"ERROR checkTripP_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): FCAP["<<curC<<"]: wrong = "<<FCAP[curC]<<"; correct = "<<CAPT<<endl;
//				}
//
//				if (PDSDIF(vioTWCT, vioTWCus[curC])) 
//				{
//					stop = 1;
//					cout<<"ERROR checkTripP_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): vioTWCus["<<curC<<"]: wrong = "<<vioTWCus[curC]<<"; correct = "<<vioTWCT<<endl;
//				}
//				if (PDSDIF(FvioTWCT, FvioTWCus[curC])) 
//				{
//					stop = 1;
//					cout<<"ERROR checkTripP_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): FvioTWCus["<<curC<<"]: wrong = "<<FvioTWCus[curC]<<"; correct = "<<FvioTWCT<<endl;
//				    int buonlam = seg[idVeh].Trip[idTrip].firstCus;
//					double cutlam = 0;
//					cout<<"VIOTWCUS: ";
//					for (int cut=1;cut<=seg[idVeh].Trip[idTrip].numCus;cut++)
//					{
//						cutlam += vioTWCus[buonlam];
//						cout<<buonlam<<"("<<vioTWCus[buonlam]<<", "<<cutlam<<"), ";
//						buonlam = nextArr[buonlam];
//					}
//					cout<<endl;
//					cout<<"DERETOUR CAL: ";
//					int curCBUON = seg[idVeh].Trip[idTrip].firstCus;
//					double FvioTWCTBUON = 0;
//					for (int cut = 1; cut <=i; cut++)
//					{
//						endSBUON += problem->c[preCBUON][curCBUON];
//						vioTWCT = endSBUON - problem->node[curCBUON].eTW;
//						//vioTWCT = PDS_MAX(endSBUON - problem->node[curCBUON].eTW, 0);
//						if (vioTWCT > eps) 
//						{
//							FvioTWCTBUON += vioTWCT;
//							cout<<curCBUON<<"("<<vioTWCT<<", "<<FvioTWCTBUON<<"), ";
//							endSBUON = problem->node[curCBUON].depart;
//						}
//						else endSBUON = PDS_MAX(endSBUON, problem->node[curCBUON].sTW) + problem->node[curCBUON].duration;
//						preCBUON = curCBUON; curCBUON = nextArr[curCBUON];
//					}
//					cout<<endl;
//				}			
//				if (vioTWCT > eps)
//					endS = problem->node[curC].eTW;
//				else endS = PDS_MAX(endS, problem->node[curC].sTW);
//
//				if (PDSDIF(endS, startS[curC]))
//				{
//					stop = 1;
//					cout<<"ERROR checkTripP_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): startS["<<curC<<"]: wrong = "<<startS[curC]<<"; correct = "<<endS<<endl;
//				}
//				
//				endS += problem->node[curC].duration;
//				if (PDSDIF(endS, depart[curC]))
//				{
//					stop = 1;
//					cout<<"ERROR checkTripP_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): depart["<<curC<<"]: wrong = "<<depart[curC]<<"; correct = "<<endS<<endl;
//				}
//				preC = curC; curC = nextArr[curC];
//		}
//	}
//
//
//
//	if (CAPT != seg[idVeh].Trip[idTrip].capacity)
//	{
//		cout<<"ERROR checkTripP_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): cap of trip: correct = "<<CAPT<<"; wrong = "<<seg[idVeh].Trip[idTrip].capacity<<endl;
//		stop = 1;
//	}
//	else
//	{
//		int vioCAPT = PDS_MAX(CAPT - problem->Q, 0);
//		if (vioCAPT != seg[idVeh].Trip[idTrip].vioCAP)
//		{
//			stop = 1;
//			cout<<"ERROR checkTripP_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): vioCAP: wrong = "<<seg[idVeh].Trip[idTrip].vioCAP<<"; correct = "<<vioCAPT<<endl;
//		}
//	}
//
//	if (seg[idVeh].Trip[idTrip].lastCus != preC)
//	{
//		stop = 1;
//		cout<<"ERROR checkTripP_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): lastCus: wrong = "<<seg[idVeh].Trip[idTrip].lastCus<<"; correct = "<<preC<<endl;
//	}
//
//
//		if (PDSDIF(seg[idVeh].Trip[idTrip].endS, endS)==0)
//		{
//			cArrTime = endS + problem->c[preC][assSP];
//			if (PDSINRANGE(cArrTime, problem->nodeSP[assSP].sTW1, problem->nodeSP[assSP].eTW1))
//			{
//				cTemp += problem->c[preC][assSP];
//				if (seg[idVeh].Trip[idTrip].waitingS != NO_WS)
//				{
//					cout<<"ERROR checkTripP_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): correct waitingS = NO_WS; wrong = "<<seg[idVeh].Trip[idTrip].waitingS<<endl;
//					stop = 1;
//				}
//				if (seg[idVeh].Trip[idTrip].vioTWSP > eps)
//				{
//					cout<<"ERROR checkTripP_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): correct vioTWSP = 0; wrong = "<<seg[idVeh].Trip[idTrip].vioTWSP<<endl;
//					stop = 1;
//				}
//				endS = cArrTime + problem->nodeSP[assSP].unload;
//			}
//			else
//			{
//				temp = cArrTime - problem->nodeSP[assSP].eTW1;
//				if (temp > eps)
//				{
//					if (seg[idVeh].Trip[idTrip].waitingS != NO_WS)
//					{
//						cout<<"ERROR checkTripP_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): correct waitingS = NO_WS; wrong = "<<seg[idVeh].Trip[idTrip].waitingS<<endl;
//						stop = 1;
//					}
//					if (PDSDIF(temp, seg[idVeh].Trip[idTrip].vioTWSP))
//					{
//						cout<<"ERROR checkTripP_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): correct vioTWSP = "<<temp<<"; wrong = "<<seg[idVeh].Trip[idTrip].vioTWSP<<endl;
//						cout<<"CASE exceed eTW1 of sp "<<assSP<<"; eTW1 = "<<problem->nodeSP[assSP].eTW1<<"; cArrTime = "<<cArrTime<<"; endS = "<<endS<<endl;
//						stop = 1;
//					}
//					cTemp += problem->c[preC][assSP];
//					endS = problem->leaveSP[assSP][0]; //unload at eTW1
//				}
//				else
//				{
//					double cArrTimeI = endS + problem->disCWSSP[preC][assSP];
//					temp = cArrTimeI - problem->nodeSP[assSP].eTW1;
//					if (temp > eps)
//					{
//						temp = problem->nodeSP[assSP].sTW1 - cArrTime;
//						if (PDSDIF(temp, seg[idVeh].Trip[idTrip].vioTWSP))
//						{
//							cout<<"ERROR checkTripP_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): correct vioTWSP = "<<temp<<"; wrong = "<<seg[idVeh].Trip[idTrip].vioTWSP<<endl;
//							cout<<"CASE too soon to go sp directly, too late to go through WS; eTW1 of sp "<<assSP<<"; eTW1 = "<<problem->nodeSP[assSP].eTW1<<"; cArrTimeDirect = "<<cArrTime<<"; cArrTimeIndirect = "<<cArrTimeI<<endl;
//							stop = 1;
//						}
//						if (seg[idVeh].Trip[idTrip].waitingS != NO_WS)
//						{
//							cout<<"ERROR checkTripP_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): correct waitingS = NO_WS; wrong = "<<seg[idVeh].Trip[idTrip].waitingS<<endl;
//							cout<<"CASE too soon to go sp directly, too late to go through WS; eTW1 of sp "<<assSP<<"; eTW1 = "<<problem->nodeSP[assSP].eTW1<<"; cArrTimeDirect = "<<cArrTime<<"; cArrTimeIndirect = "<<cArrTimeI<<endl;
//							stop = 1;
//						}
//						endS = problem->leaveSP[assSP][0]; //unload at eTW1
//						cTemp += problem->c[preC][assSP];
//					}
//					else
//					{
//						cTemp += problem->disCWSSP[preC][assSP];
//						if (seg[idVeh].Trip[idTrip].waitingS != problem->CWSSP[preC][assSP])
//						{
//							cout<<"ERROR checkTripP_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): correct waitingS = "<<problem->CWSSP[preC][assSP]<<"; wrong = "<<seg[idVeh].Trip[idTrip].waitingS<<endl;
//							cout<<"LastCus of trip = "<<preC<<" !=? "<<seg[idVeh].Trip[idTrip].lastCus<<endl;
//							cout<<"CASE to go through WS"<<endl;
//							stop = 1;
//						}
//						if (seg[idVeh].Trip[idTrip].vioTWSP > eps)
//						{
//							cout<<"ERROR checkTripP_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): correct vioTWSP = 0; wrong = "<<seg[idVeh].Trip[idTrip].vioTWSP<<endl;
//							cout<<"CASE to go through WS"<<endl;
//							stop = 1;
//						}
//						endS = PDS_MAX(cArrTimeI, problem->nodeSP[assSP].sTW1) + problem->nodeSP[assSP].unload;
//					}
//				}
//			}
//			if (stop == 0)
//			{
//				double costT = seg[idVeh].Trip[idTrip].cost - seg[idVeh].Trip[idTrip].connectCost;
//				if (PDSDIF(cTemp, costT))
//				{
//					cout<<"ERROR checkTripP_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): cost (between cus and SP, exclude connectCost): correct = "<<cTemp<<"; wrong = "<<costT<<endl;
//					stop = 1;
//				}
//				
//					int lastT = seg[idVeh].numTrips - 1;
//					if (idTrip == lastT)
//					{
//						if (PDSDIF(problem->c[assSP][0], seg[idVeh].Trip[idTrip].connectCost))
//						{
//							cout<<"ERROR checkTripP_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): Connectcost: correct = "<<problem->c[assSP][0]<<"; wrong = "<<seg[idVeh].Trip[idTrip].connectCost<<endl;
//							cout<<"CASE: last pickup trip"<<endl;
//							stop = 1;
//						}
//						if (seg[idVeh].Trip[idTrip].waitingS1 != NO_WS)
//						{
//							cout<<"ERROR checkTripP_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): waitingS1: correct = NO_WS; wrong = "<<seg[idVeh].Trip[idTrip].waitingS1<<endl;
//							cout<<"CASE: last pickup trip"<<endl;
//							stop = 1;
//						}
//						if (PDSDIF(seg[idVeh].Trip[idTrip].leaveSP, endS))
//						{
//							cout<<"ERROR checkTripP_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): leaveSP: correct = "<<endS<<"; wrong = "<<seg[idVeh].Trip[idTrip].leaveSP<<endl;
//							cout<<"CASE: last pickup trip"<<endl;
//							stop = 1;
//						}
//						cTemp += problem->c[assSP][0];
//					}
//					else //not lastTrip
//					{
//						int nextT = idTrip + 1;
//						if (seg[idVeh].Trip[nextT].Type == 1)
//						{
//							int assSP1 = seg[idVeh].Trip[nextT].assSP;
//							if (assSP1 == assSP)
//							{
//								if (seg[idVeh].Trip[idTrip].connectCost > eps)
//								{
//									cout<<"ERROR checkTripP_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): Connectcost : correct = 0; wrong = "<<seg[idVeh].Trip[idTrip].connectCost<<endl;
//									cout<<"CASE: p - d: sameSP"<<endl;
//									stop = 1;
//								}
//								if (seg[idVeh].Trip[idTrip].waitingS1 != NO_WS)
//								{
//									cout<<"ERROR checkTripP_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): waitingS1: correct = NO_WS; wrong = "<<seg[idVeh].Trip[idTrip].waitingS1<<endl;
//									cout<<"CASE: p - d: sameSP"<<endl;
//									stop = 1;
//								}
//								if (PDSDIF(seg[idVeh].Trip[idTrip].vioTWSP, seg[idVeh].Trip[nextT].vioTWSP))
//								{
//									cout<<"ERROR checkTripP_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): wrong vioTWSP of nextDelivery trip: correct = "<<seg[idVeh].Trip[idTrip].vioTWSP<<"; wrong = "<<seg[idVeh].Trip[nextT].vioTWSP<<endl;
//									cout<<"CASE: p - d: sameSP"<<endl;
//									stop = 1;
//								}
//								if (PDSDIF(seg[idVeh].Trip[idTrip].leaveSP, endS))
//								{
//									cout<<"ERROR checkTripP_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): leaveSP: correct = "<<endS<<"; wrong = "<<seg[idVeh].Trip[idTrip].leaveSP<<endl;
//									cout<<"CASE: p - d: sameSP"<<endl;
//									stop = 1;
//								}
//
//							}
//							else
//							{
//								if (PDSDIF(seg[idVeh].Trip[idTrip].leaveSP, endS))
//								{
//									cout<<"ERROR checkTripP_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): leaveSP: correct = "<<endS<<"; wrong = "<<seg[idVeh].Trip[idTrip].leaveSP<<endl;
//									cout<<"CASE: p - d: difSP"<<endl;
//									stop = 1;
//								}
//								cArrTime = endS + problem->c[assSP][assSP1];
//								if (PDSINRANGE(cArrTime, problem->nodeSP[assSP1].sTW2, problem->nodeSP[assSP1].eTW2))
//								{
//									cTemp += problem->c[assSP][assSP1];
//									if (seg[idVeh].Trip[idTrip].waitingS1 != NO_WS)
//									{
//										cout<<"ERROR checkTripP_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): correct waitingS1 = NO_WS; wrong = "<<seg[idVeh].Trip[idTrip].waitingS1<<endl;
//										cout<<"CASE: p - d: difSP"<<endl;
//										stop = 1;
//									}
//									if (PDSDIF(seg[idVeh].Trip[idTrip].connectCost,problem->c[assSP][assSP1]))
//									{
//										cout<<"ERROR checkTripP_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): correct connectCost = "<<problem->c[assSP][assSP1]<<"; wrong = "<<seg[idVeh].Trip[idTrip].connectCost<<endl;
//										cout<<"CASE: p - d: difSP"<<endl;
//										stop = 1;
//									}
//									if (seg[idVeh].Trip[nextT].vioTWSP > eps)
//									{
//										cout<<"ERROR checkTripP_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): wrong vioTWSP of nextDelivery trip: correct = 0; wrong = "<<seg[idVeh].Trip[nextT].vioTWSP<<endl;
//										cout<<"CASE: p - d: difSP"<<endl;
//										stop = 1;
//									}
//								}
//								else
//								{
//									temp = cArrTime - problem->nodeSP[assSP1].eTW2;
//									if (temp > eps)
//									{
//										  cTemp += problem->c[assSP][assSP1];
//										  if (seg[idVeh].Trip[idTrip].waitingS1 != NO_WS)
//										  {
//												cout<<"ERROR checkTripP_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): correct waitingS1 = NO_WS; wrong = "<<seg[idVeh].Trip[idTrip].waitingS1<<endl;
//												cout<<"CASE: p - d: difSP; exceed eTW2 of sp"<<endl;
//												stop = 1;
//										  }
//										  if (PDSDIF(seg[idVeh].Trip[idTrip].connectCost,problem->c[assSP][assSP1]))
//										  {
//												cout<<"ERROR checkTripP_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): correct connectCost= "<<problem->c[assSP][assSP1]<<"; wrong = "<<seg[idVeh].Trip[idTrip].connectCost<<endl;
//												cout<<"CASE: p - d: difSP; exceed eTW2 of sp"<<endl;
//												stop = 1;
//										  }
//										  if (PDSDIF(temp, seg[idVeh].Trip[nextT].vioTWSP))
//										  {
//											cout<<"ERROR checkTripP_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): wrong vioTWSP of nextDelivery trip: correct = "<<temp<<"; wrong = "<<seg[idVeh].Trip[nextT].vioTWSP<<endl;
//											cout<<"CASE: p - d: difSP; exceed eTW2 of sp"<<endl;
//											stop = 1;
//										  }
//									}
//									else
//									{
//										cArrTimeI = endS + problem->disCWSSP[assSP][assSP1];
//										temp = cArrTimeI - problem->nodeSP[assSP1].eTW2;
//										if (temp > eps)
//										{
//											  cTemp += problem->c[assSP][assSP1];
//											  temp = problem->nodeSP[assSP1].sTW2 - cArrTime;
//											  if (seg[idVeh].Trip[idTrip].waitingS1 != NO_WS)
//											  {
//													cout<<"ERROR checkTripP_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): correct waitingS1 = NO_WS; wrong = "<<seg[idVeh].Trip[idTrip].waitingS1<<endl;
//													cout<<"CASE: p - d: difSP; too soon to sp directly; too late through WS"<<endl;
//													stop = 1;
//											  }
//											  if (PDSDIF(seg[idVeh].Trip[idTrip].connectCost,problem->c[assSP][assSP1]))
//											  {
//													cout<<"ERROR checkTripP_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): correct connectCost = "<<problem->c[assSP][assSP1]<<"; wrong = "<<seg[idVeh].Trip[idTrip].connectCost<<endl;
//													cout<<"CASE: p - d: difSP; too soon to sp directly; too late through WS"<<endl;
//													stop = 1;
//											  }
//											  if (PDSDIF(temp, seg[idVeh].Trip[nextT].vioTWSP))
//											  {
//												cout<<"ERROR checkTripP_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): wrong vioTWSP of nextDelivery trip: correct = "<<temp<<"; wrong = "<<seg[idVeh].Trip[nextT].vioTWSP<<endl;
//												cout<<"CASE: p - d: difSP; too soon to sp directly; too late through WS"<<endl;
//												stop = 1;
//											  }
//										}
//										else
//										{
//											cTemp += problem->disCWSSP[assSP][assSP1];
//											if (seg[idVeh].Trip[idTrip].waitingS1 != problem->CWSSP[assSP][assSP1])
//											{
//												cout<<"ERROR checkTripP_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): correct waitingS1 = "<<problem->CWSSP[assSP][assSP1]<<"; wrong = "<<seg[idVeh].Trip[idTrip].waitingS1<<endl;
//												cout<<"CASE: p - d: difSP; through WS"<<endl;
//												stop = 1;
//											}
//											if (PDSDIF(seg[idVeh].Trip[idTrip].connectCost,problem->disCWSSP[assSP][assSP1]))
//											{
//												cout<<"ERROR checkTripP_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): correct connectCost = "<<problem->disCWSSP[assSP][assSP1]<<"; wrong = "<<seg[idVeh].Trip[idTrip].connectCost<<endl;
//												cout<<"CASE: p - d: difSP; through WS"<<endl;
//												stop = 1;
//											}
//											if (seg[idVeh].Trip[nextT].vioTWSP > eps)
//										    {
//											    cout<<"ERROR checkTripP_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): wrong vioTWSP of nextDelivery trip: correct = 0; wrong = "<<seg[idVeh].Trip[nextT].vioTWSP<<endl;
//											    cout<<"CASE: p - d: difSP; through WS"<<endl;
//											    stop = 1;
//										    }
//										}
//									}
//								}
//							}
//						}
//						else //nextTrip is pickup/C2C trip
//						{
//							if (PDSDIF(problem->c[assSP][seg[idVeh].Trip[nextT].firstCus],seg[idVeh].Trip[idTrip].connectCost))
//							{
//								cout<<"ERROR checkTripP_ALLFIELDS("<<idVeh<<", "<<idTrip<<"):ConnectCost correct = "<<problem->c[assSP][seg[idVeh].Trip[nextT].firstCus]<<"; wrong = "<<seg[idVeh].Trip[idTrip].connectCost<<endl;
//								cout<<"CASE: p - p(C2C)"<<endl;
//								stop = 1;
//							}
//							cTemp += problem->c[assSP][seg[idVeh].Trip[nextT].firstCus];
//						}//end nextTrip is pickup/C2C trip
//						if (PDSDIF(cTemp, seg[idVeh].Trip[idTrip].cost))
//						{
//							cout<<"ERROR checkTripP_ALLFIELDS("<<idVeh<<", "<<idTrip<<"):cost correct = "<<cTemp<<"; wrong = "<<seg[idVeh].Trip[idTrip].cost<<endl;
//							stop = 1;
//						}
//					}//end not lastTrip
//			}//end if (correct)
//		}
//		else 
//		{
//			cout<<"ERROR checkTripP_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): endS : correct = "<<endS<<"; wrong = "<<seg[idVeh].Trip[idTrip].endS<<endl;
//			stop = 1;
//		}
//		//Checking BCAP, BvioTWCus:
//		curC = seg[idVeh].Trip[idTrip].lastCus; int BCAPT = 0; double BvioTWCusT = 0;
//		do
//		{
//			BCAPT += problem->node[curC].capacity;
//			BvioTWCusT += vioTWCus[curC];
//			if  (BCAP[curC] != BCAPT)
//			{
//				stop = 1;
//				cout<<"ERROR checkTripP_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): BCAP["<<curC<<"]: wrong = "<<BCAP[curC]<<"; correct = "<<BCAPT<<endl;
//			}
//			if  (PDSDIF(BvioTWCusT, BvioTWCus[curC]))
//			{
//				stop = 1;
//				cout<<"ERROR checkTripP_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): BvioTWCus["<<curC<<"]: wrong = "<<BvioTWCus[curC]<<"; correct = "<<BvioTWCusT<<endl;
//			}
//			curC = predArr[curC];
//		}while (curC > 0);
//		
//		if (stop) 
//		{
//			cout<<"TRIP ERROR: "; 
//			showTripCost(idVeh, idTrip);
//			cout<<"------------------------------- VEHICLE "<<idVeh<<" ---------------------------"<<endl;
//			showSegment(idVeh);
//		}
//		return stop;
//		//if (correct == 0) exit(-1);
//}
//
//bool Solution::checkTripC2C_ALLFIELDS(int idVeh, int idTrip) //just checking field of trip; for both FEASIBLE and INFEASIBLE TRIP
//{
//	//see on 27/11/2013: C2CTrip don't need FCAP,BCAP
//	bool stop = 0;
//	double cTemp = 0; 
//
//	int preC = seg[idVeh].Trip[idTrip].firstCus;
//	int curC, i;
//	double endS, cArrTime, temp;
//	curC = seg[idVeh].Trip[idTrip].firstCus;
//	double vioTWCT =0; double FvioTWCT=0;
//	int vioCAPCT = 0; int FvioCAPCT = 0; int CAPVehCus=0;
//
//	int buon = seg[idVeh].Trip[idTrip].firstCus;
//	int nbuon = 0;
//	bool chan = 0;
//	while (buon > 0)
//	{
//		nbuon++;
//		if (buon > endidC2C) 
//		{
//			cout<<"ERROR checkTripC2C_ALLFIELDS("<<idVeh<<", "<<idTrip<<") cus exceed ID = "<<buon<<" > "<<endidC2C<<endl;
//			chan = 1;
//		}
//		if (buon < startidC2C) 
//		{
//			cout<<"ERROR checkTripC2C_ALLFIELDS("<<idVeh<<", "<<idTrip<<") cus smaller ID = "<<buon<<" < "<<startidC2C<<endl;
//			chan = 1;
//		}		
//		buon = nextArr[buon];
//	}
//	if (chan)
//	{
//	    showTripCus(idVeh, idTrip);
//		exit(-1);
//	}
//	if (nbuon != seg[idVeh].Trip[idTrip].numCus)
//	{
//		stop = 1;
//		cout<<"ERROR checkTripC2C_ALLFIELDS("<<idVeh<<", "<<idTrip<<") numCus: correct = "<<nbuon<<"; wrong = "<<seg[idVeh].Trip[idTrip].numCus<<endl;
//	    showTripCus(idVeh, idTrip);
//		exit(-1);
//	}
//
//	bool feaT;
//	if (seg[idVeh].Trip[idTrip].vioTWC > eps || seg[idVeh].Trip[idTrip].vioCAP > eps)
//		feaT = 0;
//	else feaT = 1;
//	if (seg[idVeh].Trip[idTrip].feasible != feaT)
//	{
//		stop = 1;
//		cout<<"ERROR checkTripC2C_ALLFIELDS("<<idVeh<<", "<<idTrip<<") feasible: correct = "<<feaT<<"; wrong fieldfeasible = "<<seg[idVeh].Trip[idTrip].feasible<<endl;
//	}
//	if (idTrip == 0)
//	{
//		int nextSP = seg[idVeh].Trip[0].nextSP;
//		if (seg[idVeh].Trip[0].numCus == 2 && nextSP > 0)
//		{
//			cTemp = 0;
//			endS = problem->startSOneP[curC][nextSP];
//			//checkUsed[curC] = 1;
//			int id = 0; int preC = 0;
//			do
//			{
//				cTemp += problem->c[preC][curC];
//				CAPVehCus += problem->node[curC].capacity; 
//				id++;
//				if (pos[curC] != id)
//				{
//					stop = 1;
//					cout<<"ERROR checkTripC2C_ALLFIELDS("<<idVeh<<", "<<idTrip<<") pos["<<curC<<"]: correct = 1; wrong = "<<pos[curC]<<endl;
//				}
//				if (route_num[curC] != idVeh)
//				{
//					stop = 1;
//					cout<<"ERROR checkTripC2C_ALLFIELDS("<<idVeh<<", "<<idTrip<<") route_num["<<curC<<"]: correct = "<<idVeh<<"; wrong = "<<route_num[curC]<<endl;
//				}
//				if (trip_num[curC] != idTrip)
//				{
//					stop = 1;
//					cout<<"ERROR checkTripC2C_ALLFIELDS("<<idVeh<<", "<<idTrip<<") trip_num["<<curC<<"]: correct = "<<idTrip<<"; wrong = "<<trip_num[curC]<<endl;
//				}
//
//				if  (CAPCus[curC] != CAPVehCus)
//				{
//					stop = 1;
//					cout<<"ERROR checkTripC2C_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): CAPCus["<<curC<<"]: wrong = "<<CAPCus[curC]<<"; correct = "<<CAPVehCus<<endl;
//				}
//
//				if (vioCAPCus[curC] != 0)
//				{
//					stop = 1;
//					cout<<"ERROR checkTripC2C_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): vioCAPCus["<<curC<<"]: wrong = "<<vioCAPCus[curC]<<"; correct = 0"<<endl;
//				}
//				if (FCAP[curC] != 0)
//				{
//					stop = 1;
//					cout<<"ERROR checkTripC2C_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): FvioCAPCus["<<curC<<"]: wrong = "<<FCAP[curC]<<"; correct = 0"<<endl;
//				}
//
//				/*if (FvioCAPCus[curC] != 0)
//				{
//					stop = 1;
//					cout<<"ERROR checkTripC2C_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): FvioCAPCus["<<curC<<"]: wrong = "<<FvioCAPCus[curC]<<"; correct = 0"<<endl;
//				}*/
//
//				if (BCAP[curC] != 0)
//				{
//					stop = 1;
//					cout<<"ERROR checkTripC2C_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): BvioCAPCus["<<curC<<"]: wrong = "<<BCAP[curC]<<"; correct = 0"<<endl;
//				}
//
//				/*if (BvioCAPCus[curC] != 0)
//				{
//					stop = 1;
//					cout<<"ERROR checkTripC2C_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): BvioCAPCus["<<curC<<"]: wrong = "<<BvioCAPCus[curC]<<"; correct = 0"<<endl;
//				}*/
//
//				if (PDSDIF(endS, startS[curC]))
//				{
//					stop = 1;
//					cout<<"ERROR checkTripC2C_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): startS["<<curC<<"]: wrong = "<<startS[curC]<<"; correct = "<<endS<<endl;
//				}
//				
//				endS += problem->node[curC].duration;
//				if (PDSDIF(endS, depart[curC]))
//				{
//					stop = 1;
//					cout<<"ERROR checkTripC2C_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): depart["<<curC<<"]: wrong = "<<depart[curC]<<"; correct = "<<endS<<endl;
//				}
//				preC = curC; curC = nextArr[curC];
//				if (curC > 0) endS = PDS_MAX(depart[preC] + problem->c[preC][curC], problem->node[curC].sTW);
//			}while (curC > 0);
//		}
//		else //idTrip = 0 && not (seg[idVeh].Trip[0].numCus == 2 && nextSP > 0):
//		{
//			endS = PDS_MAX(problem->c[0][curC], problem->node[curC].sTW);
//			cTemp = problem->c[0][curC];
//			CAPVehCus += problem->node[curC].capacity; 
//			//checkUsed[curC] = 1;
//			if (pos[curC] != 1)
//			{
//				stop = 1;
//				cout<<"ERROR checkTripC2C_ALLFIELDS("<<idVeh<<", "<<idTrip<<") pos["<<curC<<"]: correct = 1; wrong = "<<pos[curC]<<endl;
//			}
//			if (route_num[curC] != idVeh)
//			{
//				stop = 1;
//				cout<<"ERROR checkTripC2C_ALLFIELDS("<<idVeh<<", "<<idTrip<<") route_num["<<curC<<"]: correct = "<<idVeh<<"; wrong = "<<route_num[curC]<<endl;
//			}
//			if (trip_num[curC] != idTrip)
//			{
//				stop = 1;
//				cout<<"ERROR checkTripC2C_ALLFIELDS("<<idVeh<<", "<<idTrip<<") trip_num["<<curC<<"]: correct = "<<idTrip<<"; wrong = "<<trip_num[curC]<<endl;
//			}
//
//			if (PDSDIF(endS, startS[curC]))
//			{
//				stop = 1;
//				cout<<"ERROR checkTripC2C_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): startS["<<curC<<"]: wrong = "<<startS[curC]<<"; correct = "<<endS<<endl;
//			}
//			
//			if  (CAPCus[curC] != CAPVehCus)
//			{
//				stop = 1;
//				cout<<"ERROR checkTripC2C_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): CAPCus["<<curC<<"]: wrong = "<<CAPCus[curC]<<"; correct = "<<CAPVehCus<<endl;
//			}
//			if (vioCAPCus[curC] != 0)
//			{
//				stop = 1;
//				cout<<"ERROR checkTripC2C_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): vioCAPCus["<<curC<<"]: wrong = "<<vioCAPCus[curC]<<"; correct = 0"<<endl;
//			}
//			if (FCAP[curC] != 0)
//			{
//				stop = 1;
//				cout<<"ERROR checkTripC2C_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): FvioCAPCus["<<curC<<"]: wrong = "<<FCAP[curC]<<"; correct = 0"<<endl;
//			}
//
//			/*if (FvioCAPCus[curC] != 0)
//			{
//				stop = 1;
//				cout<<"ERROR checkTripC2C_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): FvioCAPCus["<<curC<<"]: wrong = "<<FvioCAPCus[curC]<<"; correct = 0"<<endl;
//			}*/
//			endS += problem->node[curC].duration;
//			if (PDSDIF(endS, depart[curC]))
//			{
//				stop = 1;
//				cout<<"ERROR checkTripC2C_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): depart["<<curC<<"]: wrong = "<<depart[curC]<<"; correct = "<<endS<<endl;
//			}
//
//			preC = curC; curC = nextArr[curC]; 
//			for (i=2;i<=seg[idVeh].Trip[idTrip].numCus;i++)
//			{
//					cTemp += problem->c[preC][curC];
//					endS += problem->c[preC][curC];
//					//vioTWCT = PDS_MAX(endS - problem->node[curC].eTW, 0);
//					vioTWCT = endS - problem->node[curC].eTW;	
//					if (vioTWCT > eps) FvioTWCT += vioTWCT;
//					else vioTWCT = 0;
//					
//					CAPVehCus += problem->node[curC].capacity;
//					vioCAPCT = PDS_MAX(CAPVehCus - Q, 0);
//					FvioCAPCT += vioCAPCT;
//					if (pos[curC] != i)
//					{
//						stop = 1;
//						cout<<"ERROR checkTripC2C_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): pos["<<curC<<"]: wrong = "<<pos[curC]<<"; correct = "<<i<<endl;
//					}
//					if (route_num[curC] != idVeh)
//					{
//						stop = 1;
//						cout<<"ERROR checkTripC2C_ALLFIELDS("<<idVeh<<", "<<idTrip<<") route_num["<<curC<<"]: correct = "<<idVeh<<"; wrong = "<<route_num[curC]<<endl;
//					}
//					if (trip_num[curC] != idTrip)
//					{
//						stop = 1;
//						cout<<"ERROR checkTripC2C_ALLFIELDS("<<idVeh<<", "<<idTrip<<") trip_num["<<curC<<"]: correct = "<<idTrip<<"; wrong = "<<trip_num[curC]<<endl;
//					}
//
//					if (PDSDIF(vioTWCT, vioTWCus[curC])) 
//					{
//						stop = 1;
//						cout<<"ERROR checkTripC2C_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): vioTWCus["<<curC<<"]: wrong = "<<vioTWCus[curC]<<"; correct = "<<vioTWCT<<endl;
//					}
//					if (PDSDIF(FvioTWCT, FvioTWCus[curC])) 
//					{
//						stop = 1;
//						cout<<"ERROR checkTripC2C_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): FvioTWCus["<<curC<<"]: wrong = "<<FvioTWCus[curC]<<"; correct = "<<FvioTWCT<<endl;
//					}			
//					if (vioTWCT > eps)
//						endS = problem->node[curC].eTW;
//					else endS = PDS_MAX(endS, problem->node[curC].sTW);
//
//					if (vioCAPCT != vioCAPCus[curC]) 
//					{
//						stop = 1;
//						cout<<"ERROR checkTripC2C_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): vioCAPCus["<<curC<<"]: wrong = "<<vioCAPCus[curC]<<"; correct = "<<vioCAPCT<<endl;
//					}
//					if (FvioCAPCT != FCAP[curC]) 
//					{
//						stop = 1;
//						cout<<"ERROR checkTripC2C_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): FvioCAPCus["<<curC<<"]: wrong = "<<FCAP[curC]<<"; correct = "<<FvioCAPCT<<endl;
//					}			
//					/*if (FvioCAPCT != FvioCAPCus[curC]) 
//					{
//						stop = 1;
//						cout<<"ERROR checkTripC2C_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): FvioCAPCus["<<curC<<"]: wrong = "<<FvioCAPCus[curC]<<"; correct = "<<FvioCAPCT<<endl;
//					}*/			
//
//					if (vioCAPCT > 0) CAPVehCus = Q;
//
//					if (CAPVehCus != CAPCus[curC])
//					{
//						stop = 1;
//						cout<<"ERROR checkTripC2C_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): CAPCus["<<curC<<"]: wrong = "<<CAPCus[curC]<<"; correct = "<<CAPVehCus<<endl;
//					}
//
//					if (PDSDIF(endS, startS[curC]))
//					{
//						stop = 1;
//						cout<<"ERROR checkTripC2C_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): startS["<<curC<<"]: wrong = "<<startS[curC]<<"; correct = "<<endS<<endl;
//					}
//					
//					endS += problem->node[curC].duration;
//					if (PDSDIF(endS, depart[curC]))
//					{
//						stop = 1;
//						cout<<"ERROR checkTripC2C_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): depart["<<curC<<"]: wrong = "<<depart[curC]<<"; correct = "<<endS<<endl;
//					}
//					preC = curC; curC = nextArr[curC];
//			}
//		}//end idTrip = 0 && not (seg[idVeh].Trip[0].numCus == 2 && nextSP > 0):
//	}
//	else //idTrip > 0
//	{
//		int preT = idTrip - 1; double endSBUON;
//		if (seg[idVeh].Trip[preT].Type == 0)
//		{
//			preC = seg[idVeh].Trip[preT].assSP;
//			endS = seg[idVeh].Trip[preT].leaveSP;
//		}
//		else
//		{
//			preC = seg[idVeh].Trip[preT].lastCus;
//			endS = depart[preC]; 
//		}
//		endSBUON = endS; int preCBUON = preC;
//		cTemp =-problem->c[preC][curC];
//		//FvioTWCT = 0; FvioCAPCT = 0;
//		CAPVehCus = 0; 
//		for (i=1;i<=seg[idVeh].Trip[idTrip].numCus;i++)
//		{
//				cTemp += problem->c[preC][curC];
//				endS += problem->c[preC][curC];
//				
//				vioTWCT = PDS_MAX(endS - problem->node[curC].eTW, 0);
//				vioTWCT = endS - problem->node[curC].eTW;
//				if (vioTWCT > eps) FvioTWCT += vioTWCT;
//				else vioTWCT = 0;
//				CAPVehCus += problem->node[curC].capacity;
//				vioCAPCT = PDS_MAX(CAPVehCus - Q, 0);
//				FvioCAPCT += vioCAPCT;
//
//				if  (pos[curC] != i)
//				{
//					stop = 1;
//					cout<<"ERROR checkTripC2C_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): pos["<<curC<<"]: wrong = "<<pos[curC]<<"; correct = "<<i<<endl;
//				}
//				if (route_num[curC] != idVeh)
//				{
//					stop = 1;
//					cout<<"ERROR checkTripC2C_ALLFIELDS("<<idVeh<<", "<<idTrip<<") route_num["<<curC<<"]: correct = "<<idVeh<<"; wrong = "<<route_num[curC]<<endl;
//				}
//				if (trip_num[curC] != idTrip)
//				{
//					stop = 1;
//					cout<<"ERROR checkTripC2C_ALLFIELDS("<<idVeh<<", "<<idTrip<<") trip_num["<<curC<<"]: correct = "<<idTrip<<"; wrong = "<<trip_num[curC]<<endl;
//				}
//
//				if (PDSDIF(vioTWCT, vioTWCus[curC])) 
//				{
//					stop = 1;
//					cout<<"ERROR checkTripC2C_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): vioTWCus["<<curC<<"]: wrong = "<<vioTWCus[curC]<<"; correct = "<<vioTWCT<<endl;
//				}
//				if (PDSDIF(FvioTWCT, FvioTWCus[curC])) 
//				{
//					stop = 1;
//					cout<<"ERROR checkTripC2C_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): FvioTWCus["<<curC<<"]: wrong = "<<FvioTWCus[curC]<<"; correct = "<<FvioTWCT<<endl;
//				    int buonlam = seg[idVeh].Trip[idTrip].firstCus;
//					double cutlam = 0;
//					cout<<"VIOTWCUS: ";
//					for (int cut=1;cut<=seg[idVeh].Trip[idTrip].numCus;cut++)
//					{
//						cutlam += vioTWCus[buonlam];
//						cout<<buonlam<<"("<<vioTWCus[buonlam]<<", "<<cutlam<<"), ";
//						buonlam = nextArr[buonlam];
//					}
//					cout<<endl;
//					cout<<"DERETOUR CAL: ";
//					int curCBUON = seg[idVeh].Trip[idTrip].firstCus;
//					double FvioTWCTBUON = 0;
//					for (int cut = 1; cut <=i; cut++)
//					{
//						endSBUON += problem->c[preCBUON][curCBUON];
//						//vioTWCT = PDS_MAX(endSBUON - problem->node[curCBUON].eTW, 0);
//						vioTWCT = endSBUON - problem->node[curCBUON].eTW;
//						if (vioTWCT > eps) FvioTWCTBUON += vioTWCT;
//						else vioTWCT = 0;
//						cout<<curCBUON<<"("<<vioTWCT<<", "<<FvioTWCTBUON<<"), ";
//						if (vioTWCT > eps)	endSBUON = problem->node[curCBUON].eTW;
//						else endSBUON = PDS_MAX(endSBUON, problem->node[curCBUON].sTW);
//						endSBUON += problem->node[curCBUON].duration;
//						preCBUON = curCBUON; curCBUON = nextArr[curCBUON];
//					}
//					cout<<endl;
//				}			
//				if (vioTWCT > eps)
//					endS = problem->node[curC].eTW;
//				else endS = PDS_MAX(endS, problem->node[curC].sTW);
//
//
//				if (vioCAPCT != vioCAPCus[curC]) 
//				{
//					stop = 1;
//					cout<<"ERROR checkTripC2C_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): vioCAPCus["<<curC<<"]: wrong = "<<vioCAPCus[curC]<<"; correct = "<<vioCAPCT<<endl;
//				}
//
//				if (FvioCAPCT != FCAP[curC]) 
//				{
//					stop = 1;
//					cout<<"ERROR checkTripC2C_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): FvioCAPCus["<<curC<<"]: wrong = "<<FCAP[curC]<<"; correct = "<<FvioCAPCT<<endl;
//				}
//				/*if (FvioCAPCT != FvioCAPCus[curC]) 
//				{
//					stop = 1;
//					cout<<"ERROR checkTripC2C_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): FvioCAPCus["<<curC<<"]: wrong = "<<FvioCAPCus[curC]<<"; correct = "<<FvioCAPCT<<endl;
//				}*/
//
//				if (vioCAPCT > 0) CAPVehCus = Q;
//
//				if (CAPVehCus != CAPCus[curC])
//				{
//					stop = 1;
//					cout<<"ERROR checkTripC2C_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): CAPCus["<<curC<<"]: wrong = "<<CAPCus[curC]<<"; correct = "<<CAPVehCus<<endl;
//				}
//
//				if (PDSDIF(endS, startS[curC]))
//				{
//					stop = 1;
//					cout<<"ERROR checkTripC2C_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): startS["<<curC<<"]: wrong = "<<startS[curC]<<"; correct = "<<endS<<endl;
//				}
//				
//				endS += problem->node[curC].duration;
//				if (PDSDIF(endS, depart[curC]))
//				{
//					stop = 1;
//					cout<<"ERROR checkTripC2C_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): depart["<<curC<<"]: wrong = "<<depart[curC]<<"; correct = "<<endS<<endl;
//				}
//				preC = curC; curC = nextArr[curC];
//		}
//
//	}//end idTrip > 0
//
//	if (PDSDIF(seg[idVeh].Trip[idTrip].vioTWC, FvioTWCT))
//	{
//		cout<<"ERROR checkTripC2C_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): vioTWC: wrong = "<<seg[idVeh].Trip[idTrip].vioTWC<<"; correct = "<<FvioTWCT<<endl;
//        showTripCusvioTW_C2C(idVeh,idTrip);
//		double buc = 0;
//		int chan = seg[idVeh].Trip[idTrip].firstCus;
//		while (chan > 0)
//		{
//			buc += vioTWCus[chan];
//			chan = nextArr[chan];
//		}
//		cout<<"Sum of field vioTWCus = "<<buc<<"; seg.Trip.vioTWC = "<<seg[idVeh].Trip[idTrip].vioTWC<<"; FvioTWCT = "<<FvioTWCT<<"; FvioTWC[lastC] = "<<FvioTWCus[seg[idVeh].Trip[idTrip].lastCus]<<endl; 
//		stop = 1;
//	}
//	if (seg[idVeh].Trip[idTrip].lastCus != preC)
//	{
//		stop = 1;
//		cout<<"ERROR checkTripC2C_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): lastCus: wrong = "<<seg[idVeh].Trip[idTrip].lastCus<<"; correct = "<<preC<<endl;
//	}
//
//	if (IsLIFO(idVeh,idTrip) == 0)
//	{
//		stop = 1;
//		cout<<"ERROR checkTripC2C_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): doesn't satisfy LIFO"<<endl;
//	}
//
//
//		if (PDSDIF(seg[idVeh].Trip[idTrip].endS, endS)==0)
//		{
//			int nextT = idTrip + 1; int nextSP = seg[idVeh].Trip[idTrip].nextSP;
//			if (nextT < seg[idVeh].numTrips)
//			{
//				if (seg[idVeh].Trip[nextT].Type == 1)
//				{
//					int assSP= seg[idVeh].Trip[nextT].assSP;
//					if (nextSP != assSP)
//					{
//						cout<<"ERROR checkTripC2C_checkSolution("<<idVeh<<", "<<idTrip<<"): (nextTrip is delivery trip);correct nextSP = "<<assSP<<"; but field nextSP = "<<nextSP<<endl;
//						stop = 1;
//					}
//
//					cArrTime = endS + problem->c[preC][assSP];
//					double connectTemp;
//					if (PDSINRANGE(cArrTime, problem->nodeSP[assSP].sTW2, problem->nodeSP[assSP].eTW2))
//					{
//						connectTemp = problem->c[preC][assSP];
//						//cTemp += problem->c[preC][assSP];
//						if (seg[idVeh].Trip[idTrip].waitingS != NO_WS)
//						{
//							cout<<"ERROR checkTripC2C_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): correct waitingS = NO_WS; but field waitingS = "<<seg[idVeh].Trip[idTrip].waitingS<<endl;
//							stop = 1;
//						}
//						endS = cArrTime;// + problem->nodeSP[assSP].load;
//						if (PDSDIF(endS,seg[idVeh].Trip[idTrip].arriveSP))
//						{
//							cout<<"ERROR checkTripC2C_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): correct arrTime = "<<endS<<"; but field arriveSP = "<<seg[idVeh].Trip[idTrip].arriveSP<<endl;
//							cout<<"CASE C2C - SP - D: directly"<<endl;
//							stop = 1;
//						}
//					}
//					else
//					{
//						temp = cArrTime - problem->nodeSP[assSP].eTW2;
//						if (temp > eps)
//						{
//							if (seg[idVeh].Trip[idTrip].waitingS != NO_WS)
//							{
//								cout<<"ERROR checkTripC2C_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): correct waitingS = NO_WS; wrong = "<<seg[idVeh].Trip[idTrip].waitingS<<endl;
//								stop = 1;
//							}
//							connectTemp = problem->c[preC][assSP];
//							//cTemp += problem->c[preC][assSP];
//							endS = problem->nodeSP[assSP].eTW2; //problem->leaveSP[assSP][1]; //load at eTW2
//							if (PDSDIF(endS,seg[idVeh].Trip[idTrip].arriveSP))
//							{
//								cout<<"ERROR checkTripC2C_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): correct arrTime = "<<endS<<"; but field arriveSP = "<<seg[idVeh].Trip[idTrip].arriveSP<<endl;
//								cout<<"CASE C2C - SP - D: vioTWSP: too late to go to sp directly"<<endl;
//								stop = 1;
//							}
//
//						}
//						else
//						{
//							double cArrTimeI = endS + problem->disCWSSP[preC][assSP];
//							temp = cArrTimeI - problem->nodeSP[assSP].eTW2;
//							if (temp > eps)
//							{
//								temp = problem->nodeSP[assSP].sTW2 - cArrTime;
//								if (PDSDIF(temp, seg[idVeh].Trip[nextT].vioTWSP))
//								{
//									cout<<"ERROR checkTripC2C_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): correct vioTWSP = "<<temp<<"; but field vioTWSP of nextDTrip = "<<seg[idVeh].Trip[nextT].vioTWSP<<endl;
//									cout<<"CASE too soon to go sp directly, too late to go through WS; eTW2 of sp "<<assSP<<"; eTW2 = "<<problem->nodeSP[assSP].eTW2<<"; cArrTimeDirect = "<<cArrTime<<"; cArrTimeIndirect = "<<cArrTimeI<<endl;
//									stop = 1;
//								}
//								if (seg[idVeh].Trip[idTrip].waitingS != NO_WS)
//								{
//									cout<<"ERROR checkTripC2C_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): correct waitingS = NO_WS; wrong = "<<seg[idVeh].Trip[idTrip].waitingS<<endl;
//									cout<<"CASE too soon to go sp directly, too late to go through WS; eTW2 of sp "<<assSP<<"; eTW2 = "<<problem->nodeSP[assSP].eTW2<<"; cArrTimeDirect = "<<cArrTime<<"; cArrTimeIndirect = "<<cArrTimeI<<endl;
//									stop = 1;
//								}
//								endS = problem->nodeSP[assSP].eTW2; //problem->leaveSP[assSP][1]; //load at eTW2
//								//cTemp += problem->c[preC][assSP];
//								connectTemp = problem->c[preC][assSP];
//								if (PDSDIF(endS,seg[idVeh].Trip[idTrip].arriveSP))
//								{
//									cout<<"ERROR checkTripC2C_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): correct arrTime = "<<endS<<"; but field arriveSP = "<<seg[idVeh].Trip[idTrip].arriveSP<<endl;
//									cout<<"CASE C2C - SP - D: too late through WS, too soon to sp directly"<<endl;
//									stop = 1;
//								}
//
//							}
//							else
//							{
//								//cTemp += problem->disCWSSP[preC][assSP];
//								connectTemp = problem->disCWSSP[preC][assSP];
//								if (seg[idVeh].Trip[idTrip].waitingS != problem->CWSSP[preC][assSP])
//								{
//									cout<<"ERROR checkTripC2C_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): correct waitingS = "<<problem->CWSSP[preC][assSP]<<"; wrong = "<<seg[idVeh].Trip[idTrip].waitingS<<endl;
//									cout<<"LastCus of trip = "<<preC<<" !=? "<<seg[idVeh].Trip[idTrip].lastCus<<endl;
//									cout<<"CASE to go through WS"<<endl;
//									stop = 1;
//								}
//								if (seg[idVeh].Trip[nextT].vioTWSP > eps)
//								{
//									cout<<"ERROR checkTripC2C_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): correct vioTWSP = 0; but field vioTWSP of DnextTrip = "<<seg[idVeh].Trip[nextT].vioTWSP<<endl;
//									cout<<"CASE to go through WS"<<endl;
//									stop = 1;
//								}
//								endS = PDS_MAX(cArrTimeI, problem->nodeSP[assSP].sTW2);// + problem->nodeSP[assSP].load;
//								if (PDSDIF(endS,seg[idVeh].Trip[idTrip].arriveSP))
//								{
//									cout<<"ERROR checkTripC2C_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): correct arrTime = "<<endS<<"; but field arriveSP = "<<seg[idVeh].Trip[idTrip].arriveSP<<endl;
//									cout<<"CASE C2C - SP - D: through WS"<<endl;
//									stop = 1;
//								}
//							}
//						}
//					}
//					
//					if (stop == 0)
//					{
//						double costT = seg[idVeh].Trip[idTrip].cost - seg[idVeh].Trip[idTrip].connectCost;
//						if (PDSDIF(cTemp, costT))
//						{
//							cout<<"ERROR checkTripC2C_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): cost (between cusC2C, exclude connectCost): correct = "<<cTemp<<"; wrong = "<<costT<<endl;
//							stop = 1;
//						}
//						if (PDSDIF(endS,seg[idVeh].Trip[idTrip].arriveSP))
//						{
//							cout<<"ERROR checkTripC2C_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): arriveSP correct = "<<endS<<"; but field arriveSP = "<<seg[idVeh].Trip[idTrip].arriveSP<<endl;
//							stop = 1;
//						}
//						if (PDSDIF(connectTemp, seg[idVeh].Trip[idTrip].connectCost))
//						{
//							cout<<"ERROR checkTripC2C_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): connectCost correct = "<<connectTemp<<"; but field connectCost = "<<seg[idVeh].Trip[idTrip].connectCost<<endl;
//							cout<<"Case C2C-DTrip"<<endl;
//							stop = 1;
//						}
//						cTemp += connectTemp;						
//						if (PDSDIF(cTemp, seg[idVeh].Trip[idTrip].cost))
//						{
//							cout<<"ERROR checkTripC2C_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): cost correct = "<<cTemp<<"; but field Cost = "<<seg[idVeh].Trip[idTrip].cost<<endl;
//							cout<<"Case C2C-DTrip"<<endl;
//							stop = 1;
//						}
//					}//end if (correct)
//				}
//				else //C2C-(p-SP)
//				{
//					if (nextSP >= 0)
//					{
//						cout<<"ERROR checkTripC2C_checkSolution("<<idVeh<<", "<<idTrip<<"): nextTrip is pickup trip; but field nextSP = "<<nextSP<<endl;
//						stop = 1;
//					}
//
//					int firstC_nextT = seg[idVeh].Trip[nextT].firstCus;
//					if (PDSDIF(problem->c[preC][firstC_nextT],seg[idVeh].Trip[idTrip].connectCost))
//					{
//					    cout<<"ERROR checkTripC2C_ALLFIELDS("<<idVeh<<", "<<idTrip<<"):ConnectCost correct = "<<problem->c[preC][firstC_nextT]<<"; wrong = "<<seg[idVeh].Trip[idTrip].connectCost<<endl;
//						cout<<"CASE: C2C - p"<<endl;
//						stop = 1;
//					}
//					cTemp += problem->c[preC][firstC_nextT];
//					if (PDSDIF(cTemp, seg[idVeh].Trip[idTrip].cost))
//					{
//						cout<<"ERROR checkTripC2C_ALLFIELDS("<<idVeh<<", "<<idTrip<<"):cost correct = "<<cTemp<<"; wrong = "<<seg[idVeh].Trip[idTrip].cost<<endl;
//						stop = 1;
//					}
//				}//end C2C-(p-SP)
//			}
//			else //last C2C trip
//			{
//				if (nextSP != 0)
//				{
//					cout<<"ERROR checkTripC2C_checkSolution("<<idVeh<<", "<<idTrip<<"): last C2Ctrip; but field nextSP = "<<nextSP<<"; (correct one should = 0)"<<endl;
//					stop = 1;
//				}
//
//				if (PDSDIF(problem->c[preC][0], seg[idVeh].Trip[idTrip].connectCost))
//				{
//					cout<<"ERROR checkTripC2C_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): Connectcost: correct = "<<problem->c[preC][0]<<"; wrong = "<<seg[idVeh].Trip[idTrip].connectCost<<endl;
//					cout<<"CASE: last C2C trip"<<endl;
//					stop = 1;
//				}
//				cTemp += problem->c[preC][0];
//				if (PDSDIF(cTemp, seg[idVeh].Trip[idTrip].cost))
//				{
//					cout<<"ERROR checkTripC2C_ALLFIELDS("<<idVeh<<", "<<idTrip<<"):cost correct = "<<cTemp<<"; wrong = "<<seg[idVeh].Trip[idTrip].cost<<endl;
//					cout<<"CASE: last C2C trip"<<endl;
//					stop = 1;
//				}
//			}//end last C2C trip
//		}
//		else 
//		{
//			cout<<"ERROR checkTripC2C_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): endS : correct = "<<endS<<"; wrong = "<<seg[idVeh].Trip[idTrip].endS<<endl;
//			stop = 1;
//		}
//
//		//Checking BCAP, BvioTWCus, BvioCAPCus:
//		curC = seg[idVeh].Trip[idTrip].lastCus; double BvioTWCusT = 0; int BvioCAPCusT = 0;
//		do
//		{
//			BvioTWCusT += vioTWCus[curC];
//			BvioCAPCusT += vioCAPCus[curC];
//			if  (BvioCAPCusT != BCAP[curC])
//			{
//				stop = 1;
//				cout<<"ERROR checkTripC2C_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): BvioCAPCus["<<curC<<"]: wrong = "<<BCAP[curC]<<"; correct = "<<BvioCAPCusT<<endl;
//			}
//			/*if  (BvioCAPCusT != BvioCAPCus[curC])
//			{
//				stop = 1;
//				cout<<"ERROR checkTripC2C_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): BvioCAPCus["<<curC<<"]: wrong = "<<BvioCAPCus[curC]<<"; correct = "<<BvioCAPCusT<<endl;
//			}*/
//
//			if  (PDSDIF(BvioTWCusT, BvioTWCus[curC]))
//			{
//				stop = 1;
//				cout<<"ERROR checkTripC2C_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): BvioTWCus["<<curC<<"]: wrong = "<<BvioTWCus[curC]<<"; correct = "<<BvioTWCusT<<endl;
//			}
//			curC = predArr[curC];
//		}while (curC > 0);
//	
//		if (IsLIFO(idVeh,idTrip) == 0) stop = 1;
//		if (stop) 
//		{
//			cout<<"TRIP C2C ERROR: "; 
//			showTripCost(idVeh, idTrip);
//			cout<<"------------------------------- VEHICLE "<<idVeh<<" ---------------------------"<<endl;
//			showSegment(idVeh);
//		}
//		return stop;
//		//if (correct == 0) exit(-1);
//}
//
//bool Solution::IsLIFO(int idVeh, int idTrip)
//{
//    int Pickup[200];
//	int pointP = -1; 
//	int curC = seg[idVeh].Trip[idTrip].firstCus;
//	int idP;
//	while (curC > 0)
//	{
//		if (curC >= startidC2C && curC <= endidC2CP)
//		{
//			pointP ++; Pickup[pointP] = curC;
//		}
//		else //curC is delivery
//		{
//			idP = problem->node[curC].pickID;
//			if (pointP >= 0)
//			{
//				if (Pickup[pointP] == idP) pointP--;
//				else
//				{
//					cout<<"ERROR IsLIFO of trip("<<idVeh<<", "<<idTrip<<"): at delivery customer "<<curC<<"; it has to be del cus "<<problem->node[Pickup[pointP]].delID<<" of pickupcustomer "<<Pickup[pointP]<<endl;
//				    return 0;
//				}
//			}
//			else 
//			{
//				cout<<"ERROR: ERROR at delivery cus "<<curC<<": vehicle is empty now --> can't delivery"<<endl;
//				return 0;
//			}
//		}
//		curC = nextArr[curC];
//	}
//	return 1;
//}
//
//bool Solution::checkVehicle(int idVeh)
//{
//	int i;
//	bool stop = 0;
//	for (i=0; i<seg[idVeh].numTrips;i++)
//	{
//		if (seg[idVeh].Trip[i].Type == 1)
//		{
//			if (checkTripD_ALLFIELDS(idVeh, i)) stop = 1;
//		}
//		else if (seg[idVeh].Trip[i].Type == 0)
//		{
//			if (checkTripP_ALLFIELDS(idVeh, i)) stop = 1;
//		}
//		else //if (seg[idVeh].Trip[i].Type == 2)
//		{
//			if (checkTripC2C_ALLFIELDS(idVeh, i)) stop = 1;
//		}
//	}
//	return stop;
//}
/******************************************************* CONSTRUCTOR *****************************************/
//**************************************************end INIT SOL 26/11/2013 **********************************************/


//Problem* Solution::problem=0 ;

//Solution::Solution()
//{
//
//}

//void Solution::init(Problem *p)
//{
//	// ok on 4/12/2013
//  problem = p;
//  nP=problem->nP; nD=problem->nD; nSP = problem->nSP; nWS = problem->nWS;
//  nC2C = problem->nC2C; nOrder = problem->nOrder;
//  nextArr = new int [totalNODE1]; predArr = new int [totalNODE1];
//  pos = new int [totalNODE1]; 
//  route_num = new int [totalNODE1]; trip_num = new int[totalNODE1];
//  BCAP = new int[totalNODE1]; FCAP = new int [totalNODE1];
//  vioTWCus = new double [totalNODE1]; 
//  FvioTWCus = new double [totalNODE1];
//  BvioTWCus = new double [totalNODE1];
//  startS = new double [totalNODE1]; depart = new double [totalNODE1];
//
//  for (int i=0; i < totalNODE1; i++) 
//  {
//	  nextArr[i] = 0;
//	  predArr[i] = 0;
//	  pos[i] = -1;
//	  route_num[i] = -1; trip_num[i] = -1;
//
//	  FCAP[i]=0; BCAP[i]=0; 
//	  vioTWCus[i] = 0; FvioTWCus[i]=0; BvioTWCus[i] = 0;
//	  startS[i] = 0; depart[i] = 0;
//  }
//  
//  //numTripPSP = new int[nSP1]; 
//  numTripDSP = new int[nSP1];
//  
//  int endIDC2C1 = endidC2C+1;
//  vioCAPCus = new int[endIDC2C1];
//  //FvioCAPCus = new int[endIDC2C1];BvioCAPCus = new int[endIDC2C1];
//  CAPCus = new int[endIDC2C1];
//
//  for (int i = startidC2C; i <= endidC2C; i++)
//  {
//	  vioCAPCus[i] = 0;
//	  //FvioCAPCus[i] = 0;BvioCAPCus[i] = 0;
//	  CAPCus[i] = 0;
//  }
//  //seg = new VRPSegment[MAX_VEH];
//  //seg = new VRPSegment[problem->maxVeh+1];
//  numVeh=0; numVehUsed=0;
//  cost = 0.0; fitness = 0.0;
//  vioCAP=0; vioTWC=0; vioTWSP=0; feasible=1;
//  numTrips=0;
//}



//Solution::Solution(Problem* p)
//{
//	//ok on 4/12/2013
//  problem = p;
//  nP=problem->nP; nD=problem->nD; nSP = problem->nSP; nWS = problem->nWS;
//  nC2C = problem->nC2C; nOrder = problem->nOrder;
//  //cout<<"totalNODE1 = "<<totalNODE1<<endl;
//  nextArr = new int [totalNODE1]; predArr = new int [totalNODE1];
//  pos = new int [totalNODE1]; 
//
//  route_num = new int [totalNODE1]; trip_num = new int[totalNODE1];
//  BCAP = new int[totalNODE1]; FCAP = new int [totalNODE1];
//  FvioTWCus = new double [totalNODE1];
//  BvioTWCus = new double [totalNODE1];
//  vioTWCus = new double [totalNODE1]; 
//  startS = new double [totalNODE1]; 
//  depart = new double [totalNODE1];
//  
//  for (int i=0; i < totalNODE1; i++) 
//  {
//	  nextArr[i] = -1; predArr[i] = -1; pos[i] = -1;
//	  route_num[i] = -1; trip_num[i] = -1;
//	  FCAP[i]=0; BCAP[i]=0; 
//	  vioTWCus[i] = 0; FvioTWCus[i]=0; BvioTWCus[i] = 0;
//	  startS[i] = 0; depart[i] = 0;
//  }
//  
//
//  //numTripPSP = new int[nSP1]; 
//  
//  numTripDSP = new int[nSP1];
//  for (int i=0; i<nSP1; i++) 
//	  numTripDSP[i]=0;
//
//  int endIDC2C1 = endidC2C+1;
//  vioCAPCus = new int[endIDC2C1];
//  //FvioCAPCus = new int[endIDC2C1];BvioCAPCus = new int[endIDC2C1];
//  CAPCus = new int[endIDC2C1];
//
//  for (int i = startidC2C; i <= endidC2C; i++)
//  {
//	  vioCAPCus[i] = 0;
//	  //FvioCAPCus[i] = 0;BvioCAPCus[i] = 0;
//	  CAPCus[i] = 0;
//  }
//
//  //seg = new VRPSegment[MAX_VEH];
//  //seg = new VRPSegment[problem->maxVeh+1];
//  numVeh=0; numVehUsed=0;
//  cost = 0.0; fitness = 0.0;
//  vioCAP=0; vioTWC=0; vioTWSP=0; feasible=1;
//  numTrips=0;
//}

//void Solution::calReport()
//{
//	int i,j;
//	int cTrips = 0;
//	int DM = 0; int IDM = 0; int PD = 0; int DP = 0; 
//	int DD = 0; int PD1 = 0; int PP = 0;
//	for (i=0; i<numVeh;i++)
//		if (seg[i].numTrips > 0)
//		{
//			cTrips += seg[i].numTrips;
//			if (seg[i].numTrips == 1)
//			{
//				if (seg[i].Trip[0].Type == 0)
//				{
//					if (seg[i].Trip[0].waitingS == NO_WS) DM++;
//					else IDM ++;
//				}
//			}
//			else //has > 1 trips
//			{
//				j = 0; int j1; int lastT = seg[i].numTrips - 1;
//				while (j < lastT)
//				{
//					j1 = j + 1;
//					if (seg[i].Trip[j].Type == 1)
//					{
//						if (seg[i].Trip[j1].Type == 1)
//						{
//							if (seg[i].Trip[j].waitingS == NO_WS) DM ++;
//							else IDM ++;
//							DD++;
//						}
//						else DP ++;
//					}
//					else if (seg[i].Trip[j].Type == 0) //(i,j) is pickup
//					{
//						if (seg[i].Trip[j].waitingS == NO_WS) DM++;
//						else IDM ++;
//						if (seg[i].Trip[j1].Type == 1)
//						{
//							if (seg[i].Trip[j1].coordinate) PD ++;
//							else
//							{
//								if (seg[i].Trip[j].waitingS1 == NO_WS) DM ++;
//								else IDM ++;
//								PD1++;
//							}
//						}
//						else if (seg[i].Trip[j1].Type == 0) //(i,j1) is pickup where (i,j) is pickup
//						{
//							PP ++;
//						}
//					}
//					j = j1;
//				}
//				if (seg[i].Trip[j].Type == 0)
//					if (seg[i].Trip[j].waitingS == NO_WS) DM ++;
//					else IDM ++;
//			}//end has > 1 trips
//		}
//		cout<<cTrips<<endl;
//		cout<<DM<<endl;
//		cout<<IDM<<endl;
//		cout<<PD<<endl;
//		cout<<DP<<endl;
//		cout<<DD<<endl;
//		cout<<PP<<endl;
//		cout<<PD1<<endl;
//}
//
//
//Solution::Solution(Solution &orig)//copy constructor
//{
//	//ok on 4/12/2013
//  cout<<"call copy constructor"<<endl;
//  exit(-1);
// (*this).nP = orig.nP;(*this).nD = orig.nD;(*this).nSP = orig.nSP;(*this).nWS = orig.nWS;
// (*this).nC2C = orig.nC2C; (*this).nOrder = orig.nOrder;
//
// (*this).cost = orig.cost; (*this).fitness =  orig.fitness;
//
//  nextArr = new int [totalNODE1];predArr = new int [totalNODE1];
//  
//  route_num = new int [totalNODE1];trip_num = new int[totalNODE1]; 
//  
//  routed = new bool[totalNODE1];
//  BCAP = new int[totalNODE1]; FCAP = new int [totalNODE1];
// 
//  startS = new double[totalNODE1]; depart = new double[totalNODE1];
//  vioTWCus = new double [totalNODE1];  FvioTWCus = new double [totalNODE1]; BvioTWCus = new double [totalNODE1];
//
//  int endIDC2C1 = endidC2C + 1;
//  vioCAPCus = new int[endIDC2C1]; //FvioCAPCus = new int[endIDC2C1]; BvioCAPCus = new int[endIDC2C1]; 
//  CAPCus = new int[endIDC2C1];
//
//  numTripDSP = new int[nSP1];
//
//
//  for (int i=0; i<=nSP; i++)
//  {
//	  //numTripPSP[i] = orig.numTripPSP[i];
//	  numTripDSP[i] = orig.numTripDSP[i];
//  }
//  numCusC2CRouted = orig.numCusC2CRouted;
//
//  //seg = new VRPSegment[MAX_VEH];
//  numVeh=orig.numVeh;
//  numVehUsed = orig.numVehUsed;
//  numTrips = orig.numTrips;
//  for (int i=0; i<numVeh; i++) (*this).seg[i] = orig.seg[i];
//  (*this).vioCAP= orig.vioCAP; (*this).vioTWC= orig.vioTWC; (*this).vioTWSP = orig.vioTWSP;
//
//
//    for (int i= startidC2C; i <= endidC2C; i++)
//    {
//	    (*this).nextArr[i] = orig.nextArr[i];
//	    (*this).predArr[i] = orig.predArr[i];
//	    (*this).route_num[i] = orig.route_num[i];
//	    (*this).trip_num[i] = orig.trip_num[i];
//
//	    (*this).FCAP[i] = orig.FCAP[i]; (*this).BCAP[i] = orig.BCAP[i];
//	    (*this).pos[i] = orig.pos[i];
//	    (*this).startS[i] = orig.startS[i]; (*this).depart[i] = orig.depart[i];
//		(*this).vioTWCus[i] = orig.vioTWCus[i];
//		(*this).FvioTWCus[i] = orig.FvioTWCus[i];
//		(*this).BvioTWCus[i] = orig.BvioTWCus[i];
//		(*this).vioCAPCus[i] = orig.vioCAPCus[i];
//		//(*this).FvioCAPCus[i] = orig.FvioCAPCus[i];
//		//(*this).BvioCAPCus[i] = orig.BvioCAPCus[i];
//		(*this).CAPCus[i] = orig.CAPCus[i];
//	}
//
//	  for (int i=startidP; i <= endidD; i++)
//	  {
//		  (*this).nextArr[i] = orig.nextArr[i];
//		  (*this).predArr[i] = orig.predArr[i];
//		  (*this).route_num[i] = orig.route_num[i];
//		  (*this).trip_num[i] = orig.trip_num[i];
//
//		  (*this).FCAP[i] = orig.FCAP[i]; (*this).BCAP[i] = orig.BCAP[i];
//		  (*this).pos[i] = orig.pos[i];
//		  (*this).startS[i] = orig.startS[i];
//		  (*this).depart[i] = orig.depart[i];
//		  (*this).vioTWCus[i] = orig.vioTWCus[i];
//		  (*this).FvioTWCus[i] = orig.FvioTWCus[i];
//		  (*this).BvioTWCus[i] = orig.BvioTWCus[i];
//	  }
//}


//Solution & Solution::operator = (Solution &orig) //assignment; not copy constructor
//{
//	//ok on 4/12/2013
//    cout<<"Call assignment"<<endl; 
//	if (this == &orig) return *this; 
//    (*this).nP = orig.nP; (*this).nD = orig.nD;(*this).nSP = orig.nSP;(*this).nWS = orig.nWS;
//	(*this).nOrder = orig.nOrder; (*this).nC2C = orig.nC2C;
//    (*this).cost=orig.cost; (*this).fitness=orig.fitness;
//    (*this).vioCAP= orig.vioCAP; (*this).vioTWC= orig.vioTWC; (*this).vioTWSP = orig.vioTWSP;
//
//
//	for (int i=0; i<=nSP; i++)
//    {
//	    //numTripPSP[i] = orig.numTripPSP[i];
//	    numTripDSP[i] = orig.numTripDSP[i];
//    }
//	(*this).numCusC2CRouted = orig.numCusC2CRouted;
//
//	(*this).numVeh=orig.numVeh;
//    (*this).numVehUsed=orig.numVehUsed;
//	(*this).numTrips = orig.numTrips;
//
//    for (int i=0; i<numVeh; i++) (*this).seg[i] = orig.seg[i];
//  
//    for (int i= startidC2C; i<= endidC2C; i++)
//    {
//	    (*this).nextArr[i] = orig.nextArr[i];
//	    (*this).predArr[i] = orig.predArr[i];
//	    (*this).route_num[i] = orig.route_num[i];
//	    (*this).trip_num[i] = orig.trip_num[i];
//
//	    (*this).FCAP[i] = orig.FCAP[i]; (*this).BCAP[i] = orig.BCAP[i];
//	    (*this).pos[i] = orig.pos[i];
//	    (*this).startS[i] = orig.startS[i]; (*this).depart[i] = orig.depart[i];
//		(*this).vioTWCus[i] = orig.vioTWCus[i];
//		(*this).FvioTWCus[i] = orig.FvioTWCus[i];
//		(*this).BvioTWCus[i] = orig.BvioTWCus[i];
//		(*this).vioCAPCus[i] = orig.vioCAPCus[i];
//		//(*this).FvioCAPCus[i] = orig.FvioCAPCus[i];
//		//(*this).BvioCAPCus[i] = orig.BvioCAPCus[i];
//		(*this).CAPCus[i] = orig.CAPCus[i];
//	}
//
//
//    for (int i= startidP; i <= endidD; i++)
//    {
//	    (*this).nextArr[i] = orig.nextArr[i];
//	    (*this).predArr[i] = orig.predArr[i];
//	    (*this).route_num[i] = orig.route_num[i];
//	    (*this).trip_num[i] = orig.trip_num[i];
//
//	    (*this).FCAP[i] = orig.FCAP[i]; (*this).BCAP[i] = orig.BCAP[i];
//	    (*this).pos[i] = orig.pos[i];
//	    (*this).startS[i] = orig.startS[i]; (*this).depart[i] = orig.depart[i];
//		(*this).vioTWCus[i] = orig.vioTWCus[i];
//		(*this).FvioTWCus[i] = orig.FvioTWCus[i];
//		(*this).BvioTWCus[i] = orig.BvioTWCus[i];
//	}
//
//	return *this;
//}


//Get the pointer to the problem.
//Problem* Solution::getProblem( )
//{
//  return problem;
//}

//void Solution::freeMEM(int nTypeCus)
//{
//    int i,j;
//	for (i=0;i<nTypeCus;i++)
//	{
//		for (j=0; j<totalNODE1;j++)
//		{
//			delete [] tabu[i][j];
//			delete [] frequency[i][j];
//		}
//		delete [] tabu[i];
//		delete [] frequency[i];
//	}
//	delete [] tabu; delete [] frequency;
//   for (i=0; i < startidC2C;i++)
//   {
//	  delete deleteCus[i];
//      delete insertCusEmptyVeh[i];
//		  delete insertCus[i][0];
//		  delete moveCus[i][0];
//		  delete twoOPTstarCus[i][0];
//		  delete exchangeCus[i][0]; 
//	  delete [] insertCus[i];
//	  delete [] moveCus[i];
//      delete [] exchangeCus[i]; 
//	  delete [] twoOPTstarCus[i];
//   }
//   for (i = startidP; i <= endidD;i++)
//   {
//	  delete deleteCus[i];
//      delete insertCusEmptyVeh[i];
//	  int size = problem->node[i].neighborSize;
// 	  for (j=0; j < size; j++)
//	  {
//		  delete insertCus[i][j];
//		  delete moveCus[i][j];
//		  delete twoOPTstarCus[i][j];
//		  delete exchangeCus[i][j]; 
//	  }
//	  delete [] insertCus[i];
//	  delete [] moveCus[i];
//      delete [] exchangeCus[i]; 
//	  delete [] twoOPTstarCus[i];
//	  //delete [] frequency[i];
//   }
//
//   for (i = startidC2C; i <= endidC2C;i++)
//   {
//	  delete deleteCus[i];
//      delete insertCusEmptyVeh[i];
//	  int size = problem->node[i].neighborSize;
// 	  for (j=0; j < size; j++)
//	  {
//		  delete insertCus[i][j];
//		  delete moveCus[i][j];
//		  delete twoOPTstarCus[i][j];
//	  }
//	  delete [] insertCus[i];
//	  delete [] moveCus[i];
//	  delete [] twoOPTstarCus[i];
//	  //delete [] frequency[i];
//   }
//
//   for (i=startidC2C; i <= endidC2CP;i++)
//   {
//	  int size1 = problem->nodeC2C[i].neighborSizeExchange;
// 	  for (j=0;j<size1;j++) delete exchangeCus[i][j];
//	  delete [] exchangeCus[i]; 
//   }
//
//   delete [] deleteCus;
//   delete [] insertCusEmptyVeh;
//   delete [] insertCus;
//   delete [] moveCus;
//   delete [] exchangeCus;
//   delete [] twoOPTstarCus;
//   //delete [] frequency;
//   for (i = 0; i <= endidC2C; i++) 
//   {
//	   delete [] insertC2CDAfter[i];
//	   delete [] moveC2CDAfter[i];
//   }
//   delete [] insertC2CDAfter; delete [] moveC2CDAfter;
//}

//Solution::~Solution() 
//{
//	cout<<"Call destroy solution of solution cost = "<<cost<<endl;
//	delete [] nextArr;
//	//cout<<"free predArr"<<endl;
//	delete [] predArr;
//	//cout<<"free route_num"<<endl;
//	delete [] route_num;
//	//cout<<"free trip_num"<<endl;
//	delete [] trip_num;
//	//cout<<"free pos"<<endl;
//	delete [] pos;
//	//cout<<"free startS"<<endl;
//	delete [] startS;
//	//cout<<"free depart"<<endl;
//	delete [] depart;
//	//cout<<"free FCAP"<<endl;
//	delete [] FCAP; 
//	//cout<<"free BCAP"<<endl;
//	delete [] BCAP;
//	//cout<<"free FvioTWCus"<<endl;
//	delete [] FvioTWCus; 
//	//cout<<"Free BvioTWCus"<<endl;
//	delete [] BvioTWCus;
//	//cout<<"Free vioTWCus"<<endl;
//	delete [] vioTWCus;
//
//	delete [] vioCAPCus; //delete [] FvioCAPCus; delete [] BvioCAPCus; 
//	delete [] CAPCus;
//
//	//delete [] numTripPSP;//count number of pickup trips assinged to each sp in the solution
//	//cout<<"Free numTripDSP"<<endl;
//	delete [] numTripDSP; //count number of delivery trips assinged to each sp in the solution
//	//cout<<"Free seg"<<endl;
//	//delete [] seg; 
//
//	cout<<"FISNISH DESTROY SOL"<<endl;
//}







