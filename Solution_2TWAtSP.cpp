#include "stdafx.h"
#include "PDS.h"
#include "Solution_ExchangeSP.h"
#include "Solution.h"
#include <iomanip>
#include <ctime>
using namespace std;

int *nextArrTemp, *nextArrB;
bool *routedTemp, *routed;
int *numCusPRouted; //SPToCusP[idCus] = idsp that is assigned to
int *numCusDRouted; //SPToCusP[idCus] = idsp that is assigned to
int *numCusPSP; //numCusPSP[idsp] = number of cusP assigned to idsp
int **CusPSP; // CusPSP[sp][j] = id of customerP #j assigned to sp; j = 1,..,numCusPSP[sp] 
int *SPToCusP;
int *numTripPSP;

double COEFCAP, COEFTWC, COEFTWSP; //coeficient vioCAP, vioTWCus, vioTWSP

int vioCAPC; double vioTWCC, vioTWSPC, COSTBEST, FITBEST; //total vioCAPCurrent, vioTWCurrent, COSTcurrent FITCurrent, COSTBEST, FITBEST
double penalty; 
double VCAP_START, VTWSP_START, VTWCUS_START;
double FITSTART;
int nTypeCus, nTypeSP;
int exceed,Q, nP, nD, nSP, nD1, nP1, nSP1,nDP, startidP, endidP, startidD, endidD, startidWS, endidWS, totalNODE, totalNODE1;
int IT, ITBEST;

int TABUD1[100], TABUD2[100], TABUSP1, TABUSP2, TABUP1, TABUP2; //interval of tabu for cusD, SP, cusP
double thetaD1, thetaD2, thetaSP1, thetaSP2, thetaP1, thetaP2;

bool *checkUsed;
int ITTabuCustomerZone[100];
int ITTabuP;
int ***tabu; //tabu[type][idCus][#neighbor]
int ****tabuExSP, **tabuMoveSP; //tabuExSP[spi][idVehi][spj][idVehj] and tabuMoveSP[spi][idVehi]

VariationptrDD *deleteCus; //deleteCus[cus i]: delete customer i from its current leg
VariationptrI **insertCus; //insertCus[cus i][neighbor of i]: insert its neighbor after customer i
VariationptrIE *insertCusEmptyVeh; //insertCusEmptyVeh[cur i]: insert customer i into new empty leg of empty vehicle
//Quangnn--
//VariationptrM **moveCusOneTrip;//moveCusOneTrip[cus i][neighbor of i]: move its neighbor after customer i
VariationptrEx **exchangeCus; //exchangeCus[cus i][neighbor of i]: exchange customer i and its neighbor
VariationptrT **twoOPTstarCus; //2opt*Cus[cus i][neighbor of i]

VariationptrSPCAP ****moveSP; //moveSP[spi][spj][idVehi][idVehj]: move spi on idVehi after spj on idVehj
//VariationptrSP **mergeSP; //mergeSP[spi][idVeh]: delete spi from idVeh and merge all customers currently served by spi to all other vehi with spi
VariationptrSP ****exchangeSP; //exchangeSP[spi][spj][idVehi][idVehj]: exchange spi on vehichle idVehi and spj on vehicle idVehj
moveT best_move,moveE; //moveE: use to evaluate the neighborhoods

#if CP_PORTING
int typeTW;
int startidC2C, endidC2CP, startidC2CD, endidC2C;
#endif

// Node definitions
#define NODE_DEPOT			 0
#define NODE_SUPPLY_POINT	 1
#define NODE_PICKUP			 2
#define NODE_DELIVERY		 3
#define NODE_C2C_PICKUP		 4
#define NODE_C2C_DELIVERY	 5
#define NODE_WAITING_STATION 6

#define TRIP_PICKUP			 0
#define TRIP_DELIVERY		 1
#define TRIP_C2C			 2

#define REMOVE_CUSTOMER		0
#define REMOVE_TRIP			1
#define REMOVE_VEHICLE		2
#define REMOVE_ALREADY		3
#define REMOVE_SPE_CUST		4

#define TYPE_CUST_C2C			0
#define TYPE_CUST_PICKUP		1
#define TYPE_CUST_DELIVERY		2

#define POST_OPTIMZATION		1

#define POST_OPTIMZATION_ONLY	0

#define DEBUG_FEEDBACK			0

#define VALIDTOR				0

void Solution::vdDumpMemory(int inLogLevel, char *szInfo, double *arrBuf, int inBufSz)
{
	ofstream fd;

#if (!_DEBUG)
	return;
#endif

	fd.open("master.log", ios::out | ios::app); 
     if (!fd){	 
		 cout << "\n\tInput file not found !!!!!!" << endl; getchar();
		 exit(-1);
	 }

	 //fd << __FILE__ << ":" << __LINE__;
	 fd << __LINE__;

	 switch (inLogLevel)
	 {
	 case 0: // Error
		 fd << "[ERR] ";
		 break;
	case 1: //Info.
		fd << "[INFO] ";
		break;
	 default:
		 break;
	 }

	 fd << szInfo << endl;

	 for (int i = 1; i  <= inBufSz; i++)
	 {
		 fd << arrBuf[i] << " ";
	 }
	 fd << endl;

}

/*
 * ENTRY POINT
 */
#if CP_PORTING
int main(int argc, char *argv[])
{
	double dbTotalCost;
	srand((unsigned int)time(NULL));
	//char *filename; filename = argv[1];
	char *filename = "..\\C2CDATA\\1.txt"; 
	cout<<"File name = "<<filename<<"-"<<endl;

	Problem P1(filename);  nTypeCus = 3; nTypeSP = 2;

	////P1.initData(typeTW); // Because do have src code so using current version instead
	P1.initData_Q();
	cout<<"FINI initData()"<<endl;
	Q = P1.Q; 
	nP1 = P1.nP + 1; nD1 = P1.nD + 1; nSP1 = P1.nSP + 1;
	startidWS = P1.startidWS; endidWS = P1.endidWS;
	startidP = P1.startidP; endidP = P1.endidP;
	startidD = P1.startidD; endidD = P1.endidD;
	startidC2C = P1.startidC2C; endidC2CP = P1.endidC2CP; startidC2CD = P1.startidC2CD; endidC2C = P1.endidC2C;
	
	totalNODE = P1.nSP + P1.nP + P1.nD + P1.nC2C;
	totalNODE1 = totalNODE + 1;

	cout<<"Solution sol(&P1);"<<endl;
	Solution *sol = new Solution(&P1);
    cout<<"FINI Solution sol(&P1);"<<endl;	
	COEFCAP = 1; COEFTWC = 1; COEFTWSP = 1;

    VCAP_START = 1; VCAP = VCAP_START;
	VTWCUS_START = 1; VTWCUS = VTWCUS_START;
	VTWSP_START = 1; VTWSP = VTWSP_START; 

	//typeofseed, int typeofINIT, int typeofAssCusPToSP, int valueFEE)
	cout<<"CREATE INITSOL: ";
	sol->initSol_CP(2,2,2,5);
	sol->showSolutionTempToCheck();
	sol->checkSolution();

	return 0;
}

#else
int main(int argc, char *argv[])
{
	double dbTotalCost;
	char filename[500];
	char szInitSolFileName[500];
	char szInitSolRemakeFN[500];
	char szOutSolFileName[500];
	char szOutSolStatFN[500];
	char szTestIdx[100];
	char szTestOffset[100];

	// Random seed
	srand((unsigned int)time(NULL)); 
   
#if _DEBUG
	strcpy(szTestIdx, "28");
	strcpy(szTestOffset, "1");
	//strcpy(szTestIdx, argv[1]);
	//strcpy(szTestOffset, argv[2]);
#else
	strcpy(szTestIdx, argv[1]);
	strcpy(szTestOffset, argv[2]);
#endif
	//Set path
#if DEBUG_FEEDBACK
	char szInputPath[] = "K:\\Prjs\\vn\\hanoi\\PHD_Proposal\\QuangNN-WS\\Presentations\\2E-\\WS\\PSD_New_FeasibleSP\\PSD_New\\PSDNewP\\Bug\\C2CDATA\\";
#else
	char szInputPath[] = "..\\C2CDATA\\";
#endif

#if DEBUG_FEEDBACK
	char szInitSolPath[] =  "K:\\Prjs\\vn\\hanoi\\PHD_Proposal\\QuangNN-WS\\Presentations\\2E-\\WS\\PSD_New_FeasibleSP\\PSD_New\\PSDNewP\\Bug\\CustLegOpers\\sol";// "..\\TabuSol\\sol";	
	char szInitSolRemakePath[] =  "K:\\Prjs\\vn\\hanoi\\PHD_Proposal\\QuangNN-WS\\Presentations\\2E-\\WS\\PSD_New_FeasibleSP\\PSD_New\\PSDNewP\\Bug\\CustLegOpers\\sol";//"..\\TabuSol\\sol";
#else

#if VALIDTOR
	char szInitSolPath[] =  "..\\ValidSolPool\\sol";// "..\\TabuSol\\sol";	
	char szInitSolRemakePath[] =  "..\\ValidSolPool\\sol";//"..\\TabuSol\\sol";
#else
#if POST_OPTIMZATION_ONLY
	char szInitSolPath[] =  "..\\InitPOSolPool\\sol";// "..\\TabuSol\\sol";	
	char szInitSolRemakePath[] =  "..\\InitPOSolPool\\sol";//"..\\TabuSol\\sol";
#else
	char szInitSolPath[] =  "..\\InitSolPool\\sol";// "..\\TabuSol\\sol";	
	char szInitSolRemakePath[] =  "..\\InitSolPool\\sol";//"..\\TabuSol\\sol";
#endif
#endif
#endif
	//char szInitSolRemakePath[] =  "..\\TabuSol\\sol";
	//char szInitSolPath[] =  "..\\TabuSol\\sol";;

	char szOutSolPath[] = "sol";
	char szOutSolStatPath[] = "sol";
	
	// create filename or using filename = argv[1];
   strcpy(filename, szInputPath);
   strcat(filename, szTestIdx);
   strcat(filename, ".txt");

	// init.sol
   strcpy(szInitSolFileName, szInitSolPath);
   strcat(szInitSolFileName, szTestIdx);
   strcat(szInitSolFileName, "_");
   strcat(szInitSolFileName, szTestOffset); //bfr, txt   
#if VALIDTOR
   strcat(szInitSolFileName, ".besopt");
#else
   strcat(szInitSolFileName, ".txt");
#endif

	// init.sol (remake)
   strcpy(szInitSolRemakeFN, szInitSolRemakePath);	
   //strcat(szInitSolRemakeFN, szTestIdx);
   strcat(szInitSolRemakeFN, "_");
   strcat(szInitSolRemakeFN, szTestOffset); //bfr, txt   
   strcat(szInitSolRemakeFN, ".txt");

   //output sol (curr, best)
   strcpy(szOutSolFileName, szOutSolPath);
   strcat(szOutSolFileName, szTestIdx);
   strcat(szOutSolFileName, "_");
   strcat(szOutSolFileName, szTestOffset); //bfr, txt   
   strcat(szOutSolFileName, ".qnn");

   //Statistic sol (curr, best)
   strcpy(szOutSolStatFN, szOutSolStatPath);
   strcat(szOutSolStatFN, szTestIdx);
   strcat(szOutSolStatFN, "_");
   strcat(szOutSolStatFN, szTestOffset); //bfr, txt   
   strcat(szOutSolStatFN, ".sta");

#if POST_OPTIMZATION_ONLY
   cout << "POST OPTIMIZATION ONLY>>>>>>>>>>>>>>>>>>>" << endl;
#endif

   cout << "-----------------------------------------" << endl;
   cout << "Input: \"" << filename << "\"" << endl;
#if _DEBUG
   cout << "Init.: \"" << szInitSolFileName << "\"" << endl;
   cout << "Remake: \"" << szInitSolRemakeFN << "\"" << endl;
#endif
   cout << "Output: \"" << szOutSolFileName << "\"" << endl;
   cout << "Statistic: \"" << szOutSolStatFN << "\"" << endl;
   cout << "-----------------------------------------" << endl << endl;
	   
	//TODO: Using argument
	thetaD1 = 1; //atof(argv[2]); 
	thetaD2 = 1; //atof(argv[3]); 
	penalty = 1; //atof(argv[4]); 
	penalty += 1; 
	int maxIT = 1; //atoi(argv[5]);
	//cout<<"MATIT = "<<maxIT<<endl;

	/*
	 * Read data and compute cost matrix
	 */
	Problem *P1 = new Problem(filename); 
	P1->initData_Q(); 
	Q = P1->Q;		// Vehicle capacity
	nP = P1->nP;	// Number of PICKUP customer's demands
	nD = P1->nD;	// Number of DELIVERY customer's demands
	nSP = P1->nSP;	// Number of SUPPLY POINTs
	
	//Reconstruct input to validate
	//P1->ReconstructInputData("..\\C2CDATA\\1.ou");
	
	nP1 = nP + 1; nD1 = nD + 1; nSP1 = nSP + 1;
	startidWS = P1->startidWS; endidWS = P1->endidWS;
	startidP = P1->startidP; endidP = P1->endidP;
	startidD = P1->startidD; endidD = P1->endidD;
	totalNODE = nSP + nP + nD;
	totalNODE1 = totalNODE + 1;
	
	Solution *sol = new Solution(P1, 0);
	nDP = nD + nP;
	
	COEFCAP = 1; COEFTWC = 1; COEFTWSP = 1;


	// Initiate soltion
	sol->init_Q(P1);

	//Importing solution
	sol->Load_A_Solution(szInitSolFileName);
	sol->Export_Loaded_Solution(szInitSolRemakeFN);
	sol->Reset_Time_For_Loaded_Solution(); // IMPORTANT Do conversion
	//sol->showSolution(); //unit test after reseting departure time

	if (false == sol->Check_Solution(&dbTotalCost)) {
		cout << "Check solution failed" << endl;
		return 0;
	}
	sol->g_dbBestTotalCost = dbTotalCost;

//	//Unit test for validation
//	sol->showSolutionNewFormat(szTestIdx, szTestOffset, true);
////	sol->showSolution();
//	return 0;


	//Unit test for post optimiation
	//sol->postOptimzation();
	//sol->Check_Solution(&sol->g_dbBestTotalCost);

	sol->g_dbBestFitness = dbTotalCost;
	sol->g_inInitVehNum = sol->numVeh;  // save Init. veh
	sol->g_inUsedVehNum = sol->numVeh; // save Used veh

	sol->initAssignment_Q();

	// Initiate solution
	//sol->initSolution_Q();
	//sol->Check_Solution(&dbTotalCost);
	//sol->showSolution();

	// Save the first solution as the best one
	sol->g_dbBestTotalCost = dbTotalCost;
	//sol->exportSolution();
	sol->updateBestSolution(0, 0, dbTotalCost, szTestIdx, 0, szTestOffset);

	//sol->showSolution_Old("15");
	//sol->Where_Are_Nodes();
	
	//sol->Show_A_Vehicle(1);
	//return 0;
	sol->vdLoadParameters();
	//sol->vdDumpParameters();
	//sol->ValidParameters();

#if 0
	//TODO: Unit test
	double arrDbTmp[10];
	for (int i = 1; i <= 6; i++)
	{
		arrDbTmp[i] = rand()%20;
	}
	int inSelectedTMp = sol->Select_Probability_By_Weight(arrDbTmp, 6, false);
	//sol->Worst_Util_Leg_Destroy();
	//sol->Remove_A_Leg(10, 8);
#endif


#if POST_OPTIMZATION_ONLY
#else
	sol->ALNS_Main(szOutSolStatFN, szTestIdx, szTestOffset);
#endif

#if POST_OPTIMZATION // Post optimization
	if (false == sol->Check_Solution(&dbTotalCost)) {
		cout << "Check sol. failed after post optimization" << endl; getchar();
	}
	sol->g_dbBestTotalCost = dbTotalCost;
	sol->showSolutionNewFormat(szTestIdx, szTestOffset, false); // Before post-optimization

	// Start timing for algorithm
	clock_t startTime = clock();
	sol->postOptimzation();
	if (false == sol->Check_Solution(&dbTotalCost)) {
		cout << "Check sol. failed before post optimization" << endl; getchar();
	}
	sol->g_dbBestTotalCost = dbTotalCost;

	double dbRunningTime = double( clock() - startTime ) / (double)CLOCKS_PER_SEC;
	sol->ExportStatPO(szTestIdx, szTestOffset, dbRunningTime);
	
	sol->showSolutionNewFormat("99", "99", true);

	sol->Load_A_Solution("sol99_99.besopt");
	//sol->Export_Loaded_Solution(szInitSolRemakeFN);
	sol->Reset_Time_For_Loaded_Solution(); // IMPORTANT Do conversion
	//sol->showSolution(); //unit test after reseting departure time

	if (false == sol->Check_Solution(&dbTotalCost)) {
		cout << "Check solution failed" << endl;
		return 0;
	}
	sol->g_dbBestTotalCost = dbTotalCost;

	//Unit test for validation
	sol->showSolutionNewFormat(szTestIdx, szTestOffset, true);

	return 0;
#endif

	//sol->showSolutionNewFormat();
	sol->Export_Loaded_Solution(szOutSolFileName);

#if _DEBUG
	cout << "Finished! Press enter to exit..." << endl; getchar();
#endif

	return 0;
}
#endif
void Solution::update_solutionCusD(moveT best_move)
{
	 int i, j,k;
	 j= best_move.idCus1; i = best_move.idCus2;	
	 k = best_move.idNeighbor;
     int type = best_move.type - 3;
	 int fromVeh, toVeh, fromTrip, toTrip;
		
	 fromVeh = route_num[i]; fromTrip = trip_num[i];
	 toVeh = route_num[j]; toTrip = trip_num[j];
     bool sameVeh = 0;
	 if (fromVeh == toVeh) sameVeh = 1;
     bool empty, stop;
	 int atSP = seg[fromVeh].Trip[fromTrip].assSP;
	 ITTabuCustomerZone[atSP] += 1; 

	 if (type == 0) //move 1-0: move Customer idCus2 (i) after idCus1 (j)
	 {
		 if (j==0) //move customer i into new empty vehicle:
		 {
			 if (seg[fromVeh].Trip[fromTrip].numCus ==1)
			 {
			     stop = Update_EmptyTripD(fromVeh, fromTrip);
				 if (stop)
				 {
					cout<<"Delete customer "<<i<<" from veh "<<fromVeh<<" trip "<<fromTrip<<": ";showTripCost(fromVeh, fromTrip);
					cout<<"deleteCus[i]->atIT = -100 ==??? === "<<deleteCus[i]->atIT<<endl;
					cout<<"Number of vehicles served sp "<<seg[fromVeh].Trip[fromTrip].assSP<<" = "<<numTripDSP[seg[fromVeh].Trip[fromTrip].assSP]<<" < required min = "<<problem->minTripSP[seg[fromVeh].Trip[fromTrip].assSP]<<endl;
					for (int ii=0;ii<numVeh;ii++)
						if (seg[ii].numTrips>0) {cout<<"******* Vehicle "<<ii<<": "<<endl; showSegment(ii);}
				    exit(-1);
				 }
			 }
			 else
		     {
				 //cout<<"Del cus "<<i<<" from ("<<fromVeh<<", "<<fromTrip<<") has >= 2 cus, and insert into new empty vehicle "<<toVeh<<endl;
				 deleteCusDTrip(fromVeh, fromTrip, i);
			 }
			 toVeh = CreateNewVeh_DTrip(i);
			 UpdateArray(toVeh);
			 UpdateArray(fromVeh);

			 tabu[type][i][0] = ITTabuCustomerZone[atSP] + Rand(TABUD1[atSP],TABUD2[atSP]);
			 toTrip = 0;
			 if (fromVeh == toVeh) 
			 {
				 sameVeh = 1;j=i;empty=0;
			     cout<<"THERE IS THE CASE WHERE DELETE CUS from a vehicle 1 trip and trip with one cus, and then reinsert cus into this vehicle"<<endl;
				 exit(-1);
			 }
		 }
		 else // j!=0 
		 {
			 empty = 0;
			 if (sameVeh) // i and j are in the same trip
			 {
				 moveCusDTrip(j,i,fromVeh,fromTrip);
				 UpdateArray(fromVeh);
			 }
			 else // i and j are in different trips:
			 {
				 if (seg[fromVeh].Trip[fromTrip].numCus == 1)
				 {
					     Update_EmptyTripD(fromVeh, fromTrip);
						 insertCusDTrip(j,i, toVeh, toTrip);
				 }
				 else
				 {
						 deleteCusDTrip(fromVeh, fromTrip, i);
						 insertCusDTrip(j,i, toVeh, toTrip);
				 }
				 UpdateArray(fromVeh);
				 UpdateArray(toVeh);
			 }//end i ans j are in different trips
			 tabu[type][i][0] = ITTabuCustomerZone[atSP] + Rand(TABUD1[atSP], TABUD2[atSP]);
		 }//end j !=0
	 }
	 else if (type == 1) //exchange 1-1: exchange customer idCus2 and idCus1 (CASE1: same vehicle / CASE2: 2 vehicles)
	 {
		 exchangeCusDTrip(j,i);
		 tabu[type][j][k] = ITTabuCustomerZone[atSP] + Rand(TABUD1[atSP], TABUD2[atSP]);
         int kk = problem->node[j].neighborOF[i];
		 if (kk > 0) tabu[type][i][kk] = ITTabuCustomerZone[atSP] + Rand(TABUD1[atSP], TABUD2[atSP]);
		 UpdateArray(toVeh); 
		 if (!sameVeh) UpdateArray(fromVeh); 
	 }
	 else if (type == 2) //2 opt*
	 {
		 if (sameVeh)
		 {
			 //Quangnn-- for compiling
			 //twoOPTstarCusDTrip_oneTrip(j,i); 
			 UpdateArray(toVeh);
		 }
		 else //dif vehicle
		 {
			 //Quangnn-- for compling
			 //empty = twoOPTstarCusDTrip(j,i);
			 UpdateArray(toVeh); UpdateArray(fromVeh);
	 	 }//end dif vehicle
		 tabu[type][j][k] = ITTabuCustomerZone[atSP] + Rand(TABUD1[atSP], TABUD2[atSP]); 
		 int kk = problem->node[j].neighborOF[i];
		 if (kk > 0) tabu[type][i][kk] = ITTabuCustomerZone[atSP] + Rand(TABUD1[atSP], TABUD2[atSP]);
	 }//end 2opt*

	 //UpdateSolutionAfterMove();
	 cout<<"atIT = "<<IT<<":Cus D Type = "<<type<<": varcost = "<<best_move.obj->var_cost<<"; varvioTWSP = "<<best_move.obj->var_vioTWSP<<"; varvioTWC = "<<best_move.obj->var_vioTWC<<"; varvioCAP = "<<best_move.obj->var_vioCAP<<"; vioCAPC = "<<vioCAPC<<"; vioTWCus = "<<vioTWCC<<"; vioTWSP = "<<vioTWSPC<<endl;

	 double buon = -cost; double buon1 = - vioTWSP; double buon2 = -vioTWC; int buon3 = -vioCAP;
	 UpdateCostFitnessFeasible();
	 buon +=cost; buon1 += vioTWSP; buon2 += vioTWC; buon3 += vioCAP;
	 double chan = fabs(best_move.obj->var_cost - buon);
	 //cout<<"correct = "<<buon<<" == ??? === "<<best_move.obj->var_cost<<endl;
	 if (chan > eps1)
	 {
		 cout<<"MoveCusD of move = "<<best_move.type<<" at IT = "<<IT<<endl;
		 cout<<"Solution::update_solutionCusD ERROR varcost: correct = "<<buon<<"; error = "<<best_move.obj->var_cost<<endl;
		 exit(-1);//getch();
	 }

	 chan = fabs(best_move.obj->var_vioTWSP - buon1);
	 if (chan > eps1)
	 {
		 cout<<"MoveCusD of move = "<<best_move.type<<" at IT = "<<IT<<endl;
		 cout<<"Solution::update_solutionCusD ERROR varvioTWSP: correct = "<<buon1<<"; error = "<<best_move.obj->var_vioTWSP<<endl;
		 exit(-1);//getch();
	 }
	 chan = fabs(best_move.obj->var_vioTWC - buon2);
	 if (chan > eps1)
	 {
		 cout<<"MoveCusD of move = "<<best_move.type<<" at IT = "<<IT<<endl;
		 cout<<"Solution::update_solutionCusD ERROR varvioTWC: correct = "<<buon2<<"; error = "<<best_move.obj->var_vioTWC<<endl;
		 exit(-1);//getch();
	 }
	 int chan2 = abs(best_move.obj->var_vioCAP - buon3);
	 if (chan2 > eps1)
	 {
		 cout<<"MoveCusD of move = "<<best_move.type<<" at IT = "<<IT<<endl;
		 cout<<"Solution::update_solutionCusD ERROR varvioCAP: correct = "<<buon3<<"; error = "<<best_move.obj->var_vioCAP<<endl;
		 exit(-1);//getch();
	 }
}

void Solution::update_solutionCusP(moveT best_move)
{

}

void Solution::Update_deleteCusArrayD_FirstTrip_Empty(int idVeh) //update deleteCusD for first trip of vehicle idVeh with only 1 delivery customer
{
	int assSP = seg[idVeh].Trip[0].assSP;
	int	deletednode = seg[idVeh].Trip[0].firstCus;
	
	if (numTripDSP[assSP] == problem->minTripSP[assSP]) deleteCus[deletednode]->atIT = -100;
	else
	{
			int curC, assSP1;
			double varcost, varvioTWC, varvioTWSP, cStartS;
		
			deleteCus[deletednode]->var_vioCAP = 0;
			varvioTWC = -seg[idVeh].Trip[0].vioTWC;
			varcost = -seg[idVeh].Trip[0].cost;
			curC = seg[idVeh].Trip[1].firstCus;
			if (seg[idVeh].Trip[1].Type) 
			{
				assSP1 = seg[idVeh].Trip[1].assSP;
				cStartS = problem->leaveSP[assSP1][4]; //load only at sTW2
				varvioTWSP = -seg[idVeh].Trip[1].vioTWSP;
				varcost += problem->c[0][assSP1];
			}
			else
			{
				cStartS = 0;
			    varvioTWSP = 0;
				assSP1 = 0;
				varcost += problem->c[0][curC];
			}
			GoThroughVehicle(idVeh, 1, varcost, varvioTWC, varvioTWSP, cStartS, assSP1, curC);
			deleteCus[deletednode]->var_cost = varcost;
			deleteCus[deletednode]->var_vioTWC = varvioTWC;
			deleteCus[deletednode]->var_vioTWSP = varvioTWSP;
		}//end else: need to update
}

void Solution::Update_deleteCusArrayD_MiddleTrip_Empty(int idVeh, int idTrip) //update deleteCusD for middle trip (idVeh, idTrip) with only 1 delivery customer
{
	int assSP = seg[idVeh].Trip[idTrip].assSP;
	int	deletednode = seg[idVeh].Trip[idTrip].firstCus;

	if (numTripDSP[assSP] == problem->minTripSP[assSP]) deleteCus[deletednode]->atIT = -100;
	else
	{
			deleteCus[deletednode]->var_vioCAP = 0;
			int curC, preC;
			double varcost, varvioTWC, varvioTWSP, cStartS;
			int preT = idTrip - 1; int nextT = idTrip + 1;
			bool stop;

			varvioTWC = -seg[idVeh].Trip[idTrip].vioTWC;
			varvioTWSP = -seg[idVeh].Trip[idTrip].vioTWSP;
			varcost = -(seg[idVeh].Trip[idTrip].cost + seg[idVeh].Trip[preT].connectCost);
			if (seg[idVeh].Trip[preT].Type)
			{
				preC = seg[idVeh].Trip[preT].lastCus; cStartS = depart[preC];
				if (seg[idVeh].Trip[nextT].Type) // d - [ d ] - d
				{
					stop = calCONNECTCSPTOSPD_FORDELETE(preC, idVeh, nextT, cStartS, varvioTWSP, varcost);
					if (stop) goto Update;
					preC = seg[idVeh].Trip[nextT].assSP; curC = seg[idVeh].Trip[nextT].firstCus;
				} 
				else //d - [d] - p
				{
					curC = seg[idVeh].Trip[nextT].firstCus;
					varcost += problem->c[preC][curC];
				}//end d - [d] - p
			}
			else //if (seg[idVeh].Trip[preT].Type==0)
			{
				cStartS = seg[idVeh].Trip[preT].leaveSP;
				if (seg[idVeh].Trip[nextT].Type) // p - assSP - [d] - d OR p - assSP1 - [assSP - d] - d
				{
					stop = calCONNECTCSPTOSPD_FORDELETE(seg[idVeh].Trip[preT].assSP, idVeh, nextT, cStartS, varvioTWSP, varcost);
					if (stop) goto Update;
					preC = seg[idVeh].Trip[nextT].assSP; curC = seg[idVeh].Trip[nextT].firstCus;
				}
				else //p - assSP - [d] - p OR p - assSP1 - [assSP - d] - p
				{
					preC = seg[idVeh].Trip[preT].assSP;
					curC = seg[idVeh].Trip[nextT].firstCus;
					varcost += problem->c[preC][curC];
				}//end p - assSP - [d] - p
			}//end if (seg[idVeh].Trip[preT].Type==0)

			GoThroughVehicle(idVeh, nextT, varcost, varvioTWC, varvioTWSP, cStartS, preC, curC);
			Update:
				deleteCus[deletednode]->var_cost = varcost;
				deleteCus[deletednode]->var_vioTWC = varvioTWC;
				deleteCus[deletednode]->var_vioTWSP = varvioTWSP;
		}//end else: need to update
}

void Solution::Update_deleteCusArrayD_FirstMiddleTrip(int idVeh, int idTrip) //only applied for the case where vehicle has >= 2 trips
{
	int numC = seg[idVeh].Trip[idTrip].numCus;
	int assSP = seg[idVeh].Trip[idTrip].assSP;
	int assSP1, curC, preC;
	double varcost, varvioTWC, varvioTWSP, cStartS, cArrTime, cArrTimeI, temp;
	int vioCapNEW;
	int lastTrip = seg[idVeh].numTrips-1;
	int deletednode;

	int preC1 = assSP;
	deletednode = seg[idVeh].Trip[idTrip].firstCus;
	cStartS = seg[idVeh].Trip[idTrip].leaveSP;
	int capOLD = seg[idVeh].Trip[idTrip].capacity;
	int vioCapOLD = seg[idVeh].Trip[idTrip].vioCAP;
	int curC1 = nextArr[deletednode];

	int nextT = idTrip + 1;
	assSP1 = seg[idVeh].Trip[nextT].assSP;
	int firstC_nextT = seg[idVeh].Trip[nextT].firstCus;

	if (seg[idVeh].Trip[nextT].Type)
	{
			//1. Delete the first and middle delivery customers:
			while (curC1 > 0)
			{
				varvioTWC = 0; varvioTWSP = 0;
				varcost = problem->c[preC1][curC1] - (problem->c[preC1][deletednode] + problem->c[deletednode][curC1]);
				preC = preC1; curC = curC1;
				do
				{
					cArrTime = cStartS + problem->c[preC][curC];
					cStartS = PDS_MAX(cArrTime, problem->node[curC].sTW);
					if (PDSDIF(cStartS, startS[curC])== 0) goto Update;
					temp = cStartS - problem->node[curC].eTW;
					if (temp > eps)
					{
							varvioTWC += (temp - vioTWCus[curC]);
							if (vioTWCus[curC] > eps) goto Update;
					}
					cStartS += problem->node[curC].duration;
					preC = curC; curC = nextArr[curC];
				} while (curC > 0);

				if (calChangeCONNECTCSPTOSPD_FORDELETE(preC, idVeh, nextT, cStartS, varvioTWSP, varcost) == 0)
					GoThroughVehicle(idVeh, nextT, varcost, varvioTWC, varvioTWSP, cStartS, assSP1, firstC_nextT);
				Update:
					deleteCus[deletednode]->var_cost = varcost;
					deleteCus[deletednode]->var_vioTWC = varvioTWC;
					deleteCus[deletednode]->var_vioTWSP = varvioTWSP;
					vioCapNEW = PDS_MAX(capOLD - problem->node[deletednode].capacity- problem->Q,0);
					deleteCus[deletednode]->var_vioCAP = vioCapNEW - vioCapOLD;

				//New delete customer:
				preC1 = deletednode; cStartS = depart[preC1];
				deletednode = curC1; curC1 = nextArr[curC1];
			}//end while (curC1 > 0)

			//2. Delete the last delivery customer:
			vioCapNEW = PDS_MAX(capOLD - problem->node[deletednode].capacity- problem->Q,0);
			deleteCus[deletednode]->var_vioCAP = vioCapNEW - vioCapOLD;
			varvioTWC = -vioTWCus[deletednode];

			cArrTime = cStartS + problem->c[preC1][assSP1];
			if (PDSINRANGE(cArrTime, problem->nodeSP[assSP1].sTW2, problem->nodeSP[assSP1].eTW2))
			{
				varvioTWSP = -seg[idVeh].Trip[nextT].vioTWSP;
				//before deletion has to go to sp directly: FEA OR INFEA
				varcost = problem->c[preC1][assSP1] - (problem->c[preC1][deletednode] + problem->c[deletednode][assSP1]);
				cStartS = cArrTime + problem->nodeSP[assSP1].load;
			}
			else
			{
					temp = cArrTime - problem->nodeSP[assSP1].eTW2;
					if (temp > eps)
					{
						//before deletion has to go to sp directly: INFEA
						deleteCus[deletednode]->var_cost = problem->c[preC1][assSP1] - (problem->c[preC1][deletednode] + problem->c[deletednode][assSP1]);
						deleteCus[deletednode]->var_vioTWSP = temp - seg[idVeh].Trip[nextT].vioTWSP;
						deleteCus[deletednode]->var_vioTWC = varvioTWC;
						return;
					}
					else
					{
						cArrTimeI = cStartS + problem->disCWSSP[preC1][assSP1];
						temp = cArrTimeI - problem->nodeSP[assSP1].eTW2;
						if (temp > eps) //too soon to go sp directly, too late to go through WS:
						{
							varvioTWSP = problem->nodeSP[assSP1].sTW2 - cArrTime - seg[idVeh].Trip[nextT].vioTWSP;
							//before deletion has to go to sp directly: FEA OR INFEA
							varcost = problem->c[preC1][assSP1] - (problem->c[preC1][deletednode] + problem->c[deletednode][assSP1]);
							cStartS = problem->leaveSP[assSP1][1]; //load only at eTW2
						}
						else //to go through WS
						{
							varvioTWSP = -seg[idVeh].Trip[nextT].vioTWSP;
							//before deletion may go to sp directly or through WS:
							if (seg[idVeh].Trip[idTrip].waitingS == NO_WS)
								varcost = problem->disCWSSP[preC1][assSP1] - (problem->c[preC1][deletednode] + problem->c[deletednode][assSP1]);
							else varcost = problem->disCWSSP[preC1][assSP1] - (problem->c[preC1][deletednode] + problem->disCWSSP[deletednode][assSP1]);
							cStartS = PDS_MAX(cArrTimeI, problem->nodeSP[assSP1].sTW2) + problem->nodeSP[assSP1].load;
						}
					}
				}
				GoThroughVehicle(idVeh, 1, varcost, varvioTWC, varvioTWSP, cStartS, assSP1, firstC_nextT);
				deleteCus[deletednode]->var_cost = varcost;
				deleteCus[deletednode]->var_vioTWC = varvioTWC;
				deleteCus[deletednode]->var_vioTWSP = varvioTWSP;

	}
	else //if (seg[idVeh].Trip[nextT].Type ==0)
	{
			//1. Delete the first and middle delivery customers:
			while (curC1 > 0)
			{
				varvioTWC = 0; varvioTWSP = 0;
				varcost = problem->c[preC1][curC1] - (problem->c[preC1][deletednode] + problem->c[deletednode][curC1]);
				preC = preC1; curC = curC1;
				do
				{
					cArrTime = cStartS + problem->c[preC][curC];
					cStartS = PDS_MAX(cArrTime, problem->node[curC].sTW);
					if (PDSDIF(cStartS, startS[curC])== 0) goto UpdateP;
					temp = cStartS - problem->node[curC].eTW;
					if (temp > eps)
					{
							varvioTWC += (temp - vioTWCus[curC]);
							if (vioTWCus[curC] > eps) goto UpdateP;
					}
					cStartS += problem->node[curC].duration;
					preC = curC; curC = nextArr[curC];
				} while (curC > 0);
				GoThroughVehicle(idVeh, nextT, varcost, varvioTWC, varvioTWSP, cStartS, preC, firstC_nextT);

				UpdateP:
					deleteCus[deletednode]->var_cost = varcost;
					deleteCus[deletednode]->var_vioTWC = varvioTWC;
					deleteCus[deletednode]->var_vioTWSP = varvioTWSP;
					vioCapNEW = PDS_MAX(capOLD - problem->node[deletednode].capacity- problem->Q,0);
					deleteCus[deletednode]->var_vioCAP = vioCapNEW - vioCapOLD;

				//New delete customer:
				preC1 = deletednode; cStartS = depart[preC1];
				deletednode = curC1; curC1 = nextArr[curC1];
			}//end while (curC1 > 0)

			//2. Delete the last delivery customer:
			vioCapNEW = PDS_MAX(capOLD - problem->node[deletednode].capacity- problem->Q,0);
			deleteCus[deletednode]->var_vioCAP = vioCapNEW - vioCapOLD;
			varvioTWC = -vioTWCus[deletednode];
			varcost = problem->c[preC1][firstC_nextT] - (problem->c[preC1][deletednode] + problem->c[deletednode][firstC_nextT]);
			varvioTWSP = 0;
			GoThroughVehicle(idVeh, nextT, varcost, varvioTWC, varvioTWSP, cStartS, preC1, firstC_nextT);
			deleteCus[deletednode]->var_cost = varcost;
			deleteCus[deletednode]->var_vioTWC = varvioTWC;
			deleteCus[deletednode]->var_vioTWSP = varvioTWSP;
	}//end if (seg[idVeh].Trip[nextT].Type ==0)
}

void Solution::Update_deleteCusArrayD_LastTrip_Empty(int idVeh, int idTrip)
{
	int assSP = seg[idVeh].Trip[idTrip].assSP;
	int	deletednode = seg[idVeh].Trip[idTrip].firstCus;
	
	if (numTripDSP[assSP] == problem->minTripSP[assSP]) deleteCus[deletednode]->atIT = -100;
	else
	{
		int preT = idTrip - 1;
		deleteCus[deletednode]->var_vioCAP = 0;
		deleteCus[deletednode]->var_vioTWC = -seg[idVeh].Trip[idTrip].vioTWC;
		deleteCus[deletednode]->var_vioTWSP = -seg[idVeh].Trip[idTrip].vioTWSP;

		double varcost = -(seg[idVeh].Trip[preT].connectCost + seg[idVeh].Trip[idTrip].cost);
		if (seg[idVeh].Trip[preT].Type) 
			varcost += problem->c[seg[idVeh].Trip[preT].lastCus][0];
		else
			varcost += problem->c[seg[idVeh].Trip[preT].assSP][0];
		deleteCus[deletednode]->var_cost = varcost;
	}//end else: need to update	
}

void Solution::Update_deleteCusArrayD_LastTrip(int idVeh, int idTrip) //only applied for the case where vehicle has >= 2 trips
{
	int numC = seg[idVeh].Trip[idTrip].numCus;
	int curC, preC;
	double varcost, varvioTWC, varvioTWSP, cStartS, cArrTime, temp;
	int vioCapNEW;
	int deletednode;

	int preC1 = seg[idVeh].Trip[idTrip].assSP;
	deletednode = seg[idVeh].Trip[idTrip].firstCus;
	cStartS = seg[idVeh].Trip[idTrip].leaveSP;
	int capOLD = seg[idVeh].Trip[idTrip].capacity;
	int vioCapOLD = seg[idVeh].Trip[idTrip].vioCAP;
	int curC1 = nextArr[deletednode];

	//1. Delete the first and middle delivery customers:
	while (curC1 > 0)
	{
			varvioTWC = 0; varvioTWSP = 0;
			varcost = problem->c[preC1][curC1] - (problem->c[preC1][deletednode] + problem->c[deletednode][curC1]);
			preC = preC1; curC = curC1;
			do
			{
				cArrTime = cStartS + problem->c[preC][curC];
				cStartS = PDS_MAX(cArrTime, problem->node[curC].sTW);
				if (PDSDIF(cStartS, startS[curC])== 0) break;
				temp = cStartS - problem->node[curC].eTW;
				if (temp > eps)
				{
						varvioTWC += (temp - vioTWCus[curC]);
						if (vioTWCus[curC] > eps) break;
				}
				cStartS += problem->node[curC].duration;
				preC = curC; curC = nextArr[curC];
			} while (curC > 0);
			deleteCus[deletednode]->var_cost = varcost;
			deleteCus[deletednode]->var_vioTWC = varvioTWC;
			deleteCus[deletednode]->var_vioTWSP = varvioTWSP;
			vioCapNEW = PDS_MAX(capOLD - problem->node[deletednode].capacity- problem->Q,0);
			deleteCus[deletednode]->var_vioCAP = vioCapNEW - vioCapOLD;

			//New delete customer:
			preC1 = deletednode; cStartS = depart[preC1];
			deletednode = curC1; curC1 = nextArr[curC1];
	}//end while (curC1 > 0)

	//2. Delete the last delivery customer:
	vioCapNEW = PDS_MAX(capOLD - problem->node[deletednode].capacity- problem->Q,0);
	deleteCus[deletednode]->var_vioCAP = vioCapNEW - vioCapOLD;
	deleteCus[deletednode]->var_vioTWC = -vioTWCus[deletednode];
	deleteCus[deletednode]->var_vioTWSP = 0;
	deleteCus[deletednode]->var_cost = problem->c[preC1][0] - (problem->c[preC1][deletednode] + problem->c[deletednode][0]);
}

void Solution::Update_deleteCusArrayP_FirstTrip_Empty(int idVeh) //update deleteCusD for first trip of vehicle idVeh with only 1 delivery customer
{
	int assSP1;
	int	deletednode = seg[idVeh].Trip[0].firstCus;
	
	deleteCus[deletednode]->var_vioCAP = 0;
	double varvioTWC = -seg[idVeh].Trip[0].vioTWC;
	double varcost = -seg[idVeh].Trip[0].cost;
	double varvioTWSP, cStartS;
	int curC = seg[idVeh].Trip[1].firstCus;


	if (seg[idVeh].Trip[1].Type) 
	{
		assSP1 = seg[idVeh].Trip[1].assSP;
		cStartS = problem->leaveSP[assSP1][4]; //load only at sTW2
		varvioTWSP = -(seg[idVeh].Trip[0].vioTWSP + seg[idVeh].Trip[1].vioTWSP);
		varcost += problem->c[0][assSP1];
	}
	else
	{
		cStartS = 0;
	    varvioTWSP = -seg[idVeh].Trip[0].vioTWSP;
		assSP1 = 0;
		varcost += problem->c[0][curC];
	}
	GoThroughVehicle(idVeh, 1, varcost, varvioTWC, varvioTWSP, cStartS, assSP1, curC);
	deleteCus[deletednode]->var_cost = varcost;
	deleteCus[deletednode]->var_vioTWC = varvioTWC;
	deleteCus[deletednode]->var_vioTWSP = varvioTWSP;
}

void Solution::Update_deleteCusArrayP_MiddleTrip_Empty(int idVeh, int idTrip) //update deleteCusD for middle trip (idVeh, idTrip) with only 1 delivery customer
{
	int assSP = seg[idVeh].Trip[idTrip].assSP;
	int	deletednode = seg[idVeh].Trip[idTrip].firstCus;

	deleteCus[deletednode]->var_vioCAP = 0;
	int curC, preC;
	double varcost, varvioTWC, varvioTWSP, cStartS;
	int preT = idTrip - 1; int nextT = idTrip + 1;
	bool stop;

	varvioTWC = -seg[idVeh].Trip[idTrip].vioTWC;
	varvioTWSP = -seg[idVeh].Trip[idTrip].vioTWSP;
	varcost = -(seg[idVeh].Trip[idTrip].cost + seg[idVeh].Trip[preT].connectCost);
	if (seg[idVeh].Trip[preT].Type)
	{
		preC = seg[idVeh].Trip[preT].lastCus; cStartS = depart[preC];
		if (seg[idVeh].Trip[nextT].Type) // d - [ p ] - d
		{
			stop = calCONNECTCSPTOSPD_FORDELETE(preC, idVeh, nextT, cStartS, varvioTWSP, varcost);
			if (stop) goto Update;
			preC = seg[idVeh].Trip[nextT].assSP; curC = seg[idVeh].Trip[nextT].firstCus;
		} 
		else //d - [p] - p
		{
			curC = seg[idVeh].Trip[nextT].firstCus;
			varcost += problem->c[preC][curC];
		}//end d - [p] - p
	}
	else //if (seg[idVeh].Trip[preT].Type==0)
	{
		cStartS = seg[idVeh].Trip[preT].leaveSP;
		if (seg[idVeh].Trip[nextT].Type) // p - assSP - [p - assSP1] - d OR p - assSP - [p - assSP1] - assSP2 - d 
		{
			stop = calCONNECTCSPTOSPD_FORDELETE(seg[idVeh].Trip[preT].assSP, idVeh, nextT, cStartS, varvioTWSP, varcost);
			if (stop) goto Update;
			preC = seg[idVeh].Trip[nextT].assSP; curC = seg[idVeh].Trip[nextT].firstCus;
		}
		else //p - assSP - [p - assSP1] - p - assSP2
		{
			preC = seg[idVeh].Trip[preT].assSP;
			curC = seg[idVeh].Trip[nextT].firstCus;
			varcost += problem->c[preC][curC];
		}//end p - assSP - [d] - p
	}//end if (seg[idVeh].Trip[preT].Type==0)

	GoThroughVehicle(idVeh, nextT, varcost, varvioTWC, varvioTWSP, cStartS, preC, curC);
	Update:
		deleteCus[deletednode]->var_cost = varcost;
		deleteCus[deletednode]->var_vioTWC = varvioTWC;
		deleteCus[deletednode]->var_vioTWSP = varvioTWSP;
}

void Solution::Update_deleteCusArrayP_LastTrip_Empty(int idVeh, int idTrip)
{
	int	deletednode = seg[idVeh].Trip[idTrip].firstCus;
	int preT = idTrip - 1;
	deleteCus[deletednode]->var_vioCAP = 0;
	deleteCus[deletednode]->var_vioTWC = -seg[idVeh].Trip[idTrip].vioTWC;
	deleteCus[deletednode]->var_vioTWSP = -seg[idVeh].Trip[idTrip].vioTWSP;

	double varcost = -(seg[idVeh].Trip[preT].connectCost + seg[idVeh].Trip[idTrip].cost);
	if (seg[idVeh].Trip[preT].Type) 
		varcost += problem->c[seg[idVeh].Trip[preT].lastCus][0];
	else
		varcost += problem->c[seg[idVeh].Trip[preT].assSP][0];
	deleteCus[deletednode]->var_cost = varcost;
}

void Solution::Update_deleteCusArrayP_FirstMiddleTrip(int idVeh, int idTrip) //only applied for the case where vehicle has >= 2 trips
{
	int numC = seg[idVeh].Trip[idTrip].numCus;
	int assSP1, curC, preC, preC1;
	double varcost, varvioTWC, varvioTWSP, cStartS, cArrTime, cArrTimeI, temp;
	int vioCapNEW;
	int lastTrip = seg[idVeh].numTrips-1;
	int deletednode;

	int assSP = seg[idVeh].Trip[idTrip].assSP;
	deletednode = seg[idVeh].Trip[idTrip].firstCus;
	if (idTrip == 0)
	{
		preC1 = 0;
		cStartS = 0;
	}
	else
	{
		int preT = idTrip - 1; 
		if (seg[idVeh].Trip[preT].Type) 
		{
			preC1 = seg[idVeh].Trip[preT].lastCus;
			cStartS = depart[preC1];
		}
		else 
		{
			preC1 = seg[idVeh].Trip[preT].assSP;
			cStartS = seg[idVeh].Trip[preT].leaveSP;
		}	
	}

	int capOLD = seg[idVeh].Trip[idTrip].capacity;
	int vioCapOLD = seg[idVeh].Trip[idTrip].vioCAP;
	int curC1 = nextArr[deletednode];

	int nextT = idTrip + 1;
	assSP1 = seg[idVeh].Trip[nextT].assSP;
	int firstC_nextT = seg[idVeh].Trip[nextT].firstCus;

	if (seg[idVeh].Trip[nextT].Type)
	{
		if (assSP1 == assSP) // p -assSP - d
		{
			//1. Delete the first and middle pickup customers:
			while (curC1 > 0)
			{
				varvioTWC = 0; 
				varcost = problem->c[preC1][curC1] - (problem->c[preC1][deletednode] + problem->c[deletednode][curC1]);
				preC = preC1; curC = curC1;
				do
				{
					cArrTime = cStartS + problem->c[preC][curC];
					cStartS = PDS_MAX(cArrTime, problem->node[curC].sTW);
					if (PDSDIF(cStartS, startS[curC])== 0) goto Update;
					temp = cStartS - problem->node[curC].eTW;
					if (temp > eps)
					{
							varvioTWC += (temp - vioTWCus[curC]);
							if (vioTWCus[curC] > eps) goto Update;
					}
					cStartS += problem->node[curC].duration;
					preC = curC; curC = nextArr[curC];
				} while (curC > 0);
				if (calChangeCONNECTAtSP_PickTrip_FORDELETE(preC, idVeh, idTrip, cStartS, varvioTWSP, varcost)==0)
				{
					varvioTWSP *= 2;
					cStartS += problem->nodeSP[assSP1].load;
					GoThroughVehicle(idVeh, nextT, varcost, varvioTWC, varvioTWSP, cStartS, assSP1, firstC_nextT);
				}
				Update:
					deleteCus[deletednode]->var_cost = varcost;
					deleteCus[deletednode]->var_vioTWC = varvioTWC;
					deleteCus[deletednode]->var_vioTWSP = varvioTWSP;
					vioCapNEW = PDS_MAX(capOLD - problem->node[deletednode].capacity- problem->Q,0);
					deleteCus[deletednode]->var_vioCAP = vioCapNEW - vioCapOLD;

				//New delete customer:
				preC1 = deletednode; cStartS = depart[preC1];
				deletednode = curC1; curC1 = nextArr[curC1];
			}//end while (curC1 > 0)
			
			//2. Delete the last pickup customer:
			vioCapNEW = PDS_MAX(capOLD - problem->node[deletednode].capacity- problem->Q,0);
			deleteCus[deletednode]->var_vioCAP = vioCapNEW - vioCapOLD;
			varvioTWC = -vioTWCus[deletednode];

			cArrTime = cStartS + problem->c[preC1][assSP];
			if (PDSINRANGE(cArrTime, problem->nodeSP[assSP].sTW2, problem->nodeSP[assSP].eTW2))
			{
				varvioTWSP = -seg[idVeh].Trip[idTrip].vioTWSP;
				//before deletion has to go to sp directly: FEA OR INFEA
				varcost = problem->c[preC1][assSP] - (problem->c[preC1][deletednode] + problem->c[deletednode][assSP]);
				cStartS = cArrTime + problem->nodeSP[assSP].unload + problem->nodeSP[assSP].load;
			}
			else
			{
					temp = cArrTime - problem->nodeSP[assSP].eTW2;
					if (temp > eps)
					{
						//before deletion has to go to sp directly: INFEA
						deleteCus[deletednode]->var_cost = problem->c[preC1][assSP] - (problem->c[preC1][deletednode] + problem->c[deletednode][assSP]);
						deleteCus[deletednode]->var_vioTWSP = temp - seg[idVeh].Trip[idTrip].vioTWSP;
						deleteCus[deletednode]->var_vioTWC = varvioTWC;
						return;
					}
					else
					{
						cArrTimeI = cStartS + problem->disCWSSP[preC1][assSP];
						temp = cArrTimeI - problem->nodeSP[assSP].eTW2;
						if (temp > eps) //too soon to go sp directly, too late to go through WS:
						{
							varvioTWSP = problem->nodeSP[assSP].sTW2 - cArrTime - seg[idVeh].Trip[idTrip].vioTWSP;
							//before deletion has to go to sp directly: FEA OR INFEA
							varcost = problem->c[preC1][assSP] - (problem->c[preC1][deletednode] + problem->c[deletednode][assSP]);
							if (seg[idVeh].Trip[idTrip].vioTWSP > eps)
							{
								deleteCus[deletednode]->var_cost = varcost;
								deleteCus[deletednode]->var_vioTWSP = varvioTWSP;
								deleteCus[deletednode]->var_vioTWC = varvioTWC;
								return;
							}
							cStartS = problem->leaveSP[assSP][2]; //unload and load at eTW2
						}
						else //to go through WS
						{
							varvioTWSP = -seg[idVeh].Trip[idTrip].vioTWSP;
							//before deletion may go to sp directly or through WS:
							if (seg[idVeh].Trip[idTrip].waitingS == NO_WS)
								varcost = problem->disCWSSP[preC1][assSP] - (problem->c[preC1][deletednode] + problem->c[deletednode][assSP]);
							else varcost = problem->disCWSSP[preC1][assSP] - (problem->c[preC1][deletednode] + problem->disCWSSP[deletednode][assSP]);
							cStartS = PDS_MAX(cArrTimeI, problem->nodeSP[assSP].sTW2) + problem->nodeSP[assSP].unload + problem->nodeSP[assSP].load;
						}
					}
			}
			GoThroughVehicle(idVeh, nextT, varcost, varvioTWC, varvioTWSP, cStartS, assSP1, firstC_nextT);
			deleteCus[deletednode]->var_cost = varcost;
			deleteCus[deletednode]->var_vioTWC = varvioTWC;
			deleteCus[deletednode]->var_vioTWSP = varvioTWSP;
		}
		else // p - assSP - assSP1 - d
		{
			//1. Delete the first and middle pickup customers:
			while (curC1 > 0)
			{
				varvioTWC = 0; 
				varcost = problem->c[preC1][curC1] - (problem->c[preC1][deletednode] + problem->c[deletednode][curC1]);
				preC = preC1; curC = curC1;
				do
				{
					cArrTime = cStartS + problem->c[preC][curC];
					cStartS = PDS_MAX(cArrTime, problem->node[curC].sTW);
					if (PDSDIF(cStartS, startS[curC])== 0) goto Update1;
					temp = cStartS - problem->node[curC].eTW;
					if (temp > eps)
					{
							varvioTWC += (temp - vioTWCus[curC]);
							if (vioTWCus[curC] > eps) goto Update1;
					}
					cStartS += problem->node[curC].duration;
					preC = curC; curC = nextArr[curC];
				} while (curC > 0);
				if (calChangeCONNECTAtSP_PickTrip_FORDELETE(preC, idVeh, idTrip, cStartS, varvioTWSP, varcost)==0)
				{
					if (calChangeCONNECTAtSP_SPSP(idVeh, nextT, idTrip, cStartS, varvioTWSP, varcost) == 0)
					   GoThroughVehicle(idVeh, nextT, varcost, varvioTWC, varvioTWSP, cStartS, assSP1, firstC_nextT);
				}
				Update1:
					deleteCus[deletednode]->var_cost = varcost;
					deleteCus[deletednode]->var_vioTWC = varvioTWC;
					deleteCus[deletednode]->var_vioTWSP = varvioTWSP;
					vioCapNEW = PDS_MAX(capOLD - problem->node[deletednode].capacity- problem->Q,0);
					deleteCus[deletednode]->var_vioCAP = vioCapNEW - vioCapOLD;

				//New delete customer:
				preC1 = deletednode; cStartS = depart[preC1];
				deletednode = curC1; curC1 = nextArr[curC1];
			}//end while (curC1 > 0)
			
			//2. Delete the last pickup customer:
			vioCapNEW = PDS_MAX(capOLD - problem->node[deletednode].capacity- problem->Q,0);
			deleteCus[deletednode]->var_vioCAP = vioCapNEW - vioCapOLD;
			varvioTWC = -vioTWCus[deletednode];

			cArrTime = cStartS + problem->c[preC1][assSP];
			if (PDSINRANGE(cArrTime, problem->nodeSP[assSP].sTW2, problem->nodeSP[assSP].eTW2))
			{
				varvioTWSP = -seg[idVeh].Trip[idTrip].vioTWSP;
				//before deletion has to go to sp directly: FEA OR INFEA
				varcost = problem->c[preC1][assSP] - (problem->c[preC1][deletednode] + problem->c[deletednode][assSP]);
				cStartS = cArrTime + problem->nodeSP[assSP].unload;
			}
			else
			{
					temp = cArrTime - problem->nodeSP[assSP].eTW2;
					if (temp > eps)
					{
						//before deletion has to go to sp directly: INFEA
						deleteCus[deletednode]->var_cost = problem->c[preC1][assSP] - (problem->c[preC1][deletednode] + problem->c[deletednode][assSP]);
						deleteCus[deletednode]->var_vioTWSP = temp - seg[idVeh].Trip[idTrip].vioTWSP;
						deleteCus[deletednode]->var_vioTWC = varvioTWC;
						return;
					}
					else
					{
						cArrTimeI = cStartS + problem->disCWSSP[preC1][assSP];
						temp = cArrTimeI - problem->nodeSP[assSP].eTW2;
						if (temp > eps) //too soon to go sp directly, too late to go through WS:
						{
							varvioTWSP = problem->nodeSP[assSP].sTW2 - cArrTime - seg[idVeh].Trip[idTrip].vioTWSP;
							//before deletion has to go to sp directly: FEA OR INFEA
							varcost = problem->c[preC1][assSP] - (problem->c[preC1][deletednode] + problem->c[deletednode][assSP]);
							if (seg[idVeh].Trip[idTrip].vioTWSP > eps)
							{
								deleteCus[deletednode]->var_cost = varcost;
								deleteCus[deletednode]->var_vioTWSP = varvioTWSP;
								deleteCus[deletednode]->var_vioTWC = varvioTWC;
								return;
							}
							cStartS = problem->leaveSP[assSP][0]; //unload at eTW2
						}
						else //to go through WS
						{
							varvioTWSP = -seg[idVeh].Trip[idTrip].vioTWSP;
							//before deletion may go to sp directly or through WS:
							if (seg[idVeh].Trip[idTrip].waitingS == NO_WS)
								varcost = problem->disCWSSP[preC1][assSP] - (problem->c[preC1][deletednode] + problem->c[deletednode][assSP]);
							else varcost = problem->disCWSSP[preC1][assSP] - (problem->c[preC1][deletednode] + problem->disCWSSP[deletednode][assSP]);
							cStartS = PDS_MAX(cArrTimeI, problem->nodeSP[assSP].sTW2) + problem->nodeSP[assSP].unload;
						}
					}
			}
			
			if (calChangeCONNECTAtSP_SPSP(idVeh, nextT, idTrip, cStartS, varvioTWSP, varcost) == 0)
			    GoThroughVehicle(idVeh, nextT, varcost, varvioTWC, varvioTWSP, cStartS, assSP1, firstC_nextT);
			deleteCus[deletednode]->var_cost = varcost;
			deleteCus[deletednode]->var_vioTWC = varvioTWC;
			deleteCus[deletednode]->var_vioTWSP = varvioTWSP;
		}//end p - assSP - assSP1 - d
	}
	else //if (seg[idVeh].Trip[nextT].Type ==0)
	{
			//1. Delete the first and middle pickup customers:
			while (curC1 > 0)
			{
				varvioTWC = 0; 
				varcost = problem->c[preC1][curC1] - (problem->c[preC1][deletednode] + problem->c[deletednode][curC1]);
				preC = preC1; curC = curC1;
				do
				{
					cArrTime = cStartS + problem->c[preC][curC];
					cStartS = PDS_MAX(cArrTime, problem->node[curC].sTW);
					if (PDSDIF(cStartS, startS[curC])== 0) goto Update2;
					temp = cStartS - problem->node[curC].eTW;
					if (temp > eps)
					{
							varvioTWC += (temp - vioTWCus[curC]);
							if (vioTWCus[curC] > eps) goto Update2;
					}
					cStartS += problem->node[curC].duration;
					preC = curC; curC = nextArr[curC];
				} while (curC > 0);
				if (calChangeCONNECTAtSP_PickTrip_FORDELETE(preC, idVeh, idTrip, cStartS, varvioTWSP, varcost)==0)
				   GoThroughVehicle(idVeh, nextT, varcost, varvioTWC, varvioTWSP, cStartS, assSP1, firstC_nextT);
				Update2:
					deleteCus[deletednode]->var_cost = varcost;
					deleteCus[deletednode]->var_vioTWC = varvioTWC;
					deleteCus[deletednode]->var_vioTWSP = varvioTWSP;
					vioCapNEW = PDS_MAX(capOLD - problem->node[deletednode].capacity- problem->Q,0);
					deleteCus[deletednode]->var_vioCAP = vioCapNEW - vioCapOLD;

				//New delete customer:
				preC1 = deletednode; cStartS = depart[preC1];
				deletednode = curC1; curC1 = nextArr[curC1];
			}//end while (curC1 > 0)
			
			//2. Delete the last pickup customer:
			vioCapNEW = PDS_MAX(capOLD - problem->node[deletednode].capacity- problem->Q,0);
			deleteCus[deletednode]->var_vioCAP = vioCapNEW - vioCapOLD;
			varvioTWC = -vioTWCus[deletednode];

			cArrTime = cStartS + problem->c[preC1][assSP];
			if (PDSINRANGE(cArrTime, problem->nodeSP[assSP].sTW2, problem->nodeSP[assSP].eTW2))
			{
				varvioTWSP = -seg[idVeh].Trip[idTrip].vioTWSP;
				//before deletion has to go to sp directly: FEA OR INFEA
				varcost = problem->c[preC1][assSP] - (problem->c[preC1][deletednode] + problem->c[deletednode][assSP]);
				cStartS = cArrTime + problem->nodeSP[assSP].unload;
			}
			else
			{
					temp = cArrTime - problem->nodeSP[assSP].eTW2;
					if (temp > eps)
					{
						//before deletion has to go to sp directly: INFEA
						deleteCus[deletednode]->var_cost = problem->c[preC1][assSP] - (problem->c[preC1][deletednode] + problem->c[deletednode][assSP]);
						deleteCus[deletednode]->var_vioTWSP = temp - seg[idVeh].Trip[idTrip].vioTWSP;
						deleteCus[deletednode]->var_vioTWC = varvioTWC;
						return;
					}
					else
					{
						cArrTimeI = cStartS + problem->disCWSSP[preC1][assSP];
						temp = cArrTimeI - problem->nodeSP[assSP].eTW2;
						if (temp > eps) //too soon to go sp directly, too late to go through WS:
						{
							varvioTWSP = problem->nodeSP[assSP].sTW2 - cArrTime - seg[idVeh].Trip[idTrip].vioTWSP;
							//before deletion has to go to sp directly: FEA OR INFEA
							varcost = problem->c[preC1][assSP] - (problem->c[preC1][deletednode] + problem->c[deletednode][assSP]);
							if (seg[idVeh].Trip[idTrip].vioTWSP > eps)
							{
								deleteCus[deletednode]->var_cost = varcost;
								deleteCus[deletednode]->var_vioTWSP = varvioTWSP;
								deleteCus[deletednode]->var_vioTWC = varvioTWC;
								return;
							}
							cStartS = problem->leaveSP[assSP][0]; //unload at eTW2
						}
						else //to go through WS
						{
							varvioTWSP = -seg[idVeh].Trip[idTrip].vioTWSP;
							//before deletion may go to sp directly or through WS:
							if (seg[idVeh].Trip[idTrip].waitingS == NO_WS)
								varcost = problem->disCWSSP[preC1][assSP] - (problem->c[preC1][deletednode] + problem->c[deletednode][assSP]);
							else varcost = problem->disCWSSP[preC1][assSP] - (problem->c[preC1][deletednode] + problem->disCWSSP[deletednode][assSP]);
							cStartS = PDS_MAX(cArrTimeI, problem->nodeSP[assSP].sTW2) + problem->nodeSP[assSP].unload;
						}
					}
			}
			
		    GoThroughVehicle(idVeh, nextT, varcost, varvioTWC, varvioTWSP, cStartS, assSP1, firstC_nextT);
			deleteCus[deletednode]->var_cost = varcost;
			deleteCus[deletednode]->var_vioTWC = varvioTWC;
			deleteCus[deletednode]->var_vioTWSP = varvioTWSP;
	}//end if (seg[idVeh].Trip[nextT].Type ==0)
}

void Solution::Update_deleteCusArrayP_LastTrip(int idVeh, int idTrip) //only applied for the case where vehicle has >= 2 trips
{
	int numC = seg[idVeh].Trip[idTrip].numCus;
	int assSP1, curC, preC, preC1;
	double varcost, varvioTWC, varvioTWSP, cStartS, cArrTime, cArrTimeI, temp;
	int vioCapNEW;
	int lastTrip = seg[idVeh].numTrips-1;
	int deletednode;

	int assSP = seg[idVeh].Trip[idTrip].assSP;
	deletednode = seg[idVeh].Trip[idTrip].firstCus;
	
	int preT = idTrip - 1; 
	if (seg[idVeh].Trip[preT].Type) 
	{
		preC1 = seg[idVeh].Trip[preT].lastCus;
		cStartS = depart[preC1];
	}
	else 
	{
		preC1 = seg[idVeh].Trip[preT].assSP;
		cStartS = seg[idVeh].Trip[preT].leaveSP;
	}	

	int capOLD = seg[idVeh].Trip[idTrip].capacity;
	int vioCapOLD = seg[idVeh].Trip[idTrip].vioCAP;
	int curC1 = nextArr[deletednode];

	int nextT = idTrip + 1;
	assSP1 = seg[idVeh].Trip[nextT].assSP;
	int firstC_nextT = seg[idVeh].Trip[nextT].firstCus;

	//1. Delete the first and middle pickup customers:
	while (curC1 > 0)
	{
		varvioTWC = 0; 
		varcost = problem->c[preC1][curC1] - (problem->c[preC1][deletednode] + problem->c[deletednode][curC1]);
		preC = preC1; curC = curC1;
		do
		{
			cArrTime = cStartS + problem->c[preC][curC];
			cStartS = PDS_MAX(cArrTime, problem->node[curC].sTW);
			if (PDSDIF(cStartS, startS[curC])== 0) goto Update;
			temp = cStartS - problem->node[curC].eTW;
			if (temp > eps)
			{
					varvioTWC += (temp - vioTWCus[curC]);
					if (vioTWCus[curC] > eps) goto Update;
			}
			cStartS += problem->node[curC].duration;
			preC = curC; curC = nextArr[curC];
		} while (curC > 0);
		calChangeCONNECTAtSP_PickTrip_FORDELETE(preC, idVeh, idTrip, cStartS, varvioTWSP, varcost);
		Update:
			deleteCus[deletednode]->var_cost = varcost;
			deleteCus[deletednode]->var_vioTWC = varvioTWC;
			deleteCus[deletednode]->var_vioTWSP = varvioTWSP;
			vioCapNEW = PDS_MAX(capOLD - problem->node[deletednode].capacity- problem->Q,0);
			deleteCus[deletednode]->var_vioCAP = vioCapNEW - vioCapOLD;

		//New delete customer:
		preC1 = deletednode; cStartS = depart[preC1];
		deletednode = curC1; curC1 = nextArr[curC1];
	}//end while (curC1 > 0)
	
	//2. Delete the last pickup customer:
	vioCapNEW = PDS_MAX(capOLD - problem->node[deletednode].capacity- problem->Q,0);
	deleteCus[deletednode]->var_vioCAP = vioCapNEW - vioCapOLD;
	deleteCus[deletednode]->var_vioTWC = -vioTWCus[deletednode];

	cArrTime = cStartS + problem->c[preC1][assSP];
	if (PDSINRANGE(cArrTime, problem->nodeSP[assSP].sTW2, problem->nodeSP[assSP].eTW2))
	{
		deleteCus[deletednode]->var_cost = problem->c[preC1][assSP] - (problem->c[preC1][deletednode] + problem->c[deletednode][assSP]);
		//before deletion has to go to sp directly: FEA OR INFEA
		deleteCus[deletednode]->var_vioTWSP = -seg[idVeh].Trip[idTrip].vioTWSP;
	}
	else
	{
			temp = cArrTime - problem->nodeSP[assSP].eTW2;
			if (temp > eps)
			{
				//before deletion has to go to sp directly: INFEA
				deleteCus[deletednode]->var_cost = problem->c[preC1][assSP] - (problem->c[preC1][deletednode] + problem->c[deletednode][assSP]);
				deleteCus[deletednode]->var_vioTWSP = temp - seg[idVeh].Trip[idTrip].vioTWSP;
			}
			else
			{
				cArrTimeI = cStartS + problem->disCWSSP[preC1][assSP];
				temp = cArrTimeI - problem->nodeSP[assSP].eTW2;
				if (temp > eps) //too soon to go sp directly, too late to go through WS:
				{
					deleteCus[deletednode]->var_vioTWSP = problem->nodeSP[assSP].sTW2 - cArrTime - seg[idVeh].Trip[idTrip].vioTWSP;
					//before deletion has to go to sp directly: FEA OR INFEA
					deleteCus[deletednode]->var_cost = problem->c[preC1][assSP] - (problem->c[preC1][deletednode] + problem->c[deletednode][assSP]);
				}
				else //to go through WS
				{
                    deleteCus[deletednode]->var_vioTWSP = -seg[idVeh].Trip[idTrip].vioTWSP;
					//before deletion may go to sp directly or through WS:
					if (seg[idVeh].Trip[idTrip].waitingS == NO_WS)
						deleteCus[deletednode]->var_cost = problem->disCWSSP[preC1][assSP] - (problem->c[preC1][deletednode] + problem->c[deletednode][assSP]);
					else 
						deleteCus[deletednode]->var_cost = problem->disCWSSP[preC1][assSP] - (problem->c[preC1][deletednode] + problem->disCWSSP[deletednode][assSP]);
				}
			}
	}
}

void Solution::GoThroughVehicle(int idVeh, int curT, double &varcost, double &varvioTWC, double &varvioTWSP, double cStartS, int preC, int curC)
{
	int preT, assSP;
	double cArrTime, temp;
	int lastTrip = seg[idVeh].numTrips - 1;
	bool stop;

	do
	{
		if (seg[idVeh].Trip[curT].Type)
		{
			while (curC > 0)
			{
				cArrTime = cStartS + problem->c[preC][curC];
				cStartS = PDS_MAX(cArrTime, problem->node[curC].sTW);
				if (PDSDIF(cStartS, startS[curC])==0) return;
				temp = cStartS - problem->node[curC].eTW;
				if (temp > eps)
				{
					varvioTWC += (temp - vioTWCus[curC]);
					if (vioTWCus[curC] > eps) return;
				}
				cStartS += problem->node[curC].duration;
				preC = curC; curC = nextArr[curC];
			}//end while (curC > 0)
			if (curT < lastTrip) //not the last trip yet: 
			{
				preT = curT; curT++; //preC now points to the last delivery cus of trip preT
				curC = seg[idVeh].Trip[curT].firstCus;
				if (seg[idVeh].Trip[curT].Type) // del trip - del trip
				{
				    stop = calChangeCONNECTAtSP_DD(preC, idVeh, curT, preT, cStartS, varvioTWSP, varcost);
					if (stop) return;
					preC = seg[idVeh].Trip[curT].assSP; 
				}
				/*else //del trip - pick trip
				{
					curC = seg[idVeh].Trip[curT].firstCus;
				}*/
			}//end if (curT < lastTrip) //not the last delivery trip yet
			else break; //cont = 0; already the last trip
		}
		else //if (seg[idVeh].Trip[curT].Type == 0)
		{
			while (curC > 0)
			{
				cArrTime = cStartS + problem->c[preC][curC];
				cStartS = PDS_MAX(cArrTime, problem->node[curC].sTW);
				if (PDSDIF(cStartS, startS[curC])==0) return;
				temp = cStartS - problem->node[curC].eTW;
				if (temp > eps)
				{
					varvioTWC += (temp - vioTWCus[curC]);
					if (vioTWCus[curC] > eps) return;
				}
				cStartS += problem->node[curC].duration;
				preC = curC; curC = nextArr[curC];
			} //end while (curC > 0)
		    stop = calChangeCONNECTAtSP_PickTrip(preC, idVeh, curT, cStartS, varvioTWSP, varcost);
			if (stop) return;
			if (curT < lastTrip) //not the last pickup trip yet:
			{
				preT = curT; curT++;
				assSP = seg[idVeh].Trip[preT].assSP;
				if (seg[idVeh].Trip[curT].Type) 
				{
					int assSP1 = seg[idVeh].Trip[curT].assSP;
					if (assSP == assSP1) //p-d trip
					{
						cStartS += problem->nodeSP[assSP].load;
						preC = assSP1;
						curC = seg[idVeh].Trip[curT].firstCus;
					}
					else //p - assSP - assSP1 - d
					{
						stop = calChangeCONNECTAtSP_SPSP(idVeh, curT, preT, cStartS, varvioTWSP, varcost);
						if (stop) return;
						preC = assSP1; curC = seg[idVeh].Trip[curT].firstCus;
					}//end p - assSP - assSP1 - d
				}
				else //if(seg[idVeh].Trip[curT].Type==0): p - p
				{
					preC = assSP;
					curC = seg[idVeh].Trip[curT].firstCus;
				}//end if (seg[idVeh].Trip[curT].Type==0)
			}
			else break; //cont = 0; curT is already the last pickup trip
		}//end trip curT is pickup
	}while (1);
}

bool Solution::GoThroughVehicle(int idVeh, int curT, int numTrips, double &varcost, double &varvioTWC, double &varvioTWSP, double cStartS, int preC, int curC)
{
	int preT, assSP;
	double cArrTime, temp;
	bool stop;

	for (int i=1; i <= numTrips;i++)
	{
		if (seg[idVeh].Trip[curT].Type)
		{
			while (curC > 0)
			{
				cArrTime = cStartS + problem->c[preC][curC];
				cStartS = PDS_MAX(cArrTime, problem->node[curC].sTW);
				if (PDSDIF(cStartS, startS[curC])==0) return 1;
				temp = cStartS - problem->node[curC].eTW;
				if (temp > eps)
				{
					varvioTWC += (temp - vioTWCus[curC]);
					if (vioTWCus[curC] > eps) return 1;
				}
				cStartS += problem->node[curC].duration;
				preC = curC; curC = nextArr[curC];
			}//end while (curC > 0)

			preT = curT; curT++; //preC now points to the last delivery cus of trip preT
			curC = seg[idVeh].Trip[curT].firstCus;
			if (seg[idVeh].Trip[curT].Type) // del trip - del trip
			{
				    stop = calChangeCONNECTAtSP_DD(preC, idVeh, curT, preT, cStartS, varvioTWSP, varcost);
					if (stop) return 1;
					preC = seg[idVeh].Trip[curT].assSP; 
			}
			/*else //del trip - pick trip
				{
					curC = seg[idVeh].Trip[curT].firstCus;
				}*/
		}
		else //if (seg[idVeh].Trip[curT].Type == 0)
		{
			while (curC > 0)
			{
				cArrTime = cStartS + problem->c[preC][curC];
				cStartS = PDS_MAX(cArrTime, problem->node[curC].sTW);
				if (PDSDIF(cStartS, startS[curC]) == 0) return 1;
				temp = cStartS - problem->node[curC].eTW;
				if (temp > eps)
				{
					varvioTWC += (temp - vioTWCus[curC]);
					if (vioTWCus[curC] > eps) return 1;
				}
				cStartS += problem->node[curC].duration;
				preC = curC; curC = nextArr[curC];
			} //end while (curC > 0)
		    stop = calChangeCONNECTAtSP_PickTrip(preC, idVeh, curT, cStartS, varvioTWSP, varcost);
			if (stop) return 1;
			preT = curT; curT++;
			assSP = seg[idVeh].Trip[preT].assSP;
			if (seg[idVeh].Trip[curT].Type) 
			{
				int assSP1 = seg[idVeh].Trip[curT].assSP;
				if (assSP == assSP1) //p-d trip
				{
					cStartS += problem->nodeSP[assSP].load;
					preC = assSP1;
					curC = seg[idVeh].Trip[curT].firstCus;
				}
				else //p - assSP - assSP1 - d
				{
					stop = calChangeCONNECTAtSP_SPSP(idVeh, curT, preT, cStartS, varvioTWSP, varcost);
					if (stop) return 1;
					preC = assSP1; curC = seg[idVeh].Trip[curT].firstCus;
				}//end p - assSP - assSP1 - d
			}
			else //if (seg[idVeh].Trip[curT].Type==0): p - p
			{
				preC = assSP;
				curC = seg[idVeh].Trip[curT].firstCus;
			}//end if (seg[idVeh].Trip[curT].Type==0)
		}//end trip curT is pickup
	}
	return 0;
}

bool Solution::calCONNECTCSPTOSPD_FORDELETE(int id1, int idVeh, int idTrip, double &cStartS, double &varvioTWSP, double &varcost)
{
	//calCONNECTCSPTOSPD_FORDELETE: Customer or SP to SPofDeliveryTrip
	//(idVeh, idTrip) is delivery trip 
	//calculate new cost (stored in varcost), varvioTWSP, cStartS when connecting a customer or sp id1 to assSP of delivery trip (idVeh, idTrip)
	int assSP = seg[idVeh].Trip[idTrip].assSP;
	double cArrTime = cStartS + problem->c[id1][assSP];
	
	if (PDSINRANGE(cArrTime, problem->nodeSP[assSP].sTW2, problem->nodeSP[assSP].eTW2))
	{
		varvioTWSP -= seg[idVeh].Trip[idTrip].vioTWSP;
		varcost += problem->c[id1][assSP];
		cStartS = cArrTime + problem->nodeSP[assSP].load;
	}
	else
	{
		double temp = cArrTime - problem->nodeSP[assSP].eTW2;
		if (temp > eps) //too late to go sp directly
		{
			varvioTWSP += (temp - seg[idVeh].Trip[idTrip].vioTWSP);
			varcost += problem->c[id1][assSP];
			//before deletion: also go to sp directly INFEASIBILITY
			return 1;
		}
		else
		{
			double cArrTimeI = cStartS + problem->disCWSSP[id1][assSP];
			temp = cArrTimeI - problem->nodeSP[assSP].eTW2;
			if (temp > eps) //too soon to go sp directly, too late through WS:
			{
				varvioTWSP += (problem->nodeSP[assSP].sTW2 - cArrTime - seg[idVeh].Trip[idTrip].vioTWSP);
				varcost += problem->c[id1][assSP];
				//before deletion: go to sp directly: INF OR FEA
				if (seg[idVeh].Trip[idTrip].vioTWSP > eps) return 1;
				cStartS = problem->leaveSP[assSP][1]; //load at eTW2
			}
			else //go through WS:
			{
				varvioTWSP -= seg[idVeh].Trip[idTrip].vioTWSP;
				varcost += problem->disCWSSP[id1][assSP];
				cStartS = PDS_MAX(cArrTimeI, problem->nodeSP[assSP].sTW2) + problem->nodeSP[assSP].load;
			}
		}
	}
	return 0;
}

bool Solution::calChangeCONNECTCSPTOSPD_FORDELETE(int id1, int idVeh, int idTrip, double &cStartS, double &varvioTWSP, double &varcost)
{
    //differ from calCONNECTCSPTOSPD_FORDELETE: 
	//calChangeCONNECTCSPTOSPD_FORDELETE: calculate the difference in varcost before and after deletion
	//calCONNECTCSPTOSPD_FORDELETE: calculate the new cost after deletion
	//(idVeh, idTrip) is delivery trip

	int assSP = seg[idVeh].Trip[idTrip].assSP;
	double cArrTime = cStartS + problem->c[id1][assSP];
	
	if (PDSINRANGE(cArrTime, problem->nodeSP[assSP].sTW2, problem->nodeSP[assSP].eTW2))
	{
		varvioTWSP -= seg[idVeh].Trip[idTrip].vioTWSP;
		//before deletion: go to sp directly FEA OR INFEA -->don't need to update varcost
		cStartS = cArrTime + problem->nodeSP[assSP].load;
	}
	else
	{
		double temp = cArrTime - problem->nodeSP[assSP].eTW2;
		if (temp > eps) //too late to go sp directly
		{
			varvioTWSP += (temp - seg[idVeh].Trip[idTrip].vioTWSP);
			//before deletion: too late to go to sp directly too --> don't need to update varcost
			return 1;
		}
		else
		{
			double cArrTimeI = cStartS + problem->disCWSSP[id1][assSP];
			temp = cArrTimeI - problem->nodeSP[assSP].eTW2;
			if (temp > eps) //too soon to go sp directly, too late through WS:
			{
				varvioTWSP += (problem->nodeSP[assSP].sTW2 - cArrTime - seg[idVeh].Trip[idTrip].vioTWSP);
				if (seg[idVeh].Trip[idTrip].vioTWSP > eps) return 1;
				//before deletion: go to sp directly: FEA OR INFEA --> donot need update varcost
				cStartS = problem->leaveSP[assSP][1]; //load at eTW2
			}
			else //go through WS:
			{
				varvioTWSP -= seg[idVeh].Trip[idTrip].vioTWSP;
				if (seg[idVeh].Trip[idTrip].waitingS == NO_WS)
					varcost += (problem->disCWSSP[id1][assSP]- problem->c[id1][assSP]);
				cStartS = PDS_MAX(cArrTimeI, problem->nodeSP[assSP].sTW2) + problem->nodeSP[assSP].load;
			}
		}
	}
	return 0;
}

bool Solution::calChangeCONNECTAtSP_DD(int lastC, int idVeh, int idTrip, int preT, double &cStartS, double &varvioTWSP, double &varcost)
{
	//calculte change in varcost, cStartS, varvioTWSP when connecting last delivery cus lastC of (idVeh, preT) with assSP of (idVeh, idTrip)
	int	assSP = seg[idVeh].Trip[idTrip].assSP;
	double cArrTime = cStartS + problem->c[lastC][assSP];
	
		if (PDSINRANGE(cArrTime, problem->nodeSP[assSP].sTW2, problem->nodeSP[assSP].eTW2))
		{
			varvioTWSP -= seg[idVeh].Trip[idTrip].vioTWSP;
			if (seg[idVeh].Trip[preT].waitingS != NO_WS)
				varcost += (problem->c[lastC][assSP] - problem->disCWSSP[lastC][assSP]);
			cStartS = cArrTime + problem->nodeSP[assSP].load; //load only
		}
		else
		{
			double temp = cArrTime - problem->nodeSP[assSP].eTW2;
			if (temp > eps)
			{
				varvioTWSP += (temp - seg[idVeh].Trip[idTrip].vioTWSP);
				if (seg[idVeh].Trip[idTrip].vioTWSP > eps) return 1;
				if (seg[idVeh].Trip[preT].waitingS != NO_WS)
					varcost += (problem->c[lastC][assSP] - problem->disCWSSP[lastC][assSP]);
				cStartS = problem->leaveSP[assSP][1]; //load only at eTW2
			}
			else
			{
				double cArrTimeI = cStartS + problem->disCWSSP[lastC][assSP];
				temp = cArrTimeI - problem->nodeSP[assSP].eTW2;
				if (temp > eps) //too soon to go to sp directly, too late to go through WS:
				{
					varvioTWSP += (problem->nodeSP[assSP].sTW2 - cArrTime - seg[idVeh].Trip[idTrip].vioTWSP);
					if (seg[idVeh].Trip[idTrip].vioTWSP > eps) return 1;
					if (seg[idVeh].Trip[preT].waitingS != NO_WS)
						varcost += (problem->c[lastC][assSP] - problem->disCWSSP[lastC][assSP]);
					cStartS = problem->leaveSP[assSP][1]; //load only at eTW2
				}
				else //now go through WS:
				{
					varvioTWSP -= seg[idVeh].Trip[idTrip].vioTWSP;
					if (seg[idVeh].Trip[preT].waitingS == NO_WS)
						varcost += (problem->disCWSSP[lastC][assSP] - problem->c[lastC][assSP]);
					cStartS = PDS_MAX(cArrTimeI, problem->nodeSP[assSP].sTW2) + problem->nodeSP[assSP].load;
				}
			}
		}
		return 0;
}

bool Solution::calChangeCONNECTAtSP_DD(int lastC, int idVeh, int idTrip, int preT, double &cStartS) //for procedure UpdateVehicle
{
	//calculte change in varcost, cStartS, varvioTWSP when connecting last delivery cus lastC of (idVeh, preT) with assSP of (idVeh, idTrip)
	int	assSP = seg[idVeh].Trip[idTrip].assSP;
	double varcost;
	double cArrTime = cStartS + problem->c[lastC][assSP];
	double varvioTWSP = -seg[idVeh].Trip[idTrip].vioTWSP;
	
		if (PDSINRANGE(cArrTime, problem->nodeSP[assSP].sTW2, problem->nodeSP[assSP].eTW2))
		{
			seg[idVeh].Trip[idTrip].vioTWSP = 0;
			if (seg[idVeh].Trip[preT].waitingS != NO_WS)
			{
				varcost = (problem->c[lastC][assSP] - problem->disCWSSP[lastC][assSP]);
				seg[idVeh].Trip[preT].waitingS = NO_WS;
				seg[idVeh].Trip[preT].connectCost = problem->c[lastC][assSP];
				seg[idVeh].Trip[preT].cost += varcost;
				seg[idVeh].Trip[preT].fitness += varcost;
			}
			cStartS = cArrTime + problem->nodeSP[assSP].load; //load only
		}
		else
		{
			double temp = cArrTime - problem->nodeSP[assSP].eTW2;
			if (temp > eps)
			{
				varvioTWSP += temp;
				if (seg[idVeh].Trip[idTrip].vioTWSP > eps)
				{
					seg[idVeh].Trip[idTrip].feasible = 0;
                    seg[idVeh].Trip[idTrip].vioTWSP = temp;				
					seg[idVeh].Trip[idTrip].fitness += (VTWSP * varvioTWSP);
					return 1;
				}
				seg[idVeh].Trip[idTrip].vioTWSP = temp;
				if (seg[idVeh].Trip[preT].waitingS != NO_WS)
				{
					varcost = (problem->c[lastC][assSP] - problem->disCWSSP[lastC][assSP]);
					seg[idVeh].Trip[preT].waitingS = NO_WS;
					seg[idVeh].Trip[preT].cost += varcost;
					seg[idVeh].Trip[preT].fitness += varcost;
					seg[idVeh].Trip[preT].connectCost = problem->c[lastC][assSP];
				}
				cStartS = problem->leaveSP[assSP][1]; //load only at eTW2
			}
			else
			{
				double cArrTimeI = cStartS + problem->disCWSSP[lastC][assSP];
				temp = cArrTimeI - problem->nodeSP[assSP].eTW2;
				if (temp > eps) //too soon to go to sp directly, too late to go through WS:
				{
					temp = problem->nodeSP[assSP].sTW2 - cArrTime;
					varvioTWSP += temp;
					if (seg[idVeh].Trip[idTrip].vioTWSP > eps) 
					{
						seg[idVeh].Trip[idTrip].feasible = 0;
						seg[idVeh].Trip[idTrip].vioTWSP = temp;
						seg[idVeh].Trip[idTrip].fitness += (VTWSP * varvioTWSP);
						return 1;
					}
					seg[idVeh].Trip[idTrip].vioTWSP = temp;
					if (seg[idVeh].Trip[preT].waitingS != NO_WS)
					{
						varcost = (problem->c[lastC][assSP] - problem->disCWSSP[lastC][assSP]);
						seg[idVeh].Trip[preT].waitingS = NO_WS;
						seg[idVeh].Trip[preT].cost += varcost;
						seg[idVeh].Trip[preT].fitness += varcost;
						seg[idVeh].Trip[preT].connectCost = problem->c[lastC][assSP];
					}
					cStartS = problem->leaveSP[assSP][1]; //load only at eTW2
				}
				else //now go through WS:
				{
					seg[idVeh].Trip[idTrip].vioTWSP = 0;
					
					if (seg[idVeh].Trip[preT].waitingS == NO_WS)
					{
						varcost = (problem->disCWSSP[lastC][assSP] - problem->c[lastC][assSP]);
						seg[idVeh].Trip[preT].cost += varcost;
						seg[idVeh].Trip[preT].fitness += varcost;
						seg[idVeh].Trip[preT].connectCost = problem->disCWSSP[lastC][assSP];
						seg[idVeh].Trip[preT].waitingS = problem->CWSSP[lastC][assSP];
					}
					cStartS = PDS_MAX(cArrTimeI, problem->nodeSP[assSP].sTW2) + problem->nodeSP[assSP].load;
				}
			}
		}
		seg[idVeh].Trip[idTrip].fitness += (VTWSP * varvioTWSP);
		if (PDSDIF(cStartS, seg[idVeh].Trip[idTrip].leaveSP)==0) 
		{
			if (seg[idVeh].Trip[idTrip].vioCAP > 0 || seg[idVeh].Trip[idTrip].vioTWC > eps || seg[idVeh].Trip[idTrip].vioTWSP > eps)
					seg[idVeh].Trip[idTrip].feasible = 0;
			else seg[idVeh].Trip[idTrip].feasible = 1;
			return 1;
		}
		seg[idVeh].Trip[idTrip].leaveSP = cStartS;
		return 0;
}

bool Solution::calChangeCONNECTAtSP_DD(int lastC, int idVeh, int idTrip, int preT, int varvioCAP, double varvioTWC, double varcost) //for deleteCusD and insertCusD procedure
{
	//calculte change in varcost, cStartS, varvioTWSP when connecting last delivery cus lastC of (idVeh, preT) with assSP of (idVeh, idTrip)
	int	assSP = seg[idVeh].Trip[idTrip].assSP;
	double cStartS;
	double cArrTime = depart[lastC] + problem->c[lastC][assSP];
	double varFIT = VCAP * varvioCAP + VTWCUS * varvioTWC;
	double varvioTWSP = -seg[idVeh].Trip[idTrip].vioTWSP;
	
		if (PDSINRANGE(cArrTime, problem->nodeSP[assSP].sTW2, problem->nodeSP[assSP].eTW2))
		{
			seg[idVeh].Trip[idTrip].vioTWSP = 0;
			if (seg[idVeh].Trip[preT].waitingS != NO_WS)
			{
				varcost += (problem->c[lastC][assSP] - problem->disCWSSP[lastC][assSP]);
				seg[idVeh].Trip[preT].waitingS = NO_WS;
				seg[idVeh].Trip[preT].connectCost = problem->c[lastC][assSP];
			}
			seg[idVeh].Trip[preT].cost += varcost;
			varFIT += varcost;
			seg[idVeh].Trip[preT].fitness += varFIT;
			cStartS = cArrTime + problem->nodeSP[assSP].load; //load only
		}
		else
		{
			double temp = cArrTime - problem->nodeSP[assSP].eTW2;
			if (temp > eps)
			{
				varvioTWSP += temp;
				if (seg[idVeh].Trip[idTrip].vioTWSP > eps)
				{
					seg[idVeh].Trip[idTrip].feasible = 0;
                    seg[idVeh].Trip[idTrip].vioTWSP = temp;				
					seg[idVeh].Trip[idTrip].fitness += (VTWSP * varvioTWSP);

					seg[idVeh].Trip[preT].cost += varcost;
					varFIT += varcost;
					seg[idVeh].Trip[preT].fitness += varFIT;

					varFIT += (VTWSP * varvioTWSP);
					seg[idVeh].cost += varcost; seg[idVeh].fitness += varFIT;
					seg[idVeh].vioCAP += varvioCAP; seg[idVeh].vioTWC += varvioTWC; seg[idVeh].vioTWSP += varvioTWSP;
					cost += varcost; fitness += varFIT;
					vioCAP += varvioCAP; vioTWC += varvioTWC; vioTWSP += varvioTWSP;
					return 1;
				}
				seg[idVeh].Trip[idTrip].vioTWSP = temp;
				if (seg[idVeh].Trip[preT].waitingS != NO_WS)
				{
					varcost += (problem->c[lastC][assSP] - problem->disCWSSP[lastC][assSP]);
					seg[idVeh].Trip[preT].waitingS = NO_WS;
					seg[idVeh].Trip[preT].connectCost = problem->c[lastC][assSP];
				}
				seg[idVeh].Trip[preT].cost += varcost;
				varFIT += varcost;
				seg[idVeh].Trip[preT].fitness += varFIT;

				cStartS = problem->leaveSP[assSP][1]; //load only at eTW2
			}
			else
			{
				double cArrTimeI = depart[lastC] + problem->disCWSSP[lastC][assSP];
				temp = cArrTimeI - problem->nodeSP[assSP].eTW2;
				if (temp > eps) //too soon to go to sp directly, too late to go through WS:
				{
					temp = problem->nodeSP[assSP].sTW2 - cArrTime;
					varvioTWSP += temp;
					if (seg[idVeh].Trip[idTrip].vioTWSP > eps) 
					{
						seg[idVeh].Trip[idTrip].feasible = 0;
						seg[idVeh].Trip[idTrip].vioTWSP = temp;
						seg[idVeh].Trip[idTrip].fitness += (VTWSP * varvioTWSP);

						seg[idVeh].Trip[preT].cost += varcost;
						varFIT += varcost;
						seg[idVeh].Trip[preT].fitness += varFIT;

						varFIT += (VTWSP * varvioTWSP);
						seg[idVeh].cost += varcost; seg[idVeh].fitness += varFIT;
						seg[idVeh].vioCAP += varvioCAP; seg[idVeh].vioTWC += varvioTWC; seg[idVeh].vioTWSP += varvioTWSP;
						cost += varcost; fitness += varFIT;
						vioCAP += varvioCAP; vioTWC += varvioTWC; vioTWSP += varvioTWSP;
						return 1;
					}
					seg[idVeh].Trip[idTrip].vioTWSP = temp;
					if (seg[idVeh].Trip[preT].waitingS != NO_WS)
					{
						varcost += (problem->c[lastC][assSP] - problem->disCWSSP[lastC][assSP]);
						seg[idVeh].Trip[preT].waitingS = NO_WS;
						seg[idVeh].Trip[preT].connectCost = problem->c[lastC][assSP];
					}
					seg[idVeh].Trip[preT].cost += varcost;
					varFIT += varcost;
					seg[idVeh].Trip[preT].fitness += varFIT;

					cStartS = problem->leaveSP[assSP][1]; //load only at eTW2
				}
				else //now go through WS:
				{
					seg[idVeh].Trip[idTrip].vioTWSP = 0;
					
					if (seg[idVeh].Trip[preT].waitingS == NO_WS)
					{
						varcost += (problem->disCWSSP[lastC][assSP] - problem->c[lastC][assSP]);
						seg[idVeh].Trip[preT].connectCost = problem->disCWSSP[lastC][assSP];
						seg[idVeh].Trip[preT].waitingS = problem->CWSSP[lastC][assSP];
					}
					seg[idVeh].Trip[preT].cost += varcost;
					varFIT += varcost;
					seg[idVeh].Trip[preT].fitness += varFIT;

					cStartS = PDS_MAX(cArrTimeI, problem->nodeSP[assSP].sTW2) + problem->nodeSP[assSP].load;
				}
			}
		}
		seg[idVeh].Trip[idTrip].fitness += (VTWSP * varvioTWSP);
		if (PDSDIF(cStartS, seg[idVeh].Trip[idTrip].leaveSP)==0) 
		{
			if (seg[idVeh].Trip[idTrip].vioCAP > 0 || seg[idVeh].Trip[idTrip].vioTWC > eps || seg[idVeh].Trip[idTrip].vioTWSP > eps)
					seg[idVeh].Trip[idTrip].feasible = 0;
			else seg[idVeh].Trip[idTrip].feasible = 1;

			varFIT += (VTWSP * varvioTWSP);
			seg[idVeh].cost += varcost; seg[idVeh].fitness += varFIT;
			seg[idVeh].vioCAP += varvioCAP; seg[idVeh].vioTWC += varvioTWC; seg[idVeh].vioTWSP += varvioTWSP;
			cost += varcost; fitness += varFIT;
			vioCAP += varvioCAP; vioTWC += varvioTWC; vioTWSP += varvioTWSP;
			return 1;
		}
		seg[idVeh].Trip[idTrip].leaveSP = cStartS;
		return 0;
}

bool Solution::calChangeCONNECTAtSP_DD(int lastC, int idVeh, int idTrip, int preT, int varvioCAP, double varvioTWC, double costTrip, double costOLD) //for twoOPTstarCusDTrip
{
		//calculte change in varcost, cStartS, varvioTWSP when connecting last delivery cus lastC of (idVeh, preT) with assSP of (idVeh, idTrip)
		int	assSP = seg[idVeh].Trip[idTrip].assSP;
		double cStartS, varFIT, varcost;
		double cArrTime = depart[lastC] + problem->c[lastC][assSP];
		double varvioTWSP = -seg[idVeh].Trip[idTrip].vioTWSP;
	
		if (PDSINRANGE(cArrTime, problem->nodeSP[assSP].sTW2, problem->nodeSP[assSP].eTW2))
		{
			seg[idVeh].Trip[idTrip].vioTWSP = 0;
			seg[idVeh].Trip[preT].waitingS = NO_WS;
			seg[idVeh].Trip[preT].connectCost = problem->c[lastC][assSP];
			cStartS = cArrTime + problem->nodeSP[assSP].load; //load only
		}
		else
		{
			double temp = cArrTime - problem->nodeSP[assSP].eTW2;
			if (temp > eps)
			{
				varvioTWSP += temp;
				if (seg[idVeh].Trip[idTrip].vioTWSP > eps)
				{
					seg[idVeh].Trip[idTrip].feasible = 0;
                    seg[idVeh].Trip[idTrip].vioTWSP = temp;				
					seg[idVeh].Trip[idTrip].fitness += (VTWSP * varvioTWSP);

					seg[idVeh].Trip[preT].waitingS = NO_WS;
					seg[idVeh].Trip[preT].connectCost = problem->c[lastC][assSP];
					seg[idVeh].Trip[preT].cost = costTrip + problem->c[lastC][assSP];
					varcost = seg[idVeh].Trip[preT].cost - costOLD;
					varFIT = varcost + VCAP * varvioCAP + VTWCUS * varvioTWC;
					seg[idVeh].Trip[preT].fitness += varFIT;

					varFIT += (VTWSP * varvioTWSP);
					seg[idVeh].cost += varcost; seg[idVeh].fitness += varFIT;
					seg[idVeh].vioCAP += varvioCAP; seg[idVeh].vioTWC += varvioTWC; seg[idVeh].vioTWSP += varvioTWSP;
					cost += varcost; fitness += varFIT;
					vioCAP += varvioCAP; vioTWC += varvioTWC; vioTWSP += varvioTWSP;
					return 1;
				}
				seg[idVeh].Trip[idTrip].vioTWSP = temp;
				seg[idVeh].Trip[preT].waitingS = NO_WS;
				seg[idVeh].Trip[preT].connectCost = problem->c[lastC][assSP];
				cStartS = problem->leaveSP[assSP][1]; //load only at eTW2
			}
			else
			{
				double cArrTimeI = depart[lastC] + problem->disCWSSP[lastC][assSP];
				temp = cArrTimeI - problem->nodeSP[assSP].eTW2;
				if (temp > eps) //too soon to go to sp directly, too late to go through WS:
				{
					temp = problem->nodeSP[assSP].sTW2 - cArrTime;
					varvioTWSP += temp;
					if (seg[idVeh].Trip[idTrip].vioTWSP > eps) 
					{
						seg[idVeh].Trip[idTrip].feasible = 0;
						seg[idVeh].Trip[idTrip].vioTWSP = temp;
						seg[idVeh].Trip[idTrip].fitness += (VTWSP * varvioTWSP);

						seg[idVeh].Trip[preT].waitingS = NO_WS;
						seg[idVeh].Trip[preT].connectCost = problem->c[lastC][assSP];
						seg[idVeh].Trip[preT].cost = costTrip + problem->c[lastC][assSP];
						varcost = seg[idVeh].Trip[preT].cost - costOLD;
						varFIT = varcost + VCAP * varvioCAP + VTWCUS * varvioTWC;
						seg[idVeh].Trip[preT].fitness += varFIT;

						varFIT += (VTWSP * varvioTWSP);
						seg[idVeh].cost += varcost; seg[idVeh].fitness += varFIT;
						seg[idVeh].vioCAP += varvioCAP; seg[idVeh].vioTWC += varvioTWC; seg[idVeh].vioTWSP += varvioTWSP;
						cost += varcost; fitness += varFIT;
						vioCAP += varvioCAP; vioTWC += varvioTWC; vioTWSP += varvioTWSP;
						return 1;
					}
					seg[idVeh].Trip[idTrip].vioTWSP = temp;
					seg[idVeh].Trip[preT].waitingS = NO_WS;
					seg[idVeh].Trip[preT].connectCost = problem->c[lastC][assSP];
					cStartS = problem->leaveSP[assSP][1]; //load only at eTW2
				}
				else //now go through WS:
				{
					seg[idVeh].Trip[idTrip].vioTWSP = 0;
					
					seg[idVeh].Trip[preT].waitingS = problem->CWSSP[lastC][assSP];
					seg[idVeh].Trip[preT].connectCost = problem->disCWSSP[lastC][assSP];
					cStartS = PDS_MAX(cArrTimeI, problem->nodeSP[assSP].sTW2) + problem->nodeSP[assSP].load;
				}
			}
		}
		
		seg[idVeh].Trip[idTrip].fitness += (VTWSP * varvioTWSP);
		seg[idVeh].Trip[preT].cost = costTrip + seg[idVeh].Trip[preT].connectCost;
		varcost = seg[idVeh].Trip[preT].cost - costOLD;
		varFIT = varcost + VCAP * varvioCAP + VTWCUS * varvioTWC;
		seg[idVeh].Trip[preT].fitness += varFIT;

		if (PDSDIF(cStartS, seg[idVeh].Trip[idTrip].leaveSP)==0) 
		{
			if (seg[idVeh].Trip[idTrip].vioCAP > 0 || seg[idVeh].Trip[idTrip].vioTWC > eps || seg[idVeh].Trip[idTrip].vioTWSP > eps)
					seg[idVeh].Trip[idTrip].feasible = 0;
			else seg[idVeh].Trip[idTrip].feasible = 1;

			varFIT += (VTWSP * varvioTWSP);
			seg[idVeh].cost += varcost; seg[idVeh].fitness += varFIT;
			seg[idVeh].vioCAP += varvioCAP; seg[idVeh].vioTWC += varvioTWC; seg[idVeh].vioTWSP += varvioTWSP;
			cost += varcost; fitness += varFIT;
			vioCAP += varvioCAP; vioTWC += varvioTWC; vioTWSP += varvioTWSP;
			return 1;
		}
		seg[idVeh].Trip[idTrip].leaveSP = cStartS;
		return 0;
}

bool Solution::calChangeCONNECTAtSP_DD_LastCChanged(int lastC, int idVeh, int idTrip, double &cStartS, double &varvioTWSP, double &varcost)
{
	//lastC of (idVeh, idTrip) is changed
	//calculte change in varcost, cStartS, varvioTWSP when connecting last delivery cus lastC of (idVeh, preT) with assSP of (idVeh, idTrip)
	int	assSP = seg[idVeh].Trip[idTrip].assSP;
	double cArrTime = cStartS + problem->c[lastC][assSP];
	
		if (PDSINRANGE(cArrTime, problem->nodeSP[assSP].sTW2, problem->nodeSP[assSP].eTW2))
		{
			varvioTWSP -= seg[idVeh].Trip[idTrip].vioTWSP;
			varcost += problem->c[lastC][assSP];
			cStartS = cArrTime + problem->nodeSP[assSP].load; //load only
		}
		else
		{
			double temp = cArrTime - problem->nodeSP[assSP].eTW2;
			if (temp > eps)
			{
				varvioTWSP += (temp - seg[idVeh].Trip[idTrip].vioTWSP);
				varcost += problem->c[lastC][assSP];
				if (seg[idVeh].Trip[idTrip].vioTWSP > eps) return 1;
				cStartS = problem->leaveSP[assSP][1]; //load only at eTW2
			}
			else
			{
				double cArrTimeI = cStartS + problem->disCWSSP[lastC][assSP];
				temp = cArrTimeI - problem->nodeSP[assSP].eTW2;
				if (temp > eps) //too soon to go to sp directly, too late to go through WS:
				{
					varvioTWSP += (problem->nodeSP[assSP].sTW2 - cArrTime - seg[idVeh].Trip[idTrip].vioTWSP);
					varcost += problem->c[lastC][assSP];
					if (seg[idVeh].Trip[idTrip].vioTWSP > eps) return 1;
					cStartS = problem->leaveSP[assSP][1]; //load only at eTW2
				}
				else //now go through WS:
				{
					varvioTWSP -= seg[idVeh].Trip[idTrip].vioTWSP;
					varcost += problem->disCWSSP[lastC][assSP];
					cStartS = PDS_MAX(cArrTimeI, problem->nodeSP[assSP].sTW2) + problem->nodeSP[assSP].load;
				}
			}
		}
		return 0;
}

bool Solution::calChangeCONNECTAtSP_DD_LastCChanged(int lastCOLD, int lastC, int idVeh, int curT, int preT, int varvioCAP, double varvioTWC, double varcost) //for deleteCusD and insertCusD procedure
{
	//lastC of (idVeh, preT) is changed
	//calculte change in varcost, cStartS, varvioTWSP when connecting last delivery cus lastC of (idVeh, preT) with assSP of (idVeh, curT)
	int	assSP = seg[idVeh].Trip[curT].assSP;
	
	if (seg[idVeh].Trip[preT].waitingS == NO_WS)
		varcost -= problem->c[lastCOLD][assSP];
	else varcost -= problem->disCWSSP[lastCOLD][assSP];

	double cArrTime = depart[lastC] + problem->c[lastC][assSP];
	double varFIT = VCAP * varvioCAP + VTWCUS * varvioTWC;
	double varvioTWSP = -seg[idVeh].Trip[curT].vioTWSP;
	double cStartS;

		if (PDSINRANGE(cArrTime, problem->nodeSP[assSP].sTW2, problem->nodeSP[assSP].eTW2))
		{
			seg[idVeh].Trip[curT].vioTWSP = 0;
			seg[idVeh].Trip[curT].fitness += (VTWSP * varvioTWSP);

			seg[idVeh].Trip[preT].waitingS = NO_WS;
			varcost += problem->c[lastC][assSP];
			seg[idVeh].Trip[preT].connectCost = problem->c[lastC][assSP];
			seg[idVeh].Trip[preT].cost += varcost;
			varFIT += varcost;
			seg[idVeh].Trip[preT].fitness += varFIT;
			cStartS = cArrTime + problem->nodeSP[assSP].load; //load only
		}
		else
		{
			double temp = cArrTime - problem->nodeSP[assSP].eTW2;
			if (temp > eps)
			{
				varvioTWSP += temp;
				
				seg[idVeh].Trip[preT].waitingS = NO_WS;
				varcost += problem->c[lastC][assSP];
				seg[idVeh].Trip[preT].connectCost = problem->c[lastC][assSP];
				seg[idVeh].Trip[preT].cost += varcost;
				varFIT += varcost;
				seg[idVeh].Trip[preT].fitness += varFIT;

				seg[idVeh].Trip[curT].fitness += (VTWSP * varvioTWSP);
				if (seg[idVeh].Trip[curT].vioTWSP > eps)
				{
					seg[idVeh].Trip[curT].feasible = 0;
					seg[idVeh].Trip[curT].vioTWSP = temp;
					varFIT += (VTWSP * varvioTWSP);
					seg[idVeh].vioTWC += varvioTWC; seg[idVeh].vioCAP += varvioCAP; seg[idVeh].vioTWSP += varvioTWSP;
					seg[idVeh].cost += varcost; seg[idVeh].fitness += varFIT;
					cost += varcost; fitness += varFIT; vioTWC += varvioTWC; vioCAP += varvioCAP; vioTWSP += varvioTWSP;
					return 1;
				}
				seg[idVeh].Trip[curT].vioTWSP = temp;
				cStartS = problem->leaveSP[assSP][1]; //load only at eTW2
			}
			else
			{
				double cArrTimeI = depart[lastC] + problem->disCWSSP[lastC][assSP];
				temp = cArrTimeI - problem->nodeSP[assSP].eTW2;
				if (temp > eps) //too soon to go to sp directly, too late to go through WS:
				{
					temp = problem->nodeSP[assSP].sTW2 - cArrTime;
					varvioTWSP += temp;
					seg[idVeh].Trip[preT].waitingS = NO_WS;
					varcost += problem->c[lastC][assSP];
					seg[idVeh].Trip[preT].connectCost = problem->c[lastC][assSP];
					seg[idVeh].Trip[preT].cost += varcost;
					varFIT += varcost;
					seg[idVeh].Trip[preT].fitness += varFIT;

					seg[idVeh].Trip[curT].fitness += (VTWSP * varvioTWSP);
					if (seg[idVeh].Trip[curT].vioTWSP > eps)
					{
						seg[idVeh].Trip[curT].feasible = 0;
						seg[idVeh].Trip[curT].vioTWSP = temp;
						varFIT += (VTWSP * varvioTWSP);
						seg[idVeh].cost += varcost; seg[idVeh].fitness += varFIT; 
						seg[idVeh].vioCAP += varvioCAP; seg[idVeh].vioTWC += varvioTWC; seg[idVeh].vioTWSP += varvioTWSP;
						cost += varcost; fitness += varFIT;
						vioCAP += varvioCAP; vioTWC += varvioTWC; vioTWSP += varvioTWSP;
						return 1;
					}
					seg[idVeh].Trip[curT].vioTWSP = temp;
					cStartS = problem->leaveSP[assSP][1]; //load only at eTW2
				}
				else //now go through WS:
				{
					seg[idVeh].Trip[curT].vioTWSP = 0;
					seg[idVeh].Trip[curT].fitness += (VTWSP * varvioTWSP);

					seg[idVeh].Trip[preT].waitingS = problem->CWSSP[lastC][assSP];
					varcost += problem->disCWSSP[lastC][assSP];
					seg[idVeh].Trip[preT].connectCost = problem->disCWSSP[lastC][assSP];
					seg[idVeh].Trip[preT].cost += varcost;
					varFIT += varcost;
					seg[idVeh].Trip[preT].fitness += varFIT;
					cStartS = PDS_MAX(cArrTimeI, problem->nodeSP[assSP].sTW2) + problem->nodeSP[assSP].load;
				}
			}
		}
		if (PDSDIF(cStartS, seg[idVeh].Trip[curT].leaveSP)==0)
		{
			if (seg[idVeh].Trip[curT].vioTWSP > eps || seg[idVeh].Trip[curT].vioCAP > 0 || seg[idVeh].Trip[curT].vioTWC > eps)
				seg[idVeh].Trip[curT].feasible = 0;
			else seg[idVeh].Trip[curT].feasible = 1;

			varFIT += (VTWSP * varvioTWSP);
			seg[idVeh].vioTWC += varvioTWC; seg[idVeh].vioCAP += varvioCAP; seg[idVeh].vioTWSP += varvioTWSP;
			seg[idVeh].cost += varcost; seg[idVeh].fitness += varFIT;
			cost += varcost; fitness += varFIT; vioTWC += varvioTWC; vioCAP += varvioCAP; vioTWSP += varvioTWSP;
			return 1;
		}
		seg[idVeh].Trip[curT].leaveSP = cStartS;
		return 0;
}

bool Solution::calChangeCONNECTAtSP_PickTrip(int lastC, int idVeh, int idTrip, double &cStartS, double &varvioTWSP, double &varcost)
{
	//calculate variation of varcost, varvioTWSP, cStartS when connecting lastC of pickup trip (idVeh, idTrip) with its assSP
	int	assSP = seg[idVeh].Trip[idTrip].assSP;
	double	cArrTime = cStartS + problem->c[lastC][assSP];

		if (PDSINRANGE(cArrTime, problem->nodeSP[assSP].sTW1, problem->nodeSP[assSP].eTW1))
		{
			varvioTWSP -= seg[idVeh].Trip[idTrip].vioTWSP;
			if (seg[idVeh].Trip[idTrip].waitingS != NO_WS)
				varcost += (problem->c[lastC][assSP] - problem->disCWSSP[lastC][assSP]);
			cStartS = cArrTime + problem->nodeSP[assSP].unload;
		}
		else
		{
			double temp = cArrTime - problem->nodeSP[assSP].eTW1;
			if (temp > eps)
			{
				varvioTWSP += (temp - seg[idVeh].Trip[idTrip].vioTWSP);
				if (seg[idVeh].Trip[idTrip].vioTWSP > eps) return 1;
				if (seg[idVeh].Trip[idTrip].waitingS != NO_WS)
					varcost += (problem->c[lastC][assSP] - problem->disCWSSP[lastC][assSP]);
				cStartS = problem->leaveSP[assSP][0]; //unload at eTW1
			}
			else
			{
				double cArrTimeI = cStartS + problem->disCWSSP[lastC][assSP];
				temp = cArrTimeI - problem->nodeSP[assSP].eTW1;
				if (temp > eps) //too soon to go sp directly, too late through WS
				{
					varvioTWSP += (problem->nodeSP[assSP].sTW1 - cArrTime - seg[idVeh].Trip[idTrip].vioTWSP);
					if (seg[idVeh].Trip[idTrip].vioTWSP > eps) return 1;
					if (seg[idVeh].Trip[idTrip].waitingS != NO_WS)
						varcost += (problem->c[lastC][assSP] - problem->disCWSSP[lastC][assSP]);
					cStartS = problem->leaveSP[assSP][0]; //unload only at eTW1
				}
				else //go through WS:
				{
					varvioTWSP -= seg[idVeh].Trip[idTrip].vioTWSP;
					if (seg[idVeh].Trip[idTrip].waitingS == NO_WS)
						varcost += (problem->disCWSSP[lastC][assSP] - problem->c[lastC][assSP]);
					cStartS = PDS_MAX(cArrTimeI, problem->nodeSP[assSP].sTW1) + problem->nodeSP[assSP].unload;
				}
			}
		}
		return 0;
}

bool Solution::calChangeCONNECTAtSP_PickTrip_LastCChanged(int lastC, int idVeh, int idTrip, double &cStartS, double &varvioTWSP, double &varcost)
{
	//lastC is new last cus
	//ALMOST AS SAME AS Solution::calChangeCONNECTAtSP_PickTrip
	//calculate variation of varcost, varvioTWSP, cStartS when connecting lastC of pickup trip (idVeh, idTrip) with its assSP
	int	assSP = seg[idVeh].Trip[idTrip].assSP;
	double	cArrTime = cStartS + problem->c[lastC][assSP];

		if (PDSINRANGE(cArrTime, problem->nodeSP[assSP].sTW1, problem->nodeSP[assSP].eTW1))
		{
			varvioTWSP -= seg[idVeh].Trip[idTrip].vioTWSP;
			varcost += problem->c[lastC][assSP];
			cStartS = cArrTime + problem->nodeSP[assSP].unload;
		}
		else
		{
			double temp = cArrTime - problem->nodeSP[assSP].eTW1;
			if (temp > eps)
			{
				varvioTWSP += (temp - seg[idVeh].Trip[idTrip].vioTWSP);
				varcost += problem->c[lastC][assSP];
				if (seg[idVeh].Trip[idTrip].vioTWSP > eps) return 1;
				cStartS = problem->leaveSP[assSP][0]; //unload at eTW1
			}
			else
			{
				double cArrTimeI = cStartS + problem->disCWSSP[lastC][assSP];
				temp = cArrTimeI - problem->nodeSP[assSP].eTW1;
				if (temp > eps) //too soon to go sp directly, too late through WS
				{
					varvioTWSP += (problem->nodeSP[assSP].sTW1 - cArrTime - seg[idVeh].Trip[idTrip].vioTWSP);
					varcost += problem->c[lastC][assSP];
					if (seg[idVeh].Trip[idTrip].vioTWSP > eps) return 1;
					cStartS = problem->leaveSP[assSP][0]; //unload only at eTW1
				}
				else //go through WS:
				{
					varvioTWSP -= seg[idVeh].Trip[idTrip].vioTWSP;
					varcost += problem->disCWSSP[lastC][assSP];
					cStartS = PDS_MAX(cArrTimeI, problem->nodeSP[assSP].sTW1) + problem->nodeSP[assSP].unload;
				}
			}
		}
		return 0;
}

bool Solution::calChangeCONNECTAtSP_PickTrip(int lastC, int idVeh, int idTrip, double &cStartS) //for procedure UpdateVehicle
{
	//calculate variation of varcost, varvioTWSP, cStartS when connecting lastC of pickup trip (idVeh, idTrip) with its assSP
	int	assSP = seg[idVeh].Trip[idTrip].assSP;
	double	cArrTime = cStartS + problem->c[lastC][assSP];
	double varcost;

	double varvioTWSP = -seg[idVeh].Trip[idTrip].vioTWSP;

		if (PDSINRANGE(cArrTime, problem->nodeSP[assSP].sTW1, problem->nodeSP[assSP].eTW1))
		{
			seg[idVeh].Trip[idTrip].vioTWSP = 0;
			if (seg[idVeh].Trip[idTrip].vioCAP > 0 || seg[idVeh].Trip[idTrip].vioTWC > eps)
				seg[idVeh].Trip[idTrip].feasible = 0;
			else seg[idVeh].Trip[idTrip].feasible = 1;

			if (seg[idVeh].Trip[idTrip].waitingS != NO_WS)
			{
				varcost = (problem->c[lastC][assSP] - problem->disCWSSP[lastC][assSP]);
			    seg[idVeh].Trip[idTrip].waitingS = NO_WS;
				seg[idVeh].Trip[idTrip].cost += varcost;
				seg[idVeh].Trip[idTrip].fitness += varcost;
			}
			cStartS = cArrTime + problem->nodeSP[assSP].unload;
		}
		else
		{
			double temp = cArrTime - problem->nodeSP[assSP].eTW1;
			if (temp > eps)
			{
				varvioTWSP += temp;
				seg[idVeh].Trip[idTrip].feasible = 0;
				if (seg[idVeh].Trip[idTrip].vioTWSP > eps)
				{
					seg[idVeh].Trip[idTrip].vioTWSP = temp;
					seg[idVeh].Trip[idTrip].fitness += (VTWSP * varvioTWSP);
					return 1;
				}
				if (seg[idVeh].Trip[idTrip].waitingS != NO_WS)
				{
					varcost = (problem->c[lastC][assSP] - problem->disCWSSP[lastC][assSP]);
					seg[idVeh].Trip[idTrip].cost += varcost;
					seg[idVeh].Trip[idTrip].fitness += varcost;
					seg[idVeh].Trip[idTrip].waitingS = NO_WS;
				}
				cStartS = problem->leaveSP[assSP][0]; //unload at eTW1
			}
			else
			{
				double cArrTimeI = cStartS + problem->disCWSSP[lastC][assSP];
				temp = cArrTimeI - problem->nodeSP[assSP].eTW1;
				if (temp > eps) //too soon to go sp directly, too late through WS
				{
					temp = problem->nodeSP[assSP].sTW1 - cArrTime;
					varvioTWSP += temp;
					seg[idVeh].Trip[idTrip].feasible = 0;
					if (seg[idVeh].Trip[idTrip].vioTWSP > eps)
					{
						seg[idVeh].Trip[idTrip].vioTWSP = temp;
						seg[idVeh].Trip[idTrip].fitness += (VTWSP * varvioTWSP);
						return 1;
					}
					if (seg[idVeh].Trip[idTrip].waitingS != NO_WS)
					{
						varcost = (problem->c[lastC][assSP] - problem->disCWSSP[lastC][assSP]);
						seg[idVeh].Trip[idTrip].waitingS = NO_WS;
						seg[idVeh].Trip[idTrip].cost += varcost;
						seg[idVeh].Trip[idTrip].fitness += varcost;
					}
					cStartS = problem->leaveSP[assSP][0]; //unload only at eTW1
				}
				else //go through WS:
				{
					if (seg[idVeh].Trip[idTrip].waitingS == NO_WS)
					{
						varcost = (problem->disCWSSP[lastC][assSP] - problem->c[lastC][assSP]);
						seg[idVeh].Trip[idTrip].waitingS = problem->CWSSP[lastC][assSP];
						seg[idVeh].Trip[idTrip].cost += varcost;
						seg[idVeh].Trip[idTrip].fitness += varcost;
					}
					seg[idVeh].Trip[idTrip].vioTWSP = 0;
					if (seg[idVeh].Trip[idTrip].vioCAP > 0 || seg[idVeh].Trip[idTrip].vioTWC > eps)
						seg[idVeh].Trip[idTrip].feasible = 0;
					else seg[idVeh].Trip[idTrip].feasible = 1;

					cStartS = PDS_MAX(cArrTimeI, problem->nodeSP[assSP].sTW1) + problem->nodeSP[assSP].unload;
				}
			}
		}
		seg[idVeh].Trip[idTrip].fitness += (VTWSP * varvioTWSP);
		if (PDSDIF(cStartS, seg[idVeh].Trip[idTrip].leaveSP)==0) return 1;
		seg[idVeh].Trip[idTrip].leaveSP = cStartS;
		return 0;
}

bool Solution::calChangeCONNECTAtSP_SPSP(int idVeh, int idTrip, int preT, double &cStartS, double &varvioTWSP, double &varcost)
{
	//calculate variation of varcost, varvioTWSP, cStartS when connecting assSP of pickup trip (idVeh, preT) with assSP1 of delivery trip (idVeh, idTrip)
	int assSP = seg[idVeh].Trip[preT].assSP;
	int assSP1 = seg[idVeh].Trip[idTrip].assSP;

	double cArrTime = cStartS + problem->c[assSP][assSP1];
	if (PDSINRANGE(cArrTime, problem->nodeSP[assSP1].sTW2, problem->nodeSP[assSP1].eTW2))
	{
		varvioTWSP -= seg[idVeh].Trip[idTrip].vioTWSP;
		if (seg[idVeh].Trip[preT].waitingS1 != NO_WS)
			varcost += (problem->c[assSP][assSP1] - problem->disCWSSP[assSP][assSP1]);
		cStartS = cArrTime + problem->nodeSP[assSP1].load;
	}
	else
	{
		double temp = cArrTime - problem->nodeSP[assSP1].eTW2;
		if (temp > eps)
		{
			varvioTWSP += (temp - seg[idVeh].Trip[idTrip].vioTWSP);
			if (seg[idVeh].Trip[idTrip].vioTWSP > eps) return 1;
			if (seg[idVeh].Trip[preT].waitingS1 != NO_WS)
				varcost += (problem->c[assSP][assSP1] - problem->disCWSSP[assSP][assSP1]);
			cStartS = problem->leaveSP[assSP1][1]; //load at eTW2
		}
		else
		{
			double cArrTimeI = cStartS + problem->disCWSSP[assSP][assSP1];
			temp = cArrTimeI - problem->nodeSP[assSP1].eTW2;
			if (temp > eps) //too soon to go sp directly, too late to go through WS:
			{
				varvioTWSP += (problem->nodeSP[assSP1].sTW2 - cArrTime - seg[idVeh].Trip[idTrip].vioTWSP);
				if (seg[idVeh].Trip[idTrip].vioTWSP > eps) return 1;
				if (seg[idVeh].Trip[preT].waitingS1 != NO_WS)
					varcost += (problem->c[assSP][assSP1] - problem->disCWSSP[assSP][assSP1]);
				cStartS = problem->leaveSP[assSP1][1]; //load at eTW2
			}
			else //go through WS:
			{
				varvioTWSP -= seg[idVeh].Trip[idTrip].vioTWSP;
				if (seg[idVeh].Trip[preT].waitingS1 == NO_WS)
					varcost += (problem->disCWSSP[assSP][assSP1] - problem->c[assSP][assSP1]);
				cStartS = PDS_MAX(cArrTimeI, problem->nodeSP[assSP1].sTW2) + problem->nodeSP[assSP1].load;
			}
		}
	}
	return 0;
}

bool Solution::calChangeCONNECTAtSP_PickTrip_FORDELETE(int lastC, int idVeh, int idTrip, double &cStartS, double &varvioTWSP, double &varcost)
{
	//calculate variation of varcost, varvioTWSP, cStartS when connecting lastC of pickup trip (idVeh, idTrip) with its assSP after delete one pickup customer of this trip
   //--> differ from calChangeCONNECTAtSP_PickTrip: 
	//calChangeCONNECTAtSP_PickTrip_FORDELETE: is called only when delete a pickup customer of (idVeh, idTrip)
	//calChangeCONNECTAtSP_PickTrip: is called when not delete but there is a change in startS

	int	assSP = seg[idVeh].Trip[idTrip].assSP;
	double	cArrTime = cStartS + problem->c[lastC][assSP];

		if (PDSINRANGE(cArrTime, problem->nodeSP[assSP].sTW1, problem->nodeSP[assSP].eTW1))
		{
			varvioTWSP = -seg[idVeh].Trip[idTrip].vioTWSP;
			//before deletion: go to sp directly: FEA OR INFEA --> don't need to update varcost
			cStartS = cArrTime + problem->nodeSP[assSP].unload;
		}
		else
		{
			double temp = cArrTime - problem->nodeSP[assSP].eTW1;
			if (temp > eps)
			{
				varvioTWSP = (temp - seg[idVeh].Trip[idTrip].vioTWSP);
				//before deletion: too late to go sp directly too --> don't need to update varcost
				return 1;
				cStartS = problem->leaveSP[assSP][0]; //unload at eTW1
			}
			else
			{
				double cArrTimeI = cStartS + problem->disCWSSP[lastC][assSP];
				temp = cArrTimeI - problem->nodeSP[assSP].eTW1;
				if (temp > eps) //too soon to go sp directly, too late through WS
				{
					varvioTWSP = (problem->nodeSP[assSP].sTW1 - cArrTime) - seg[idVeh].Trip[idTrip].vioTWSP;
					 //before deletion: to go sp directly FEA or INFEA --> don't need to update varcost
					if (seg[idVeh].Trip[idTrip].vioTWSP > eps) return 1;
					cStartS = problem->leaveSP[assSP][0]; //unload only at eTW1
				}
				else //go through WS:
				{
					varvioTWSP = -seg[idVeh].Trip[idTrip].vioTWSP;
					//before deletion: go to sp directly or through WS:
					if (seg[idVeh].Trip[idTrip].waitingS == NO_WS)
						varcost += (problem->disCWSSP[lastC][assSP] - problem->c[lastC][assSP]);
					cStartS = PDS_MAX(cArrTimeI, problem->nodeSP[assSP].sTW1) + problem->nodeSP[assSP].unload;
				}
			}
		}
		return 0;
}

bool Solution::calChangeCONNECTAtSP_SPSP(int idVeh, int idTrip, int preT, double &cStartS) //for procedure UpdateVehicle
{
	//calculate variation of varcost, varvioTWSP, cStartS when connecting assSP of pickup trip (idVeh, preT) with assSP1 of delivery trip (idVeh, idTrip)
	int assSP = seg[idVeh].Trip[preT].assSP;
	int assSP1 = seg[idVeh].Trip[idTrip].assSP;

	double cArrTime = cStartS + problem->c[assSP][assSP1];
	double varvioTWSP = -seg[idVeh].Trip[idTrip].vioTWSP;
    double varcost;

	if (PDSINRANGE(cArrTime, problem->nodeSP[assSP1].sTW2, problem->nodeSP[assSP1].eTW2))
	{
		if (seg[idVeh].Trip[preT].waitingS1 != NO_WS)
		{
			varcost = (problem->c[assSP][assSP1] - problem->disCWSSP[assSP][assSP1]);
			seg[idVeh].Trip[preT].waitingS1 = NO_WS;
			seg[idVeh].Trip[preT].connectCost = problem->c[assSP][assSP1];
			seg[idVeh].Trip[preT].cost += varcost;
			seg[idVeh].Trip[preT].fitness += varcost;
		}
		seg[idVeh].Trip[idTrip].vioTWSP = 0;
		cStartS = cArrTime + problem->nodeSP[assSP1].load;
	}
	else
	{
		double temp = cArrTime - problem->nodeSP[assSP1].eTW2;
		if (temp > eps)
		{
			varvioTWSP += temp;
			if (seg[idVeh].Trip[idTrip].vioTWSP > eps)
			{
				seg[idVeh].Trip[idTrip].vioTWSP = temp;
				seg[idVeh].Trip[idTrip].fitness += (VTWSP * varvioTWSP);
				seg[idVeh].Trip[idTrip].feasible = 0;
				return 1;
			}
			seg[idVeh].Trip[idTrip].vioTWSP = temp;
			if (seg[idVeh].Trip[preT].waitingS1 != NO_WS)
			{
				varcost = (problem->c[assSP][assSP1] - problem->disCWSSP[assSP][assSP1]);
				seg[idVeh].Trip[preT].waitingS1 = NO_WS;
				seg[idVeh].Trip[preT].connectCost = problem->c[assSP][assSP1];
				seg[idVeh].Trip[preT].cost += varcost;
				seg[idVeh].Trip[preT].fitness += varcost;
			}
			cStartS = problem->leaveSP[assSP1][1]; //load at eTW2
		}
		else
		{
			double cArrTimeI = cStartS + problem->disCWSSP[assSP][assSP1];
			temp = cArrTimeI - problem->nodeSP[assSP1].eTW2;
			if (temp > eps) //too soon to go sp directly, too late to go through WS:
			{
				temp = problem->nodeSP[assSP1].sTW2 - cArrTime;
				varvioTWSP += temp;
				if (seg[idVeh].Trip[idTrip].vioTWSP > eps)
				{
					seg[idVeh].Trip[idTrip].vioTWSP = temp;
					seg[idVeh].Trip[idTrip].fitness += (VTWSP * varvioTWSP);
					seg[idVeh].Trip[idTrip].feasible = 0;
					return 1;
				}
				seg[idVeh].Trip[idTrip].vioTWSP = temp;
				if (seg[idVeh].Trip[preT].waitingS1 != NO_WS)
				{
					varcost = (problem->c[assSP][assSP1] - problem->disCWSSP[assSP][assSP1]);
					seg[idVeh].Trip[preT].waitingS1 = NO_WS;
					seg[idVeh].Trip[preT].connectCost = problem->c[assSP][assSP1];
					seg[idVeh].Trip[preT].cost += varcost;
					seg[idVeh].Trip[preT].fitness += varcost;
				}
				cStartS = problem->leaveSP[assSP1][1]; //load at eTW2
			}
			else //go through WS:
			{
				seg[idVeh].Trip[idTrip].vioTWSP = 0;
				if (seg[idVeh].Trip[preT].waitingS1 == NO_WS)
				{
					varcost = (problem->disCWSSP[assSP][assSP1] - problem->c[assSP][assSP1]);
					seg[idVeh].Trip[preT].waitingS1 = problem->CWSSP[assSP][assSP1];
					seg[idVeh].Trip[preT].connectCost = problem->disCWSSP[assSP][assSP1];
					seg[idVeh].Trip[preT].cost += varcost;
					seg[idVeh].Trip[preT].fitness += varcost;
				}
				cStartS = PDS_MAX(cArrTimeI, problem->nodeSP[assSP1].sTW2) + problem->nodeSP[assSP1].load;
			}
		}
	}
	seg[idVeh].Trip[idTrip].fitness += (VTWSP * varvioTWSP);
	if (PDSDIF(seg[idVeh].Trip[idTrip].leaveSP, cStartS) == 0) 
	{
		if (seg[idVeh].Trip[idTrip].vioCAP > 0 || seg[idVeh].Trip[idTrip].vioTWC > eps || seg[idVeh].Trip[idTrip].vioTWSP > eps)
			seg[idVeh].Trip[idTrip].feasible = 0;
		else seg[idVeh].Trip[idTrip].feasible = 1;
		return 1;
	}
	seg[idVeh].Trip[idTrip].leaveSP = cStartS;
	return 0;
}

void Solution::cal_InsertCusDIntoEmptyVeh(int idCus, int startSP) //once we call this, that mean the solution has an empty vehicle:
{
	//don't need to check if there is an empty vehicle in the solution: numUsedVeh < numVeh
	double cArrTime = problem->leaveSP[startSP][4] + problem->c[startSP][idCus];
	double temp = cArrTime - problem->node[idCus].eTW;
	if (temp > eps)
		insertCusEmptyVeh[idCus]->var_vioTWC = temp;
	else
		insertCusEmptyVeh[idCus]->var_vioTWC=0;
	insertCusEmptyVeh[idCus]->var_cost = problem->c[0][startSP] + problem->c[startSP][idCus] + problem->c[idCus][0];
}

void Solution::cal_InsertCusDIAfterJ_LastC_LastTrip(int j, int k,int idVeh, int idTrip)
{
	int i = problem->node[j].neighborNode[k].id; //insert customer i after j
    double cArrTime, temp;

	cArrTime = depart[j] + problem->c[j][i];
	temp = cArrTime - problem->node[i].eTW;
	if (temp > eps) insertCus[j][k]->var_vioTWC = temp;
	else insertCus[j][k]->var_vioTWC = 0;
    insertCus[j][k]->var_cost = (problem->c[j][i] + problem->c[i][0]) - problem->c[j][0];
    insertCus[j][k]->var_vioTWSP = 0;
    insertCus[j][k]->var_vioCAP = PDS_MAX(seg[idVeh].Trip[idTrip].capacity + problem->node[i].capacity - problem->Q,0) - seg[idVeh].Trip[idTrip].vioCAP;

}

void Solution::cal_InsertCusDIAfterJ_NotLastC_LastTrip(int j, int k,int idVeh, int idTrip)
{
	int i = problem->node[j].neighborNode[k].id; //insert customer i after j
    double cArrTime, cStartS, temp;

	cArrTime = depart[j] + problem->c[j][i];
	temp = cArrTime - problem->node[i].eTW;
	int nextC = nextArr[j];

	    double vioTWCNEW = FvioTWCus[j];
		if (temp > eps)
		{
			vioTWCNEW += temp;
			cStartS = problem->node[i].depart;
		}
		else
			cStartS = PDS_MAX(cArrTime, problem->node[i].sTW) + problem->node[i].duration;

		int idcur = i; 
		insertCus[j][k]->var_cost = (problem->c[j][i] + problem->c[i][nextC]) - problem->c[j][nextC];
		insertCus[j][k]->var_vioCAP = PDS_MAX(seg[idVeh].Trip[idTrip].capacity + problem->node[i].capacity - problem->Q,0) - seg[idVeh].Trip[idTrip].vioCAP;
		insertCus[j][k]->var_vioTWSP = 0;

		do
		{
          cArrTime = cStartS + problem->c[idcur][nextC]; //Arrive Time to Customer nextC
		  temp = cArrTime - problem->node[nextC].eTW;
          if (temp > eps)
		  {
			  vioTWCNEW += temp;
			  if (vioTWCus[nextC] > eps) 
			  {
					insertCus[j][k]->var_vioTWC = vioTWCNEW - FvioTWCus[nextC];
				    return;
			  }
			  cStartS = problem->node[nextC].depart;
		  }
		  else
		  {
			  cStartS = PDS_MAX(cArrTime, problem->node[nextC].sTW) + problem->node[nextC].duration;
		  }
		  idcur=nextC; nextC= nextArr[nextC];
		}while (nextC > 0);
		insertCus[j][k]->var_vioTWC = vioTWCNEW - seg[idVeh].Trip[idTrip].vioTWC;
}

void Solution::cal_InsertCusDIAfterJ_LastC_NextTripP(int j, int k, int idVeh, int idTrip)
{
	int i = problem->node[j].neighborNode[k].id; //insert customer i after j
    double varcost, varvioTWC, varvioTWSP; 
    double cArrTime, cStartS, temp;

	int nextT = idTrip + 1;
	int firstC_nextT = seg[idVeh].Trip[nextT].firstCus;
   
	insertCus[j][k]->var_vioCAP = PDS_MAX(seg[idVeh].Trip[idTrip].capacity + problem->node[i].capacity - problem->Q,0) - seg[idVeh].Trip[idTrip].vioCAP;
    
	cArrTime = depart[j] + problem->c[j][i];
	temp = cArrTime - problem->node[i].eTW;
	if (temp > eps) 
	{
		varvioTWC = temp;
		cStartS = problem->node[i].depart;
	}
	else 
	{
		varvioTWC = 0;
		cStartS = PDS_MAX(cArrTime, problem->node[i].sTW) + problem->node[i].duration;
	}
	varcost = problem->c[j][i] + problem->c[i][firstC_nextT] - problem->c[j][firstC_nextT];
	varvioTWSP = 0;
	GoThroughVehicle(idVeh, nextT, varcost, varvioTWC, varvioTWSP, cStartS, i, firstC_nextT);
    insertCus[j][k]->var_vioTWC = varvioTWC;
    insertCus[j][k]->var_vioTWSP = varvioTWSP;
	insertCus[j][k]->var_cost = varcost;
}

void Solution::cal_InsertCusDIAfterJ_NotLastC_NextTripP(int j, int k, int idVeh, int idTrip)
{
	int i = problem->node[j].neighborNode[k].id; //insert customer i after j
    double varcost, varvioTWC, varvioTWSP; 
    double cArrTime, cStartS, temp;

	int nextT = idTrip + 1;
	int firstC_nextT = seg[idVeh].Trip[nextT].firstCus;
   
	insertCus[j][k]->var_vioCAP = PDS_MAX(seg[idVeh].Trip[idTrip].capacity + problem->node[i].capacity - problem->Q,0) - seg[idVeh].Trip[idTrip].vioCAP;
    
	cArrTime = depart[j] + problem->c[j][i];
	temp = cArrTime - problem->node[i].eTW;
	varvioTWC = FvioTWCus[j];
	if (temp > eps)
	{
		varvioTWC += temp;
		cStartS = problem->node[i].depart;
	}
	else cStartS = PDS_MAX(cArrTime, problem->node[i].sTW) + problem->node[i].duration;
	int nextC = nextArr[j];
	varcost = problem->c[j][i] + problem->c[i][nextC] - problem->c[j][nextC];
	int idcur = i;
	do
	{
		cArrTime = cStartS + problem->c[idcur][nextC];
		temp = cArrTime - problem->node[nextC].eTW;
		if (temp > eps)
		{
			 varvioTWC += temp;
			 if (vioTWCus[nextC] > eps)
			 {
				 insertCus[j][k]->var_vioTWC = varvioTWC - FvioTWCus[nextC];
				 insertCus[j][k]->var_vioTWSP = 0;
				 insertCus[j][k]->var_cost = varcost;
				 return;
			 }
			 cStartS = problem->node[nextC].depart;
		}
		else cStartS = PDS_MAX(cArrTime, problem->node[nextC].sTW) + problem->node[nextC].duration;
		idcur = nextC; nextC = nextArr[nextC];
	}while (nextC > 0);
	//idcur now points to the last delivery customer
	varvioTWC -= seg[idVeh].Trip[idTrip].vioTWC;
	varvioTWSP = 0;
    GoThroughVehicle(idVeh, nextT, varcost, varvioTWC, varvioTWSP, cStartS, idcur, firstC_nextT);
    insertCus[j][k]->var_vioTWC = varvioTWC;
    insertCus[j][k]->var_vioTWSP = varvioTWSP;
	insertCus[j][k]->var_cost = varcost;
}

void Solution::cal_InsertCusDIAfterJ_LastC_NextTripD(int j, int k, int idVeh, int idTrip)
{
	int i = problem->node[j].neighborNode[k].id; //insert customer i after j
    double varcost, varvioTWC, varvioTWSP; 
    double cArrTime, cStartS, temp;

	int nextT = idTrip + 1;
	int firstC_nextT = seg[idVeh].Trip[nextT].firstCus;
	int assSP1 = seg[idVeh].Trip[nextT].assSP;
   
	insertCus[j][k]->var_vioCAP = PDS_MAX(seg[idVeh].Trip[idTrip].capacity + problem->node[i].capacity - problem->Q,0) - seg[idVeh].Trip[idTrip].vioCAP;
    
	cArrTime = depart[j] + problem->c[j][i];
	temp = cArrTime - problem->node[i].eTW;
		if (temp > eps) 
		{
			varvioTWC = temp;
			cStartS = problem->node[i].depart;
		}
		else 
		{
			varvioTWC = 0;
			cStartS = PDS_MAX(cArrTime, problem->node[i].sTW) + problem->node[i].duration;
		}
		varcost = problem->c[j][i];

		cArrTime = cStartS + problem->c[i][assSP1];
		if (PDSINRANGE(cArrTime, problem->nodeSP[assSP1].sTW2, problem->nodeSP[assSP1].eTW2))
		{
			varvioTWSP = -seg[idVeh].Trip[nextT].vioTWSP;
			//before insertion may go to sp directly: FEA OR INFEA; OR go through WS:
			varcost += problem->c[i][assSP1];
			if (seg[idVeh].Trip[idTrip].waitingS == NO_WS)
				varcost -= problem->c[j][assSP1];
			else varcost -= problem->disCWSSP[j][assSP1];
			cStartS = cArrTime + problem->nodeSP[assSP1].load;
		}
		else
		{
			temp = cArrTime - problem->nodeSP[assSP1].eTW2;
			if (temp > eps)
			{
				varvioTWSP = temp - seg[idVeh].Trip[nextT].vioTWSP;
				varcost += problem->c[i][assSP1];
				//before insertion: may go to sp directly: FEA OR INFEA; OR go through WS
				if (seg[idVeh].Trip[idTrip].waitingS == NO_WS)
				{
					varcost -= problem->c[j][assSP1];
					if (seg[idVeh].Trip[nextT].vioTWSP > eps) goto Update;
				}
				else varcost -= problem->disCWSSP[j][assSP1];
				cStartS = problem->leaveSP[assSP1][1];//load only at eTW2
			}
			else
			{
				double cArrTimeI = cStartS + problem->disCWSSP[i][assSP1];
				temp = cArrTimeI - problem->nodeSP[assSP1].eTW2;
				if (temp > eps) //too soon to go sp directly, too late to go through WS:
				{
					varvioTWSP = problem->nodeSP[assSP1].sTW2 - cArrTime - seg[idVeh].Trip[nextT].vioTWSP;
					//before insertion has to go to sp directly: FEA OR INFEA; OR go through WS
					varcost += problem->c[i][assSP1];
					if (seg[idVeh].Trip[idTrip].waitingS == NO_WS)
					{
						varcost -= problem->c[j][assSP1];
					    if (seg[idVeh].Trip[nextT].vioTWSP > eps) goto Update;
					}
					else varcost -= problem->disCWSSP[j][assSP1];
					cStartS = problem->leaveSP[assSP1][1]; //load only at eTW2
				}
				else //to go through WS
				{
					varvioTWSP = -seg[idVeh].Trip[nextT].vioTWSP;
					//before insertion: go through WS too
					varcost += (problem->disCWSSP[i][assSP1] - problem->disCWSSP[j][assSP1]);
					cStartS = PDS_MAX(cArrTimeI, problem->nodeSP[assSP1].sTW2) + problem->nodeSP[assSP1].load;
				}
			}
		}
		GoThroughVehicle(idVeh, nextT, varcost, varvioTWC, varvioTWSP, cStartS, assSP1, firstC_nextT);
		Update:
			insertCus[j][k]->var_vioTWC = varvioTWC;
			insertCus[j][k]->var_vioTWSP = varvioTWSP;
			insertCus[j][k]->var_cost = varcost;
}

void Solution::cal_InsertCusDIAfterJ_NotLastC_NextTripD(int j, int k, int idVeh, int idTrip)
{
	int i = problem->node[j].neighborNode[k].id; //insert customer i after j
    double varcost, varvioTWC, varvioTWSP; 
    double cArrTime, cStartS, temp;

	int nextT = idTrip + 1;
	int firstC_nextT = seg[idVeh].Trip[nextT].firstCus;
	int assSP1 = seg[idVeh].Trip[nextT].assSP;
   
	insertCus[j][k]->var_vioCAP = PDS_MAX(seg[idVeh].Trip[idTrip].capacity + problem->node[i].capacity - problem->Q,0) - seg[idVeh].Trip[idTrip].vioCAP;
    
	cArrTime = depart[j] + problem->c[j][i];
	temp = cArrTime - problem->node[i].eTW;

	varvioTWC = FvioTWCus[j];
		if (temp > eps)
		{
			varvioTWC += temp;
			cStartS = problem->node[i].depart;
		}
		else cStartS = PDS_MAX(cArrTime, problem->node[i].sTW) + problem->node[i].duration;
		int nextC = nextArr[j];
		varcost = problem->c[j][i] + problem->c[i][nextC] - problem->c[j][nextC];
		int idcur = i;
		do
		{
			cArrTime = cStartS + problem->c[idcur][nextC];
			temp = cArrTime - problem->node[nextC].eTW;
			if (temp > eps)
			{
				 varvioTWC += temp;
				 if (vioTWCus[nextC] > eps)
				 {
					 insertCus[j][k]->var_vioTWC = varvioTWC - FvioTWCus[nextC];
					 insertCus[j][k]->var_vioTWSP = 0;
					 insertCus[j][k]->var_cost = varcost;
					 return;
				 }
				 cStartS = problem->node[nextC].depart;
			}
			else cStartS = PDS_MAX(cArrTime, problem->node[nextC].sTW) + problem->node[nextC].duration;
			idcur = nextC; nextC = nextArr[nextC];
		}while (nextC > 0);
		
		//idcur now points to the last delivery customer
		varvioTWC -= seg[idVeh].Trip[idTrip].vioTWC;
		cArrTime = cStartS + problem->c[idcur][assSP1];
		if (PDSINRANGE(cArrTime, problem->nodeSP[assSP1].sTW2, problem->nodeSP[assSP1].eTW2))
		{
			varvioTWSP = -seg[idVeh].Trip[nextT].vioTWSP;
			//before insertion may go to sp directly: FEA OR INFEA; OR go through WS:
			if (seg[idVeh].Trip[idTrip].waitingS != NO_WS)
				varcost += (problem->c[idcur][assSP1] - problem->disCWSSP[idcur][assSP1]);
			cStartS = cArrTime + problem->nodeSP[assSP1].load;
		}
		else
		{
			temp = cArrTime - problem->nodeSP[assSP1].eTW2;
			if (temp > eps)
			{
				varvioTWSP = temp - seg[idVeh].Trip[nextT].vioTWSP;
				//before insertion: may go to sp directly: FEA OR INFEA; OR go through WS
				if (seg[idVeh].Trip[idTrip].waitingS != NO_WS)
					varcost += (problem->c[idcur][assSP1] - problem->disCWSSP[j][assSP1]);
				else if (seg[idVeh].Trip[nextT].vioTWSP > eps) goto Update;
				cStartS = problem->leaveSP[assSP1][1];//load only at eTW2
			}
			else
			{
				double cArrTimeI = cStartS + problem->disCWSSP[i][assSP1];
				temp = cArrTimeI - problem->nodeSP[assSP1].eTW2;
				if (temp > eps) //too soon to go sp directly, too late to go through WS:
				{
					varvioTWSP = problem->nodeSP[assSP1].sTW2 - cArrTime - seg[idVeh].Trip[nextT].vioTWSP;
					//before insertion has to go to sp directly: FEA OR INFEA; OR go through WS
					if (seg[idVeh].Trip[idTrip].waitingS != NO_WS)
						varcost += (problem->c[idcur][assSP1] - problem->disCWSSP[j][assSP1]);
					else if (seg[idVeh].Trip[nextT].vioTWSP > eps) goto Update;
					cStartS = problem->leaveSP[assSP1][1]; //load only at eTW2
				}
				else //to go through WS
				{
					varvioTWSP = -seg[idVeh].Trip[nextT].vioTWSP;
					//before insertion: go through WS too
					cStartS = PDS_MAX(cArrTimeI, problem->nodeSP[assSP1].sTW2) + problem->nodeSP[assSP1].load;
				}
			}
		}
		
        GoThroughVehicle(idVeh, nextT, varcost, varvioTWC, varvioTWSP, cStartS, idcur, firstC_nextT);
		Update:
			insertCus[j][k]->var_vioTWC = varvioTWC;
			insertCus[j][k]->var_vioTWSP = varvioTWSP;
			insertCus[j][k]->var_cost = varcost;
}

bool Solution::SUBcal_InsertCusPIAfterJ_NotLastC(int j, int i, int idVeh, int idTrip, int &varvioCAP, double &varcost, double &varvioTWC, double &varvioTWSP, double &cStartS)
{
	varvioCAP = PDS_MAX(seg[idVeh].Trip[idTrip].capacity + problem->node[i].capacity - problem->Q, 0) - seg[idVeh].Trip[idTrip].vioCAP;

	double cArrTime, temp;
	
	cArrTime = depart[j] + problem->c[j][i];
	temp = cArrTime - problem->node[i].eTW;
	double vioTWCNEW = FvioTWCus[j];
	
	if (temp > eps)
	{
		vioTWCNEW += temp;
		cStartS = problem->node[i].depart;
	}
	else
		cStartS = PDS_MAX(cArrTime, problem->node[i].sTW) + problem->node[i].duration;
	
	int nextC = nextArr[j];
	varcost = problem->c[j][i] + problem->c[i][nextC] - problem->c[j][nextC];

	int idcur = i; 
	do
	{
          cArrTime = cStartS + problem->c[idcur][nextC]; //Arrive Time to Customer nextC
		  temp = cArrTime - problem->node[nextC].eTW;
          if (temp > eps)
		  {
			  vioTWCNEW += temp;
			  if (vioTWCus[nextC] > eps) 
			  {
					varvioTWC = vioTWCNEW - FvioTWCus[nextC];
					varvioTWSP = 0;
				    return 1;
			  }
			  cStartS = problem->node[nextC].depart;
		  }
		  else
			  cStartS = PDS_MAX(cArrTime, problem->node[nextC].sTW) + problem->node[nextC].duration;
		  idcur=nextC; nextC= nextArr[nextC];
	}while (nextC > 0);

	varvioTWC = vioTWCNEW - seg[idVeh].Trip[idTrip].vioTWC;

	int assSP = seg[idVeh].Trip[idTrip].assSP; 
    //idcur now points to the last customer
	cArrTime = cStartS + problem->c[idcur][assSP];
	if (PDSINRANGE(cArrTime, problem->nodeSP[assSP].sTW1, problem->nodeSP[assSP].eTW1))
	{
		//before insertion: go sp directly FEA OR INF; OR go through WS
		varvioTWSP = -seg[idVeh].Trip[idTrip].vioTWSP;
		if (seg[idVeh].Trip[idTrip].waitingS != NO_WS)
			varcost += (problem->c[idcur][assSP] - problem->disCWSSP[idcur][assSP]);
		cStartS = cArrTime + problem->nodeSP[assSP].unload;
	}
	else
	{
		temp = cArrTime - problem->nodeSP[assSP].eTW1;
		if (temp > eps) //too late to go sp directly
		{
			varvioTWSP = temp - seg[idVeh].Trip[idTrip].vioTWSP;
			//before insertion: go sp directly FEA OR INF; OR go through WS
			if (seg[idVeh].Trip[idTrip].vioTWSP > eps) return 1;
			if (seg[idVeh].Trip[idTrip].waitingS != NO_WS)
				varcost += (problem->c[idcur][assSP] - problem->disCWSSP[idcur][assSP]);
		}
		else
		{
			double cArrTimeI = cStartS + problem->disCWSSP[idcur][assSP];
			temp = cArrTimeI - problem->nodeSP[assSP].eTW1;
			if (temp > eps) //too soon to go sp directly, too late to go through WS:
			{
				varvioTWSP = problem->nodeSP[assSP].sTW1 - cArrTime - seg[idVeh].Trip[idTrip].vioTWSP;
				//before insertion: go sp directly FEA OR INF; OR go through WS
				if (seg[idVeh].Trip[idTrip].vioTWSP > eps) return 1;
				if (seg[idVeh].Trip[idTrip].waitingS != NO_WS)
					varcost += (problem->c[idcur][assSP] - problem->disCWSSP[idcur][assSP]);
			}
			else //go through WS:
			{
				varvioTWSP = 0;
				//before insertion: go through WS too --> donnt need to update varcost
			}
		}
	}
	return 0;
}

bool Solution::SUBcal_InsertCusPIAfterJ_LastC(int j, int i, int idVeh, int idTrip, int &varvioCAP, double &varcost, double &varvioTWC, double &varvioTWSP, double &cStartS) 
{
	varvioCAP = PDS_MAX(seg[idVeh].Trip[idTrip].capacity + problem->node[i].capacity - problem->Q, 0) - seg[idVeh].Trip[idTrip].vioCAP;
	varcost = problem->c[j][i];
	double cArrTime, temp;

	cArrTime = depart[j] + problem->c[j][i];
	temp = cArrTime - problem->node[i].eTW;
	if (temp > eps)
	{
		varvioTWC = temp;
		cStartS = problem->node[i].depart;
	}
	else
	{
		varvioTWC = 0;
		cStartS = PDS_MAX(cArrTime, problem->node[i].sTW) + problem->node[i].duration;
	}

	int assSP = seg[idVeh].Trip[idTrip].assSP; 
	cArrTime = cStartS + problem->c[i][assSP];
	if (PDSINRANGE(cArrTime, problem->nodeSP[assSP].sTW1, problem->nodeSP[assSP].eTW1))
	{
		//before insertion: go sp directly FEA OR INF; OR go through WS
		varvioTWSP = -seg[idVeh].Trip[idTrip].vioTWSP;
		varcost += problem->c[i][assSP];
		if (seg[idVeh].Trip[idTrip].waitingS == NO_WS)
			varcost -= problem->c[j][assSP];
		else varcost -= problem->disCWSSP[j][assSP];
		cStartS = cArrTime + problem->nodeSP[assSP].unload;
	}
	else
	{
		temp = cArrTime - problem->nodeSP[assSP].eTW1;
		if (temp > eps) //too late to go sp directly
		{
			varvioTWSP = temp - seg[idVeh].Trip[idTrip].vioTWSP;
			varcost += problem->c[i][assSP];
			//before insertion: go sp directly FEA OR INF; OR go through WS
			if (seg[idVeh].Trip[idTrip].waitingS == NO_WS)
			{
				varcost -= problem->c[j][assSP];
				if (seg[idVeh].Trip[idTrip].vioTWSP > eps) return 1;
			}
			else varcost -= problem->disCWSSP[j][assSP];			
			cStartS = problem->leaveSP[assSP][0]; //unload only at eTW1
		}
		else
		{
			double cArrTimeI = cStartS + problem->disCWSSP[i][assSP];
			temp = cArrTimeI - problem->nodeSP[assSP].eTW1;
			if (temp > eps) //too soon to go sp directly, too late to go through WS:
			{
				varvioTWSP = problem->nodeSP[assSP].sTW1 - cArrTime - seg[idVeh].Trip[idTrip].vioTWSP;
				varcost += problem->c[i][assSP];
				//before insertion: go sp directly FEA OR INF; OR go through WS
				if (seg[idVeh].Trip[idTrip].waitingS == NO_WS)
				{
					varcost -= problem->c[j][assSP];
					if (seg[idVeh].Trip[idTrip].vioTWSP > eps) return 1;
				}
				else varcost -= problem->disCWSSP[j][assSP];
				cStartS = problem->leaveSP[assSP][0]; //unload only at eTW1
			}
			else //go through WS:
			{
				varvioTWSP = 0;
				//before insertion: go through WS too
				varcost += (problem->disCWSSP[i][assSP] - problem->disCWSSP[j][assSP]);
				cStartS = PDS_MAX(cArrTimeI, problem->nodeSP[assSP].sTW1) + problem->nodeSP[assSP].unload;
			}
		}
	}
	return 0;
}

void Solution::cal_InsertCusPIAfterJ_LastC_NextTripP(int j, int i, int idVeh, int idTrip, int &varvioCAP, double &varcost, double &varvioTWC, double &varvioTWSP)
{
   double cStartS; 
   if (SUBcal_InsertCusPIAfterJ_LastC(j, i, idVeh, idTrip, varvioCAP, varcost, varvioTWC, varvioTWSP, cStartS)== 0)
   {
       int nextT = idTrip + 1;
       int firstC_nextT = seg[idVeh].Trip[nextT].firstCus;
       GoThroughVehicle(idVeh, nextT, varcost, varvioTWC, varvioTWSP, cStartS, seg[idVeh].Trip[idTrip].assSP, firstC_nextT);
   }
}

void Solution::cal_InsertCusPIAfterJ_LastC_NextTripD_SameSP(int j, int i, int idVeh, int idTrip, int &varvioCAP, double &varcost, double &varvioTWC, double &varvioTWSP)
{
   double cStartS; 
   if (SUBcal_InsertCusPIAfterJ_LastC(j, i, idVeh, idTrip, varvioCAP, varcost, varvioTWC, varvioTWSP, cStartS)== 0)
   {
		varvioTWSP *= 2;
		int assSP = seg[idVeh].Trip[idTrip].assSP;
		cStartS += problem->nodeSP[assSP].load;
	 
		int nextT = idTrip + 1;
 	    int firstC_nextT = seg[idVeh].Trip[nextT].firstCus;
		GoThroughVehicle(idVeh, nextT, varcost, varvioTWC, varvioTWSP, cStartS, assSP, firstC_nextT);
   }
}

void Solution::cal_InsertCusPIAfterJ_LastC_NextTripD_DifSP(int j, int i, int idVeh, int idTrip, int &varvioCAP, double &varcost, double &varvioTWC, double &varvioTWSP)
{
   double cStartS; 
   if (SUBcal_InsertCusPIAfterJ_LastC(j, i, idVeh, idTrip, varvioCAP, varcost, varvioTWC, varvioTWSP, cStartS)== 0)
   {
		int nextT = idTrip + 1;
 	    int firstC_nextT = seg[idVeh].Trip[nextT].firstCus;
		if (calChangeCONNECTAtSP_SPSP(idVeh, nextT, idTrip, cStartS, varvioTWSP, varcost) == 0)
			GoThroughVehicle(idVeh, nextT, varcost, varvioTWC, varvioTWSP, cStartS, seg[idVeh].Trip[nextT].assSP, firstC_nextT);
   }
}

void Solution::cal_InsertCusPIAfterJ_NotLastC_NextTripP(int j, int i, int idVeh, int idTrip, int &varvioCAP, double &varcost, double &varvioTWC, double &varvioTWSP)
{
   double cStartS; 
   if (SUBcal_InsertCusPIAfterJ_NotLastC(j, i, idVeh, idTrip, varvioCAP, varcost, varvioTWC, varvioTWSP, cStartS)== 0)
   {
       int nextT = idTrip + 1;
       int firstC_nextT = seg[idVeh].Trip[nextT].firstCus;
       GoThroughVehicle(idVeh, nextT, varcost, varvioTWC, varvioTWSP, cStartS, seg[idVeh].Trip[idTrip].assSP, firstC_nextT);
   }
}

void Solution::cal_InsertCusPIAfterJ_NotLastC_NextTripD_SameSP(int j, int i, int idVeh, int idTrip, int &varvioCAP, double &varcost, double &varvioTWC, double &varvioTWSP)
{
   double cStartS; 
   if (SUBcal_InsertCusPIAfterJ_NotLastC(j, i, idVeh, idTrip, varvioCAP, varcost, varvioTWC, varvioTWSP, cStartS)== 0)
   {
		varvioTWSP *=2;
		int assSP = seg[idVeh].Trip[idTrip].assSP;
		cStartS += problem->nodeSP[assSP].load;
	 
		int nextT = idTrip + 1;
 	    int firstC_nextT = seg[idVeh].Trip[nextT].firstCus;
		GoThroughVehicle(idVeh, nextT, varcost, varvioTWC, varvioTWSP, cStartS, assSP, firstC_nextT);
   }
}

void Solution::cal_InsertCusPIAfterJ_NotLastC_NextTripD_DifSP(int j, int i, int idVeh, int idTrip, int &varvioCAP, double &varcost, double &varvioTWC, double &varvioTWSP)
{
   double cStartS; 
   if (SUBcal_InsertCusPIAfterJ_NotLastC(j, i, idVeh, idTrip, varvioCAP, varcost, varvioTWC, varvioTWSP, cStartS)== 0)
   {
		int nextT = idTrip + 1;
 	    int firstC_nextT = seg[idVeh].Trip[nextT].firstCus;
		if (calChangeCONNECTAtSP_SPSP(idVeh, nextT, idTrip, cStartS, varvioTWSP, varcost) == 0)
			GoThroughVehicle(idVeh, nextT, varcost, varvioTWC, varvioTWSP, cStartS, seg[idVeh].Trip[nextT].assSP, firstC_nextT);
   }
}

void Solution::cal_MoveCusDIAfterJ_oneTrip_LastTrip(int j, int k, int idVeh, int idTrip)
{
    //ALMOST AS SAME AS Solution::cal_MoveCusDIAfterJ_oneTrip_nextTripP
	int i = problem->node[j].neighborNode[k].id; //insert customer i after j

	if (nextArr[j]==i) //i is already after j:
	{
		cout<<"ERROR cal_MoveCusDIAfterJ_oneTrip_LastTrip: nextArr[j] = i"<<endl;
		exit(-1);
	}

	int prei,suci, idcur, idnext, sucj;
	double vioTWCNEW, cArrTime, cStartS, temp, varcost;
	int assSP = seg[idVeh].Trip[idTrip].assSP;

	prei=predArr[i];suci=nextArr[i]; sucj = nextArr[j];
	//if (starti <startj)
	if (pos[i] < pos[j])
	{
		//remove i:
		if (prei > 0) 
		{
			vioTWCNEW = FvioTWCus[prei];
			cArrTime = depart[prei] + problem->c[prei][suci];
	        varcost = problem->c[prei][suci] - (problem->c[prei][i] + problem->c[i][suci]);
		}
		else //i is the first customer of the trip
		{
			vioTWCNEW = 0;
			cArrTime = seg[idVeh].Trip[idTrip].leaveSP + problem->c[assSP][suci];
            varcost = problem->c[assSP][suci] - (problem->c[assSP][i] + problem->c[i][suci]);
		}
		temp = cArrTime - problem->node[suci].eTW;
		if (temp > eps) 
		{
			vioTWCNEW += temp;
			cStartS = problem->node[suci].depart;
		}
		else cStartS = PDS_MAX(cArrTime, problem->node[suci].sTW) + problem->node[suci].duration;

		//from suci to j:
		idcur = suci;
		if (suci != j)
		{
			idnext = nextArr[suci];
			while (idnext != sucj)
			{
				cArrTime = cStartS + problem->c[idcur][idnext];
				temp = cArrTime - problem->node[idnext].eTW;
				if (temp > eps)
				{
					vioTWCNEW += temp;
					cStartS = problem->node[idnext].depart;
				}
				else cStartS = PDS_MAX(cArrTime, problem->node[idnext].sTW) + problem->node[idnext].duration;
				idcur = idnext; idnext = nextArr[idnext];
			}
		}

		//now idnext point to sucj; idcur is j:

		//insert i after j:
		cArrTime = cStartS + problem->c[idcur][i];
		temp = cArrTime - problem->node[i].eTW;
		if (temp > eps)
		{
			vioTWCNEW += temp;
			cStartS = problem->node[i].depart;
		}
		else cStartS = PDS_MAX(cArrTime, problem->node[i].sTW) + problem->node[i].duration;

		if (sucj >0)
		{
				varcost += ((problem->c[j][i] + problem->c[i][sucj]) - problem->c[j][sucj]);
				//check from sucj till the end of the trip:
				idcur=i; idnext=sucj;
				while (idnext >0)
				{
					cArrTime = cStartS + problem->c[idcur][idnext];
					temp = cArrTime - problem->node[idnext].eTW;
					if (temp > eps)
					{
						vioTWCNEW += temp;
						if (vioTWCus[idnext] > eps)
						{
							insertCus[j][k]->var_cost = varcost;
							insertCus[j][k]->var_vioTWC = vioTWCNEW - FvioTWCus[idnext];
							insertCus[j][k]->var_vioTWSP = 0;
							insertCus[j][k]->var_vioCAP = 0;
							return;
						}
						cStartS = problem->node[idnext].depart;
					}
					else cStartS = PDS_MAX(cArrTime, problem->node[idnext].sTW) + problem->node[idnext].duration;
					idcur = idnext;idnext = nextArr[idnext];
				}
		}
		else //j was the last del cus
		{idcur=i; varcost += (problem->c[j][i] + problem->c[i][0] - problem->c[j][0]);/*if (print) cout<<"problem->c[j][i] = "<<problem->c[j][i]<<endl;*/}
	}
	else // i after j and nextArr[j] != i:
	{
        vioTWCNEW = FvioTWCus[j];
		//insert i after j:
		cArrTime = depart[j] + problem->c[j][i];
		temp = cArrTime - problem->node[i].eTW;
		if (temp > eps)
		{
			vioTWCNEW += temp;
			cStartS = problem->node[i].depart;
		}
		else cStartS = PDS_MAX(cArrTime,problem->node[i].sTW) + problem->node[i].duration; //start service time of customer i
		
		//from i to sucj: because nextArr[j] !=i then sucj can not be the endSP:
		cArrTime = cStartS + problem->c[i][sucj];
		temp = cArrTime - problem->node[sucj].eTW;
		if (temp > eps)
		{
			vioTWCNEW += temp;
			cStartS = problem->node[sucj].depart;
		}
		else cStartS = PDS_MAX(cArrTime,problem->node[sucj].sTW) + problem->node[sucj].duration; //start service time of customer sucj
        varcost = problem->c[j][i] + problem->c[i][sucj] - problem->c[j][sucj];
		//cout<<"problem->c[j][i] = "<<problem->c[j][i]<<"; problem->c[i][sucj] = "<<problem->c[i][sucj]<<"; problem->c[j][sucj] = "<<problem->c[j][sucj]<<"; varcost = "<<varcost<<endl;  
		idcur = sucj; idnext = nextArr[sucj];
		//checking from sucj till prei:
		while (idnext != i)
		{
			cArrTime = cStartS + problem->c[idcur][idnext];
			temp = cArrTime - problem->node[idnext].eTW;
			if (temp > eps)
			{
				vioTWCNEW += temp;
				cStartS = problem->node[idnext].depart;
			}
			else cStartS = PDS_MAX(cArrTime,problem->node[idnext].sTW) + problem->node[idnext].duration; //start service time of customer idnext
            idcur = idnext; idnext = nextArr[idnext];
		}

		//now idcur points to prei:
		//from prei to suci & suci till the end of the trip:
		if (suci > 0) // i was not the last customer of the trip
		{
			varcost += (problem->c[prei][suci] - problem->c[prei][i] - problem->c[i][suci]);
			//cout<<"problem->c[prei][suci] = "<<problem->c[prei][suci]<<"; problem->c[prei][i] = "<<problem->c[prei][i]<<"; problem->c[i][suci] = "<<problem->c[i][suci]<<endl<<"; varcost = "<<varcost<<endl;
			idnext = suci;
			while (idnext > 0)
			{
				cArrTime = cStartS + problem->c[idcur][idnext];
				temp = cArrTime - problem->node[idnext].eTW;
				if (temp > eps)
				{
					vioTWCNEW += temp;
					if (vioTWCus[idnext] > eps) 
					{
						insertCus[j][k]->var_cost = varcost;
						insertCus[j][k]->var_vioTWC = vioTWCNEW - FvioTWCus[idnext];
						insertCus[j][k]->var_vioTWSP = 0;
						insertCus[j][k]->var_vioCAP = 0;
						return;
					}
					cStartS = problem->node[idnext].depart;
				}
				else cStartS = PDS_MAX(cArrTime,problem->node[idnext].sTW) + problem->node[idnext].duration; //start service time of customer idnext
				idcur = idnext; idnext = nextArr[idnext];
			}
		}
		else //i was the last customer of the trip:
		{
			varcost += (problem->c[prei][0] - problem->c[prei][i] - problem->c[i][0]);
		}
		//now idcur points to the NEW last delivery customer of the trip:
	}

	//idcur is now the last customer of the trip and cStartS is startService at the NEW last customer of current vehicle
	//Quangnn-- for compling: 3 lines
//    moveCusOneTrip[j][k]->var_vioTWSP = 0;
//    moveCusOneTrip[j][k]->var_vioTWC = vioTWCNEW - seg[idVeh].Trip[idTrip].vioTWC;
//	  moveCusOneTrip[j][k]->var_cost = varcost;
}

void Solution::cal_MoveCusDIAfterJ_oneTrip_NextTripP(int j, int k,int idVeh, int idTrip)
{
	int i = problem->node[j].neighborNode[k].id; //insert customer i after j
	if (route_num[i] != idVeh)
	{
		cout<<"ERROR Solution::cal_MoveCusDIAfterJ_oneTrip_NextTripP: route_num[i] != route_num[j]"<<endl;
		cout<<"i = "<<i<<": veh = "<<route_num[i]<<", trip = "<<trip_num[i]<<endl;
		cout<<"j = "<<j<<": veh = "<<route_num[j]<<", trip = "<<trip_num[j]<<endl;
		showTripCost(route_num[i], trip_num[i]);
		showTripCost(route_num[j], trip_num[j]);
		exit(-1);
	}

	if (trip_num[i] != trip_num[j])
	{
		cout<<"ERROR Solution::cal_MoveCusDIAfterJ_oneTrip_NextTripP: trip_num[i] != trip_num[j]"<<endl;
		cout<<"i = "<<i<<": veh = "<<route_num[i]<<", trip = "<<trip_num[i]<<endl;
		cout<<"j = "<<j<<": veh = "<<route_num[j]<<", trip = "<<trip_num[j]<<endl;
		showTripCost(route_num[i], trip_num[i]);
		showTripCost(route_num[j], trip_num[j]);
		exit(-1);
	}


	if (nextArr[j]==i) //i is already after j:
	{
		cout<<"ERROR cal_MoveCusDIAfterJ_oneTrip_NextTripP: nextArr[j] = i"<<endl;
		exit(-1);
	}

	int prei,suci, idcur, idnext, sucj;
	double vioTWCNEW, cArrTime, cStartS, temp,varcost;
	int assSP = seg[idVeh].Trip[idTrip].assSP;
	
	int nextTrip = idTrip + 1;
    int firstC_nextT = seg[idVeh].Trip[nextTrip].firstCus;

    prei=predArr[i];suci=nextArr[i]; sucj = nextArr[j];
	//if (starti <startj)
	if (pos[i]<pos[j])
	{
		//remove i:
		if (prei>0) 
		{
			vioTWCNEW = FvioTWCus[prei];
			cArrTime = depart[prei] + problem->c[prei][suci];
	        varcost = problem->c[prei][suci] - (problem->c[prei][i] + problem->c[i][suci]);
		}
		else //i is the first customer of the trip
		{
			vioTWCNEW = 0;
			cArrTime = seg[idVeh].Trip[idTrip].leaveSP + problem->c[assSP][suci];
            varcost = problem->c[assSP][suci] - (problem->c[assSP][i] + problem->c[i][suci]);
		}
		temp = cArrTime - problem->node[suci].eTW;
		if(temp > eps)
		{
			vioTWCNEW +=temp;
			cStartS = problem->node[suci].depart;
		}
		else cStartS = PDS_MAX(cArrTime, problem->node[suci].sTW) + problem->node[suci].duration;

		//from suci to j:
		idcur = suci;
		if (suci != j)
		{
			idnext = nextArr[suci];
			while (idnext != sucj)
			{
				cArrTime = cStartS + problem->c[idcur][idnext];
				temp = cArrTime - problem->node[idnext].eTW;
				if (temp > eps)
				{
					vioTWCNEW +=temp;
					cStartS = problem->node[idnext].depart;
				}
				else cStartS = PDS_MAX(cArrTime, problem->node[idnext].sTW) + problem->node[idnext].duration;
				idcur = idnext; idnext = nextArr[idnext];
			}
		}

		//now idnext point to sucj; idcur is j:
		//insert i after j:

		cArrTime = cStartS + problem->c[idcur][i];
		temp = cArrTime - problem->node[i].eTW;
		if (temp > eps)
		{
			vioTWCNEW += temp;
			cStartS = problem->node[i].depart;
		}
		else cStartS = PDS_MAX(cArrTime, problem->node[i].sTW) + problem->node[i].duration; //start service time at customer i
	
		if (sucj >0)
		{
			varcost += ((problem->c[j][i] + problem->c[i][sucj]) - problem->c[j][sucj]);
			//check from sucj till the end of the trip:
			idcur=i; idnext=sucj;
			while (idnext >0)
			{
				cArrTime = cStartS + problem->c[idcur][idnext];
				temp = cArrTime - problem->node[idnext].eTW;
				if (temp > eps)
				{
					vioTWCNEW += temp;
					if (vioTWCus[idnext] > eps)
					{
							insertCus[j][k]->var_cost = varcost;
							insertCus[j][k]->var_vioTWC = vioTWCNEW - FvioTWCus[idnext];
							insertCus[j][k]->var_vioTWSP = 0;
							insertCus[j][k]->var_vioCAP = 0;
							return;
					}
					cStartS = problem->node[idnext].depart;
				}
				else cStartS = PDS_MAX(cArrTime, problem->node[idnext].sTW) + problem->node[idnext].duration;
				idcur = idnext;idnext = nextArr[idnext];
			}
		} //j was the last del cus
		else 
		{
			idcur=i; 
			varcost += (problem->c[j][i] + problem->c[i][firstC_nextT] - problem->c[j][firstC_nextT]);/*if (print) cout<<"problem->c[j][i] = "<<problem->c[j][i]<<endl;*/}
	}
	else // i after j and nextArr[j] !=i:
	{
        vioTWCNEW = FvioTWCus[j];
		//insert i after j:
		cArrTime = depart[j] + problem->c[j][i];
		temp = cArrTime - problem->node[i].eTW;
		if (temp > eps)
		{
			vioTWCNEW += temp;
			cStartS = problem->node[i].depart;
		}
		else cStartS = PDS_MAX(cArrTime,problem->node[i].sTW) + problem->node[i].duration; //start service time of customer i
	
		//from i to sucj: because nextArr[j] !=i then sucj can not be the endSP:
		cArrTime = cStartS + problem->c[i][sucj];
		temp = cArrTime - problem->node[sucj].eTW;
		if (temp > eps)
		{
			vioTWCNEW += temp;
			cStartS = problem->node[sucj].depart;
		}
		else cStartS = PDS_MAX(cArrTime,problem->node[sucj].sTW) + problem->node[sucj].duration; //start service time of customer sucj
		
		varcost = problem->c[j][i] + problem->c[i][sucj] - problem->c[j][sucj];
		//cout<<"problem->c[j][i] = "<<problem->c[j][i]<<"; problem->c[i][sucj] = "<<problem->c[i][sucj]<<"; problem->c[j][sucj] = "<<problem->c[j][sucj]<<"; varcost = "<<varcost<<endl;  
		idcur = sucj; idnext = nextArr[sucj];
		
		//checking from sucj till prei:
		while (idnext != i)
		{
			cArrTime = cStartS + problem->c[idcur][idnext];
			temp = cArrTime - problem->node[idnext].eTW;
			if (temp > eps)
			{
				vioTWCNEW += temp;
				cStartS = problem->node[idnext].depart;
			}
			else
				cStartS = PDS_MAX(cArrTime, problem->node[idnext].sTW) + problem->node[idnext].duration; //start service time of customer idnext
		    idcur = idnext; idnext = nextArr[idnext];
		}

        //now idcur points to prei:
		//from prei to suci & suci till the end of the leg:
		if (suci>0) // i was not the last customer of the leg
		{
			varcost += (problem->c[prei][suci] - problem->c[prei][i] - problem->c[i][suci]);
			//cout<<"problem->c[prei][suci] = "<<problem->c[prei][suci]<<"; problem->c[prei][i] = "<<problem->c[prei][i]<<"; problem->c[i][suci] = "<<problem->c[i][suci]<<endl<<"; varcost = "<<varcost<<endl;
			idnext = suci;
			while (idnext > 0)
			{
				cArrTime = cStartS + problem->c[idcur][idnext];
				temp = cArrTime - problem->node[idnext].eTW;
				if (temp > eps)
				{
					vioTWCNEW += temp;
					if (vioTWCus[idnext] > eps)
					{
                        insertCus[j][k]->var_cost = varcost;
						insertCus[j][k]->var_vioTWC = vioTWCNEW - FvioTWCus[idnext];
						insertCus[j][k]->var_vioTWSP = 0;
						insertCus[j][k]->var_vioCAP = 0;
					}
					cStartS = problem->node[idnext].depart;
				}
				else cStartS = PDS_MAX(cArrTime, problem->node[idnext].sTW) + problem->node[idnext].duration; //start service time of customer idnext
				idcur = idnext; idnext = nextArr[idnext];
			}
		}
		else //i was the last customer of the trip:
		{
			varcost += (problem->c[prei][firstC_nextT] - problem->c[prei][i] - problem->c[i][firstC_nextT]);
			//cout<<"problem->c[prei][i] = "<<problem->c[prei][i]<<"; varcost = "<<varcost<<endl;
		}
		//now idcur points to the last delivery customer of the trip:
	}

	//idcur is now the last customer of the trip and cStartS is time to leave the NEW last customer of current vehicle

	double varvioTWC = vioTWCNEW - seg[idVeh].Trip[idTrip].vioTWC;
	double varvioTWSP = 0;
    GoThroughVehicle(idVeh, nextTrip, varcost, varvioTWC, varvioTWSP, cStartS, idcur, firstC_nextT);
	//Quangnn-- for compling: 3 lines
//    moveCusOneTrip[j][k]->var_vioTWSP = varvioTWSP;
//    moveCusOneTrip[j][k]->var_vioTWC = varvioTWC;
//    moveCusOneTrip[j][k]->var_cost = varcost;
}

void Solution::cal_MoveCusDIAfterJ_oneTrip_NextTripD(int j, int k,int idVeh, int idTrip)
{
	int i = problem->node[j].neighborNode[k].id; //insert customer i after j
	if (route_num[i] != idVeh)
	{
		cout<<"ERROR Solution::cal_MoveCusDIAfterJ_oneTrip_NextTripP: route_num[i] != route_num[j]"<<endl;
		cout<<"i = "<<i<<": veh = "<<route_num[i]<<", trip = "<<trip_num[i]<<endl;
		cout<<"j = "<<j<<": veh = "<<route_num[j]<<", trip = "<<trip_num[j]<<endl;
		showTripCost(route_num[i], trip_num[i]);
		showTripCost(route_num[j], trip_num[j]);
		exit(-1);
	}

	if (trip_num[i] != trip_num[j])
	{
		cout<<"ERROR Solution::cal_MoveCusDIAfterJ_oneTrip_NextTripP: trip_num[i] != trip_num[j]"<<endl;
		cout<<"i = "<<i<<": veh = "<<route_num[i]<<", trip = "<<trip_num[i]<<endl;
		cout<<"j = "<<j<<": veh = "<<route_num[j]<<", trip = "<<trip_num[j]<<endl;
		showTripCost(route_num[i], trip_num[i]);
		showTripCost(route_num[j], trip_num[j]);
		exit(-1);
	}


	if (nextArr[j]==i) //i is already after j:
	{
		cout<<"ERROR Solution::cal_MoveCusDIAfterJ_oneTrip_NextTripP: nextArr[j] = i"<<endl;
		exit(-1);
	}

	int prei,suci, idcur, idnext, sucj;
	double vioTWCNEW, cArrTime, cStartS, temp,varcost;
	
	int assSP = seg[idVeh].Trip[idTrip].assSP;
	
	int nextTrip = idTrip + 1;
	int assSP1 = seg[idVeh].Trip[nextTrip].assSP;
    int firstC_nextT = seg[idVeh].Trip[nextTrip].firstCus;

    prei=predArr[i];suci=nextArr[i]; sucj = nextArr[j];
	bool lastCChanged = 0;


	//if (starti <startj)
	if (pos[i]<pos[j])
	{
		//remove i:
		if (prei>0) 
		{
			vioTWCNEW = FvioTWCus[prei];
			cArrTime = depart[prei] + problem->c[prei][suci];
	        varcost = problem->c[prei][suci] - (problem->c[prei][i] + problem->c[i][suci]);
		}
		else //i is the first customer of the trip
		{
			vioTWCNEW = 0;
			cArrTime = seg[idVeh].Trip[idTrip].leaveSP + problem->c[assSP][suci];
            varcost = problem->c[assSP][suci] - (problem->c[assSP][i] + problem->c[i][suci]);
		}
		temp = cArrTime - problem->node[suci].eTW;
		if(temp > eps)
		{
			vioTWCNEW +=temp;
			cStartS = problem->node[suci].depart;
		}
		else cStartS = PDS_MAX(cArrTime, problem->node[suci].sTW) + problem->node[suci].duration;

		//from suci to j:
		idcur = suci;
		if (suci != j)
		{
			idnext = nextArr[suci];
			while (idnext != sucj)
			{
				cArrTime = cStartS + problem->c[idcur][idnext];
				temp = cArrTime - problem->node[idnext].eTW;
				if (temp > eps)
				{
					vioTWCNEW +=temp;
					cStartS = problem->node[idnext].depart;
				}
				else cStartS = PDS_MAX(cArrTime, problem->node[idnext].sTW) + problem->node[idnext].duration;
				idcur = idnext; idnext = nextArr[idnext];
			}
		}

		//now idnext point to sucj; idcur is j:
		//insert i after j:

		cArrTime = cStartS + problem->c[idcur][i];
		temp = cArrTime - problem->node[i].eTW;
		if (temp > eps)
		{
			vioTWCNEW += temp;
			cStartS = problem->node[i].depart;
		}
		else cStartS = PDS_MAX(cArrTime, problem->node[i].sTW) + problem->node[i].duration; //start service time at customer i
	
		if (sucj >0)
		{
			varcost += ((problem->c[j][i] + problem->c[i][sucj]) - problem->c[j][sucj]);
			//check from sucj till the end of the trip:
			idcur=i; idnext=sucj;
			while (idnext >0)
			{
				cArrTime = cStartS + problem->c[idcur][idnext];
				temp = cArrTime - problem->node[idnext].eTW;
				if (temp > eps)
				{
					vioTWCNEW += temp;
					if (vioTWCus[idnext] > eps)
					{
							insertCus[j][k]->var_cost = varcost;
							insertCus[j][k]->var_vioTWC = vioTWCNEW - FvioTWCus[idnext];
							insertCus[j][k]->var_vioTWSP = 0;
							insertCus[j][k]->var_vioCAP = 0;
							return;
					}
					cStartS = problem->node[idnext].depart;
				}
				else cStartS = PDS_MAX(cArrTime, problem->node[idnext].sTW) + problem->node[idnext].duration;
				idcur = idnext;idnext = nextArr[idnext];
			}
		} 
		else //j was the last del cus  --> i is now new lastCus
		{
			lastCChanged = 1;
			idcur=i; 
			varcost += problem->c[j][i];
			if (seg[idVeh].Trip[idTrip].waitingS == NO_WS)
				varcost -= problem->c[j][assSP1];
			else varcost -= problem->disCWSSP[j][assSP1];
		}
	}
	else // i after j and nextArr[j] !=i:
	{
        vioTWCNEW = FvioTWCus[j];
		//insert i after j:
		cArrTime = depart[j] + problem->c[j][i];
		temp = cArrTime - problem->node[i].eTW;
		if (temp > eps)
		{
			vioTWCNEW += temp;
			cStartS = problem->node[i].depart;
		}
		else cStartS = PDS_MAX(cArrTime,problem->node[i].sTW) + problem->node[i].duration; //start service time of customer i
	
		//from i to sucj: because nextArr[j] !=i then sucj can not be the endSP:
		cArrTime = cStartS + problem->c[i][sucj];
		temp = cArrTime - problem->node[sucj].eTW;
		if (temp > eps)
		{
			vioTWCNEW += temp;
			cStartS = problem->node[sucj].depart;
		}
		else cStartS = PDS_MAX(cArrTime,problem->node[sucj].sTW) + problem->node[sucj].duration; //start service time of customer sucj
		
		varcost = problem->c[j][i] + problem->c[i][sucj] - problem->c[j][sucj];
		//cout<<"problem->c[j][i] = "<<problem->c[j][i]<<"; problem->c[i][sucj] = "<<problem->c[i][sucj]<<"; problem->c[j][sucj] = "<<problem->c[j][sucj]<<"; varcost = "<<varcost<<endl;  
		idcur = sucj; idnext = nextArr[sucj];
		
		//checking from sucj till prei:
		while (idnext != i)
		{
			cArrTime = cStartS + problem->c[idcur][idnext];
			temp = cArrTime - problem->node[idnext].eTW;
			if (temp > eps)
			{
				vioTWCNEW += temp;
				cStartS = problem->node[idnext].depart;
			}
			else
				cStartS = PDS_MAX(cArrTime, problem->node[idnext].sTW) + problem->node[idnext].duration; //start service time of customer idnext
		    idcur = idnext; idnext = nextArr[idnext];
		}

        //now idcur points to prei:
		//from prei to suci & suci till the end of the leg:
		if (suci>0) // i was not the last customer of the leg
		{
			varcost += (problem->c[prei][suci] - problem->c[prei][i] - problem->c[i][suci]);
			//cout<<"problem->c[prei][suci] = "<<problem->c[prei][suci]<<"; problem->c[prei][i] = "<<problem->c[prei][i]<<"; problem->c[i][suci] = "<<problem->c[i][suci]<<endl<<"; varcost = "<<varcost<<endl;
			idnext = suci;
			while (idnext > 0)
			{
				cArrTime = cStartS + problem->c[idcur][idnext];
				temp = cArrTime - problem->node[idnext].eTW;
				if (temp > eps)
				{
					vioTWCNEW += temp;
					if (vioTWCus[idnext] > eps)
					{
                        insertCus[j][k]->var_cost = varcost;
						insertCus[j][k]->var_vioTWC = vioTWCNEW - FvioTWCus[idnext];
						insertCus[j][k]->var_vioTWSP = 0;
						insertCus[j][k]->var_vioCAP = 0;
					}
					cStartS = problem->node[idnext].depart;
				}
				else cStartS = PDS_MAX(cArrTime, problem->node[idnext].sTW) + problem->node[idnext].duration; //start service time of customer idnext
				idcur = idnext; idnext = nextArr[idnext];
			}
		}
		else //i was the last customer of the trip:
		{
			lastCChanged = 1;
			if (seg[idVeh].Trip[idTrip].waitingS == NO_WS)
				varcost -= (problem->c[prei][i] + problem->c[i][assSP1]);
			else varcost -= (problem->c[prei][i] + problem->disCWSSP[i][assSP1]);
		}
		//now idcur points to the last delivery customer of the trip:
	}

	//idcur is now the last customer of the trip and cStartS is time to leave the NEW last customer of current vehicle

	double varvioTWC = vioTWCNEW - seg[idVeh].Trip[idTrip].vioTWC;
	//Connect lastCus with assSP of next trip (idVeh, nextTrip):
	bool stop;
	double varvioTWSP = 0;
	if (lastCChanged)
		stop = calChangeCONNECTAtSP_DD_LastCChanged(idcur, idVeh, nextTrip, cStartS, varvioTWSP, varcost);
	else
		stop = calChangeCONNECTAtSP_DD(idcur, idVeh, nextTrip, idTrip, cStartS, varvioTWSP, varcost);

	if (stop == 0)
	    GoThroughVehicle(idVeh, nextTrip, varcost, varvioTWC, varvioTWSP, cStartS, assSP1, firstC_nextT);
	//Quangnn-- for compling: 3 lines
//    moveCusOneTrip[j][k]->var_vioTWSP = varvioTWSP;
//    moveCusOneTrip[j][k]->var_vioTWC = varvioTWC;
//    moveCusOneTrip[j][k]->var_cost = varcost;
}

bool Solution::SUBcal_MoveCusPIAfterJ_oneTrip(int j, int i, int idVeh, int idTrip, double &varcost, double &varvioTWC, double &varvioTWSP, double &cStartS)
{
    //ALMOST AS SAME AS Solution::cal_MoveCusDIAfterJ_oneTrip_nextTripP
	int prei,suci, idcur, idnext, sucj;
	double vioTWCNEW, cArrTime, temp;
	
	int assSP = seg[idVeh].Trip[idTrip].assSP;
	bool lastCChanged = 0;

	prei=predArr[i];suci=nextArr[i]; sucj = nextArr[j];
	//if (starti <startj)
	if (pos[i] < pos[j])
	{
		//remove i:
		if (prei > 0) 
		{
			vioTWCNEW = FvioTWCus[prei];
			cArrTime = depart[prei] + problem->c[prei][suci];
	        varcost = problem->c[prei][suci] - (problem->c[prei][i] + problem->c[i][suci]);
		}
		else //i is the first customer of the trip
		{
			vioTWCNEW = 0;
			if (idTrip == 0)
			{
				cArrTime = problem->c[0][suci];
				varcost = problem->c[0][suci] - (problem->c[0][i] + problem->c[i][suci]);
			}
			else
			{
			    int preT = idTrip - 1;
				if (seg[idVeh].Trip[preT].Type == 0)
				{
			        int assSPp = seg[idVeh].Trip[preT].assSP;
			        cArrTime = seg[idVeh].Trip[preT].leaveSP + problem->c[assSPp][suci];
                    varcost = problem->c[assSPp][suci] - (problem->c[assSPp][i] + problem->c[i][suci]);
				}
				else
				{
					int lastCp = seg[idVeh].Trip[preT].lastCus;
					cArrTime = depart[lastCp] + problem->c[lastCp][suci];
					varcost = problem->c[lastCp][suci] - (problem->c[lastCp][i] + problem->c[i][suci]);
				}
			}
		}
		temp = cArrTime - problem->node[suci].eTW;
		if (temp > eps) 
		{
			vioTWCNEW += temp;
			cStartS = problem->node[suci].depart;
		}
		else cStartS = PDS_MAX(cArrTime, problem->node[suci].sTW) + problem->node[suci].duration;

		//from suci to j:
		idcur = suci;
		if (suci != j)
		{
			idnext = nextArr[suci];
			while (idnext != sucj)
			{
				cArrTime = cStartS + problem->c[idcur][idnext];
				temp = cArrTime - problem->node[idnext].eTW;
				if (temp > eps)
				{
					vioTWCNEW += temp;
					cStartS = problem->node[idnext].depart;
				}
				else cStartS = PDS_MAX(cArrTime, problem->node[idnext].sTW) + problem->node[idnext].duration;
				idcur = idnext; idnext = nextArr[idnext];
			}
		}

		//now idnext point to sucj; idcur is j:

		//insert i after j:
		cArrTime = cStartS + problem->c[idcur][i];
		temp = cArrTime - problem->node[i].eTW;
		if (temp > eps)
		{
			vioTWCNEW += temp;
			cStartS = problem->node[i].depart;
		}
		else cStartS = PDS_MAX(cArrTime, problem->node[i].sTW) + problem->node[i].duration;

		if (sucj >0)
		{
				varcost += ((problem->c[j][i] + problem->c[i][sucj]) - problem->c[j][sucj]);
				//check from sucj till the end of the trip:
				idcur=i; idnext=sucj;
				while (idnext >0)
				{
					cArrTime = cStartS + problem->c[idcur][idnext];
					temp = cArrTime - problem->node[idnext].eTW;
					if (temp > eps)
					{
						vioTWCNEW += temp;
						if (vioTWCus[idnext] > eps)
						{
							varvioTWC = vioTWCNEW - FvioTWCus[idnext];
							varvioTWSP = 0;
							return 1;
						}
						cStartS = problem->node[idnext].depart;
					}
					else cStartS = PDS_MAX(cArrTime, problem->node[idnext].sTW) + problem->node[idnext].duration;
					idcur = idnext;idnext = nextArr[idnext];
				}
		}
		else //j was the last pick cus
		{
			lastCChanged = 1;
			idcur=i; 
			varcost += problem->c[j][i];
			if (seg[idVeh].Trip[idTrip].waitingS == NO_WS) varcost -= problem->c[j][assSP];
			else varcost -= problem->disCWSSP[j][assSP];
		}
	}
	else // i after j and nextArr[j] != i:
	{
        vioTWCNEW = FvioTWCus[j];
		//insert i after j:
		cArrTime = depart[j] + problem->c[j][i];
		temp = cArrTime - problem->node[i].eTW;
		if (temp > eps)
		{
			vioTWCNEW += temp;
			cStartS = problem->node[i].depart;
		}
		else cStartS = PDS_MAX(cArrTime,problem->node[i].sTW) + problem->node[i].duration; //start service time of customer i
		
		//from i to sucj: because nextArr[j] !=i then sucj can not be the endSP:
		cArrTime = cStartS + problem->c[i][sucj];
		temp = cArrTime - problem->node[sucj].eTW;
		if (temp > eps)
		{
			vioTWCNEW += temp;
			cStartS = problem->node[sucj].depart;
		}
		else cStartS = PDS_MAX(cArrTime,problem->node[sucj].sTW) + problem->node[sucj].duration; //start service time of customer sucj
        varcost = problem->c[j][i] + problem->c[i][sucj] - problem->c[j][sucj];
		//cout<<"problem->c[j][i] = "<<problem->c[j][i]<<"; problem->c[i][sucj] = "<<problem->c[i][sucj]<<"; problem->c[j][sucj] = "<<problem->c[j][sucj]<<"; varcost = "<<varcost<<endl;  
		idcur = sucj; idnext = nextArr[sucj];
		//checking from sucj till prei:
		while (idnext != i)
		{
			cArrTime = cStartS + problem->c[idcur][idnext];
			temp = cArrTime - problem->node[idnext].eTW;
			if (temp > eps)
			{
				vioTWCNEW += temp;
				cStartS = problem->node[idnext].depart;
			}
			else cStartS = PDS_MAX(cArrTime,problem->node[idnext].sTW) + problem->node[idnext].duration; //start service time of customer idnext
            idcur = idnext; idnext = nextArr[idnext];
		}

		//now idcur points to prei:
		//from prei to suci & suci till the end of the trip:
		if (suci > 0) // i was not the last customer of the trip
		{
			varcost += (problem->c[prei][suci] - problem->c[prei][i] - problem->c[i][suci]);
			//cout<<"problem->c[prei][suci] = "<<problem->c[prei][suci]<<"; problem->c[prei][i] = "<<problem->c[prei][i]<<"; problem->c[i][suci] = "<<problem->c[i][suci]<<endl<<"; varcost = "<<varcost<<endl;
			idnext = suci;
			while (idnext > 0)
			{
				cArrTime = cStartS + problem->c[idcur][idnext];
				temp = cArrTime - problem->node[idnext].eTW;
				if (temp > eps)
				{
					vioTWCNEW += temp;
					if (vioTWCus[idnext] > eps) 
					{
						varvioTWC = vioTWCNEW - FvioTWCus[idnext];
						varvioTWSP = 0;
						return 1;
					}
					cStartS = problem->node[idnext].depart;
				}
				else cStartS = PDS_MAX(cArrTime,problem->node[idnext].sTW) + problem->node[idnext].duration; //start service time of customer idnext
				idcur = idnext; idnext = nextArr[idnext];
			}
		}
		else //i was the last customer of the trip:
		{
			lastCChanged = 1;
			if (seg[idVeh].Trip[idTrip].waitingS == NO_WS)
				varcost -= (problem->c[prei][i] + problem->c[i][assSP]);
			else varcost -= (problem->c[prei][i] + problem->disCWSSP[i][assSP]);
		}
		//now idcur points to the NEW last delivery customer of the trip:
	}

	//idcur is now the last customer of the trip and cStartS is time to leave the NEW last customer of current vehicle
    bool stop;
	if (lastCChanged)
	   stop = calChangeCONNECTAtSP_PickTrip_LastCChanged(idcur, idVeh, idTrip, cStartS, varvioTWSP, varcost);
	else
	   stop = calChangeCONNECTAtSP_PickTrip(idcur, idVeh, idTrip, cStartS, varvioTWSP, varcost);
    return stop;
}

void Solution::cal_MoveCusPIAfterJ_oneTrip_NextTripP(int j, int i, int idVeh, int idTrip, double &varcost, double &varvioTWC, double &varvioTWSP)
{
   double cStartS; 
   //Quangnn-- for compiling
   //if (SUBcal_MoveCusPIAfterJ_oneTrip(j, i, idVeh, idTrip, varcost, varvioTWC, varvioTWSP, cStartS)== 0)
   {
       int nextT = idTrip + 1;
       int firstC_nextT = seg[idVeh].Trip[nextT].firstCus;
       GoThroughVehicle(idVeh, nextT, varcost, varvioTWC, varvioTWSP, cStartS, seg[idVeh].Trip[idTrip].assSP, firstC_nextT);
   }
}

void Solution::cal_MoveCusPIAfterJ_oneTrip_NextTripD_SameSP(int j, int i, int idVeh, int idTrip, double &varcost, double &varvioTWC, double &varvioTWSP)
{
   double cStartS; 
   if (SUBcal_MoveCusPIAfterJ_oneTrip(j, i, idVeh, idTrip, varcost, varvioTWC, varvioTWSP, cStartS)== 0)
   {
		varvioTWSP *=2;
		int assSP = seg[idVeh].Trip[idTrip].assSP;
		cStartS += problem->nodeSP[assSP].load;
	 
		int nextT = idTrip + 1;
 	    int firstC_nextT = seg[idVeh].Trip[nextT].firstCus;
		GoThroughVehicle(idVeh, nextT, varcost, varvioTWC, varvioTWSP, cStartS, assSP, firstC_nextT);
   }
}

void Solution::cal_MoveCusPIAfterJ_oneTrip_NextTripD_DifSP(int j, int i, int idVeh, int idTrip, double &varcost, double &varvioTWC, double &varvioTWSP)
{
   double cStartS; 
   if (SUBcal_MoveCusPIAfterJ_oneTrip(j, i, idVeh, idTrip, varcost, varvioTWC, varvioTWSP, cStartS)== 0)
   {
		int nextT = idTrip + 1;
 	    int firstC_nextT = seg[idVeh].Trip[nextT].firstCus;
		if (calChangeCONNECTAtSP_SPSP(idVeh, nextT, idTrip, cStartS, varvioTWSP, varcost) == 0)
			GoThroughVehicle(idVeh, nextT, varcost, varvioTWC, varvioTWSP, cStartS, seg[idVeh].Trip[nextT].assSP, firstC_nextT);
   }

}

void Solution::cal_ExchangeCusDIAndJ(int j, int k)
{
	int i = problem->node[j].neighborNode[k].id; 
    int previ, suci, prevj, sucj, idcur, idnext;

    int idVehj = route_num[j]; int idTripj = trip_num[j];
    int idVehi = route_num[i]; int idTripi = trip_num[i];
	int nextTripj = idTripj+1;
	int nextTripi = idTripi+1;

	double vioTWCNEW, varvioTWC, varvioTWSP, varcost; 
	int varvioCAP;
	double cStartS, cArrTime,temp;

	if (idVehi==idVehj)    //case 1: i and j in the same vehicle:
	{
		int assSP = seg[idVehi].Trip[idTripi].assSP; 
		int lastCus = seg[idVehi].Trip[idTripi].lastCus;
        bool firstI;
		int fC = seg[idVehi].Trip[idTripi].firstCus;
		int nC = seg[idVehi].Trip[idTripi].numCus;
        for (int k1=1;k1<=nC;k1++)
		{
			if (fC ==i) {firstI=true;break;}
			else if (fC==j) {firstI=false; break;}
	        fC = nextArr[fC];
		}
		int idN = j;
		if (!firstI) {int tt=i;i=j;j=tt;} //swap i and j so that i is before j
		//if (nextArr[j]==i) return;
		previ = predArr[i]; suci = nextArr[i];
		prevj = predArr[j]; sucj = nextArr[j];
		//if (print) cout<<"swap i and j, i = "<<i<<"; j ="<<j<<endl;

		if (previ > 0) {cStartS = depart[previ]; vioTWCNEW = FvioTWCus[previ];}
		else 
		{
			previ = assSP;
			cStartS = seg[idVehi].Trip[idTripi].leaveSP;
			vioTWCNEW = 0;
		}

		if (i != prevj)
		{
			//check TW till i:
			//if (print) cout<<"check TW till i("<<i<<")"<<endl;
			cArrTime = cStartS + problem->c[previ][j];
			temp = cArrTime - problem->node[j].eTW;
			if (temp > eps) 
			{
				vioTWCNEW += temp;
				cStartS = problem->node[j].depart;
			}
			else cStartS = PDS_MAX(problem->node[j].sTW, cArrTime) + problem->node[j].duration;

			cArrTime = cStartS + problem->c[j][suci];
			temp = cArrTime - problem->node[suci].eTW;
			if (temp > eps)
			{
				vioTWCNEW += temp;
				cStartS = problem->node[suci].depart;
			}
			else cStartS = PDS_MAX(cArrTime, problem->node[suci].sTW) + problem->node[suci].duration;
			
			idcur = suci;
			while (idcur != prevj) //check from suci to prevj
			{
				idnext = nextArr[idcur];
				//cout<<"idnext = "<<idnext<<"; ";
				cArrTime = cStartS + problem->c[idcur][idnext];
				temp = cArrTime - problem->node[idnext].eTW;
				if (temp > eps)
				{
					vioTWCNEW += temp;
					cStartS = problem->node[idnext].depart;
				}
				else cStartS = PDS_MAX(problem->node[idnext].sTW, cArrTime) + problem->node[idnext].duration;
				idcur=idnext;
			}
			//cout<<endl;
			cArrTime = cStartS + problem->c[idcur][i];
			temp = cArrTime - problem->node[i].eTW;
			if (temp > eps)
			{
				vioTWCNEW += temp;
				cStartS = problem->node[i].depart;
			}
			else cStartS = PDS_MAX (problem->node[i].sTW, cArrTime) + problem->node[i].duration;
		}
		else  // previ - i  -  j  -  sucj
		{
            cArrTime = cStartS + problem->c[previ][j];
			temp = cArrTime - problem->node[j].eTW;
            if (temp > eps) 
			{
				vioTWCNEW +=temp;
				cStartS = problem->node[j].depart;
			}   
			else cStartS = PDS_MAX(problem->node[j].sTW, cArrTime) + problem->node[j].duration;
		  
			cArrTime = cStartS + problem->c[j][i];
			temp = cArrTime - problem->node[i].eTW;
			if (temp > eps) 
			{
				vioTWCNEW +=temp;
				cStartS = problem->node[i].depart;
			}   
			else cStartS = PDS_MAX(problem->node[i].sTW, cArrTime) + problem->node[i].duration;
		}
		
		idcur = i; 
		//if (print) cout<<"Here i = "<<i<<endl;
	    // need to check from sucj till the end of the trip:
		if (sucj >0) // last customer of the trip doesn't change
		{
			   idnext = sucj;
			   while (idcur != lastCus) //check from sucj till the end of the leg
			   {
				    cArrTime = cStartS + problem->c[idcur][idnext];
					temp = cArrTime - problem->node[idnext].eTW;
					if (temp > eps)
					{
						vioTWCNEW += temp;
						if (vioTWCus[idnext] > eps)
						{
							 if (i != prevj) // previ - i .... j - sucj --> previ - j .... - i - sucj
								 varcost = (problem->c[previ][j] + problem->c[j][suci] + problem->c[prevj][i] + problem->c[i][sucj])
										   -(problem->c[previ][i] + problem->c[i][suci] + problem->c[prevj][j] + problem->c[j][sucj]);
							 else //previ - i - j - sucj --> previ - j - i - sucj
         						 varcost = (problem->c[previ][j] + problem->c[i][sucj]) -(problem->c[previ][i] + problem->c[j][sucj]);
							 exchangeCus[idN][k]->var_vioTWC = vioTWCNEW - FvioTWCus[idnext];
							 exchangeCus[idN][k]->var_vioTWSP=0;
							 exchangeCus[idN][k]->var_vioCAP = 0;
							 exchangeCus[idN][k]->var_cost = varcost;
							 exchangeCus[idN][k]->var_costj = varcost;
//							 exchangeCus[idN][k]->var_costNeighbor=0; //Quangnn-- for compiling
							 return;
						}
						cStartS = problem->node[idnext].depart;
					}
					else cStartS = PDS_MAX(problem->node[idnext].sTW, cArrTime) + problem->node[idnext].duration;
				    idcur=idnext; idnext = nextArr[idcur];
			   }
		}

		//idcur is now the last customer of the trip:
		int nextTrip = idTripi + 1;
		if (nextTrip == seg[idVehi].numTrips) //the last trip:
		{
             varvioTWC = vioTWCNEW - seg[idVehi].Trip[idTripi].vioTWC;
			 if (sucj<0) sucj=0;
			 if (i != prevj) // previ - i .... j - sucj --> previ - j .... - i - sucj
			     varcost = (problem->c[previ][j] + problem->c[j][suci] + problem->c[prevj][i] + problem->c[i][sucj])
				           -(problem->c[previ][i] + problem->c[i][suci] + problem->c[prevj][j] + problem->c[j][sucj]);
			 else //previ - i - j - sucj --> previ - j - i - sucj
				 varcost = (problem->c[previ][j] + problem->c[i][sucj]) -(problem->c[previ][i] + problem->c[j][sucj]);
		
			 exchangeCus[idN][k]->var_vioTWC = varvioTWC;
			 exchangeCus[idN][k]->var_vioTWSP=0;
			 exchangeCus[idN][k]->var_vioCAP = 0;
			 exchangeCus[idN][k]->var_cost = varcost;
			 exchangeCus[idN][k]->var_costj = varcost;
			 //exchangeCus[idN][k]->var_costNeighbor=0;//Quangnn-- for compiling
		}
		else //idTrip is not the last trip
		{
			varvioTWSP = 0;
           	int firstC_nextT = seg[idVehi].Trip[nextTrip].firstCus;
			if (seg[idVehi].Trip[nextTrip].Type ==0) //nextTrip is pickup trip
			{
				 varvioTWC = vioTWCNEW - seg[idVehi].Trip[idTripi].vioTWC;
				 if (sucj<0) sucj = firstC_nextT;
				 if (i != prevj) // previ - i .... j - sucj --> previ - j .... - i - sucj
					 varcost = (problem->c[previ][j] + problem->c[j][suci] + problem->c[prevj][i] + problem->c[i][sucj])
							   -(problem->c[previ][i] + problem->c[i][suci] + problem->c[prevj][j] + problem->c[j][sucj]);
				 else //previ - i - j - sucj --> previ - j - i - sucj
					 varcost = (problem->c[previ][j] + problem->c[i][sucj]) -(problem->c[previ][i] + problem->c[j][sucj]);
                 
				 
				 GoThroughVehicle(idVehi, nextTrip, varcost, varvioTWC, varvioTWSP, cStartS, idcur, firstC_nextT);

				 exchangeCus[idN][k]->var_vioTWC = varvioTWC;
				 exchangeCus[idN][k]->var_vioTWSP = varvioTWSP;
				 exchangeCus[idN][k]->var_vioCAP = 0;
				 exchangeCus[idN][k]->var_cost = varcost;
				 exchangeCus[idN][k]->var_costj = varcost;
				 //exchangeCus[idN][k]->var_costNeighbor=0;//Quangnn-- for compiling
			}
			else //nextTrip is delivery trip
			{
				 varvioTWC = vioTWCNEW - seg[idVehi].Trip[idTripi].vioTWC;
				 int assSP1 = seg[idVehi].Trip[nextTrip].assSP;
				 bool stop;
				 if (sucj < 0) // lastC change --> i is now the last cus
				 {
					 if (seg[idVehi].Trip[idTripi].waitingS == NO_WS)
					 {
						 if (i != prevj) // previ - i .... j - assSP1 --> previ - j .... - i ??-?? assSP1
							 varcost = (problem->c[previ][j] + problem->c[j][suci] + problem->c[prevj][i])
									   -(problem->c[previ][i] + problem->c[i][suci] + problem->c[prevj][j] + problem->c[j][assSP1]);
						 else //previ - i - j - assSP1 --> previ - j - i ??-?? assSP1
							 varcost = problem->c[previ][j] -(problem->c[previ][i] + problem->c[j][assSP1]);
					 }
					 else
					 {
						 if (i != prevj) // previ - i .... j -WS- assSP1 --> previ - j .... - i ??-?? assSP1
							 varcost = (problem->c[previ][j] + problem->c[j][suci] + problem->c[prevj][i])
									   -(problem->c[previ][i] + problem->c[i][suci] + problem->c[prevj][j] + problem->disCWSSP[j][assSP1]);
						 else //previ - i - j -WS- assSP1 --> previ - j - i ??-?? assSP1
							 varcost = problem->c[previ][j] -(problem->c[previ][i] + problem->disCWSSP[j][assSP1]);
					 }
					 stop = calChangeCONNECTAtSP_DD_LastCChanged(i, idVehi, nextTrip, cStartS, varvioTWSP, varcost);
				 }
				 else // lastC not change --> idcur now points to the last cus
				 {
					 if (i != prevj) // previ - i .... j - sucj --> previ - j .... - i - sucj
						 varcost = (problem->c[previ][j] + problem->c[j][suci] + problem->c[prevj][i] + problem->c[i][sucj])
								   -(problem->c[previ][i] + problem->c[i][suci] + problem->c[prevj][j] + problem->c[j][sucj]);
					 else //previ - i - j - sucj --> previ - j - i - sucj
						 varcost = (problem->c[previ][j] + problem->c[i][sucj]) -(problem->c[previ][i] + problem->c[j][sucj]);
					 stop = calChangeCONNECTAtSP_DD(idcur, idVehi, nextTrip, idTripi, cStartS, varvioTWSP, varcost);
				 }
				 if (stop == 0)
					 GoThroughVehicle(idVehi, nextTrip, varcost, varvioTWC, varvioTWSP, cStartS, idcur, firstC_nextT);

				exchangeCus[idN][k]->var_vioTWC = varvioTWC;
				exchangeCus[idN][k]->var_vioTWSP = varvioTWSP;
				exchangeCus[idN][k]->var_vioCAP = 0;
				exchangeCus[idN][k]->var_cost = varcost;
				exchangeCus[idN][k]->var_costj = varcost;
				//exchangeCus[idN][k]->var_costNeighbor=0;//Quangnn-- for compiling
			}//end nextTrip is delivery trip
       }//end else //idTrip is not the last trip
	}
	else //case 2: i and j are in different veh:
	{
		double vioTWCNEWi, vioTWCNEWj, varvioTWCi, varvioTWCj, varvioTWSPi, varvioTWSPj;
		int assSPi = seg[idVehi].Trip[idTripi].assSP; 
		int assSPj = seg[idVehj].Trip[idTripj].assSP; 

		double varcosti, varcostj; int idcuri, idcurj;
		previ = predArr[i]; suci = nextArr[i];
		prevj = predArr[j]; sucj = nextArr[j];

		if (previ > 0) {cStartS = depart[previ]; vioTWCNEWi = FvioTWCus[previ];}
		else 
		{
			previ = assSPi;
			cStartS = seg[idVehi].Trip[idTripi].leaveSP;
			vioTWCNEWi = 0;
		}

		int lastCusj = seg[idVehj].Trip[idTripj].lastCus;
		int lastCusi = seg[idVehi].Trip[idTripi].lastCus;
		cArrTime = cStartS + problem->c[previ][j];
		temp = cArrTime - problem->node[j].eTW;
		if (temp > eps)
		{
			vioTWCNEWi += temp;
			cStartS = problem->node[j].depart;
		}
		else cStartS = PDS_MAX(problem->node[j].sTW, cArrTime) + problem->node[j].duration;
		
        idcuri=j;
		if (suci > 0) //need to check TW till the end of the trip i
		{
			idnext = suci;
	        while (idcuri != lastCusi) //check from suci till the end of the leg i
		    {
		        cArrTime = cStartS + problem->c[idcuri][idnext];
				temp = cArrTime - problem->node[idnext].eTW;
				if (temp > eps)
				{
					vioTWCNEWi += temp;
					if (vioTWCus[idnext] > eps)
					{
						varvioTWCi = vioTWCNEWi - FvioTWCus[idnext];
						varvioTWSPi = 0;
			        	//if (previ <0) previ = assSPi;
						varcosti = problem->c[previ][j] + problem->c[j][suci] - (problem->c[previ][i] + problem->c[i][suci]);
						goto Updatej;
					}
					cStartS = problem->node[idnext].depart;
				}
				else cStartS = PDS_MAX(problem->node[idnext].sTW, cArrTime) + problem->node[idnext].duration;
			    idcuri=idnext; idnext = nextArr[idcuri];
		    }
		}

		//idcuri is now the last customer of the trip and cStartS is the time to leave the NEW last customer of the trip:
		varvioTWSPi = 0;
		varvioTWCi = vioTWCNEWi - seg[idVehi].Trip[idTripi].vioTWC;

		if (nextTripi == seg[idVehi].numTrips) //is the last trip
		{
        	 //if (previ <0) previ = assSPi;
			 if (suci < 0) suci = 0;
			 varcosti = problem->c[previ][j] + problem->c[j][suci] - (problem->c[previ][i] + problem->c[i][suci]);
		}
		else //not the last trip
		{
	         int firstC_nextT = seg[idVehi].Trip[nextTripi].firstCus;
			 //if (previ < 0) previ = assSPi;
			 if (seg[idVehi].Trip[nextTripi].Type ==0) //nextTripi is pickup trip
			 {
				if (suci < 0) //change the last customer: j is now the last customer
				{
					varcosti = (problem->c[previ][j] + problem->c[j][firstC_nextT])
						      -(problem->c[previ][i] + problem->c[i][firstC_nextT]);
				}
				else //doesn't change the last customer of the trip
				{
					varcosti = (problem->c[previ][j] + problem->c[j][suci]) 
						     - (problem->c[previ][i] + problem->c[i][suci]);
				}

				GoThroughVehicle(idVehi, nextTripi, varcosti, varvioTWCi, varvioTWSPi, cStartS, idcuri, firstC_nextT);
			 }//end //nextTripi is pickup trip
			 else //nextTripi is delivery trip
			 {
				 int assSP1 = seg[idVehi].Trip[nextTripi].assSP;
				 bool stop;
				 if (suci < 0) //change the last customer: j is now the last customer; suci was the last cus
				 {
					 if (seg[idVehi].Trip[idTripi].waitingS == NO_WS)
					    varcosti = problem->c[previ][j] -(problem->c[previ][i] + problem->c[i][assSP1]);
					 else
						varcosti = problem->c[previ][j] -(problem->c[previ][i] + problem->disCWSSP[i][assSP1]);
					 
					 stop = calChangeCONNECTAtSP_DD_LastCChanged(j, idVehi, nextTripi, cStartS, varvioTWSPi, varcosti);
				 }
				 else //doesn't change the last customer of the trip
				 {
					varcosti = (problem->c[previ][j] + problem->c[j][suci])
					         - (problem->c[previ][i] + problem->c[i][suci]);
					stop = calChangeCONNECTAtSP_DD(idcuri, idVehi, nextTripi, idTripi, cStartS, varvioTWSPi, varcosti);
				 }
				if (stop == 0)
					GoThroughVehicle(idVehi, nextTripi, varcosti, varvioTWCi, varvioTWSPi, cStartS, assSP1, firstC_nextT);
			 }//end nextTripi is delivery trip
		}//end idTripi is not the last trip


	Updatej:
   		if (prevj > 0) {cStartS = depart[prevj]; vioTWCNEWj = FvioTWCus[prevj];}
		else 
		{
			prevj = assSPj;
			cStartS = seg[idVehj].Trip[idTripj].leaveSP;
			vioTWCNEWj = 0;
		}

		cArrTime = cStartS + problem->c[prevj][i];
		temp = cArrTime - problem->node[i].eTW;
		if (temp > eps)
		{
			vioTWCNEWj += temp;
			cStartS = problem->node[i].depart;
		}
		else cStartS = PDS_MAX(problem->node[i].sTW, cArrTime) + problem->node[i].duration;
		
		idcurj=i;
		if (sucj > 0) //need to check TW till the end of the trip j
		{
			idnext = sucj;
	        while (idcurj != lastCusj) //check from suci till the end of the trip j
		    {
		        cArrTime = cStartS + problem->c[idcurj][idnext];
				temp = cArrTime - problem->node[idnext].eTW;
				if (temp > eps)
				{
					vioTWCNEWj += temp;
					if (vioTWCus[idnext] > eps)
					{
						varvioTWCj = vioTWCNEWj - FvioTWCus[idnext];
						varvioTWSPj = 0;
						//if (prevj < 0) prevj = assSPj;
						varcostj = problem->c[prevj][i] + problem->c[i][sucj] - (problem->c[prevj][j] + problem->c[j][sucj]);
						goto Update;
					}
					cStartS = problem->node[idnext].depart;
				}
				else  cStartS = PDS_MAX(problem->node[idnext].sTW, cArrTime) + problem->node[idnext].duration;
			    idcurj=idnext; idnext = nextArr[idcurj];
		    }
		}
		//idcurj is now the last customer of the trip and cStartS is the start service at the NEW last customer of the trip:
		varvioTWSPj = 0;
		varvioTWCj = vioTWCNEWj - seg[idVehj].Trip[idTripj].vioTWC;
			 
		if (nextTripj == seg[idVehj].numTrips) //is the last trip
		{
		     //if (prevj < 0) prevj = assSPj;
			 if (sucj < 0) sucj = 0;
			 varcostj = problem->c[prevj][i] + problem->c[i][sucj] - (problem->c[prevj][j] + problem->c[j][sucj]);
		}
		else //not the last trip
		{
			 int firstC_nextT = seg[idVehj].Trip[nextTripj].firstCus;
			 //if (prevj < 0) prevj = assSPj;
			 if (seg[idVehj].Trip[nextTripj].Type ==0) //nextTripj is pickup trip
			 {
				if (sucj < 0) //change the last customer: i is now the last customer
					varcostj = (problem->c[prevj][i] + problem->c[i][firstC_nextT])
						      -(problem->c[prevj][j] + problem->c[j][firstC_nextT]);
				else //doesn't change the last customer of the trip
					varcostj = (problem->c[prevj][i] + problem->c[i][sucj]) 
					         - (problem->c[prevj][j] + problem->c[j][sucj]);
				GoThroughVehicle(idVehj, nextTripj, varcostj, varvioTWCj, varvioTWSPj, cStartS, idcurj, firstC_nextT);
			 }//end nextTripj is pickup trip
			 else //nextTripj is delivery trip
			 {
			    int assSP1 = seg[idVehj].Trip[nextTripj].assSP;
				bool stop;
				if (sucj < 0) //change the last customer: i is now the last customer; j was the last customer
				{
					if (seg[idVehj].Trip[idTripj].waitingS == NO_WS)
						varcostj = problem->c[prevj][i] -(problem->c[prevj][j] + problem->c[j][assSP1]);
					else 
						varcostj = problem->c[prevj][i] -(problem->c[prevj][j] + problem->disCWSSP[j][assSP1]);
					stop = calChangeCONNECTAtSP_DD_LastCChanged(i, idVehj, nextTripj, cStartS, varvioTWSPj, varcostj);
				}
				else //doesn't change the last customer of the trip
				{
					varcostj = (problem->c[prevj][i] + problem->c[i][sucj]) 
						     - (problem->c[prevj][j] + problem->c[j][sucj]);
					stop = calChangeCONNECTAtSP_DD(idcurj, idVehj, nextTripj, idTripj, cStartS, varvioTWSPj, varcostj);
				}
				if (stop == 0)
				   GoThroughVehicle(idVehj, nextTripj, varcostj, varvioTWCj, varvioTWSPj, cStartS, assSP1, firstC_nextT);
			 }//end nextTripj is delivery trip
		}//end idTripj is not the last trip

	Update:
		varvioTWC = varvioTWCi + varvioTWCj;
		varvioTWSP = varvioTWSPi + varvioTWSPj;
		int capi = seg[idVehi].Trip[idTripi].capacity - problem->node[i].capacity + problem->node[j].capacity;
		int capj = seg[idVehj].Trip[idTripj].capacity - problem->node[j].capacity + problem->node[i].capacity;
		int vioCapi = PDS_MAX(capi - problem->Q,0);
		int vioCapj = PDS_MAX(capj - problem->Q,0);
		varvioCAP = (vioCapi - seg[idVehi].Trip[idTripi].vioCAP) + (vioCapj - seg[idVehj].Trip[idTripj].vioCAP);
	    varcost = varcosti + varcostj;

		exchangeCus[j][k]->var_vioTWC = varvioTWC;
    	exchangeCus[j][k]->var_vioTWSP = varvioTWSP;
		exchangeCus[j][k]->var_vioCAP = varvioCAP;
		exchangeCus[j][k]->var_cost = varcost;
		exchangeCus[j][k]->var_costj = varcostj;
		//exchangeCus[j][k]->var_costNeighbor = varcosti;//Quangnn-- for compiling
	}
}

void Solution::cal_ExchangeCusPIAndJ(int j, int k)
{
	int i = problem->node[j].neighborNode[k].id; 

    int previ, suci, prevj, sucj, idcur, idnext;

    int idVehj = route_num[j]; int idTripj = trip_num[j];
    int idVehi = route_num[i]; int idTripi = trip_num[i];

	double vioTWCNEW, varvioTWC, varvioTWSP, varcost; 
	int varvioCAP;
	double cStartS, cArrTime,temp;

    if (idVehi == idVehj)
	{
		if (idTripi == idTripj) // i and j are in the same trip:
		{
			int assSP = seg[idVehi].Trip[idTripi].assSP; 
			int lastCus = seg[idVehi].Trip[idTripi].lastCus;
			bool firstI;
			int fC = seg[idVehi].Trip[idTripi].firstCus;
			int nC = seg[idVehi].Trip[idTripi].numCus;
			for (int k1=1;k1<=nC;k1++)
			{
				if (fC ==i) {firstI=true;break;}
				else if (fC==j) {firstI=false; break;}
				fC = nextArr[fC];
			}
			int idN = j;
			if (!firstI) {int tt=i;i=j;j=tt;} //swap i and j so that i is before j
			//if (nextArr[j]==i) return;
			previ = predArr[i]; suci = nextArr[i];
			prevj = predArr[j]; sucj = nextArr[j];
			//if (print) cout<<"swap i and j, i = "<<i<<"; j ="<<j<<endl;

			if (previ > 0) {cStartS = depart[previ]; vioTWCNEW = FvioTWCus[previ];}
			else 
			{
				vioTWCNEW = 0;
				if (idTripi == 0)
				{
					previ = 0;
					cStartS = 0;
				}
				else
				{
					int preT = idTripi - 1;
					if (seg[idVehi].Trip[preT].Type)
					{
						previ = seg[idVehi].Trip[preT].lastCus;
						cStartS = depart[previ];
					}
					else
					{
						previ = seg[idVehi].Trip[preT].assSP;
						cStartS = seg[idVehi].Trip[preT].leaveSP;
					}
				}
			}

			if (i != prevj)
			{
				//check TW till i:
				//if (print) cout<<"check TW till i("<<i<<")"<<endl;
				cArrTime = cStartS + problem->c[previ][j];
				temp = cArrTime - problem->node[j].eTW;
				if (temp > eps) 
				{
					vioTWCNEW += temp;
					cStartS = problem->node[j].depart;
				}
				else cStartS = PDS_MAX(problem->node[j].sTW, cArrTime) + problem->node[j].duration;

				cArrTime = cStartS + problem->c[j][suci];
				temp = cArrTime - problem->node[suci].eTW;
				if (temp > eps)
				{
					vioTWCNEW += temp;
					cStartS = problem->node[suci].depart;
				}
				else cStartS = PDS_MAX(cArrTime, problem->node[suci].sTW) + problem->node[suci].duration;
				
				idcur = suci;
				while (idcur != prevj) //check from suci to prevj
				{
					idnext = nextArr[idcur];
					//cout<<"idnext = "<<idnext<<"; ";
					cArrTime = cStartS + problem->c[idcur][idnext];
					temp = cArrTime - problem->node[idnext].eTW;
					if (temp > eps)
					{
						vioTWCNEW += temp;
						cStartS = problem->node[idnext].depart;
					}
					else cStartS = PDS_MAX(problem->node[idnext].sTW, cArrTime) + problem->node[idnext].duration;
					idcur=idnext;
				}
				//cout<<endl;
				cArrTime = cStartS + problem->c[idcur][i];
				temp = cArrTime - problem->node[i].eTW;
				if (temp > eps)
				{
					vioTWCNEW += temp;
					cStartS = problem->node[i].depart;
				}
				else cStartS = PDS_MAX (problem->node[i].sTW, cArrTime) + problem->node[i].duration;
			}
			else  // previ - i  -  j  -  sucj
			{
				cArrTime = cStartS + problem->c[previ][j];
				temp = cArrTime - problem->node[j].eTW;
				if (temp > eps) 
				{
					vioTWCNEW +=temp;
					cStartS = problem->node[j].depart;
				}   
				else cStartS = PDS_MAX(problem->node[j].sTW, cArrTime) + problem->node[j].duration;
			  
				cArrTime = cStartS + problem->c[j][i];
				temp = cArrTime - problem->node[i].eTW;
				if (temp > eps) 
				{
					vioTWCNEW +=temp;
					cStartS = problem->node[i].depart;
				}   
				else cStartS = PDS_MAX(problem->node[i].sTW, cArrTime) + problem->node[i].duration;
			}
			
			idcur = i; bool stop;
			//if (print) cout<<"Here i = "<<i<<endl;
			// need to check from sucj till the end of the trip:
			if (sucj > 0) // last customer of the trip doesn't change
			{
				   idnext = sucj;
				   while (idcur != lastCus) //check from sucj till the end of the leg
				   {
						cArrTime = cStartS + problem->c[idcur][idnext];
						temp = cArrTime - problem->node[idnext].eTW;
						if (temp > eps)
						{
							vioTWCNEW += temp;
							if (vioTWCus[idnext] > eps)
							{
								 if (i != prevj) // previ - i .... j - sucj --> previ - j .... - i - sucj
									 varcost = (problem->c[previ][j] + problem->c[j][suci] + problem->c[prevj][i] + problem->c[i][sucj])
											   -(problem->c[previ][i] + problem->c[i][suci] + problem->c[prevj][j] + problem->c[j][sucj]);
								 else //previ - i - j - sucj --> previ - j - i - sucj
         							 varcost = (problem->c[previ][j] + problem->c[i][sucj]) -(problem->c[previ][i] + problem->c[j][sucj]);
								 exchangeCus[idN][k]->var_vioTWC = vioTWCNEW - FvioTWCus[idnext];
								 exchangeCus[idN][k]->var_vioTWSP=0;
								 exchangeCus[idN][k]->var_vioCAP = 0;
								 exchangeCus[idN][k]->var_cost = varcost;
								 exchangeCus[idN][k]->var_costj = varcost;
								 //exchangeCus[idN][k]->var_costNeighbor=0;//Quangnn-- for compiling
								 return;
							}
							cStartS = problem->node[idnext].depart;
						}
						else cStartS = PDS_MAX(problem->node[idnext].sTW, cArrTime) + problem->node[idnext].duration;
						idcur=idnext; idnext = nextArr[idcur];
				   }
				   //lastC doesn't change; idcur now points to the last cus
					if (i != prevj) // previ - i .... j - sucj --> previ - j .... - i - sucj
						 varcost = (problem->c[previ][j] + problem->c[j][suci] + problem->c[prevj][i] + problem->c[i][sucj])
								   -(problem->c[previ][i] + problem->c[i][suci] + problem->c[prevj][j] + problem->c[j][sucj]);
					else //previ - i - j - sucj --> previ - j - i - sucj
						 varcost = (problem->c[previ][j] + problem->c[i][sucj]) -(problem->c[previ][i] + problem->c[j][sucj]);
					stop = calChangeCONNECTAtSP_PickTrip(idcur, idVehi, idTripi, cStartS, varvioTWSP, varcost);
			}
			else //lastC is changed: i is now the last cus; j was the last cus
			{
				if (i != prevj) // previ - i .... j. --> previ - j .... - i.
					 varcost = (problem->c[previ][j] + problem->c[j][suci] + problem->c[prevj][i])
							   -(problem->c[previ][i] + problem->c[i][suci] + problem->c[prevj][j]);
				else //previ - i - j. --> previ - j - i.
					varcost = problem->c[previ][j] - problem->c[previ][i];
				if (seg[idVehi].Trip[idTripi].waitingS == NO_WS)
					varcost -= problem->c[j][assSP];
				else varcost -= problem->disCWSSP[j][assSP];
				stop = calChangeCONNECTAtSP_PickTrip_LastCChanged(i, idVehi, idTripi, cStartS, varvioTWSP, varcost);
			}

			varvioTWC = vioTWCNEW - seg[idVehi].Trip[idTripi].vioTWC;
			if (stop == 0)
			{
				int nextT = idTripi + 1;
				if (nextT < seg[idVehi].numTrips)
				{
					int firstC_nextT = seg[idVehi].Trip[nextT].firstCus;
					if (seg[idVehi].Trip[nextT].Type == 0)
					{
					   GoThroughVehicle(idVehi, nextT, varcost, varvioTWC, varvioTWSP, cStartS, assSP, firstC_nextT);
					}
					else //nextT is delivery trip
					{
						if (seg[idVehi].Trip[nextT].assSP == assSP)
						{
							varvioTWSP *= 2;
							cStartS += problem->nodeSP[assSP].load;
						    GoThroughVehicle(idVehi, nextT, varcost, varvioTWC, varvioTWSP, cStartS, assSP, firstC_nextT);
						}
						else // p - asssP -- asssP1 - d
						{
							if (calChangeCONNECTAtSP_SPSP(idVehi, nextT, idTripi, cStartS, varvioTWSP, varcost) ==0)
							    GoThroughVehicle(idVehi, nextT, varcost, varvioTWC, varvioTWSP, cStartS, seg[idVehi].Trip[nextT].assSP, firstC_nextT);
						}//end p - asssP -- asssP1 - d
					}//end nextT is delivery trip
				}
			}
			exchangeCus[idN][k]->var_vioTWC = varvioTWC;
			exchangeCus[idN][k]->var_vioTWSP = varvioTWSP;
			exchangeCus[idN][k]->var_vioCAP = 0;
			exchangeCus[idN][k]->var_cost = varcost;
			exchangeCus[idN][k]->var_costj = varcost;
			//exchangeCus[idN][k]->var_costNeighbor=0;//Quangnn-- for compiling
		}
		else // i and j are in the same vehicle, but different trips
		{
				int assSPi = seg[idVehi].Trip[idTripi].assSP; 
				int assSPj = seg[idVehj].Trip[idTripj].assSP; 

				if (problem->belong[j][assSPi] == 0 || problem->belong[i][assSPj] == 0)
				{
					exchangeCus[j][k]->var_vioCAP = PDS_INFINITY;
					return;
				}
				double vioTWCNEWi, vioTWCNEWj, varvioTWCi, varvioTWCj, varvioTWSPi, varvioTWSPj;
				varvioTWSPi = 0; varvioTWSPj = 0;

				double varcosti, varcostj; int idcuri, idcurj;

				int idN = j;
				if (idTripi > idTripj) 
				{
					int tt=i;i=j;j=tt;
					tt = idTripi; idTripi = idTripj; idTripj = tt;
				} //swap i and j so that i is before j
				int numTrips = idTripj-idTripi - 1;
				previ = predArr[i]; suci = nextArr[i];
				prevj = predArr[j]; sucj = nextArr[j];
				int preTi, preTj = idTripj - 1;
				bool stop;

				if (previ > 0) {cStartS = depart[previ]; vioTWCNEWi = FvioTWCus[previ];}
				else 
				{
					vioTWCNEWi = 0;
					if (idTripi == 0)
					{
					   previ = 0;
					   cStartS = 0;
					}
					else
					{
						preTi = idTripi - 1;
						if (seg[idVehi].Trip[preTi].Type)
						{
							previ = seg[idVehi].Trip[preTi].lastCus;
							cStartS = depart[previ];
						}
						else
						{
							previ = seg[idVehi].Trip[preTi].assSP;
							cStartS = seg[idVehi].Trip[preTi].leaveSP;
						}
					}
				}
				int lastCusj = seg[idVehj].Trip[idTripj].lastCus;
				int lastCusi = seg[idVehi].Trip[idTripi].lastCus;
				cArrTime = cStartS + problem->c[previ][j];
				temp = cArrTime - problem->node[j].eTW;
				if (temp > eps)
				{
					vioTWCNEWi += temp;
					cStartS = problem->node[j].depart;
				}
				else cStartS = PDS_MAX(problem->node[j].sTW, cArrTime) + problem->node[j].duration;
				
				idcuri=j; 
				if (suci > 0) //need to check TW till the end of the trip i
				{
					idnext = suci;
					while (idcuri != lastCusi) //check from suci till the end of the trip i
					{
						cArrTime = cStartS + problem->c[idcuri][idnext];
						temp = cArrTime - problem->node[idnext].eTW;
						if (temp > eps)
						{
							vioTWCNEWi += temp;
							if (vioTWCus[idnext] > eps)
							{
								varvioTWCi = vioTWCNEWi - FvioTWCus[idnext];
								//varvioTWSPi = 0;
								//if (previ <0) previ = assSPi;
								varcosti = problem->c[previ][j] + problem->c[j][suci] - (problem->c[previ][i] + problem->c[i][suci]);
								if (seg[idVehj].Trip[preTj].Type)
								{
									idcurj = seg[idVehj].Trip[preTj].lastCus;
									cStartS = depart[idcurj];
								}
								else
								{
									idcurj = seg[idVehj].Trip[preTj].assSP;
									cStartS = seg[idVehj].Trip[preTj].leaveSP;
								}
								goto Updatej;
							}
							cStartS = problem->node[idnext].depart;
						}
						else cStartS = PDS_MAX(problem->node[idnext].sTW, cArrTime) + problem->node[idnext].duration;
						idcuri=idnext; idnext = nextArr[idcuri];
					}
					//dont change the last customer: idcuri now points to the last customer
					varcosti = problem->c[previ][j] + problem->c[j][suci] - (problem->c[previ][i] + problem->c[i][suci]);
					stop = calChangeCONNECTAtSP_PickTrip(idcuri, idVehi, idTripi, cStartS, varvioTWSPi, varcosti);
				}
				else //change the last customer: j is now the last customer; i was the last customer
				{
					varcosti = problem->c[previ][j] - problem->c[previ][i];
					if (seg[idVehi].Trip[idTripi].waitingS == NO_WS)
						varcosti -= problem->c[i][assSPi];
					else varcosti -= problem->disCWSSP[i][assSPi];
					stop = calChangeCONNECTAtSP_PickTrip_LastCChanged(j, idVehi, idTripi, cStartS, varvioTWSPi, varcosti);
				}

				varvioTWCi = vioTWCNEWi - seg[idVehi].Trip[idTripi].vioTWC;
				if (stop == 0)
				{
					if (numTrips > 0)
					{
							int nextT = idTripi + 1;
							int firstC_nextT = seg[idVehi].Trip[nextT].firstCus;
							if (seg[idVehi].Trip[nextT].Type == 0){
							   //stop = GoThroughVehicle(idVehi, nextT,numTrips, varcosti, varvioTWCi, varvioTWSPi, cStartS, assSPi, firstC_nextT);//Quangnn-- for compiling
							}
							else
							{
								if (assSPi == seg[idVehi].Trip[nextT].assSP)
								{
									varvioTWSPi *= 2;
									cStartS += problem->nodeSP[assSPi].load;
									//stop = GoThroughVehicle(idVehi, nextT, numTrips, varcosti, varvioTWCi, varvioTWSPi, cStartS, assSPi, firstC_nextT);//Quangnn-- for compiling
								}
								else //p - assSPi -- assSP1 - d
								{
									if (calChangeCONNECTAtSP_SPSP(idVehi, nextT, idTripi, cStartS, varvioTWSPi, varcosti) == 0){
										//stop = GoThroughVehicle(idVehi, nextT, numTrips, varcosti, varvioTWCi, varvioTWSPi, cStartS, seg[idVehi].Trip[nextT].assSP, firstC_nextT);//Quangnn-- for compiling
									}
								}
							}
							if (stop)
							{
								if (seg[idVehj].Trip[preTj].Type)
								{
									idcurj = seg[idVehj].Trip[preTj].lastCus;
									cStartS = depart[idcurj];
								}
								else
								{
									idcurj = seg[idVehj].Trip[preTj].assSP;
									cStartS = seg[idVehj].Trip[preTj].leaveSP;
								}
							}
							else
							{
								preTj = idTripj - 1;
								if (seg[idVehj].Trip[preTj].Type) idcurj = seg[idVehj].Trip[preTj].lastCus;
								else idcurj = seg[idVehj].Trip[preTj].assSP;
								//cStartS taken from GoThroughVehicle
							}
					}//end if (numTrips > 0)
					else //idTripj == idTripi + 1:
					{
						idcurj = seg[idVehi].Trip[idTripi].assSP;
						//cStartS taken from the call of calChangeCONNECTAtSP_PickTrip/alChangeCONNECTAtSP_PickTrip_LastCChanged
					}
				}//end if (stop == 0)
				else //stop = 1 --> nothing's changed after replace i by j in pickup trip (idVehi, idTripi)
				{
					preTj = idTripj - 1;
					if (seg[idVehj].Trip[preTj].Type) 
					{
						idcurj = seg[idVehj].Trip[preTj].lastCus;
						cStartS = depart[idcurj];
					}
					else
					{
						idcurj = seg[idVehj].Trip[preTj].assSP;
						cStartS = seg[idVehj].Trip[preTj].leaveSP;
					}
				}

			Updatej:
				vioTWCNEWj = 0;
				idnext = seg[idVehj].Trip[idTripj].firstCus;
				if (prevj < 0) prevj = idcurj;
				while (idnext != j)
				{
						cArrTime = cStartS + problem->c[idcurj][idnext];
						temp = cArrTime - problem->node[idnext].eTW;
						if (temp > eps)
						{
							vioTWCNEWj += temp;
							cStartS = problem->node[idnext].depart;
						}
						else cStartS = PDS_MAX(cArrTime, problem->node[idnext].sTW) + problem->node[idnext].duration;
						idcurj = idnext; idnext = nextArr[idcurj];
				}
				//idcurj now points to prevj:
				cArrTime = cStartS + problem->c[idcurj][i];
				temp = cArrTime - problem->node[i].eTW;
				if (temp > eps)
				{
					vioTWCNEWj += temp;
					cStartS = problem->node[i].depart;
				}
				else cStartS = PDS_MAX(cArrTime, problem->node[i].sTW) + problem->node[i].duration;

				idcurj = i; 
				if (sucj > 0) //need to check TW till the end of the trip j
				{
					idnext = sucj;
					while (idcurj != lastCusj) //check from sucj till the end of the trip j
					{
						cArrTime = cStartS + problem->c[idcurj][idnext];
						temp = cArrTime - problem->node[idnext].eTW;
						if (temp > eps)
						{
							vioTWCNEWj += temp;
							if (vioTWCus[idnext] > eps)
							{
								varvioTWCj = vioTWCNEWj - FvioTWCus[idnext];
								//varvioTWSPi = 0;
								//if (previ <0) previ = assSPi;
								varcostj = problem->c[prevj][i] + problem->c[i][sucj] - (problem->c[prevj][j] + problem->c[j][sucj]);
								goto Updatej1;
							}
							cStartS = problem->node[idnext].depart;
						}
						else cStartS = PDS_MAX(problem->node[idnext].sTW, cArrTime) + problem->node[idnext].duration;
						idcurj=idnext; idnext = nextArr[idcurj];
					}
					//dont change the last customer: idcurj now points to the last customer
					varcostj = problem->c[prevj][i] + problem->c[i][sucj] - (problem->c[prevj][j] + problem->c[j][sucj]);
					stop = calChangeCONNECTAtSP_PickTrip(idcurj, idVehj, idTripj, cStartS, varvioTWSPj, varcostj);
				}
				else //change the last customer: i is now the last customer; j was the last customer
				{
					varcostj = problem->c[prevj][i] - problem->c[prevj][j];
					if (seg[idVehj].Trip[idTripj].waitingS == NO_WS)
						varcostj -= problem->c[j][assSPj];
					else varcostj -= problem->disCWSSP[j][assSPj];
					stop = calChangeCONNECTAtSP_PickTrip_LastCChanged(i, idVehj, idTripj, cStartS, varvioTWSPj, varcostj);
				}
				
				varvioTWCj = vioTWCNEWj - seg[idVehj].Trip[idTripj].vioTWC;
				if (stop == 0)
				{
					int nextT = idTripj + 1;
					if (nextT < seg[idVehj].numTrips) //not the last trip:
					{
						int firstC_nextT = seg[idVehj].Trip[nextT].firstCus;
						if (seg[idVehj].Trip[nextT].Type == 0) //nextT is pickup trip
						{
							GoThroughVehicle(idVehj, nextT, varcostj, varvioTWCj, varvioTWSPj, cStartS, assSPj, firstC_nextT);
						}
						else //nextT is delivery trip:
						{
							if (assSPj == seg[idVehj].Trip[nextT].assSP) // p - assSPj - d
							{
								varvioTWSPj *= 2;
								cStartS += problem->nodeSP[assSPj].load;
								GoThroughVehicle(idVehj, nextT, varcostj, varvioTWCj, varvioTWSPj, cStartS, assSPj, firstC_nextT);
							}
							else //p  - assSPj - assSP1 - d
							{
								if (calChangeCONNECTAtSP_SPSP(idVehj, nextT, idTripj, cStartS, varvioTWSPj, varcostj) == 0)
									GoThroughVehicle(idVehj, nextT, varcostj, varvioTWCj, varvioTWSPj, cStartS, seg[idVehj].Trip[nextT].assSP, firstC_nextT);
							}//end p  - assSPj - assSP1 - d
						}//end nextT is delivery trip
					}
				}
			Updatej1:
				varvioTWC = varvioTWCi + varvioTWCj;
				varvioTWSP = varvioTWSPi + varvioTWSPj;
				int capi = seg[idVehi].Trip[idTripi].capacity - problem->node[i].capacity + problem->node[j].capacity;
				int capj = seg[idVehj].Trip[idTripj].capacity - problem->node[j].capacity + problem->node[i].capacity;
				int vioCapi = PDS_MAX(capi - problem->Q,0);
				int vioCapj = PDS_MAX(capj - problem->Q,0);
				varvioCAP = (vioCapi - seg[idVehi].Trip[idTripi].vioCAP) + (vioCapj - seg[idVehj].Trip[idTripj].vioCAP);
				varcost = varcosti + varcostj;

				exchangeCus[idN][k]->var_vioTWC = varvioTWC;
    			exchangeCus[idN][k]->var_vioTWSP = varvioTWSP;
				exchangeCus[idN][k]->var_vioCAP = varvioCAP;
				exchangeCus[idN][k]->var_cost = varcost;
				exchangeCus[idN][k]->var_costj = varcostj;
				//exchangeCus[idN][k]->var_costNeighbor = varcosti;//Quangnn-- for compiling

		}//end i and j are in the same vehicle, but different trips
	}
	else // i and j are in the different vehicles:
	{
		int assSPi = seg[idVehi].Trip[idTripi].assSP; 
		int assSPj = seg[idVehj].Trip[idTripj].assSP; 

		if (problem->belong[j][assSPi] == 0 || problem->belong[i][assSPj] == 0)
		{
			exchangeCus[j][k]->var_vioCAP = PDS_INFINITY;
			return;
		}
		
		double vioTWCNEWi, vioTWCNEWj, varvioTWCi, varvioTWCj, varvioTWSPi, varvioTWSPj;
		varvioTWSPi = 0; varvioTWSPj = 0;

		double varcosti, varcostj; int idcuri, idcurj;
		previ = predArr[i]; suci = nextArr[i];
		prevj = predArr[j]; sucj = nextArr[j];
		int preTi, preTj;
		bool stop;

		if (previ > 0) {cStartS = depart[previ]; vioTWCNEWi = FvioTWCus[previ];}
		else 
		{
			vioTWCNEWi = 0;
			if (idTripi == 0)
			{
			   previ = 0;
			   cStartS = 0;
			}
			else
			{
				preTi = idTripi - 1;
				if (seg[idVehi].Trip[preTi].Type)
				{
					previ = seg[idVehi].Trip[preTi].lastCus;
					cStartS = depart[previ];
				}
				else
				{
					previ = seg[idVehi].Trip[preTi].assSP;
					cStartS = seg[idVehi].Trip[preTi].leaveSP;
				}
			}
		}

		int lastCusj = seg[idVehj].Trip[idTripj].lastCus;
		int lastCusi = seg[idVehi].Trip[idTripi].lastCus;
		cArrTime = cStartS + problem->c[previ][j];
		temp = cArrTime - problem->node[j].eTW;
		if (temp > eps)
		{
			vioTWCNEWi += temp;
			cStartS = problem->node[j].depart;
		}
		else cStartS = PDS_MAX(problem->node[j].sTW, cArrTime) + problem->node[j].duration;
		
        idcuri=j; 
		if (suci > 0) //need to check TW till the end of the trip i
		{
			idnext = suci;
	        while (idcuri != lastCusi) //check from suci till the end of the leg i
		    {
		        cArrTime = cStartS + problem->c[idcuri][idnext];
				temp = cArrTime - problem->node[idnext].eTW;
				if (temp > eps)
				{
					vioTWCNEWi += temp;
					if (vioTWCus[idnext] > eps)
					{
						varvioTWCi = vioTWCNEWi - FvioTWCus[idnext];
						//varvioTWSPi = 0;
						//if (previ <0) previ = assSPi;
						varcosti = problem->c[previ][j] + problem->c[j][suci] - (problem->c[previ][i] + problem->c[i][suci]);
						goto Updatej2;
					}
					cStartS = problem->node[idnext].depart;
				}
				else cStartS = PDS_MAX(problem->node[idnext].sTW, cArrTime) + problem->node[idnext].duration;
			    idcuri=idnext; idnext = nextArr[idcuri];
		    }
			//dont change the last customer: idcuri now points to the last customer
			varcosti = problem->c[previ][j] + problem->c[j][suci] - (problem->c[previ][i] + problem->c[i][suci]);
			stop = calChangeCONNECTAtSP_PickTrip(idcuri, idVehi, idTripi, cStartS, varvioTWSPi, varcosti);
		}
		else //change the last customer: j is now the last customer; i was the last customer
		{
			varcosti = problem->c[previ][j] - problem->c[previ][i];
			if (seg[idVehi].Trip[idTripi].waitingS == NO_WS)
				varcosti -= problem->c[i][assSPi];
			else varcosti -= problem->disCWSSP[i][assSPi];
			stop = calChangeCONNECTAtSP_PickTrip_LastCChanged(j, idVehi, idTripi, cStartS, varvioTWSPi, varcosti);
		}

		varvioTWCi = vioTWCNEWi - seg[idVehi].Trip[idTripi].vioTWC;
		if (stop == 0)
		{
			int nextT = idTripi + 1;
			if (nextT < seg[idVehi].numTrips)
			{
				int firstC_nextT = seg[idVehi].Trip[nextT].firstCus;
				if (seg[idVehi].Trip[nextT].Type == 0)
				   GoThroughVehicle(idVehi, nextT, varcosti, varvioTWCi, varvioTWSPi, cStartS, assSPi, firstC_nextT);
				else
				{
					if (assSPi == seg[idVehi].Trip[nextT].assSP)
					{
						varvioTWSPi *= 2;
						cStartS += problem->nodeSP[assSPi].load;
						GoThroughVehicle(idVehi, nextT, varcosti, varvioTWCi, varvioTWSPi, cStartS, assSPi, firstC_nextT);
					}
					else //p - assSPi -- assSP1 - d
					{
						if (calChangeCONNECTAtSP_SPSP(idVehi, nextT, idTripi, cStartS, varvioTWSPi, varcosti) == 0)
							GoThroughVehicle(idVehi, nextT, varcosti, varvioTWCi, varvioTWSPi, cStartS, seg[idVehi].Trip[nextT].assSP, firstC_nextT);
					}
				}
			}
		}


	Updatej2:

   		if (prevj > 0) {cStartS = depart[prevj]; vioTWCNEWj = FvioTWCus[prevj];}
		else 
		{
			vioTWCNEWj = 0;
			if (idTripj == 0)
			{
				prevj = 0;
				cStartS = 0;
			}
			else
			{
				preTj = idTripj - 1;
				if (seg[idVehj].Trip[preTj].Type)
				{
					prevj = seg[idVehj].Trip[preTj].lastCus;
					cStartS = depart[prevj];
				}
				else
				{
					prevj = seg[idVehj].Trip[preTj].assSP;
					cStartS = seg[idVehj].Trip[preTj].leaveSP;
				}
			}
		}

		cArrTime = cStartS + problem->c[prevj][i];
		temp = cArrTime - problem->node[i].eTW;
		if (temp > eps)
		{
			vioTWCNEWj += temp;
			cStartS = problem->node[i].depart;
		}
		else cStartS = PDS_MAX(problem->node[i].sTW, cArrTime) + problem->node[i].duration;
		
		idcurj=i;
		if (sucj > 0) //need to check TW till the end of the trip j
		{
			idnext = sucj;
	        while (idcurj != lastCusj) //check from suci till the end of the trip j
		    {
		        cArrTime = cStartS + problem->c[idcurj][idnext];
				temp = cArrTime - problem->node[idnext].eTW;
				if (temp > eps)
				{
					vioTWCNEWj += temp;
					if (vioTWCus[idnext] > eps)
					{
						varvioTWCj = vioTWCNEWj - FvioTWCus[idnext];
						//varvioTWSPj = 0;
						//if (prevj <0) prevj = assSPj;
						varcostj = problem->c[prevj][i] + problem->c[i][sucj] - (problem->c[prevj][j] + problem->c[j][sucj]);
						goto Update;
					}
					cStartS = problem->node[idnext].depart;
				}
				else  cStartS = PDS_MAX(problem->node[idnext].sTW, cArrTime) + problem->node[idnext].duration;
			    idcurj=idnext; idnext = nextArr[idcurj];
		    }
			//idcurj now points to the last customer; lastCustomer doesn't change
			varcostj = problem->c[prevj][i] + problem->c[i][sucj] - (problem->c[prevj][j] + problem->c[j][sucj]);
			stop = calChangeCONNECTAtSP_PickTrip(idcurj, idVehj, idTripj, cStartS, varvioTWSPj, varcostj);
		}
		else //i is now the last customer; j was the last customer
		{
			varcostj = problem->c[prevj][i] - problem->c[prevj][j];
			if (seg[idVehj].Trip[idTripj].waitingS == NO_WS)
				varcostj -= problem->c[j][assSPj];
			else varcostj -= problem->disCWSSP[j][assSPj];
			stop = calChangeCONNECTAtSP_PickTrip_LastCChanged(i, idVehj, idTripj, cStartS, varvioTWSPj, varcostj);
		}//end //i is now the last customer; j was the last customer

		varvioTWCj = vioTWCNEWj - seg[idVehj].Trip[idTripj].vioTWC;
		if (stop == 0)
		{
			int nextT = idTripj + 1;
			if (nextT < seg[idVehj].numTrips) //not the last trip:
			{
				int firstC_nextT = seg[idVehj].Trip[nextT].firstCus;
				if (seg[idVehj].Trip[nextT].Type == 0) //nextT is pickup trip
				{
					GoThroughVehicle(idVehj, nextT, varcostj, varvioTWCj, varvioTWSPj, cStartS, assSPj, firstC_nextT);
				}
				else //nextT is delivery trip:
				{
					if (assSPj == seg[idVehj].Trip[nextT].assSP) // p - assSPj - d
					{
						varvioTWSPj *= 2;
						cStartS += problem->nodeSP[assSPj].load;
						GoThroughVehicle(idVehj, nextT, varcostj, varvioTWCj, varvioTWSPj, cStartS, assSPj, firstC_nextT);
					}
					else //p  - assSPj - assSP1 - d
					{
						if (calChangeCONNECTAtSP_SPSP(idVehj, nextT, idTripj, cStartS, varvioTWSPj, varcostj) == 0)
							GoThroughVehicle(idVehj, nextT, varcostj, varvioTWCj, varvioTWSPj, cStartS, seg[idVehj].Trip[nextT].assSP, firstC_nextT);
					}//end p  - assSPj - assSP1 - d
				}//end nextT is delivery trip
			}
		}
	Update:
		varvioTWC = varvioTWCi + varvioTWCj;
		varvioTWSP = varvioTWSPi + varvioTWSPj;
		int capi = seg[idVehi].Trip[idTripi].capacity - problem->node[i].capacity + problem->node[j].capacity;
		int capj = seg[idVehj].Trip[idTripj].capacity - problem->node[j].capacity + problem->node[i].capacity;
		int vioCapi = PDS_MAX(capi - problem->Q,0);
		int vioCapj = PDS_MAX(capj - problem->Q,0);
		varvioCAP = (vioCapi - seg[idVehi].Trip[idTripi].vioCAP) + (vioCapj - seg[idVehj].Trip[idTripj].vioCAP);
	    varcost = varcosti + varcostj;

		exchangeCus[j][k]->var_vioTWC = varvioTWC;
    	exchangeCus[j][k]->var_vioTWSP = varvioTWSP;
		exchangeCus[j][k]->var_vioCAP = varvioCAP;
		exchangeCus[j][k]->var_cost = varcost;
		exchangeCus[j][k]->var_costj = varcostj;
		//exchangeCus[j][k]->var_costNeighbor = varcosti;//Quangnn-- for compiling
	}//end i and j are in the different vehicles
}

void Solution::cal_twoOPTstarCusDIAndJ_oneTrip_LastTrip(int j, int k) //connect j with i where j and i are in the same trip; i after j and i != sucj
{
   	int i = problem->node[j].neighborNode[k].id;  // i != sucj
	int prei, suci, sucj, idcur, idnext,idpre;
	
	int idVeh = route_num[i];int idTrip = trip_num[i];

    double varcost,vioTWCNEW, varvioTWC;
	double cStartS, cArrTime,temp;

	prei = predArr[i]; suci = nextArr[i];sucj = nextArr[j];

	//Start to check leg:	
	cStartS = depart[j]; vioTWCNEW = FvioTWCus[j];
    cArrTime = cStartS + problem->c[j][i];
	temp = cArrTime - problem->node[i].eTW;
	if (temp > eps)
	{
		vioTWCNEW += temp;
		cStartS = problem->node[i].depart;
	}
	else cStartS = PDS_MAX(cArrTime, problem->node[i].sTW) + problem->node[i].duration;

	idcur=i;
	idpre = prei;
    while (idpre != j) //check reverse from prei to sucj
    {
		cArrTime = cStartS + problem->c[idcur][idpre];
	    temp = cArrTime - problem->node[idpre].eTW;
	    if (temp > eps)
		{
			vioTWCNEW +=temp;
			cStartS = problem->node[idpre].depart;
		}
		else cStartS = PDS_MAX(problem->node[idpre].sTW, cArrTime) + problem->node[idpre].duration;
		idcur=idpre; idpre = predArr[idpre];
    }
	//idcur is now sucj; check sucj-->suci & suci till the end of the trip:
	idnext = suci;
    while (idnext >0)
	{
		cArrTime = cStartS + problem->c[idcur][idnext];
		temp = cArrTime - problem->node[idnext].eTW;
		if (temp > eps)
		{
			vioTWCNEW += temp;
			if (vioTWCus[idnext] > eps)
			{
				varvioTWC = vioTWCNEW - FvioTWCus[idnext];
				goto Update;
			}
			cStartS = problem->node[idnext].depart;
		}
		else cStartS = PDS_MAX(problem->node[idnext].sTW, cArrTime) + problem->node[idnext].duration;
		idcur = idnext;idnext=nextArr[idnext];
	}
	//idcur is now the lastCus of the trip
	varvioTWC = vioTWCNEW - seg[idVeh].Trip[idTrip].vioTWC;

		Update:
		    if (suci >0) //i was not the last customer of the trip:
			   varcost = problem->c[j][i] + problem->c[sucj][suci] - problem->c[j][sucj] - problem->c[i][suci];
			 else //i was the last customer of the trip --> sucj is now the last customer of the trip:
				 varcost = problem->c[j][i] + problem->c[sucj][0] - problem->c[j][sucj] - problem->c[i][0];
			 twoOPTstarCus[j][k]->var_vioCAP = 0;
			 twoOPTstarCus[j][k]->var_vioTWC = varvioTWC;
			 twoOPTstarCus[j][k]->var_vioTWSP = 0;
			 twoOPTstarCus[j][k]->var_cost = varcost;
			 twoOPTstarCus[j][k]->empty=0;
}

void Solution::cal_twoOPTstarCusDIAndJ_oneTrip_NextTripD(int j, int k) //connect j with i where j and i are in the same trip
{
   	int i = problem->node[j].neighborNode[k].id;  // i != sucj
	int prei, suci, sucj, idcur, idnext,idpre;
	
	int idVeh = route_num[i]; int idTrip = trip_num[i];

    double varcost, vioTWCNEW, varvioTWC;
	double cStartS, cArrTime,temp;
	double varvioTWSP = 0;

	prei = predArr[i]; suci = nextArr[i];sucj = nextArr[j];

	//Start to check leg:	
	cStartS = depart[j]; vioTWCNEW = FvioTWCus[j];
    cArrTime = cStartS + problem->c[j][i];
	temp = cArrTime - problem->node[i].eTW;
	if (temp > eps)
	{
		vioTWCNEW += temp;
		cStartS = problem->node[i].depart;
	}
	else cStartS = PDS_MAX(problem->node[i].sTW, cArrTime) + problem->node[i].duration;

	idcur=i;
	idpre = prei;
	while (idpre != j) //check reverse from prei to sucj
	{
		cArrTime = cStartS + problem->c[idcur][idpre];
		temp = cArrTime - problem->node[idpre].eTW;
		if (temp > eps)
		{
			vioTWCNEW += temp;
			cStartS = problem->node[idpre].depart;
		}
		else  cStartS = PDS_MAX(problem->node[idpre].sTW, cArrTime) + problem->node[idpre].duration;
	    idcur=idpre; idpre = predArr[idpre];
	}
	//idcur is now sucj; check sucj-->suci & suci till the end of the trip:
	bool stop; int nextT;
	if (suci > 0)
	{
		idnext = suci;
		while (idnext >0)
		{
			cArrTime = cStartS + problem->c[idcur][idnext];
			temp = cArrTime - problem->node[idnext].eTW;
			if (temp > eps)
			{
				vioTWCNEW += temp;
				if (vioTWCus[idnext] > eps)
				{
					varvioTWC = vioTWCNEW - FvioTWCus[idnext];
					varcost = problem->c[j][i] + problem->c[sucj][suci] - problem->c[j][sucj] - problem->c[i][suci];
					goto Update;
				}
				cStartS = problem->node[idnext].depart;
			}
			else cStartS = PDS_MAX(problem->node[idnext].sTW, cArrTime) + problem->node[idnext].duration;
			idcur = idnext;idnext=nextArr[idnext];
		}
		varcost = problem->c[j][i] + problem->c[sucj][suci] - problem->c[j][sucj] - problem->c[i][suci];
		varvioTWC = vioTWCNEW - seg[idVeh].Trip[idTrip].vioTWC;
		nextT = idTrip + 1;
		stop = calChangeCONNECTAtSP_DD(idcur, idVeh, nextT, idTrip, cStartS, varvioTWSP, varcost);
	}
	else //change lastC: i was the last; sucj is now the last
	{
		 varvioTWC = vioTWCNEW - seg[idVeh].Trip[idTrip].vioTWC;
		 varcost = problem->c[j][i] - problem->c[j][sucj];
		 nextT = idTrip + 1;
		 if (seg[idVeh].Trip[idTrip].waitingS == NO_WS)
			 varcost -= problem->c[i][seg[idVeh].Trip[nextT].assSP];
		 else varcost -= problem->disCWSSP[i][seg[idVeh].Trip[nextT].assSP];
		 stop = calChangeCONNECTAtSP_DD_LastCChanged(sucj, idVeh, nextT, cStartS, varvioTWSP, varcost);
	}//end change lastC: i was the last; sucj is now the last
	if (stop == 0)
	{
        int firstC_nextT = seg[idVeh].Trip[nextT].firstCus;	 
		GoThroughVehicle(idVeh, nextT, varcost, varvioTWC, varvioTWSP, cStartS, seg[idVeh].Trip[nextT].assSP, firstC_nextT);
	}

Update:
	 twoOPTstarCus[j][k]->var_vioCAP = 0;
     twoOPTstarCus[j][k]->var_vioTWC = varvioTWC;
     twoOPTstarCus[j][k]->var_vioTWSP = varvioTWSP;
     twoOPTstarCus[j][k]->var_cost = varcost;
     twoOPTstarCus[j][k]->empty=0;

}

void Solution::cal_twoOPTstarCusDIAndJ_oneTrip_NextTripP(int j, int k) //connect j with i where j and i are in the same trip
{
   	int i = problem->node[j].neighborNode[k].id;  // i != sucj
	int prei, suci, sucj, idcur, idnext,idpre;
	
	int idVeh = route_num[i]; int idTrip = trip_num[i];

    double varcost, vioTWCNEW, varvioTWC;
	double cStartS, cArrTime,temp;
	double varvioTWSP = 0;

	prei = predArr[i]; suci = nextArr[i];sucj = nextArr[j];

	//Start to check leg:	
	cStartS = depart[j]; vioTWCNEW = FvioTWCus[j];
    cArrTime = cStartS + problem->c[j][i];
	temp = cArrTime - problem->node[i].eTW;
	if (temp > eps)
	{
		vioTWCNEW += temp;
		cStartS = problem->node[i].depart;
	}
	else cStartS = PDS_MAX(problem->node[i].sTW, cArrTime) + problem->node[i].duration;

	idcur=i;
	idpre = prei;
	while (idpre != j) //check reverse from prei to sucj
	{
		cArrTime = cStartS + problem->c[idcur][idpre];
		temp = cArrTime - problem->node[idpre].eTW;
		if (temp > eps)
		{
			vioTWCNEW += temp;
			cStartS = problem->node[idpre].depart;
		}
		else  cStartS = PDS_MAX(problem->node[idpre].sTW, cArrTime) + problem->node[idpre].duration;
	    idcur=idpre; idpre = predArr[idpre];
	}
	//idcur is now sucj; check sucj-->suci & suci till the end of the trip:
	int nextT = idTrip + 1;
	int firstC_nextT = seg[idVeh].Trip[nextT].firstCus;

	if (suci > 0)
	{
		idnext = suci;
		while (idnext >0)
		{
			cArrTime = cStartS + problem->c[idcur][idnext];
			temp = cArrTime - problem->node[idnext].eTW;
			if (temp > eps)
			{
				vioTWCNEW += temp;
				if (vioTWCus[idnext] > eps)
				{
					varvioTWC = vioTWCNEW - FvioTWCus[idnext];
					varcost = problem->c[j][i] + problem->c[sucj][suci] - problem->c[j][sucj] - problem->c[i][suci];
					goto Update;
				}
				cStartS = problem->node[idnext].depart;
			}
			else cStartS = PDS_MAX(problem->node[idnext].sTW, cArrTime) + problem->node[idnext].duration;
			idcur = idnext;idnext=nextArr[idnext];
		}
		varcost = problem->c[j][i] + problem->c[sucj][suci] - problem->c[j][sucj] - problem->c[i][suci];
	}
	else //change lastC: i was the last; sucj is now the last
	{
		 varcost = problem->c[j][i] + problem->c[sucj][firstC_nextT] - problem->c[j][sucj] - problem->c[i][firstC_nextT];

	}//end change lastC: i was the last; sucj is now the last
	varvioTWC = vioTWCNEW - seg[idVeh].Trip[idTrip].vioTWC;
	//idcur now points to the last customer:
	GoThroughVehicle(idVeh, nextT, varcost, varvioTWC, varvioTWSP, cStartS, idcur, firstC_nextT);

Update:
	 twoOPTstarCus[j][k]->var_vioCAP = 0;
     twoOPTstarCus[j][k]->var_vioTWC = varvioTWC;
     twoOPTstarCus[j][k]->var_vioTWSP = varvioTWSP;
     twoOPTstarCus[j][k]->var_cost = varcost;
     twoOPTstarCus[j][k]->empty=0;

}

void Solution::cal_twoOPTstarCusDIAndJ(int j, int k) //j and its #k neighbor belong to different vehicles
{
	//Moi trip sau idTripi va idTripj giu nguyen vehicle, ko exchange vehicle cua chung:
	int i = problem->node[j].neighborNode[k].id; //connect j with i
	int prei, suci, prej, sucj, idcur, idnext;


	prei = predArr[i]; suci = nextArr[i];
	prej = predArr[j]; sucj = nextArr[j];

	int capi;
	int capj = FCAP[j] + BCAP[i];
	int idVehj = route_num[j]; int idVehi = route_num[i];
	int idTripj = trip_num[j];  int idTripi = trip_num[i];
	int assSPi = seg[idVehi].Trip[idTripi].assSP;

    if (prei <0 && sucj <0) //Tripi becomes empty after move
	{
		if (capj > exceed) //24Oct: too long route & still don't have move to cut it--> don't use this move when capacity exceeds 1.5 capacity of the vehicle
		{
			  twoOPTstarCus[j][k]->var_vioCAP = PDS_INFINITY;
			  return;
		}
		if (numTripDSP[assSPi] <= problem->minTripSP[assSPi]) 
		{
			  twoOPTstarCus[j][k]->var_vioCAP = PDS_INFINITY;
			  return;
		}
	}
	else //Tripi is not empty after move
	{
		capi=0; 
		if (prei > 0) capi = FCAP[prei];
		if (sucj>0) capi += BCAP[sucj];
		if (capj > exceed || capi > exceed)
		{
			 twoOPTstarCus[j][k]->var_vioCAP = PDS_INFINITY;
			 return;
		}
	}


		int varvioCAP;
		double cStartS, cArrTime,temp;
		double varcosti, varcostj;
		double varvioTWCi, varvioTWCj, varvioTWSPi = 0, varvioTWSPj = 0;

		int assSPj = seg[idVehj].Trip[idTripj].assSP;

		int lastCOLDj = seg[idVehj].Trip[idTripj].lastCus;
		int lastCOLDi = seg[idVehi].Trip[idTripi].lastCus;

        //Start to check trip j	
		varcostj = problem->c[j][i];
		if (sucj >0) varcostj -= problem->c[j][sucj];
		varcostj -= seg[idVehj].Trip[idTripj].connectCost;

		cStartS = depart[j]; 
        cArrTime = cStartS + problem->c[j][i];
		temp = cArrTime - problem->node[i].eTW;
		if (temp > eps)
		{
			if (vioTWCus[i] > eps)
			{
				varvioTWCj = temp - vioTWCus[i];
				cStartS = depart[lastCOLDi];
				goto CalConnectj;
			}
			varvioTWCj = temp;
			cStartS = problem->node[i].depart;
		}
		else cStartS = PDS_MAX(cArrTime, problem->node[i].sTW) + problem->node[i].duration;

		idcur=i;
		if (suci > 0) //need to check TW till the end of the trip i:
		{
			idnext = suci;
	        while (idcur != lastCOLDi) //check from suci till the end of the leg i
		    {
		        cArrTime = cStartS + problem->c[idcur][idnext];
				temp = cArrTime - problem->node[idnext].eTW;
				if (temp > eps)
				{
					if (vioTWCus[idnext] > eps)
					{
						varvioTWCj += (temp - vioTWCus[idnext]); 
						cStartS = depart[lastCOLDi];
						goto CalConnectj;
					}
					varvioTWCj += temp;
					cStartS = problem->node[idnext].depart;
				}
				else cStartS = PDS_MAX(problem->node[idnext].sTW, cArrTime) + problem->node[idnext].duration;
			    idcur=idnext; idnext = nextArr[idcur];
		    }
		}
		//idcur is now the NEW last customer of the tripj: = lastCOLDi
	CalConnectj:
		int nextTj = idTripj + 1;
		if (nextTj < seg[idVehj].numTrips) //Tripj is not the last trip
		{
			int firstC_nextT = seg[idVehj].Trip[nextTj].firstCus;
			if (seg[idVehj].Trip[nextTj].Type) //nextTrip is delivery trip
			{
				 int assSP1 = seg[idVehj].Trip[nextTj].assSP;
				 if (calChangeCONNECTAtSP_DD_LastCChanged(lastCOLDi, idVehj, nextTj, cStartS, varvioTWSPj, varcostj) ==0)
					GoThroughVehicle(idVehj, nextTj, varcostj, varvioTWCj, varvioTWSPj, cStartS, assSP1, firstC_nextT);
			}
			else //nextTripj is pickup trip
			{
				varcostj += problem->c[lastCOLDi][firstC_nextT];
				GoThroughVehicle(idVehj, nextTj, varcostj, varvioTWCj, varvioTWSPj, cStartS, lastCOLDi, firstC_nextT);
			}//end nextTripj is pickup trip
		} //end Tripj is not the last trip
		else varcostj += problem->c[lastCOLDi][0];

		int nextTripi = idTripi+1;
		bool empty_idVehi = 0;
		varcosti = -seg[idVehi].Trip[idTripi].connectCost;

		if (prei <0 && sucj <0) //Tripi becomes empty after move
		{
	        varvioTWCi = 0;
  			varcosti -= problem->c[assSPi][i];
			int vioCapj = PDS_MAX(capj - problem->Q, 0);
			varvioCAP = -seg[idVehi].Trip[idTripi].vioCAP + (vioCapj - seg[idVehj].Trip[idTripj].vioCAP);

			if (seg[idVehi].numTrips ==1) // after move, idVehi becomes empty
			{
				 varcosti -= problem->c[0][assSPi];
				 empty_idVehi = 1;
			}
			else //vehicle i has >= 2trips
			{
				if (idTripi == 0) //tripi is the first trip
				{
					varcosti -= problem->c[0][assSPi];
					if (seg[idVehi].Trip[1].Type == 1) //nextTripi is delivery trip: ok
					{
					   varvioTWSPi = -seg[idVehi].Trip[1].vioTWSP;
					   int assSP1 = seg[idVehi].Trip[1].assSP;
					   varcosti += problem->c[0][assSP1];
					   cStartS = problem->leaveSP[assSP1][4]; //load only at sTW2
					   if (PDSDIF(cStartS, seg[idVehi].Trip[1].leaveSP) == 0)
						   goto Update;
					   else
					   {
					       int firstC_nextT = seg[idVehi].Trip[1].firstCus; 
						   GoThroughVehicle(idVehi,1, varcosti, varvioTWCi, varvioTWSPi, cStartS, assSP1, firstC_nextT);
					   }
					}
					else //nextTripi is pickup trip
					{
						int firstC_nextT = seg[idVehi].Trip[1].firstCus;
						varcosti += problem->c[0][firstC_nextT];
						cStartS = 0;
					    GoThroughVehicle(idVehi, 1, varcosti, varvioTWCi, varvioTWSPi, cStartS, 0, firstC_nextT);
					}//end nextTripi is pickup trip (CASE: tripi becomes empty, tripi is the first trip)
				}
				else //tripi is not the first trip:
				{
					 int preTripi = idTripi - 1;
					 varcosti -= seg[idVehi].Trip[preTripi].connectCost;
					 varvioTWSPi -= seg[idVehi].Trip[idTripi].vioTWSP;
                     if (nextTripi == seg[idVehi].numTrips) //tripi is the last trip
					 {
						 if (seg[idVehi].Trip[preTripi].Type)
							 varcosti += problem->c[seg[idVehi].Trip[preTripi].lastCus][0];
						 else
							 varcosti += problem->c[seg[idVehi].Trip[preTripi].assSP][0];
					 }
					 else //idTripi is not the lastTrip (is middle)
					 {
						 if (seg[idVehi].Trip[preTripi].Type == 0) //preTripi is the pickup trip
						 {
							 cStartS = seg[idVehi].Trip[preTripi].leaveSP;
							 int assSPprei = seg[idVehi].Trip[preTripi].assSP;
							 if (seg[idVehi].Trip[nextTripi].Type) // nextTripi is delivery trip
							 {
                                  bool stop = calCONNECTCSPTOSPD_FORDELETE(assSPprei, idVehi, nextTripi, cStartS, varvioTWSPi, varcosti);
                                  if (stop) goto Update;
								  int firstC_nextT = seg[idVehi].Trip[nextTripi].firstCus;
								  GoThroughVehicle(idVehi, nextTripi, varcosti, varvioTWCi, varvioTWSPi, cStartS, seg[idVehi].Trip[nextTripi].assSP, firstC_nextT);
							 }//end preTripi is pickup, nextTripi is delivery
							 else //preTripi is pickup, nextTripi is pickup
							 {
								 int firstC_nextT = seg[idVehi].Trip[nextTripi].firstCus;
								 varcosti += problem->c[assSPprei][firstC_nextT];
								 GoThroughVehicle(idVehi, nextTripi, varcosti, varvioTWCi, varvioTWSPi, cStartS, assSPprei, firstC_nextT);
							 }//end preTripi is pickup, nextTripi is pickup
						 }
						 else //preTripi is delivery trip
						 {
							 int lastCprei = seg[idVehi].Trip[preTripi].lastCus;
							 cStartS = depart[lastCprei];
							 if (seg[idVehi].Trip[nextTripi].Type) //nextTripi is delivery trip
							 {
                                 bool stop = calCONNECTCSPTOSPD_FORDELETE(lastCprei, idVehi, nextTripi, cStartS, varvioTWSPi, varcosti);
                                 if (stop) goto Update;
								 int assSP1 = seg[idVehi].Trip[nextTripi].assSP;
								 int firstC_nextT = seg[idVehi].Trip[nextTripi].firstCus;
								 GoThroughVehicle(idVehi, nextTripi, varcosti, varvioTWCi, varvioTWSPi, cStartS, assSP1, firstC_nextT);
							 }//end nextTripi is delivery trip; preTripi is delivery trip
							 else //nextTripi is pickup trip; preTripi is delivery trip
							 {
								 int firstC_nextT = seg[idVehi].Trip[nextTripi].firstCus;
								 varcosti += problem->c[lastCprei][firstC_nextT];
								 GoThroughVehicle(idVehi, nextTripi, varcosti, varvioTWCi, varvioTWSPi, cStartS, lastCprei, firstC_nextT);
							 }//end nextTripi is pickup trip; preTripi is delivery trip
						 }//end preTripi is delivery trip
					 }//end //idTripi is not the lastTrip (is middle)
				}//end tripi is not the first trip
			}//end vehicle i has >= 2 trips
		}
		else //Tripi is not empty after move
		{
			 int vioCapi = PDS_MAX(capi - problem->Q, 0);
			 int vioCapj = PDS_MAX(capj - problem->Q, 0);
			 varvioCAP = (vioCapi - seg[idVehi].Trip[idTripi].vioCAP) + (vioCapj - seg[idVehj].Trip[idTripj].vioCAP);

			//Start to check trip i	
			if (prei > 0)
			{
				cStartS = depart[prei]; 
				varcosti -= problem->c[prei][i];
				if (sucj > 0) varcosti += problem->c[prei][sucj];
			}
			else //prei < 0 --> sucj > 0
			{
				prei = assSPi;
				cStartS = seg[idVehi].Trip[idTripi].leaveSP;
				varcosti += (problem->c[assSPi][sucj] - problem->c[assSPi][i]);
			}

			varvioTWCi = 0;
			idcur = prei;
			if (sucj >0)
			{
				idnext = sucj;
				while (idcur != lastCOLDj) //check from previ till the end of the leg j
				{
					cArrTime = cStartS + problem->c[idcur][idnext];
					temp = cArrTime - problem->node[idnext].eTW;
					if (temp > eps)
					{
						if (vioTWCus[idnext] > eps)
						{
							varvioTWCi += (temp - vioTWCus[idnext]);
							cStartS = depart[lastCOLDj];
							idcur = lastCOLDj;
							goto CalConnecti;
						}
						varvioTWCi += temp;
						cStartS = problem->node[idnext].depart;
					}
					else cStartS = PDS_MAX(problem->node[idnext].sTW, cArrTime) + problem->node[idnext].duration;
					idcur=idnext; idnext = nextArr[idcur];
				}
			}
			//idcur is now the last customer of new idTripi:
		CalConnecti:
			if (nextTripi == seg[idVehi].numTrips) //Tripi is the last trip of idVehi:
			{
				 varcosti += problem->c[idcur][0];
			}
			else //Tripi is not the last trip of idVehi:
			{
				 int firstC_nextT = seg[idVehi].Trip[nextTripi].firstCus;
				 if (seg[idVehi].Trip[nextTripi].Type) //nextTripi is delivery trip:
				 {
					 int assSP1 = seg[idVehi].Trip[nextTripi].assSP;
                     if (calChangeCONNECTAtSP_DD_LastCChanged(idcur, idVehi, nextTripi, cStartS, varvioTWSPi, varcosti) ==0)
  					     GoThroughVehicle(idVehi, nextTripi, varcosti, varvioTWCi, varvioTWSPi, cStartS, assSP1, firstC_nextT);
				 }//end nextTripi is delivery trip 
				 else //nextTripi is pickup trip:
				 {
					 varcosti += problem->c[idcur][firstC_nextT];
					 GoThroughVehicle(idVehi, nextTripi, varcosti, varvioTWCi, varvioTWSPi, cStartS, idcur, firstC_nextT);
				 }//end nextTripi is pickup trip
			 }//end Tripi is not the last trip of idVehi
	}//end Tripi is not empty after move

    Update:
	    twoOPTstarCus[j][k]->var_vioTWC = varvioTWCi + varvioTWCj;
		twoOPTstarCus[j][k]->var_vioTWSP = varvioTWSPi + varvioTWSPj;
		//twoOPTstarCus[j][k]->var_vioTWSPi = varvioTWSPi; //Quang--
		//twoOPTstarCus[j][k]->var_vioTWSPj = varvioTWSPj;//Quang--

		twoOPTstarCus[j][k]->var_vioCAP = varvioCAP;
		twoOPTstarCus[j][k]->var_cost = varcosti + varcostj;
        //twoOPTstarCus[j][k]->var_costi = varcosti;//Quang--
		//twoOPTstarCus[j][k]->var_costj = varcostj;//Quang--
		twoOPTstarCus[j][k]->atIT = IT;
		if (empty_idVehi) twoOPTstarCus[j][k]->empty = 1;
		else twoOPTstarCus[j][k]->empty = 0;
}

bool Solution::SUBcal_twoOPTstarCusPIAndJ_oneTrip(int j, int i, int idVeh, int idTrip, double &varcost, double &varvioTWC, double &varvioTWSP, double &cStartS) //connect j with i where j and i are in the same trip
{
	int prei, suci, sucj, idcur, idnext,idpre;
    double vioTWCNEW, cArrTime,temp;
	varvioTWSP = 0;

	prei = predArr[i]; suci = nextArr[i];sucj = nextArr[j];

	//Start to check leg:	
	cStartS = depart[j]; vioTWCNEW = FvioTWCus[j];
    cArrTime = cStartS + problem->c[j][i];
	temp = cArrTime - problem->node[i].eTW;
	if (temp > eps)
	{
		vioTWCNEW += temp;
		cStartS = problem->node[i].depart;
	}
	else cStartS = PDS_MAX(problem->node[i].sTW, cArrTime) + problem->node[i].duration;

	idcur=i;
	idpre = prei;
	while (idpre != j) //check reverse from prei to sucj
	{
		cArrTime = cStartS + problem->c[idcur][idpre];
		temp = cArrTime - problem->node[idpre].eTW;
		if (temp > eps)
		{
			vioTWCNEW += temp;
			cStartS = problem->node[idpre].depart;
		}
		else  cStartS = PDS_MAX(problem->node[idpre].sTW, cArrTime) + problem->node[idpre].duration;
	    idcur=idpre; idpre = predArr[idpre];
	}
	//idcur is now sucj; check sucj-->suci & suci till the end of the trip:
	if (suci > 0)
	{
		idnext = suci;
		while (idnext >0)
		{
			cArrTime = cStartS + problem->c[idcur][idnext];
			temp = cArrTime - problem->node[idnext].eTW;
			if (temp > eps)
			{
				vioTWCNEW += temp;
				if (vioTWCus[idnext] > eps)
				{
					varvioTWC = vioTWCNEW - FvioTWCus[idnext];
					varcost = problem->c[j][i] + problem->c[sucj][suci] - problem->c[j][sucj] - problem->c[i][suci];
					return 1;
				}
				cStartS = problem->node[idnext].depart;
			}
			else cStartS = PDS_MAX(problem->node[idnext].sTW, cArrTime) + problem->node[idnext].duration;
			idcur = idnext;idnext=nextArr[idnext];
		}
		varcost = problem->c[j][i] + problem->c[sucj][suci] - problem->c[j][sucj] - problem->c[i][suci];
		varvioTWC = vioTWCNEW - seg[idVeh].Trip[idTrip].vioTWC;
		return calChangeCONNECTAtSP_PickTrip(idcur, idVeh, idTrip, cStartS, varvioTWSP, varcost);
	}
	else //change lastC: i was the last; sucj is now the last
	{
		 varvioTWC = vioTWCNEW - seg[idVeh].Trip[idTrip].vioTWC;
		 varcost = problem->c[j][i] - problem->c[j][sucj];
		 if (seg[idVeh].Trip[idTrip].waitingS == NO_WS)
			 varcost -= problem->c[i][seg[idVeh].Trip[idTrip].assSP];
		 else varcost -= problem->disCWSSP[i][seg[idVeh].Trip[idTrip].assSP];
		 return calChangeCONNECTAtSP_PickTrip_LastCChanged(sucj, idVeh, idTrip, cStartS, varvioTWSP, varcost);
	}//end change lastC: i was the last; sucj is now the last
}

void Solution::cal_twoOPTstarCusPIAndJ_oneTrip_NextTripP(int j, int i, int idVeh, int idTrip, double &varcost, double &varvioTWC, double &varvioTWSP)
{
   double cStartS; 
   if (SUBcal_twoOPTstarCusPIAndJ_oneTrip(j, i, idVeh, idTrip, varcost, varvioTWC, varvioTWSP, cStartS)== 0)
   {
       int nextT = idTrip + 1;
       int firstC_nextT = seg[idVeh].Trip[nextT].firstCus;
       GoThroughVehicle(idVeh, nextT, varcost, varvioTWC, varvioTWSP, cStartS, seg[idVeh].Trip[idTrip].assSP, firstC_nextT);
   }
}

void Solution::cal_twoOPTstarCusPIAndJ_oneTrip_NextTripD_SameSP(int j, int i, int idVeh, int idTrip, double &varcost, double &varvioTWC, double &varvioTWSP)
{
   double cStartS; 
   if (SUBcal_twoOPTstarCusPIAndJ_oneTrip(j, i, idVeh, idTrip, varcost, varvioTWC, varvioTWSP, cStartS)== 0)
   {
		varvioTWSP *=2;
		int assSP = seg[idVeh].Trip[idTrip].assSP;
		cStartS += problem->nodeSP[assSP].load;
	 
		int nextT = idTrip + 1;
 	    int firstC_nextT = seg[idVeh].Trip[nextT].firstCus;
		GoThroughVehicle(idVeh, nextT, varcost, varvioTWC, varvioTWSP, cStartS, assSP, firstC_nextT);
   }
}

void Solution::cal_twoOPTstarCusPIAndJ_oneTrip_NextTripD_DifSP(int j, int i, int idVeh, int idTrip, double &varcost, double &varvioTWC, double &varvioTWSP)
{
   double cStartS; 
   if (SUBcal_twoOPTstarCusPIAndJ_oneTrip(j, i, idVeh, idTrip, varcost, varvioTWC, varvioTWSP, cStartS)== 0)
   {
		int nextT = idTrip + 1;
 	    int firstC_nextT = seg[idVeh].Trip[nextT].firstCus;
		if (calChangeCONNECTAtSP_SPSP(idVeh, nextT, idTrip, cStartS, varvioTWSP, varcost) == 0)
			GoThroughVehicle(idVeh, nextT, varcost, varvioTWC, varvioTWSP, cStartS, seg[idVeh].Trip[nextT].assSP, firstC_nextT);
   }

}

void Solution::cal_twoOPTstarCusPIAndJ_oneTrip(int j, int k)
{
   	int i = problem->node[j].neighborNode[k].id;
	int idVeh = route_num[i]; int idTrip = trip_num[i];
	int lastT = seg[idVeh].numTrips - 1;
	double cStartS;

    twoOPTstarCus[j][k]->var_vioCAP = 0;
	if (idTrip == lastT)
       SUBcal_twoOPTstarCusPIAndJ_oneTrip(j, i, idVeh, idTrip, twoOPTstarCus[j][k]->var_cost, twoOPTstarCus[j][k]->var_vioTWC,  twoOPTstarCus[j][k]->var_vioTWSP, cStartS); //connect j with i where j and i are in the same trip
	else
	{
	   double varcost, varvioTWC, varvioTWSP;
	   if (SUBcal_twoOPTstarCusPIAndJ_oneTrip(j, i, idVeh, idTrip, varcost, varvioTWC, varvioTWSP, cStartS)== 0)
	   {
		   int nextT = idTrip + 1;
		   int firstC_nextT = seg[idVeh].Trip[nextT].firstCus;
		   if (seg[idVeh].Trip[nextT].Type)
		   {
			   int assSP = seg[idVeh].Trip[idTrip].assSP;
			   if (assSP == seg[idVeh].Trip[nextT].assSP) //same SP
			   {
					varvioTWSP *=2;
					cStartS += problem->nodeSP[assSP].load;
					GoThroughVehicle(idVeh, nextT, varcost, varvioTWC, varvioTWSP, cStartS, assSP, firstC_nextT);
			   }
			   else //dif SP
			   {
					if (calChangeCONNECTAtSP_SPSP(idVeh, nextT, idTrip, cStartS, varvioTWSP, varcost) == 0)
						GoThroughVehicle(idVeh, nextT, varcost, varvioTWC, varvioTWSP, cStartS, seg[idVeh].Trip[nextT].assSP, firstC_nextT);
			   }
		   }
		   else
		       GoThroughVehicle(idVeh, nextT, varcost, varvioTWC, varvioTWSP, cStartS, seg[idVeh].Trip[idTrip].assSP, firstC_nextT);
	   }
	   twoOPTstarCus[j][k]->var_cost = varcost;
	   twoOPTstarCus[j][k]->var_vioTWSP = varvioTWSP;
	   twoOPTstarCus[j][k]->var_vioTWC = varvioTWC;

	}

}

void Solution::cal_twoOPTstarCusPIAndJ(int j, int k) //j and its neighbor #k belong to different vehicles
{
	//Moi trip sau idTripi va idTripj giu nguyen vehicle, ko exchange vehicle cua chung:
	int i = problem->node[j].neighborNode[k].id; //connect j with i
	int prei, suci, prej, sucj, idcur, idnext;

	int idVehj = route_num[j]; int idVehi = route_num[i];
	int idTripj = trip_num[j]; int idTripi = trip_num[i];
	int assSPi = seg[idVehi].Trip[idTripi].assSP;
	int assSPj = seg[idVehj].Trip[idTripj].assSP;

	prei = predArr[i]; suci = nextArr[i];
	prej = predArr[j]; sucj = nextArr[j];

	int capi;
	int capj = FCAP[j] + BCAP[i];

	if (prei <0 && sucj <0) //Tripi becomes empty after move
	{
		if (capj > exceed) //24Oct: too long route & still don't have move to cut it--> don't use this move when capacity exceeds 1.5 capacity of the vehicle
		{
			  twoOPTstarCus[j][k]->var_vioCAP = PDS_INFINITY;
			  return;
		}
	}
	else //Tripi is not empty after move
	{
		capi=0; 
		if (prei > 0) capi = FCAP[prei];
		if (sucj>0) capi += BCAP[sucj];
		if (capj > exceed || capi > exceed)
		{
			 twoOPTstarCus[j][k]->var_vioCAP = PDS_INFINITY;
			 return;
		}
	}


		int varvioCAP;
		double cStartS, cArrTime,temp;
		double varcosti, varcostj;
		double varvioTWCi, varvioTWCj, varvioTWSPi = 0, varvioTWSPj = 0;

		int lastCOLDj = seg[idVehj].Trip[idTripj].lastCus;
		int lastCOLDi = seg[idVehi].Trip[idTripi].lastCus;

        //Start to check trip j	
		varcostj = problem->c[j][i];
		if (sucj >0) varcostj -= problem->c[j][sucj];
		if (seg[idVehj].Trip[idTripj].waitingS == NO_WS)
			varcostj -= problem->c[lastCOLDj][assSPj];
		else varcostj -= problem->disCWSSP[lastCOLDj][assSPj];

		cStartS = depart[j]; 
        cArrTime = cStartS + problem->c[j][i];
		temp = cArrTime - problem->node[i].eTW;
		if (temp > eps)
		{
			if (vioTWCus[i] > eps)
			{
				varvioTWCj = temp - vioTWCus[i];
				cStartS = depart[lastCOLDi];
				goto CalConnectj;
			}
			varvioTWCj = temp;
			cStartS = problem->node[i].depart;
		}
		else cStartS = PDS_MAX(cArrTime, problem->node[i].sTW) + problem->node[i].duration;

		idcur=i;
		if (suci > 0) //need to check TW till the end of the trip i:
		{
			idnext = suci;
	        while (idcur != lastCOLDi) //check from suci till the end of the leg i
		    {
		        cArrTime = cStartS + problem->c[idcur][idnext];
				temp = cArrTime - problem->node[idnext].eTW;
				if (temp > eps)
				{
					if (vioTWCus[idnext] > eps)
					{
						varvioTWCj += (temp - vioTWCus[idnext]); 
						cStartS = depart[lastCOLDi];
						goto CalConnectj;
					}
					varvioTWCj += temp;
					cStartS = problem->node[idnext].depart;
				}
				else cStartS = PDS_MAX(problem->node[idnext].sTW, cArrTime) + problem->node[idnext].duration;
			    idcur=idnext; idnext = nextArr[idcur];
		    }
		}
		//idcur is now the NEW last customer of the tripj: = lastCOLDi
	CalConnectj:
		//lastC is changed: old lastCus = lastCOLDj; new lastcus = lastCOLDi
		bool stop = calChangeCONNECTAtSP_PickTrip_LastCChanged(lastCOLDi, idVehj, idTripj, cStartS, varvioTWSPj, varcostj);
        if (stop == 0)
		{
			int nextTj = idTripj + 1;
			if (nextTj < seg[idVehj].numTrips) // Tripj is not the last trip
			{
				int firstC_nextT = seg[idVehj].Trip[nextTj].firstCus;
				if (seg[idVehj].Trip[nextTj].Type)
				{
					if (seg[idVehj].Trip[nextTj].assSP == assSPj)
					{
						varvioTWSPj *= 2;
						cStartS += problem->nodeSP[assSPj].load;
						GoThroughVehicle(idVehj, nextTj, varcostj, varvioTWCj, varvioTWSPj, cStartS, assSPj, firstC_nextT);
					}
					else // p - asssP -- asssP1 - d
					{
						if (calChangeCONNECTAtSP_SPSP(idVehj, nextTj, idTripj, cStartS, varvioTWSPj, varcostj) ==0)
						    GoThroughVehicle(idVehj, nextTj, varcostj, varvioTWCj, varvioTWSPj, cStartS, seg[idVehj].Trip[nextTj].assSP, firstC_nextT);
					}
				}
				else //nextTj is pickup trip:
				{
                    GoThroughVehicle(idVehj, nextTj, varcostj, varvioTWCj, varvioTWSPj, cStartS, assSPj, firstC_nextT);
				}//end nextTj is pickup trip
			}
		}

		int nextTripi = idTripi+1;
		bool empty_idVehi = 0;
		if (seg[idVehi].Trip[idTripi].waitingS == NO_WS)
			varcosti = -problem->c[lastCOLDi][assSPi];
		else varcosti = -problem->disCWSSP[lastCOLDi][assSPi];

		if (prei <0 && sucj <0) //Tripi becomes empty after move
		{
			varcosti -= seg[idVehi].Trip[idTripi].connectCost;
	        varvioTWCi = 0;
			int vioCapj = PDS_MAX(capj - problem->Q, 0);
			varvioCAP = -seg[idVehi].Trip[idTripi].vioCAP + (vioCapj - seg[idVehj].Trip[idTripj].vioCAP);
			varvioTWSPi = -seg[idVehi].Trip[idTripi].vioTWSP;

			if (seg[idVehi].numTrips ==1) // after move, idVehi becomes empty
			{
				 varcosti -= problem->c[0][i];
				 empty_idVehi = 1;
			}
			else //vehicle i has >= 2trips
			{
				if (idTripi == 0) //tripi is the first trip
				{
					varcosti -= problem->c[0][i];
					if (seg[idVehi].Trip[1].Type == 1) //nextTripi is delivery trip: ok
					{
					   varvioTWSPi -= seg[idVehi].Trip[1].vioTWSP;
					   int assSP1 = seg[idVehi].Trip[1].assSP;
					   varcosti += problem->c[0][assSP1];
					   cStartS = problem->leaveSP[assSP1][4]; //load only at sTW2
					   if (PDSDIF(cStartS, seg[idVehi].Trip[1].leaveSP) == 0)
						   goto Update;
					   else
					   {
					       int firstC_nextT = seg[idVehi].Trip[1].firstCus; 
						   GoThroughVehicle(idVehi,1, varcosti, varvioTWCi, varvioTWSPi, cStartS, assSP1, firstC_nextT);
					   }
					}
					else //nextTripi is pickup trip
					{
						int firstC_nextT = seg[idVehi].Trip[1].firstCus;
						varcosti += problem->c[0][firstC_nextT];
						cStartS = 0;
					    GoThroughVehicle(idVehi, 1, varcosti, varvioTWCi, varvioTWSPi, cStartS, 0, firstC_nextT);
					}//end nextTripi is pickup trip (CASE: tripi becomes empty, tripi is the first trip)
				}
				else //tripi is not the first trip:
				{
					 int preTripi = idTripi - 1;
					 varcosti -= seg[idVehi].Trip[preTripi].connectCost;
                     if (nextTripi == seg[idVehi].numTrips) //tripi is the last trip
					 {
						 if (seg[idVehi].Trip[preTripi].Type)
							 varcosti += problem->c[seg[idVehi].Trip[preTripi].lastCus][0];
						 else
							 varcosti += problem->c[seg[idVehi].Trip[preTripi].assSP][0];
					 }
					 else //idTripi is not the lastTrip (is middle)
					 {
						 if (seg[idVehi].Trip[preTripi].Type == 0) //preTripi is the pickup trip
						 {
							 cStartS = seg[idVehi].Trip[preTripi].leaveSP;
							 int assSPprei = seg[idVehi].Trip[preTripi].assSP;
							 if (seg[idVehi].Trip[nextTripi].Type) // nextTripi is delivery trip
							 {
                                  bool stop = calCONNECTCSPTOSPD_FORDELETE(assSPprei, idVehi, nextTripi, cStartS, varvioTWSPi, varcosti);
                                  if (stop) goto Update;
								  int firstC_nextT = seg[idVehi].Trip[nextTripi].firstCus;
								  GoThroughVehicle(idVehi, nextTripi, varcosti, varvioTWCi, varvioTWSPi, cStartS, seg[idVehi].Trip[nextTripi].assSP, firstC_nextT);
							 }//end preTripi is pickup, nextTripi is delivery
							 else //preTripi is pickup, nextTripi is pickup
							 {
								 int firstC_nextT = seg[idVehi].Trip[nextTripi].firstCus;
								 varcosti += problem->c[assSPprei][firstC_nextT];
								 GoThroughVehicle(idVehi, nextTripi, varcosti, varvioTWCi, varvioTWSPi, cStartS, assSPprei, firstC_nextT);
							 }//end preTripi is pickup, nextTripi is pickup
						 }
						 else //preTripi is delivery trip
						 {
							 int lastCprei = seg[idVehi].Trip[preTripi].lastCus;
							 cStartS = depart[lastCprei];
							 if (seg[idVehi].Trip[nextTripi].Type) //nextTripi is delivery trip
							 {
                                 bool stop = calCONNECTCSPTOSPD_FORDELETE(lastCprei, idVehi, nextTripi, cStartS, varvioTWSPi, varcosti);
                                 if (stop) goto Update;
								 int assSP1 = seg[idVehi].Trip[nextTripi].assSP;
								 int firstC_nextT = seg[idVehi].Trip[nextTripi].firstCus;
								 GoThroughVehicle(idVehi, nextTripi, varcosti, varvioTWCi, varvioTWSPi, cStartS, assSP1, firstC_nextT);
							 }//end nextTripi is delivery trip; preTripi is delivery trip
							 else //nextTripi is pickup trip; preTripi is delivery trip
							 {
								 int firstC_nextT = seg[idVehi].Trip[nextTripi].firstCus;
								 varcosti += problem->c[lastCprei][firstC_nextT];
								 GoThroughVehicle(idVehi, nextTripi, varcosti, varvioTWCi, varvioTWSPi, cStartS, lastCprei, firstC_nextT);
							 }//end nextTripi is pickup trip; preTripi is delivery trip
						 }//end preTripi is delivery trip
					 }//end //idTripi is not the lastTrip (is middle)
				}//end tripi is not the first trip
			}//end vehicle i has >= 2 trips
		}
		else //Tripi is not empty after move
		{
			 int vioCapi = PDS_MAX(capi - problem->Q, 0);
			 int vioCapj = PDS_MAX(capj - problem->Q, 0);
			 varvioCAP = (vioCapi - seg[idVehi].Trip[idTripi].vioCAP) + (vioCapj - seg[idVehj].Trip[idTripj].vioCAP);

			//Start to check trip i	
			if (prei > 0)
			{
				cStartS = depart[prei]; 
				varcosti -= problem->c[prei][i];
				if (sucj > 0) varcosti += problem->c[prei][sucj];
			}
			else //prei < 0 --> sucj > 0
			{
				if (idTripi == 0)
				{
					prei = 0;
					cStartS = 0;
				}
				else
				{
					int preTi = idTripi - 1;
					if (seg[idVehi].Trip[preTi].Type)
					{
					   prei = seg[idVehi].Trip[preTi].lastCus;
					   cStartS = depart[prei];
					}
					else
					{
						prei = seg[idVehi].Trip[preTi].assSP;
						cStartS = seg[idVehi].Trip[preTi].leaveSP;
					}
				}
				varcosti += (problem->c[prei][sucj] - problem->c[prei][i]);
			}

			varvioTWCi = 0;
			idcur = prei;
			if (sucj >0)
			{
				idnext = sucj;
				while (idcur != lastCOLDj) //check from previ till the end of the leg j
				{
					cArrTime = cStartS + problem->c[idcur][idnext];
					temp = cArrTime - problem->node[idnext].eTW;
					if (temp > eps)
					{
						if (vioTWCus[idnext] > eps)
						{
							varvioTWCi += (temp - vioTWCus[idnext]);
							cStartS = depart[lastCOLDj];
							idcur = lastCOLDj;
							goto CalConnecti;
						}
						varvioTWCi += temp;
						cStartS = problem->node[idnext].depart;
					}
					else cStartS = PDS_MAX(problem->node[idnext].sTW, cArrTime) + problem->node[idnext].duration;
					idcur=idnext; idnext = nextArr[idcur];
				}
			}
			//idcur is now the last customer of new idTripi: = lastCOLDj OR prei
		    CalConnecti:
				bool stop = calChangeCONNECTAtSP_PickTrip_LastCChanged(idcur, idVehi, idTripi, cStartS, varvioTWSPi, varcosti);
				if (stop == 0)
				{
					int nextTi = idTripi + 1;
					if (nextTi < seg[idVehi].numTrips) // Tripi is not the last trip
					{
						int firstC_nextT = seg[idVehi].Trip[nextTi].firstCus;
						if (seg[idVehi].Trip[nextTi].Type)
						{
							if (seg[idVehi].Trip[nextTi].assSP == assSPi)
							{
								varvioTWSPi *= 2;
								cStartS += problem->nodeSP[assSPi].load;
								GoThroughVehicle(idVehi, nextTi, varcosti, varvioTWCi, varvioTWSPi, cStartS, assSPi, firstC_nextT);
							}
							else // p - asssP -- asssP1 - d
							{
								if (calChangeCONNECTAtSP_SPSP(idVehi, nextTi, idTripi, cStartS, varvioTWSPi, varcosti) ==0)
									GoThroughVehicle(idVehi, nextTi, varcosti, varvioTWCi, varvioTWSPi, cStartS, seg[idVehi].Trip[nextTi].assSP, firstC_nextT);
							}
						}
						else //nextTi is pickup trip:
						{
							GoThroughVehicle(idVehi, nextTi, varcosti, varvioTWCi, varvioTWSPi, cStartS, assSPi, firstC_nextT);
						}//end nextTi is pickup trip
					}
				}
	}//end Tripi is not empty after move

    Update:
	    twoOPTstarCus[j][k]->var_vioTWC = varvioTWCi + varvioTWCj;
		twoOPTstarCus[j][k]->var_vioTWSP = varvioTWSPi + varvioTWSPj;
		//twoOPTstarCus[j][k]->var_vioTWSPi = varvioTWSPi;//Quang--
		//twoOPTstarCus[j][k]->var_vioTWSPj = varvioTWSPj;//Quang--

		twoOPTstarCus[j][k]->var_vioCAP = varvioCAP;
		twoOPTstarCus[j][k]->var_cost = varcosti + varcostj;
        //twoOPTstarCus[j][k]->var_costi = varcosti;//Quang--
		//twoOPTstarCus[j][k]->var_costj = varcostj;//Quang--
		twoOPTstarCus[j][k]->atIT = IT;
		if (empty_idVehi) twoOPTstarCus[j][k]->empty = 1;
		else twoOPTstarCus[j][k]->empty = 0;
}

int Solution::CreateNewVeh_DTrip(int idCus)
{
	int i;
	for (i=0;i<numVeh;i++)
		if (seg[i].numTrips == 0) break;
	seg[i].numTrips=1;
	seg[i].Trip[0].Type = 1;
	seg[i].Trip[0].coordinate = 0;
	seg[i].Trip[0].assSP = problem->node[idCus].zone;
	seg[i].Trip[0].firstCus = idCus;
	seg[i].Trip[0].lastCus= idCus;
	seg[i].Trip[0].numCus=1;
	numVehUsed++;
    nextArr[idCus]=-1; predArr[idCus]=-1;

	seg[i].Trip[0].leaveSP = problem->leaveSP[seg[i].Trip[0].assSP][4];

	
	double cArrTime = seg[i].Trip[0].leaveSP + problem->c[seg[i].Trip[0].assSP][idCus];
	double temp = cArrTime - problem->node[idCus].eTW;
	if (temp > eps)
	{
		vioTWCus[idCus] = temp;
		FvioTWCus[idCus] = temp; BvioTWCus[idCus] = temp;
		startS[idCus] = problem->node[idCus].eTW;
		depart[idCus] = problem->node[idCus].depart;
	}
	else
	{
		vioTWCus[idCus] = 0;
		FvioTWCus[idCus] = 0; BvioTWCus[idCus] = 0;
		startS[idCus] = PDS_MAX(cArrTime, problem->node[idCus].sTW);
		depart[idCus] = startS[idCus] + problem->node[idCus].duration;
	}
   
	seg[i].Trip[0].endS = depart[idCus];
    seg[i].Trip[0].cost = problem->c[0][seg[i].Trip[0].assSP] + problem->c[seg[i].Trip[0].assSP][idCus];
	seg[i].Trip[0].connectCost = problem->c[idCus][0];
	seg[i].Trip[0].capacity = problem->node[idCus].capacity;
	seg[i].Trip[0].vioCAP = 0;
	seg[i].Trip[0].vioTWC = vioTWCus[idCus];
	seg[i].Trip[0].vioTWSP = 0;
	seg[i].Trip[0].waitingS = NO_WS;
	if (seg[i].Trip[0].vioTWC > eps)
	{
        seg[i].Trip[0].feasible = 0;
		seg[i].Trip[0].fitness = seg[i].Trip[0].cost + vioTWCC * seg[i].Trip[0].vioTWC;
	}
	else
	{
		seg[i].Trip[0].feasible=1;
	    seg[i].Trip[0].fitness = seg[i].Trip[0].cost;
	}
	route_num[idCus]=i; trip_num[idCus]=0;
	FCAP[idCus]=problem->node[idCus].capacity;
	BCAP[idCus] = problem->node[idCus].capacity;
	pos[idCus] = 1;
	
	cout<<"NEW VEHICLE: with fit = "<<seg[i].Trip[0].fitness<<"; cost = "<<seg[i].Trip[0].cost<<"; c = "<<problem->c[seg[i].Trip[0].assSP][idCus]<<"; idCus = "<<idCus<<endl;
	cout<<"sp = "<<problem->node[idCus].zone<<endl;
	showTripCost(i,0);
	//UpdateMoveSPNotEmptyVeh(i); CAN XEM
	return i;
}

void Solution::deleteCusDTrip(int idVeh, int idTrip, int idCus)
{
	int pre = predArr[idCus]; int next = nextArr[idCus];
	int preID = pre; int nextID = next;
	int assSP = seg[idVeh].Trip[idTrip].assSP;
	int lastCus = seg[idVeh].Trip[idTrip].lastCus;

    double cStartS,cArrTime,temp;

	int capDEL = problem->node[idCus].capacity;
	seg[idVeh].Trip[idTrip].capacity -= capDEL;
	int vioCAPNEW = PDS_MAX(seg[idVeh].Trip[idTrip].capacity - problem->Q,0);
	int varvioCAP = vioCAPNEW - seg[idVeh].Trip[idTrip].vioCAP;
	seg[idVeh].Trip[idTrip].vioCAP = vioCAPNEW;

	seg[idVeh].Trip[idTrip].numCus -=1;

	double varcost, varvioTWC;
    int nextTrip = idTrip + 1;
	int id;
	
    if (nextTrip == seg[idVeh].numTrips) //idCus belongs to the last delivery trip >= 2customers
	{
		if (pre <0)  //delete the first cus
		{
			cStartS = seg[idVeh].Trip[idTrip].leaveSP;
			seg[idVeh].Trip[idTrip].firstCus = next;
		    predArr[next] = -1;
			preID = assSP;
			varcost = problem->c[assSP][next] - problem->c[assSP][idCus] - problem->c[idCus][next];
		}
		else //pre > 0
		{
			cStartS = depart[pre];
			if (next > 0) //delete the middle cus
			{
				varcost = problem->c[pre][next] - problem->c[pre][idCus] - problem->c[idCus][next];
				nextArr[pre] = next; predArr[next] = pre;
			}
			else //delete the last cus
			{	
				varcost = problem->c[pre][0] - problem->c[pre][idCus] - problem->c[idCus][0];
				seg[idVeh].Trip[idTrip].lastCus = pre;
				seg[idVeh].Trip[idTrip].connectCost = problem->c[pre][0];
				nextArr[pre] = -1;
			}
		}

		while (nextID >0)
		{
			cArrTime = cStartS + problem->c[preID][nextID]; //arrTime at customer nextID
			cStartS = PDS_MAX(cArrTime, problem->node[nextID].sTW);
            if (PDSDIF(cStartS, startS[nextID])==0) //it means varvioTWCus[curC] =0 
			{
				//update BvioTWCus from preID to first Cus
				id = nextID;
				while (preID != pre)
				{
					BvioTWCus[preID] = BvioTWCus[id] + vioTWCus[preID];
					id = preID; preID = predArr[id];
				}
				//update BCAP from pre to firstCus
				id = next;
				while (preID > 0)
				{
					BvioTWCus[preID] = BvioTWCus[id] + vioTWCus[preID];
					BCAP[preID] -= capDEL;
					id = preID; preID = predArr[id];
				}
				//update FCAP, FvioTWCus from nextID to lastCus:
				id = nextID; preID = predArr[nextID];
				do
				{
					FCAP[id] -= capDEL;
					FvioTWCus[id] = FvioTWCus[preID] + vioTWCus[id];
					preID = id; id = nextArr[id];
				}while (id > 0);
				//preID now points to lastCus
				varvioTWC = FvioTWCus[preID] - seg[idVeh].Trip[idTrip].vioTWC;
				seg[idVeh].Trip[idTrip].vioTWC = FvioTWCus[preID];
				goto Update;
			}
			temp = cStartS - problem->node[nextID].eTW;
			if (temp > eps)
			{
				if (vioTWCus[nextID] > eps) 
				{
					vioTWCus[nextID] = temp;
					//Update BvioTWCus from nextID to firstCus
					id = nextArr[nextID];
					if (id < 0) BvioTWCus[nextID] = vioTWCus[nextID];
					else BvioTWCus[nextID] = BvioTWCus[id] + vioTWCus[nextID];
					id = nextID;
					while (preID != pre)
					{
						BvioTWCus[preID] = BvioTWCus[id] + vioTWCus[preID];
						id = preID; preID = predArr[id];
					}
					//update BCAP from pre to firstCus:
					id = next;
					while (preID > 0)
					{
						BvioTWCus[preID] = BvioTWCus[id] + vioTWCus[preID];
						BCAP[preID] -= capDEL;
						id = preID; preID = predArr[id];
					}
					//Update FCAP and FvioTWCus from nextID to lastCus
					id = nextID; preID = predArr[nextID];
					do
					{
						FCAP[id] -= capDEL;
						FvioTWCus[id] = FvioTWCus[preID] + vioTWCus[id];
						preID = id; id = nextArr[id];
					}while (id > 0);
					//preID now points to lastCus
					varvioTWC = FvioTWCus[preID] - seg[idVeh].Trip[idTrip].vioTWC;
					seg[idVeh].Trip[idTrip].vioTWC = FvioTWCus[preID];
					goto Update;
				}
				vioTWCus[nextID] = temp;
				FvioTWCus[nextID] = FvioTWCus[preID] + temp;
				cStartS = problem->node[nextID].eTW;
			}
            startS[nextID] = cStartS;
			cStartS += problem->node[nextID].duration;
			depart[nextID] = cStartS;
			FCAP[nextID] -= capDEL;
			preID = nextID; nextID = nextArr[nextID];
		}
		seg[idVeh].Trip[idTrip].endS = cStartS;
		varvioTWC = FvioTWCus[preID] - seg[idVeh].Trip[idTrip].vioTWC;
        seg[idVeh].Trip[idTrip].vioTWC = FvioTWCus[preID];
		//preID now points to the last cus:
		//Update BCAP from pre to firstCus
		//Update BvioTWCus from lastCus to firstCus
		if (next > 0)
		{
			BvioTWCus[preID] = vioTWCus[preID];
			id = predArr[preID];
			while (id != pre)
			{
				BvioTWCus[id] = BvioTWCus[preID] + vioTWCus[id];
				preID = id; id = predArr[id];
			}
			while (id > 0)
			{
				BvioTWCus[id] = BvioTWCus[preID] + vioTWCus[id];
				BCAP[id] -= capDEL;
				preID = id; id = predArr[id];
			}
		}
		else //delete the last cus:
		{
			BvioTWCus[preID] = vioTWCus[preID];
			BCAP[preID] -= capDEL;
			id = predArr[preID];
			while (id > 0)
			{
				BvioTWCus[id] = BvioTWCus[preID] + vioTWCus[id];
				BCAP[id] -= capDEL; //ok
				preID = id; id = predArr[id];
			}
		}

   Update:
		seg[idVeh].Trip[idTrip].cost += varcost;
		double varFIT = varcost + VCAP * varvioCAP + VTWCUS * varvioTWC;
		if (FvioTWCus[seg[idVeh].Trip[idTrip].lastCus] > eps || vioCAPNEW > 0 || seg[idVeh].Trip[idTrip].vioTWSP > eps)
		{
			seg[idVeh].Trip[idTrip].feasible = 0;
			seg[idVeh].Trip[idTrip].fitness +=  varFIT;
		}
		else
		{
			seg[idVeh].Trip[idTrip].feasible = 1;
			seg[idVeh].Trip[idTrip].fitness = seg[idVeh].Trip[idTrip].cost;
		}
		seg[idVeh].cost += varcost; seg[idVeh].fitness += varFIT; seg[idVeh].vioCAP += varvioCAP; seg[idVeh].vioTWC += varvioTWC;
		cost += varcost; fitness += varFIT; vioCAP += varvioCAP; vioTWC += varvioTWC;
	}
	else //vehicle has >= 2 trips, delivery trip >= 2 customers not the last trip:
	{
			if (pre <0)  //delete the first cus
			{
				cStartS = seg[idVeh].Trip[idTrip].leaveSP;
				seg[idVeh].Trip[idTrip].firstCus = next;
				predArr[next] = -1;
				preID = assSP;
				varcost = problem->c[assSP][next] - problem->c[assSP][idCus] - problem->c[idCus][next];
			}
			else 
			{
				cStartS = depart[pre];
				if (next > 0)
					varcost = problem->c[pre][next] - problem->c[pre][idCus] - problem->c[idCus][next];
			}
			while (nextID >0)
			{
				cArrTime = cStartS + problem->c[preID][nextID]; //arrTime at customer nextID
				cStartS = PDS_MAX(cArrTime, problem->node[nextID].sTW);
				cStartS = PDS_MAX(cArrTime, problem->node[nextID].sTW);
				if (PDSDIF(cStartS, startS[nextID])==0) //it means varvioTWCus[nextID] =0 
				{
					//Update BvioTWCus from preID to firstCus
					id = nextID;
					while (preID != pre)
					{
						BvioTWCus[preID] = BvioTWCus[id] + vioTWCus[preID];
						id = preID; preID = predArr[id];
					}
					//Update BCAP from pre to firstCus
					id = next;
					while (preID > 0)
					{
						BvioTWCus[preID] = BvioTWCus[id] + vioTWCus[preID];
						BCAP[preID] -= capDEL;
						id = preID; preID = predArr[id];
					}
					//Update FCAP, FvioTWCus from nextID to lastCus
					id = nextID; preID = predArr[id];
					do
					{
						FCAP[id] -= capDEL;
						FvioTWCus[id] = FvioTWCus[preID] + vioTWCus[id];
						preID = id; id = nextArr[id];
					}while (id > 0);
					//preID now points to lastCus
					varvioTWC = FvioTWCus[preID] - seg[idVeh].Trip[idTrip].vioTWC;
					seg[idVeh].Trip[idTrip].vioTWC = FvioTWCus[preID];
					goto Update1;
				}
				temp = cStartS - problem->node[nextID].eTW;
				if (temp > eps)
				{
					if (vioTWCus[nextID] > eps) 
					{
						vioTWCus[nextID] = temp;
						//Update BvioTWCus from nextID to the firstCus
						id = nextArr[nextID];
						if (id < 0) BvioTWCus[nextID] = vioTWCus[nextID];
						else BvioTWCus[nextID] = BvioTWCus[id] + vioTWCus[nextID];
						id = nextID;
						while (preID != pre)
						{
							BvioTWCus[preID] = BvioTWCus[id] + vioTWCus[preID];
							id = preID; preID = predArr[id];
						}
						//Update BCAP from pre to firstCus
						id = next;
						while (preID > 0)
						{
							BvioTWCus[preID] = BvioTWCus[id] + vioTWCus[preID];
							BCAP[preID] -= capDEL;
							id = preID; preID = predArr[id];
						}

						//Update FCAP and FvioTWCus from nextID to lastCus
						id = nextID; preID = predArr[nextID];
						do
						{
							FCAP[id] -= capDEL;
							FvioTWCus[id] = FvioTWCus[preID] + vioTWCus[id];
							preID = id; id = nextArr[id];
						}while (id > 0);
						varvioTWC = FvioTWCus[preID] - seg[idVeh].Trip[idTrip].vioTWC;
						seg[idVeh].Trip[idTrip].vioTWC = FvioTWCus[preID];

						goto Update1;
					}
					vioTWCus[nextID] = temp;
					FvioTWCus[nextID] = FvioTWCus[preID] + temp;
					cStartS = problem->node[nextID].eTW;
				}
                startS[nextID] = cStartS;
				cStartS += problem->node[nextID].duration;
				depart[nextID] = cStartS;
				FCAP[nextID] -= capDEL;
				preID = nextID; nextID = nextArr[nextID];
			}
			seg[idVeh].Trip[idTrip].endS = cStartS;
			varvioTWC = FvioTWCus[preID] - seg[idVeh].Trip[idTrip].vioTWC;
			seg[idVeh].Trip[idTrip].vioTWC = FvioTWCus[preID];
			//preID now points to lastCus:
			if (seg[idVeh].Trip[idTrip].vioTWSP > eps || seg[idVeh].Trip[idTrip].vioCAP > 0 || seg[idVeh].Trip[idTrip].vioTWC > eps)
				seg[idVeh].Trip[idTrip].feasible = 0;
			else
				seg[idVeh].Trip[idTrip].feasible = 1;

			//Update BvioTWCus from lastCus to the firstCus
			//Update BCAP from pre to firstCus
			if (next > 0) //not delete the lastCus
			{
				BvioTWCus[preID] = vioTWCus[preID];
				id = predArr[preID];
				while (id != pre)
				{
					BvioTWCus[id] = BvioTWCus[preID] + vioTWCus[id];
					preID = id; id = predArr[id];
				}
				while (id > 0)
				{
					BvioTWCus[id] = BvioTWCus[preID] + vioTWCus[id];
					BCAP[id] -= capDEL;
					preID = id; id = predArr[id];
				}

				preID = seg[idVeh].Trip[nextTrip].lastCus;
				if (seg[idVeh].Trip[nextTrip].Type) //nextTrip is delivery trip, not delete the last cus of idTrip
				{
					bool stop = calChangeCONNECTAtSP_DD(preID, idVeh, nextTrip, idTrip, varvioCAP, varvioTWC, varcost);
					if (stop == 0){
						//UpdateVehicle(idVeh, nextTrip, seg[idVeh].Trip[nextTrip].assSP, seg[idVeh].Trip[nextTrip].leaveSP, varvioCAP);//Quang--
					}
					goto Update2;
				}
				else //next Trip is pickup, not delete the last cus of idTrip
				{
					double varFIT = varcost + VCAP * varvioCAP + VTWCUS * varvioTWC;
					seg[idVeh].Trip[idTrip].cost += varcost;
					seg[idVeh].Trip[idTrip].fitness += varFIT;

					//UpdateVehicle(idVeh, nextTrip, preID, seg[idVeh].Trip[idTrip].endS, varvioCAP);//Quang--
					goto Update2;
				}//end nextTrip is pickup, not delete the last cus of idTrip
			}
			else //delete the lastCus:
			{
				BvioTWCus[preID] = vioTWCus[preID];
				BCAP[preID] -= capDEL;
				id = predArr[preID];
				while (id > 0)
				{
					BvioTWCus[id] = BvioTWCus[preID] + vioTWCus[id];
					BCAP[id] -= capDEL;
					preID = id; id = predArr[preID];
				}
				if (seg[idVeh].Trip[nextTrip].Type) //nextTrip is delivery trip, delete the last cus of idTrip:
				{
					varcost = -problem->c[pre][idCus];
					bool stop = calChangeCONNECTAtSP_DD_LastCChanged(idCus, pre, idVeh, nextTrip, idTrip, varvioCAP, varvioTWC,varcost); //for deleteCusD procedure
					if (stop == 0)
						//UpdateVehicle(idVeh, nextTrip, seg[idVeh].Trip[nextTrip].assSP, seg[idVeh].Trip[nextTrip].leaveSP, varvioCAP);//Quang--
					goto Update2;
				}
				else //nextTrip is pickup, delete the last cus of idTrip
				{
					int firstC_nextT = seg[idVeh].Trip[nextTrip].firstCus;
					varcost = problem->c[pre][firstC_nextT] - problem->c[pre][idCus] - problem->c[idCus][firstC_nextT];
					seg[idVeh].Trip[idTrip].connectCost = problem->c[pre][firstC_nextT];
					seg[idVeh].Trip[idTrip].cost += varcost;
					double varFIT = varcost + VCAP * varvioCAP + VTWCUS * varvioTWC;
					seg[idVeh].Trip[idTrip].fitness += varFIT;
					//UpdateVehicle(idVeh, nextTrip, pre, seg[idVeh].Trip[idTrip].endS, varvioCAP);//Quang--
					goto Update2;
				}//end nextTrip is pickup, delete the last cus of idTrip
			}
   Update1: //this happened when not delete the last cus
			double varFIT = varcost + VCAP * varvioCAP + VTWCUS * varvioTWC;
			seg[idVeh].Trip[idTrip].cost += varcost;
			seg[idVeh].Trip[idTrip].fitness += varFIT;
			if (seg[idVeh].Trip[idTrip].vioTWSP > eps || seg[idVeh].Trip[idTrip].vioCAP > 0 || seg[idVeh].Trip[idTrip].vioTWC > eps)
				seg[idVeh].Trip[idTrip].feasible = 0;
			else
				seg[idVeh].Trip[idTrip].feasible = 1;
			seg[idVeh].cost += varcost; seg[idVeh].fitness += varFIT; 
			seg[idVeh].vioCAP += varvioCAP; seg[idVeh].vioTWC += varvioTWC;
			cost += varcost; fitness += varFIT; vioCAP += varvioCAP; vioTWC += varvioTWC;
	}//end vehicle has >= 2 trips, delivery trip >= 2 customers, not the last trip

Update2:
    UpdatePos(idVeh, idTrip);
	bool stop = checkTripD_ALLFIELDS(idVeh, idTrip);
	if (stop)
	{
	  cout<<"STOP AT deleteCusDTrip @IT = "<<IT<<endl;
	  exit(-1);
	}
	//return 0;
}

void Solution::insertCusDTrip(int insert_after, int IDinsert, int idVeh, int idTrip) //insert IDinsert after insert_after: note that insert_after is always a customer, so don't need tocheck if it is startSP or endSP or not
{
    //cout<<"Cost old = "<<seg[idVeh].leg[idLeg].cost<<"; fitold = "<<seg[idVeh].leg[idLeg].fitness<<endl; 
	route_num[IDinsert] = idVeh; trip_num[IDinsert] = idTrip;
    
	//1. Update capacity, numCus, vio_CAP
	int capINS = problem->node[IDinsert].capacity;
	seg[idVeh].Trip[idTrip].capacity += capINS;
	int vioCAPNEW = PDS_MAX(seg[idVeh].Trip[idTrip].capacity - problem->Q,0);
	int varvioCAP = vioCAPNEW - seg[idVeh].Trip[idTrip].vioCAP;
	seg[idVeh].Trip[idTrip].vioCAP = vioCAPNEW;
	
	seg[idVeh].Trip[idTrip].numCus += 1;

	int assSP = seg[idVeh].Trip[idTrip].assSP; 
	int lastCOLD = seg[idVeh].Trip[idTrip].lastCus;
	int next = nextArr[insert_after];
	int nextTrip = idTrip + 1;
	double varcost, varvioTWC, cStartS, temp, cArrTime;
	int id;


    if (nextTrip == seg[idVeh].numTrips) //idCus belongs to the last delivery trip >= 2customers
	{
		if (next > 0)
		{
			varcost = problem->c[insert_after][IDinsert] + problem->c[IDinsert][next] - problem->c[insert_after][next];
            nextArr[insert_after] = IDinsert; predArr[IDinsert] = insert_after;
			nextArr[IDinsert] = next; predArr[next] = IDinsert;
		}
		else //insert at the end of the trip
		{
			varcost = problem->c[insert_after][IDinsert] + problem->c[IDinsert][0] - problem->c[insert_after][0];
			nextArr[insert_after] = IDinsert; predArr[IDinsert] = insert_after;
			nextArr[IDinsert] = -1;
			seg[idVeh].Trip[idTrip].lastCus = IDinsert;
			seg[idVeh].Trip[idTrip].connectCost = problem->c[IDinsert][0];
		}
		FCAP[IDinsert] = FCAP[insert_after] + capINS;
		cArrTime = depart[insert_after] + problem->c[insert_after][IDinsert];
		temp = cArrTime - problem->node[IDinsert].eTW;
		if (temp > eps)
		{
			vioTWCus[IDinsert] = temp;
			FvioTWCus[IDinsert] = FvioTWCus[insert_after] + temp;
			startS[IDinsert] = problem->node[IDinsert].eTW;
			depart[IDinsert] = problem->node[IDinsert].depart;
		}
		else
		{
			vioTWCus[IDinsert] = 0;
			FvioTWCus[IDinsert] = FvioTWCus[insert_after];
			startS[IDinsert] = PDS_MAX(cArrTime, problem->node[IDinsert].sTW);
			depart[IDinsert] = startS[IDinsert] + problem->node[IDinsert].duration;
		}
		cStartS = depart[IDinsert];
		int nextID = next; int preID = IDinsert;
		while (nextID >0)
		{
			cArrTime = cStartS + problem->c[preID][nextID]; //arrTime at customer nextID
			cStartS = PDS_MAX(cArrTime, problem->node[nextID].sTW);
            if (PDSDIF(cStartS, startS[nextID])==0) //it means varvioTWCus[curC] =0 
			{
				//update BvioTWCus from preID to first Cus
				//update BCAP from IDinsert to firstCus
				//update FCAP from nextID to lastCus
				//update FvioTWCus from nextID to lastCus
				id = nextID;
				while (preID != IDinsert)
				{
					BvioTWCus[preID] = BvioTWCus[id] + vioTWCus[preID];
					id = preID; preID = predArr[id];
				}
				//update BCAP and BvioTWCus at IDinsert
				BvioTWCus[IDinsert] = BvioTWCus[id] + vioTWCus[IDinsert];
				BCAP[IDinsert] = BCAP[id] + capINS;
				//update BCAP from insert_after to firstCus
				preID = insert_after; id = IDinsert;
				do
				{
					BvioTWCus[preID] = BvioTWCus[id] + vioTWCus[preID];
					BCAP[preID] += capINS;
					id = preID; preID = predArr[id];
				}while (preID > 0);
				//update FCAP, FvioTWCus from nextID to lastCus:
				id = nextID; preID = predArr[nextID];
				do
				{
					FCAP[id] += capINS;
					FvioTWCus[id] = FvioTWCus[preID] + vioTWCus[id];
					preID = id; id = nextArr[id];
				}while (id > 0);
				//preID now points to the last cus
				varvioTWC = FvioTWCus[preID] - seg[idVeh].Trip[idTrip].vioTWC; 
				seg[idVeh].Trip[idTrip].vioTWC = FvioTWCus[preID];
				goto Update;
			}
			temp = cStartS - problem->node[nextID].eTW;
			if (temp > eps)
			{
				if (vioTWCus[nextID] > eps) 
				{
					vioTWCus[nextID] = temp;
					//Update BvioTWCus from nextID to firstCus
					//Update BCAP from IDinsert to firstCus
					//Update FCAP, FvioTWCus from nextID to lastCus
					id = nextArr[nextID];
					if (id < 0) BvioTWCus[nextID] = vioTWCus[nextID];
					else BvioTWCus[nextID] = BvioTWCus[id] + vioTWCus[nextID];

					id = nextID;
					while (preID != IDinsert)
					{
						BvioTWCus[preID] = BvioTWCus[id] + vioTWCus[preID];
						id = preID; preID = predArr[id];
					}
					//Update BCAP and BvioTWCus at IDinsert
					BCAP[IDinsert] = BCAP[next] + capINS;
					BvioTWCus[IDinsert] = BvioTWCus[next] + vioTWCus[IDinsert];

					//update BCAP from insert_after to firstCus:
					preID = insert_after; id = IDinsert;
					do
					{
						BvioTWCus[preID] = BvioTWCus[id] + vioTWCus[preID];
						BCAP[preID] += capINS;
						id = preID; preID = predArr[id];
					}while (preID > 0);

					//Update FCAP and FvioTWCus from nextID to lastCus
					id = nextID; preID = predArr[nextID];
					do
					{
						FCAP[id] += capINS;
						FvioTWCus[id] = FvioTWCus[preID] + vioTWCus[id];
						preID = id; id = nextArr[id];
					}while (id > 0);
					//preID now points to the last cus
					varvioTWC = FvioTWCus[preID] - seg[idVeh].Trip[idTrip].vioTWC;
					seg[idVeh].Trip[idTrip].vioTWC = FvioTWCus[preID];
					goto Update;
				}
				vioTWCus[nextID] = temp;
				FvioTWCus[nextID] = FvioTWCus[preID] + temp;
				cStartS = problem->node[nextID].eTW;
			}
            startS[nextID] = cStartS;
			cStartS += problem->node[nextID].duration;
			depart[nextID] = cStartS;
			FCAP[nextID] += capINS;
			preID = nextID; nextID = nextArr[nextID];
		}
		seg[idVeh].Trip[idTrip].endS = cStartS;
		varvioTWC = FvioTWCus[preID] - seg[idVeh].Trip[idTrip].vioTWC;
        seg[idVeh].Trip[idTrip].vioTWC = FvioTWCus[preID];
		//preID now points to the last cus:
		//Update BCAP from IDinsert to firstCus
		//Update BvioTWCus from lastCus to firstCus
		if (next > 0)
		{
			BvioTWCus[preID] = vioTWCus[preID];
			id = predArr[preID];
			while (id != IDinsert)
			{
				BvioTWCus[id] = BvioTWCus[preID] + vioTWCus[id];
				preID = id; id = predArr[id];
			}
			BvioTWCus[IDinsert] = BvioTWCus[preID] + vioTWCus[IDinsert];
			BCAP[IDinsert] = BCAP[preID] + capINS;
			id = predArr[IDinsert]; preID = IDinsert;
			while (id > 0)
			{
				BvioTWCus[id] = BvioTWCus[preID] + vioTWCus[id];
				BCAP[id] += capINS;
				preID = id; id = predArr[id];
			}
		}
		else //insert at the end of the trip:
		{
			BvioTWCus[preID] = vioTWCus[preID];
			BCAP[preID] = capINS;
			id = predArr[preID];
			while (id > 0)
			{
				BvioTWCus[id] = BvioTWCus[preID] + vioTWCus[id];
				BCAP[id] += capINS;
				preID = id; id = predArr[id];
			}
		}

   Update:
		seg[idVeh].Trip[idTrip].cost += varcost;
		double varFIT = varcost + VCAP * varvioCAP + VTWCUS * varvioTWC;
		if (FvioTWCus[seg[idVeh].Trip[idTrip].lastCus] > eps || vioCAPNEW > 0 || seg[idVeh].Trip[idTrip].vioTWSP > eps)
		{
			seg[idVeh].Trip[idTrip].feasible = 0;
			seg[idVeh].Trip[idTrip].fitness +=  varFIT;
		}
		else
		{
			seg[idVeh].Trip[idTrip].feasible = 1;
			seg[idVeh].Trip[idTrip].fitness = seg[idVeh].Trip[idTrip].cost;
		}
		seg[idVeh].cost += varcost; seg[idVeh].fitness += varFIT; seg[idVeh].vioCAP += varvioCAP; seg[idVeh].vioTWC += varvioTWC;
		cost += varcost; fitness += varFIT; vioCAP += varvioCAP; vioTWC += varvioTWC;
	}
	else //vehicle has >= 2 trips, delivery trip >= 2 customers not the last trip:
	{
		if (next > 0) //not insert at the end of the trip
		{
			varcost = problem->c[insert_after][IDinsert] + problem->c[IDinsert][next] - problem->c[insert_after][next];
            nextArr[insert_after] = IDinsert; predArr[IDinsert] = insert_after;
			nextArr[IDinsert] = next; predArr[next] = IDinsert;
		}
		else //insert IDinsert at the end of the trip:
		{
			nextArr[insert_after] = IDinsert; predArr[IDinsert] = insert_after;
			nextArr[IDinsert] = -1;
			seg[idVeh].Trip[idTrip].lastCus = IDinsert;
		}//end insert IDinsert at the end of the trip

		FCAP[IDinsert] = FCAP[insert_after] + capINS;
		cArrTime = depart[insert_after] + problem->c[insert_after][IDinsert];
		temp = cArrTime - problem->node[IDinsert].eTW;
		if (temp > eps)
		{
			vioTWCus[IDinsert] = temp;
			FvioTWCus[IDinsert] = FvioTWCus[insert_after] + temp;
			startS[IDinsert] = problem->node[IDinsert].eTW;
			depart[IDinsert] = problem->node[IDinsert].depart;
		}
		else
		{
			vioTWCus[IDinsert] = 0;
			FvioTWCus[IDinsert] = FvioTWCus[insert_after];
			startS[IDinsert] = PDS_MAX(cArrTime, problem->node[IDinsert].sTW);
			depart[IDinsert] = startS[IDinsert] + problem->node[IDinsert].duration;
		}
		cStartS = depart[IDinsert];
		int nextID = next; int preID = IDinsert;
		while (nextID > 0)
		{
			cArrTime = cStartS + problem->c[preID][nextID]; //arrTime at customer nextID
			cStartS = PDS_MAX(cArrTime, problem->node[nextID].sTW);
            if (PDSDIF(cStartS, startS[nextID])==0) //it means varvioTWCus[curC] =0 
			{
				//update BvioTWCus from preID to first Cus
				//update BCAP from IDinsert to firstCus
				//update FCAP from nextID to lastCus
				//update FvioTWCus from nextID to lastCus
				id = nextID;
				while (preID != IDinsert)
				{
					BvioTWCus[preID] = BvioTWCus[id] + vioTWCus[preID];
					id = preID; preID = predArr[id];
				}
				//update BCAP and BvioTWCus at IDinsert
				BvioTWCus[IDinsert] = BvioTWCus[id] + vioTWCus[IDinsert];
				BCAP[IDinsert] = BCAP[id] + capINS;
				//update BCAP from insert_after to firstCus
				preID = insert_after; id = IDinsert;
				do
				{
					BvioTWCus[preID] = BvioTWCus[id] + vioTWCus[preID];
					BCAP[preID] += capINS;
					id = preID; preID = predArr[id];
				}while (preID > 0);
				//update FCAP, FvioTWCus from nextID to lastCus:
				id = nextID; preID = predArr[nextID];
				do
				{
					FCAP[id] += capINS;
					FvioTWCus[id] = FvioTWCus[preID] + vioTWCus[id];
					preID = id; id = nextArr[id];
				}while (id > 0);
				//preID now points to the last cus
				varvioTWC = FvioTWCus[preID] - seg[idVeh].Trip[idTrip].vioTWC; 
				seg[idVeh].Trip[idTrip].vioTWC = FvioTWCus[preID];
				goto Update1;
			}
			temp = cStartS - problem->node[nextID].eTW;
			if (temp > eps)
			{
				if (vioTWCus[nextID] > eps) 
				{
					vioTWCus[nextID] = temp;
					//Update BvioTWCus from nextID to firstCus
					//Update BCAP from IDinsert to firstCus
					//Update FCAP, FvioTWCus from nextID to lastCus
					id = nextArr[nextID];
					if (id < 0) BvioTWCus[nextID] = vioTWCus[nextID];
					else BvioTWCus[nextID] = BvioTWCus[id] + vioTWCus[nextID];

					id = nextID;
					while (preID != IDinsert)
					{
						BvioTWCus[preID] = BvioTWCus[id] + vioTWCus[preID];
						id = preID; preID = predArr[id];
					}
					//Update BCAP and BvioTWCus at IDinsert
					BCAP[IDinsert] = BCAP[next] + capINS;
					BvioTWCus[IDinsert] = BvioTWCus[next] + vioTWCus[IDinsert];

					//update BCAP from insert_after to firstCus:
					preID = insert_after; id = IDinsert;
					do
					{
						BvioTWCus[preID] = BvioTWCus[id] + vioTWCus[preID];
						BCAP[preID] += capINS;
						id = preID; preID = predArr[id];
					}while (preID > 0);

					//Update FCAP and FvioTWCus from nextID to lastCus
					id = nextID; preID = predArr[nextID];
					do
					{
						FCAP[id] += capINS;
						FvioTWCus[id] = FvioTWCus[preID] + vioTWCus[id];
						preID = id; id = nextArr[id];
					}while (id > 0);
					//preID now points to the last cus
					varvioTWC = FvioTWCus[preID] - seg[idVeh].Trip[idTrip].vioTWC;
					seg[idVeh].Trip[idTrip].vioTWC = FvioTWCus[preID];
					goto Update1;
				}
				vioTWCus[nextID] = temp;
				FvioTWCus[nextID] = FvioTWCus[preID] + temp;
				cStartS = problem->node[nextID].eTW;
			}
            startS[nextID] = cStartS;
			cStartS += problem->node[nextID].duration;
			depart[nextID] = cStartS;
			FCAP[nextID] += capINS;
			preID = nextID; nextID = nextArr[nextID];
		}
		seg[idVeh].Trip[idTrip].endS = cStartS;
		varvioTWC = FvioTWCus[preID] - seg[idVeh].Trip[idTrip].vioTWC;
        seg[idVeh].Trip[idTrip].vioTWC = FvioTWCus[preID];

		if (seg[idVeh].Trip[idTrip].vioTWSP > eps || seg[idVeh].Trip[idTrip].vioCAP > 0 || seg[idVeh].Trip[idTrip].vioTWC > eps)
			seg[idVeh].Trip[idTrip].feasible = 0;
		else
			seg[idVeh].Trip[idTrip].feasible = 1;

		//preID now points to the last cus:
		//Update BCAP from IDinsert to firstCus
		//Update BvioTWCus from lastCus to firstCus
		if (next > 0)
		{
			BvioTWCus[preID] = vioTWCus[preID];
			id = predArr[preID];
			while (id != IDinsert)
			{
				BvioTWCus[id] = BvioTWCus[preID] + vioTWCus[id];
				preID = id; id = predArr[id];
			}
			BvioTWCus[IDinsert] = BvioTWCus[preID] + vioTWCus[IDinsert];
			BCAP[IDinsert] = BCAP[preID] + capINS;
			id = predArr[IDinsert]; preID = IDinsert;
			while (id > 0)
			{
				BvioTWCus[id] = BvioTWCus[preID] + vioTWCus[id];
				BCAP[id] += capINS;
				preID = id; id = predArr[id];
			}

			preID = seg[idVeh].Trip[nextTrip].lastCus;
			if (seg[idVeh].Trip[nextTrip].Type) //nextTrip is delivery trip, not insert at the end of the idTrip
			{
				bool stop = calChangeCONNECTAtSP_DD(preID, idVeh, nextTrip, idTrip, varvioCAP, varvioTWC, varcost);
				if (stop == 0){
					//UpdateVehicle(idVeh, nextTrip, seg[idVeh].Trip[nextTrip].assSP, seg[idVeh].Trip[nextTrip].leaveSP, varvioCAP);//Quang--
				}
				goto Update2;
			}
			else //next Trip is pickup, not insert at the end of the idTrip
			{
				double varFIT = varcost + VCAP * varvioCAP + VTWCUS * varvioTWC;
				seg[idVeh].Trip[idTrip].cost += varcost;
				seg[idVeh].Trip[idTrip].fitness += varFIT;

				//UpdateVehicle(idVeh, nextTrip, preID, seg[idVeh].Trip[idTrip].endS, varvioCAP);//Quang--
				goto Update2;
			}//end next Trip is pickup, not insert at the end of the idTrip
		}
		else //insert at the end of the trip:
		{
			BvioTWCus[preID] = vioTWCus[preID];
			BCAP[preID] = capINS;
			id = predArr[preID];
			while (id > 0)
			{
				BvioTWCus[id] = BvioTWCus[preID] + vioTWCus[id];
				BCAP[id] += capINS;
				preID = id; id = predArr[id];
			}

			if (seg[idVeh].Trip[nextTrip].Type) //nextTrip is delivery trip, insert at the end of the idTrip:
			{
				varcost = problem->c[insert_after][IDinsert];
				bool stop = calChangeCONNECTAtSP_DD_LastCChanged(insert_after, IDinsert, idVeh, nextTrip, idTrip, varvioCAP, varvioTWC, varcost); //for insertCusD procedure
				if (stop == 0){
					//UpdateVehicle(idVeh, nextTrip, seg[idVeh].Trip[nextTrip].assSP, seg[idVeh].Trip[nextTrip].leaveSP, varvioCAP);//Quang--
				}
				goto Update2;
			}
			else //nextTrip is pickup, insert at the end of the idTrip
			{
				int firstC_nextT = seg[idVeh].Trip[nextTrip].firstCus;
				varcost = problem->c[insert_after][IDinsert] + problem->c[IDinsert][firstC_nextT]
				        - problem->c[insert_after][firstC_nextT];
				seg[idVeh].Trip[idTrip].connectCost = problem->c[IDinsert][firstC_nextT];
				seg[idVeh].Trip[idTrip].cost += varcost;
				double varFIT = varcost + VCAP * varvioCAP + VTWCUS * varvioTWC;
				seg[idVeh].Trip[idTrip].fitness += varFIT;
				//UpdateVehicle(idVeh, nextTrip, IDinsert, seg[idVeh].Trip[idTrip].endS, varvioCAP);//Quang--
				goto Update2;
			}//end nextTrip is pickup, insert at the end of the idTrip
		}//end insert at the end of the trip

	 Update1: //this happened when not insert at the the last cus
			double varFIT = varcost + VCAP * varvioCAP + VTWCUS * varvioTWC;
			seg[idVeh].Trip[idTrip].cost += varcost;
			seg[idVeh].Trip[idTrip].fitness += varFIT;
			if (seg[idVeh].Trip[idTrip].vioTWSP > eps || seg[idVeh].Trip[idTrip].vioCAP > 0 || seg[idVeh].Trip[idTrip].vioTWC > eps)
				seg[idVeh].Trip[idTrip].feasible = 0;
			else
				seg[idVeh].Trip[idTrip].feasible = 1;
			seg[idVeh].cost += varcost; seg[idVeh].fitness += varFIT; 
			seg[idVeh].vioCAP += varvioCAP; seg[idVeh].vioTWC += varvioTWC;
			cost += varcost; fitness += varFIT; vioCAP += varvioCAP; vioTWC += varvioTWC;
	}//end vehicle has >= 2 trips, delivery trip >= 2 customers, not the last trip

Update2:
    UpdatePos(idVeh, idTrip);
	bool stop = checkTripD_ALLFIELDS(idVeh, idTrip);
	if (stop)
	{
	  cout<<"STOP AT insertCusDTrip @IT = "<<IT<<endl;
	  exit(-1);
	}
	//return 0;
}

void Solution::moveCusDTrip(int j, int i, int idVeh, int idTrip) //move customer i from its current place to place after j: both i and j are at the same trip
{
	int assSP = seg[idVeh].Trip[idTrip].assSP;
	int lastCOLD = seg[idVeh].Trip[idTrip].lastCus;

	int preID, nextID;
	int prei = predArr[i]; int suci = nextArr[i];
	int sucj=nextArr[j];

	double cArrTime, cStartS, varvioTWC, temp, varcost;
	bool caseij; //=1 if i was before j in the trip

	//2. Update nextArr and predArr, firstCus, lastCus:
	varcost = problem->c[j][i];
	if (prei > 0) 
	{
		if (suci > 0) 
		{
			if (pos[i] < pos[j]) caseij = 1;
			else caseij = 0;
			predArr[suci]=prei;
			varcost += (problem->c[prei][suci] - problem->c[prei][i] - problem->c[i][suci]);
		}
		else //i was the last customer of the trip:
		{
			seg[idVeh].Trip[idTrip].lastCus = prei;caseij=0;
			varcost -= problem->c[prei][i];
		} //i was the last customer of the trip
		nextArr[prei] = suci;
		if (caseij) {cStartS = depart[prei]; preID = prei;}
		else {cStartS = depart[j]; preID = j;}
		nextID = nextArr[preID]; 
	}
	else  //customer i was first customer of the trip:
	{
		seg[idVeh].Trip[idTrip].firstCus = suci;
		predArr[suci]=-1;
		cStartS = seg[idVeh].Trip[idTrip].leaveSP; preID = assSP; 
		varcost += (problem->c[assSP][suci] - problem->c[assSP][i] - problem->c[i][suci]);
		nextID = seg[idVeh].Trip[idTrip].firstCus;
	}
	nextArr[j] = i;  predArr[i]=j; nextArr[i] = sucj;

	int nextTrip = idTrip + 1;
	if (nextTrip == seg[idVeh].numTrips)
	{
		if (sucj > 0)
		{
			predArr[sucj]=i;
			varcost += (problem->c[i][sucj] - problem->c[j][sucj]);
			if (suci <0)
			{
				varcost += (problem->c[prei][0] - problem->c[i][0]);
				seg[idVeh].Trip[idTrip].connectCost = problem->c[prei][0];
			}
		}
		else //i becomes that last cus of idTrip
		{
			seg[idVeh].Trip[idTrip].lastCus = i; // insert i at the end of the trip
			varcost += (problem->c[i][0] - problem->c[j][0]);
			seg[idVeh].Trip[idTrip].connectCost = problem->c[i][0];
		}
	
		while (nextID >0)
		{
			cArrTime = cStartS + problem->c[preID][nextID]; //arrTime at customer nextID
			temp = cArrTime - problem->node[nextID].eTW;
			if (temp > eps)
			{
				vioTWCus[nextID] = temp;
				FvioTWCus[nextID] = FvioTWCus[preID] + temp;
				startS[nextID] = problem->node[nextID].eTW;
			}
			else
			{
				vioTWCus[nextID] = 0;
				FvioTWCus[nextID] = FvioTWCus[preID];
                startS[nextID] = PDS_MAX(cArrTime, problem->node[nextID].sTW);
			}
			depart[nextID] = startS[nextID] + problem->node[nextID].duration;
			cStartS = depart[nextID];
			FCAP[nextID] = FCAP[preID] + problem->node[nextID].capacity;
			preID = nextID; nextID = nextArr[nextID];
		}
		//preID now points to the last cus
		seg[idVeh].Trip[idTrip].endS = cStartS;
		varvioTWC = FvioTWCus[preID] - seg[idVeh].Trip[idTrip].vioTWC;
        seg[idVeh].Trip[idTrip].vioTWC = FvioTWCus[preID];

		//Update BCAP and BvioTWCus from the lastCus to the firstCus:
		BCAP[preID] = problem->node[preID].capacity;
		BvioTWCus[preID] = vioTWCus[preID];
		int id = predArr[preID];
		while (id > 0)
		{
			BCAP[id] = BCAP[preID] + problem->node[id].capacity;
			BvioTWCus[id] = BvioTWCus[preID] + vioTWCus[id];
			preID = id; id = predArr[id];
		}
		if (seg[idVeh].Trip[idTrip].vioCAP > 0 || seg[idVeh].Trip[idTrip].vioTWC > eps || seg[idVeh].Trip[idTrip].vioTWSP > eps)
			 seg[idVeh].Trip[idTrip].feasible = 0;
		else seg[idVeh].Trip[idTrip].feasible = 1;
		seg[idVeh].Trip[idTrip].cost += varcost;
		double varFIT = VTWCUS * varvioTWC + varcost;
		seg[idVeh].Trip[idTrip].fitness += varFIT;
		seg[idVeh].cost += varcost; seg[idVeh].fitness += varFIT;
		cost += varcost; fitness += varFIT;
	}
	else //not the last trip
	{
		while (nextID >0)
		{
			cArrTime = cStartS + problem->c[preID][nextID]; //arrTime at customer nextID
			temp = cArrTime - problem->node[nextID].eTW;
			if (temp > eps)
			{
				vioTWCus[nextID] = temp;
				FvioTWCus[nextID] = FvioTWCus[preID] + temp;
				startS[nextID] = problem->node[nextID].eTW;
			}
			else
			{
				vioTWCus[nextID] = 0;
				FvioTWCus[nextID] = FvioTWCus[preID];
                startS[nextID] = PDS_MAX(cArrTime, problem->node[nextID].sTW);
			}
			depart[nextID] = startS[nextID] + problem->node[nextID].duration;
			cStartS = depart[nextID];
			FCAP[nextID] = FCAP[preID] + problem->node[nextID].capacity;
			preID = nextID; nextID = nextArr[nextID];
		}
		//preID now points to the last cus
		seg[idVeh].Trip[idTrip].endS = cStartS;
		varvioTWC = FvioTWCus[preID] - seg[idVeh].Trip[idTrip].vioTWC;
        seg[idVeh].Trip[idTrip].vioTWC = FvioTWCus[preID];
		if (seg[idVeh].Trip[idTrip].vioCAP > 0 || seg[idVeh].Trip[idTrip].vioTWC > eps || seg[idVeh].Trip[idTrip].vioTWSP > eps)
			 seg[idVeh].Trip[idTrip].feasible = 0;
		else seg[idVeh].Trip[idTrip].feasible = 1;

		if (sucj > 0)
		{
			predArr[sucj]=i;
			varcost += (problem->c[i][sucj] - problem->c[j][sucj]);
			if (seg[idVeh].Trip[nextTrip].Type)
			{
				if (suci < 0) //prei now the last cus
				{
					bool stop = calChangeCONNECTAtSP_DD_LastCChanged(i, prei, idVeh, nextTrip, idTrip, 0, varvioTWC,varcost); //for insertCusD procedure
					if (stop == 0){
						//UpdateVehicle(idVeh, nextTrip, seg[idVeh].Trip[nextTrip].assSP, seg[idVeh].Trip[nextTrip].leaveSP, 0);//Quang--
					}
				}
				else //the last cus doesnot change
				{
					bool stop = calChangeCONNECTAtSP_DD(preID, idVeh, nextTrip, idTrip, 0, varvioTWC, varcost);
					if (stop == 0){
				//		UpdateVehicle(idVeh, nextTrip, seg[idVeh].Trip[nextTrip].assSP, seg[idVeh].Trip[nextTrip].leaveSP, 0);//Quang--
					}
				}
			}
			else //nextTrip is pickup, sucj > 0
			{
				if (suci < 0) //prei now the last cus, nextTrip is pickup
				{
					int firstC_nextT = seg[idVeh].Trip[nextTrip].firstCus;
					varcost += (problem->c[prei][firstC_nextT] - problem->c[i][firstC_nextT]);
					seg[idVeh].Trip[idTrip].connectCost = problem->c[prei][firstC_nextT];
					seg[idVeh].Trip[idTrip].cost += varcost;
					double varFIT = varcost + VTWCUS * varvioTWC;
					seg[idVeh].Trip[idTrip].fitness += varFIT;
					//UpdateVehicle(idVeh, nextTrip, prei, seg[idVeh].Trip[idTrip].endS, 0);//Quang--
				}
				else //the last cus doesnt change
				{
					double varFIT = varcost + VTWCUS * varvioTWC;
					seg[idVeh].Trip[idTrip].cost += varcost;
					seg[idVeh].Trip[idTrip].fitness += varFIT;
					//preID now points to the lastCus
					//UpdateVehicle(idVeh, nextTrip, preID, seg[idVeh].Trip[idTrip].endS, 0);//Quang--
				}
			}//end nextTrip is pickup, sucj > 0
		}
		else //i becomes that last cus of idTrip
		{
			seg[idVeh].Trip[idTrip].lastCus = i; // insert i at the end of the trip
			if (seg[idVeh].Trip[nextTrip].Type)
			{
				bool stop = calChangeCONNECTAtSP_DD_LastCChanged(j, i, idVeh, nextTrip, idTrip, 0, varvioTWC,varcost); //for insertCusD procedure
				if (stop == 0){
					//UpdateVehicle(idVeh, nextTrip, seg[idVeh].Trip[nextTrip].assSP, seg[idVeh].Trip[nextTrip].leaveSP, 0);//Quang--
				}
			}
			else //i becomes the last cus of idTrip, nextTrip is pickup
			{
				int firstC_nextT = seg[idVeh].Trip[nextTrip].firstCus;
				varcost += (problem->c[i][firstC_nextT] - problem->c[j][firstC_nextT]);
				seg[idVeh].Trip[idTrip].connectCost = problem->c[i][firstC_nextT];
				seg[idVeh].Trip[idTrip].cost += varcost;
				double varFIT = varcost + VTWCUS * varvioTWC;
				seg[idVeh].Trip[idTrip].fitness += varFIT;
				//UpdateVehicle(idVeh, nextTrip, i, seg[idVeh].Trip[idTrip].endS, 0);//Quang--
			} //end i becomes the last cus of idTrip, nextTrip is pickup
		}//end i becomes that last cus of idTrip

		//Update BCAP and BvioTWCus from the lastCus to the firstCus
		preID = seg[idVeh].Trip[idTrip].lastCus;
		BCAP[preID] = problem->node[preID].capacity;
		BvioTWCus[preID] = vioTWCus[preID];
		int id = predArr[preID];
		while (id > 0)
		{
			BCAP[id] = BCAP[preID] + problem->node[id].capacity;
			BvioTWCus[id] = BvioTWCus[preID] + vioTWCus[id];
			preID = id; id = predArr[id];
		}
	}//end not the last trip

    UpdatePos(idVeh, idTrip);
	bool stop = checkTripD_ALLFIELDS(idVeh, idTrip);
	if (stop)
	{
	  cout<<"STOP AT moveCusDTrip @IT = "<<IT<<endl;
	  exit(-1);
	}
} //move customer i (neighbor of customer j) after customer j

void Solution::exchangeCusDTrip(int j, int i) //exchange customer j and its neighbor i: in 1 trip OR 2 trips
{
	int idVehi = route_num[i]; int idTripi = trip_num[i];
	int idVehj = route_num[j]; int idTripj = trip_num[j];
	
	double varvioTWC;
	double cStartS, cArrTime,temp,varcost;
	int prei, prej, suci, sucj;

    if (idVehi == idVehj) // customer i and j are in the same trip:
	{
	    int assSP = seg[idVehi].Trip[idTripi].assSP; 
		int lastCOLD = seg[idVehi].Trip[idTripi].lastCus;
	    
		if (pos[i] > pos[j]) {int tt=i;i=j;j=tt;} //swap i and j so that i is before j
		prei = predArr[i]; suci = nextArr[i];
		prej = predArr[j]; sucj = nextArr[j];
		int preID,nextID;
		
		//2.Update predArr, nextArr, firstCus, lastCus:
		if (prei > 0) //suci and prej always > 0
		{
			cStartS = depart[prei]; 
			preID = prei;
			nextArr[prei]=j;predArr[j]=prei;
			if (i != prej)
			{
				varcost = problem->c[prei][j] + problem->c[j][suci] - (problem->c[prei][i] + problem->c[i][suci])
					   + (problem->c[prej][i] - problem->c[prej][j]);
				 nextArr[j]=suci;predArr[suci]=j;
				 nextArr[prej]=i; predArr[i]=prej;
			}
			else //-i-j-
			{
				varcost = problem->c[prei][j] - problem->c[prei][i];
				nextArr[j]=i;predArr[i]=j;
			}
			nextArr[i] = sucj; 
			if (sucj > 0)
			{
				predArr[sucj]=i;
				varcost += (problem->c[i][sucj] - problem->c[j][sucj]);
			}
			else //j was the last customer --> i is now the last customer
			{
                 seg[idVehi].Trip[idTripi].lastCus=i;
			}
			nextID = nextArr[preID];
		}
		else //i was the first customer --> j is now the first customer: //suci and prej always > 0
		{
			predArr[j]= -1;
			if (i != prej)
			{
				varcost = problem->c[assSP][j] + problem->c[j][suci] - (problem->c[assSP][i] + problem->c[i][suci])
					   + (problem->c[prej][i] - problem->c[prej][j]);
				nextArr[j] = suci; predArr[suci]=j;
				nextArr[prej]=i;predArr[i]=prej;
			}
			else 
			{
				varcost = problem->c[assSP][j] - problem->c[assSP][i];
				nextArr[j]=i;
				predArr[i]=j;
			}
			seg[idVehi].Trip[idTripi].firstCus=j;
			nextArr[i]=sucj;
			if (sucj > 0)
			{
				predArr[sucj]=i;
				varcost += (problem->c[i][sucj] - problem->c[j][sucj]);
			}
			else //j was the last customer --> i is now the last customer
				seg[idVehi].Trip[idTripi].lastCus=i;

			preID = assSP; cStartS = seg[idVehi].Trip[idTripi].leaveSP; 
			nextID = j;
		}

		int nextTrip = idTripi + 1;
		if (nextTrip == seg[idVehi].numTrips)
		{
			if (sucj < 0) //j was the last --> i is now the last
			{
				varcost += (problem->c[i][0] - problem->c[j][0]);
				seg[idVehi].Trip[idTripi].connectCost = problem->c[i][0];
			}
			while (nextID >0)
			{
				cArrTime = cStartS + problem->c[preID][nextID]; //arrTime at customer nextID
				temp = cArrTime - problem->node[nextID].eTW;
				if (temp > eps)
				{
					vioTWCus[nextID] = temp;
					FvioTWCus[nextID] = FvioTWCus[preID] + temp;
					startS[nextID] = problem->node[nextID].eTW;
				}
				else
				{
					vioTWCus[nextID] = 0;
					FvioTWCus[nextID] = FvioTWCus[preID];
					startS[nextID] = PDS_MAX(cArrTime, problem->node[nextID].sTW);
				}
				depart[nextID] = startS[nextID] + problem->node[nextID].duration;
				cStartS = depart[nextID];
				FCAP[nextID] = FCAP[preID] + problem->node[nextID].capacity;
				preID = nextID; nextID = nextArr[nextID];
			}
			//preID now points to the last cus
			seg[idVehi].Trip[idTripi].endS = cStartS;
			varvioTWC = FvioTWCus[preID] - seg[idVehi].Trip[idTripi].vioTWC;
			seg[idVehi].Trip[idTripi].vioTWC = FvioTWCus[preID];

			//Update BCAP and BvioTWCus from the lastCus to the firstCus:
			BCAP[preID] = problem->node[preID].capacity;
			BvioTWCus[preID] = vioTWCus[preID];
			int id = predArr[preID];
			while (id > 0)
			{
				BCAP[id] = BCAP[preID] + problem->node[id].capacity;
				BvioTWCus[id] = BvioTWCus[preID] + vioTWCus[id];
				preID = id; id = predArr[id];
			}
			if (seg[idVehi].Trip[idTripi].vioCAP > 0 || seg[idVehi].Trip[idTripi].vioTWC > eps || seg[idVehi].Trip[idTripi].vioTWSP > eps)
				 seg[idVehi].Trip[idTripi].feasible = 0;
			else seg[idVehi].Trip[idTripi].feasible = 1;
			seg[idVehi].Trip[idTripi].cost += varcost;
			double varFIT = VTWCUS * varvioTWC + varcost;
			seg[idVehi].Trip[idTripi].fitness += varFIT;
			seg[idVehi].cost += varcost; seg[idVehi].fitness += varFIT;
			cost += varcost; fitness += varFIT;
		}
		else //not the last trip
		{
			while (nextID >0)
			{
				cArrTime = cStartS + problem->c[preID][nextID]; //arrTime at customer nextID
				temp = cArrTime - problem->node[nextID].eTW;
				if (temp > eps)
				{
					vioTWCus[nextID] = temp;
					FvioTWCus[nextID] = FvioTWCus[preID] + temp;
					startS[nextID] = problem->node[nextID].eTW;
				}
				else
				{
					vioTWCus[nextID] = 0;
					FvioTWCus[nextID] = FvioTWCus[preID];
					startS[nextID] = PDS_MAX(cArrTime, problem->node[nextID].sTW);
				}
				depart[nextID] = startS[nextID] + problem->node[nextID].duration;
				cStartS = depart[nextID];
				FCAP[nextID] = FCAP[preID] + problem->node[nextID].capacity;
				preID = nextID; nextID = nextArr[nextID];
			}
			//preID now points to the last cus
			seg[idVehi].Trip[idTripi].endS = cStartS;
			varvioTWC = FvioTWCus[preID] - seg[idVehi].Trip[idTripi].vioTWC;
			seg[idVehi].Trip[idTripi].vioTWC = FvioTWCus[preID];
			if (seg[idVehi].Trip[idTripi].vioCAP > 0 || seg[idVehi].Trip[idTripi].vioTWC > eps || seg[idVehi].Trip[idTripi].vioTWSP > eps)
				 seg[idVehi].Trip[idTripi].feasible = 0;
			else seg[idVehi].Trip[idTripi].feasible = 1;

			if (seg[idVehi].Trip[nextTrip].Type)
			{
				if (sucj > 0) //lastCus doesn't change
				{
					bool stop = calChangeCONNECTAtSP_DD(preID, idVehi, nextTrip, idTripi, 0, varvioTWC, varcost);
					if (stop == 0){
						//UpdateVehicle(idVehi, nextTrip, seg[idVehi].Trip[nextTrip].assSP, seg[idVehi].Trip[nextTrip].leaveSP, 0);//Quang--
					}
				}
				else //i is now the last cus, j was the lastCus
				{
					bool stop = calChangeCONNECTAtSP_DD_LastCChanged(j, i, idVehi, nextTrip, idTripi, 0, varvioTWC,varcost); //for insertCusD procedure
					if (stop == 0){
						//UpdateVehicle(idVehi, nextTrip, seg[idVehi].Trip[nextTrip].assSP, seg[idVehi].Trip[nextTrip].leaveSP, 0);//Quang--
					}
				}//end i is now the last cus, j was the lastCus
			}
			else //nextTrip is pickup
			{
				if (sucj > 0) //lastCus doesn't change:
				{
					double varFIT = varcost + VTWCUS * varvioTWC;
					seg[idVehi].Trip[idTripi].cost += varcost;
					seg[idVehi].Trip[idTripi].fitness += varFIT;
					//preID now points to the lastCus
					//UpdateVehicle(idVehi, nextTrip, preID, seg[idVehi].Trip[idTripi].endS, 0);//Quang--
				}
				else //i is now the last cus; j was the last cus
				{
					int firstC_nextT = seg[idVehi].Trip[nextTrip].lastCus;
					varcost += (problem->c[i][firstC_nextT] - problem->c[j][firstC_nextT]); 
                    seg[idVehi].Trip[idTripi].connectCost = problem->c[i][firstC_nextT];
				    seg[idVehi].Trip[idTripi].cost += varcost;
				    double varFIT = varcost + VTWCUS * varvioTWC;
				    seg[idVehi].Trip[idTripi].fitness += varFIT;
				    //UpdateVehicle(idVehi, nextTrip, i, seg[idVehi].Trip[idTripi].endS, 0);//Quang--
				}//end i is now the last cus
			}///end nextTrip is pickup
			
			//Update BCAP and BvioTWCus from the lastCus to the firstCus
			preID = seg[idVehi].Trip[idTripi].lastCus;
			BCAP[preID] = problem->node[preID].capacity;
			BvioTWCus[preID] = vioTWCus[preID];
			int id = predArr[preID];
			while (id > 0)
			{
				BCAP[id] = BCAP[preID] + problem->node[id].capacity;
				BvioTWCus[id] = BvioTWCus[preID] + vioTWCus[id];
				preID = id; id = predArr[id];
			}
		}//end not the last trip
	}
	else //customer i and j are in different trips:
	{
		//1. Update capacity, numCus, vio_CAP
		int assSPi = seg[idVehi].Trip[idTripi].assSP; 
		int assSPj = seg[idVehj].Trip[idTripj].assSP; 
		double varcosti, varcostj;

	    //2.Update predArr, nextArr, firstCus, lastCus:
		prei = predArr[i]; suci = nextArr[i];
		prej = predArr[j]; sucj = nextArr[j];
		predArr[j]=prei;
		if (prei >0) 
		{
			nextArr[prei]=j; 
			varcosti = problem->c[prei][j] - problem->c[prei][i];
		}
		else //i was the first customer of the trip --> j is now the first customer of the trip:
		{
			seg[idVehi].Trip[idTripi].firstCus=j;
			varcosti = problem->c[assSPi][j] - problem->c[assSPi][i];
		}
		nextArr[j]=suci;
		if (suci > 0)
		{
			predArr[suci]=j;
			varcosti += (problem->c[j][suci] - problem->c[i][suci]);
		}
		else seg[idVehi].Trip[idTripi].lastCus = j; //j is now the last customer of the legi
		
		predArr[i]=prej;
		if (prej >0) 
		{
			nextArr[prej]=i;
			varcostj = problem->c[prej][i] - problem->c[prej][j];
		}
		else //j was the first customer of the trip --> i is now the first customer of the trip:
		{
			seg[idVehj].Trip[idTripj].firstCus=i;
			varcostj = problem->c[assSPj][i] - problem->c[assSPj][j];
		}
		nextArr[i]=sucj;
		if (sucj > 0)
		{
			predArr[sucj]=i;
			varcostj += (problem->c[i][sucj] - problem->c[j][sucj]);
		}
		else seg[idVehj].Trip[idTripj].lastCus = i; //i is now the last customer of the legj
		
		trip_num[i] = idTripj; route_num[i] = idVehj;
		trip_num[j] = idTripi; route_num[j] = idVehi;
		SUBexchangeCusDTrip(idVehi, idTripi, prei, suci, i, j, varcosti); //replace i by j on (idVehi, idTripi)
		SUBexchangeCusDTrip(idVehj, idTripj, prej, sucj, j, i, varcostj); //replace j by i on (idVehj, idTripj)
	}//end customer i and j are in different trips
}

void Solution::SUBexchangeCusDTrip(int idVeh, int idTrip, int prei, int suci, int i, int j, double varcost) //replace i by j
{
	double cStartS, cArrTime, temp, varvioTWC;
	int preID, nextID, id;

	int deltaCAP = problem->node[j].capacity - problem->node[i].capacity;
	seg[idVeh].Trip[idTrip].capacity += deltaCAP;
	int vioCAPNEW = PDS_MAX(seg[idVeh].Trip[idTrip].capacity - problem->Q, 0);
	int varvioCAP = vioCAPNEW - seg[idVeh].Trip[idTrip].vioCAP;
	seg[idVeh].Trip[idTrip].vioCAP = varvioCAP;
	int assSP = seg[idVeh].Trip[idTrip].assSP;

		if (prei > 0) 
		{
			//Update at j:
			FCAP[j] = FCAP[prei] + problem->node[j].capacity;
			cArrTime = depart[prei] + problem->c[prei][j];
			temp = cArrTime - problem->node[j].eTW;
			if (temp > eps)
			{
				vioTWCus[j] = temp;
				FvioTWCus[j] = FvioTWCus[prei] + temp;
				startS[j] = problem->node[j].eTW;
				depart[j] = problem->node[j].depart;
			}
			else
			{
				vioTWCus[j] = 0;
				FvioTWCus[j] = FvioTWCus[prei];
				startS[j] = PDS_MAX(cArrTime, problem->node[j].sTW);
				depart[j] = startS[j] + problem->node[j].duration;
			}
		}
		else 
		{
			cStartS = seg[idVeh].Trip[idTrip].leaveSP; 
			//Update at j:
			FCAP[j] = problem->node[j].capacity;
			cArrTime = cStartS + problem->c[assSP][j];
			temp = cArrTime - problem->node[j].eTW;
			if (temp > eps)
			{
				vioTWCus[j] = temp;
				FvioTWCus[j] = temp;
				startS[j] = problem->node[j].eTW;
				depart[j] = problem->node[j].depart;
			}
			else
			{
				vioTWCus[j] = 0;
				FvioTWCus[j] = 0;
				startS[j] = PDS_MAX(cArrTime, problem->node[j].sTW);
				depart[j] = startS[j] + problem->node[j].duration;
			}
		}
		cStartS = depart[j]; preID = j; nextID = nextArr[j];
		
		int nextTrip = idTrip + 1;

		if (nextTrip == seg[idVeh].numTrips)
		{
			while (nextID > 0)
			{
				cArrTime = cStartS + problem->c[preID][nextID]; //arrTime at customer nextID
				cStartS = PDS_MAX(cArrTime, problem->node[nextID].sTW);
				if (PDSDIF(cStartS, startS[nextID])==0) //it means varvioTWCus[nextID] =0 
				{
					//update BvioTWCus from preID to first Cus
					//update BCAP from j to firstCus
					//update FCAP from nextID to lastCus
					//update FvioTWCus from nextID to lastCus
					id = nextID;
					while (preID != j)
					{
						BvioTWCus[preID] = BvioTWCus[id] + vioTWCus[preID];
						id = preID; preID = predArr[id];
					}
					//update BCAP and BvioTWCus at j
					BvioTWCus[j] = BvioTWCus[id] + vioTWCus[j];
					BCAP[j] = BCAP[id] + problem->node[j].capacity;
					//update BCAP from prei = predArr[j] to firstCus
					preID = prei; id = j;
					while (preID > 0)
					{
						BvioTWCus[preID] = BvioTWCus[id] + vioTWCus[preID];
						BCAP[preID] += deltaCAP;
						id = preID; preID = predArr[id];
					}
					//update FCAP, FvioTWCus from nextID to lastCus:
					id = nextID; preID = predArr[nextID];
					do
					{
						FCAP[id] += deltaCAP;
						FvioTWCus[id] = FvioTWCus[preID] + vioTWCus[id];
						preID = id; id = nextArr[id];
					}while (id > 0);
					//preID now points to the last cus
					varvioTWC = FvioTWCus[preID] - seg[idVeh].Trip[idTrip].vioTWC; 
					seg[idVeh].Trip[idTrip].vioTWC = FvioTWCus[preID];
					goto Update;
				}
				temp = cStartS - problem->node[nextID].eTW;
				if (temp > eps)
				{
					if (vioTWCus[nextID] > eps) 
					{
						vioTWCus[nextID] = temp;
						//Update BvioTWCus from nextID to firstCus
						//Update BCAP from j to firstCus
						//Update FCAP, FvioTWCus from nextID to lastCus
						id = nextArr[nextID];
						if (id < 0) BvioTWCus[nextID] = vioTWCus[nextID];
						else BvioTWCus[nextID] = BvioTWCus[id] + vioTWCus[nextID];

						id = nextID;
						while (preID != j)
						{
							BvioTWCus[preID] = BvioTWCus[id] + vioTWCus[preID];
							id = preID; preID = predArr[id];
						}
						//Update BCAP and BvioTWCus at j
						BCAP[j] = BCAP[id] + problem->node[j].capacity;
						BvioTWCus[j] = BvioTWCus[id] + vioTWCus[j];

						//update BCAP from prei to firstCus:
						preID = prei; id = j;
						while (preID > 0)
						{
							BvioTWCus[preID] = BvioTWCus[id] + vioTWCus[preID];
							BCAP[preID] += deltaCAP;
							id = preID; preID = predArr[id];
						}

						//Update FCAP and FvioTWCus from nextID to lastCus
						id = nextID; preID = predArr[nextID];
						do
						{
							FCAP[id] += deltaCAP;
							FvioTWCus[id] = FvioTWCus[preID] + vioTWCus[id];
							preID = id; id = nextArr[id];
						}while (id > 0);
						//preID now points to the last cus
						varvioTWC = FvioTWCus[preID] - seg[idVeh].Trip[idTrip].vioTWC;
						seg[idVeh].Trip[idTrip].vioTWC = FvioTWCus[preID];
						goto Update;
					}
					vioTWCus[nextID] = temp;
					FvioTWCus[nextID] = FvioTWCus[preID] + temp;
					cStartS = problem->node[nextID].eTW;
				}
				startS[nextID] = cStartS;
				cStartS += problem->node[nextID].duration;
				depart[nextID] = cStartS;
				FCAP[nextID] += deltaCAP;
				preID = nextID; nextID = nextArr[nextID];
			}
			seg[idVeh].Trip[idTrip].endS = cStartS;
			varvioTWC = FvioTWCus[preID] - seg[idVeh].Trip[idTrip].vioTWC;
			seg[idVeh].Trip[idTrip].vioTWC = FvioTWCus[preID];
			//preID now points to the last cus:
			//Update BCAP from j to firstCus
			//Update BvioTWCus from lastCus to firstCus
			if (suci > 0)
			{
				BvioTWCus[preID] = vioTWCus[preID];
				id = predArr[preID];
				while (id != j)
				{
					BvioTWCus[id] = BvioTWCus[preID] + vioTWCus[id];
					preID = id; id = predArr[id];
				}
				BvioTWCus[j] = BvioTWCus[preID] + vioTWCus[j];
				BCAP[j] = BCAP[preID] + problem->node[j].capacity;
				id = prei; preID = j;
				while (id > 0)
				{
					BvioTWCus[id] = BvioTWCus[preID] + vioTWCus[id];
					BCAP[id] += deltaCAP;
					preID = id; id = predArr[id];
				}
			}
			else //j is now the last cus:
			{
				varcost += (problem->c[j][0] - problem->c[i][0]);
				seg[idVeh].Trip[idTrip].connectCost = problem->c[j][0];

				BvioTWCus[preID] = vioTWCus[preID];
				BCAP[preID] = problem->node[j].capacity;
				id = predArr[preID];
				while (id > 0)
				{
					BvioTWCus[id] = BvioTWCus[preID] + vioTWCus[id];
					BCAP[id] += deltaCAP; //ok
					preID = id; id = predArr[id];
				}
			}

			Update:
				seg[idVeh].Trip[idTrip].cost += varcost;
				double varFIT = varcost + VCAP * varvioCAP + VTWCUS * varvioTWC;
				if (seg[idVeh].Trip[idTrip].vioTWC > eps || seg[idVeh].Trip[idTrip].vioCAP > 0 || seg[idVeh].Trip[idTrip].vioTWSP > eps)
				{
					seg[idVeh].Trip[idTrip].feasible = 0;
					seg[idVeh].Trip[idTrip].fitness +=  varFIT;
				}
				else
				{
					seg[idVeh].Trip[idTrip].feasible = 1;
					seg[idVeh].Trip[idTrip].fitness = seg[idVeh].Trip[idTrip].cost;
				}
				seg[idVeh].cost += varcost; seg[idVeh].fitness += varFIT; 
				seg[idVeh].vioCAP += varvioCAP; seg[idVeh].vioTWC += varvioTWC;
				cost += varcost; fitness += varFIT; vioCAP += varvioCAP; vioTWC += varvioTWC;
		}
		else //idTrip not the last trip
		{
				while (nextID > 0)
				{
					cArrTime = cStartS + problem->c[preID][nextID]; //arrTime at customer nextID
					cStartS = PDS_MAX(cArrTime, problem->node[nextID].sTW);
            		if (PDSDIF(cStartS, startS[nextID])==0) //it means varvioTWCus[nextID] =0 
					{
						//update BvioTWCus from preID to first Cus
						//update BCAP from j to firstCus
						//update FCAP from nextID to lastCus
						//update FvioTWCus from nextID to lastCus
						id = nextID;
						while (preID != j)
						{
							BvioTWCus[preID] = BvioTWCus[id] + vioTWCus[preID];
							id = preID; preID = predArr[id];
						}
						//update BCAP and BvioTWCus at j
						BvioTWCus[j] = BvioTWCus[id] + vioTWCus[j];
						BCAP[j] = BCAP[id] + problem->node[j].capacity;
						//update BCAP from prei to firstCus
						preID = prei; id = j;
						while (preID > 0)
						{
							BvioTWCus[preID] = BvioTWCus[id] + vioTWCus[preID];
							BCAP[preID] += deltaCAP;
							id = preID; preID = predArr[id];
						}
						//update FCAP, FvioTWCus from nextID to lastCus:
						id = nextID; preID = predArr[nextID];
						do
						{
							FCAP[id] += deltaCAP;
							FvioTWCus[id] = FvioTWCus[preID] + vioTWCus[id];
							preID = id; id = nextArr[id];
						}while (id > 0);
						//preID now points to the last cus
						varvioTWC = FvioTWCus[preID] - seg[idVeh].Trip[idTrip].vioTWC; 
						seg[idVeh].Trip[idTrip].vioTWC = FvioTWCus[preID];
						goto Update1;
					}
					temp = cStartS - problem->node[nextID].eTW;
					if (temp > eps)
					{
						if (vioTWCus[nextID] > eps) 
						{
							vioTWCus[nextID] = temp;
							//Update BvioTWCus from nextID to firstCus
							//Update BCAP from j to firstCus
							//Update FCAP, FvioTWCus from nextID to lastCus
							id = nextArr[nextID];
							if (id < 0) BvioTWCus[nextID] = vioTWCus[nextID];
							else BvioTWCus[nextID] = BvioTWCus[id] + vioTWCus[nextID];

							id = nextID;
							while (preID != j)
							{
								BvioTWCus[preID] = BvioTWCus[id] + vioTWCus[preID];
								id = preID; preID = predArr[id];
							}
							//Update BCAP and BvioTWCus at j
							BCAP[j] = BCAP[id] + problem->node[j].capacity;
							BvioTWCus[j] = BvioTWCus[id] + vioTWCus[j];

							//update BCAP from prei to firstCus:
							preID = prei; id = j;
							while (preID > 0)
							{
								BvioTWCus[preID] = BvioTWCus[id] + vioTWCus[preID];
								BCAP[preID] += deltaCAP;
								id = preID; preID = predArr[id];
							}

							//Update FCAP and FvioTWCus from nextID to lastCus
							id = nextID; preID = predArr[nextID];
							do
							{
								FCAP[id] += deltaCAP;
								FvioTWCus[id] = FvioTWCus[preID] + vioTWCus[id];
								preID = id; id = nextArr[id];
							}while (id > 0);
							//preID now points to the last cus
							varvioTWC = FvioTWCus[preID] - seg[idVeh].Trip[idTrip].vioTWC;
							seg[idVeh].Trip[idTrip].vioTWC = FvioTWCus[preID];
							goto Update1;
						}
						vioTWCus[nextID] = temp;
						FvioTWCus[nextID] = FvioTWCus[preID] + temp;
						cStartS = problem->node[nextID].eTW;
					}
					startS[nextID] = cStartS;
					cStartS += problem->node[nextID].duration;
					depart[nextID] = cStartS;
					FCAP[nextID] += deltaCAP;
					preID = nextID; nextID = nextArr[nextID];
				}
				seg[idVeh].Trip[idTrip].endS = cStartS;
				varvioTWC = FvioTWCus[preID] - seg[idVeh].Trip[idTrip].vioTWC;
				seg[idVeh].Trip[idTrip].vioTWC = FvioTWCus[preID];

				if (seg[idVeh].Trip[idTrip].vioTWSP > eps || seg[idVeh].Trip[idTrip].vioCAP > 0 || seg[idVeh].Trip[idTrip].vioTWC > eps)
					seg[idVeh].Trip[idTrip].feasible = 0;
				else
					seg[idVeh].Trip[idTrip].feasible = 1;

				//preIDi now points to the last cus:
				//Update BCAP from j to firstCus
				//Update BvioTWCus from lastCus to firstCus
				if (suci > 0)
				{
					BvioTWCus[preID] = vioTWCus[preID];
					id = predArr[preID];
					while (id != j)
					{
						BvioTWCus[id] = BvioTWCus[preID] + vioTWCus[id];
						preID = id; id = predArr[id];
					}
					BvioTWCus[j] = BvioTWCus[preID] + vioTWCus[j];
					BCAP[j] = BCAP[preID] + problem->node[j].capacity;
					id = prei; preID = j;
					while (id > 0)
					{
						BvioTWCus[id] = BvioTWCus[preID] + vioTWCus[id];
						BCAP[id] += deltaCAP;
						preID = id; id = predArr[id];
					}

					preID = seg[idVeh].Trip[nextTrip].lastCus;
					if (seg[idVeh].Trip[nextTrip].Type) //nextTrip is delivery trip, doesnot change the last cus of idTrip
					{
						bool stop = calChangeCONNECTAtSP_DD(preID, idVeh, nextTrip, idTrip, varvioCAP, varvioTWC, varcost);
						if (stop == 0){
							//UpdateVehicle(idVeh, nextTrip, seg[idVeh].Trip[nextTrip].assSP, seg[idVeh].Trip[nextTrip].leaveSP, varvioCAP);//Quang--
						}
						goto Update2;
					}
					else //nextTrip is pickup, doesnot change the lastCus of the idTrip
					{
						double varFIT = varcost + VCAP * varvioCAP + VTWCUS * varvioTWC;
						seg[idVeh].Trip[idTrip].cost += varcost;
						seg[idVeh].Trip[idTrip].fitness += varFIT;

						//UpdateVehicle(idVeh, nextTrip, preID, seg[idVeh].Trip[idTrip].endS, varvioCAP);//Quang--
						goto Update2;
					}//end nextTrip is pickup, doesnot change the lastCus of the idTrip
				}
				else //j is now the last cus of the trip:
				{
					BvioTWCus[j] = vioTWCus[j];
					BCAP[j] = problem->node[j].capacity;
					id = prei; 
					while (id > 0)
					{
						BvioTWCus[id] = BvioTWCus[preID] + vioTWCus[id];
						BCAP[id] += deltaCAP; //OK
						preID = id; id = predArr[id];
					}

					if (seg[idVeh].Trip[nextTrip].Type) //nextTrip is delivery trip, change the lastCus of the idTrip:
					{
						bool stop = calChangeCONNECTAtSP_DD_LastCChanged(i, j, idVeh, nextTrip, idTrip, varvioCAP, varvioTWC, varcost); //for insertCusD procedure
						if (stop == 0){
							//UpdateVehicle(idVeh, nextTrip, seg[idVeh].Trip[nextTrip].assSP, seg[idVeh].Trip[nextTrip].leaveSP, varvioCAP);//Quang--
						}
						goto Update2;
					}
					else //nextTrip is pickup, change the lastCus of the idTrip
					{
						int firstC_nextT = seg[idVeh].Trip[nextTrip].firstCus;
						varcost += (problem->c[j][firstC_nextT] - problem->c[i][firstC_nextT]);
						seg[idVeh].Trip[idTrip].connectCost = problem->c[j][firstC_nextT];
						seg[idVeh].Trip[idTrip].cost += varcost;
						double varFIT = varcost + VCAP * varvioCAP + VTWCUS * varvioTWC;
						seg[idVeh].Trip[idTrip].fitness += varFIT;
						//UpdateVehicle(idVeh, nextTrip, j, seg[idVeh].Trip[idTrip].endS, varvioCAP);//Quang--
						goto Update2;
					}//end nextTrip is pickup, change the lastCus of the idTrip
				}//end insert at the end of the trip
				 Update1: //this happened when i is not the last cus of idTrip
							double varFIT = varcost + VCAP * varvioCAP + VTWCUS * varvioTWC;
							seg[idVeh].Trip[idTrip].cost += varcost;
							seg[idVeh].Trip[idTrip].fitness += varFIT;
							if (seg[idVeh].Trip[idTrip].vioTWSP > eps || seg[idVeh].Trip[idTrip].vioCAP > 0 || seg[idVeh].Trip[idTrip].vioTWC > eps)
								seg[idVeh].Trip[idTrip].feasible = 0;
							else
								seg[idVeh].Trip[idTrip].feasible = 1;
							seg[idVeh].cost += varcost; seg[idVeh].fitness += varFIT; 
							seg[idVeh].vioCAP += varvioCAP; seg[idVeh].vioTWC += varvioTWC;
							cost += varcost; fitness += varFIT; vioCAP += varvioCAP; vioTWC += varvioTWC;
		}//end not the lastTrip

		Update2:
			UpdatePos(idVeh, idTrip);
			bool stop = checkTripD_ALLFIELDS(idVeh, idTrip);
			if (stop)
			{
			  cout<<"STOP AT SUBexchangeCusDTrip @IT = "<<IT<<endl;
			  exit(-1);
			}
}

void Solution::twoOPTstarCusDTrip_oneTrip(int j, int i) //2opt* between 2 customer j and its neighbor (i) where j and i are in the same trip
{
	 //posD[j] < posD[i] 
     int idVeh = route_num[j]; int idTrip = trip_num[j];
	 int assSP = seg[idVeh].Trip[idTrip].assSP;

	 int lastCOLD = seg[idVeh].Trip[idTrip].lastCus;
	 int sucj = nextArr[j]; int prei = predArr[i];
	 int suci = nextArr[i]; 

	 int idpre,idcur,idTemp;
	 double cArrTime, cStartS,temp;

	 double varcost = problem->c[j][i] - problem->c[j][sucj];

	 cArrTime = depart[j] + problem->c[j][i];
	 //Update i:
	 temp = cArrTime - problem->node[i].eTW;
	 if (temp > eps)
	 {
		 vioTWCus[i] = temp;
		 FvioTWCus[i] = FvioTWCus[j] + temp;
		 startS[i] = problem->node[i].eTW;
		 depart[i] = problem->node[i].depart;
	 }
	 else
	 {
		 startS[i] = PDS_MAX(cArrTime, problem->node[i].sTW);
		 vioTWCus[i] = 0;
		 FvioTWCus[i] = FvioTWCus[j];
		 depart[i] = startS[i] + problem->node[i].duration;
	 }
	 cStartS = depart[i];
     nextArr[j] = i; predArr[i] = j; 
	 FCAP[i] = FCAP[j] + problem->node[i].capacity;

	 idcur = i; idpre = prei;
	 while (idpre != j) 
	 {
		   cArrTime = cStartS + problem->c[idcur][idpre];
		   temp = cArrTime - problem->node[idpre].eTW;
		   if (temp > eps)
		   {
			   startS[idpre] = problem->node[idpre].eTW;
			   depart[idpre] = problem->node[idpre].depart;
			   vioTWCus[idpre] = temp;
			   FvioTWCus[idpre] = FvioTWCus[idcur] + temp;
		   }
		   else
		   {
			   startS[idpre] = PDS_MAX(cArrTime, problem->node[idpre].sTW);
			   depart[idpre] = startS[idpre] + problem->node[idpre].duration;
			   vioTWCus[idpre] = 0;
			   FvioTWCus[idpre] = FvioTWCus[idcur];
		   }
		   cStartS = depart[idpre];
		   FCAP[idpre] = FCAP[idcur] + problem->node[idpre].capacity;
		   idTemp = idpre; idpre = predArr[idpre];
		   predArr[idTemp]=idcur; nextArr[idcur]=idTemp;
		   idcur = idTemp;
	  }
	  nextArr[sucj]=suci;

	  //now idpre is j; idcur is sucj
	  //from sucj to suci:
	  int nextTrip = idTrip + 1;
	  int nextID, preID, id;
	  double varvioTWC;
	  if (nextTrip == seg[idVeh].numTrips)
	  {
		  if (suci > 0) //i was not the last customer of the trip; sucj has to be > 0
		  {
				varcost += (problem->c[sucj][suci] - problem->c[i][suci]);
				//idcur is now sucj; check sucj-->suci & suci till the end of the leg:
				predArr[suci] = sucj;
				nextID = suci; preID = sucj; cStartS = depart[sucj];
				while (nextID > 0)
				{
					cArrTime = cStartS + problem->c[preID][nextID]; //arrTime at customer nextID
					cStartS = PDS_MAX(cArrTime, problem->node[nextID].sTW);
            		if (PDSDIF(cStartS, startS[nextID])==0) //it means varvioTWCus[nextID]=0 
					{
						//update BvioTWCus from preID to firstCus
						//update BCAP from sucj to i
						//update FvioTWCus from nextID to lastCus; DONT NEED TO UPDATE FCAP
						id = nextID;
						while (preID != sucj)
						{
							BvioTWCus[preID] = BvioTWCus[id] + vioTWCus[preID];
							id = preID; preID = predArr[id];
						}
						do
						{
							BvioTWCus[preID] = BvioTWCus[id] + vioTWCus[preID];
							BCAP[preID] = BCAP[id] + problem->node[preID].capacity;
							id = preID; preID = predArr[id];
						}while (preID != j);
						do
						{
							BvioTWCus[preID] = BvioTWCus[id] + vioTWCus[preID];
							id = preID; preID = predArr[id];
						}while (preID > 0);

						//update FCAP, FvioTWCus from nextID to lastCus:
						id = nextID; preID = predArr[nextID];
						do
						{
							FvioTWCus[id] = FvioTWCus[preID] + vioTWCus[id];
							preID = id; id = nextArr[id];
						}while (id > 0);
						//preID now points to the last cus
						varvioTWC = FvioTWCus[preID] - seg[idVeh].Trip[idTrip].vioTWC; 
						seg[idVeh].Trip[idTrip].vioTWC = FvioTWCus[preID];
						goto Update;
					}
					temp = cStartS - problem->node[nextID].eTW;
					if (temp > eps)
					{
						if (vioTWCus[nextID] > eps) 
						{
							vioTWCus[nextID] = temp;
							//Update BvioTWCus from nextID to firstCus
							//Update BCAP from sucj to i
							//Update FvioTWCus from nextID to lastCus; DONT NEED TO UPDATE FCAP
							id = nextArr[nextID];
							if (id < 0) BvioTWCus[nextID] = vioTWCus[nextID];
							else BvioTWCus[nextID] = BvioTWCus[id] + vioTWCus[nextID];

							id = nextID;
							while (preID != sucj)
							{
								BvioTWCus[preID] = BvioTWCus[id] + vioTWCus[preID];
								id = preID; preID = predArr[id];
							}
							do
							{
								BvioTWCus[preID] = BvioTWCus[id] + vioTWCus[preID];
								BCAP[preID] = BCAP[id] + problem->node[preID].capacity;
								id = preID; preID = predArr[id];
							}while (preID != j);

							do
							{
								BvioTWCus[preID] = BvioTWCus[id] + vioTWCus[preID];
								id = preID; preID = predArr[id];
							}while (preID > 0);

							//Update FvioTWCus from nextID to lastCus
							id = nextID; preID = predArr[nextID];
							do
							{
								FvioTWCus[id] = FvioTWCus[preID] + vioTWCus[id];
								preID = id; id = nextArr[id];
							}while (id > 0);
							//preID now points to the last cus
							varvioTWC = FvioTWCus[preID] - seg[idVeh].Trip[idTrip].vioTWC;
							seg[idVeh].Trip[idTrip].vioTWC = FvioTWCus[preID];
							goto Update;
						}
						vioTWCus[nextID] = temp;
						FvioTWCus[nextID] = FvioTWCus[preID] + temp;
						cStartS = problem->node[nextID].eTW;
					}
					startS[nextID] = cStartS;
					cStartS += problem->node[nextID].duration;
					depart[nextID] = cStartS;
					//FCAP[nextID] don't need to update FCAP
					preID = nextID; nextID = nextArr[nextID];
				}
				seg[idVeh].Trip[idTrip].endS = cStartS;
				varvioTWC = FvioTWCus[preID] - seg[idVeh].Trip[idTrip].vioTWC;
				seg[idVeh].Trip[idTrip].vioTWC = FvioTWCus[preID];

				//preID now points to the last cus:
				//Update BCAP from sucj to i
				//Update BvioTWCus from lastCus to firstCus
				BvioTWCus[preID] = vioTWCus[preID];
				id = predArr[preID];
				while (id != sucj)
				{
					BvioTWCus[id] = BvioTWCus[preID] + vioTWCus[id];
					preID = id; id = predArr[id];
				}
				do
				{
					BvioTWCus[id] = BvioTWCus[preID] + vioTWCus[id];
					BCAP[id] = BCAP[preID] + problem->node[id].capacity;
					preID = id; id = predArr[id];
				}while (id != j);
				do
				{
					BvioTWCus[id] = BvioTWCus[preID] + vioTWCus[id];
					preID = id; id = predArr[id];
				}while (id > 0);
		  }
		  else //i was the last customer of the trip --> sucj is now the last customer of the trip:
		  {
			  seg[idVeh].Trip[idTrip].lastCus = sucj;
			  seg[idVeh].Trip[idTrip].endS = depart[sucj];
			  varcost += (problem->c[sucj][0] - problem->c[i][0]);
			  seg[idVeh].Trip[idTrip].connectCost = problem->c[sucj][0];
			  varvioTWC = FvioTWCus[sucj] - seg[idVeh].Trip[idTrip].vioTWC;
              seg[idVeh].Trip[idTrip].vioTWC = FvioTWCus[sucj];
              //Update BvioTWCus from lastCus to firstCus
			  //Update BCAP from lastCus to i
			  BvioTWCus[sucj] = vioTWCus[sucj];
			  BCAP[sucj] = problem->node[sucj].capacity;
			  id = predArr[sucj]; preID = sucj;
			  while (id != j)
			  {
					BvioTWCus[id] = BvioTWCus[preID] + vioTWCus[id];
					BCAP[id] = BCAP[preID] + problem->node[id].capacity; //ok
					preID = id; id = predArr[id];
			 }
			 do
			 {
					BvioTWCus[id] = BvioTWCus[preID] + vioTWCus[id];
					preID = id; id = predArr[id];
			 }while (id > 0);
		  }//i was the last customer of the trip --> sucj is now the last customer of the trip
		   Update:
				seg[idVeh].Trip[idTrip].cost += varcost;
				double varFIT = varcost + VTWCUS * varvioTWC;
				if (FvioTWCus[seg[idVeh].Trip[idTrip].lastCus] > eps || seg[idVeh].Trip[idTrip].vioCAP > 0 || seg[idVeh].Trip[idTrip].vioTWSP > eps)
				{
					seg[idVeh].Trip[idTrip].feasible = 0;
					seg[idVeh].Trip[idTrip].fitness +=  varFIT;
				}
				else
				{
					seg[idVeh].Trip[idTrip].feasible = 1;
					seg[idVeh].Trip[idTrip].fitness = seg[idVeh].Trip[idTrip].cost;
				}
				seg[idVeh].cost += varcost; seg[idVeh].fitness += varFIT; seg[idVeh].vioTWC += varvioTWC;
				cost += varcost; fitness += varFIT; vioTWC += varvioTWC;
	  }
	  else //not the last trip
	  {
		  if (suci > 0) //i was not the last customer of the trip; sucj has to be > 0
		  {
				varcost += (problem->c[sucj][suci] - problem->c[i][suci]);
				//idcur is now sucj; check sucj-->suci & suci till the end of the leg:
				predArr[suci] = sucj;
				nextID = suci; preID = sucj; cStartS = depart[sucj];
				while (nextID > 0)
				{
					cArrTime = cStartS + problem->c[preID][nextID]; //arrTime at customer nextID
					cStartS = PDS_MAX(cArrTime, problem->node[nextID].sTW);
            		if (PDSDIF(cStartS, startS[nextID])==0) //it means varvioTWCus[nextID]=0 
					{
						//update BvioTWCus from preID to firstCus
						//update BCAP from sucj to i
						//update FvioTWCus from nextID to lastCus; DONT NEED TO UPDATE FCAP
						id = nextID;
						while (preID != sucj)
						{
							BvioTWCus[preID] = BvioTWCus[id] + vioTWCus[preID];
							id = preID; preID = predArr[id];
						}
						do
						{
							BvioTWCus[preID] = BvioTWCus[id] + vioTWCus[preID];
							BCAP[preID] = BCAP[id] + problem->node[preID].capacity;
							id = preID; preID = predArr[id];
						}while (preID != j);
						do
						{
							BvioTWCus[preID] = BvioTWCus[id] + vioTWCus[preID];
							id = preID; preID = predArr[id];
						}while (preID > 0);

						//update FCAP, FvioTWCus from nextID to lastCus:
						id = nextID; preID = predArr[nextID];
						do
						{
							FvioTWCus[id] = FvioTWCus[preID] + vioTWCus[id];
							preID = id; id = nextArr[id];
						}while (id > 0);
						//preID now points to the last cus
						varvioTWC = FvioTWCus[preID] - seg[idVeh].Trip[idTrip].vioTWC; 
						seg[idVeh].Trip[idTrip].vioTWC = FvioTWCus[preID];
						goto Update1;
					}
					temp = cStartS - problem->node[nextID].eTW;
					if (temp > eps)
					{
						if (vioTWCus[nextID] > eps) 
						{
							vioTWCus[nextID] = temp;
							//Update BvioTWCus from nextID to firstCus
							//Update BCAP from sucj to i
							//Update FvioTWCus from nextID to lastCus; DONT NEED TO UPDATE FCAP
							id = nextArr[nextID];
							if (id < 0) BvioTWCus[nextID] = vioTWCus[nextID];
							else BvioTWCus[nextID] = BvioTWCus[id] + vioTWCus[nextID];

							id = nextID;
							while (preID != sucj)
							{
								BvioTWCus[preID] = BvioTWCus[id] + vioTWCus[preID];
								id = preID; preID = predArr[id];
							}
							do
							{
								BvioTWCus[preID] = BvioTWCus[id] + vioTWCus[preID];
								BCAP[preID] = BCAP[id] + problem->node[preID].capacity;
								id = preID; preID = predArr[id];
							}while (preID != j);

							do
							{
								BvioTWCus[preID] = BvioTWCus[id] + vioTWCus[preID];
								id = preID; preID = predArr[id];
							}while (preID > 0);

							//Update FvioTWCus from nextID to lastCus
							id = nextID; preID = predArr[nextID];
							do
							{
								FvioTWCus[id] = FvioTWCus[preID] + vioTWCus[id];
								preID = id; id = nextArr[id];
							}while (id > 0);
							//preID now points to the last cus
							varvioTWC = FvioTWCus[preID] - seg[idVeh].Trip[idTrip].vioTWC;
							seg[idVeh].Trip[idTrip].vioTWC = FvioTWCus[preID];
							goto Update1;
						}
						vioTWCus[nextID] = temp;
						FvioTWCus[nextID] = FvioTWCus[preID] + temp;
						cStartS = problem->node[nextID].eTW;
					}
					startS[nextID] = cStartS;
					cStartS += problem->node[nextID].duration;
					depart[nextID] = cStartS;
					//FCAP[nextID] don't need to update FCAP
					preID = nextID; nextID = nextArr[nextID];
				}
				seg[idVeh].Trip[idTrip].endS = cStartS;
				varvioTWC = FvioTWCus[preID] - seg[idVeh].Trip[idTrip].vioTWC;
				seg[idVeh].Trip[idTrip].vioTWC = FvioTWCus[preID];
		
				if (seg[idVeh].Trip[idTrip].vioTWSP > eps || seg[idVeh].Trip[idTrip].vioCAP > 0 || seg[idVeh].Trip[idTrip].vioTWC > eps)
					seg[idVeh].Trip[idTrip].feasible = 0;
				else
					seg[idVeh].Trip[idTrip].feasible = 1;

				//preID now points to the last cus:
				//Update BCAP from sucj to i
				//Update BvioTWCus from lastCus to firstCus
				BvioTWCus[preID] = vioTWCus[preID];
				id = predArr[preID];
				while (id != sucj)
				{
					BvioTWCus[id] = BvioTWCus[preID] + vioTWCus[id];
					preID = id; id = predArr[id];
				}
				do
				{
					BvioTWCus[id] = BvioTWCus[preID] + vioTWCus[id];
					BCAP[id] = BCAP[preID] + problem->node[id].capacity;
					preID = id; id = predArr[id];
				}while (id != j);
				do
				{
					BvioTWCus[id] = BvioTWCus[preID] + vioTWCus[id];
					preID = id; id = predArr[id];
				}while (id > 0);

				preID = seg[idVeh].Trip[nextTrip].lastCus;
				if (seg[idVeh].Trip[nextTrip].Type) //nextTrip is delivery trip, lastCus doesn't change
				{
					bool stop = calChangeCONNECTAtSP_DD(preID, idVeh, nextTrip, idTrip, 0, varvioTWC, varcost);
					if (stop == 0){
						//UpdateVehicle(idVeh, nextTrip, seg[idVeh].Trip[nextTrip].assSP, seg[idVeh].Trip[nextTrip].leaveSP, 0);//Quangnn--
					}
					goto Update2;
				}
				else //next Trip is pickup, lastCus doesn't change
				{
					double varFIT = varcost + VTWCUS * varvioTWC;
					seg[idVeh].Trip[idTrip].cost += varcost;
					seg[idVeh].Trip[idTrip].fitness += varFIT;

					//UpdateVehicle(idVeh, nextTrip, preID, seg[idVeh].Trip[idTrip].endS, 0);//Quangnn--
					goto Update2;
				}//end next Trip is pickup, not insert at the end of the idTrip
		  }
		  else //i was the last customer of the trip --> sucj is now the last customer of the trip:
		  {
			  seg[idVeh].Trip[idTrip].lastCus = sucj;
			  seg[idVeh].Trip[idTrip].endS = depart[sucj];
			  preID = sucj;
			  varvioTWC = FvioTWCus[preID] - seg[idVeh].Trip[idTrip].vioTWC;
              seg[idVeh].Trip[idTrip].vioTWC = FvioTWCus[preID];
              //Update BvioTWCus from lastCus to firstCus
			  //Update BCAP from lastCus to i
			  BvioTWCus[preID] = vioTWCus[preID];
			  BCAP[preID] = problem->node[j].capacity;
			  id = predArr[preID];
			  while (id != j)
			  {
					BvioTWCus[id] = BvioTWCus[preID] + vioTWCus[id];
					BCAP[id] = BCAP[preID] + problem->node[id].capacity; //ok
					preID = id; id = predArr[id];
			 }
			 do
			 {
					BvioTWCus[id] = BvioTWCus[preID] + vioTWCus[id];
					preID = id; id = predArr[id];
			 }while (id > 0);

			 if (seg[idVeh].Trip[nextTrip].Type)
			 {
				bool stop = calChangeCONNECTAtSP_DD_LastCChanged(j, sucj, idVeh, nextTrip, idTrip, 0, varvioTWC, varcost); //for insertCusD procedure
				if (stop == 0){
					//UpdateVehicle(idVeh, nextTrip, seg[idVeh].Trip[nextTrip].assSP, seg[idVeh].Trip[nextTrip].leaveSP, 0);//Quangnn--
				}
				goto Update2;
			 }
			 else //nextTrip is pickup, lastCus change:
			 {
				int firstC_nextT = seg[idVeh].Trip[nextTrip].firstCus;
				varcost += (problem->c[sucj][firstC_nextT] - problem->c[i][firstC_nextT]);
				seg[idVeh].Trip[idTrip].connectCost = problem->c[sucj][firstC_nextT];
				seg[idVeh].Trip[idTrip].cost += varcost;
				double varFIT = varcost + VTWCUS * varvioTWC;
				seg[idVeh].Trip[idTrip].fitness += varFIT;
				//UpdateVehicle(idVeh, nextTrip, sucj, seg[idVeh].Trip[idTrip].endS, 0);//Quangnn--
				goto Update2;
			 }//end nextTrip is pickup, lastCus change
		  }//i was the last customer of the trip --> sucj is now the last customer of the trip

	 Update1: //this happened when not insert at the the last cus
			double varFIT = varcost + VTWCUS * varvioTWC;
			seg[idVeh].Trip[idTrip].cost += varcost;
			seg[idVeh].Trip[idTrip].fitness += varFIT;
			if (seg[idVeh].Trip[idTrip].vioTWSP > eps || seg[idVeh].Trip[idTrip].vioCAP > 0 || seg[idVeh].Trip[idTrip].vioTWC > eps)
				seg[idVeh].Trip[idTrip].feasible = 0;
			else
				seg[idVeh].Trip[idTrip].feasible = 1;
			seg[idVeh].cost += varcost; seg[idVeh].fitness += varFIT; 
			seg[idVeh].vioTWC += varvioTWC;
			cost += varcost; fitness += varFIT; vioTWC += varvioTWC;
	  }//not the last trip
	Update2:
		UpdatePos(idVeh, idTrip);
		bool stop = checkTripD_ALLFIELDS(idVeh, idTrip);
		if (stop)
		{
		  cout<<"STOP AT twoOPTstarCusDTrip_oneTrip @IT = "<<IT<<endl;
		  exit(-1);
		}
		//return 0;
}

bool Solution::twoOPTstarCusDTrip(int j, int i) //2opt* between 2 customer j and its neighbor (i) where j and i belong to different trips
{
	//April 17th: moi trip sau idTripj va idTripi can giu nguyen vehicle
     int idVehj = route_num[j]; int idTripj = trip_num[j];
	 int idVehi = route_num[i]; int idTripi = trip_num[i];

	 int assSPi = seg[idVehi].Trip[idTripi].assSP;
	 int assSPj = seg[idVehj].Trip[idTripj].assSP;
	 int lastCOLDi = seg[idVehi].Trip[idTripi].lastCus;
	 int lastCOLDj = seg[idVehj].Trip[idTripj].lastCus;
	 double TcostOLD = seg[idVehi].Trip[idTripi].cost + seg[idVehj].Trip[idTripj].cost; //total cost old

	 int sucj = nextArr[j]; int prei = predArr[i];
	 bool emptyTripi=0; bool emptyVehi=0;
     double COSTOLDj = seg[idVehj].Trip[idTripj].cost;
	 double COSTOLDi = seg[idVehi].Trip[idTripi].cost;

	 //1. vioCAP,capacity:
	 int capj = FCAP[j] + BCAP[i];
	 int capi=0; 
	 if (prei > 0) capi = FCAP[prei];
	 if (sucj > 0) capi += BCAP[sucj];
	 
	 seg[idVehi].Trip[idTripi].capacity = capi;
	 int vioCAPNEW = PDS_MAX(capi - problem->Q, 0);
	 int varvioCAPi = vioCAPNEW - seg[idVehi].Trip[idTripi].vioCAP;
	 seg[idVehi].Trip[idTripi].vioCAP = vioCAPNEW;

	 seg[idVehj].Trip[idTripj].capacity = capj;
	 vioCAPNEW = PDS_MAX(capj - problem->Q, 0);
	 int varvioCAPj = vioCAPNEW - seg[idVehj].Trip[idTripj].vioCAP;
     seg[idVehj].Trip[idTripj].vioCAP = vioCAPNEW;
	 
	 double cArrTime, cStartSi, cStartS, temp, varvioTWC, varcostj, varcosti;
     int fC,id,preID, nextID, curi, idnexti;

	 //2. Update nextArr, predArr, firstCus, lastCus
	 //For the trip contains j:
	 nextArr[j] = i; predArr[i] = j;
	 seg[idVehj].Trip[idTripj].lastCus = lastCOLDi;
	
	 //For the trip contained i before:
	 if (prei > 0)
	 {
		 if (sucj > 0) 
		 {
			 nextArr[prei]=sucj;
			 predArr[sucj]=prei;
			 seg[idVehi].Trip[idTripi].lastCus = lastCOLDj;
		 }
		 else 
		 {
			 seg[idVehi].Trip[idTripi].lastCus = prei; 
			 nextArr[prei]=-1;
		 }
		 cStartSi = depart[prei]; 
		 curi=prei; idnexti=sucj;
	 }
	 else //i was the first customer of idTripi
	 {
		 if (sucj > 0) 
		 {
			 seg[idVehi].Trip[idTripi].firstCus = sucj; 
             predArr[sucj]=-1; 
			 seg[idVehi].Trip[idTripi].lastCus = lastCOLDj;
			 cStartSi = seg[idVehi].Trip[idTripi].leaveSP; 
			 curi = assSPi; idnexti = sucj;
		 }
		 else {emptyTripi=1; /*update_EmptyLeg(idVehi,idLegi);*///cout<<"EMPTY LEG ("<<idVehi<<", "<<idLegi<<")"<<endl;
		      } //it is now the empty leg
	 }

	 int numCusj = seg[idVehj].Trip[idTripj].numCus;
	 int numCusi = seg[idVehi].Trip[idTripi].numCus;
	 seg[idVehj].Trip[idTripj].numCus = pos[j] + (numCusi - pos[i] + 1);
	 seg[idVehi].Trip[idTripi].numCus = numCusi + numCusj - seg[idVehj].Trip[idTripj].numCus;
	 
     
	 //Calculate cost from firstCus of idTripj to j:
	 double COSTj=0; fC = seg[idVehj].Trip[idTripj].firstCus; int preCC= assSPj;
	 
	 if (sucj > 0)
	 {
		 while (preCC != j)
		 {
			 COSTj += problem->c[preCC][fC];
			 preCC=fC; fC =nextArr[fC];
		 }
	 }
	 else 
		 COSTj = seg[idVehj].Trip[idTripj].cost - seg[idVehj].Trip[idTripj].connectCost;

	 double COSTi = 0;
	 if (prei > 0)
	 {
		 preCC = assSPi; fC = seg[idVehi].Trip[idTripi].firstCus;
		 while (preCC != prei)
		 {
			 COSTi += problem->c[preCC][fC];
			 preCC = fC; fC = nextArr[fC];
		 }
	 }
	 //else COSTi = 0;

 
	 //For the trip contain j:
	 cStartS = depart[j]; preID = j; nextID = i;
	 int nextTrip = idTripj+1;
	 if (nextTrip == seg[idVehj].numTrips) //idTripj is the last trip
	 {
 		 while (nextID > 0) 
		 {
			   cArrTime = cStartS + problem->c[preID][nextID];
			   cStartS = PDS_MAX(cArrTime, problem->node[nextID].sTW);
			   if (PDSDIF(cStartS, startS[nextID])==0) //it means varvioTWCus[nextID] = 0 
			   {
				   //Update BCAP from j to firstCus
				   //Update BvioTWCus from preID to firstCus
				   //Update trip_num, route_num, pos from nextID to lastCus
				   //Update FCAP, FvioTWCus from nextID to lastCus
				   //Update cost
				   id = nextID;
				   while (preID != j)
				   {
					   BvioTWCus[preID] = BvioTWCus[id] + vioTWCus[preID];
					   id = preID; preID = predArr[preID];
				   }
				   do
				   {
					   BvioTWCus[preID] = BvioTWCus[id] + vioTWCus[preID];
					   BCAP[preID] = BCAP[id] + problem->node[preID].capacity;
					   id = preID; preID = predArr[preID];
				   }while (preID > 0);
				   id = nextID; preID = predArr[id];
				   do
				   {
					   route_num[id] = idVehj; trip_num[id] = idTripj;
					   pos[id] = pos[preID] + 1;
					   FCAP[id] = FCAP[preID] + problem->node[id].capacity;
					   FvioTWCus[id] = FvioTWCus[preID] + vioTWCus[id];
					   COSTj += problem->c[preID][id];
					   preID = id; id = nextArr[id];
				   }while (id > 0);
				   //preID now points to lastCus:
				   varvioTWC = seg[idVehj].Trip[idTripj].vioTWC - FvioTWCus[preID];
				   seg[idVehj].Trip[idTripj].vioTWC = FvioTWCus[preID];
				   seg[idVehj].Trip[idTripj].endS = depart[preID];
				   goto Update;
			   }
			   temp = cStartS - problem->node[nextID].eTW;
			   if (temp > eps)
			   {
					if (vioTWCus[nextID] > eps) 
					{
						vioTWCus[nextID] = temp;
						//Update BvioTWCus from nextID to firstCus
						//Update BCAP from j to firstCus
						//Update FCAP, FvioTWCus from nextID to lastCus
						//Update trip_num, route_num fro nextID to lastCus
						//Update cost
						id = nextArr[nextID];
						if (id < 0) BvioTWCus[nextID] = vioTWCus[nextID];
						else BvioTWCus[nextID] = BvioTWCus[id] + vioTWCus[nextID];

					    id = nextID;
					    while (preID != j)
					    {
						   BvioTWCus[preID] = BvioTWCus[id] + vioTWCus[preID];
						   id = preID; preID = predArr[preID];
					    }
					    do
					    {
						   BvioTWCus[preID] = BvioTWCus[id] + vioTWCus[preID];
						   BCAP[preID] = BCAP[id] + problem->node[preID].capacity;
						   id = preID; preID = predArr[preID];
					    }while (preID > 0);
					    id = nextID; preID = predArr[id];
					    do
					    {
						   route_num[id] = idVehj; trip_num[id] = idTripj;
						   pos[id] = pos[preID] + 1;
						   FCAP[id] = FCAP[preID] + problem->node[id].capacity;
						   FvioTWCus[id] = FvioTWCus[preID] + vioTWCus[id];
						   COSTj += problem->c[preID][id];
						   preID = id; id = nextArr[id];
					    }while (id > 0);
					    //preID now points to lastCus:
					    varvioTWC = seg[idVehj].Trip[idTripj].vioTWC - FvioTWCus[preID];
					    seg[idVehj].Trip[idTripj].vioTWC = FvioTWCus[preID];
						seg[idVehj].Trip[idTripj].endS = depart[preID];
						goto Update;
					}
					vioTWCus[nextID] = temp;
					FvioTWCus[nextID] = FvioTWCus[preID] + temp;
					cStartS = problem->node[nextID].eTW;
			   }
			   startS[nextID] = cStartS;
			   cStartS += problem->node[nextID].duration;
			   depart[nextID] = cStartS;
			   FCAP[nextID] = FCAP[preID] + problem->node[nextID].capacity;
			   route_num[nextID] = idVehj; trip_num[nextID] = idTripj;
			   pos[nextID] = pos[preID] + 1;
			   COSTj += problem->c[preID][nextID];
			   preID = nextID; nextID = nextArr[nextID];
		 }
		 seg[idVehj].Trip[idTripj].endS = cStartS;
		 varvioTWC = FvioTWCus[preID] - seg[idVehj].Trip[idTripj].vioTWC;
		 seg[idVehj].Trip[idTripj].vioTWC = FvioTWCus[preID];
		//preID now points to the last cus:
		 seg[idVehj].Trip[idTripj].connectCost = problem->c[preID][0];

		 //Update BCAP from j to firstCus
		 //Update BvioTWCus from lastCus to firstCus
		 BvioTWCus[preID] = vioTWCus[preID];
		 id = predArr[preID];
		 while (id != j)
		 {
			BvioTWCus[id] = BvioTWCus[preID] + vioTWCus[id];
			preID = id; id = predArr[id];
		}
		BvioTWCus[j] = BvioTWCus[preID] + vioTWCus[j];
		BCAP[j] = BCAP[preID] + problem->node[j].capacity;
		id = prei; preID = j;
		while (id > 0)
		{
			BvioTWCus[id] = BvioTWCus[preID] + vioTWCus[id];
			BCAP[id] = BCAP[preID] + problem->node[id].capacity;
			preID = id; id = predArr[id];
		}

		Update:
		    COSTj += problem->c[lastCOLDi][0];
			seg[idVehj].Trip[idTripj].cost = COSTj;
			varcostj = COSTj - COSTOLDj;
			double varFIT = varcostj + VCAP * varvioCAPj + VTWCUS * varvioTWC;
			if (seg[idVehj].Trip[idTripj].vioTWC > eps || seg[idVehj].Trip[idTripj].vioCAP > 0 || seg[idVehj].Trip[idTripj].vioTWSP > eps)
			{
				seg[idVehj].Trip[idTripj].feasible = 0;
				seg[idVehj].Trip[idTripj].fitness +=  varFIT;
			}
			else
			{
				seg[idVehj].Trip[idTripj].feasible = 1;
				seg[idVehj].Trip[idTripj].fitness = seg[idVehj].Trip[idTripj].cost;
			}
			seg[idVehj].cost += varcostj; seg[idVehj].fitness += varFIT; 
			seg[idVehj].vioCAP += varvioCAPj; seg[idVehj].vioTWC += varvioTWC;
			cost += varcostj; fitness += varFIT; vioCAP += varvioCAPj; vioTWC += varvioTWC;
	 }
	 else //idTripj is not the last trip
	 {
 		 while (nextID > 0) 
		 {
			   cArrTime = cStartS + problem->c[preID][nextID];
			   cStartS = PDS_MAX(cArrTime, problem->node[nextID].sTW);
			   if (PDSDIF(cStartS, startS[nextID])==0) //it means varvioTWCus[nextID] = 0 
			   {
				   //Update BCAP from j to firstCus
				   //Update BvioTWCus from preID to firstCus
				   //Update trip_num, route_num, pos from nextID to lastCus
				   //Update FCAP, FvioTWCus from nextID to lastCus
				   //Update cost
				   id = nextID;
				   while (preID != j)
				   {
					   BvioTWCus[preID] = BvioTWCus[id] + vioTWCus[preID];
					   id = preID; preID = predArr[preID];
				   }
				   do
				   {
					   BvioTWCus[preID] = BvioTWCus[id] + vioTWCus[preID];
					   BCAP[preID] = BCAP[id] + problem->node[preID].capacity;
					   id = preID; preID = predArr[preID];
				   }while (preID > 0);
				   id = nextID; preID = predArr[id];
				   do
				   {
					   route_num[id] = idVehj; trip_num[id] = idTripj;
					   pos[id] = pos[preID] + 1;
					   FCAP[id] = FCAP[preID] + problem->node[id].capacity;
					   FvioTWCus[id] = FvioTWCus[preID] + vioTWCus[id];
					   COSTj += problem->c[preID][id];
					   preID = id; id = nextArr[id];
				   }while (id > 0);
				   //preID now points to lastCus:
				   varvioTWC = seg[idVehj].Trip[idTripj].vioTWC - FvioTWCus[preID];
				   seg[idVehj].Trip[idTripj].vioTWC = FvioTWCus[preID];
				   seg[idVehj].Trip[idTripj].endS = depart[preID];
				   goto Update1;
			   }
			   temp = cStartS - problem->node[nextID].eTW;
			   if (temp > eps)
			   {
					if (vioTWCus[nextID] > eps) 
					{
						vioTWCus[nextID] = temp;
						//Update BvioTWCus from nextID to firstCus
						//Update BCAP from j to firstCus
						//Update FCAP, FvioTWCus from nextID to lastCus
						//Update trip_num, route_num fro nextID to lastCus
						//Update cost
						id = nextArr[nextID];
						if (id < 0) BvioTWCus[nextID] = vioTWCus[nextID];
						else BvioTWCus[nextID] = BvioTWCus[id] + vioTWCus[nextID];

					    id = nextID;
					    while (preID != j)
					    {
						   BvioTWCus[preID] = BvioTWCus[id] + vioTWCus[preID];
						   id = preID; preID = predArr[preID];
					    }
					    do
					    {
						   BvioTWCus[preID] = BvioTWCus[id] + vioTWCus[preID];
						   BCAP[preID] = BCAP[id] + problem->node[preID].capacity;
						   id = preID; preID = predArr[preID];
					    }while (preID > 0);
					    id = nextID; preID = predArr[id];
					    do
					    {
						   route_num[id] = idVehj; trip_num[id] = idTripj;
						   pos[id] = pos[preID] + 1;
						   FCAP[id] = FCAP[preID] + problem->node[id].capacity;
						   FvioTWCus[id] = FvioTWCus[preID] + vioTWCus[id];
						   COSTj += problem->c[preID][id];
						   preID = id; id = nextArr[id];
					    }while (id > 0);
					    //preID now points to lastCus:
					    varvioTWC = seg[idVehj].Trip[idTripj].vioTWC - FvioTWCus[preID];
					    seg[idVehj].Trip[idTripj].vioTWC = FvioTWCus[preID];
					    seg[idVehj].Trip[idTripj].endS = depart[preID];
						goto Update1;
					}
					vioTWCus[nextID] = temp;
					FvioTWCus[nextID] = FvioTWCus[preID] + temp;
					cStartS = problem->node[nextID].eTW;
			   }
			   startS[nextID] = cStartS;
			   cStartS += problem->node[nextID].duration;
			   depart[nextID] = cStartS;
			   FCAP[nextID] = FCAP[preID] + problem->node[nextID].capacity;
			   route_num[nextID] = idVehj; trip_num[nextID] = idTripj;
			   COSTj += problem->c[preID][nextID];
			   preID = nextID; nextID = nextArr[nextID];
		 }
		 seg[idVehj].Trip[idTripj].endS = cStartS;
		 varvioTWC = FvioTWCus[preID] - seg[idVehj].Trip[idTripj].vioTWC;
		 seg[idVehj].Trip[idTripj].vioTWC = FvioTWCus[preID];
		//preID now points to the last cus:
		 //Update BCAP from j to firstCus
		 //Update BvioTWCus from lastCus to firstCus
		 BvioTWCus[preID] = vioTWCus[preID];
		 id = predArr[preID];
		 while (id != j)
		 {
			BvioTWCus[id] = BvioTWCus[preID] + vioTWCus[id];
			preID = id; id = predArr[id];
		}
		BvioTWCus[j] = BvioTWCus[preID] + vioTWCus[j];
		BCAP[j] = BCAP[preID] + problem->node[j].capacity;
		id = prei; preID = j;
		while (id > 0)
		{
			BvioTWCus[id] = BvioTWCus[preID] + vioTWCus[id];
			BCAP[id] = BCAP[preID] + problem->node[id].capacity;
			preID = id; id = predArr[id];
		}

		Update1:
		if (seg[idVehj].Trip[idTripj].vioTWSP > eps || seg[idVehj].Trip[idTripj].vioCAP > 0 || seg[idVehj].Trip[idTripj].vioTWC > eps)
			seg[idVehj].Trip[idTripj].feasible = 0;
		else
			seg[idVehj].Trip[idTripj].feasible = 1;

		if (seg[idVehj].Trip[nextTrip].Type) //nextTrip is delivery trip, change the lastCus of the idTrip:
		{
			bool stop = calChangeCONNECTAtSP_DD(lastCOLDi, idVehj, nextTrip, idTripj, varvioCAPj, varvioTWC, COSTj, COSTOLDj);
			if (stop == 0){
				//UpdateVehicle(idVehj, nextTrip, seg[idVehj].Trip[nextTrip].assSP, seg[idVehj].Trip[nextTrip].leaveSP, varvioCAPj);//Quangnn--
			}
		}
		else //nextTrip is pickup, change the lastCus of the idTripj
		{
			int firstC_nextT = seg[idVehj].Trip[nextTrip].firstCus;
			COSTj += problem->c[lastCOLDi][firstC_nextT];
			seg[idVehj].Trip[idTripj].connectCost = problem->c[lastCOLDi][firstC_nextT];
			seg[idVehj].Trip[idTripj].cost = COSTj;
			varcostj = COSTj - COSTOLDj;
			double varFIT = varcostj + VCAP * varvioCAPj + VTWCUS * varvioTWC;
			seg[idVehj].Trip[idTripj].fitness += varFIT;
			//UpdateVehicle(idVehj, nextTrip, lastCOLDi, seg[idVehj].Trip[idTripj].endS, varvioCAPj);//Quangnn--
		}//end nextTrip is pickup, change the lastCus of the idTrip
	 }//end idTripj is not the last trip
   	 

	  //For the trip contain i:
	  if (!emptyTripi) //tripi is not the empty trip:
	  {
			 preID = curi; nextID = idnexti; cStartS = cStartSi;
			 nextTrip = idTripi + 1;
			 while (nextID > 0) 
			 {
				   cArrTime = cStartS + problem->c[preID][nextID];
				   cStartS = PDS_MAX(cArrTime, problem->node[nextID].sTW);
				   if (PDSDIF(cStartS, startS[nextID])==0) //it means varvioTWCus[nextID] = 0 
				   {
					   //Update BCAP from prei to firstCus (prei may = assSPi)
					   //Update BvioTWCus from preID to firstCus (preID may = assSPi)
					   //Update trip_num, route_num, pos from nextID to lastCus
					   //Update FCAP, FvioTWCus from nextID to lastCus
					   //Update cost
					   id = nextID; preID = predArr[nextID];
					   while (preID > 0)
					   {
						   BvioTWCus[preID] = BvioTWCus[id] + vioTWCus[preID];
						   BCAP[preID] = BCAP[id] + problem->node[preID].capacity;
						   id = preID; preID = predArr[preID];
					   }
					   id = nextID; preID = predArr[id];
					   if (preID < 0) 
					   {
						   pos[id] = 1;route_num[id] = idVehi; trip_num[id] = idTripi;
						   FCAP[id] = problem->node[id].capacity;
						   FvioTWCus[id] = vioTWCus[id];
						   COSTi = problem->c[assSPi][nextID];
						   preID = id; id = nextArr[id];
					   }
					   while (id > 0)
					   {
						   route_num[id] = idVehi; trip_num[id] = idTripi;
						   pos[id] = pos[preID] + 1;
						   FCAP[id] = FCAP[preID] + problem->node[id].capacity;
						   FvioTWCus[id] = FvioTWCus[preID] + vioTWCus[id];
						   COSTi += problem->c[preID][id];
						   preID = id; id = nextArr[id];
					   }
					   //preID now points to lastCus:
					   varvioTWC = seg[idVehi].Trip[idTripi].vioTWC - FvioTWCus[preID];
					   seg[idVehi].Trip[idTripi].vioTWC = FvioTWCus[preID];
					   seg[idVehi].Trip[idTripi].endS = depart[preID];
					   goto Update3;
				   }
				   temp = cStartS - problem->node[nextID].eTW;
				   if (temp > eps)
				   {
						if (vioTWCus[nextID] > eps) 
						{
							vioTWCus[nextID] = temp;
							//Update BvioTWCus from nextID to firstCus
							//Update BCAP from prei to firstCus (prei may = assSPi)
							//Update FCAP, FvioTWCus from nextID to lastCus
							//Update trip_num, route_num, pos from nextID to lastCus
							//Update cost
							id = nextArr[nextID];
							if (id < 0) BvioTWCus[nextID] = vioTWCus[nextID];
							else BvioTWCus[nextID] = BvioTWCus[id] + vioTWCus[nextID];

							id = nextID; preID = predArr[id];
							while (preID > 0)
							{
							   BvioTWCus[preID] = BvioTWCus[id] + vioTWCus[preID];
							   BCAP[preID] = BCAP[id] + problem->node[preID].capacity;
							   id = preID; preID = predArr[preID];
							}
							
							id = nextID; preID = predArr[nextID];
							if (preID < 0)
							{
								route_num[nextID] = idVehi; trip_num[nextID] = idTripi; 
								pos[nextID] = 1;
								COSTi = problem->c[assSPi][nextID];
								FCAP[nextID] = problem->node[nextID].capacity;
								FvioTWCus[nextID] = vioTWCus[nextID];
								preID = nextID; id = nextArr[nextID];
							}

							while (id > 0)
							{
								route_num[id] = idVehi; trip_num[id] = idTripi;
								pos[id] = pos[preID] + 1;
								COSTi += problem->c[preID][id];
								FCAP[id] = FCAP[preID] + problem->node[id].capacity;
								FvioTWCus[id] = FvioTWCus[preID] + vioTWCus[id];
								preID = id; id = nextArr[id];
							}
							//preID now points to lastCus:
							varvioTWC = seg[idVehi].Trip[idTripi].vioTWC - FvioTWCus[preID];
							seg[idVehi].Trip[idTripi].vioTWC = FvioTWCus[preID];
							seg[idVehi].Trip[idTripi].endS = depart[preID];
							goto Update3;
						}
						vioTWCus[nextID] = temp;
						FvioTWCus[nextID] = FvioTWCus[preID] + temp;
						cStartS = problem->node[nextID].eTW;
				   }
				   startS[nextID] = cStartS;
				   cStartS += problem->node[nextID].duration;
				   depart[nextID] = cStartS;
				   FCAP[nextID] = FCAP[preID] + problem->node[nextID].capacity;
				   route_num[nextID] = idVehi; trip_num[nextID] = idTripi;
				   pos[nextID] = pos[preID] + 1;
				   COSTi += problem->c[preID][nextID];
				   preID = nextID; nextID = nextArr[nextID];
			 }//end while (nextID > 0)
			 seg[idVehi].Trip[idTripi].endS = cStartS;
			 varvioTWC = FvioTWCus[preID] - seg[idVehi].Trip[idTripi].vioTWC;
			 seg[idVehi].Trip[idTripi].vioTWC = FvioTWCus[preID];
			//preID now points to the last cus:
			 //Update BCAP from prei to firstCus
			 //Update BvioTWCus from lastCus to firstCus
			 BvioTWCus[preID] = vioTWCus[preID];
			 BCAP[preID] = problem->node[preID].capacity;
			 id = predArr[preID];
			 while (id > 0)
			 {
				 BvioTWCus[id] = BvioTWCus[preID] + vioTWCus[id];
				 BCAP[id] = BCAP[preID] + problem->node[id].capacity;
				 preID = id; id = predArr[id];
			 }
			 Update3:
			  if (nextTrip == seg[idVehi].numTrips)
			  {
				    COSTi += problem->c[seg[idVehi].Trip[idTripi].lastCus][0];
					seg[idVehi].Trip[idTripi].cost = COSTi;
					varcosti = COSTi - COSTOLDi;
					double varFIT = varcosti + VCAP * varvioCAPi + VTWCUS * varvioTWC;
					if (seg[idVehi].Trip[idTripi].vioTWC > eps || seg[idVehi].Trip[idTripi].vioCAP > 0 || seg[idVehi].Trip[idTripi].vioTWSP > eps)
					{
						seg[idVehi].Trip[idTripi].feasible = 0;
						seg[idVehi].Trip[idTripi].fitness +=  varFIT;
					}
					else
					{
						seg[idVehi].Trip[idTripi].feasible = 1;
						seg[idVehi].Trip[idTripi].fitness = seg[idVehi].Trip[idTripi].cost;
					}
					seg[idVehi].cost += varcosti; seg[idVehi].fitness += varFIT; 
					seg[idVehi].vioCAP += varvioCAPi; seg[idVehi].vioTWC += varvioTWC;
					cost += varcosti; fitness += varFIT; vioCAP += varvioCAPi; vioTWC += varvioTWC;
			  }
			  else //not the last trip
			  {
					if (seg[idVehi].Trip[idTripi].vioTWC > eps || seg[idVehi].Trip[idTripi].vioCAP > 0 || seg[idVehi].Trip[idTripi].vioTWSP > eps)
						seg[idVehi].Trip[idTripi].feasible = 0;
					else
						seg[idVehi].Trip[idTripi].feasible = 1;
		
					if (seg[idVehi].Trip[nextTrip].Type)
					{
						bool stop = calChangeCONNECTAtSP_DD(seg[idVehi].Trip[idTripi].lastCus, idVehi, nextTrip, idTripi, varvioCAPi, varvioTWC, COSTi, COSTOLDi);
						if (stop == 0){
							//UpdateVehicle(idVehi, nextTrip, seg[idVehi].Trip[nextTrip].assSP, seg[idVehi].Trip[nextTrip].leaveSP, varvioCAPi);//Quangnn--
						}
					}
					else //nextTrip is pickup
					{
						  int firstC_nextT = seg[idVehi].Trip[nextTrip].firstCus;
						  seg[idVehi].Trip[idTripi].connectCost = problem->c[seg[idVehi].Trip[idTripi].lastCus][firstC_nextT];
						  COSTi += seg[idVehi].Trip[idTripi].connectCost;
						  seg[idVehi].Trip[idTripi].cost = COSTi;
						  varcosti = COSTi - COSTOLDi;
						  double varFIT = VCAP * varvioCAPi + VTWCUS * varvioTWC + varcosti;
						  seg[idVehi].Trip[idTripi].fitness += varFIT;
						  //UpdateVehicle(idVehi, nextTrip, seg[idVehi].Trip[idTripi].lastCus, seg[idVehi].Trip[idTripi].endS, varvioCAPi);//Quangnn--
					}//end nextTrip is pickup
			  }//end not the last trip
	  }
	  else  //idVehi.idTripi is empty
	  {
		  Update_EmptyTripD(idVehi, idTripi);
	  }//idTripi empty
	 return emptyTripi;
}

bool Solution::Update_EmptyTripD(int idVeh, int idTrip)
{
	int assSP = seg[idVeh].Trip[idTrip].assSP;
	if (numTripDSP[assSP] == problem->minTripSP[assSP]) return 1;

	double temp;

	int varvioCAP = -seg[idVeh].Trip[idTrip].vioCAP;

	seg[idVeh].Trip[idTrip].numCus=0;
	seg[idVeh].numTrips --;

	int nL = seg[idVeh].numTrips;
	int i,curT;

	if (seg[idVeh].numTrips==0) //vehicle now becomes empty:
	{
         cout<<"Vehicle "<<idVeh<<"-> now becomes empty"<<endl;
		 numVehUsed--;
		 seg[idVeh].numTrips=0;
		 //UpdateMoveSPEmptyVeh(idVeh); CAN XEM
	}
	else //vehicle doesn't become empty
	{
			if (idTrip == seg[idVeh].numTrips) //last trip becomes empty
			{
				//cout<<"Last trip becomes empty"<<endl;
				curT = idTrip-1;
				if (seg[idVeh].Trip[curT].Type == 1)
				{
					temp = seg[idVeh].Trip[curT].connectCost;
				    seg[idVeh].Trip[curT].cost -= temp;
				    seg[idVeh].Trip[curT].fitness -= temp;
				    seg[idVeh].Trip[curT].connectCost = 0;
					seg[idVeh].Trip[curT].waitingS = NO_WS;
				}
				else 
				{
					if (seg[idVeh].Trip[curT].assSP != assSP)
					{
                        temp = seg[idVeh].Trip[curT].connectCost;
						seg[idVeh].Trip[curT].cost -= temp;
						seg[idVeh].Trip[curT].fitness -= temp;
						seg[idVeh].Trip[curT].connectCost = 0;
						seg[idVeh].Trip[curT].waitingS1 = NO_WS;
					}
				}
			}
			else if (idTrip ==0) //first delivery trip becomes empty
			{
				//cout<<"first trip becomes empty"<<endl;
				//Don toa:
				for (i=0;i<seg[idVeh].numTrips; i++)
				{
					seg[idVeh].Trip[i] = seg[idVeh].Trip[i+1];
					UpdateTripnum(idVeh,i);
				}
				if (seg[idVeh].Trip[0].Type) 
				{
					seg[idVeh].Trip[0].leaveSP = problem->leaveSP[seg[idVeh].Trip[0].assSP][4]; //load at sTW2
				    seg[idVeh].Trip[0].fitness += (VTWSP * seg[idVeh].Trip[0].vioTWSP);
					seg[idVeh].Trip[0].vioTWSP = 0;
					//UpdateVehicle(idVeh,0, seg[idVeh].Trip[0].assSP, seg[idVeh].Trip[0].leaveSP, varvioCAP);//Quangnn--
				}
				else{
					//UpdateVehicle(idVeh,0, 0, 0, varvioCAP);//Quangnn--
				}
				
			}
			else  //middle delivery trip becomes empty: 6 cases
			{
				//Don toa:
				for (i=idTrip;i<seg[idVeh].numTrips; i++)
				{
					seg[idVeh].Trip[i] = seg[idVeh].Trip[i+1];
					UpdateTripnum(idVeh,i);
				}
				int preT = idTrip - 1;
				int assSPpreT = seg[idVeh].Trip[preT].assSP;
				double cArrTime, varC, varvioTWSP;
				varC = -seg[idVeh].Trip[preT].connectCost;

				if (seg[idVeh].Trip[preT].Type ==0) //preTrip is pickup trip
				{
					if (seg[idVeh].Trip[idTrip].Type ==0) //preTrip is pickup trip and nextTrip is pickup trip
					{
						int firstC_nextT = seg[idVeh].Trip[idTrip].firstCus;
						varC += problem->c[assSPpreT][firstC_nextT];
						seg[idVeh].Trip[preT].waitingS1 = NO_WS;
						seg[idVeh].Trip[preT].connectCost = problem->c[assSPpreT][firstC_nextT];
						seg[idVeh].Trip[preT].cost += varC;
						seg[idVeh].Trip[preT].fitness += varC;
						//UpdateVehicle(idVeh, idTrip, assSPpreT, seg[idVeh].Trip[preT].leaveSP, varvioCAP);//Quangnn--
					}
					else //preTrip is pickup trip and nextTrip is delivery trip
					{
						int assSPnextT = seg[idVeh].Trip[idTrip].assSP;
						cArrTime = seg[idVeh].Trip[preT].leaveSP + problem->c[assSPpreT][assSPnextT];
						varvioTWSP = -seg[idVeh].Trip[idTrip].vioTWSP;
						if (PDSINRANGE(cArrTime, problem->nodeSP[assSPnextT].sTW2, problem->nodeSP[assSPnextT].eTW2))
						{
							varC += problem->c[assSPpreT][assSPnextT];
							seg[idVeh].Trip[preT].waitingS1 = NO_WS;
							seg[idVeh].Trip[preT].connectCost = problem->c[assSPpreT][assSPnextT];
							seg[idVeh].Trip[preT].cost += varC;
							seg[idVeh].Trip[preT].fitness += varC;

							//before delete: go to sp directly: FEA OR INFEASIBLE or through WS
							seg[idVeh].Trip[idTrip].vioTWSP = 0;
							seg[idVeh].Trip[idTrip].fitness += (VTWSP * varvioTWSP);
							seg[idVeh].Trip[idTrip].leaveSP = cArrTime + problem->nodeSP[assSPnextT].load;
							//UpdateVehicle(idVeh, idTrip, assSPnextT, seg[idVeh].Trip[idTrip].leaveSP, varvioCAP);//Quangnn--
						}
						else
						{
							temp = cArrTime - problem->nodeSP[assSPnextT].eTW2;
							if (temp > eps) //too late to go sp directly
							{
								varC += problem->c[assSPpreT][assSPnextT];
								seg[idVeh].Trip[preT].waitingS1 = NO_WS;
								seg[idVeh].Trip[preT].connectCost = problem->c[assSPpreT][assSPnextT];
								seg[idVeh].Trip[preT].cost += varC;
								seg[idVeh].Trip[preT].fitness += varC;
								//before delete: the same -->don't need to update all remaining trips
								varvioTWSP += temp; 
								seg[idVeh].Trip[idTrip].vioTWSP = temp;
								seg[idVeh].Trip[idTrip].fitness += (VTWSP *varvioTWSP);
							}
							else
							{
								double cArrTimeI = seg[idVeh].Trip[preT].leaveSP + problem->disCWSSP[assSPpreT][assSPnextT];
								temp = cArrTimeI - problem->nodeSP[assSPnextT].eTW2;
								if (temp > eps)
								{
									varC += problem->c[assSPpreT][assSPnextT];
									seg[idVeh].Trip[preT].waitingS1 = NO_WS;
									seg[idVeh].Trip[preT].connectCost = problem->c[assSPpreT][assSPnextT];
									seg[idVeh].Trip[preT].cost += varC;
									seg[idVeh].Trip[preT].fitness += varC;

									//before delete: go to sp directly FEA OR INFEA
									temp = problem->nodeSP[assSPnextT].sTW2 - cArrTime;
									varvioTWSP += temp;
									if (seg[idVeh].Trip[idTrip].vioTWSP > eps) //don't need to update all remaining trips
									{
										seg[idVeh].Trip[idTrip].vioTWSP = temp;
										seg[idVeh].Trip[idTrip].fitness += (VTWSP * varvioTWSP);
									}
									else //need to update all remaining trips:
									{
										seg[idVeh].Trip[idTrip].vioTWSP = temp;
										seg[idVeh].Trip[idTrip].fitness += VTWSP * varvioTWSP;
										seg[idVeh].Trip[idTrip].leaveSP = problem->leaveSP[assSPnextT][1]; //load only at eTW2
										//UpdateVehicle(idVeh, idTrip, assSPnextT, seg[idVeh].Trip[idTrip].leaveSP, varvioCAP);//Quangnn--
									}
								}
								else //go through WS:
								{
									varC += problem->disCWSSP[assSPpreT][assSPnextT];
									seg[idVeh].Trip[preT].waitingS1 = problem->CWSSP[assSPpreT][assSPnextT];
									seg[idVeh].Trip[preT].connectCost = problem->disCWSSP[assSPpreT][assSPnextT];
									seg[idVeh].Trip[preT].cost += varC;
									seg[idVeh].Trip[preT].fitness += varC;
									
									seg[idVeh].Trip[idTrip].vioTWSP = 0;
									seg[idVeh].Trip[idTrip].fitness += (VTWSP * varvioTWSP);
									seg[idVeh].Trip[idTrip].leaveSP = PDS_MAX(cArrTimeI, problem->nodeSP[assSPnextT].sTW2) + problem->nodeSP[assSPnextT].load;
									//UpdateVehicle(idVeh, idTrip, assSPnextT, seg[idVeh].Trip[idTrip].leaveSP, varvioCAP);//Quangnn--
								}
							}
						}
					}//end preTrip is pickup trip and nextTrip is delivery trip
				}
				else //preTrip is delivery trip
				{
					int lastCpreT = seg[idVeh].Trip[preT].lastCus;
					if (seg[idVeh].Trip[idTrip].Type) //preTrip is delivery trip, nextTrip is delivery trip
					{
						int assSPnextT = seg[idVeh].Trip[idTrip].assSP;
						varvioTWSP = -seg[idVeh].Trip[idTrip].vioTWSP;
						cArrTime = seg[idVeh].Trip[preT].endS + problem->c[lastCpreT][assSPnextT];
						if (PDSINRANGE(cArrTime, problem->nodeSP[assSPnextT].sTW2, problem->nodeSP[assSPnextT].eTW2))
						{
							seg[idVeh].Trip[preT].connectCost = problem->c[lastCpreT][assSPnextT];
							varC += problem->c[lastCpreT][assSPnextT];
							seg[idVeh].Trip[preT].waitingS = NO_WS;
							seg[idVeh].Trip[preT].cost += varC;
							seg[idVeh].Trip[preT].fitness += varC;

							seg[idVeh].Trip[idTrip].vioTWSP = 0;
							seg[idVeh].Trip[idTrip].fitness += (VTWSP *varvioTWSP);
							//before delete: go to sp directly or through WS:
							seg[idVeh].Trip[idTrip].leaveSP = cArrTime + problem->nodeSP[assSPnextT].load;
							//UpdateVehicle(idVeh, idTrip, assSPnextT, seg[idVeh].Trip[idTrip].leaveSP, varvioCAP);//Quangnn--
						}
						else
						{
							temp = cArrTime - problem->nodeSP[assSPnextT].eTW2;
							if (temp > eps) 
							{
								seg[idVeh].Trip[preT].connectCost = problem->c[lastCpreT][assSPnextT];
								varC += problem->c[lastCpreT][assSPnextT];
								seg[idVeh].Trip[preT].waitingS = NO_WS;
								seg[idVeh].Trip[preT].cost += varC;
								seg[idVeh].Trip[preT].fitness += varC;

								seg[idVeh].Trip[idTrip].vioTWSP = temp;
								varvioTWSP += temp;
								seg[idVeh].Trip[idTrip].fitness += (VTWSP * varvioTWSP);
								//before delete: go to sp directly INFEA TOO --> don't need to update all remaining trips
							}
							else
							{
								double cArrTimeI = seg[idVeh].Trip[preT].endS + problem->disCWSSP[lastCpreT][assSPnextT];
								temp = cArrTimeI - problem->nodeSP[assSPnextT].eTW2;
								if (temp > eps) //too soon to sp directly; too late through WS:
								{
									seg[idVeh].Trip[preT].connectCost = problem->c[lastCpreT][assSPnextT];
									varC += problem->c[lastCpreT][assSPnextT];
									seg[idVeh].Trip[preT].waitingS = NO_WS;
									seg[idVeh].Trip[preT].cost += varC;
									seg[idVeh].Trip[preT].fitness += varC;

									//before delete: to sp directly FEA OR INF or through WS:
									temp = problem->nodeSP[assSPnextT].sTW2 - cArrTime;
									varvioTWSP += temp;
									if (seg[idVeh].Trip[idTrip].vioTWSP > eps) //before also vioTWSP --> don't need to update all remaining trips
									{
										seg[idVeh].Trip[idTrip].vioTWSP = temp;
										seg[idVeh].Trip[idTrip].fitness += (VTWSP * varvioTWSP);
									}
									else //need to update all remaining trips:
									{
										seg[idVeh].Trip[idTrip].vioTWSP = temp;
										seg[idVeh].Trip[idTrip].fitness += (VTWSP * varvioTWSP);
										seg[idVeh].Trip[idTrip].leaveSP = problem->leaveSP[assSPnextT][1]; //load at eTW2
										//UpdateVehicle(idVeh, idTrip, assSPnextT, seg[idVeh].Trip[idTrip].leaveSP, varvioCAP);//Quangnn--
									}
								}
								else //through WS:
								{
									seg[idVeh].Trip[idTrip].connectCost = problem->disCWSSP[lastCpreT][assSPnextT];
									varC += problem->disCWSSP[lastCpreT][assSPnextT];
									seg[idVeh].Trip[preT].waitingS = problem->CWSSP[lastCpreT][assSPnextT];
									seg[idVeh].Trip[preT].cost += varC;
									seg[idVeh].Trip[preT].fitness += varC;

									//before delete: to sp directly FEA or INF or through WS:
									seg[idVeh].Trip[idTrip].vioTWSP = 0;
									seg[idVeh].Trip[idTrip].fitness += (VTWSP * varvioTWSP);
									seg[idVeh].Trip[idTrip].leaveSP = PDS_MAX(cArrTimeI, problem->nodeSP[assSPnextT].sTW2) + problem->nodeSP[assSPnextT].load;
									//UpdateVehicle(idVeh, idTrip, assSPnextT, seg[idVeh].Trip[idTrip].leaveSP, varvioCAP);//Quangnn--
								}
							}
						}
					}
					else //preTrip is delivery trip, nextTrip is pickup trip
					{
						seg[idVeh].Trip[preT].connectCost = problem->c[seg[idVeh].Trip[preT].lastCus][seg[idVeh].Trip[idTrip].firstCus];
						varC += seg[idVeh].Trip[preT].connectCost;
						seg[idVeh].Trip[preT].waitingS = NO_WS;
						seg[idVeh].Trip[preT].cost += varC;
						seg[idVeh].Trip[preT].fitness += varC;
						//UpdateVehicle(idVeh, idTrip, seg[idVeh].Trip[preT].lastCus, seg[idVeh].Trip[preT].endS, varvioCAP);//Quangnn--
					}//end preTrip is delivery trip, nextTrip is pickup trip
				}//end preTrip is delivery trip
		    }//end middle delivery trip becomes empty: 6 cases
	} //end vehicle doesn't become empty
    return 0;
}

void Solution::UpdateTripnum(int idVeh, int idTrip)
{
    int curCus = seg[idVeh].Trip[idTrip].firstCus;
    int numC = seg[idVeh].Trip[idTrip].numCus;
	for (int cc=1;cc<=numC;cc++)
	{
		trip_num[curCus] = idTrip;
		curCus = nextArr[curCus];
	}
}

void Solution::UpdateVehicle(int idVeh, int curT, int preC, double cStartS, int varvioCAP)
{
	int curC, preT, assSP;
	double cArrTime, temp, varvioTWSP, varvioTWC, varcost, varfit;
	int lastTrip = seg[idVeh].numTrips - 1;
	bool stop;

	do
	{
		curC = seg[idVeh].Trip[curT].firstCus;
		varvioTWC = 0;
		if (seg[idVeh].Trip[curT].Type)
		{
			while (curC > 0)
			{
				cArrTime = cStartS + problem->c[preC][curC];
				cStartS = PDS_MAX(cArrTime, problem->node[curC].sTW);
				if (PDSDIF(cStartS, startS[curC])==0) //it means vioTWCus[curC] =0 
				{
					seg[idVeh].Trip[curT].fitness += (VTWCUS * varvioTWC);
					if (curC != seg[idVeh].Trip[curT].firstCus)
						UpdateFBvioTWCus(idVeh, curT, curC);
					seg[idVeh].Trip[curT].vioTWC = FvioTWCus[seg[idVeh].Trip[curT].lastCus];
					seg[idVeh].Trip[curT].fitness += (VTWCUS * varvioTWC);
					if (seg[idVeh].Trip[curT].vioCAP > 0 || seg[idVeh].Trip[curT].vioTWC > eps || seg[idVeh].Trip[curT].vioTWSP > eps)
						seg[idVeh].Trip[curT].feasible = 0;
					else seg[idVeh].Trip[curT].feasible = 1;
					goto Update;
				}
				temp = cStartS - problem->node[curC].eTW;
				if (temp > eps)
				{
					varvioTWC += (temp - vioTWCus[curC]);
					if (vioTWCus[curC] > eps) 
					{
						vioTWCus[curC] = temp;
						seg[idVeh].Trip[curT].fitness += (VTWCUS * varvioTWC);
						UpdateFBvioTWCus(idVeh, curT, curC);
						seg[idVeh].Trip[curT].vioTWC = FvioTWCus[seg[idVeh].Trip[curT].lastCus];
						seg[idVeh].Trip[curT].fitness += (VTWCUS * varvioTWC);
						if (seg[idVeh].Trip[curT].vioCAP > 0 || seg[idVeh].Trip[curT].vioTWC > eps || seg[idVeh].Trip[curT].vioTWSP > eps)
							seg[idVeh].Trip[curT].feasible = 0;
						else seg[idVeh].Trip[curT].feasible = 1;
						goto Update;
					}
					vioTWCus[curC] = temp;
					FvioTWCus[curC] = FvioTWCus[preC] + temp;
					cStartS = problem->node[curC].eTW;
				}
				startS[curC] = cStartS;
				cStartS += problem->node[curC].duration;
				depart[curC] = cStartS;
				preC = curC; curC = nextArr[curC];
			}//end while (curC > 0)
			seg[idVeh].Trip[curT].endS = depart[preC];
			seg[idVeh].Trip[curT].vioTWC += varvioTWC;
			seg[idVeh].Trip[curT].fitness += (VTWCUS * varvioTWC);
			UpdateBvioTWCus(idVeh, curT, preC);

			if (seg[idVeh].Trip[curT].vioTWC > eps || seg[idVeh].Trip[curT].vioCAP > 0 || seg[idVeh].Trip[curT].vioTWSP > eps)
				seg[idVeh].Trip[curT].feasible = 0;
			else seg[idVeh].Trip[curT].feasible = 1;

			if (curT < lastTrip) //not the last trip yet: 
			{
				preT = curT; curT++; //preC now points to the last delivery cus of trip preT
				curC = seg[idVeh].Trip[curT].firstCus;
				if (seg[idVeh].Trip[curT].Type) // del trip - del trip
				{
				    stop = calChangeCONNECTAtSP_DD(preC, idVeh, curT, preT, cStartS);
					if (stop) goto Update;
					preC = seg[idVeh].Trip[curT].assSP; 
				}
				/*else //del trip - pick trip
				{
					curC = seg[idVeh].Trip[curT].firstCus;
				}*/
			}//end if (curT < lastTrip) //not the last delivery trip yet
			else //last delivery trip
				break; //cont = 0; already the last trip
		}
		else //if (seg[idVeh].Trip[curT].Type == 0)
		{
			while (curC > 0)
			{
				cArrTime = cStartS + problem->c[preC][curC];
				cStartS = PDS_MAX(cArrTime, problem->node[curC].sTW);
				if (PDSDIF(cStartS, startS[curC])==0)
				{
					seg[idVeh].Trip[curT].fitness += (VTWCUS * varvioTWC);
					if (curC != seg[idVeh].Trip[curT].firstCus)
						UpdateFBvioTWCus(idVeh, curT, curC);
					seg[idVeh].Trip[curT].vioTWC = FvioTWCus[seg[idVeh].Trip[curT].lastCus];
					seg[idVeh].Trip[curT].fitness += (VTWCUS * varvioTWC);
					if (seg[idVeh].Trip[curT].vioCAP > 0 || seg[idVeh].Trip[curT].vioTWC > eps || seg[idVeh].Trip[curT].vioTWSP > eps)
						seg[idVeh].Trip[curT].feasible = 0;
					else seg[idVeh].Trip[curT].feasible = 1;
					goto Update;
				}
				temp = cStartS - problem->node[curC].eTW;
				if (temp > eps)
				{
					varvioTWC += (temp - vioTWCus[curC]);
					if (vioTWCus[curC] > eps)
					{
						seg[idVeh].Trip[curT].fitness += (VTWCUS * varvioTWC);
						vioTWCus[curC] = temp;
						UpdateFBvioTWCus(idVeh, curT, curC);
						seg[idVeh].Trip[curT].vioTWC = FvioTWCus[seg[idVeh].Trip[curT].lastCus];
						seg[idVeh].Trip[curT].fitness += (VTWCUS * varvioTWC);
						if (seg[idVeh].Trip[curT].vioCAP > 0 || seg[idVeh].Trip[curT].vioTWC > eps || seg[idVeh].Trip[curT].vioTWSP > eps)
							seg[idVeh].Trip[curT].feasible = 0;
						else seg[idVeh].Trip[curT].feasible = 1;

						goto Update;
					}
					vioTWCus[curC] = temp;
					FvioTWCus[curC] = FvioTWCus[preC] + temp;
					cStartS = problem->node[curC].eTW;
				}
				startS[curC] = cStartS;
				cStartS += problem->node[curC].duration;
				depart[curC] = cStartS;
				preC = curC; curC = nextArr[curC];
			} //end while (curC > 0)
			seg[idVeh].Trip[curT].endS = depart[preC];
			seg[idVeh].Trip[curT].vioTWC += varvioTWC;
			seg[idVeh].Trip[curT].fitness += (VTWCUS * varvioTWC);

		    stop = calChangeCONNECTAtSP_PickTrip(preC, idVeh, curT, cStartS);
			if (stop) goto Update;
			if (curT < lastTrip) //not the last pickup trip yet:
			{
				preT = curT; curT++;
				assSP = seg[idVeh].Trip[preT].assSP;
				if (seg[idVeh].Trip[curT].Type) 
				{
					int assSP1 = seg[idVeh].Trip[curT].assSP;
					if (assSP == assSP1) //p-d trip
					{
						cStartS += problem->nodeSP[assSP].load;
						seg[idVeh].Trip[curT].leaveSP = cStartS;
						temp = seg[idVeh].Trip[preT].vioTWSP - seg[idVeh].Trip[curT].vioTWSP;
						seg[idVeh].Trip[curT].vioTWSP = seg[idVeh].Trip[preT].vioTWSP;
						seg[idVeh].Trip[curT].fitness += (VTWSP * temp);
						preC = assSP1;
						curC = seg[idVeh].Trip[curT].firstCus;
					}
					else //p - assSP - assSP1 - d
					{
						stop = calChangeCONNECTAtSP_SPSP(idVeh, curT, preT, cStartS);
						if (stop) goto Update;
						preC = assSP1; curC = seg[idVeh].Trip[curT].firstCus;
					}//end p - assSP - assSP1 - d
				}
				else //if(seg[idVeh].Trip[curT].Type==0): p - p
				{
					preC = assSP;
					curC = seg[idVeh].Trip[curT].firstCus;
				}//end if (seg[idVeh].Trip[curT].Type==0)
			}
			else break; //cont = 0; curT is already the last pickup trip
		}//end trip curT is pickup
	}while (1);
Update:
   varcost = -seg[idVeh].cost;
   varfit = -seg[idVeh].fitness;
   varvioTWC = -seg[idVeh].vioTWC;
   varvioTWSP = -seg[idVeh].vioTWSP;
 
   seg[idVeh].cost = 0; seg[idVeh].fitness = 0;
   seg[idVeh].vioTWC = 0; seg[idVeh].vioTWSP = 0;
   for (int i=0;i<seg[idVeh].numTrips;i++)
   {
	   seg[idVeh].cost += seg[idVeh].Trip[i].cost;
       seg[idVeh].fitness += seg[idVeh].Trip[i].fitness;
	   seg[idVeh].vioTWC += seg[idVeh].Trip[i].vioTWC;
	   seg[idVeh].vioTWSP += seg[idVeh].Trip[i].vioTWSP;
   }
   seg[idVeh].vioCAP += varvioCAP;

   varcost += seg[idVeh].cost; varfit += seg[idVeh].fitness;
   cost += varcost; fitness += varfit;
   varvioTWC += seg[idVeh].vioTWC; varvioTWSP += seg[idVeh].vioTWSP; 
   vioCAP += varvioCAP; vioTWC += varvioTWC; vioTWSP += varvioTWSP;
}

void Solution::UpdateBvioTWCus(int idVeh, int idTrip, int idCus) //when vioTWCus[idCus] is changed
{
	int nextC;
	if (idCus == seg[idVeh].Trip[idTrip].lastCus) 
		BvioTWCus[idCus] = vioTWCus[idCus];
	else
	{
		nextC = nextArr[idCus];
		BvioTWCus[idCus] = BvioTWCus[nextC] + vioTWCus[idCus];
	}
	nextC = idCus;
	int curC = predArr[idCus];
	while (curC > 0)
	{
		BvioTWCus[curC] = BvioTWCus[nextC] + vioTWCus[curC];
		nextC = curC; curC = predArr[curC];
	}
}

void Solution::UpdateFBvioTWCus(int idVeh, int idTrip, int idCus) //when vioTWCus[idCus] is changed
{
	int nextC;
	if (idCus == seg[idVeh].Trip[idTrip].lastCus) 
		BvioTWCus[idCus] = vioTWCus[idCus];
	else
	{
		nextC = nextArr[idCus];
		BvioTWCus[idCus] = BvioTWCus[nextC] + vioTWCus[idCus];
	}
	nextC = idCus;
	int curC = predArr[idCus];
	while (curC > 0)
	{
		BvioTWCus[curC] = BvioTWCus[nextC] + vioTWCus[curC];
		nextC = curC; curC = predArr[curC];
	}

	int preC;
	if (idCus == seg[idVeh].Trip[idTrip].firstCus) FvioTWCus[idCus] = vioTWCus[idCus];
	else
	{
		preC = predArr[idCus];
		FvioTWCus[idCus] = FvioTWCus[preC] + vioTWCus[idCus];
	}
	preC = idCus;
	curC = nextArr[idCus];
	while (curC > 0)
	{
		FvioTWCus[curC] = FvioTWCus[preC] + vioTWCus[curC];
		preC = curC; curC = nextArr[curC];
	}
}

void Solution::UpdateArray(int idVeh)
{
		UpdateDeleteArray(idVeh); 
		UpdateInsertArray(idVeh);
		UpdateMoveCusOneTripArray(idVeh); 
		UpdateExchangeArray(idVeh);
		UpdatetwoOPTstarArray(idVeh);
}

void Solution::UpdateDeleteArray(int idVeh)
{
	int	lastT = seg[idVeh].numTrips-1; 
	int numC, assSP;
	int vioCapNEW, vioCapOLD, capOLD, deletednode, idpre, pre_deletednode, nextC, next1;
	double vioTWCOLD, vioTWCNEW, cArrTime, cStartS, temp, cArrTimeI;


		if (lastT==0) //vehicle with only one trip
		{
            numC = seg[idVeh].Trip[0].numCus;
			if (numC ==1) //after delete: vehicle empty
			{
				deletednode = seg[idVeh].Trip[0].firstCus;
				if (seg[idVeh].Trip[0].Type) //delivery trip:
				{
					deleteCus[deletednode]->var_vioCAP = 0;
					deleteCus[deletednode]->var_vioTWC = -seg[idVeh].Trip[0].vioTWC;
					deleteCus[deletednode]->var_vioTWSP = 0;
					deleteCus[deletednode]->var_cost = -seg[idVeh].Trip[0].cost;
					deleteCus[deletednode]->empty = 1;
				}
				else //pick up trip:
				{
					deleteCus[deletednode]->var_vioCAP = 0;
					deleteCus[deletednode]->var_vioTWSP = 0;
					deleteCus[deletednode]->var_cost = -seg[idVeh].Trip[0].cost;
					deleteCus[deletednode]->var_vioTWC = 0;
					deleteCus[deletednode]->empty = 1;
					deleteCus[deletednode]->atIT = IT;
				}
			}
			else //vehicle with >=2 customers:
			{
				assSP = seg[idVeh].Trip[0].assSP; 
				deletednode = seg[idVeh].Trip[0].firstCus;
				capOLD = seg[idVeh].Trip[0].capacity;
			    vioCapOLD = seg[idVeh].Trip[0].vioCAP;
			    vioTWCOLD = seg[idVeh].Trip[0].vioTWC; vioTWCNEW = 0;
				if (seg[idVeh].Trip[0].Type) //is delivery trip: with >= 2 customers
				{
					idpre = assSP;cStartS = seg[idVeh].Trip[0].leaveSP;
					while (deletednode >0)
					{
						deleteCus[deletednode]->empty = 0;
				        pre_deletednode = idpre;
						//1. update vioCAP
						vioCapNEW = PDS_MAX(capOLD - problem->node[deletednode].capacity- problem->Q,0);
					    deleteCus[deletednode]->var_vioCAP = vioCapNEW - vioCapOLD;
					   //2.update vioTWC at deleted node:
						nextC = nextArr[deletednode]; 
						while (nextC > 0)
						{
							cArrTime = cStartS + problem->c[idpre][nextC];//arrTime at customer nextC
							cStartS = PDS_MAX(cArrTime, problem->node[nextC].sTW);
							temp = cStartS - problem->node[nextC].eTW;
							if (temp > eps) //if deletion causes vioTW --> vioTW at remaining customers are the same 
							{
								vioTWCNEW += temp;
								vioTWCNEW += (BvioTWCus[nextC] - vioTWCus[nextC]);
								break;
							}
							idpre = nextC; cStartS += problem->node[idpre].duration; 
							nextC = nextArr[nextC];
						}
						deleteCus[deletednode]->var_vioTWC = vioTWCNEW - vioTWCOLD;   
						deleteCus[deletednode]->var_vioTWSP = 0;
						int next1 = nextArr[deletednode];
						if (next1 >0) //not delete the last cus:
						    deleteCus[deletednode]->var_cost = problem->c[pre_deletednode][next1] - (problem->c[pre_deletednode][deletednode] + problem->c[deletednode][next1]);
						else //delete the last cus:
							deleteCus[deletednode]->var_cost = problem->c[pre_deletednode][0] - (problem->c[pre_deletednode][deletednode] + problem->c[deletednode][0]);
						//new deletednode:
						cStartS = depart[deletednode]; vioTWCNEW = FvioTWCus[deletednode];
						idpre = deletednode; deletednode = next1;
					}
				}
				else //is pickup trip: with >=2 customers:
				{
					//1. Delete the first pick Cus:
					deleteCus[deletednode]->empty = 0;
					//1.1. Update vioCAP
					vioCapNEW = PDS_MAX(capOLD - problem->node[deletednode].capacity - problem->Q,0);
					deleteCus[deletednode]->var_vioCAP = vioCapNEW - vioCapOLD;
				
					idpre = nextArr[deletednode]; cStartS = problem->node[idpre].sTW + problem->node[idpre].duration;
					deleteCus[deletednode]->var_cost = problem->c[0][idpre] - (problem->c[0][deletednode] + problem->c[deletednode][idpre]);
				
					//1.3 Update vioTWC at deleted node:
					nextC = nextArr[idpre];
					while (nextC > 0)
					{
						cArrTime = cStartS + problem->c[idpre][nextC]; //arrTime at customer nextC
						cStartS = PDS_MAX(cArrTime, problem->node[nextC].sTW);
						temp = cStartS - problem->node[nextC].eTW;
						if (temp > eps)
						{
							vioTWCNEW += temp;
							vioTWCNEW += (BvioTWCus[nextC] - vioTWCus[nextC]);
							deleteCus[deletednode]->var_vioTWSP = 0;
							break;
						}
						idpre = nextC; cStartS += problem->node[idpre].duration; 
						nextC = nextArr[nextC];
					}
					deleteCus[deletednode]->var_vioTWC = vioTWCNEW - vioTWCOLD;
					if (nextC < 0) // arrival time at sp may change
					{
						cArrTime = cStartS + problem->c[idpre][assSP]; //idpre is now the last customer
						if (PDSINRANGE(cArrTime, problem->nodeSP[assSP].sTW1, problem->nodeSP[assSP].eTW1))
							deleteCus[deletednode]->var_vioTWSP = -seg[idVeh].Trip[0].vioTWSP;
						else
						{
							temp = cArrTime - problem->nodeSP[assSP].eTW1;
							if (temp > eps) //too late to go sp directly: -->before delete also
								deleteCus[deletednode]->var_vioTWSP = temp - seg[idVeh].Trip[0].vioTWSP;
							else
							{
								cArrTimeI = cStartS + problem->disCWSSP[idpre][assSP]; //go through WS:
								temp = cArrTimeI - problem->nodeSP[assSP].eTW1;
								if (temp > eps) //too soon for direct, too late for indirect --> vioTWSP and go direct: before may go to sp directly OR same as now
								{
									deleteCus[deletednode]->var_vioTWSP = (problem->nodeSP[assSP].sTW1 - cArrTime) - seg[idVeh].Trip[0].vioTWSP;
								    //if (seg[idVeh].Trip[0].waitingS != NO_WS) //before go through WS: NO; CANNOT HAPPENED
								}
								else //now go through WS:
								{
									deleteCus[deletednode]->var_vioTWSP = - seg[idVeh].Trip[0].vioTWSP;
									if (seg[idVeh].Trip[0].waitingS == NO_WS) //before go to sp directly:
										deleteCus[deletednode]->var_cost += (problem->disCWSSP[idpre][assSP] - problem->c[idpre][assSP]);
								}
							}
						}
					}
				    //2. Delete the middle pickup cus:
					idpre = deletednode; 
					deletednode = nextArr[deletednode];
					do
					{
						deleteCus[deletednode]->empty = 0;
				        pre_deletednode = idpre;
						//1. update vioCAP
						vioCapNEW = PDS_MAX(capOLD - problem->node[deletednode].capacity- problem->Q,0);
					    deleteCus[deletednode]->var_vioCAP = vioCapNEW - vioCapOLD;
					   //2.update vioTWC at deleted node:
						cStartS = depart[idpre];
						vioTWCNEW = FvioTWCus[idpre];
						nextC = nextArr[deletednode]; 
						while (nextC > 0)
						{
							cArrTime = cStartS + problem->c[idpre][nextC];//arrTime at customer nextC
							cStartS = PDS_MAX(cArrTime, problem->node[nextC].sTW);
							temp = cStartS - problem->node[nextC].eTW;
							if (temp > eps) //if deletion causes vioTW --> vioTW at remaining customers are the same 
							{
								vioTWCNEW += temp;
								vioTWCNEW += (BvioTWCus[nextC] - vioTWCus[nextC]);
								deleteCus[deletednode]->var_vioTWSP = 0;
								next1 = nextArr[deletednode];
								deleteCus[deletednode]->var_cost = problem->c[pre_deletednode][next1] - (problem->c[pre_deletednode][deletednode] + problem->c[deletednode][next1]);
								break;
							}
							idpre = nextC; cStartS += problem->node[idpre].duration; 
							nextC = nextArr[nextC];
						}
						deleteCus[deletednode]->var_vioTWC = vioTWCNEW - vioTWCOLD;  
						if (nextC < 0) //arrival time at sp may change OR delete the last cus:
						{
							cArrTime = cStartS + problem->c[idpre][assSP]; //idpre is now the last customer
							if (PDSINRANGE(cArrTime, problem->nodeSP[assSP].sTW1, problem->nodeSP[assSP].eTW1))
							{
								deleteCus[deletednode]->var_vioTWSP = -seg[idVeh].Trip[0].vioTWSP;
							    next1 = nextArr[deletednode];
								if (next1 > 0)
									deleteCus[deletednode]->var_cost = problem->c[pre_deletednode][next1] - (problem->c[pre_deletednode][deletednode] + problem->c[deletednode][next1]);
								else //delete the last cus: now go to sp directly, before also:
									deleteCus[deletednode]->var_cost = problem->c[idpre][assSP] - (problem->c[idpre][deletednode] + problem->c[deletednode][assSP]); 
							}
							else
							{
								temp = cArrTime - problem->nodeSP[assSP].eTW1;
								if (temp > eps) // too late to go sp directly --> before delete also:
								{
									deleteCus[deletednode]->var_vioTWSP = temp - seg[idVeh].Trip[0].vioTWSP;
									next1 = nextArr[deletednode];
									if (next1 > 0)
										deleteCus[deletednode]->var_cost = problem->c[pre_deletednode][next1] - (problem->c[pre_deletednode][deletednode] + problem->c[deletednode][next1]);
									else //delete the last cus: now too late to go to sp directly, before also:
										deleteCus[deletednode]->var_cost = problem->c[idpre][assSP] - (problem->c[idpre][deletednode] + problem->c[deletednode][assSP]); 
								}
								else
								{
									cArrTimeI = cStartS + problem->disCWSSP[idpre][assSP]; //go through WS:
									temp = cArrTimeI - problem->nodeSP[assSP].eTW1;
									if (temp > eps) //too soon for direct, too late for indirect --> vioTWSP and go direct ==> before: go to sp directly feasibility OR the SAME
									{
										deleteCus[deletednode]->var_vioTWSP = (problem->nodeSP[assSP].sTW1 - cArrTime) - seg[idVeh].Trip[0].vioTWSP;
										next1 = nextArr[deletednode];
										if (next1 > 0)
											deleteCus[deletednode]->var_cost = problem->c[pre_deletednode][next1] - (problem->c[pre_deletednode][deletednode] + problem->c[deletednode][next1]);
										else //delete the last cus: before go to sp directly or the SAME
											deleteCus[deletednode]->var_cost = problem->c[idpre][assSP] - (problem->c[idpre][deletednode] + problem->c[deletednode][assSP]);
									}
									else //go through WS:
									{
										deleteCus[deletednode]->var_vioTWSP = - seg[idVeh].Trip[0].vioTWSP;
										next1 = nextArr[deletednode];
										if (next1 > 0)
										{
											deleteCus[deletednode]->var_cost = problem->c[pre_deletednode][next1] - (problem->c[pre_deletednode][deletednode] + problem->c[deletednode][next1]);
											if (seg[idVeh].Trip[0].waitingS == NO_WS) //before go to sp directly
												deleteCus[deletednode]->var_cost += (problem->disCWSSP[idpre][assSP] - problem->c[idpre][assSP]);
										}
										else //delete the last cus:
										{
											if (seg[idVeh].Trip[0].waitingS == NO_WS) //now go through WS, before go to sp directly
												deleteCus[deletednode]->var_cost = problem->disCWSSP[idpre][assSP] - (problem->c[idpre][deletednode] + problem->c[deletednode][assSP]);
											else // now go through WS, before also:
												deleteCus[deletednode]->var_cost = problem->disCWSSP[idpre][assSP] - (problem->c[idpre][deletednode] + problem->disCWSSP[deletednode][assSP]);

										}
									}
								}
							}
						}
     					//new deletednode:
						idpre = deletednode; deletednode = next1;
					}while (deletednode > 0);
				}//end is pickup trip: with >=2 customers: vehicle with only one pickup trip with >= 2 customers
			}
		}
		else //vehicle with more than one trip:
		{
			  int numC = seg[idVeh].Trip[0].numCus;
			  if (seg[idVeh].Trip[0].Type)
			  {
				  if (numC == 1) Update_deleteCusArrayD_FirstTrip_Empty(idVeh);
				  else Update_deleteCusArrayD_FirstMiddleTrip(idVeh, 0);
			  }
			  else
			  {
				  if (numC == 1) Update_deleteCusArrayP_FirstTrip_Empty(idVeh);
				  else Update_deleteCusArrayP_FirstMiddleTrip(idVeh, 0);
			  }

			  for (int idTrip = 1; idTrip < lastT; idTrip++)
			  {
				  numC = seg[idVeh].Trip[idTrip].numCus;
				  if (seg[idVeh].Trip[idTrip].Type)
				  {
					  if (numC == 1) Update_deleteCusArrayD_MiddleTrip_Empty(idVeh, idTrip);
					  else Update_deleteCusArrayD_FirstMiddleTrip(idVeh, idTrip);
				  }
				  else
				  {
					  if (numC == 1) Update_deleteCusArrayP_MiddleTrip_Empty(idVeh, idTrip);
					  else Update_deleteCusArrayP_FirstMiddleTrip(idVeh, idTrip);
				  }
			  }

			  numC = seg[idVeh].Trip[lastT].numCus;
			  if (seg[idVeh].Trip[lastT].Type)
			  {
				  if (numC == 1) Update_deleteCusArrayD_LastTrip_Empty(idVeh, lastT);
				  else Update_deleteCusArrayD_LastTrip(idVeh, lastT);
			  }
			  else
			  {
				  if (numC == 1) Update_deleteCusArrayP_LastTrip_Empty(idVeh, lastT);
				  else Update_deleteCusArrayP_LastTrip(idVeh, lastT);
			  }
		} //end vehicle with more that one trip


}

void Solution::UpdateInsertArray(int idVeh)
{
    //2nd Transform: Insert customers:
    //cout<<"2. Insert customers between trips: "<<endl;
    int i,idTrip, nextT, k, curC, nextC;
	double cStartS;


	//2.1 Insert delivery customers:
	int lastT = seg[idVeh].numTrips - 1;
	for (idTrip = 0;idTrip < lastT;idTrip++)
	{
		curC = seg[idVeh].Trip[idTrip].firstCus;
		nextC = nextArr[curC];
		nextT = idTrip + 1;
		if (seg[idVeh].Trip[idTrip].Type)
		{
			if (seg[idVeh].Trip[nextT].Type) //idTrip is delivery trip, nextT is delivery trip
			{
				while (nextC > 0)
				{
					for (k=0; k < problem->node[curC].neighborSize; k++)
					{
						if (nextArr[curC] != problem->node[curC].neighborNode[k].id)
						{
							//calculate: insert neighbor #k after curC:
							cal_InsertCusDIAfterJ_NotLastC_NextTripD(curC, k, idVeh, idTrip);
						}
						//else //neighbor k is already after curC 
					}
					curC = nextC; nextC = nextArr[curC];
				}
				//curC now points to the last cus of delivery trip, nextT is delivery trip
				for (k=0; k < problem->node[curC].neighborSize; k++)
				{
					if (nextArr[curC] != problem->node[curC].neighborNode[k].id)
					{
						//calculate: insert neighbor #k after curC:
						cal_InsertCusDIAfterJ_LastC_NextTripD(curC, k, idVeh, idTrip);
					}
					//else //neighbor k is already after curC 
				}
			}
			else //idTrip is delivery trip, nextT is pickup trip
			{
				while (nextC > 0)
				{
					for (k=0; k < problem->node[curC].neighborSize; k++)
					{
						if (nextArr[curC] != problem->node[curC].neighborNode[k].id)
						{
							//calculate: insert neighbor #k after curC:
							cal_InsertCusDIAfterJ_NotLastC_NextTripP(curC,k,idVeh, idTrip);
						}
						//else //neighbor k is already after curC
					}
					curC = nextC; nextC = nextArr[curC];
				}
				//curC now points to the last cus
				for (k=0; k < problem->node[curC].neighborSize; k++)
				{
					if (nextArr[curC] != problem->node[curC].neighborNode[k].id)
					{
						//calculate: insert neighbor #k after curC:
						cal_InsertCusDIAfterJ_LastC_NextTripP(curC,k,idVeh, idTrip);
					}
					//else //neighbor k is already after curC
				}
			}//end idTrip is delivery trip, nextT is pickup trip
		}
		else //idTrip is pickup trip
		{
			if (seg[idVeh].Trip[nextT].Type) //idTrip is pickup, nextT is delivery
			{
					if (seg[idVeh].Trip[idTrip].assSP == seg[idVeh].Trip[nextT].assSP) //curC is the not last pickup customer, nextTrip is delivery trip, sameSP
					{
						while (nextC > 0)
						{
							for (k=0; k < problem->node[curC].neighborSize; k++)
							{
								i = problem->node[curC].neighborNode[k].id;
								if (nextArr[curC] != i)
								{
								   cal_InsertCusPIAfterJ_NotLastC_NextTripD_SameSP(curC, i, idVeh, idTrip, insertCus[curC][k]->var_vioCAP, insertCus[curC][k]->var_cost, insertCus[curC][k]->var_vioTWC, insertCus[curC][k]->var_vioTWSP);
								}
								//else //neighbor k is already after curC
							}
							curC = nextC; nextC = nextArr[curC];
						}
						//curC now points to the last cus
						for (k=0; k < problem->node[curC].neighborSize; k++)
						{
							i = problem->node[curC].neighborNode[k].id;
							if (nextArr[curC] != i)
							{
							   cal_InsertCusPIAfterJ_LastC_NextTripD_SameSP(curC, i, idVeh, idTrip, insertCus[curC][k]->var_vioCAP, insertCus[curC][k]->var_cost, insertCus[curC][k]->var_vioTWC, insertCus[curC][k]->var_vioTWSP);
							}
							//else //neighbor k is already after curC
						}
					}
					else //curC is not the last pickup customer, nextTrip is delivery trip, difSP
					{
						while (nextC > 0)
						{
							for (k=0; k < problem->node[curC].neighborSize; k++)
							{
								i = problem->node[curC].neighborNode[k].id;
								if (nextArr[curC] != i)
								{
								   cal_InsertCusPIAfterJ_NotLastC_NextTripD_DifSP(curC, i, idVeh, idTrip, insertCus[curC][k]->var_vioCAP, insertCus[curC][k]->var_cost, insertCus[curC][k]->var_vioTWC, insertCus[curC][k]->var_vioTWSP);
								}
								//else //neighbor k is already after curC
							}
							curC = nextC; nextC = nextArr[curC];
						}
						//curC now points to the last cus:
						for (k=0; k < problem->node[curC].neighborSize; k++)
						{
							i = problem->node[curC].neighborNode[k].id;
							if (nextArr[curC] != i)
							{
							   cal_InsertCusPIAfterJ_LastC_NextTripD_DifSP(curC, i, idVeh, idTrip, insertCus[curC][k]->var_vioCAP, insertCus[curC][k]->var_cost, insertCus[curC][k]->var_vioTWC, insertCus[curC][k]->var_vioTWSP);
							}
							//else //neighbor k is already after curC
						}
					}
			}//end idTrip is pickup, nextT is delivery trip
			else //idTrip is pickup, nextT is pickup
			{
				while (nextC > 0)
				{
					for (k=0; k < problem->node[curC].neighborSize; k++)
					{
						i = problem->node[curC].neighborNode[k].id;
						if (nextArr[curC] != i)
						{
						   cal_InsertCusPIAfterJ_NotLastC_NextTripP(curC, i, idVeh, idTrip, insertCus[curC][k]->var_vioCAP, insertCus[curC][k]->var_cost, insertCus[curC][k]->var_vioTWC, insertCus[curC][k]->var_vioTWSP);
						}
						//else //neighbor k is already after curC
					}
					curC = nextC; nextC = nextArr[curC];
				}
				//curC now points to the last cus
				for (k=0; k < problem->node[curC].neighborSize; k++)
				{
					if (nextArr[curC] != problem->node[curC].neighborNode[k].id)
					{
						//calculate: insert neighbor #k after curC:
					   cal_InsertCusPIAfterJ_LastC_NextTripP(curC, i, idVeh, idTrip, insertCus[curC][k]->var_vioCAP, insertCus[curC][k]->var_cost, insertCus[curC][k]->var_vioTWC, insertCus[curC][k]->var_vioTWSP);
					}
					//else //neighbor k is already after curC
				}
			}//end idTrip is pickup, nextT is pickup
		}//idTrip is pickup trip

	}

	curC = seg[idVeh].Trip[lastT].firstCus;
	nextC = nextArr[curC];
	if (seg[idVeh].Trip[lastT].Type) //LAST TRIP IS delivery trip
	{
		while (nextC > 0)
		{
			for (k=0; k < problem->node[curC].neighborSize; k++)
			{
				if (nextArr[curC] != problem->node[curC].neighborNode[k].id)
				{
					//calculate: insert neighbor #k after curC:
					cal_InsertCusDIAfterJ_NotLastC_LastTrip(curC, k, idVeh, idTrip);
				}
				//else //neighbor #k is already after curC 
			}
			curC = nextC; nextC = nextArr[curC];
		}
		//curC now points to the last cus:
		for (k=0; k < problem->node[curC].neighborSize; k++)
		{
			if (nextArr[curC] != problem->node[curC].neighborNode[k].id)
			{
				//calculate: insert neighbor #k after curC:
				cal_InsertCusDIAfterJ_LastC_LastTrip(curC, k, idVeh, idTrip);
			}
			//else //neighbor #k is already after curC 
		}
	}
	else //LAST TRIP IS pickup trip:
	{
		while (nextC > 0)
		{
			for (k=0; k < problem->node[curC].neighborSize; k++)
			{
				i = problem->node[curC].neighborNode[k].id;
				if (nextArr[curC] != i)
				{
					SUBcal_InsertCusPIAfterJ_NotLastC(curC, i, idVeh, idTrip, insertCus[curC][k]->var_vioCAP, insertCus[curC][k]->var_cost, insertCus[curC][k]->var_vioTWC, insertCus[curC][k]->var_vioTWSP, cStartS);
				}
				//else //neighbor k is already after curC
			}
			curC = nextC; nextC = nextArr[curC];
		}
		//curC now points to the last cus:
		for (k=0; k < problem->node[curC].neighborSize; k++)
		{
			i = problem->node[curC].neighborNode[k].id;
			if (nextArr[curC] != i)
			{
				SUBcal_InsertCusPIAfterJ_LastC(curC, i, idVeh, idTrip, insertCus[curC][k]->var_vioCAP, insertCus[curC][k]->var_cost, insertCus[curC][k]->var_vioTWC, insertCus[curC][k]->var_vioTWSP, cStartS);
			}
			//else //neighbor k is already after curC
		}
	}//end LAST TRIP IS pickup trip
}

void Solution::UpdateMoveCusOneTripArray(int idVeh)
{
	int lastT = seg[idVeh].numTrips - 1;
	int idTrip, nextT, curC, numC, curC1,j,j1,k;
	double cStartS;

	for (idTrip = 0; idTrip < lastT; idTrip++)
	{
		nextT = idTrip + 1;
		curC = seg[idVeh].Trip[idTrip].firstCus;
		numC = seg[idVeh].Trip[idTrip].numCus;
		if (seg[idVeh].Trip[idTrip].Type) //idTrip is delivery trip:
		{
			if (seg[idVeh].Trip[nextT].Type) //idTrip is delivery trip, nextTrip is delivery trip
			{
				for (j=1; j<numC; j++)
				{
					curC1 = nextArr[curC];
					for (j1=j+2;j1<=numC;j1++)
					{
						curC1 = nextArr[curC1];
						k = problem->node[curC1].neighborOF[curC];
						if (k != -1) //node curC1 is neighbor of curC
						   cal_MoveCusDIAfterJ_oneTrip_NextTripD(curC,k, idVeh, idTrip); //calculate: move neighbor #k after curC:
					}
					curC1 = curC;
					for (j1=j-1; j1>=1; j1--)
					{
						curC1 = predArr[curC1];
						k = problem->node[curC1].neighborOF[curC];
						if (k != -1) //node curC1 is neighbor of curC
						   cal_MoveCusDIAfterJ_oneTrip_NextTripD(curC,k, idVeh, idTrip); //calculate: move neighbor #k after curC:
					}
					curC = nextArr[curC];
				}
				//curC now points to the last customer
				curC1 = seg[idVeh].Trip[idTrip].firstCus;
				for (j=1;j<numC;j++)
				{
					k = problem->node[curC1].neighborOF[curC];
					if (k != -1) //node curC1 is neighbor of curC
					   cal_MoveCusDIAfterJ_oneTrip_NextTripD(curC,k, idVeh, idTrip); //calculate: move neighbor #k after curC
					curC1 = nextArr[curC1];
				}
			}
			else //idTrip is delivery trip, nextTrip is pickup trip
			{
				for (j=1; j<numC; j++)
				{
					curC1 = nextArr[curC];
					for (j1=j+2;j1<=numC;j1++)
					{
						curC1 = nextArr[curC1];
						k = problem->node[curC1].neighborOF[curC];
						if (k != -1) //node curC1 is neighbor of curC
						   cal_MoveCusDIAfterJ_oneTrip_NextTripP(curC,k, idVeh, idTrip); //calculate: move neighbor #k after curC:
					}
					curC1 = curC;
					for (j1=j-1; j1>=1; j1--)
					{
						curC1 = predArr[curC1];
						k = problem->node[curC1].neighborOF[curC];
						if (k != -1) //node curC1 is neighbor of curC
						   cal_MoveCusDIAfterJ_oneTrip_NextTripP(curC,k, idVeh, idTrip); //calculate: move neighbor #k after curC:
					}
					curC = nextArr[curC];
				}
				//curC now points to the last customer
				curC1 = seg[idVeh].Trip[idTrip].firstCus;
				for (j=1;j<numC;j++)
				{
					k = problem->node[curC1].neighborOF[curC];
					if (k != -1) //node curC1 is neighbor of curC
					   cal_MoveCusDIAfterJ_oneTrip_NextTripP(curC,k, idVeh, idTrip); //calculate: move neighbor #k after curC
					curC1 = nextArr[curC1];
				}
			}//end idTrip is delivery trip, nextTrip is pickup trip
		}
		else //idTrip is pickup trip
		{
			if (seg[idVeh].Trip[nextT].Type)
			{
				if (seg[idVeh].Trip[idTrip].assSP == seg[idVeh].Trip[nextT].assSP)
				{
						for (j=1; j<numC; j++)
						{
							curC1 = nextArr[curC];
							for (j1=j+2;j1<=numC;j1++)
							{
								curC1 = nextArr[curC1];
								k = problem->node[curC1].neighborOF[curC];
								if (k != -1){ //node curC1 is neighbor of curC
									//Quangnn--
									//cal_MoveCusPIAfterJ_oneTrip_NextTripD_SameSP(curC, curC1, idVeh, idTrip, moveCusOneTrip[curC][k]->var_cost, moveCusOneTrip[curC][k]->var_vioTWC, moveCusOneTrip[curC][k]->var_vioTWSP);
								}
							}
							curC1 = curC;
							for (j1=j-1; j1>=1; j1--)
							{
								curC1 = predArr[curC1];
								k = problem->node[curC1].neighborOF[curC];
								if (k != -1){ //node curC1 is neighbor of curC
									//Quangnn--
									//cal_MoveCusPIAfterJ_oneTrip_NextTripD_SameSP(curC, curC1, idVeh, idTrip, moveCusOneTrip[curC][k]->var_cost, moveCusOneTrip[curC][k]->var_vioTWC, moveCusOneTrip[curC][k]->var_vioTWSP);
								}
							}
							curC = nextArr[curC];
						}
						//curC now points to the last customer
						curC1 = seg[idVeh].Trip[idTrip].firstCus;
						for (j=1;j<numC;j++)
						{
							k = problem->node[curC1].neighborOF[curC];
							if (k != -1){ //node curC1 is neighbor of curC
								//Quangnn--
								//cal_MoveCusPIAfterJ_oneTrip_NextTripD_SameSP(curC, curC1, idVeh, idTrip, moveCusOneTrip[curC][k]->var_cost, moveCusOneTrip[curC][k]->var_vioTWC, moveCusOneTrip[curC][k]->var_vioTWSP);
							}
							curC1 = nextArr[curC1];
						}

				}
				else //idTrip is pickup, nextTrip is delivery, dif sp
				{
						for (j=1; j<numC; j++)
						{
							curC1 = nextArr[curC];
							for (j1=j+2;j1<=numC;j1++)
							{
								curC1 = nextArr[curC1];
								k = problem->node[curC1].neighborOF[curC];
								if (k != -1){ //node curC1 is neighbor of curC
									//Quangnn--
									//cal_MoveCusPIAfterJ_oneTrip_NextTripD_DifSP(curC, curC1, idVeh, idTrip, moveCusOneTrip[curC][k]->var_cost, moveCusOneTrip[curC][k]->var_vioTWC, moveCusOneTrip[curC][k]->var_vioTWSP);
								}
							}
							curC1 = curC;
							for (j1=j-1; j1>=1; j1--)
							{
								curC1 = predArr[curC1];
								k = problem->node[curC1].neighborOF[curC];
								if (k != -1){ //node curC1 is neighbor of curC
									//Quangnn--
									//cal_MoveCusPIAfterJ_oneTrip_NextTripD_DifSP(curC, curC1, idVeh, idTrip, moveCusOneTrip[curC][k]->var_cost, moveCusOneTrip[curC][k]->var_vioTWC, moveCusOneTrip[curC][k]->var_vioTWSP);
								}
							}
							curC = nextArr[curC];
						}
						//curC now points to the last customer
						curC1 = seg[idVeh].Trip[idTrip].firstCus;
						for (j=1;j<numC;j++)
						{
							k = problem->node[curC1].neighborOF[curC];
							if (k != -1){ //node curC1 is neighbor of curC
								//Quangnn--
								//cal_MoveCusPIAfterJ_oneTrip_NextTripD_DifSP(curC, curC1, idVeh, idTrip, moveCusOneTrip[curC][k]->var_cost, moveCusOneTrip[curC][k]->var_vioTWC, moveCusOneTrip[curC][k]->var_vioTWSP);
							}
							curC1 = nextArr[curC1];
						}
				}//end idTrip is pickup, nextTrip is delivery, dif sp
			}
			else //idTrip is pickup, nextT is pickup
			{
				for (j=1; j<numC; j++)
				{
					curC1 = nextArr[curC];
					for (j1=j+2;j1<=numC;j1++)
					{
						curC1 = nextArr[curC1];
						k = problem->node[curC1].neighborOF[curC];
						if (k != -1){ //node curC1 is neighbor of curC
							//Quangnn--
							//cal_MoveCusPIAfterJ_oneTrip_NextTripP(curC, curC1, idVeh, idTrip, moveCusOneTrip[curC][k]->var_cost, moveCusOneTrip[curC][k]->var_vioTWC, moveCusOneTrip[curC][k]->var_vioTWSP);
						}
					}
					curC1 = curC;
					for (j1=j-1; j1>=1; j1--)
					{
						curC1 = predArr[curC1];
						k = problem->node[curC1].neighborOF[curC];
						if (k != -1){ //node curC1 is neighbor of curC
							//Quangnn--
							//cal_MoveCusPIAfterJ_oneTrip_NextTripP(curC, curC1, idVeh, idTrip, moveCusOneTrip[curC][k]->var_cost, moveCusOneTrip[curC][k]->var_vioTWC, moveCusOneTrip[curC][k]->var_vioTWSP);
						}
					}
					curC = nextArr[curC];
				}
				//curC now points to the last customer
				curC1 = seg[idVeh].Trip[idTrip].firstCus;
				for (j=1;j<numC;j++)
				{
					k = problem->node[curC1].neighborOF[curC];
					if (k != -1){ //node curC1 is neighbor of curC
						//Quangnn--
						//cal_MoveCusPIAfterJ_oneTrip_NextTripP(curC, curC1, idVeh, idTrip, moveCusOneTrip[curC][k]->var_cost, moveCusOneTrip[curC][k]->var_vioTWC, moveCusOneTrip[curC][k]->var_vioTWSP);
					}
					curC1 = nextArr[curC1];
				}
			}//end idTrip is pickup, nextT is pickup
		}//end idTrip is pickup trip
	}

	//lastTrip:
	curC = seg[idVeh].Trip[lastT].firstCus;
	numC = seg[idVeh].Trip[lastT].numCus;
	if (seg[idVeh].Trip[lastT].Type)
	{
		for (j=1; j<numC; j++)
		{
			curC1 = nextArr[curC];
			for (j1=j+2;j1<=numC;j1++)
			{
				curC1 = nextArr[curC1];
				k = problem->node[curC1].neighborOF[curC];
				if (k != -1) //node curC1 is neighbor of curC
				   cal_MoveCusDIAfterJ_oneTrip_LastTrip(curC, k, idVeh, idTrip); //calculate: move neighbor #k after curC:
			}
			curC1 = curC;
			for (j1=j-1; j1>=1; j1--)
			{
				curC1 = predArr[curC1];
				k = problem->node[curC1].neighborOF[curC];
				if (k != -1) //node curC1 is neighbor of curC
				   cal_MoveCusDIAfterJ_oneTrip_LastTrip(curC, k, idVeh, idTrip); //calculate: move neighbor #k after curC:
			}
			curC = nextArr[curC];
		}
		//curC now points to the last customer
		curC1 = seg[idVeh].Trip[idTrip].firstCus;
		for (j=1;j<numC;j++)
		{
			k = problem->node[curC1].neighborOF[curC];
			if (k != -1) //node curC1 is neighbor of curC
			   cal_MoveCusDIAfterJ_oneTrip_LastTrip(curC, k, idVeh, idTrip); //calculate: move neighbor #k after curC:
            curC1 = nextArr[curC1];
		}
	}
	else //lastT is pickup trip
	{
		for (j=1; j<numC; j++)
		{
			curC1 = nextArr[curC];
			for (j1=j+2;j1<=numC;j1++)
			{
				curC1 = nextArr[curC1];
				k = problem->node[curC1].neighborOF[curC];
				if (k != -1){ //node curC1 is neighbor of curC
					//Quangnn--
					//SUBcal_MoveCusPIAfterJ_oneTrip(curC, curC1, idVeh, idTrip, moveCusOneTrip[curC][k]->var_cost, moveCusOneTrip[curC][k]->var_vioTWC, moveCusOneTrip[curC][k]->var_vioTWSP, cStartS);
				}
			}
			curC1 = curC;
			for (j1=j-1; j1>=1; j1--)
			{
				curC1 = predArr[curC1];
				k = problem->node[curC1].neighborOF[curC];
				if (k != -1){ //node curC1 is neighbor of curC
					//Quangnn--
					//SUBcal_MoveCusPIAfterJ_oneTrip(curC, curC1, idVeh, idTrip, moveCusOneTrip[curC][k]->var_cost, moveCusOneTrip[curC][k]->var_vioTWC, moveCusOneTrip[curC][k]->var_vioTWSP, cStartS);
				}
			}
			curC = nextArr[curC];
		}
		//curC now points to the last customer
		curC1 = seg[idVeh].Trip[idTrip].firstCus;
		for (j=1;j<numC;j++)
		{
			k = problem->node[curC1].neighborOF[curC];
			if (k != -1){ //node curC1 is neighbor of curC
				//Quangnn--
				//SUBcal_MoveCusPIAfterJ_oneTrip(curC, curC1, idVeh, idTrip, moveCusOneTrip[curC][k]->var_cost, moveCusOneTrip[curC][k]->var_vioTWC, moveCusOneTrip[curC][k]->var_vioTWSP, cStartS);
			}
            curC1 = nextArr[curC1];
		}
	}//end lastT is pickup trip
}

void Solution::UpdateExchangeArray(int idVeh)
{
	//4th Transform: Exchange customer:
 	//4.1 Exchange delivery customers:
	//Recalculate exchange array: 1) exchangeCus[i][its neighbor] where i is in the trip
	                            //2) exchangeCus[??][i] where i is in the trip

	int curC,k, ii, kk;

	for (int idTrip = 0; idTrip < seg[idVeh].numTrips; idTrip++)
	{
		curC = seg[idVeh].Trip[idTrip].firstCus;
		if (seg[idVeh].Trip[idTrip].Type)
		{
			while (curC > 0)
			{
          		for (k=0;k<problem->node[curC].neighborSize; k++)
				{
					//calculate: exchange customer curC and its neighbor #k:
					cal_ExchangeCusDIAndJ(curC,k);
					exchangeCus[curC][k]->atIT=IT;
					ii = problem->node[curC].neighborNode[k].id; //exchange customer ii and curC
					kk = problem->node[curC].neighborOF[ii];
					if (kk != -1) exchangeCus[ii][kk] = exchangeCus[curC][k]; //ii is neighbor kkth of curC					
				}
				//2) exchangeCus[node[curC].beneighbor[#k]][curC] where curC is in the trip
				 for (k=0; k < problem->node[curC].beNeighborSize; k++)
				 {
					   //calculate: exchange:
						ii = problem->node[curC].beNeighbor[k].id;
						kk = problem->node[curC].beNeighbor[k].at;
						if (exchangeCus[ii][kk]->atIT != IT)
						{
							cal_ExchangeCusDIAndJ(ii,kk);
							exchangeCus[ii][kk]->atIT=IT;
						}
				 }
				 curC = nextArr[curC];
			}
		}
		else //(idVeh, idTrip) is pickup trip
		{
			while (curC > 0)
			{
          		for (k=0;k<problem->node[curC].neighborSize; k++)
				{
					//calculate: exchange customer curC and its neighbor #k:
					cal_ExchangeCusPIAndJ(curC,k);
					exchangeCus[curC][k]->atIT = IT;
					ii = problem->node[curC].neighborNode[k].id; //exchange customer ii and curC
					kk = problem->node[curC].neighborOF[ii];
					if (kk != -1) exchangeCus[ii][kk] = exchangeCus[curC][k]; //ii is neighbor kkth of curC					
				}
				//2) exchangeCus[node[curC].beneighbor[#k]][curC] where curC is in the trip
				 for (k=0; k < problem->node[curC].beNeighborSize; k++)
				 {
					   //calculate: exchange:
						ii = problem->node[curC].beNeighbor[k].id;
						kk = problem->node[curC].beNeighbor[k].at;
						if (exchangeCus[ii][kk]->atIT != IT)
						{
							cal_ExchangeCusPIAndJ(ii,kk);
							exchangeCus[ii][kk]->atIT=IT;
						}
				 }
				curC = nextArr[curC];
			}
		}//end (idVeh, idTrip) is pickup trip
	}
}

void Solution::UpdatetwoOPTstarArray(int idVeh)
{
	//5th Transform: 2opt*:
	//5. Recalculate twoOPTstar array: 1) twoOPTstarCus[i][its neighbor] where i is in the trip
	                                 //2) twoOPTstarCus[??][i] where i is in the trip

	int nextT, startNeighbor, curC, numC,i,j,k,ii,kk,idVehii, idTripii,nextTripii;
	int lastT = seg[idVeh].numTrips - 1;
	
	for (int idTrip = 0; idTrip < lastT; idTrip++)
	{
		nextT = idTrip + 1;
		curC = seg[idVeh].Trip[idTrip].firstCus;
		numC = seg[idVeh].Trip[idTrip].numCus;
		if (seg[idVeh].Trip[idTrip].Type)
		{
			if (seg[idVeh].Trip[nextT].Type) //idTrip is delivery, nextT is delivery
			{
				for (j=1;j<=numC;j++)
				{
					for (k=0;k<problem->node[curC].neighborSize; k++)
					{
						  //calculate: exchange customer curC and its neighbor #k:
						  i = problem->node[curC].neighborNode[k].id;
						  if (idVeh != route_num[i])
						  {
								 cal_twoOPTstarCusDIAndJ(curC,k);
								 twoOPTstarCus[curC][k]->type = 1;
						  }
						  else 
						  {
							  //curC has to be placed before its neighbor #k in the current route:
							  if (nextArr[curC]!= i)
							  {
								  startNeighbor = pos[i];
								  if (j < startNeighbor)
								  {
									  cal_twoOPTstarCusDIAndJ_oneTrip_NextTripD(curC,k);
									  twoOPTstarCus[curC][k]->type = 3;
								  }
							  }
						  }
 						  twoOPTstarCus[curC][k]->atIT = IT;
    				}

					//2. twoOPTstarCus[??][curC] where curC is in the trip
					 for (k=0; k < problem->node[curC].beNeighborSize; k++)
					 {
						  //calculate: 2opt*
						  ii = problem->node[curC].beNeighbor[k].id;
						  kk = problem->node[curC].beNeighbor[k].at;
						  if (twoOPTstarCus[ii][kk]->atIT != IT)
						  {
		  						idVehii = route_num[ii]; idTripii = trip_num[ii];
								nextTripii = idTripii + 1;
								twoOPTstarCus[ii][kk]->atIT = IT;
								if (idVeh != idVehii)
								{
									cal_twoOPTstarCusDIAndJ(ii,kk);
									twoOPTstarCus[ii][kk]->type = 1;
								}
								else //same trip:
								{
									if (nextArr[ii] != curC)
									{
										startNeighbor = pos[ii];
										if (startNeighbor < j)
										{
										    if (nextTripii == seg[idVehii].numTrips)
											{
												cal_twoOPTstarCusDIAndJ_oneTrip_LastTrip(ii, kk);
												twoOPTstarCus[ii][kk]->type = 2;
											}
											else if (seg[idVehii].Trip[nextTripii].Type)
											{
												  cal_twoOPTstarCusDIAndJ_oneTrip_NextTripD(ii, kk);
												  twoOPTstarCus[ii][kk]->type = 3;
											}
											else
											{
												  cal_twoOPTstarCusDIAndJ_oneTrip_NextTripP(ii, kk);
												  twoOPTstarCus[ii][kk]->type = 4;
											}
										}
									}
								}
						  }//end if (twoOPTstarCus[ii][kk]->atIT != IT)
					 }//end for k
					curC = nextArr[curC];
				}
			}
			else //idTrip is delivery, nextT is pickup
			{
				for (j=1;j<=numC;j++)
				{
					for (k=0;k<problem->node[curC].neighborSize; k++)
					{
						  //calculate: exchange customer curC and its neighbor #k:
						  i = problem->node[curC].neighborNode[k].id;
						  if (idVeh != route_num[i])
						  {
								 cal_twoOPTstarCusDIAndJ(curC, k);
								 twoOPTstarCus[curC][k]->type = 1;
						  }
						  else 
						  {
							  //curC has to be placed before its neighbor #k in the current route:
							  if (nextArr[curC] != i)
							  {
								  startNeighbor = pos[i];
								  if (j < startNeighbor)
								  {
									  cal_twoOPTstarCusDIAndJ_oneTrip_NextTripP(curC,k);
									  twoOPTstarCus[curC][k]->type = 4;
								  }
							  }

						  }
 						  twoOPTstarCus[curC][k]->atIT = IT;
    				}
					//2. twoOPTstarCus[??][curC] where curC is in the trip
					 for (k=0; k < problem->node[curC].beNeighborSize; k++)
					 {
						  //calculate: 2opt*
						  ii = problem->node[curC].beNeighbor[k].id;
						  kk = problem->node[curC].beNeighbor[k].at;
						  if (twoOPTstarCus[ii][kk]->atIT != IT)
						  {
		  						idVehii = route_num[ii]; idTripii = trip_num[ii];
								nextTripii = idTripii + 1;
								twoOPTstarCus[ii][kk]->atIT = IT;
								if (idVeh != idVehii)
								{
									cal_twoOPTstarCusDIAndJ(ii,kk);
									twoOPTstarCus[ii][kk]->type = 1;
								}
								else //same trip:
								{
									if (nextArr[ii] != curC)
									{
										startNeighbor = pos[ii];
										if (startNeighbor < j)
										{
										    if (nextTripii == seg[idVehii].numTrips)
											{
												cal_twoOPTstarCusDIAndJ_oneTrip_LastTrip(ii, kk);
												twoOPTstarCus[ii][kk]->type = 2;
											}
											else if (seg[idVehii].Trip[nextTripii].Type)
											{
												  cal_twoOPTstarCusDIAndJ_oneTrip_NextTripD(ii, kk);
												  twoOPTstarCus[ii][kk]->type = 3;
											}
											else
											{
												  cal_twoOPTstarCusDIAndJ_oneTrip_NextTripP(ii, kk);
												  twoOPTstarCus[ii][kk]->type = 4;
											}
										}
									}
								}
						  }//end if (twoOPTstarCus[ii][kk]->atIT != IT)
					 }//end for k

					curC = nextArr[curC];
				}
			}//end idTrip is delivery, nextT is pickup
		}
		else //idTrip is pickup
		{
			int assSP = seg[idVeh].Trip[idTrip].assSP;
			for (j=1;j <= numC;j++)
			{
				for (k=0;k<problem->node[curC].neighborSize; k++)
				{
					  //calculate: exchange customer curC and its neighbor #k:
					  i = problem->node[curC].neighborNode[k].id;
					  if (assSP != seg[route_num[i]].Trip[trip_num[i]].assSP)
						 twoOPTstarCus[curC][k]->var_vioCAP = PDS_INFINITY;
					  else
					  {
						  if (idVeh != route_num[i]) //dif veh, dif trip
							  cal_twoOPTstarCusPIAndJ(curC, k);
						  else //same vehicle
						  {
							  if (idTrip == trip_num[i]) //same trip, same vehicle
							  {
								  //curC has to be placed before its neighbor #k in the current route:
								  if (pos[i] > j && nextArr[curC] != i)  cal_twoOPTstarCusPIAndJ_oneTrip(curC,k);
								  else twoOPTstarCus[curC][k]->var_vioCAP = PDS_INFINITY;
							  }//end same trip, same vehicle
						  }//end same vehicle
					  }
					  twoOPTstarCus[curC][k]->atIT = IT;
				}

				//2. twoOPTstarCus[??][curC] where curC is in the trip
				 for (k=0; k < problem->node[curC].beNeighborSize; k++)
				 {
					  //calculate: 2opt*
					  ii = problem->node[curC].beNeighbor[k].id;
					  kk = problem->node[curC].beNeighbor[k].at;
					  if (twoOPTstarCus[ii][kk]->atIT != IT)
					  {
	  						idVehii = route_num[ii]; idTripii = trip_num[ii];
							nextTripii = idTripii + 1;
							twoOPTstarCus[ii][kk]->atIT = IT;
							if (idVeh != idVehii)
							{
								cal_twoOPTstarCusDIAndJ(ii,kk);
								twoOPTstarCus[ii][kk]->type = 1;
							}
							else //same trip:
							{
								if (nextArr[ii] != curC)
								{
									startNeighbor = pos[ii];
									if (startNeighbor < j)
									{
									    if (nextTripii == seg[idVehii].numTrips)
										{
											cal_twoOPTstarCusDIAndJ_oneTrip_LastTrip(ii, kk);
											twoOPTstarCus[ii][kk]->type = 2;
										}
										else if (seg[idVehii].Trip[nextTripii].Type)
										{
											  cal_twoOPTstarCusDIAndJ_oneTrip_NextTripD(ii, kk);
											  twoOPTstarCus[ii][kk]->type = 3;
										}
										else
										{
											  cal_twoOPTstarCusDIAndJ_oneTrip_NextTripP(ii, kk);
											  twoOPTstarCus[ii][kk]->type = 4;
										}
									}
								}
							}
					  }//end if (twoOPTstarCus[ii][kk]->atIT != IT)
				 }//end for k
				curC = nextArr[curC];
			}
		}//end idTrip is pickup
	}
	
	//last Trip:
	curC = seg[idVeh].Trip[lastT].firstCus;
	numC = seg[idVeh].Trip[lastT].numCus;
	if (seg[idVeh].Trip[lastT].Type)
	{
		for (j = 1; j<= numC; j++)
		{
			for (k=0; k< problem->node[curC].neighborSize; k++)
			{
				  //calculate: 2opt* customer curC and its neighbor #k:
				  i = problem->node[curC].neighborNode[k].id;
				  if (idVeh != route_num[i]) //curC and its neighbor i belong to different vehicles
				  {
						 cal_twoOPTstarCusDIAndJ(curC,k);
						 twoOPTstarCus[curC][k]->type = 1;
				  }
				  else //curC and i belong to the same trip
				  {
					  //curC has to be placed before its neighbor #k in the current route:
					  if (nextArr[curC] != i)
					  {
						  startNeighbor = pos[i];
						  if (j < startNeighbor)
						  {
							  cal_twoOPTstarCusDIAndJ_oneTrip_LastTrip(curC,k);
							  twoOPTstarCus[curC][k]->type = 2;
						  }
					  }
				  }
				  twoOPTstarCus[curC][k]->atIT = IT;
			}			
			//2. twoOPTstarCus[??][curC] where curC is in the trip
			 for (k=0; k < problem->node[curC].beNeighborSize; k++)
			 {
				  //calculate: 2opt*
				  ii = problem->node[curC].beNeighbor[k].id;
				  kk = problem->node[curC].beNeighbor[k].at;
				  if (twoOPTstarCus[ii][kk]->atIT != IT)
				  {
  						idVehii = route_num[ii]; idTripii = trip_num[ii];
						nextTripii = idTripii + 1;
						twoOPTstarCus[ii][kk]->atIT = IT;
						if (idVeh != idVehii)
						{
							cal_twoOPTstarCusDIAndJ(ii,kk);
							twoOPTstarCus[ii][kk]->type = 1;
						}
						else //same trip:
						{
							if (nextArr[ii] != curC)
							{
								startNeighbor = pos[ii];
								if (startNeighbor < j)
								{
								    if (nextTripii == seg[idVehii].numTrips)
									{
										cal_twoOPTstarCusDIAndJ_oneTrip_LastTrip(ii, kk);
										twoOPTstarCus[ii][kk]->type = 2;
									}
									else if (seg[idVehii].Trip[nextTripii].Type)
									{
										  cal_twoOPTstarCusDIAndJ_oneTrip_NextTripD(ii, kk);
										  twoOPTstarCus[ii][kk]->type = 3;
									}
									else
									{
										  cal_twoOPTstarCusDIAndJ_oneTrip_NextTripP(ii, kk);
										  twoOPTstarCus[ii][kk]->type = 4;
									}
								}
							}
						}
				  }//end if (twoOPTstarCus[ii][kk]->atIT != IT)
			 }//end for k
			curC = nextArr[curC];
		}
	}
	else //lastT is pickup trip
	{
		int assSP = seg[idVeh].Trip[lastT].assSP;
		for (j=1;j <= numC;j++)
		{
			for (k=0;k<problem->node[curC].neighborSize; k++)
			{
				  //calculate: exchange customer curC and its neighbor #k:
				  i = problem->node[curC].neighborNode[k].id;
				  if (assSP != seg[route_num[i]].Trip[trip_num[i]].assSP)
					 twoOPTstarCus[curC][k]->var_vioCAP = PDS_INFINITY;
				  else
				  {
					  if (idVeh != route_num[i]) //dif veh, dif trip
						  cal_twoOPTstarCusPIAndJ(curC, k);
					  else //same vehicle
					  {
						  if (lastT == trip_num[i]) //same trip, same vehicle
						  {
							  //curC has to be placed before its neighbor #k in the current route:
							  if (pos[i] > j && nextArr[curC] != i)  cal_twoOPTstarCusPIAndJ_oneTrip(curC,k);
							  else twoOPTstarCus[curC][k]->var_vioCAP = PDS_INFINITY;
						  }//end same trip, same vehicle
					  }//end same vehicle
				  }
				  twoOPTstarCus[curC][k]->atIT = IT;
			}
			//2. twoOPTstarCus[??][curC] where curC is in the trip
			 for (k=0; k < problem->node[curC].beNeighborSize; k++)
			 {
				  //calculate: 2opt*
				  ii = problem->node[curC].beNeighbor[k].id;
				  kk = problem->node[curC].beNeighbor[k].at;
				  if (twoOPTstarCus[ii][kk]->atIT != IT)
				  {
  						idVehii = route_num[ii]; idTripii = trip_num[ii];
						nextTripii = idTripii + 1;
						twoOPTstarCus[ii][kk]->atIT = IT;
						if (idVeh != idVehii)
						{
							cal_twoOPTstarCusDIAndJ(ii,kk);
							twoOPTstarCus[ii][kk]->type = 1;
						}
						else //same trip:
						{
							if (nextArr[ii] != curC)
							{
								startNeighbor = pos[ii];
								if (startNeighbor < j)
								{
								    if (nextTripii == seg[idVehii].numTrips)
									{
										cal_twoOPTstarCusDIAndJ_oneTrip_LastTrip(ii, kk);
										twoOPTstarCus[ii][kk]->type = 2;
									}
									else if (seg[idVehii].Trip[nextTripii].Type)
									{
										  cal_twoOPTstarCusDIAndJ_oneTrip_NextTripD(ii, kk);
										  twoOPTstarCus[ii][kk]->type = 3;
									}
									else
									{
										  cal_twoOPTstarCusDIAndJ_oneTrip_NextTripP(ii, kk);
										  twoOPTstarCus[ii][kk]->type = 4;
									}
								}
							}
						}
				  }//end if (twoOPTstarCus[ii][kk]->atIT != IT)
			 }//end for k
			curC = nextArr[curC];
		}
	}//end lastT is pickup trip
}

//-------------------------------------------------- INIT SOLUTION ----------------------------------------------
void Solution::CheckAndCreateSingleTrip(void)
{
	int startSP;
	int i;
	int inPUCusDemandTot;
	int inDECusDemandTot;
	int inC2CCusDemandTot;

	cout << "\t\t\tCheckAndCreateSingleTrip..." ;
	inPUCusDemandTot = 0;
	inDECusDemandTot = 0;
	inC2CCusDemandTot = 0;
	for (int inMainLoop = 1; inMainLoop <= nSP; inMainLoop++)
	{
		startSP = inMainLoop;

		// Create a new vehicle trip for PICKUP demands		
		//if (numCusPRouted[startSP] < numCusPSP[startSP]) // the SP startSP has unrouted PICKUP demands
		{
			for ( i = 1; i <= numCusPSP[startSP]; i++)
			{
				int idPUCus = CusPSP[startSP][i];
				if (routed[idPUCus] == 0)
				{
					//Create new single route: depot -> startSP -> delivery -> depot
					int inRetVal = Create_Single_Pickup_Trip_Q(idPUCus, startSP, numVeh);
					if (!inRetVal)
					{

						//cout << "Create SINGLE PICKUP " << idPUCus << " OK!" << endl;
						if (false == Valid_A_Trip(numVeh, 1))
						{
							cout << "\t The PICKUP trip is not valid" << endl; getchar();
							return; // Expected the single-demand trip was VALID always
						}
						inPUCusDemandTot++;

						numVeh++; // Now, we got a new PICKUP trip
					} else 
					{
						cout << "\tCheck input data " << idPUCus << " can not be selfserved!" << endl; getchar();
						return; 
					}
				}
			}
		}

		// Create a new vehicle trip for DELLIVERY demands
		if (numCusDRouted[startSP] < problem->numCusDSP[startSP]) // the SP startSP has unrouted DELIVERY demands
		{
			for (int idDECus = problem->startCusDSP[startSP]; idDECus <= problem->endCusDSP[startSP]; idDECus++)
			{
			    if (routed[idDECus] == 0)
				{
					//Create new single route: depot -> startSP -> delivery -> depot
					int inRetVal = Create_Single_Delivery_Trip_Q(idDECus, startSP, numVeh);
					if (!inRetVal)
					{
						//cout << "Create SINGLE DELIVERY " << idDECus << " OK!" << endl;
						if (false == Valid_A_Trip(numVeh, 1))
						{
							cout << "\t The DELIVERY trip is not valid" << endl;
							return; // Expected the single-demand trip was VALID always
						}
						inDECusDemandTot++;

						numVeh++; // Now, we got a new PICKUP trip
					} else
					{
						cout << "\tCheck input data " << idDECus << " can not be selfserved!" << endl; getchar();
						return; 
					}
				}
			}
		}

	}

	// Create a new C2C trip
	for (i = problem->startidC2C; i <= problem->endidC2CP; i++)
	{
		if (routed[i] == 0)
		{
			int inRetVal = Create_Single_C2C_Trip_Q(i, numVeh);
			if (!inRetVal)
			{
				//cout << "Create SINGLE c2C " << i << " OK!" << endl;
				if (false == Valid_A_Trip(numVeh, 1))
				{
					cout << "\t The DELIVERY trip is not valid" << endl; getchar();
					return; // Expected the single-demand trip was VALID always
				}
				inC2CCusDemandTot++;
		
				numVeh++; // Now, we got a new C2C trip
			} else
			{
				cout << "\tCheck input data " << i << " can not be selfserved!" << endl; getchar();
				return; 
			}

		}
	}

	// Summurize
	if ((inPUCusDemandTot) || (inDECusDemandTot) || (inC2CCusDemandTot))
	{
		cout << endl;
		cout << "\t\t\t Create new PICKUP single trip: " << inPUCusDemandTot << endl;
		cout << "\t\t\t Create new DELIVERY single trip: " << inDECusDemandTot << endl;
		cout << "\t\t\t Create new C2C single trip: " << inC2CCusDemandTot << endl;
	} else
	{
		cout << "OK - No need singles!" << endl;
	}
}

void Solution::initAssignment_Q(void)
{
	int i;

	// Init. the number of pickup/delivery assigned to supply point 
	for (i = 1; i <= nSP; i++) {  // number of supply points 
		numCusDRouted[i] = 0;     // the number of DELIVERY assigned to supply point i
		numCusPRouted[i] = 0;	  // the number of PICKUP assigned to supply point i
	}

	/*
	 * S1: Compute the total DELIVERY demands assigned to each supply point. 
	 * Let K_s denotes this number for supply point s \in S
	 * --> Calculated while reading data
	 */
#if Q_DEBUG_PU_ASSIGNMENT
		 cout << "\tTotal of DELIVERY demands assigned to each supply point (SP | CapTot " << endl;
		 for (i = 1; i <=nSP; i++){
			 cout << "\t\t" << i << "\t" << problem->capDSP[i] << endl;
		 }
#endif

	/* 
	 * S2: Bound the total volume vehicles can PICKUP and UNLOAD at supply point s to K_s
	 * --> 
	 */
#if Q_DEBUG_PU_ASSIGNMENT
	cout << "\tMinimum trips required to serve all PICKUP customer: " << minTripCusP << endl;
	cout << "\tMinimum legs required for each supply point (SP | nbr): "  << endl;
	for (i = 1; i <=nSP; i++){
		cout << "\t\t" << i << "\t" << minTripSP[i] << endl;
	}
#endif

	/*
	 * S3: Randomly select a PICKUP demand p until are assigned, and
	 *		- Assign p to the nearest supply point in S_p;
	 *		- When the assignment violates the maximum capacity of the nearest supply point in S_p,
	 *			the PICKUP demand p is randomly allocated to the supply point in S_p whose residual capacity
	 *			is large enough to accommodate it.
	 */
	AssignCusPToSP_Q();
}
// Hope fine
void Solution::initSolution_Q(void)
{
	int i, j;
	int inPreSPIdx;
	nextArrTemp = new int[totalNODE1];	// Temporary storage for a solution
	nextArrB = new int [totalNODE1];
	routedTemp = new bool[totalNODE1];

	bool cont=1;
	int numTrip, startSP, nextSP,type;
	double leave_SP;

	int inFirstPickupTime = -1;
	int inFirstPickupNode = -1;

    int inCandidateNbr = 0;
	int arrDemandCandidates[2000];

    int createTrip; //= 0: last delivery trip; = 1: d-p trip; =2: only delivery trip
    double feeMIN = PDS_INFINITY;
    bool canRoute = 0; 
	double leave_startSP;
	bool bRetVal;
	bool isOnlyC2C = false;
	//int  inNodeTotPerTrip; // counting number of customer-demands per trip

	cout << "****IntiSolution_Q >>>" << endl;

	// Init. the number of pickup/delivery assigned to supply point 
	for (i = 1; i <= nSP; i++) {  // number of supply points 
		numCusDRouted[i] = 0;     // the number of DELIVERY assigned to supply point i
		numCusPRouted[i] = 0;	  // the number of PICKUP assigned to supply point i
	}

	//Init. status of pickup/delivery  (ASSIGNED or NOT ASSIGN)
	for (i = problem->startidC2C; i <= endidD; i++) {
		routed[i] = false;		 // Current status of 
		nextArr[i] = 0;			 // Solution storage
	}
		   						

	/*
	 * S1: Compute the total DELIVERY demands assigned to each supply point. 
	 * Let K_s denotes this number for supply point s \in S
	 * --> Calculated while reading data
	 */
#if Q_DEBUG_INIT_SOL
		 cout << "\tTotal of DELIVERY demands assigned to each supply point (SP | CapTot " << endl;
		 for (i = 1; i <=nSP; i++){
			 cout << "\t\t" << i << "\t" << problem->capDSP[i] << endl;
		 }
#endif

	/* 
	 * S2: Bound the total volume vehicles can PICKUP and UNLOAD at supply point s to K_s
	 * --> 
	 */
#if Q_DEBUG_INIT_SOL
	cout << "\tMinimum trips required to serve all PICKUP customer: " << minTripCusP << endl;
	cout << "\tMinimum legs required for each supply point (SP | nbr): "  << endl;
	for (i = 1; i <=nSP; i++){
		cout << "\t\t" << i << "\t" << minTripSP[i] << endl;
	}
#endif

	/*
	 * S3: Randomly select a PICKUP demand p until are assigned, and
	 *		- Assign p to the nearest supply point in S_p;
	 *		- When the assignment violates the maximum capacity of the nearest supply point in S_p,
	 *			the PICKUP demand p is randomly allocated to the supply point in S_p whose residual capacity
	 *			is large enough to accommodate it.
	 */
	AssignCusPToSP_Q();

	/*
	 * S4: Initial WORK ASSIGNMENTS are built SEQUENTIALLY until all customer demands are serviced
	 *		For each work assignment:
	 *			- Determine the initial supply point if the first leg as the supply point s with 
	 *				earliest opening time and unserviced customer demands;
	 *			- Create one or sequence of LEGs between supply point s and either another supply point
	 *				or the garage g using the GREEDY algorithm
	 *			- If the leg (or sequence of) ends at a supply point s^', set s <-- s^' and build the next leg(s)
	 *			- Otherwise, i.e., the legs at the garage, STOP (the current work assignment is completed).
	 */
	
	numVeh = 1;		// Total of used vehicles
	seg[numVeh].numTrips = 0;
	int inSelectedSP = -1;
	g_inInitVehNum = 0;

	while (cont) //each loop create one vehicle
	{
		if (1 == Update_SP_Status()) // All ROUTED!
		{
			cont = 0;
			break;
		}

		/*
		 *	- Determine the initial supply point if the first leg as the supply point s with 
		 *		EARLIEST opening time and unserviced customer demands;
		 */
		double dbMinETime = PDS_INFINITY;

#if Q_DEBUG_INIT_SOL
		cout << "Vehicle " << numVeh << endl;
#endif
		inSelectedSP = -1;
		//if (-1 == inSelectedSP)
		{
			inPreSPIdx = 0; //DEPOT
			for (startSP = 1; startSP <= nSP; startSP++){
				if ((numCusPRouted[startSP] < numCusPSP[startSP]) || (numCusDRouted[startSP] < problem->numCusDSP[startSP])){ // Supply point has unserviced customer demand
					if (problem->nodeSP[startSP].sTW1 < dbMinETime){
						dbMinETime = problem->nodeSP[startSP].sTW1;
						inSelectedSP = startSP;
					}
				}
			}
			if (-1 == inSelectedSP) // means all Pickup/Delivery-customer demands are ROUTED
			{
				cout << "C2C unrouted: "; 
				for (int ii = problem->startidC2C; ii <= problem->endidC2CP; ii++)
				{
					if (routed[ii] == 0)
					{
						cout << ii << " ";
					}
				}

				for (startSP = 1; startSP <= nSP; startSP++)
				{
					if (problem->nodeSP[startSP].sTW1 < dbMinETime)
					{
						dbMinETime = problem->nodeSP[startSP].sTW1;
						inSelectedSP = startSP;
					}
				}
				inSelectedSP = 0;
				isOnlyC2C = true;
			}
		}
		startSP = inSelectedSP; // Now, supply point startSP is selected as initial one
		double dbDepartureTime = 0;
#if Q_DEBUG_INIT_SOL
		cout << "\t The first UNROUTED SP with earliest openning time: " << startSP << endl;
#endif

		/*
		 * Create INITIAL leg DEPOT --> C2Cs --> PICKUPs --> startSP
		 */
			bool bGetC2CTrip = false;
			bool bGetPickupTrip = false;
			bool bGetDeliveryTrip = false;

			/****************************** CREATE DEPOT --> C2Cs --> startSP *******************************/
#if Q_DEBUG_INIT_SOL
			cout << "\t\t Init. C2C leg (looped) " << inPreSPIdx << " to " << startSP << " at " << dbDepartureTime;
#endif			
			do
			{
				bGetC2CTrip = Create_C2CTrip_Q(inPreSPIdx,			// Start from
											dbDepartureTime,		// Departure time
											startSP,				// EndSP
											0,						// Current capacity
											numVeh,					// Current vehicleIdx
											seg[numVeh].numTrips);	// Current tripIdx
				if (true == bGetC2CTrip)
				{
					int inTripIdxTmp, inVehIdxTmp;
					double dbTimeTmp;

					if (true == Get_Node_Info(seg[numVeh].Trip[seg[numVeh].numTrips].lastCus, &dbTimeTmp, &inVehIdxTmp, &inTripIdxTmp))
					{ 
						dbDepartureTime = dbTimeTmp;
						inPreSPIdx = seg[numVeh].Trip[seg[numVeh].numTrips].lastCus;
						g_inInitVehNum++;
						cout << "...ok with " << seg[numVeh].Trip[seg[numVeh].numTrips].numCus << " demands" << endl;
					}
				} else
				{
					cout << "...failed" << endl;
					break;
				}
			} while (1);

			if ((0 == startSP) && (true == isOnlyC2C))
			{
				if (seg[numVeh].numTrips > 0)
				{
					numVeh++;
					seg[numVeh].numTrips = 0;
				}
				continue;
			}
			/****************************** CREATE DEPOT ... PICKUPs --> startSP *******************************/
			if (numCusPRouted[startSP] < numCusPSP[startSP]) // re-check to make sure that existence of unrouted PICKUP customers.
			{
#if Q_DEBUG_INIT_SOL
			cout << "\t\t Init. PICKUP leg from " << inPreSPIdx << " to " << startSP << " at " << dbDepartureTime;
#endif
				bGetPickupTrip = Create_PickupTrip_Q(
							inPreSPIdx,				// departure SP index: can be DEPOT, SP, last C2C-delivery, last delivery
					   		dbDepartureTime,		// departure time at departSPIdx
							startSP,				// can be DEPOT to pickup or SP
							NODE_SUPPLY_POINT,			// 0 - depot; 1 - pickup; 2- supply point to delivery
							0,			// current vehicle capacity
							numVeh,				
							seg[numVeh].numTrips);
				if (true == bGetPickupTrip)
				{
					if (false == Valid_A_Trip(numVeh, seg[numVeh].numTrips))
					{
						cout << " ...Valid failed" << endl; getchar();
					} else
					{
//						Show_A_Trip(numVeh, seg[numVeh].numTrips);
						dbDepartureTime = seg[numVeh].Trip[seg[numVeh].numTrips].endS;
						g_inInitVehNum++;
						cout << "...ok with " << seg[numVeh].Trip[seg[numVeh].numTrips].numCus << " demands" << endl;
					}
				} else 
				{
					cout << "...failed" << endl;
				}
			} else
			{
#if Q_DEBUG_INIT_SOL
			cout << "\t\t Init. PICKUP leg from " << inPreSPIdx << " to " << startSP << "... ALL ROUTED" << endl;
#endif
			}


#if Q_DEBUG_INIT_SOL
		cout << "\t MAIN LOOP --> set legs between S -> S'" << endl;
#endif
#if 1
		do
		{
			// Find SP s' with unserviced customer demands that t(s') > t(startSP)
			int s_SP;
			int arrSPCandidates[2000];
			int SPCandidateNbr = 0;

			for (s_SP = 1; s_SP <= nSP; s_SP++){
				if (numCusPRouted[s_SP] < numCusPSP[s_SP] || numCusDRouted[s_SP] < problem->numCusDSP[s_SP]){ // Supply point has unserviced customer demand
					if (problem->nodeSP[startSP].sTW1 < problem->nodeSP[s_SP].sTW1){
						SPCandidateNbr++;
						arrSPCandidates[SPCandidateNbr] = s_SP;
					}
				}
			}
			//if (0 == SPCandidateNbr)
			{
				SPCandidateNbr++;
				arrSPCandidates[SPCandidateNbr] = 0;
			}
		
			int inMaxNodePerTrip = 0;
			int inMaxTripPerVeh = 0;
			int inSaveSPIdx = -1;
			int inCurrTripIdx = seg[numVeh].numTrips;
			for (s_SP = 1; s_SP <= SPCandidateNbr; s_SP++)
			{
				cout << "\t\t Check leg from " << startSP << " to " << arrSPCandidates[s_SP] << endl;
				int inPossNode = Build_Seq_Leg(startSP, arrSPCandidates[s_SP], dbDepartureTime);
				cout << "\t\t\t Leg from " << startSP << " to " << arrSPCandidates[s_SP] << " has: " << inPossNode << endl;

				if (inPossNode > inMaxNodePerTrip)
				{
					inSaveSPIdx = arrSPCandidates[s_SP];
					inMaxNodePerTrip = inPossNode;
				}

				//if (seg[numVeh].numTrips > inMaxTripPerVeh)
				//{
				//	inSaveSPIdx = arrSPCandidates[s_SP];
				//	inMaxTripPerVeh = seg[numVeh].numTrips;
				//	inMaxNodePerTrip = inPossNode;
				//} else if (seg[numVeh].numTrips == inMaxTripPerVeh)
				//{
				//	if (inPossNode > inMaxNodePerTrip)
				//	{
				//		inSaveSPIdx = arrSPCandidates[s_SP];
				//		inMaxNodePerTrip = inPossNode;
				//	}
				//}

				// Unrouted this vehicle
				for (int jj = inCurrTripIdx+1; jj <= seg[numVeh].numTrips; jj++)
				{
					int curC = seg[numVeh].Trip[jj].firstCus;
				    while (curC > 0)
				    {
					   routed[curC] = 0;				
					   curC = nextArr[curC];
				    }
				}
				seg[numVeh].numTrips = inCurrTripIdx;
				Update_SP_Status();
			}
			if (-1 == inSaveSPIdx)
			{
				break; 
			} else
			{
				cout << "\t\t Build leg from " << startSP << " to " << inSaveSPIdx << " at " << dbDepartureTime << endl;
				Build_Seq_Leg(startSP, inSaveSPIdx, dbDepartureTime);
				startSP = inSaveSPIdx;
				g_inInitVehNum++;
			}

			if (0 == startSP)
				break;
		} while (1);
#else
		//*****************8
		do
		{
			int s_SP;
			int arrSPCandidates[2000];
			int SPCandidateNbr = 0;
			bool bDeliveryTripS = false;
			bool bC2CTripS = false;
			bool bPickupS_com = false;

//			Update_SP_Status();

			// Find SP s' with unserviced customer demands that t(s') > t(startSP)
			for (s_SP = 1; s_SP <= nSP; s_SP++){
				if (numCusPRouted[s_SP] < numCusPSP[s_SP] || numCusDRouted[s_SP] < problem->numCusDSP[s_SP]){ // Supply point has unserviced customer demand
					if (problem->nodeSP[startSP].sTW1 < problem->nodeSP[s_SP].sTW1){
						SPCandidateNbr++;
						arrSPCandidates[SPCandidateNbr] = s_SP;
					}
				}
			}

			SPCandidateNbr++;
			arrSPCandidates[SPCandidateNbr] = 0;
//			if (SPCandidateNbr == 0) // all PICKUP/DELIVERY-customer-demands are ROUTED
//			{
//#if Q_DEBUG_INIT_SOL
//				cout << "\t\tNO SP S' FOUND --> BACK TO DEPOT" << endl;
//#endif
//				SPCandidateNbr = 1;
//				arrSPCandidates[SPCandidateNbr] = 0; // DEPOT
//				//break;
//
//				//for (s_SP = 1; s_SP <= nSP; s_SP++)
//				//{
//				//	if (problem->nodeSP[startSP].sTW1 < problem->nodeSP[s_SP].sTW1)
//				//	{
//				//		SPCandidateNbr++;
//				//		arrSPCandidates[SPCandidateNbr] = s_SP;
//				//	}
//				//}
//			} 
			//else 
			{

				for (s_SP = 1; s_SP <= SPCandidateNbr; s_SP++)
				{
#if Q_DEBUG_INIT_SOL
					cout << "\t Create legs from SP " << startSP << " to " << arrSPCandidates[s_SP] << endl;
#endif

#if Q_DEBUG_INIT_SOL
					cout << "\t\t Build delivery of SP " << startSP << " to " << arrSPCandidates[s_SP] << " at " << dbDepartureTime;
#endif
					/* In case that startSP is not SP so we should find a SP that still has unrouted delivery demands
					 * and has ready time < ready time of arrSPCandidates[s_SP]
					 */
					int startSPTmp = startSP;
					if (NODE_SUPPLY_POINT != Get_Node_Type(startSPTmp))
					{
						for (int ii = 1; ii <= nSP; ii++)
						{
							if (numCusDRouted[ii] < problem->numCusDSP[ii]) // this SP ii still has unrouted delivery-customer-demands
							{
								if (problem->nodeSP[ii].sTW1 < problem->nodeSP[arrSPCandidates[s_SP]].sTW1)
								{
									startSPTmp = ii;

									break;
								}
							}
						}
					}
					double dbDepartureTimeTmp = dbDepartureTime;
					if ((0 == seg[numVeh].numTrips) && (0 == dbDepartureTimeTmp))
					{
						dbDepartureTimeTmp = problem->nodeSP[arrSPCandidates[s_SP]].sTW1; // means this delivery is first trip so need to move from DEPOT to SP
					} else 
					{
						if ((seg[numVeh].Trip[seg[numVeh].numTrips].endNodeIdx != startSPTmp) && (seg[numVeh].Trip[seg[numVeh].numTrips].endNodeIdx > 0))
						{
							dbDepartureTimeTmp += problem->c[seg[numVeh].Trip[seg[numVeh].numTrips].endNodeIdx][startSPTmp];
						} else if (seg[numVeh].Trip[seg[numVeh].numTrips].endNodeIdx == startSPTmp)
						{
							dbDepartureTimeTmp = seg[numVeh].Trip[seg[numVeh].numTrips].endS;
						}
					}

					bDeliveryTripS = Create_DeliveryTrip_Q2(startSPTmp,
										   dbDepartureTimeTmp,
										   arrSPCandidates[s_SP],
										   Get_Node_Type(arrSPCandidates[s_SP]),
										   0,
										   numVeh,
										   seg[numVeh].numTrips);
					if (true == bDeliveryTripS)
					{
						//Show_A_Trip(numVeh, seg[numVeh].numTrips);
						int inTripIdxTmp, inVehIdxTmp;
						double dbTimeTmp;
						if (true == Get_Node_Info(seg[numVeh].Trip[seg[numVeh].numTrips].lastCus, &dbTimeTmp, &inVehIdxTmp, &inTripIdxTmp))
						{ 
							dbDepartureTime = dbTimeTmp;
							startSP = seg[numVeh].Trip[seg[numVeh].numTrips].lastCus;
							g_inInitVehNum++;
							cout << "...ok with " << seg[numVeh].Trip[seg[numVeh].numTrips].numCus << " demands" << endl;

						} 

					} else
					{
						cout << "...failed" << endl; 
						if (seg[numVeh].numTrips < 1) // means still no PICKUP/DELIVERY associated to this SP
							continue;
					}

					// Build startSP -> c2c demands -> s'
#if Q_DEBUG_INIT_SOL
					cout << "\t\t Build c2c from " << startSP << " to " << arrSPCandidates[s_SP] << " at " << dbDepartureTime;
#endif
					bC2CTripS = Create_C2CTrip_Q(startSP,
												dbDepartureTime,
												arrSPCandidates[s_SP],
												0,
												numVeh,
												seg[numVeh].numTrips);

					int inTripIdxTmp, inVehIdxTmp;
					double dbTimeTmp;
					if (true == bC2CTripS)
					{
						if (true == Get_Node_Info(seg[numVeh].Trip[seg[numVeh].numTrips].lastCus, &dbTimeTmp, &inVehIdxTmp, &inTripIdxTmp))
						{ 
							dbDepartureTime = dbTimeTmp;
							startSP = seg[numVeh].Trip[seg[numVeh].numTrips].lastCus;
							bC2CTripS = true;
							g_inInitVehNum++;
							cout << "...ok with " << seg[numVeh].Trip[seg[numVeh].numTrips].numCus << " demands" << endl;
						}
					} else
					{
						cout << "...failed" << endl; 
					}

					// Build startSP --> PICKUP of demand s'
#if Q_DEBUG_INIT_SOL
					cout << "\t\t Build pickup from " << startSP << " to " << arrSPCandidates[s_SP] << " at " << dbDepartureTime;
#endif

					if (numCusPRouted[arrSPCandidates[s_SP]] < numCusPSP[arrSPCandidates[s_SP]]) // re-check to make sure that existence of unrouted PICKUP customers.
					{
						bPickupS_com = Create_PickupTrip_Q(
									startSP,				// departure SP index: can be DEPOT, SP, last C2C-delivery, last delivery
					   				dbDepartureTime,		// departure time at departSPIdx
									arrSPCandidates[s_SP],				// can be DEPOT to pickup or SP
									NODE_SUPPLY_POINT,			// 0 - depot; 1 - pickup; 2- supply point to delivery
									0,			// current vehicle capacity
									numVeh,				
									seg[numVeh].numTrips);
						if (true == bPickupS_com)
						{
							if (false == Valid_A_Trip(numVeh, seg[numVeh].numTrips))
							{
								cout << "Valid failed" << endl; getchar();
							}
							dbDepartureTime = seg[numVeh].Trip[seg[numVeh].numTrips].endS;
							//Show_A_Trip(numVeh, seg[numVeh].numTrips);
							g_inInitVehNum++;
							cout << "...ok with " << seg[numVeh].Trip[seg[numVeh].numTrips].numCus << " demands" << endl;
						} else
						{
							cout << "...failed" << endl; 
						}
					} else
					{
						cout << "... all routed" << endl;
					}

					//if ((false == bDeliveryTripS) && (false == bC2CTripS) && (false == bPickupS_com)) // Cannot find any possible legs
					//	break;

					if ((true == bPickupS_com) || (true == bC2CTripS) || (true == bPickupS_com))
					{
						startSP = arrSPCandidates[s_SP];
						break;
					}


				} // end for scan s_SP

				if (0 == arrSPCandidates[s_SP])
					break;

				if ((false == bPickupS_com) && (false == bC2CTripS) && (false == bPickupS_com))
					break;
	 
			}

		} while (1);	
#endif

		cout << "\t\t>>>> Vehicle " << numVeh << " has " << Get_Node_Tot_In_Veh(numVeh) << " demands" << endl;

		// Create new 
		if (seg[numVeh].numTrips > 0)
		{
			numVeh++;
			seg[numVeh].numTrips = 0;
		} else
		{
			showSolution();
		}
	} // each loop creates a vehicle

	if (numVeh > g_inInitVehNum)
	{
		numVeh = g_inInitVehNum;
	}

	Update_SP_Status();
//	double dbCurrCostTot;
//	Check_Solution(&dbCurrCostTot);
	//showSolution_Old();
//	showSolution();


	delete [] nextArrTemp;
	delete [] nextArrB;
	delete [] routedTemp;
}

// Buid sequence of legs from SP inStartSP
int Solution::Build_Seq_Leg(int startSP, int inEndSP, double dbDepartureTime)
{
	int s_SP;
	
	int SPCandidateNbr = 0;
	bool bDeliveryTripS = false;
	bool bC2CTripS = false;
	bool bPickupS_com = false;

	Update_SP_Status();

#if Q_DEBUG_INIT_SOL
	cout << "\t\t\t Create legs from SP " << startSP << " to " << inEndSP << endl;
#endif


	//////////////////////////////////////////////////////////////////////////////////////////////////
#if Q_DEBUG_INIT_SOL
					cout << "\t\t\t\t Build delivery of SP " << startSP << " to " << inEndSP << " at " << dbDepartureTime;
#endif
					/* In case that startSP is not SP so we should find a SP that still has unrouted delivery demands
					 * and has ready time < ready time of arrSPCandidates[s_SP]
					 */
					int startSPTmp = startSP;
					if (NODE_SUPPLY_POINT != Get_Node_Type(startSPTmp))
					{
						for (int ii = 1; ii <= nSP; ii++)
						{
							if (numCusDRouted[ii] < problem->numCusDSP[ii]) // this SP ii still has unrouted delivery-customer-demands
							{
								if (problem->nodeSP[ii].sTW1 < problem->nodeSP[inEndSP].sTW1)
								{
									startSPTmp = ii;

									break;
								}
							}
						}
					}
					double dbDepartureTimeTmp = dbDepartureTime;
					if ((0 == seg[numVeh].numTrips) && (0 == dbDepartureTimeTmp))
					{
						dbDepartureTimeTmp = problem->nodeSP[startSP].sTW1; // means this delivery is first trip so need to move from DEPOT to SP
					} else 
					{
						if ((seg[numVeh].Trip[seg[numVeh].numTrips].endNodeIdx != startSPTmp) && (seg[numVeh].Trip[seg[numVeh].numTrips].endNodeIdx > 0))
						{
							dbDepartureTimeTmp += problem->c[seg[numVeh].Trip[seg[numVeh].numTrips].endNodeIdx][startSPTmp];
						} else if (seg[numVeh].Trip[seg[numVeh].numTrips].endNodeIdx == startSPTmp)
						{
							dbDepartureTimeTmp = seg[numVeh].Trip[seg[numVeh].numTrips].endS;
						}
					}

					bDeliveryTripS = Create_DeliveryTrip_Q2(startSPTmp,
										   dbDepartureTimeTmp,
										   inEndSP,
										   Get_Node_Type(inEndSP),
										   0,
										   numVeh,
										   seg[numVeh].numTrips);
					if (true == bDeliveryTripS)
					{
						//Show_A_Trip(numVeh, seg[numVeh].numTrips);
						int inTripIdxTmp, inVehIdxTmp;
						double dbTimeTmp;
						if (true == Get_Node_Info(seg[numVeh].Trip[seg[numVeh].numTrips].lastCus, &dbTimeTmp, &inVehIdxTmp, &inTripIdxTmp))
						{ 
							dbDepartureTime = dbTimeTmp;
							startSP = seg[numVeh].Trip[seg[numVeh].numTrips].lastCus;
							g_inInitVehNum++;
							cout << "...ok with " << seg[numVeh].Trip[seg[numVeh].numTrips].numCus << " demands" << endl;

						} 

					} else
					{
						cout << "...failed" << endl; 
						//if (seg[numVeh].numTrips < 1) // means still no PICKUP/DELIVERY associated to this SP
						//	continue;
					}

					// Build startSP -> c2c demands -> s'
#if Q_DEBUG_INIT_SOL
					cout << "\t\t\t\t Build c2c from (looped) " << startSP << " to " << inEndSP << " at " << dbDepartureTime;
#endif
					do
					{
						bC2CTripS = Create_C2CTrip_Q(startSP,				// Start point
													dbDepartureTime,		// Departure time
													inEndSP,				// EndSP
													0,						// Current capacity
													numVeh,					// Current vehicleIdx
													seg[numVeh].numTrips);	// Current tripIdx

						int inTripIdxTmp, inVehIdxTmp;
						double dbTimeTmp;
						if (true == bC2CTripS)
						{
							if (true == Get_Node_Info(seg[numVeh].Trip[seg[numVeh].numTrips].lastCus, &dbTimeTmp, &inVehIdxTmp, &inTripIdxTmp))
							{ 
								dbDepartureTime = dbTimeTmp;
								startSP = seg[numVeh].Trip[seg[numVeh].numTrips].lastCus;
								bC2CTripS = true;
								g_inInitVehNum++;
								cout << "...ok with " << seg[numVeh].Trip[seg[numVeh].numTrips].numCus << " demands" << endl;
							}
						} else
						{
							cout << "...failed" << endl; 
							break;
						}
					} while (1);

					// Build startSP --> PICKUP of demand s'
#if Q_DEBUG_INIT_SOL
					cout << "\t\t\t\t Build pickup from " << startSP << " to " << inEndSP << " at " << dbDepartureTime;
#endif

					if (numCusPRouted[inEndSP] < numCusPSP[inEndSP]) // re-check to make sure that existence of unrouted PICKUP customers.
					{
						bPickupS_com = Create_PickupTrip_Q(
									startSP,				// departure SP index: can be DEPOT, SP, last C2C-delivery, last delivery
					   				dbDepartureTime,		// departure time at departSPIdx
									inEndSP,				// can be DEPOT to pickup or SP
									NODE_SUPPLY_POINT,			// 0 - depot; 1 - pickup; 2- supply point to delivery
									0,			// current vehicle capacity
									numVeh,				
									seg[numVeh].numTrips);
						if (true == bPickupS_com)
						{
							if (false == Valid_A_Trip(numVeh, seg[numVeh].numTrips))
							{
								cout << "Valid failed" << endl; getchar();
							}
							dbDepartureTime = seg[numVeh].Trip[seg[numVeh].numTrips].endS;
							//Show_A_Trip(numVeh, seg[numVeh].numTrips);
							g_inInitVehNum++;
							cout << "...ok with " << seg[numVeh].Trip[seg[numVeh].numTrips].numCus << " demands" << endl;
						} else
						{
							cout << "...failed" << endl; 
						}
					} else
					{
						cout << "... all routed" << endl;
					}


	//////////////////////////////////////////////////////////////////////////////////////////////////
	
	//return Get_Node_Tot_In_Veh(numVeh);
	return seg[numVeh].numTrips;
}

//2 2 2 5
void Solution::initSol(int typeofseed, int typeofINIT, int typeofAssCusPToSP, int valueFEE)
{
   int i,j;
   
   for (i=1; i<=nSP; i++) 
   {   
       numCusDRouted[i]=0; 
	   numCusPRouted[i]=0;
   }
   for (i=startidP;i<=endidD;i++) {routed[i]=false;nextArr[i]=0;}
  
   nextArrTemp = new int[totalNODE1];
   nextArrB = new int [totalNODE1];
   routedTemp = new bool[totalNODE1];
   
  
   numVeh=0; 			   							
   bool cont=1;
   int numTrip, startSP, nextSP,type;
   double leave_SP;
   

   AssignCusPToSP(typeofAssCusPToSP);
   while (cont) //each loop create one vehicle
   {
	   for (startSP = 1;startSP<=nSP;startSP++)
		   if (numCusPRouted[startSP] < numCusPSP[startSP] || numCusDRouted[startSP] < problem->numCusDSP[startSP]) break;

       if (startSP <= nSP) // still exists unrouted customers:
	   {
		   if (numCusPRouted[startSP] < numCusPSP[startSP]) // exist unrouted pickup customers:
		   {
			   Create_FirstPickupTripLeavingDepot(startSP);
			   cout<<"First pickup trip of veh "<<numVeh<<": cost = "<<seg[numVeh].Trip[0].cost<<"; endS = "<<seg[numVeh].Trip[0].endS<<"; assSP = "<<seg[numVeh].Trip[0].assSP<<"; lastC = "<<seg[numVeh].Trip[0].lastCus<<endl;
			   if (numCusDRouted[startSP] < problem->numCusDSP[startSP]) //exist also delivery customers not routed:
			   {
			       leave_SP =  seg[numVeh].Trip[0].leaveSP + problem->nodeSP[startSP].load;
	   			   numTrip = 1;
			  	   type = Create_DeliveryTrip(startSP, numTrip, leave_SP, nextSP, typeofseed, typeofINIT, valueFEE);
				   //returns 0 or 1 or 2: 0: create startSP-d-depot; 1: create startSP-d-p-nextSP; 2: create startSP-d-nextSP
			   }
			   else
			   {
			       leave_SP =  seg[numVeh].Trip[0].leaveSP;
				   numTrip = 0;
			  	   type = Create_PickupTrip(startSP, numTrip, leave_SP, nextSP, typeofseed, typeofINIT, valueFEE);
				   //returns 0 or 1 or 2: 0: cannot create new trip --> (p-startSP) already last trip; 1: created a new pickup trip leaving startSP; 2: a NULL trip connecting 2 sp (startSP, nextSP) 
			   }
		   }
		   else //only unrouted delivery customers
		   {
			   numTrip = 0;
			   leave_SP = problem->nodeSP[startSP].sTW2 + problem->nodeSP[startSP].load;
			   type = Create_DeliveryTrip(startSP, numTrip, leave_SP, nextSP, typeofseed, typeofINIT, valueFEE);
		   }//end only unrouted delivery customers
		  
		   while (type > 0) //type = 0: already last trip; =1 or = 2: not last trip yet
		   {
			   startSP = nextSP;
			   if (type == 1) //having: pickup trip - startSP.....
			   {
				   if (numCusDRouted[startSP] < problem->numCusDSP[startSP]) //nextTrip is deliverytrip
				   {
                       leave_SP = seg[numVeh].Trip[numTrip].leaveSP + problem->nodeSP[startSP].load;
					   numTrip++;
				       type = Create_DeliveryTrip(startSP,numTrip, leave_SP, nextSP, typeofseed, typeofINIT, valueFEE);
				   }
				   else
				   {
					   leave_SP = seg[numVeh].Trip[numTrip].leaveSP;
				       type = Create_PickupTrip(startSP,numTrip, leave_SP, nextSP, typeofseed, typeofINIT, valueFEE);
				   }
			   }
			   else //if (type==2) //having: delivery trip - startSP.... OR having pickup-SP -- startSP... --> nextTrip is delivery trip of startSP
			   {
				  leave_SP = seg[numVeh].Trip[numTrip].arriveSP + problem->nodeSP[startSP].load;
		          numTrip++;
				  type = Create_DeliveryTrip(startSP,numTrip, leave_SP, nextSP, typeofseed, typeofINIT, valueFEE);
			   }
		   }
		   seg[numVeh].numTrips = numTrip+1;
		   //cout<<"----------Finish create vehicle "<<numVeh<<"; numTrips = "<<seg[numVeh].numTrips<<endl;
		   numVeh++;
	   }//still has unrouted customers
	   else cont = 0;
   }//end while (cont) //each loop create one vehicle

   //Update all information for the created solution:

   double CC = 0; double buon;
   for (i=0;i<numVeh;i++)
   {
	   buon = CC;
	   for (j=0;j<seg[i].numTrips;j++)
		   CC += seg[i].Trip[j].cost;
	   if (seg[i].Trip[0].Type)
		   CC += problem->c[0][seg[i].Trip[0].assSP];
	   //else buon += problem->cP[0][seg[i].Trip[0].firstCus];
	   int lastT = seg[i].numTrips -1;
	   if (seg[i].Trip[lastT].Type == 0)
		   CC += problem->c[seg[i].Trip[lastT].assSP][0];
	   buon = CC - buon;
	   cout<<"Cost of vehicle "<<i<<" =  "<<buon<<endl;
   }
   cout<<"CALL calCostFrom Beginning"<<endl;
   calCostFromBeginning();

   if (PDSDIF(CC, cost))
   {
	   cout<<"Solution::initSol   ERROR cost of solution: calCostFromBeginning = "<<cost<<" != cost from initSol = "<<CC<<endl;
	   //exit(-1);
   }

   double checkC = cost;
   for (i=0;i<numVeh;i++)
   {
	   double costSeg = 0; double fitSeg = 0;
	   for (j=0;j<seg[i].numTrips;j++)
	   {
		   if (seg[i].Trip[j].Type==0) 
		   {
			   CalInfromationTripP(i, j); 
			   //cout<<"Pick("<<i<<", "<<j<<"): "<<seg[i].Trip[j].cost<<endl; 
		   }
		   else if (seg[i].Trip[j].Type==1) 
		   {
			   CalInfromationTripD(i, j); 
		   	   //cout<<"Delivery("<<i<<", "<<j<<"): "<<seg[i].Trip[j].cost<<endl;
		   }
		   costSeg += seg[i].Trip[j].cost; fitSeg += seg[i].Trip[j].fitness;
	   }
	  // cout<<"----- COST OF VEH "<<i<<": "<<costSeg<<endl;
	   seg[i].cost = costSeg; seg[i].fitness = fitSeg;
   }
   calFitCostSumTrip();
   if (PDSDIF(checkC, cost))
   {
	   cout<<"Solution::initSol   ERROR cost of solution: calCostFromBeginning = "<<checkC<<"; calCostSumTrip = "<<cost<<endl;
	   exit(-1);
   }
   numVehUsed = numVeh;

   delete [] nextArrTemp;
   delete [] nextArrB;
   delete [] routedTemp;
}
/*
 * S3. Assign randomly PICKUP to the nearest supply point...
 * 
 */
void Solution::AssignCusPToSP_Q(void){
	//Estimate pickup demands based on total delivery demands at each s
	int source[PDS_MAX_NUM_CUSP]; 
	int per[PDS_MAX_NUM_CUSP]; 
	int curCAP[PDS_MAX_NUM_SUPPLYPOINTS];
	int idCus, idS, sp;
	int i, j;

#if Q_DEBUG_PU_ASSIGNMENT
	cout << "\tS.3 Assign PICKUP to supply point" << endl;
#endif

	//Initiate
	for (i = 0; i <= nSP; i++) numCusPSP[i] = 0;
	for (i = 1; i <= nP; i++) source[i]=i;
	for (i = 1; i <= nSP; i++) curCAP[i] = 0;

	//create a permutation for PICKUP demands
	RandPermutation(nP,source,per); 

#if Q_DEBUG_PU_ASSIGNMENT
	cout << "\t\t-PICKUP permutation: (FIXED!)" << endl;
	cout << "\t\t";
	for (i=1; i<=nP; i++){
		cout << per[i] << " ";
	}
	cout << endl;
#endif 

	//For all PICKUP demands
	for (i = 1;  i<= nP; i++){
		idCus = per[i] + nSP + 2*nOrder;  // PICKUP demand index
#if Q_DEBUG_PU_ASSIGNMENT
		cout << "\t\t\t" << idCus;
#endif
		if (problem->node[idCus].numSP > 1){ // More than 1 supply point can serve this demand
			idS = Rand(1, 1); //assigned this demand to the nearest supply point
			sp = problem->node[idCus].sp[idS]; // Get supply point id
			if (curCAP[sp] + problem->node[idCus].capacity > problem->capDSP[sp]) //if exceed cap:
			{
				//TODO: Only select supply id that is large enough to accommodate this demands
				if (curCAP[sp] + problem->node[idCus].capacity > problem->capDSP[sp])
				{
					idS = Rand(2, problem->node[idCus].numSP);
					sp = problem->node[idCus].sp[idS];
				}
#if Q_DEBUG_PU_ASSIGNMENT
				cout << " " << problem->node[idCus].numSP << " supply points. The nearest SP " 
					<< problem->node[idCus].sp[1] << ", using randomly SP " << sp << " instead" << endl; 
#endif
			} else {
#if Q_DEBUG_PU_ASSIGNMENT
				cout << " " << problem->node[idCus].numSP << " supply points. The nearest SP " 
					<< problem->node[idCus].sp[1] << " is used" << endl; 
#endif
			}
		} else {
			sp = problem->node[idCus].sp[1]; // Only 1 supply point can serve this demand
#if Q_DEBUG_PU_ASSIGNMENT
			cout << " only 1 supply point " << sp << endl;
#endif
		}

		//Got supply Id, update all 
		curCAP[sp] += problem->node[idCus].capacity; // local variables
		SPToCusP[idCus] = sp;						// Relationship PICKUP index -> Supply point Id
		numCusPSP[sp]++;							// Total of assigned PICKUP demands by supply point Id
		CusPSP[sp][numCusPSP[sp]] = idCus;			// Relationship Supply Point Ids -> PICKUP index
		// Use SPToCusP[], numCusPSP[] and CusPSP[][] to handle status of relationship between PICKUP index <-> SUPPLY POINT id
	}
#if Q_DEBUG_PU_ASSIGNMENT
	cout << "***DUMPING SUPPLY POINT ASSIGNMENT" << endl;
	int inAssignedPUTot = 0;
	for (i = 1; i <= nSP; i++)
	{
		cout << "Supply point " << i << " serves " << numCusPSP[i] << " PICKUPs: ";
		for (j=1;j<=numCusPSP[i];j++)
		{
			cout << CusPSP[i][j] << " ";
		}
		inAssignedPUTot += numCusPSP[i];
		cout << endl;
	}

	if (inAssignedPUTot != nP)
	{
		cout << "****Critical ERROR!*****" << endl; getchar();
	} else
	{
		cout << inAssignedPUTot << "/" << nP << " assigned PICKUP nodes" << endl;
	}

	cout << "Current capacity of SUPPLY POINTs after ASSIGNMENT (SUPPLY POINT Id | Capacity/Maximum)" << endl;
	for (i = 1; i <= nSP; i++)
	{
		cout << i << " " << curCAP[i] << "/" << problem->capDSP[i] << endl;
	}

	// DELIVERY-CUSTOMER-
	int inAssignedDETot;
	for (i = 1; i <= nSP; i++)
	{
		inAssignedDETot = 0;
		cout << "Supply point " << i << " serves " << " DELIVERYs: ";
		for (j = startidD; j <= endidD; j++)
		{
			if (problem->node[j].zone == i)
			{
				cout << j << " ";
				inAssignedDETot++;
			}			
		}	
		cout << endl << "\t SP " << i << " servers " << inAssignedDETot << " DELIVERY demands" << endl;
	}	

	cout << "***END of DUMPING SUPPLY POINT ASSIGNMENT" << endl;
#endif
}

void Solution::AssignCusPToSP(int typeofAssCusPToSP)
{
	int TT = problem->endidP + 1;
	int *SPToCusP = new int[TT];

	int i,j;
	for (i=0;i<=nSP;i++) numCusPSP[i] = 0;

	if (typeofAssCusPToSP == 1) //Assign each pickup to its closest sp:
	{
		for (i=startidP;i <= endidP;i++)
		{
			j = problem->node[i].sp[1]; //closest sp of customer i
			SPToCusP[i] = j;
			numCusPSP[j]++; 
			CusPSP[j][numCusPSP[j]] = i;
		}
	}
	else if (typeofAssCusPToSP == 2)
	{
		//Each sp s services a number of its pickup customers closest to it with total demand not exceed the AVG CAP of pick
        int source[PDS_MAX_NUM_SUPPLYPOINTS]; int per[PDS_MAX_NUM_SUPPLYPOINTS];
		for (i=1;i<=nSP;i++) source[i]=i;
		RandPermutation(nSP,source,per);
		int sp, idCus, CAPT;
		for (i=startidP;i<=endidP;i++) SPToCusP[i] = -1;
        for (i=1;i<=nSP;i++)
		{
			sp = per[i]; CAPT = 0;
			for (j=1;j<=problem->numCusPAvailSP[sp];j++)
			{
				idCus = problem->closestPSP[sp][j]; //is pickup cus closest #jth of sp
				//cout<<"idCus = "<<idCus<<";startidP = "<<startidP<<"; endidP = "<<endidP<<endl;
				if (SPToCusP[idCus] == -1) 
				{
				   SPToCusP[idCus]=sp;
				   numCusPSP[sp]++; 
				   CusPSP[sp][numCusPSP[sp]] = idCus;
				   CAPT += problem->node[idCus].capacity;
				   if (CAPT > problem->capDSP[sp]) break;
				}
			}
		}
		for (i=startidP;i<=endidP;i++)
			if (SPToCusP[i]== -1) //pickcus i is not assigned to any sp yet--> need to assign
		    {
				j = problem->node[i].sp[1]; //closest sp of customer i
				SPToCusP[i] = j;
				numCusPSP[j]++; 
				CusPSP[j][numCusPSP[j]] = i;
		    }
      for (i=1;i<=nSP;i++)
	  {
		  cout<<"List cusP of sp "<<i<<": ";
		  for (j=1;j<=numCusPSP[i];j++)
			  cout<<CusPSP[i][j]<<", ";
	      cout<<endl;
	  }
	}
	else
	{
		//Estimate pickup demands based on total delivery demands at each s
        int source[PDS_MAX_NUM_CUSP]; int per[PDS_MAX_NUM_CUSP]; int curCAP[PDS_MAX_NUM_SUPPLYPOINTS];
		int idCus, idS, sp;
		for (i=1;i<=nP;i++) source[i]=i;
		for (i=1;i<=nSP;i++) curCAP[i] = 0;
		RandPermutation(nP,source,per); //create a permutation for pickup cus
		for (i=1;i<=nP;i++)
		{
			idCus = per[i] + nSP;
			if (problem->node[idCus].numSP > 1)
			{
				idS = Rand(1,2); //assign randomly to one of the 2 nearest sp
				sp = problem->node[idCus].sp[idS];
				if (curCAP[sp] + problem->node[idCus].capacity > problem->capDSP[sp]) //if exceed cap:
				{
					if (idS == 1) sp = problem->node[idCus].sp[2];
					else sp = problem->node[idCus].sp[1];
					if (curCAP[sp] + problem->node[idCus].capacity > problem->capDSP[sp]) //if exceed cap--> randomly to any sp
					{
						idS = Rand(1, problem->node[idCus].numSP);
						sp = problem->node[idCus].sp[idS];
					}
				}
			}
			else sp = problem->node[idCus].sp[1];
			curCAP[sp] += problem->node[idCus].capacity;
		    SPToCusP[idCus]=sp;
		    numCusPSP[sp]++; 
		    CusPSP[sp][numCusPSP[sp]] = idCus;
		}
	}
	delete [] SPToCusP;
}
 
 //create first pickup trip leaving depot to go to assignSP:
void Solution::Create_FirstPickupTripLeavingDepot(int assignSP)
{
	int i,j, idCus;
	double ArrTime, ArrTime1;
	int goWS, WSIDtemp, WSID;


    //cout<<"Tao vehicle thu "<<idVeh<<endl;
	seg[numVeh].Trip[1].assSP = assignSP;
   
    //1.Insert a pickup customer as the first customer of current trip:
  
	 double costMINI = PDS_INFINITY; double temp, startSMINI; int seed;
	 for (i=1;i<=numCusPSP[assignSP];i++)
	 {
		 idCus = CusPSP[assignSP][i];
		 if (routed[idCus] == 0)
		 { 
			 ArrTime = problem->node[idCus].sTW + problem->node[idCus].duration + problem->c[idCus][assignSP];
             if (PDSINRANGE(ArrTime, problem->nodeSP[assignSP].sTW1, problem->nodeSP[assignSP].eTW1))
			 {
				 temp = problem->c[0][idCus] + problem->c[idCus][assignSP];
				 if (temp < costMINI)
				 {
					 seed = idCus;
					 costMINI = temp;
					 goWS = NO_WS;
					 startSMINI = problem->node[idCus].sTW;
				 }	
			 }
			 else 
			 {
				 ArrTime = problem->node[idCus].sTW + problem->node[idCus].duration + problem->disCWSSP[idCus][assignSP];
				 double tt = ArrTime - problem->nodeSP[assignSP].eTW1;
				 if (tt > eps)
				 {
					 temp = problem->c[0][idCus] + problem->c[idCus][assignSP];
					 if (temp < costMINI)
					 {
						seed = idCus;
						costMINI = temp;
						goWS = NO_WS;
						startSMINI = problem->nodeSP[assignSP].eTW1 - problem->c[idCus][assignSP] - problem->node[idCus].duration;
					 } 
				 }
				 else
				 {
					 temp = problem->c[0][idCus] + problem->disCWSSP[idCus][assignSP];
					 if (temp < costMINI)
					 {
						seed = idCus;
						costMINI = temp;
						goWS = problem->CWSSP[idCus][assignSP];
						startSMINI = problem->node[idCus].sTW;
					 } 
				 }
			 }
		 }
	 }

	 routed[seed]=1;  
	 seg[numVeh].Trip[1].Type = 0;
     seg[numVeh].Trip[1].firstCus = seed; //id of the first Customer of Leg
	 seg[numVeh].Trip[1].lastCus = seed; //id of the first Customer of Leg
	 seg[numVeh].Trip[1].numCus = 1; //#Customers in the leg
	 seg[numVeh].Trip[1].capacity = problem->node[seed].capacity;
	 nextArr[seed] = 0; //just correct for initial solution
	 seg[numVeh].Trip[1].cost = costMINI;
     seg[numVeh].Trip[1].waitingS = goWS;
	 //cout<<"CREATE FIRST PICKUP TRIP of veh "<<numVeh<<": "<<seed<<",   WS = "<<goWS<<"; sp = "<<assignSP<<"; cost = "<<costMINI<<endl;
	 seg[numVeh].Trip[1].feasible = 1;
	 startS[seed] = startSMINI;
	 depart[seed] = startSMINI + problem->node[seed].duration;
	 seg[numVeh].Trip[1].endS = depart[seed];
	 numCusPRouted[assignSP]++;


     // 2. Continue to insert pickup customers:
     //starting to find pickup customer to insert into the current trip (depot, assignSP):
     bool cont=true;  
	 int curC, nextC, preINS, nextINS, insert_after, IDinsert;
	 double varcost,TOTALTIME,c1, c2, c2OPT;

	 if (numCusPRouted[assignSP] < numCusPSP[assignSP])
	 {
		 do
		 {
			 insert_after = -1; c2OPT = -PDS_INFINITY;
		 	 for (i=1;i<=numCusPSP[assignSP];i++)
			 {
					 idCus = CusPSP[assignSP][i];
					 if (routed[idCus]==0 && seg[numVeh].Trip[1].capacity + problem->node[idCus].capacity < problem->Q)
					 {
						 bool ok = 1;
						 //1. First try to insert at the beginning of the trip:
						 nextINS = seg[numVeh].Trip[1].firstCus;
						 ArrTime = problem->node[idCus].sTW + problem->node[idCus].duration + problem->c[idCus][nextINS];
						 temp = problem->node[nextINS].eTW - ArrTime;
						 if (temp > 0) 
						 {
							 ArrTime = PDS_MAX(ArrTime, problem->node[nextINS].sTW) + problem->node[nextINS].duration;
							 curC = nextINS; nextC = nextArr[nextINS];
							 while (nextC > 0)
							 {
								 ArrTime += problem->c[curC][nextC];
								 temp = ArrTime - problem->node[nextC].eTW;
								 if (temp > eps) {ok = 0; break;} //vioTW at nextC
								 else
								 {
									 ArrTime = PDS_MAX(ArrTime, problem->node[nextC].sTW) + problem->node[nextC].duration;
									 curC = nextC; nextC = nextArr[curC];
								 }
							 }
							 if (ok) //curC is now pointed to lastC
							 {
	                             ArrTime1 = ArrTime + problem->c[curC][assignSP];
								 temp =  problem->nodeSP[assignSP].eTW1 - ArrTime1;
								 if (temp > eps) 
								 {
									 if (PDSINRANGE(ArrTime1, problem->nodeSP[assignSP].sTW1, problem->nodeSP[assignSP].eTW1))
										 WSIDtemp = NO_WS;
									 else
									 {
										 ArrTime1 = ArrTime + problem->disCWSSP[curC][assignSP];
										 temp = ArrTime1 - problem->nodeSP[assignSP].eTW1;
										 if (temp > eps) ok = 0; //too late to go to sp through WS
										 else WSIDtemp = problem->CWSSP[curC][assignSP];
									 }
									 if (ok)
									 {
										 c1 = problem->c[0][idCus] + problem->c[idCus][nextINS] - problem->c[0][nextINS];
										 if (goWS != WSIDtemp)
										 {
											 if (goWS != NO_WS) //before go to WS, after insert don't need to go to WS:
												 c1 += (problem->c[curC][assignSP] - problem->disCWSSP[curC][assignSP]);
											 else 
											 {
													 cout<<"ERROR Create_FirstPickupTripLeavingDepot before insert go to sp, after insert go to WS"<<endl;
													 cout<<"Trying to insert pickup cus "<<idCus<<" at the beginning of: ";
													 showTripCost(numVeh,0);
													 exit(-1);
											 }
										 }
										 c2 = problem->c[idCus][assignSP]-c1;
										 if (c2 > c2OPT) {c2OPT=c2; varcost=c1; IDinsert=idCus; 
														  insert_after = 0;WSID=WSIDtemp;
														  TOTALTIME = ArrTime;
														 } 
									 }
								 }							 
							 }//end if (ok)
						 }
						 //else vioTW at first customer of trip
						
                         //2. try to insert customer idCus after each pickup customer j of the trip:
						 preINS = seg[numVeh].Trip[1].firstCus;
						 for (j=1;j<=seg[numVeh].Trip[1].numCus;j++)
						 {
							ok = 1;
						    ArrTime = depart[preINS] + problem->c[preINS][idCus];
						    temp = problem->node[idCus].eTW -  ArrTime;
							if (temp > eps)
							{
								ArrTime = PDS_MAX(ArrTime, problem->node[idCus].sTW) + problem->node[idCus].duration;
								//start checking TW from idCus to the end of the trip:
								curC = idCus; nextC = nextArr[preINS];
								while (nextC > 0)
								{
									ArrTime += problem->c[curC][nextC];
									temp = ArrTime - problem->node[nextC].eTW;
									if (temp > eps) {ok = 0;break;} //vioTW at nextC
									ArrTime = PDS_MAX(ArrTime, problem->node[nextC].sTW) + problem->node[nextC].duration;
									curC = nextC; nextC = nextArr[nextC];
								}
								//now curC point to the last
								if (ok)
								{
									 ArrTime1 = ArrTime + problem->c[curC][assignSP];
                                     temp = problem->nodeSP[assignSP].eTW1 - ArrTime1;
									 if (temp > eps)
									 {
										 if (PDSINRANGE(ArrTime1,problem->nodeSP[assignSP].sTW1, problem->nodeSP[assignSP].eTW1))
											 WSIDtemp=NO_WS;
										 else
										 {
                                              ArrTime1 = ArrTime + problem->disCWSSP[curC][assignSP];
											  temp = ArrTime1 - problem->nodeSP[assignSP].eTW1;
											  if (temp > eps) ok=0; //too late to go to sp through WS
											  else WSIDtemp = problem->CWSSP[curC][assignSP];
										 }
										 if (ok)
										 {
												 if (j != seg[numVeh].Trip[1].numCus) //nextINS != assignSP								        
												 {
													 nextINS = nextArr[preINS];
													 c1 = problem->c[preINS][idCus] + problem->c[idCus][nextINS] - problem->c[preINS][nextINS];
													 if (goWS != WSIDtemp)
													 {
														 if (goWS != NO_WS) //before go to WS, after insert don't need to go to WS:
															 c1 += (problem->c[curC][assignSP] - problem->disCWSSP[curC][assignSP]);
														 else 
														 {
															 cout<<"ERROR Create_FirstPickupTripLeavingDepot before insert go to sp directly, after insert go to WS"<<endl;
															 cout<<"Trying to insert pickup "<<idCus<<" after "<<preINS<<": ";
															 showTripCost(numVeh,0);
															 exit(-1);
														 }
													 }
												 }
												 else //insert to the end of the leg:
												 {
													 c1 = problem->c[preINS][idCus];
													 if (goWS==NO_WS) //before insert customer idCus, go to sp directly
													 {
														 if (WSIDtemp ==NO_WS) c1 += (problem->c[idCus][assignSP] - problem->c[preINS][assignSP]);
														 else 
														 {
															 cout<<"Create_FirstPickupTripLeavingDepot  ERROR before insert go to sp directly, after insert need to go to WS"<<endl; 
															 cout<<"Trying to insert pickup "<<idCus<<" at the end of the trip: ";
															 showTripCost(numVeh,0);
															 exit(-1);
														 }
													 }
													 else //before insert customer idCus, go to WS:
													 {
														 if (WSIDtemp == NO_WS) c1 += (problem->c[idCus][assignSP] - problem->disCWSSP[preINS][assignSP]);
														 else c1+=(problem->disCWSSP[idCus][assignSP] - problem->disCWSSP[preINS][assignSP]);
													 }
												 }
												 c2 = problem->c[idCus][assignSP]-c1;
												 if (c2 > c2OPT) {c2OPT=c2; varcost=c1; IDinsert=idCus; 
																  insert_after = preINS;WSID=WSIDtemp;
																  TOTALTIME = ArrTime;} 
										 }//else too early to go to sp directly, but go through WS too late
									} //else vioTW at assignSP
								}//end if (ok): //everything is fine till last cus
							}//end else:not vioTW at idCus
                            preINS = nextArr[preINS];
						 }//end for
					 }//end if routedP[idCus]==0...
			 }//end for: try all unrouted pickup customers assigned to assignSP
			 if (insert_after!=-1)
			 {
				  //cout<<"Insert customer "<<IDinsert<<" after "<<insert_after<<": ";
				  if (insert_after == 0)
				  {
					  int pre = seg[numVeh].Trip[1].firstCus;
					  seg[numVeh].Trip[1].firstCus = IDinsert;
					  nextArr[IDinsert] = pre;
					  startS[IDinsert] = problem->node[IDinsert].sTW;
					  depart[IDinsert] = startS[IDinsert] + problem->node[IDinsert].duration;
					  updateStartSP_FEASIBLETRIP(numVeh,0,IDinsert,nextArr[IDinsert]);
				  }
				  else if (insert_after == seg[numVeh].Trip[1].lastCus) //insert at the end of the leg:
				  {
					  nextArr[insert_after] = IDinsert;
					  seg[numVeh].Trip[1].lastCus=IDinsert;
					  nextArr[IDinsert]=0;
					  ArrTime = depart[insert_after] + problem->c[insert_after][IDinsert];
		              startS[IDinsert] = PDS_MAX(ArrTime, problem->node[IDinsert].sTW);
		              depart[IDinsert] = startS[IDinsert] + problem->node[IDinsert].duration;
					  //cout<<"*************Insert customer "<<IDinsert<<" at the end of the leg: after "<<insert_after<<endl;
				  }
				  else //insert at the middile of the leg:
				  {
					  int tt=nextArr[insert_after];
					  nextArr[insert_after]=IDinsert;
					  nextArr[IDinsert]=tt;
					  updateStartSP_FEASIBLETRIP(numVeh,1,insert_after,IDinsert);
					  //cout<<"***********Insert customer "<<IDinsert<<" in the middle of the leg: after "<<insert_after<<endl;
				  }
				  seg[numVeh].Trip[1].numCus++;seg[numVeh].Trip[1].waitingS = WSID;
				  routed[IDinsert]=1;
				  seg[numVeh].Trip[1].capacity += problem->node[IDinsert].capacity;
				  goWS = WSID;
				  seg[numVeh].Trip[1].cost += varcost;

				  seg[numVeh].Trip[1].endS = TOTALTIME;
				  numCusPRouted[assignSP]++;
				  if (numCusPRouted[assignSP] == numCusPSP[assignSP]) cont = 0;
			}
			else cont = 0;  //can't find any customer to insert into the current leg
		 }while (cont);
	 } //end if (numCusPRouted[assignSP] < numCusPSP[assignSP])
     int lastC = seg[numVeh].Trip[1].lastCus;
	 if (goWS == NO_WS)
		 ArrTime = seg[numVeh].Trip[1].endS + problem->c[lastC][assignSP];
	 else
		 ArrTime = seg[numVeh].Trip[1].endS + problem->disCWSSP[lastC][assignSP];
	 seg[numVeh].Trip[1].leaveSP = PDS_MAX(ArrTime, problem->nodeSP[assignSP].sTW1) + problem->nodeSP[assignSP].unload;

}

void Solution::updateStartSP_FEASIBLETRIP(int idVeh, int idTrip, int preC, int idCus) //update startS array from idCus on feasible trip(idVeh, idTrip): idCus is not the first customer
{
	double ArrTime;
	while (idCus > 0)
	{
		ArrTime = depart[preC] + problem->c[preC][idCus];
		startS[idCus] = PDS_MAX(ArrTime, problem->node[idCus].sTW);
		depart[idCus] = startS[idCus] + problem->node[idCus].duration;
		preC = idCus; idCus = nextArr[idCus];
	}
}

int Solution::Create_DeliveryTrip(int startSP, int &numTrip, double leave_startSP, int &nextSP, int typeofseed, int typeofINIT, int valueFEE)
{
	   //Create a delivery trip (idVeh, idTrip) of sp startSP where the time to leave startSP is leave_startSP:
	   int i,endSP;
	   int createTrip; //= 0: last delivery trip; = 1: d-p trip; =2: only delivery trip
	   double feeMIN = PDS_INFINITY;
       bool canRoute = 0; 
	   //cout<<"CALL Create_DeliveryTrip: startSP = "<<startSP<<", numVeh = "<<numVeh<<", numTrip = "<<numTrip<<endl;
		
			   for (endSP = startSP+1;endSP<=nSP;endSP++)
				  if (numCusPRouted[endSP] < numCusPSP[endSP] || numCusDRouted[endSP] < problem->numCusDSP[endSP]) //exist unrouted customers in sj
					  Init_NewSolomonI1_NewDeliveryTrip(startSP, endSP, numTrip,leave_startSP, feeMIN, nextSP, createTrip, typeofseed,valueFEE,typeofINIT,canRoute);

			   if (!canRoute) 
			   {
				   Init_NewSolomonI1_NewDeliveryTrip(startSP,0, numTrip, leave_startSP, feeMIN, nextSP, createTrip, typeofseed,valueFEE,typeofINIT,canRoute);
				   //cout<<"At initSol: Create xong last delivery trip cho vehicle "<<numVeh<<": ";
				  //showTripCost(numVeh,numTrip+3);
			   }
			   seg[numVeh].Trip[numTrip] = seg[numVeh].Trip[numTrip+3]; //bestTrip
			 
			   //Update all information for new trip:.....
			   int curC = seg[numVeh].Trip[numTrip].firstCus;

			   for (i=1;i<=seg[numVeh].Trip[numTrip].numCus;i++)
			   {
					routed[curC]=1;
					nextArr[curC]=nextArrB[curC];
					curC = nextArr[curC];
			   }
			   nextArr[curC]= 0;
			   numCusDRouted[startSP] += seg[numVeh].Trip[numTrip].numCus; 

			   /*cout<<"Just create a delivery trip "<<numTrip<<": numC = "<<seg[numVeh].Trip[numTrip].numCus<<"; firstC = "<<seg[numVeh].Trip[numTrip].firstCus<<"; sp = "<<seg[numVeh].Trip[numTrip].assSP<<"; type = "<<seg[numVeh].Trip[numTrip].Type<<endl;
			   int buc = seg[numVeh].Trip[numTrip].firstCus;
			   while (buc > 0)
			   {
				   cout<<buc<<"  ";
				   buc = nextArrD[buc];
			   }
			   cout<<endl;*/
			   //cout<<"Create Deltrip("<<numVeh<<", "<<numTrip<<") = "<<seg[numVeh].Trip[numTrip].cost<<endl;

			   if (createTrip >0)
			   {
					if (createTrip==1) //create trips: s-delivery - pickup - startSP
					{
					   numTrip = numTrip+1;
					   seg[numVeh].Trip[numTrip] = seg[numVeh].Trip[numTrip+3]; //bestTrip
					   if (seg[numVeh].Trip[numTrip].assSP > nSP)
					   {
						   cout<<"Create xong mot pickup trip "<<numTrip<<" cho vehicle "<<numVeh<<endl;
						   cout<<"ERRORRRRRRRRRRRRRRRRRRR: > nSP"<<endl;
						   exit(-1);
					   }
					
					   //Update all information for new pickup trip:.....
					   int curC = seg[numVeh].Trip[numTrip].firstCus;
					   for (i=1;i<=seg[numVeh].Trip[numTrip].numCus;i++)
					   {
							routed[curC]=1;
							nextArr[curC]=nextArrB[curC];
							curC = nextArr[curC];
					   }
					   nextArr[curC]=0;
					   numCusPRouted[nextSP] += seg[numVeh].Trip[numTrip].numCus; 
					   int lastC = seg[numVeh].Trip[numTrip].lastCus; double arrTime;
                       if (seg[numVeh].Trip[numTrip].waitingS == NO_WS)
					 	   arrTime = seg[numVeh].Trip[numTrip].endS + problem->c[lastC][nextSP];
					   else
						   arrTime = seg[numVeh].Trip[numTrip].endS + problem->disCWSSP[lastC][nextSP];
					   arrTime = PDS_MAX(arrTime, problem->nodeSP[nextSP].sTW1);
					   seg[numVeh].Trip[numTrip].leaveSP = arrTime + problem->nodeSP[nextSP].unload;

					   /*cout<<"Just create a pickup trip "<<numTrip<<": numC = "<<seg[numVeh].Trip[numTrip].numCus<<"; firstC = "<<seg[numVeh].Trip[numTrip].firstCus<<"; sp = "<<seg[numVeh].Trip[numTrip].assSP<<endl;
					   int buc = seg[numVeh].Trip[numTrip].firstCus;
					   while (buc > 0)
					   {
						   cout<<buc<<"  ";
						   buc = nextArrP[buc];
					   }
					   cout<<endl;*/
				       //cout<<"Create Picktrip("<<numVeh<<", "<<numTrip<<") = "<<seg[numVeh].Trip[numTrip].cost<<endl;
				   }
				   else //create delivery trip only: startSP - del - nextSP --> at nextSP vehicles has to LOAD:
				   {
					   int lastC = seg[numVeh].Trip[numTrip].lastCus; double arrTime;
					   if (seg[numVeh].Trip[numTrip].waitingS == NO_WS)
						   arrTime = seg[numVeh].Trip[numTrip].endS + problem->c[lastC][nextSP];
					   else arrTime = seg[numVeh].Trip[numTrip].endS + problem->disCWSSP[lastC][nextSP];
					   arrTime = PDS_MAX(arrTime, problem->nodeSP[nextSP].sTW2);
					   seg[numVeh].Trip[numTrip].arriveSP = arrTime; 
					   /*cout<<"Just create a ONLY delivery trip "<<numTrip<<": numC = "<<seg[numVeh].Trip[numTrip].numCus<<"; firstC = "<<seg[numVeh].Trip[numTrip].firstCus<<"; sp = "<<seg[numVeh].Trip[numTrip].assSP<<endl;
					   int buc = seg[numVeh].Trip[numTrip].firstCus;
					   while (buc > 0)
					   {
						   cout<<buc<<"  ";
						   buc = nextArrD[buc];
					   }
					   cout<<endl;*/
					   //cout<<"Create only Deltrip("<<numVeh<<", "<<numTrip<<") = "<<seg[numVeh].Trip[numTrip].cost<<endl;
					}
				   //numTrip++;
			   }
			   /*else //last trip --> end current vehicle
			   {
				   cout<<"It's last delivery trip ("<<numVeh<<", "<<numTrip<<"): cost = "<<seg[numVeh].Trip[numTrip].cost<<endl;
			   }*/
			   return createTrip;
}
int Solution::Get_Node_Nbr_In_DeliveryTrip_Q(int startSP, int &numTrip, 
						  double leave_startSP, int &nextSP, 
						  int endSP,
						  int typeofseed, int typeofINIT, int valueFEE)
{
	   //Create a delivery trip (idVeh, idTrip) of sp startSP where the time to leave startSP is leave_startSP:
	   int i;
	   int createTrip; //= 0: last delivery trip; = 1: d-p trip; =2: only delivery trip
	   double feeMIN = PDS_INFINITY;
       bool canRoute = 0; 

#if Q_DEBUG
	  // cout<<"CALL Create_DeliveryTrip_Q: startSP = "<<startSP<<", numVeh = "<<numVeh<<", numTrip = "<<numTrip<<endl;
#endif
		
			   //for (endSP = startSP+1;endSP<=nSP;endSP++)
				if (numCusPRouted[endSP] < numCusPSP[endSP] || numCusDRouted[endSP] < problem->numCusDSP[endSP]){ //exist unrouted customers in sj
					Init_NewSolomonI1_NewDeliveryTrip(startSP, endSP, numTrip,leave_startSP, feeMIN, nextSP, createTrip, typeofseed,valueFEE,typeofINIT,canRoute);
				} else {
#if Q_DEBUG
					cout << "Supply point " << endSP << " is full" << endl;
#endif
					return -1;
				}

			   if (!canRoute) 
			   {
				   return -1;
			   }

	return (seg[numVeh].Trip[numTrip].numCus);
}

//create new leg l(th) for vehicle idVeh(th) according to Solomon I1
void Solution::Init_NewSolomonI1_NewDeliveryTrip(int startSP, int endSP, int idTrip, double leave_startSP, double &feeMIN, int &nextSP, int &createTrip, int typeofseed, int valueFEE, int typeofINIT, bool &canRoute)  //always create feasible leg
{
	 int l = idTrip+1;
	 bool routedTemp[2000];
	 int nextArrTemp[2000];
	 //int nextArrB[1000];
	 int lP=0;
	 seg[numVeh].Trip[l].assSP = startSP;
	 seg[numVeh].Trip[l].leaveSP = leave_startSP;
	 
	 

     //cout<<"----------INIT LEG "<<l<<" of vehicle "<<numVeh<<"("<<startSP<<", "<<endSP<<")"<<endl;

	 int i,j;
     int start = problem->startCusDSP[startSP];
	 int end = problem->endCusDSP[startSP]; //int end = start + problem->numCusSP[startSP]-1;
     for (i=start;i<=end;i++) routedTemp[i]=routed[i];

     int seed=0, idCus; 
     
	 double ArrTime,ArrTime1;
	 int goWS, goWSMINI, preINS, nextINS,curC,nextC,lastC; 
	 double temp,startSTemp;
	 double varcost,c1,c2,c2OPT;
	 bool ok;
	 int IDinsert, WSID,WSIDtemp, insert_after;
	 double costP, costS, costMINI, arrTimeMINI;
	 double TOTALTIME=0;
	 //bool dien1 = 0;
	 if (endSP!=0) //A.not last leg: then should check if it is possible to create pickup trip after this delivery trip
	 {
		   costMINI=PDS_INFINITY; goWSMINI=-10;
           for (i=start;i<=end;i++)
				 if (!routedTemp[i])
				 {
					  ArrTime = leave_startSP + problem->c[startSP][i];
					  temp = problem->node[i].sTW - ArrTime;//Quangnn++
					  if (temp > eps) continue;				//Quangnn++
					  temp = ArrTime - problem->node[i].eTW;
					  if (temp > eps) continue;
			          ArrTime = PDS_MAX(ArrTime, problem->node[i].sTW) + problem->node[i].duration;
					  ArrTime1 = ArrTime + problem->c[i][endSP];
			          if (PDSINRANGE(ArrTime1, problem->nodeSP[endSP].sTW2, problem->nodeSP[endSP].eTW2)) 
					  {
						  goWS=NO_WS;
						  costS = problem->c[startSP][i] + problem->c[i][endSP];
					  }
					  else
					  {
                         	temp = ArrTime1 - problem->nodeSP[endSP].eTW2;
					        if (temp > eps) continue;
							ArrTime1 = ArrTime + problem->disCWSSP[i][endSP];
							temp = ArrTime1 - problem->nodeSP[endSP].eTW2;
							if (temp > eps) continue;
							goWS = problem->CWSSP[i][endSP];
							costS = problem->c[startSP][i] + problem->disCWSSP[i][endSP];
					  }
					  if (costS < costMINI)
					  {
						  seed=i;
						  costMINI = costS;
						  goWSMINI = goWS;
						  arrTimeMINI = ArrTime;
					  }
				 }
				 if (goWSMINI !=-10) //can find seed:
				 {
				 	 routedTemp[seed]=1; 
					 seg[numVeh].Trip[l].firstCus=seed; //id of the first Customer of Leg
					 seg[numVeh].Trip[l].lastCus=seed; //id of the first Customer of Leg
					 seg[numVeh].Trip[l].numCus=1; //#Customers in the leg
					 seg[numVeh].Trip[l].capacity = problem->node[seed].capacity;
					 seg[numVeh].Trip[l].waitingS = goWSMINI;
					 nextArrTemp[seed] = 0; //just correct for initial solution
					 seg[numVeh].Trip[l].cost = costMINI;
					 seg[numVeh].Trip[l].endS = arrTimeMINI;
					 seg[numVeh].Trip[l].feasible = 1;
					 seg[numVeh].Trip[l].Type = 1;
					 goWS = goWSMINI;
					 //cout<<"First cus of veh "<<numVeh<<", trip "<<l<<": seed = "<<seed<<endl;
				 }
				 else return;
				//starting to find unrouted DELIVERY customer to insert into the current trip (startSP, endSP):
				bool cont=true;  
				do //each loop insert 1 DELIVERY customer
				{
					  insert_after=-1; c2OPT = -PDS_INFINITY;
					  lastC = seg[numVeh].Trip[l].lastCus;
					  for (idCus=start;idCus<=end;idCus++)
						   if (routedTemp[idCus]==0 && (seg[numVeh].Trip[l].capacity + problem->node[idCus].capacity <= problem->Q))
						   {
								 //1. try to insert at the beginning of the leg:
								 ok=1; nextINS = seg[numVeh].Trip[l].firstCus;
								 ArrTime = leave_startSP + problem->c[startSP][idCus];

								 temp = problem->node[idCus].sTW - ArrTime; //Quangnn++
								 if (temp > eps) continue;					//Quangnn++
								 temp = ArrTime - problem->node[idCus].eTW;
								 if (temp > eps) continue; //vioTW at customer idCus --> try another idCus
								 
								 ArrTime = PDS_MAX(ArrTime, problem->node[idCus].sTW) + problem->node[idCus].duration;
								 curC = idCus; nextC = seg[numVeh].Trip[l].firstCus;
								 for (j=1;j<=seg[numVeh].Trip[l].numCus;j++)
								 {
											 ArrTime += problem->c[curC][nextC]; 
											 double temp2 = problem->node[nextC].sTW - ArrTime; //Quangnn++
											 if (temp2 > eps) {ok=0;break;}						//Quangnn++
											 temp = ArrTime - problem->node[nextC].eTW;
											 if (temp > eps) {ok=0;break;} //vioTW at customer nextC
											 else
											 {
													 ArrTime = PDS_MAX(ArrTime,problem->node[nextC].sTW) + problem->node[nextC].duration;
													 curC = nextC; nextC=nextArrTemp[curC];
											 }
								}
                                if (ok)
								{
								     ArrTime1 =  ArrTime + problem->c[curC][endSP];
					    			 temp = problem->nodeSP[endSP].eTW2 - ArrTime1;
									 if (temp > eps)  //else too late to go to sp directly
									 {
										 if (PDSINRANGE(ArrTime1,problem->nodeSP[endSP].sTW2, problem->nodeSP[endSP].eTW2))
											 WSIDtemp=NO_WS;
										 else
										 {
											  ArrTime1 = ArrTime + problem->disCWSSP[curC][endSP];
											  temp = ArrTime1 - problem->nodeSP[endSP].eTW2;
											  if (temp > eps) ok=0; //too late to go to sp through WS
											  else WSIDtemp = problem->CWSSP[curC][endSP];
										 }
                                         if (ok)
										 {
										     c1 = problem->c[startSP][idCus] + problem->c[idCus][nextINS] - problem->c[startSP][nextINS];
										     if (goWS!= WSIDtemp)
											 {
												 if (goWS!= NO_WS) //before go to WS, after insert don't need to go to WS:
												 {
														 c1 += (problem->c[curC][endSP] - problem->disCWSSP[curC][endSP]);
												 }
												 else 
												 {
														 cout<<"Solution::Init_NewSolomonI1_NewDeliveryTrip ERROR before insert go to sp, after insert go to WS"<<endl;
														 cout<<"Trying to insert delivery cus "<<idCus<<" at the beginning of: ";
														 showTripCostTemp(numVeh,l);
														 exit(-1);
												 }
											 }
											 c2 = problem->c[startSP][idCus] - c1;
											 if (c2 > c2OPT) 
											 {
												 c2OPT=c2; varcost=c1; IDinsert=idCus; insert_after = 0;WSID=WSIDtemp;
												 TOTALTIME = ArrTime;
											} 
										 }
									 }//else too late to go to sp directly			
								}//end if (ok) else vioTW at a delivery cus
								 //2. try to insert customer idCus after each delivery customer j of the trip:
								 preINS = seg[numVeh].Trip[l].firstCus;
								 ArrTime = leave_startSP + problem->c[startSP][preINS];
								 for (j=1;j<=seg[numVeh].Trip[l].numCus;j++) 
								 {
										 ok=1;
									     startSTemp = ArrTime; //PDS_MAX(ArrTime, problem->node[preINS].sTW); //Quangnn+-
										 ArrTime = startSTemp + problem->node[preINS].duration + problem->c[preINS][idCus];
										 temp = problem->node[idCus].sTW - ArrTime;		//Quangnn++
										 if (temp > eps) break;							//Quangnn++
										 temp = ArrTime - problem->node[idCus].eTW;
										 if (temp > eps) break; //vioTW at idCus --> don't need to check any j 
										 ArrTime = PDS_MAX(ArrTime, problem->node[idCus].sTW) + problem->node[idCus].duration;
										
										 //start checking TW from i to the end of the leg:
										 curC = idCus; nextC = nextArrTemp[preINS];
										 while (nextC > 0)
										 {
													 ArrTime += problem->c[curC][nextC]; 
													 double temp2 = problem->node[nextC].sTW - ArrTime; //Quangnn++
													 if (temp2 > eps) {ok=0;break;}						//Quangnn++
													 temp = ArrTime - problem->node[nextC].eTW;
													 if (temp > eps) {ok=0;break;}
													 else
													 {
															 ArrTime = PDS_MAX(ArrTime,problem->node[nextC].sTW) + problem->node[nextC].duration;
															 curC = nextC; nextC=nextArrTemp[curC];
													 }
										 }
										 if (ok) //now curC point to the lastCus  (DELIVERY)
										 {
													 ArrTime1=  ArrTime + problem->c[curC][endSP];
													 temp = problem->nodeSP[endSP].eTW2 - ArrTime1;
													 if (temp > eps)//else too late to go to sp directly
													 {
														 if (PDSINRANGE(ArrTime1,problem->nodeSP[endSP].sTW2, problem->nodeSP[endSP].eTW2))
															  WSIDtemp=NO_WS;
														 else
														 {
															  ArrTime1 = ArrTime + problem->disCWSSP[curC][endSP];
															  temp = ArrTime1 - problem->nodeSP[endSP].eTW2;
															  if (temp > eps) ok=0; //too late to go to sp through WS
															  else WSIDtemp = problem->CWSSP[curC][endSP];
														 }
                                                         if (ok)
														 {
																 if (j != seg[numVeh].Trip[l].numCus)								        
																 {
																	 nextINS = nextArrTemp[preINS];
																	 c1 = problem->c[preINS][idCus] + problem->c[idCus][nextINS] - problem->c[preINS][nextINS];
																	 if (goWS != WSIDtemp)
																	 {
																		 if (goWS != NO_WS) //before go to WS, after insert don't need to go to WS:
																			 c1 += (problem->c[curC][endSP] - problem->disCWSSP[curC][endSP]);
																		 else 
																		 {
																			 cout<<"Solution::Init_NewSolomonI1_NewDeliveryTrip ERROR before insert go to sp directly, after insert go to WS"<<endl;
																			 cout<<"Trying to insert "<<idCus<<" after "<<preINS<<": ";
																			 showTripCostTemp(numVeh,l);
																			 exit(-1);
																		 }
																	 }
																 }
																 else //insert to the end of the leg:
																 {
																	 c1 = problem->c[preINS][idCus];
																	 if (goWS==NO_WS) //before insert customer idCus, go to sp directly
																	 {
																		 if (WSIDtemp ==NO_WS) c1 += (problem->c[idCus][endSP] - problem->c[preINS][endSP]);
																		 else 
																		 {
																			 cout<<"Solution::Init_NewSolomonI1_NewDeliveryTrip  ERROR before insert go to sp directly, after insert need to go to WS"<<endl; 
																			 cout<<"Trying to insert "<<idCus<<" at the end of the trip: ";
																			 showTripCostTemp(numVeh,l);
																			 exit(-1);
																		 }
																	 }
																	 else //before insert customer idCus, go to WS:
																	 {
																		 if (WSIDtemp == NO_WS) c1 += (problem->c[idCus][endSP] - problem->disCWSSP[preINS][endSP]);
																		 else c1+=(problem->disCWSSP[idCus][endSP] - problem->disCWSSP[preINS][endSP]);
																	 }
																 }
																 c2 = problem->c[startSP][idCus]-c1;
																 if (c2 > c2OPT) 
																 {
																	 c2OPT=c2; varcost=c1; IDinsert=idCus; insert_after = preINS;
																	 WSID=WSIDtemp;
																	 TOTALTIME = ArrTime;
																 } 
														 }//else too soon to go to sp directly, too late to go to sp through WS
													 }//else too late to go to sp directly
										}//end if (ok) :else vioTW at one customer of route
										nextINS = nextArrTemp[preINS];
										ArrTime = startSTemp + problem->node[preINS].duration + problem->c[preINS][nextINS];
										preINS = nextINS;
								 }//end for j
						   }//end if (!routedDTemp[idCus])
						   if (insert_after!=-1)
						   {
									  //cout<<"Insert customer "<<IDinsert<<" after "<<insert_after<<": ";
									  if (insert_after == 0)
									  {
										  int TEPRE = seg[numVeh].Trip[l].firstCus;
										  seg[numVeh].Trip[l].firstCus = IDinsert;
										  nextArrTemp[IDinsert] = TEPRE;
										  //cout<<"************Insert customer "<<IDinsert<<" beginning of the leg: after "<<insert_after<<"; varcost = "<<varcost<<endl;
									  }
									  else if (insert_after == seg[numVeh].Trip[l].lastCus) //insert at the end of the leg:
									  {
										  nextArrTemp[insert_after] = IDinsert;
										  seg[numVeh].Trip[l].lastCus = IDinsert;
										  nextArrTemp[IDinsert]=0;
										  //cout<<"*************Insert customer "<<IDinsert<<" at the end of the leg: after "<<insert_after<<endl;
									  }
									  else //insert at the middile of the leg:
									  {
										  int tt=nextArrTemp[insert_after];
										  nextArrTemp[insert_after]=IDinsert;
										  nextArrTemp[IDinsert]=tt;
										  //cout<<"***********Insert customer "<<IDinsert<<" in the middle of the leg: after "<<insert_after<<endl;
									  }
									  seg[numVeh].Trip[l].numCus++;seg[numVeh].Trip[l].waitingS = WSID;
									  routedTemp[IDinsert]=1;
									  seg[numVeh].Trip[l].capacity += problem->node[IDinsert].capacity;
									  goWS = WSID;
									  seg[numVeh].Trip[l].cost += varcost;
									  seg[numVeh].Trip[l].endS = TOTALTIME;
							 }
							 else cont=false; //can't find any customer to insert into the current leg
				}while (cont);


				//Checking if can route PICKUP customers:
#if 0
				numCusPRouted[endSP] = numCusPSP[endSP];
#endif
				if (numCusPRouted[endSP] < numCusPSP[endSP]) //endSP still exists unrouted pickup customers
				{
					if (seg[numVeh].Trip[l].waitingS != NO_WS) //from last delivery customer has to go to sp endSP through WS, then can insert pickup customer between them:
					{
						
                        for (i=1;i<=numCusPSP[endSP];i++)
						{
							idCus = CusPSP[endSP][i];
							routedTemp[idCus] = routed[idCus];                       
						}
						int lastD = seg[numVeh].Trip[l].lastCus;
					    costMINI = PDS_INFINITY; seed = -1;
						//P1.Insert first pickup customer:
						for (i=1;i<=numCusPSP[endSP];i++)
						{
							idCus = CusPSP[endSP][i];
							if (routedTemp[idCus]==0)
							{
							    ArrTime = seg[numVeh].Trip[l].endS + problem->c[lastD][idCus];
								temp = ArrTime - problem->node[idCus].eTW;
								if (temp > eps) continue; //vioTW at idCus--> try another idCus
								ArrTime = PDS_MAX(ArrTime, problem->node[idCus].sTW) + problem->node[idCus].duration;
								ArrTime1 = ArrTime + problem->c[idCus][endSP];
								if (PDSINRANGE(ArrTime1, problem->nodeSP[endSP].sTW1, problem->nodeSP[endSP].eTW1)) 
								{
									  goWS=NO_WS;
									  costP = problem->c[lastD][idCus] + problem->c[idCus][endSP];
								}
								else
								{
										temp = ArrTime1 - problem->nodeSP[endSP].eTW1;
										if (temp > eps) continue;
										ArrTime1 = ArrTime + problem->disCWSSP[idCus][endSP];
										temp = ArrTime1 - problem->nodeSP[endSP].eTW1;
										if (temp > eps) continue;
										goWS = problem->CWSSP[idCus][endSP];
										costP = problem->c[lastD][idCus] + problem->disCWSSP[idCus][endSP];
								}
								if (costP < costMINI)
								{
									  seed=idCus;
									  costMINI = costP;
									  goWSMINI = goWS;
									  TOTALTIME = ArrTime;
								}
							}
						}//end for
     				    if (seed != -1) //can insert pickup customer after delivery
						{
								 routedTemp[seed]=1; lP = l+1; 
								 seg[numVeh].Trip[lP].Type = 0;
								 seg[numVeh].Trip[lP].assSP = endSP;
								 seg[numVeh].Trip[lP].firstCus = seed; //id of the first Customer of Leg
								 seg[numVeh].Trip[lP].lastCus = seed; //id of the first Customer of Leg
								 seg[numVeh].Trip[lP].numCus = 1; //#Customers in the leg
								 seg[numVeh].Trip[lP].capacity = problem->node[seed].capacity;
								 seg[numVeh].Trip[lP].waitingS = goWSMINI;
								 nextArrTemp[seed] = 0; //just correct for initial solution
								 seg[numVeh].Trip[lP].cost = costMINI;
								 seg[numVeh].Trip[lP].endS = TOTALTIME;
								 seg[numVeh].Trip[lP].feasible = 1;
								 seg[numVeh].Trip[lP].Type = 0;
								 goWS = goWSMINI;

								 // P2. Continue to insert PICKUP customers:
			  					 //starting to find customer to insert into the current trip (startSP, endSP):
								 bool cont=true;  
								 do //each loop insert 1 pickup customer
								 {
									  insert_after=-1; varcost = PDS_INFINITY;
									  int lastCP = seg[numVeh].Trip[lP].lastCus;  
									  for (i=1;i<=numCusPSP[endSP];i++)
									  {
											  idCus = CusPSP[endSP][i];
											  if (!routedTemp[idCus]  && (seg[numVeh].Trip[lP].capacity + problem->node[idCus].capacity <= problem->Q))
											  {
												    //1. try to insert pickup idCus at the beginning of the trip:
													ok=1; nextINS = seg[numVeh].Trip[lP].firstCus;
													ArrTime = seg[numVeh].Trip[l].endS + problem->c[lastD][idCus];
													temp = ArrTime - problem->node[idCus].eTW;
													if (temp > eps) continue; //check another idCus
													temp = problem->node[idCus].sTW - ArrTime; //Quangnn++
													if (temp > eps) continue; //Quangnn++

													ArrTime = PDS_MAX(ArrTime, problem->node[idCus].sTW) + problem->node[idCus].duration;
#if Q_DEBUG
													//cout << ArrTime << endl;
#endif
													curC = idCus; nextC = seg[numVeh].Trip[lP].firstCus;
													while (nextC > 0)
													{
														ArrTime += problem->c[curC][nextC];
														double temp2 = problem->node[nextC].sTW - ArrTime;	//Quangnn++
														if (temp2 > eps) {ok=0;break;}						//Quangnn++
														temp = ArrTime - problem->node[nextC].eTW;
														if (temp > eps) {ok=0;break;} //vioTW at customer nextC
														else
														{
															ArrTime = PDS_MAX(ArrTime, problem->node[nextC].sTW) + problem->node[nextC].duration;
															curC = nextC; nextC = nextArrTemp[curC];
														}
													}
#if Q_DEBUG
													//cout << ArrTime << endl;
#endif
                                                    if (ok) //curC now points to last pick of trip (numVeh, lP)
													{
														ArrTime1 = ArrTime + problem->c[curC][endSP];
														temp = problem->nodeSP[endSP].eTW1 - ArrTime1;
														if (temp > eps) //else too late to go to sp directly
														{
															 if (PDSINRANGE(ArrTime1,problem->nodeSP[endSP].sTW1, problem->nodeSP[endSP].eTW1))
																 WSIDtemp = NO_WS;
															 else
															 {
																  ArrTime1 = ArrTime + problem->disCWSSP[curC][endSP];
																  temp = ArrTime1 - problem->nodeSP[endSP].eTW1;
																  if (temp > eps) ok=0; //too late to go to sp through WS
																  else WSIDtemp = problem->CWSSP[curC][endSP];
															 }
															 if (ok) //ok to insert idCus at beginning of trip lP
															 {
																 c1 = problem->c[lastD][idCus] + problem->c[idCus][nextINS] - problem->c[lastD][nextINS];
																 if (goWS != WSIDtemp)
																 {
																	if (goWS != NO_WS) //before go to WS, after insert don't need to go to WS:
																		c1 += (problem->c[lastCP][endSP] - problem->disCWSSP[lastCP][endSP]);
																	else 
																	{
																		cout<<"Init_NewSolomonI1_NewDeliveryTrip: ERROR before insert pickup customer go to sp, after insert go to WS "<<WSIDtemp<<endl;
																		cout<<"Trying to insert pickup cus "<<idCus<<" at the beginning of the: ";
																		showTripCostTemp(numVeh,lP);
																		cout<<"lastD = "<<lastD<<endl;
																		exit(-1);
																	}
																}
																if (c1 < varcost) 
																{
																	varcost=c1; IDinsert=idCus; insert_after = 0;
																	WSID=WSIDtemp;
																	TOTALTIME = ArrTime;
#if Q_DEBUG
																	//cout << TOTALTIME << endl;
#endif
																}  
															 }
														}//end if (temp > eps) //else too late to go to sp directly
													}//end if(ok) else vioTW at some pickup cus
													
													//2. Try to insert idCus after each customer j of the trip:
											        preINS = seg[numVeh].Trip[lP].firstCus; 
												    ArrTime = seg[numVeh].Trip[l].endS + problem->c[lastD][preINS];
#if Q_DEBUG
													//cout << ArrTime << endl;
#endif
												   	for (j=1;j<=seg[numVeh].Trip[lP].numCus;j++)
											        {
												   		 ok=1;
														 startSTemp = ArrTime ; //PDS_MAX(ArrTime, problem->node[preINS].sTW); //Quangnn+-
														 ArrTime = startSTemp + problem->node[preINS].duration + problem->c[preINS][idCus];
														 //ArrTime += problem->node[preINS].duration + problem->c[preINS][idCus];
#if Q_DEBUG
													cout << ArrTime << endl;
#endif

														 temp = ArrTime - problem->node[idCus].eTW;
														 if (temp > eps) break; //vioTW at idCus --> don't need to check any j 
														 temp = problem->node[idCus].sTW - ArrTime; //Quangnn++
														 if (temp > eps) break;						//Quangnn++

														 ArrTime = PDS_MAX(ArrTime, problem->node[idCus].sTW) + problem->node[idCus].duration;
#if Q_DEBUG
													//cout << ArrTime << " " << " " << problem->node[idCus].sTW << " " << problem->node[idCus].eTW << endl;
#endif

														 //start checking TW from idCus to the end of the leg:
														 curC = idCus; nextC = nextArrTemp[preINS];
														 while (nextC > 0)
														 {
															 ArrTime += problem->c[curC][nextC]; 
															 double temp2 = problem->node[nextC].sTW - ArrTime; //Quangnn++
															 if (temp2 > eps) {ok=0;break;}						//Quangnn++
															 temp = ArrTime - problem->node[nextC].eTW;															 
															 if (temp > eps) {ok=0;break;}
															 else
															 {
																 ArrTime = PDS_MAX(ArrTime,problem->node[nextC].sTW) + problem->node[nextC].duration;
																 curC = nextC; nextC=nextArrTemp[curC];
															 }
														 }
												
											   			 if (ok) //curC is now pointed to LAST CUST of pickup trip
														 {
														         ArrTime1=  ArrTime + problem->c[curC][endSP];
																 temp = problem->nodeSP[endSP].eTW1 - ArrTime1;
																 if (temp > eps)//else too late to go to sp directly
																 {
																	 if (PDSINRANGE(ArrTime1,problem->nodeSP[endSP].sTW1, problem->nodeSP[endSP].eTW1))
																		  WSIDtemp=NO_WS;
																	 else
																	 {
																		  ArrTime1 = ArrTime + problem->disCWSSP[curC][endSP];
																		  temp = ArrTime1 - problem->nodeSP[endSP].eTW1;
																		  if (temp > eps) ok=0; //too late to go to sp through WS
																		  else WSIDtemp = problem->CWSSP[curC][endSP];
																	 }
																	 if (ok)
																	 {
																			 if (j != seg[numVeh].Trip[lP].numCus)								        
																			 {
																				 nextINS = nextArrTemp[preINS];
																				 c1 = problem->c[preINS][idCus] + problem->c[idCus][nextINS] - problem->c[preINS][nextINS];
																				 if (goWS != WSIDtemp)
																				 {
																					 if (goWS != NO_WS) //before go to WS, after insert don't need to go to WS:
																						 c1 += (problem->c[curC][endSP] - problem->disCWSSP[curC][endSP]);
																					 else 
																					 {
																						 cout<<"Init_NewSolomonI1_NewDeliveryTrip( ERROR before insert go to sp directly, after insert go to WS"<<endl;
																						 cout<<"Trying to insert pickup "<<idCus<<" after "<<preINS<<": ";
																						 showTripCostTemp(numVeh,lP);
																						 exit(-1);
																					 }
																				 }
																			 }
																			 else //insert to the end of the trip:
																			 {
																				 c1 = problem->c[preINS][idCus];
																				 if (goWS==NO_WS) //before insert customer idCus, go to sp directly
																				 {
																					 if (WSIDtemp ==NO_WS) c1 += (problem->c[idCus][endSP] - problem->c[preINS][endSP]);
																					 else 
																					 {
																						 cout<<"Solution::Init_NewSolomonI1_NewDeliveryTrip(  ERROR before insert go to sp directly, after insert need to go to WS"<<endl; 
																						 cout<<"Trying to insert pickup "<<idCus<<" at the end of the pickup trip: ";
																						 showTripCostTemp(numVeh,lP);
																						 exit(-1);
																					 }
																				 }
																				 else //before insert customer idCus, go to WS:
																				 {
																					 if (WSIDtemp == NO_WS) c1 += (problem->c[idCus][endSP] - problem->disCWSSP[preINS][endSP]);
																					 else c1+=(problem->disCWSSP[idCus][endSP] - problem->disCWSSP[preINS][endSP]);
																				 }
																			 }
																			 if (c1 < varcost) 
																			 {
																				 varcost=c1; IDinsert=idCus; insert_after = preINS;WSID=WSIDtemp;
																				 TOTALTIME = ArrTime;
#if Q_DEBUG
																	//cout << TOTALTIME << endl;
#endif
																			 } 
																	 }//else too soon to go to sp directly, too late to go to sp through WS
																 }//else too late to go to sp directly													 						
														 }//end if (ok) :else vioTW at one customer of route
											  			 nextINS = nextArrTemp[preINS];
														 ArrTime = startSTemp + problem->node[preINS].duration + problem->c[preINS][nextINS];
														 preINS = nextINS;
												  }//end for (j=1;j<=seg[numVeh].Trip[lP].numCus;j++)
											  }//end if of each pickup customer: if (!routedPTemp[i] && (seg[numVeh].Trip[lP].capacity + problem->nodeP[i].capacity <= problem->Q))
									  }//end for
#if Q_DEBUG
									  cout << TOTALTIME << endl;
									  showTripCostTemp(numVeh,lP);
#endif
									  
									  // Now take the best insertion position:
									  if (insert_after!=-1)
									  {
	   										  //cout<<"Insert customer "<<IDinsert<<" after "<<insert_after<<endl;
											  if (insert_after == 0)
											  {
												  int pre = seg[numVeh].Trip[lP].firstCus;
												  seg[numVeh].Trip[lP].firstCus = IDinsert;
												  nextArrTemp[IDinsert] = pre;
												  //cout<<"************Insert customer "<<IDinsert<<" beginning of the leg: after delivery cus "<<insert_after<<"; varcost = "<<varcost<<endl;
												  //cout<<"/endS = "<<TOTALTIME<<"; goWS = "<<WSID<<"; (sTW,eTW)= ("<<problem->nodeD[endSPID].sTW<<", "<<problem->nodeD[endSPID].eTW<<")"<<endl;
											  }
											  else if (insert_after == seg[numVeh].Trip[lP].lastCus) //insert at the end of the leg:
											  {
												  nextArrTemp[insert_after] = IDinsert;
												  seg[numVeh].Trip[lP].lastCus = IDinsert;
												  nextArrTemp[IDinsert]= 0;
												  //cout<"*************Insert customer "<<IDinsert<<" at the end of the leg: after "<<insert_after<<"; varcost = "<<varcost<<endl;
												  //cout<<"endS = "<<TOTALTIME<<"; goWS = "<<WSID<<"; (sTW,eTW)= ("<<problem->nodeD[endSPID].sTW<<", "<<problem->nodeD[endSPID].eTW<<")"<<endl;
											  }
											  else //insert at the middile of the leg:
											  {
												  int tt=nextArrTemp[insert_after];
												  nextArrTemp[insert_after]=IDinsert;
												  nextArrTemp[IDinsert]=tt;
												  //cout<<"***********Insert customer "<<IDinsert<<" in the middle of the leg: after "<<insert_after<<"; varcost = "<<varcost<<endl;
												  //cout<<"endS = "<<TOTALTIME<<"; goWS = "<<WSID<<"; (sTW,eTW)= ("<<problem->nodeD[endSPID].sTW<<", "<<problem->nodeD[endSPID].eTW<<")"<<endl;
											  }
											  seg[numVeh].Trip[lP].numCus++;seg[numVeh].Trip[lP].waitingS = WSID;
											  routedTemp[IDinsert]=1;
											  seg[numVeh].Trip[lP].capacity += problem->node[IDinsert].capacity;
											  goWS = WSID;
											  seg[numVeh].Trip[lP].cost += varcost;
											  seg[numVeh].Trip[lP].fitness += varcost;
											  //showTripCostTemp(numVeh,lP);
											  seg[numVeh].Trip[lP].endS =  TOTALTIME;
#if Q_DEBUG
																	//cout << TOTALTIME << endl;
#endif
											  
									   }//end  if (insert_after != -1)
								       else cont = false; //cannot find any pickup customer to insert into the current trip

									   //showTripCostTemp(numVeh,lP);
								 }while (cont);//end do each loop insert 1 pickup customer

								 seg[numVeh].Trip[l].connectCost = problem->c[seg[numVeh].Trip[l].lastCus][seg[numVeh].Trip[lP].firstCus];
								 //cout<<"connectCost @ init_newSolomonI1_NewLeg = "<<seg[numVeh].Trip[l].connectCost<<"; costESP = "<<seg[numVeh].Trip[l].cost;
								 if (seg[numVeh].Trip[l].waitingS == NO_WS)
									 seg[numVeh].Trip[l].cost += (seg[numVeh].Trip[l].connectCost - problem->c[seg[numVeh].Trip[l].lastCus][endSP]);
								 else seg[numVeh].Trip[l].cost += (seg[numVeh].Trip[l].connectCost - problem->disCWSSP[seg[numVeh].Trip[l].lastCus][endSP]);
								 //cout<<"; cost inc connectCost = "<<seg[numVeh].Trip[l].cost<<endl;
								 seg[numVeh].Trip[l].waitingS = NO_WS;
								 seg[numVeh].Trip[lP].cost -= seg[numVeh].Trip[l].connectCost;
						}//end if (seed != -1)
						else
						{
							//cout<<"Although exists unrouted pickup customers, can't create pickup trip"<<endl;
	                        if (numCusDRouted[endSP] >= problem->numCusDSP[endSP]) return; //doesnot exist any unrouted delivery customer in endSP --> don't create this delivery trip, otherwise will create: [startSP - d - endSP - p] or [startSP-d-endSP-endSP1]: mean: does nothing at endSP				   	
							//seg[numVeh].Trip[l].connectCost = problem->disDWSSP[seg[numVeh].Trip[l].lastCus][endSP];
						}
					} //end  if (WS != NO_WS)
			   	    else
					{
                        if (numCusDRouted[endSP] >= problem->numCusDSP[endSP]) return; //doesnot exist any unrouted delivery customer in endSP --> don't create this delivery trip, otherwise will create: [startSP - d - endSP - p] or [startSP-d-endSP-endSP1]: mean: does nothing at endSP				   	
						seg[numVeh].Trip[l].connectCost = problem->c[seg[numVeh].Trip[l].lastCus][endSP];
					}
				}//end if (numCusPRouted[endSP] < numCusPSP[endSP]): endSP still exists unrouted pickup customers
				else //not exist any unrouted PICKUP customers --> just create delivery trip: startSP - d - endSP:
				{
					//cout<<"JUST CREATE DELIVERY TRIP ("<<numVeh<<", "<<l<<"): startSP = "<<startSP<<", endSP = "<<endSP<<endl;
					if (seg[numVeh].Trip[l].waitingS == NO_WS)
						seg[numVeh].Trip[l].connectCost = problem->c[seg[numVeh].Trip[l].lastCus][endSP];
					else
						seg[numVeh].Trip[l].connectCost = problem->disCWSSP[seg[numVeh].Trip[l].lastCus][endSP];
				}//end just create delivery trip: startSP - d - endSP


	 }
	 else //B.last leg of segment
	 {
			 double costMINI=PDS_INFINITY;
			 seed = -1;
			 for (idCus=start;idCus<=end;idCus++)
			 {
				 if (!routedTemp[idCus])
				 {
					 if (!PDSINRANGE(leave_startSP + problem->c[startSP][idCus],problem->node[idCus].sTW, problem->node[idCus].eTW)) //Quangnn++
						 continue;

					  double cc = problem->c[startSP][idCus] + problem->c[idCus][0];
					  if (cc < costMINI)
					  {
						  costMINI = cc;
						  seed=idCus;
					  }
				 }
			 }

			 if (-1 == seed) return; //Quangnn++

		     routedTemp[seed]=1;
			 seg[numVeh].Trip[l].firstCus=seed; //id of the first Customer of Leg
			 seg[numVeh].Trip[l].lastCus=seed; //id of the first Customer of Leg
			 seg[numVeh].Trip[l].numCus=1; //#Customers in the leg
			 seg[numVeh].Trip[l].capacity = problem->node[seed].capacity;
			 nextArrTemp[seed]= 0; //just correct for initial solution
			 seg[numVeh].Trip[l].cost = costMINI;
			 seg[numVeh].Trip[l].feasible = 1;
			 seg[numVeh].Trip[l].Type = 1;
			 seg[numVeh].Trip[l].waitingS=NO_WS; seg[numVeh].Trip[l].connectCost = 0;
			 seg[numVeh].Trip[l].endS = PDS_MAX(leave_startSP + problem->c[startSP][seed], problem->node[seed].sTW) + problem->node[seed].duration;
			
			 bool cont=true;
			 do //each loop insert 1 delivery customer
			 {
				 insert_after=-1;c2OPT = -PDS_INFINITY; lastC = seg[numVeh].Trip[l].lastCus;
				 for (idCus=start;idCus<=end;idCus++)
				 {
					 if (!routedTemp[idCus] && (seg[numVeh].Trip[l].capacity + problem->node[idCus].capacity <= problem->Q))
					 {
						         //1. try to insert at the beginning of the leg:
								 ok=1; nextINS = seg[numVeh].Trip[l].firstCus;
								 ArrTime = leave_startSP + problem->c[startSP][idCus];
								 temp = problem->node[idCus].sTW - ArrTime; //Quangnn++
								 if (temp > eps) continue;					//Quangnn++
								 temp = ArrTime - problem->node[idCus].eTW;
								 if (temp > eps) continue; //vioTW at customer idCus --> try another idCus
								 
								 ArrTime = PDS_MAX(ArrTime, problem->node[idCus].sTW) + problem->node[idCus].duration;
								 curC = idCus; nextC = seg[numVeh].Trip[l].firstCus;
								 for (j=1;j<=seg[numVeh].Trip[l].numCus;j++)
								 {
											 ArrTime += problem->c[curC][nextC]; 
											 double temp2 = problem->node[nextC].sTW - ArrTime; //Quangnn++
											 if (temp2 > eps) {ok=0;break;}						//Quangnn++
											 temp = ArrTime - problem->node[nextC].eTW;
											 if (temp > eps) {ok=0;break;} //vioTW at customer nextC
											 else
											 {
													 ArrTime = PDS_MAX(ArrTime,problem->node[nextC].sTW) + problem->node[nextC].duration;
													 curC = nextC; nextC=nextArrTemp[curC];
											 }
								}
								if (ok)
							    {
							         c1 = problem->c[startSP][idCus] + problem->c[idCus][nextINS] - problem->c[startSP][nextINS];
									 c2 = problem->c[startSP][idCus] - c1;
								     if (c2 > c2OPT) 
									 {
										 c2OPT=c2; varcost=c1; IDinsert=idCus; insert_after = 0;
										 TOTALTIME = ArrTime;/*time to service last customer*/
									 } 
							    }
								//2. try to insert customer idCus after each delivery customer j of the trip:
                                 preINS = seg[numVeh].Trip[l].firstCus;
								 ArrTime = leave_startSP + problem->c[startSP][preINS];
								 for (j=1;j<=seg[numVeh].Trip[l].numCus;j++) 
								 {
										 ok=1;nextINS = nextArrTemp[preINS];
									     startSTemp = ArrTime; //PDS_MAX(ArrTime, problem->node[preINS].sTW); //Quangnn+-
										 ArrTime = startSTemp + problem->node[preINS].duration + problem->c[preINS][idCus];
										 temp = problem->node[idCus].sTW - ArrTime; //Quangnn++
										 if (temp > eps) break;						//Quangnn++
										 temp = ArrTime - problem->node[idCus].eTW;
										 if (temp > eps) break; //vioTW at idCus --> don't need to check any j 
										 ArrTime = PDS_MAX(ArrTime, problem->node[idCus].sTW) + problem->node[idCus].duration;
										
										 //start checking TW from i to the end of the leg:
										 curC = idCus; nextC = nextINS;
										 while (nextC > 0)
										 {
													 ArrTime += problem->c[curC][nextC]; 
													 double temp2 = problem->node[nextC].sTW - ArrTime;
													 if (temp2 > eps) {ok=0;break;}
													 temp = ArrTime - problem->node[nextC].eTW;
													 if (temp > eps) {ok=0;break;}
													 else
													 {
															 ArrTime = PDS_MAX(ArrTime,problem->node[nextC].sTW) + problem->node[nextC].duration;
															 curC = nextC; nextC=nextArrTemp[curC];
													 }
										 }
										if (ok) //now curC point to the lastCus
								        {  
											if (curC == idCus) //insert idCus at the end of trip:
											   c1 = problem->c[preINS][idCus] + problem->c[idCus][0] - problem->c[preINS][0];
											else
											   c1 = problem->c[preINS][idCus] + problem->c[idCus][nextINS] - problem->c[preINS][nextINS];
										    c2 = problem->c[idCus][startSP]-c1;
									        if (c2 > c2OPT) 
											{
												c2OPT=c2; varcost=c1;IDinsert=idCus; insert_after = preINS; 
												TOTALTIME = ArrTime;
											} 
								        }
										ArrTime = startSTemp + problem->node[preINS].duration + problem->c[preINS][nextINS];
										preINS = nextINS;
								 }//end for j
					 }//end if (!routedDTemp[idCus] && (seg[numVeh].Trip[l].capacity + problem->nodeD[idCus].capacity <= problem->Q))
				 }//end for (idCus=start;idCus<=end;idCus++)
				 if (insert_after!=-1)
			     {
					  //cout<<"For lastTrip: Insert customer "<<IDinsert<<" after "<<insert_after<<": ";
					  if (insert_after == 0)
					  {
						  int pre = seg[numVeh].Trip[l].firstCus;
						  seg[numVeh].Trip[l].firstCus = IDinsert;
						  nextArrTemp[IDinsert] = pre;
						  //cout<<"begin of trip; ";
					  }
					  else if (insert_after == seg[numVeh].Trip[l].lastCus) //insert at the end of the leg:
					  {
		                  nextArrTemp[insert_after] = IDinsert;
						  seg[numVeh].Trip[l].lastCus=IDinsert;
						  nextArrTemp[IDinsert]=0;
						  //cout<<" end of trip; ";
					  }
					  else //insert at the middile of the leg:
					  {
						  int tt = nextArrTemp[insert_after];
						  nextArrTemp[insert_after] = IDinsert;
						  nextArrTemp[IDinsert] = tt;
						  //cout<<"middle of trip; ";
					  }
					  seg[numVeh].Trip[l].numCus++;seg[numVeh].Trip[l].waitingS = NO_WS;
					  routedTemp[IDinsert] = 1;
					  seg[numVeh].Trip[l].capacity += problem->node[IDinsert].capacity;
					 // cout<<"leaveSP = "<<_dur<<"; Total time = "<<TOTALTIME<<"; durLastCus = "<<problem->nodeD[seg[numVeh].Trip[l].lastCus].duration<<"; ";
					  seg[numVeh].Trip[l].endS = TOTALTIME;
					  seg[numVeh].Trip[l].cost += varcost;
			     }
			     else cont=false; //can't find any customer to insert into the current leg
			 }while (cont);//end do
	}//end else //B.last leg of segment

	//CalCost of the leg: //seg[numVeh].leg[l].calCost();
	double fee;
    if (typeofINIT==1)
	{
			if (endSP==0)
			{
				fee = seg[numVeh].Trip[l].cost/seg[numVeh].Trip[l].capacity;
			}
			else
			{
				if (lP ==0) //only delivery customer: startSP - delivery - endSP
				{
				    fee = (problem->nodeSP[endSP].sTW2 - seg[numVeh].Trip[l].endS)/seg[numVeh].Trip[l].capacity;
				    fee *= seg[numVeh].Trip[l].cost;
				}
				else //create startSP-delivery - pickup-endSP
				{
				    fee = (problem->nodeSP[endSP].sTW1 - seg[numVeh].Trip[lP].endS)/(seg[numVeh].Trip[l].capacity + seg[numVeh].Trip[lP].capacity);
				    //seg[numVeh].Trip[l].cost += (problem->c[seg[numVeh].Trip[l].lastCus][seg[numVeh].Trip[lP].firstCus] - problem->disDWSSP[seg[numVeh].Trip[l].lastCus][endSP]);
                    //seg[numVeh].Trip[lP].cost -= problem->c[seg[numVeh].Trip[l].lastCus][seg[numVeh].Trip[lP].firstCus];
					fee *= (seg[numVeh].Trip[l].cost + seg[numVeh].Trip[lP].cost);
				}
			}
	}
	else if (typeofINIT==2)
	{
			if (endSP==0)
			{
				fee = seg[numVeh].Trip[l].cost/seg[numVeh].Trip[l].capacity;
			}
			else
			{
				if (lP ==0) //only delivery customer: startSP - delivery - endSP
				{
					fee = valueFEE*((problem->nodeSP[endSP].sTW2 - seg[numVeh].Trip[l].endS)/seg[numVeh].Trip[l].capacity);
					fee += seg[numVeh].Trip[l].cost;
				}
				else //create startSP-delivery - pickup-endSP
				{
				    fee = valueFEE*(problem->nodeSP[endSP].sTW1 - seg[numVeh].Trip[lP].endS)/(seg[numVeh].Trip[l].capacity + seg[numVeh].Trip[lP].capacity);
 				    //seg[numVeh].Trip[l].cost += (problem->c[seg[numVeh].Trip[l].lastCus][seg[numVeh].Trip[lP].firstCus] - problem->disDWSSP[seg[numVeh].Trip[l].lastCus][endSP]);
                    //seg[numVeh].Trip[lP].cost -= problem->c[seg[numVeh].Trip[l].lastCus][seg[numVeh].Trip[lP].firstCus];
					fee += (seg[numVeh].Trip[l].cost + seg[numVeh].Trip[lP].cost);
				}
			}
	}

	if (feeMIN > fee)
	{
		    feeMIN=fee; int ll = l+2;
			seg[numVeh].Trip[ll] = seg[numVeh].Trip[l];
			//cout<<"Update best del cost of ("<<numVeh<<", "<<ll<<") = "<<seg[numVeh].Trip[ll].cost<<" huhuhu = "<<seg[numVeh].Trip[l].cost<<endl;
			curC = seg[numVeh].Trip[l].firstCus;
			while (curC >0)
			{
				nextArrB[curC] = nextArrTemp[curC];
				curC = nextArrB[curC];
			}
			if (lP !=0)
			{
				curC = seg[numVeh].Trip[lP].firstCus;
				seg[numVeh].Trip[lP].duration = seg[numVeh].Trip[lP].endS - seg[numVeh].Trip[l].endS - problem->c[seg[numVeh].Trip[l].lastCus][curC];
				ll = l+3;
				seg[numVeh].Trip[ll] = seg[numVeh].Trip[lP];
				//cout<<"Update d-p trip: costD("<<numVeh<<", "<<(ll-1)<<") = "<<seg[numVeh].Trip[ll-1].cost<<"; Pcost("<<numVeh<<", "<<ll<<") = "<<seg[numVeh].Trip[lP].cost<<endl;
				while (curC > 0)
				{
					nextArrB[curC] = nextArrTemp[curC];
					curC = nextArrB[curC];
				}
				createTrip = 1; //create d-p trips
			} 
			else 
			{
				if (endSP == 0) createTrip = 0; //create last delivery trip
				else  createTrip = 2; //create only d trips
		       /*double buon = seg[numVeh].Trip[l].endS + problem->cDSP[seg[numVeh].Trip[l].lastCus][endSP];
			   if (!PDSINRANGE(buon, problem->nodeSP[endSP].sTW2, problem->nodeSP[endSP].eTW2))
			   {
				   double chan = buon - problem->nodeSP[endSPID].eTW2;
				   if (chan > eps)
				   {
					   cout<<"ERROR tao inv delivery trip: go directly to sp, exceed eTW of sp "<<(endSP)<<" = "<<problem->nodeSP[endSP].eTW2<<endl;
					   cout<<"seg[numVeh].Trip[l].waitingS = "<<seg[numVeh].Trip[l].waitingS<<endl;
					   cout<<"seg.Trip.endS = "<<seg[numVeh].Trip[l].endS<<"; dis = "<<problem->cDSP[seg[numVeh].Trip[l].lastCus][endSP]<<endl;
					   cout<<"sTW of sp = "<<problem->nodeSP[endSP].sTW2<<endl;
					   cout<<"lastCusD of trip = "<<seg[numVeh].Trip[l].lastCus<<" belongs to sp = "<<problem->nodeD[seg[numVeh].Trip[l].lastCus].sp<<endl;
                       showTripCost(numVeh, l);						  
				   }
			   }*/
			}
		    canRoute = 1; nextSP = endSP;
	}
}

// Create new C2C trip
int Solution::Create_New_C2C_Trip_Q(
							int inC2CPUIdx,
							int inVehNum,
							int inStartIdx,
							double leaveDepartSPIdx ,
							int inEndIdx
							)
{
	int arrTripTmp[2000];
	int inTripSzTmp;
	bool bRetVal;
	double arrBeginIime[2000];
	int inWSId;
	double leaveDepot;
	double dbEndS;
	int inVehCap;

	arrTripTmp[1] = inC2CPUIdx;
	arrTripTmp[2] = inC2CPUIdx + nOrder;
	inTripSzTmp = 2;

	//for (int inTimePeriod = 0; inTimePeriod < problem->nodeSP[startSPIdx].eTW1; inTimePeriod++)
	{
		leaveDepot = problem->node[inC2CPUIdx].sTW - problem->c[0][inC2CPUIdx];

		bRetVal = SetBeginTimeForPath_Q(leaveDepot, inStartIdx,
						arrTripTmp,
						inTripSzTmp,
						arrBeginIime,
						inEndIdx,
						&dbEndS,
						&inWSId,
						&inVehCap);

		if (true == bRetVal)
		{
			// Create new trip
			seg[numVeh].Trip[1].firstCus = inC2CPUIdx;			//id of the first Customer of Leg
			seg[numVeh].Trip[1].lastCus = inC2CPUIdx + nOrder;   //id of the first Customer of Leg
			seg[numVeh].Trip[1].Type = TRIP_C2C;						//c2c
			seg[numVeh].Trip[1].numCus = 2;						 //#Customers in the leg
			seg[numVeh].Trip[1].capacity = inVehCap;			 
			//nextArr[seed] = 0; //just correct for initial solution		
			seg[numVeh].Trip[1].waitingS = inWSId;		
			seg[numVeh].Trip[1].feasible = 1;	
			seg[numVeh].Trip[1].leaveSP = leaveDepot;
			seg[numVeh].Trip[1].endS = dbEndS;
			seg[numVeh].Trip[1].nextSP = -1;

			seg[numVeh].Trip[1].startNodeIdx = inStartIdx;
			seg[numVeh].Trip[1].endNodeIdx = inEndIdx;
			
			seg[numVeh].numTrips = 1;

			// Get cost
			//seg[numVeh].Trip[0].cost = costMINI;

			// Update status of demand and SP
			routed[inC2CPUIdx] = 1;
			routed[inC2CPUIdx + nOrder] = 1;
			//numCusDRouted[startSPIdx]++;

			int curC = seg[numVeh].Trip[1].firstCus;
			nextArr[curC] =  seg[numVeh].Trip[1].lastCus;
			curC = nextArr[curC];
			nextArr[curC] = -1;

			return 0;

		}
	}


	return -1;
}

// Create single C2C: Depot --> c2c --> depo
int Solution::Create_Single_C2C_Trip_Q(
							int inC2CPUIdx,							
							int inVehNum)
{
	int arrTripTmp[2000];
	int inTripSzTmp;
	bool bRetVal;
	double arrBeginIime[2000];
	int inWSId;
	double leaveDepot;
	double dbEndS;
	int inVehCap;

	arrTripTmp[1] = inC2CPUIdx;
	arrTripTmp[2] = inC2CPUIdx + nOrder;
	inTripSzTmp = 2;

	//for (int inTimePeriod = 0; inTimePeriod < problem->nodeSP[startSPIdx].eTW1; inTimePeriod++)
	{
		leaveDepot = problem->node[inC2CPUIdx].sTW - problem->c[0][inC2CPUIdx];

		bRetVal = SetBeginTimeForPath_Q(leaveDepot, 0,
						arrTripTmp,
						inTripSzTmp,
						arrBeginIime,
						0,
						&dbEndS,
						&inWSId,
						&inVehCap);

		if (true == bRetVal)
		{
			// Create new trip
			seg[numVeh].Trip[1].firstCus = inC2CPUIdx;			//id of the first Customer of Leg
			seg[numVeh].Trip[1].lastCus = inC2CPUIdx + nOrder;   //id of the first Customer of Leg
			seg[numVeh].Trip[1].Type = TRIP_C2C;						//c2c
			seg[numVeh].Trip[1].numCus = 2;						 //#Customers in the leg
			seg[numVeh].Trip[1].capacity = inVehCap;			 
			//nextArr[seed] = 0; //just correct for initial solution		
			seg[numVeh].Trip[1].waitingS = inWSId;		
			seg[numVeh].Trip[1].feasible = 1;	
			seg[numVeh].Trip[1].leaveSP = leaveDepot;
			seg[numVeh].Trip[1].endS = dbEndS;
			seg[numVeh].Trip[1].nextSP = -1;

			seg[numVeh].Trip[1].startNodeIdx = 0;
			seg[numVeh].Trip[1].endNodeIdx = 0;
			seg[numVeh].Trip[1].assSP = -1;
			
			seg[numVeh].numTrips = 1;

			// Get cost
			//seg[numVeh].Trip[0].cost = costMINI;

			// Update status of demand and SP
			routed[inC2CPUIdx] = 1;
			routed[inC2CPUIdx + nOrder] = 1;
			//numCusDRouted[startSPIdx]++;

			int curC = seg[numVeh].Trip[1].firstCus;
			nextArr[curC] =  seg[numVeh].Trip[1].lastCus;
			curC = nextArr[curC];
			nextArr[curC] = -1;

			return 0;

		}
	}


	return -1;
}

// Create single pickup trip: DEPOT --> SP --> delivery(s) --> DEPOT
int Solution::Create_Single_Delivery_Trip_Q(
							int inDEIdx,
							int startSPIdx,
							int inVehNum)
{
	int arrTripTmp[2000];
	int inTripSzTmp;
	bool bRetVal;
	double arrBeginIime[2000];
	int inWSId;
	double leaveDepot;
	double dbEndS;
	int inVehCap;

	arrTripTmp[1] = inDEIdx;
	inTripSzTmp = 1;

	for (int inTimePeriod = problem->nodeSP[startSPIdx].sTW1; inTimePeriod < problem->nodeSP[startSPIdx].eTW1; inTimePeriod++)
	{
		leaveDepot = inTimePeriod + problem->nodeSP[startSPIdx].load;

		bRetVal = SetBeginTimeForPath_Q(leaveDepot, startSPIdx,
						arrTripTmp,
						inTripSzTmp,
						arrBeginIime,
						0,
						&dbEndS,
						&inWSId,
						&inVehCap);

		if (true == bRetVal)
		{
			// Create new trip
			seg[numVeh].Trip[1].firstCus = inDEIdx;  //id of the first Customer of Leg
			seg[numVeh].Trip[1].lastCus = inDEIdx;   //id of the first Customer of Leg
			seg[numVeh].Trip[1].Type = TRIP_DELIVERY;			 //delivery trip
			seg[numVeh].Trip[1].numCus = 1;			 //#Customers in the leg
			seg[numVeh].Trip[1].capacity = inVehCap;			 
			//nextArr[seed] = 0; //just correct for initial solution		
			seg[numVeh].Trip[1].waitingS = inWSId;		
			seg[numVeh].Trip[1].feasible = 1;	
			seg[numVeh].Trip[1].leaveSP = leaveDepot;
			seg[numVeh].Trip[1].endS = dbEndS;
			seg[numVeh].Trip[1].nextSP = -1;

			seg[numVeh].Trip[1].startNodeIdx = startSPIdx;
			seg[numVeh].Trip[1].endNodeIdx = 0;
			seg[numVeh].Trip[1].assSP = startSPIdx;
			
			seg[numVeh].numTrips = 1;

			// Get cost
			//seg[numVeh].Trip[0].cost = costMINI;

			// Update status of demand and SP
			routed[inDEIdx]=1;  			
			numCusDRouted[startSPIdx]++;
			nextArr[inDEIdx] = -1;

			return 0;

		}
	}


	return -1;
}

// Create single pickup trip: DEPOT --> pickup(s) --> [Waiting Station] --> SP --> DEPOT
int Solution::Create_Single_Pickup_Trip_Q(
							int inPUIdx,
							int endSPIdx,
							int inVehNum)
{
	int arrTripTmp[2000];
	int inTripSzTmp;
	bool bRetVal;
	double arrBeginIime[2000];
	int inWSId;
	double leaveDepot;
	double dbEndS;
	int inVehCap;

	arrTripTmp[1] = inPUIdx;
	inTripSzTmp = 1;

	for (int inTimePeriod = 0; inTimePeriod < problem->nodeSP[endSPIdx].sTW1; inTimePeriod++)
	{
		leaveDepot = inTimePeriod;
		bRetVal = SetBeginTimeForPath_Q(leaveDepot, 0,
						arrTripTmp,
						inTripSzTmp,
						arrBeginIime,
						endSPIdx,
						&dbEndS,
						&inWSId,
						&inVehCap);

		if (true == bRetVal)
		{
			// Create new trip
			seg[numVeh].Trip[1].firstCus = inPUIdx;  //id of the first Customer of Leg
			seg[numVeh].Trip[1].lastCus = inPUIdx;   //id of the first Customer of Leg
			seg[numVeh].Trip[1].Type = TRIP_PICKUP;			 //PICKUP trip
			seg[numVeh].Trip[1].numCus = 1;			 //#Customers in the leg
			seg[numVeh].Trip[1].capacity = inVehCap;			 
			//nextArr[seed] = 0; //just correct for initial solution		
			seg[numVeh].Trip[1].waitingS = inWSId;		
			seg[numVeh].Trip[1].feasible = 1;	
			seg[numVeh].Trip[1].leaveSP = leaveDepot;
			seg[numVeh].Trip[1].endS = dbEndS + problem->nodeSP[endSPIdx].unload;
			seg[numVeh].Trip[1].nextSP = 0;

			seg[numVeh].Trip[1].startNodeIdx = 0;
			seg[numVeh].Trip[1].endNodeIdx = endSPIdx;
			seg[numVeh].Trip[1].assSP = endSPIdx;
			
			seg[numVeh].numTrips = 1;

			// Get cost
			//seg[numVeh].Trip[0].cost = costMINI;

			// Update status of demand and SP
			//for (int i=1;i<seg[numVeh].Trip[0].numCus;i++)
			//{
			//	routed[arrTripTmp[i]]=1;
			//	nextArr[arrTripTmp[i]]= arrTripTmp[i+1];
			//}
			//nextArr[arrTripTmp[2*inC2CPickupNbr]]= 0;

			routed[inPUIdx]=1;  			
			numCusPRouted[endSPIdx]++;
			nextArr[inPUIdx] = -1;

			return 0;

		} else 
		{
			
		}
	}


	return -1;
}
// Create C2C Trip
bool Solution::Create_C2CTrip_Q( int departSPIdx,			// departure SP index: can be DEPOT, SP, last C2C-delivery, last delivery
								double leaveDepartSPIdx,	// departure time at departSPIdx
								int endSPIdx,				// eclude C2C PICKUP/DELIVERY demands
								int inCurrVehCap,			// current vehicle capacity - reserved
								int inCurrVehIdx,			// Current vehicle index
								int inCurrTripIdx)			// Current trip index
{
	int arrDemandCandidates[2000];
	int inCandidateNbr;


	inCandidateNbr = 0;
#if Q_DEBUG_C2C
			cout << "Build list of c2c-customer demands: " << departSPIdx << " -> " << endSPIdx << endl;
#endif
			for (int inC2CPIndex = problem->startidC2C; inC2CPIndex <= problem->endidC2CP; inC2CPIndex++) // scan all C2C Pickup
			{
				if (!routed[inC2CPIndex]) // unrouted c2c-pickup
				{
					if ((problem->node[inC2CPIndex].sTW < problem->nodeSP[endSPIdx].eTW1) && (problem->node[inC2CPIndex].sTW > problem->nodeSP[departSPIdx].sTW1))
					{
						inCandidateNbr++;
						arrDemandCandidates[inCandidateNbr] = inC2CPIndex;
#if Q_DEBUG_C2C
						cout << inC2CPIndex << " ";
#endif
					}
				}
			}
#if Q_DEBUG_C2C
			cout << endl;
#endif
			// Sort candidates increase by EARLY time
			for (int i = 1; i <= inCandidateNbr; i++)
			{
				for (int j = i+1; j <= inCandidateNbr; j++)
				{
					if (problem->node[arrDemandCandidates[i]].sTW > problem->node[arrDemandCandidates[j]].sTW)
					{
						int inNodeTmp =  arrDemandCandidates[i];
						arrDemandCandidates[i] = arrDemandCandidates[j];
						arrDemandCandidates[j] = inNodeTmp;
					}
				}
			}
#if Q_DEBUG_C2C
			cout << "Sorted C2C PICKUP: ";
			for (int i = 1; i <= inCandidateNbr; i++)
			{
				cout << arrDemandCandidates[i] << " ";
			}
			cout << endl;
#endif

			// APPLY SOLOMON ALGORITHM TO CREATE A NEW C2C TRIP
		bool bRetVal = CreateC2CTripSolomonI1_Q(inCurrVehIdx, inCurrTripIdx,  // current vehicle, current trip idc
			0,	// current capacity
			departSPIdx, leaveDepartSPIdx, // Start point index, departure time 
			endSPIdx, Get_Node_Type(endSPIdx), // End point index, type of endpoint
			0, 0,	// Not used 
			arrDemandCandidates, inCandidateNbr); // candidate list
		if (true == bRetVal) 
		{
			if (false == Valid_A_Trip(inCurrVehIdx, inCurrTripIdx+1))
			{
				cout << " CreateC2CTripSolomonI1_Q::Valid failed" << endl; getchar();
			}
#if Q_DEBUG_C2C
			Show_A_Trip(inCurrVehIdx, inCurrTripIdx+1);
#endif
			return true;
		} else
		{
#if Q_DEBUG_C2C
			cout << "Cannot make initial C2C " << endl;
#endif
		}
	return false;
}
/*
 * Create pickup trip departSPIdx --> pickup(s) --> endSPIdx
 */
bool Solution::Create_PickupTrip_Q(
						   int departSPIdx,				// departure SP index: can be DEPOT, SP, last C2C-delivery, last delivery
					   	   double leaveDepartSPIdx,		// departure time at departSPIdx
						   int endSPIdx,				// can be DEPOT to pickup or SP
						   int inEndPointType,			// 0 - depot; 1 - pickup; 2- supply point to delivery

						   int inCurrVehCap,			// current vehicle capacity
						   int inCurrVehIdx,
						   int inCurrTripIdx
						   )
{
	int arrPUCan[2000];
	int inPUCanNbr = 0;
	int arrTripTmp[2000];
	int inTripSzTmp;
	bool bRetVal;
	double arrBeginIime[2000];
	int inWSId;
	int inVehCap;
	int arrTrip[2000];
	int inTripSz;
	double dbEnds;
	bool bIsRouted = false;
	double dbSavedEnds;
	int inSavedWSId;
	int inSavedVehCa;


#if Q_DEBUG_PICKUP
	cout << "Create a PICKUP trip from " <<  departSPIdx << " to " << endSPIdx << " at " <<  leaveDepartSPIdx << endl;
#endif

	int inNodeType = Get_Node_Type(endSPIdx);
	if (NODE_SUPPLY_POINT != inNodeType)
	{
		cout << endl << "\t\t\tCreate_PickupTrip_Q::must end at SP" << endl;
		return false;
	}


	// Vehicle has to be empty before starting PICKUP leg
	if (inCurrVehCap)
	{
		cout << "\t Vehicle is not empty" << endl;  getchar();
		return false;
	}

	/*
	 * Should build pickup candidates.
	 * Here, we get assigned pickup-customer-demands to SP endSPIdx
	 */
	if (numCusPRouted[endSPIdx] >= numCusPSP[endSPIdx]) // SP endSPIdx still has NO unrouted PICKUP demands
	{
		cout << "\t This SP has been routed all" << endl;  getchar();
		return false;
	}

#if Q_DEBUG_PICKUP
	cout << "List of PICKUP assigned to SP " << endSPIdx << " : " ;
#endif
	for (int index=1; index<=numCusPSP[endSPIdx]; index++)
	{
		int idCus = CusPSP[endSPIdx][index];
		if (routed[idCus] == 0)
		{ 
			if ((leaveDepartSPIdx + problem->c[departSPIdx][idCus]) > problem->node[idCus].eTW)
				continue;

#if Q_DEBUG_PICKUP
			cout << idCus << " ";
#endif

			inPUCanNbr++;
			arrPUCan[inPUCanNbr] = idCus;
		}
	}		
#if Q_DEBUG_PICKUP
	cout << endl;
#endif

	//Sort PU by early time  (Buble sort for quickly implement)
	for (int i = 1; i <= inPUCanNbr; i++)
	{
		for (int j = i+1; j <= inPUCanNbr; j++)
		{
			if (problem->node[arrPUCan[i]].sTW > problem->node[arrPUCan[j]].sTW)
			{
				int inTmp = arrPUCan[i];
				arrPUCan[i] = arrPUCan[j];
				arrPUCan[j] = inTmp;
			}
		}
	}
#if Q_DEBUG_PICKUP
	cout << "List of SORTED PICKUP assigned to SP " << endSPIdx << " : " ;
	for (int i = 1; i <= inPUCanNbr; i++)
	{
		cout << arrPUCan[i] << "(" << problem->node[arrPUCan[i]].sTW << "|" << problem->node[arrPUCan[i]].eTW << ") ";
	}
	cout << endl;
#endif

	// Solomon
	int inPUNbr = 0;
	inTripSzTmp = 0;
	inTripSz = 0;
	for (int inDECandidateIdx = 1; inDECandidateIdx <= inPUCanNbr; inDECandidateIdx++)
	{

		if (0 == inPUNbr) // the trip is empty
		{
			
			inTripSzTmp++;
			arrTripTmp[inTripSzTmp] = arrPUCan[inDECandidateIdx];

			bRetVal = SetBeginTimeForPath_Q(leaveDepartSPIdx, departSPIdx,
			arrTripTmp,
			inTripSzTmp,
			arrBeginIime,
			endSPIdx,
			&dbEnds,
			&inWSId,
			&inVehCap);
			if (true == bRetVal)
			{
#if Q_DEBUG_PICKUP
				cout << "\tCreat a new PICKUP trip...ok!" << endl;
#endif
				//memcpy(arrTrip, arrTripTmp, (inTripSzTmp)*sizeof(int));
				for (int i = 1; i <= inTripSzTmp; i++)
				{
					arrTrip[i] = arrTripTmp[i];
				}
				inTripSz = inTripSzTmp;
				inPUNbr++;
				bIsRouted = true;
				dbSavedEnds = dbEnds;
				inSavedWSId = inWSId;
				inSavedVehCa = inVehCap;
			} else 
			{
#if Q_DEBUG_PICKUP
				cout << "\tCreat a new PICKUP trip failed. Next node" << endl;
#endif
				continue;
			}
		} else // existed Pickup trip
		{
#if Q_DEBUG_PICKUP
			cout << "\tCurrent PICKUP trip: " << endl;
			for (int i = 1; i <= inPUNbr; i++)
			{
				cout << arrTrip[i] << "->";
			}
			cout << endl;
#endif

			for (int inPos = 1; inPos <= inPUNbr+1; inPos++)
			{
				inTripSzTmp = 0;
				//First move 1 -> inPos-1 from arrTrip to arrTripTmp
				for (int i = 1; i <= (inPos-1); i++)
				{
					inTripSzTmp++;
					arrTripTmp[inTripSzTmp] = arrTrip[i];
				}
				//Set arrPUCan[inDECandidateIdx] to inPos
				inTripSzTmp++;
				arrTripTmp[inTripSzTmp] = arrPUCan[inDECandidateIdx];
				// Move the remaining
				for (int i = inPos; i <= inPUNbr; i++)
				{
					inTripSzTmp++;
					arrTripTmp[inTripSzTmp] = arrTrip[i];
				}
#if Q_DEBUG_PICKUP
			cout << "\New PICKUP trip: " << endl;
			for (int i = 1; i <= inTripSzTmp; i++)
			{
				if (arrTripTmp[i] == arrPUCan[inDECandidateIdx])
				{
					cout << arrTripTmp[i] << "*->";
				} else
					cout << arrTripTmp[i] << "->";
			}
			cout << endl;
#endif

				bRetVal = SetBeginTimeForPath_Q(leaveDepartSPIdx, departSPIdx,
				arrTripTmp,
				inTripSzTmp,
				arrBeginIime,
				endSPIdx,
				&dbEnds,
				&inWSId,
				&inVehCap);
				if (true == bRetVal)
				{
#if Q_DEBUG_PICKUP
					cout << "\tInsert pickup " <<  arrPUCan[inDECandidateIdx] << "...ok!" << endl;
#endif
					//memcpy(arrTrip, arrTripTmp, (inTripSzTmp)*sizeof(int));
					for (int i = 1; i <= inTripSzTmp; i++)
					{
						arrTrip[i] = arrTripTmp[i];
					}
					inTripSz = inTripSzTmp;
					bIsRouted = true;
					dbSavedEnds = dbEnds;
					inSavedWSId = inWSId;
					inSavedVehCa = inVehCap;
					inPUNbr++;
					break;
				} else 
				{
#if Q_DEBUG_PICKUP
					cout << "\tInsert pickup " <<  arrPUCan[inDECandidateIdx] << "...failed!" << endl;
#endif
				}

			}
		}

	}

	if (bIsRouted == true)
	{
#if Q_DEBUG_PICKUP
			cout << "\Got PICKUP trip: " << endl;
			for (int i = 1; i <= inTripSz; i++)
			{
				cout << arrTrip[i] << "->";
			}
			cout << endl;
#endif

		// Create new trip
		seg[inCurrVehIdx].Trip[inCurrTripIdx+1].firstCus = arrTrip[1];  //id of the first Customer of Leg
		seg[inCurrVehIdx].Trip[inCurrTripIdx+1].lastCus = arrTrip[inTripSz];   //id of the first Customer of Leg
		seg[inCurrVehIdx].Trip[inCurrTripIdx+1].Type = TRIP_PICKUP;			 //DELIVERY trip
		seg[inCurrVehIdx].Trip[inCurrTripIdx+1].numCus = inTripSz;			 //#Customers in the leg
		seg[inCurrVehIdx].Trip[inCurrTripIdx+1].capacity = inSavedVehCa;			 
		//nextArr[seed] = 0; //just correct for initial solution		
		seg[inCurrVehIdx].Trip[inCurrTripIdx+1].waitingS = inSavedWSId;		
		seg[inCurrVehIdx].Trip[inCurrTripIdx+1].feasible = 1;	
		seg[inCurrVehIdx].Trip[inCurrTripIdx+1].leaveSP = leaveDepartSPIdx;
		seg[inCurrVehIdx].Trip[inCurrTripIdx+1].endS = dbSavedEnds + problem->nodeSP[endSPIdx].unload;
		seg[inCurrVehIdx].Trip[inCurrTripIdx+1].nextSP = 0;

		seg[inCurrVehIdx].Trip[inCurrTripIdx+1].startNodeIdx = departSPIdx;
		seg[inCurrVehIdx].Trip[inCurrTripIdx+1].endNodeIdx = endSPIdx;
		seg[inCurrVehIdx].Trip[inCurrTripIdx+1].assSP = departSPIdx;
			
		seg[inCurrVehIdx].numTrips += 1;


		int curC = seg[inCurrVehIdx].Trip[inCurrTripIdx+1].firstCus;
		routed[curC] = 1;
		for (int i = 2; i <= inTripSz; i++)
		{
			routed[arrTripTmp[i]] = 1;
			nextArr[curC] = arrTripTmp[i];
			curC = arrTripTmp[i];
		}
		nextArr[curC] = -1;		
			
		numCusDRouted[departSPIdx] += inTripSz;

		return true;
	}

	return false;

	//Initiate trip: departSPIdx --> endSPIdx
	inTripSzTmp = 0;
	for (int i = 1; i <= inPUCanNbr; i++)
	{
		inTripSzTmp++;
		arrTripTmp[inTripSzTmp] = arrPUCan[i];
	}

	for (int inNotTot = inTripSzTmp; inNotTot > 0; inNotTot--)
	{
		double dbEnds;
		bRetVal = SetBeginTimeForPath_Q(leaveDepartSPIdx, departSPIdx,
					arrTripTmp,
					inNotTot,
					arrBeginIime,
					endSPIdx,
					&dbEnds,
					&inWSId,
					&inVehCap);
		if (true == bRetVal)
		{
			// Create new trip
			seg[inCurrVehIdx].Trip[inCurrTripIdx+1].firstCus = arrTripTmp[1];  //id of the first Customer of Leg
			seg[inCurrVehIdx].Trip[inCurrTripIdx+1].lastCus = arrTripTmp[inNotTot];   //id of the first Customer of Leg
			seg[inCurrVehIdx].Trip[inCurrTripIdx+1].Type = TRIP_PICKUP;			 //PICKUP trip
			seg[inCurrVehIdx].Trip[inCurrTripIdx+1].numCus = inNotTot;			 //#Customers in the leg
			seg[inCurrVehIdx].Trip[inCurrTripIdx+1].capacity = inVehCap;			 
			//nextArr[seed] = 0; //just correct for initial solution		
			seg[inCurrVehIdx].Trip[inCurrTripIdx+1].waitingS = inWSId;		
			seg[inCurrVehIdx].Trip[inCurrTripIdx+1].feasible = 1;	
			seg[inCurrVehIdx].Trip[inCurrTripIdx+1].leaveSP = leaveDepartSPIdx;
			seg[inCurrVehIdx].Trip[inCurrTripIdx+1].endS = dbEnds + problem->nodeSP[endSPIdx].unload;
			seg[inCurrVehIdx].Trip[inCurrTripIdx+1].nextSP = 0;

			seg[inCurrVehIdx].Trip[inCurrTripIdx+1].startNodeIdx = departSPIdx;
			seg[inCurrVehIdx].Trip[inCurrTripIdx+1].endNodeIdx = endSPIdx;
			seg[inCurrVehIdx].Trip[inCurrTripIdx+1].assSP = endSPIdx;
			
			seg[inCurrVehIdx].numTrips += 1;


			int curC = seg[inCurrVehIdx].Trip[inCurrTripIdx+1].firstCus;
			routed[curC] = 1;
			for (int i = 2; i <= inNotTot; i++)
			{
				routed[arrTripTmp[i]] = 1;
				nextArr[curC] = arrTripTmp[i];
				curC = arrTripTmp[i];
			}
			nextArr[curC] = -1;		
			
			numCusPRouted[endSPIdx] += inNotTot;


			return true;
		}

	}


	return false;
}
/*
 * Create pickup trip departSPIdx --> pickup(s) --> endSPIdx
 */
bool Solution::Create_DeliveryTrip_Q2(
						   int departSPIdx,				// departure SP index: can be DEPOT, SP, last C2C-delivery, last delivery
					   	   double leaveDepartSPIdx,		// departure time at departSPIdx
						   int endSPIdx,				// can be DEPOT to pickup or SP
						   int inEndPointType,			// 0 - depot; 1 - pickup; 2- supply point to delivery

						   int inCurrVehCap,			// current vehicle capacity
						   int inCurrVehIdx,
						   int inCurrTripIdx)
{
	int arrPUCan[2000];		
	int inPUCanNbr = 0;
	int arrTripTmp[2000];
	int arrTrip[2000];
	int inTripSzTmp;
	int inTripSz;
	bool bRetVal;
	double arrBeginIime[2000]; 
	int inWSId;
	int inVehCap;
	double dbEnds;
	bool bIsRouted = false;
	double dbSavedEnds;
	int inSavedWSId;
	int inSavedVehCa;


#if Q_DEBUG_DELIVERY
	cout << "\t\t\t Create_DeliveryTrip_Q2";
#endif

	int inNodeType = Get_Node_Type(departSPIdx);
	if (inNodeType != NODE_SUPPLY_POINT)
	{
#if Q_DEBUG_DELIVERY
		cout << "\t\t\t Create_DeliveryTrip_Q2::Must start at Supply point!" ; getchar();
#endif
		return false;
	}

#if Q_DEBUG_DELIVERY
	cout << "Create a DELIVERY trip from " <<  departSPIdx << " to " << endSPIdx << " at " <<  leaveDepartSPIdx << endl;
#endif
	leaveDepartSPIdx += problem->nodeSP[departSPIdx].load;
#if Q_DEBUG_DELIVERY
	cout << "Loading time " <<  problem->nodeSP[departSPIdx].load << " --> leave at " <<  leaveDepartSPIdx << endl;
#endif

	// Vehicle has to be empty before starting PICKUP leg
	if (inCurrVehCap)
	{
		cout << "\t\t\t Create_DeliveryTrip_Q2::Vehicle is not empty" << endl; getchar();
		return false;
	}

	/*
	 * Should build pickup candidates.
	 * Here, we get assigned pickup-customer-demands to SP endSPIdx
	 */
	if (numCusDRouted[departSPIdx] >= problem->numCusDSP[departSPIdx]) // SP endSPIdx still has NO unrouted DELIVERY demands
	{
		cout << "\t\t\t Create_DeliveryTrip_Q2::SP doesnot have unrouted delivery" << endl;
		//getchar();
		return false;
	}

	double dbEarlyTime;
	
	inNodeType = Get_Node_Type(endSPIdx);
	switch (inNodeType)
	{
	case NODE_WAITING_STATION:
		return false;
	case NODE_SUPPLY_POINT:
			dbEarlyTime = problem->nodeSP[endSPIdx].sTW1;
			break;
		default:
			dbEarlyTime = problem->node[endSPIdx].sTW;
			break;
	}

#if Q_DEBUG_DELIVERY
	cout << "List of DELIVERY assigned to SP " << departSPIdx << " : " ;
#endif
	for (int index = startidD; index <= endidD; index++)
	{
		if (problem->node[index].zone == departSPIdx) // belongs to this SP
		{
			if (routed[index] == 0) // unrouted demands
			{ 
				//if ((problem->node[index].sTW > dbEarlyTime) || (problem->node[index].sTW < leaveDepartSPIdx))
				//	continue;
				if ((leaveDepartSPIdx + problem->c[departSPIdx][index]) > problem->node[index].eTW) // due-date
					continue;

#if Q_DEBUG_DELIVERY
				cout << index << " ";
#endif

				inPUCanNbr++;
				arrPUCan[inPUCanNbr] = index;
			}
		}
	}		
#if Q_DEBUG_DELIVERY
	cout << endl;
#endif

	//Sort PU by early time  (Buble sort for quickly implement)
	for (int i = 1; i <= inPUCanNbr; i++)
	{
		for (int j = i+1; j <= inPUCanNbr; j++)
		{
			if (problem->node[arrPUCan[i]].sTW > problem->node[arrPUCan[j]].sTW)
			{
				int inTmp = arrPUCan[i];
				arrPUCan[i] = arrPUCan[j];
				arrPUCan[j] = inTmp;
			}
		}
	}
#if Q_DEBUG_DELIVERY
	cout << "List of SORTED DELIVERY assigned to SP " << departSPIdx << " : " ;
	for (int i = 1; i <= inPUCanNbr; i++)
	{
		cout << arrPUCan[i] << "(" << problem->node[arrPUCan[i]].sTW << "|" << problem->node[arrPUCan[i]].eTW << ") ";
	}
	cout << endl;
#endif

	//Solomon
	int inDENbr = 0;
	inTripSzTmp = 0;
	inTripSz = 0;
	for (int inDECandidateIdx = 1; inDECandidateIdx <= inPUCanNbr; inDECandidateIdx++)
	{

		if (0 == inDENbr) // the trip is empty
		{
			
			inTripSzTmp++;
			arrTripTmp[inTripSzTmp] = arrPUCan[inDECandidateIdx];

			bRetVal = SetBeginTimeForPath_Q(leaveDepartSPIdx, departSPIdx,
			arrTripTmp,
			inTripSzTmp,
			arrBeginIime,
			endSPIdx,
			&dbEnds,
			&inWSId,
			&inVehCap);
			if (true == bRetVal)
			{
#if Q_DEBUG_DELIVERY
				cout << "\tCreat a new DELIVERY trip...ok!" << endl;
#endif
				//memcpy(arrTrip, arrTripTmp, (inTripSzTmp)*sizeof(int));
				for (int i = 1; i <= inTripSzTmp; i++)
				{
					arrTrip[i] = arrTripTmp[i];
				}
				inTripSz = inTripSzTmp;
				inDENbr++;
				bIsRouted = true;
				dbSavedEnds = dbEnds;
				inSavedWSId = inWSId;
				inSavedVehCa = inVehCap;
			} else 
			{
#if Q_DEBUG_DELIVERY
				cout << "\tCreat a new DELIVERY trip failed. Next node" << endl;
#endif
				continue;
			}
		} else // existed Delivery trip
		{
#if Q_DEBUG_DELIVERY
			cout << "\tCurrent DELIVERY trip: " << endl;
			for (int i = 1; i <= inDENbr; i++)
			{
				cout << arrTrip[i] << "->";
			}
			cout << endl;
#endif

			for (int inPos = 1; inPos <= inDENbr+1; inPos++)
			{
				inTripSzTmp = 0;
				//First move 1 -> inPos-1 from arrTrip to arrTripTmp
				for (int i = 1; i <= (inPos-1); i++)
				{
					inTripSzTmp++;
					arrTripTmp[inTripSzTmp] = arrTrip[i];
				}
				//Set arrPUCan[inDECandidateIdx] to inPos
				inTripSzTmp++;
				arrTripTmp[inTripSzTmp] = arrPUCan[inDECandidateIdx];
				// Move the remaining
				for (int i = inPos; i <= inDENbr; i++)
				{
					inTripSzTmp++;
					arrTripTmp[inTripSzTmp] = arrTrip[i];
				}
#if Q_DEBUG_DELIVERY
			cout << "\New DELIVERY trip: " << endl;
			for (int i = 1; i <= inTripSzTmp; i++)
			{
				if (arrTripTmp[i] == arrPUCan[inDECandidateIdx])
				{
					cout << arrTripTmp[i] << "*->";
				} else
					cout << arrTripTmp[i] << "->";
			}
			cout << endl;
#endif

				bRetVal = SetBeginTimeForPath_Q(leaveDepartSPIdx, departSPIdx,
				arrTripTmp,
				inTripSzTmp,
				arrBeginIime,
				endSPIdx,
				&dbEnds,
				&inWSId,
				&inVehCap);
				if (true == bRetVal)
				{
#if Q_DEBUG_DELIVERY
					cout << "\tInsert delivery " <<  arrPUCan[inDECandidateIdx] << "...ok!" << endl;
#endif
					//memcpy(arrTrip, arrTripTmp, (inTripSzTmp)*sizeof(int));
					for (int i = 1; i <= inTripSzTmp; i++)
					{
						arrTrip[i] = arrTripTmp[i];
					}
					inTripSz = inTripSzTmp;
					bIsRouted = true;
					dbSavedEnds = dbEnds;
					inSavedWSId = inWSId;
					inSavedVehCa = inVehCap;
					inDENbr++;
					break;
				} else 
				{
#if Q_DEBUG_DELIVERY
					cout << "\tInsert delivery " <<  arrPUCan[inDECandidateIdx] << "...failed!" << endl;
#endif
				}

			}
		}

	}

	if (bIsRouted == true)
	{
#if Q_DEBUG_DELIVERY
			cout << "\Got DELIVERY trip: " << endl;
			for (int i = 1; i <= inTripSz; i++)
			{
				cout << arrTrip[i] << "->";
			}
			cout << endl;
#endif

		// Create new trip
		seg[inCurrVehIdx].Trip[inCurrTripIdx+1].firstCus = arrTrip[1];  //id of the first Customer of Leg
		seg[inCurrVehIdx].Trip[inCurrTripIdx+1].lastCus = arrTrip[inTripSz];   //id of the first Customer of Leg
		seg[inCurrVehIdx].Trip[inCurrTripIdx+1].Type = TRIP_DELIVERY;			 //DELIVERY trip
		seg[inCurrVehIdx].Trip[inCurrTripIdx+1].numCus = inTripSz;			 //#Customers in the leg
		seg[inCurrVehIdx].Trip[inCurrTripIdx+1].capacity = inSavedVehCa;			 
		//nextArr[seed] = 0; //just correct for initial solution		
		seg[inCurrVehIdx].Trip[inCurrTripIdx+1].waitingS = inSavedWSId;		
		seg[inCurrVehIdx].Trip[inCurrTripIdx+1].feasible = 1;	
		seg[inCurrVehIdx].Trip[inCurrTripIdx+1].leaveSP = leaveDepartSPIdx - problem->nodeSP[departSPIdx].load;
		seg[inCurrVehIdx].Trip[inCurrTripIdx+1].endS = dbSavedEnds;
		seg[inCurrVehIdx].Trip[inCurrTripIdx+1].nextSP = 0;

		seg[inCurrVehIdx].Trip[inCurrTripIdx+1].startNodeIdx = departSPIdx;
		seg[inCurrVehIdx].Trip[inCurrTripIdx+1].endNodeIdx = endSPIdx;
		seg[inCurrVehIdx].Trip[inCurrTripIdx+1].assSP = departSPIdx;
			
		seg[inCurrVehIdx].numTrips += 1;


		int curC = seg[inCurrVehIdx].Trip[inCurrTripIdx+1].firstCus;
		routed[curC] = 1;
		for (int i = 2; i <= inTripSz; i++)
		{
			routed[arrTripTmp[i]] = 1;
			nextArr[curC] = arrTripTmp[i];
			curC = arrTripTmp[i];
		}
		nextArr[curC] = -1;		
			
		numCusDRouted[departSPIdx] += inTripSz;

		return true;
	}

	return false;


	//Initiate trip: departSPIdx --> endSPIdx
	inTripSzTmp = 0;
	for (int i = 1; i <= inPUCanNbr; i++)
	{
		inTripSzTmp++;
		arrTripTmp[inTripSzTmp] = arrPUCan[i];
	}

	for (int inNotTot = inTripSzTmp; inNotTot > 0; inNotTot--)
	{
		
		bRetVal = SetBeginTimeForPath_Q(leaveDepartSPIdx, departSPIdx,
					arrTripTmp,
					inNotTot,
					arrBeginIime,
					endSPIdx,
					&dbEnds,
					&inWSId,
					&inVehCap);
		if (true == bRetVal)
		{
			{
				// Create new trip
				seg[inCurrVehIdx].Trip[inCurrTripIdx+1].firstCus = arrTripTmp[1];  //id of the first Customer of Leg
				seg[inCurrVehIdx].Trip[inCurrTripIdx+1].lastCus = arrTripTmp[inNotTot];   //id of the first Customer of Leg
				seg[inCurrVehIdx].Trip[inCurrTripIdx+1].Type = TRIP_DELIVERY;			 //DELIVERY trip
				seg[inCurrVehIdx].Trip[inCurrTripIdx+1].numCus = inNotTot;			 //#Customers in the leg
				seg[inCurrVehIdx].Trip[inCurrTripIdx+1].capacity = inVehCap;			 
				//nextArr[seed] = 0; //just correct for initial solution		
				seg[inCurrVehIdx].Trip[inCurrTripIdx+1].waitingS = inWSId;		
				seg[inCurrVehIdx].Trip[inCurrTripIdx+1].feasible = 1;	
				seg[inCurrVehIdx].Trip[inCurrTripIdx+1].leaveSP = leaveDepartSPIdx - problem->nodeSP[departSPIdx].load;
				seg[inCurrVehIdx].Trip[inCurrTripIdx+1].endS = dbEnds;
				seg[inCurrVehIdx].Trip[inCurrTripIdx+1].nextSP = 0;

				seg[inCurrVehIdx].Trip[inCurrTripIdx+1].startNodeIdx = departSPIdx;
				seg[inCurrVehIdx].Trip[inCurrTripIdx+1].endNodeIdx = endSPIdx;
				seg[inCurrVehIdx].Trip[inCurrTripIdx+1].assSP = departSPIdx;
			
				seg[inCurrVehIdx].numTrips += 1;


				int curC = seg[inCurrVehIdx].Trip[inCurrTripIdx+1].firstCus;
				routed[curC] = 1;
				for (int i = 2; i <= inNotTot; i++)
				{
					routed[arrTripTmp[i]] = 1;
					nextArr[curC] = arrTripTmp[i];
					curC = arrTripTmp[i];
				}
				nextArr[curC] = -1;		
			
				numCusDRouted[departSPIdx] += inNotTot;
			}

			return true;
		}

	}


	return false;
}

/*
 *
 */
int Solution::Create_PickupTrip_Q_Old(int departSP, int &numTrip, 
								  double leave_departSP, int &nextSP, 
								  int endSP,
								  int typeofseed, int typeofINIT, int valueFEE)
{
	//Create a pickup trip (idVeh, idTrip) that leaves sp departSP where the time to leave departSP is leave_departSP:
    //int endSP1;
	bool canRoute = 0;
	double feeMIN = PDS_INFINITY;
    bool NULLTrip = 0;

	int idTrip = numTrip+2; //for storing temporary trip during call Init_NewSolomonI1_NewPickupTrip
	//for (endSP1=departSP+1; endSP1<=nSP;endSP1++)
	{
	  if (numCusPRouted[endSP] < numCusPSP[endSP] || numCusDRouted[endSP] < problem->numCusDSP[endSP]) //exist unrouted customers in sj
		  Init_NewSolomonI1_NewPickupTrip(departSP, endSP, idTrip,leave_departSP, nextSP, feeMIN, NULLTrip, typeofseed,valueFEE,typeofINIT,canRoute);
	}

	if (!canRoute) return 0; //p-departSP is already last trip

	int idB = idTrip+1;
	if (NULLTrip) //p -departSP (-- nextSP)  Note: thing in () is what be created
	{
		seg[numVeh].Trip[numTrip].connectCost = seg[numVeh].Trip[idB].cost;
		seg[numVeh].Trip[numTrip].cost += seg[numVeh].Trip[numTrip].connectCost;
		seg[numVeh].Trip[numTrip].waitingS1 = seg[numVeh].Trip[idB].waitingS;
		seg[numVeh].Trip[numTrip].arriveSP = seg[numVeh].Trip[idB].leaveSP;
		//cout<<"CREATING p -departSP (-- nextSP): picktrip("<<numVeh<<", "<<numTrip<<") = "<<seg[numVeh].Trip[numTrip].cost<<endl;
		return 2;
	}
	else //p - departSP - (p - nextSP)
	{
		   numTrip++;
		   seg[numVeh].Trip[numTrip] = seg[numVeh].Trip[idB]; //bestTrip is pickup: 
		   //cout<<endl;
		   //cout<<endl;
		   //cout<<"Create pickup trip ("<<numVeh<<", "<<numTrip<<"): assSP = "<<seg[numVeh].Trip[numTrip].assSP<<endl;
		   int preT = numTrip - 1;
		  
		   //Update all information for new trip:.....
		   int curC = seg[numVeh].Trip[numTrip].firstCus;
		   
		   seg[numVeh].Trip[preT].connectCost = problem->c[departSP][curC];
		   seg[numVeh].Trip[preT].cost += seg[numVeh].Trip[preT].connectCost;
		   seg[numVeh].Trip[numTrip].cost -= seg[numVeh].Trip[preT].connectCost;
		   //cout<<"CORRECT COST of pickuptrip("<<numVeh<<", "<<preT<<") = "<<seg[numVeh].Trip[preT].cost<<"; ???nextP cost = "<<seg[numVeh].Trip[numTrip].cost<<endl;
		  
		   while (curC > 0)
		   {
				routed[curC]=1;
				nextArr[curC]=nextArrB[curC];
				curC = nextArr[curC];
		   }
		   curC = seg[numVeh].Trip[numTrip].lastCus;
		   //nextArrP[curC]= 0;

		   numCusPRouted[nextSP] += seg[numVeh].Trip[numTrip].numCus; 	
		   double ArrTime;
		   //cout<<"curC = "<<curC<<"; nextSP = "<<nextSP<<endl;
		   if (seg[numVeh].Trip[numTrip].waitingS == NO_WS)
			 ArrTime = seg[numVeh].Trip[numTrip].endS + problem->c[curC][nextSP];
		   else
			 ArrTime = seg[numVeh].Trip[numTrip].endS + problem->disCWSSP[curC][nextSP];
		   ArrTime = PDS_MAX(ArrTime, problem->nodeSP[nextSP].sTW1);
		   seg[numVeh].Trip[numTrip].leaveSP = ArrTime + problem->nodeSP[nextSP].unload;
		   /*cout<<"p - departSP - (p - nextSP) Just create PICKUP trip "<<numTrip<<": numC = "<<seg[numVeh].Trip[numTrip].numCus<<"; firstC = "<<seg[numVeh].Trip[numTrip].firstCus<<"; sp = "<<seg[numVeh].Trip[numTrip].assSP<<endl;
		   int buc = seg[numVeh].Trip[numTrip].firstCus;
		   while (buc > 0)
		   {
			   cout<<buc<<"  ";
			   buc = nextArrD[buc];
		   }
		   cout<<endl;*/
		   //cout<<"Create Picktrip("<<numVeh<<", "<<numTrip<<") = "<<seg[numVeh].Trip[numTrip].cost<<endl;
	       return 1;
	}
}
int Solution::Create_PickupTrip(int departSP, int &numTrip, double leave_departSP, int &nextSP, int typeofseed, int typeofINIT, int valueFEE)
{
	//Create a pickup trip (idVeh, idTrip) that leaves sp departSP where the time to leave departSP is leave_departSP:
    int endSP;
	bool canRoute = 0;
	double feeMIN = PDS_INFINITY;
    bool NULLTrip = 0;

	int idTrip = numTrip+2; //for storing temporary trip during call Init_NewSolomonI1_NewPickupTrip
	for (endSP=departSP+1; endSP<=nSP;endSP++)
	  if (numCusPRouted[endSP] < numCusPSP[endSP] || numCusDRouted[endSP] < problem->numCusDSP[endSP]) //exist unrouted customers in sj
		  Init_NewSolomonI1_NewPickupTrip(departSP, endSP, idTrip,leave_departSP, nextSP, feeMIN, NULLTrip, typeofseed,valueFEE,typeofINIT,canRoute);
 
	if (!canRoute) return 0; //p-departSP is already last trip

	int idB = idTrip+1;
	if (NULLTrip) //p -departSP (-- nextSP)  Note: thing in () is what be created
	{
		seg[numVeh].Trip[numTrip].connectCost = seg[numVeh].Trip[idB].cost;
		seg[numVeh].Trip[numTrip].cost += seg[numVeh].Trip[numTrip].connectCost;
		seg[numVeh].Trip[numTrip].waitingS1 = seg[numVeh].Trip[idB].waitingS;
		seg[numVeh].Trip[numTrip].arriveSP = seg[numVeh].Trip[idB].leaveSP;
		//cout<<"CREATING p -departSP (-- nextSP): picktrip("<<numVeh<<", "<<numTrip<<") = "<<seg[numVeh].Trip[numTrip].cost<<endl;
		return 2;
	}
	else //p - departSP - (p - nextSP)
	{
		   numTrip++;
		   seg[numVeh].Trip[numTrip] = seg[numVeh].Trip[idB]; //bestTrip is pickup: 
		   //cout<<endl;
		   //cout<<endl;
		   //cout<<"Create pickup trip ("<<numVeh<<", "<<numTrip<<"): assSP = "<<seg[numVeh].Trip[numTrip].assSP<<endl;
		   int preT = numTrip - 1;
		  
		   //Update all information for new trip:.....
		   int curC = seg[numVeh].Trip[numTrip].firstCus;
		   
		   seg[numVeh].Trip[preT].connectCost = problem->c[departSP][curC];
		   seg[numVeh].Trip[preT].cost += seg[numVeh].Trip[preT].connectCost;
		   seg[numVeh].Trip[numTrip].cost -= seg[numVeh].Trip[preT].connectCost;
		   //cout<<"CORRECT COST of pickuptrip("<<numVeh<<", "<<preT<<") = "<<seg[numVeh].Trip[preT].cost<<"; ???nextP cost = "<<seg[numVeh].Trip[numTrip].cost<<endl;
		  
		   while (curC > 0)
		   {
				routed[curC]=1;
				nextArr[curC]=nextArrB[curC];
				curC = nextArr[curC];
		   }
		   curC = seg[numVeh].Trip[numTrip].lastCus;
		   //nextArrP[curC]= 0;

		   numCusPRouted[nextSP] += seg[numVeh].Trip[numTrip].numCus; 	
		   double ArrTime;
		   //cout<<"curC = "<<curC<<"; nextSP = "<<nextSP<<endl;
		   if (seg[numVeh].Trip[numTrip].waitingS == NO_WS)
			 ArrTime = seg[numVeh].Trip[numTrip].endS + problem->c[curC][nextSP];
		   else
			 ArrTime = seg[numVeh].Trip[numTrip].endS + problem->disCWSSP[curC][nextSP];
		   ArrTime = PDS_MAX(ArrTime, problem->nodeSP[nextSP].sTW1);
		   seg[numVeh].Trip[numTrip].leaveSP = ArrTime + problem->nodeSP[nextSP].unload;
		   /*cout<<"p - departSP - (p - nextSP) Just create PICKUP trip "<<numTrip<<": numC = "<<seg[numVeh].Trip[numTrip].numCus<<"; firstC = "<<seg[numVeh].Trip[numTrip].firstCus<<"; sp = "<<seg[numVeh].Trip[numTrip].assSP<<endl;
		   int buc = seg[numVeh].Trip[numTrip].firstCus;
		   while (buc > 0)
		   {
			   cout<<buc<<"  ";
			   buc = nextArrD[buc];
		   }
		   cout<<endl;*/
		   //cout<<"Create Picktrip("<<numVeh<<", "<<numTrip<<") = "<<seg[numVeh].Trip[numTrip].cost<<endl;
	       return 1;
	}
}


void Solution::Init_NewSolomonI1_NewPickupTrip(int departSP, int endSP, 
											   int idTrip, 
											   double leave_departSP, int &nextSP, 
											   double &feeMIN, bool &NULLTrip, 
											   int typeofseed, int valueFEE, int typeofINIT, bool &canRoute)
{
	bool emptyTrip = 0;
	double ArrTime, temp;
	
#if Q_DEBUG
	cout<<"Solution::Init_NewSolomonI1_NewPickupTrip departSP = "<<departSP<<"; endSP = "<<endSP<<"; leave_departSP = "<<leave_departSP<<"; eTW = "<<problem->nodeSP[endSP].eTW1<<endl;
#endif

	if (numCusPRouted[endSP] < numCusPSP[endSP])
	{
			int i, idCus, seed, insert_after, preINS, nextINS, curC, nextC; 
			int goWS, goWSMINI, WSIDtemp, IDinsert;
			double startSTemp, ArrTime1, costP, TOTALTIME, varcost,c1;
			for (i=1;i<=numCusPSP[endSP];i++)
			{
				idCus = CusPSP[endSP][i];
				routedTemp[idCus] = routed[idCus];                       
			}
			double costMINI = PDS_INFINITY; seed = -1;
			//P1.Insert first pickup customer:
			for (i=1;i<=numCusPSP[endSP];i++)
			{
				idCus = CusPSP[endSP][i];
				if (routedTemp[idCus]==0)
				{
					ArrTime = leave_departSP + problem->c[departSP][idCus];
					temp = ArrTime - problem->node[idCus].eTW;
					if (temp > eps) continue; //vioTW at idCus--> try another idCus
					ArrTime = PDS_MAX(ArrTime, problem->node[idCus].sTW) + problem->node[idCus].duration;
					ArrTime1 = ArrTime + problem->c[idCus][endSP];
					if (PDSINRANGE(ArrTime1, problem->nodeSP[endSP].sTW1, problem->nodeSP[endSP].eTW1)) 
					{
						  goWS=NO_WS;
						  costP = problem->c[departSP][idCus] + problem->c[idCus][endSP];
					}
					else
					{
						temp = ArrTime1 - problem->nodeSP[endSP].eTW1;
						if (temp > eps) continue;
						ArrTime1 = ArrTime + problem->disCWSSP[idCus][endSP];
						temp = ArrTime1 - problem->nodeSP[endSP].eTW1;
						if (temp > eps) continue;
						goWS = problem->CWSSP[idCus][endSP];
						costP = problem->c[departSP][idCus] + problem->disCWSSP[idCus][endSP];
					}
					if (costP < costMINI)
					{
						  seed=idCus;
						  costMINI = costP;
						  goWSMINI = goWS;
						  TOTALTIME = ArrTime;
					}
				}
			}//end for
     		if (seed != -1) //can insert pickup customer 
			{
				routedTemp[seed]=1;  
				seg[numVeh].Trip[idTrip].Type = 0;
				seg[numVeh].Trip[idTrip].assSP = endSP;
				//cout<<"Pickup seed = "<<seed<<": ASSSP = "<<seg[numVeh].Trip[idTrip].assSP<<endl;
				seg[numVeh].Trip[idTrip].firstCus = seed; //id of the first Customer of Leg
				seg[numVeh].Trip[idTrip].lastCus = seed; //id of the first Customer of Leg
				seg[numVeh].Trip[idTrip].numCus = 1; //#Customers in the leg
				seg[numVeh].Trip[idTrip].capacity = problem->node[seed].capacity;
				seg[numVeh].Trip[idTrip].waitingS = goWSMINI;
				nextArrTemp[seed] = 0; //just correct for initial solution
				seg[numVeh].Trip[idTrip].cost = costMINI;
				seg[numVeh].Trip[idTrip].endS = TOTALTIME;
				seg[numVeh].Trip[idTrip].feasible = 1;
			    goWS = goWSMINI;
	
				// P2. Continue to insert pickup customers:
				//starting to find customer to insert into the current trip (startSP, endSP):
				bool cont=true;  
				int WSID;
				do //each loop insert 1 pickup customer
				{
				    insert_after=-1; varcost = PDS_INFINITY;
				    int lastCP = seg[numVeh].Trip[idTrip].lastCus;  
					bool ok; 
					for (i=1;i<=numCusPSP[endSP];i++)
					{
					   idCus = CusPSP[endSP][i];
					   if (!routedTemp[idCus]  && (seg[numVeh].Trip[idTrip].capacity + problem->node[idCus].capacity <= problem->Q))
					   {
						    //1. try to insert pickup idCus at the beginning of the trip:
							ok=1; nextINS = seg[numVeh].Trip[idTrip].firstCus;
							ArrTime = leave_departSP + problem->c[departSP][idCus];
							temp = ArrTime - problem->node[idCus].eTW;
							if (temp > eps) continue; //check another idCus
							ArrTime = PDS_MAX(ArrTime, problem->node[idCus].sTW) + problem->node[idCus].duration;
							curC = idCus; nextC = seg[numVeh].Trip[idTrip].firstCus;
							while (nextC > 0)
							{
								ArrTime += problem->c[curC][nextC];
								temp = ArrTime - problem->node[nextC].eTW;
								if (temp > eps) {ok=0;break;} //vioTW at customer nextC
								else
								{
									ArrTime = PDS_MAX(ArrTime, problem->node[nextC].sTW) + problem->node[nextC].duration;
									curC = nextC; nextC = nextArrTemp[curC];
								}
							}
                            if (ok) //curC now points to last pick of trip (numVeh, l)
							{
								ArrTime1 = ArrTime + problem->c[curC][endSP];
								temp = problem->nodeSP[endSP].eTW1 - ArrTime1;
								if (temp > eps) //else too late to go to sp directly
								{
								   if (PDSINRANGE(ArrTime1,problem->nodeSP[endSP].sTW1, problem->nodeSP[endSP].eTW1))
									 WSIDtemp = NO_WS;
								   else
								   {
									  ArrTime1 = ArrTime + problem->disCWSSP[curC][endSP];
									  temp = ArrTime1 - problem->nodeSP[endSP].eTW1;
									  if (temp > eps) ok=0; //too late to go to sp through WS
									  else WSIDtemp = problem->CWSSP[curC][endSP];
								   }
								   if (ok) //ok to insert idCus at beginning of trip l
								   {
								 	  c1 = problem->c[departSP][idCus] + problem->c[idCus][nextINS] - problem->c[departSP][nextINS];
					                  if (goWS != WSIDtemp)
									  {
									  	if (goWS != NO_WS) //before go to WS, after insert don't need to go to WS:
											c1 += (problem->c[lastCP][endSP] - problem->disCWSSP[lastCP][endSP]);
										else 
										{
											    cout<<"Solution::Init_NewSolomonI1_NewPickupTrip ERROR before insert pickup customer go to sp, after insert go to WS "<<WSIDtemp<<endl;
												cout<<"Trying to insert pickup cus "<<idCus<<" at the beginning: ";
												showTripCostTemp(numVeh,idTrip);
												cout<<"After sp: "<<departSP<<endl;
												exit(-1);
										}
									 }
									 if (c1 < varcost) {varcost=c1; IDinsert=idCus; insert_after = 0;
														WSID=WSIDtemp;TOTALTIME = ArrTime;}  
														}
								  }//end if (temp > eps) //else too late to go to sp directly
							}//end if(ok) else vioTW at some pickup cus
													
							//2. Try to insert idCus after each customer j of the trip:
							preINS = seg[numVeh].Trip[idTrip].firstCus; 
							ArrTime = leave_departSP + problem->c[departSP][preINS];
							for (int j=1;j<=seg[numVeh].Trip[idTrip].numCus;j++)
							{
								ok=1;
								startSTemp = PDS_MAX(ArrTime, problem->node[preINS].sTW);
								ArrTime = startSTemp + problem->node[preINS].duration + problem->c[preINS][idCus];
								temp = ArrTime - problem->node[idCus].eTW;
								if (temp > eps) break; //vioTW at idCus --> don't need to check any j 
								ArrTime = PDS_MAX(ArrTime, problem->node[idCus].sTW) + problem->node[idCus].duration;
								//start checking TW from idCus to the end of the leg:
								curC = idCus; nextC = nextArrTemp[preINS];
								while (nextC > 0)
								{
									 ArrTime += problem->c[curC][nextC]; 
									 temp = ArrTime - problem->node[nextC].eTW;
									 if (temp > eps) {ok=0;break;}
									 else
									 {
										 ArrTime = PDS_MAX(ArrTime,problem->node[nextC].sTW) + problem->node[nextC].duration;
								    	 curC = nextC; nextC=nextArrTemp[curC];
									 }
							    }
								if (ok) //curC is now pointed to last cus of pickup trip
								{
								     ArrTime1=  ArrTime + problem->c[curC][endSP];
									 temp = problem->nodeSP[endSP].eTW1 - ArrTime1;
									 if (temp > eps)//else too late to go to sp directly
									 {
									     if (PDSINRANGE(ArrTime1,problem->nodeSP[endSP].sTW1, problem->nodeSP[endSP].eTW1))
											  WSIDtemp=NO_WS;
										 else
										 {
											  ArrTime1 = ArrTime + problem->disCWSSP[curC][endSP];
											  temp = ArrTime1 - problem->nodeSP[endSP].eTW1;
											  if (temp > eps) ok=0; //too late to go to sp through WS
											  else WSIDtemp = problem->CWSSP[curC][endSP];
										 }
										 if (ok)
										 {
											 if (j != seg[numVeh].Trip[idTrip].numCus)								        
											 {
												 nextINS = nextArrTemp[preINS];
												 c1 = problem->c[preINS][idCus] + problem->c[idCus][nextINS] - problem->c[preINS][nextINS];
												 if (goWS != WSIDtemp)
												 {
													 if (goWS != NO_WS) //before go to WS, after insert don't need to go to WS:
														 c1 += (problem->c[curC][endSP] - problem->disCWSSP[curC][endSP]);
													 else 
													 {
														 cout<<"Solution::Init_NewSolomonI1_NewPickupTrip ERROR before insert go to sp directly, after insert go to WS"<<endl;
														 cout<<"Trying to insert pickup "<<idCus<<" after "<<preINS<<": ";
														 showTripCostTemp(numVeh,idTrip);
														 exit(-1);
													 }
												 }
											 }
											 else //insert to the end of the trip:
											 {
												 c1 = problem->c[preINS][idCus];
												 if (goWS==NO_WS) //before insert customer idCus, go to sp directly
												 {
													 if (WSIDtemp ==NO_WS) c1 += (problem->c[idCus][endSP] - problem->c[preINS][endSP]);
													 else 
													 {
														 cout<<"Solution::Init_NewSolomonI1_NewPickupTrip  ERROR before insert go to sp directly, after insert need to go to WS"<<endl; 
														 cout<<"Trying to insert pickup "<<idCus<<" at the end of the pickup trip: ";
														 showTripCostTemp(numVeh,idTrip);
														 exit(-1);
													 }
												 }
												 else //before insert customer idCus, go to WS:
												 {
												     if (WSIDtemp == NO_WS) c1 += (problem->c[idCus][endSP] - problem->disCWSSP[preINS][endSP]);
													 else c1+=(problem->disCWSSP[idCus][endSP] - problem->disCWSSP[preINS][endSP]);
												 }
											 }
											 if (c1 < varcost) {varcost=c1; IDinsert=idCus; insert_after = preINS;WSID=WSIDtemp;TOTALTIME = ArrTime;} 
										 }//else too soon to go to sp directly, too late to go to sp through WS
									 }//else too late to go to sp directly													 						
								 }//end if (ok) :else vioTW at one customer of route
								 nextINS = nextArrTemp[preINS];
								 ArrTime = startSTemp + problem->node[preINS].duration + problem->c[preINS][nextINS];
								 preINS = nextINS;
							}//end for (j=1;j<=seg[numVeh].Trip[lP].numCus;j++)
					   }//end if of each pickup customer: if (!routedPTemp[i] && (seg[numVeh].Trip[lP].capacity + problem->nodeP[i].capacity <= problem->Q))
				    }//end for
				    // Now take the best insertion position:
					  if (insert_after!=-1)
					  {
							  //cout<<"Insert customer "<<IDinsert<<" after "<<insert_after<<endl;
							  if (insert_after == 0)
							  {
								  int pre = seg[numVeh].Trip[idTrip].firstCus;
								  seg[numVeh].Trip[idTrip].firstCus = IDinsert;
								  nextArrTemp[IDinsert] = pre;
								  //cout<<"************Insert customer "<<IDinsert<<" beginning of the leg: after delivery cus "<<insert_after<<"; varcost = "<<varcost<<endl;
								  //cout<<"/endS = "<<TOTALTIME<<"; goWS = "<<WSID<<"; (sTW,eTW)= ("<<problem->nodeD[endSPID].sTW<<", "<<problem->nodeD[endSPID].eTW<<")"<<endl;
							  }
							  else if (insert_after == seg[numVeh].Trip[idTrip].lastCus) //insert at the end of the leg:
							  {
								  nextArrTemp[insert_after] = IDinsert;
								  seg[numVeh].Trip[idTrip].lastCus = IDinsert;
								  nextArrTemp[IDinsert]= 0;
								  //cout<<"*************Insert customer "<<IDinsert<<" at the end of the leg: after "<<insert_after<<"; varcost = "<<varcost<<endl;
								  //cout<<"endS = "<<TOTALTIME<<"; goWS = "<<WSID<<"; (sTW,eTW)= ("<<problem->nodeD[endSPID].sTW<<", "<<problem->nodeD[endSPID].eTW<<")"<<endl;
							  }
							  else //insert at the middile of the leg:
							  {
								  int tt=nextArrTemp[insert_after];
								  nextArrTemp[insert_after]=IDinsert;
								  nextArrTemp[IDinsert]=tt;
								  //cout<<"***********Insert customer "<<IDinsert<<" in the middle of the leg: after "<<insert_after<<"; varcost = "<<varcost<<endl;
								  //cout<<"endS = "<<TOTALTIME<<"; goWS = "<<WSID<<"; (sTW,eTW)= ("<<problem->nodeD[endSPID].sTW<<", "<<problem->nodeD[endSPID].eTW<<")"<<endl;
							  }
							  seg[numVeh].Trip[idTrip].numCus++;seg[numVeh].Trip[idTrip].waitingS = WSID;
							  routedTemp[IDinsert]=1;
							  seg[numVeh].Trip[idTrip].capacity += problem->node[IDinsert].capacity;
							  goWS = WSID;
							  seg[numVeh].Trip[idTrip].cost += varcost;
							  seg[numVeh].Trip[idTrip].endS =  TOTALTIME;
					   }//end  if (insert_after != -1)
				       else cont = false; //cannot find any pickup customer to insert into the current trip
			    }while (cont);//end do each loop insert 1 pickup customer
			}//end if (seed != -1)
			else
			{
#if Q_DEBUG
				cout<<"CANNOT create pickup trip connect these sp ("<<departSP<<", "<<endSP<<") even still have "<<(numCusPSP[endSP] - numCusPRouted[endSP])<<" unrouted pickup customers"<<endl;
#endif
				
				//for (i=1;i<=numCusPSP[endSP];i++)
				//{
				//	idCus = CusPSP[endSP][i];
				//	if (routedPTemp[idCus]==0)
				//	{
				//		cout<<"Pick "<<idCus<<": sTW = "<<problem->nodeP[idCus].sTW<<", eTW = "<<problem->nodeP[idCus].eTW<<"; dis1 = "<<problem->cPSP[idCus][departSP]<<"; dis2 = "<<problem->cPSP[idCus][endSP]<<"; dur = "<<problem->nodeP[idCus].duration<<endl;
				//	}
				//}

				return;
			}
	}
	else //empty trip: departSP (unload) - endSP
	{
		emptyTrip = 1;
		//therefore: numCusDRouted[endSP] < problem->numCusDSP[endSP]:
		ArrTime = seg[numVeh].Trip[idTrip-2].leaveSP + problem->c[departSP][endSP];
		if (PDSINRANGE(ArrTime, problem->nodeSP[endSP].sTW2, problem->nodeSP[endSP].eTW2))
		{
			seg[numVeh].Trip[idTrip].leaveSP = ArrTime;
			seg[numVeh].Trip[idTrip].waitingS = NO_WS;
			seg[numVeh].Trip[idTrip].cost = problem->c[departSP][endSP];
		}
		else
		{
			temp = ArrTime - problem->nodeSP[endSP].eTW2;
			if (temp > eps) 
			{
#if Q_DEBUG
				cout << "Invalida time 1" << endl;
#endif
				return;
			}
			ArrTime = seg[numVeh].Trip[idTrip-2].leaveSP + problem->disCWSSP[departSP][endSP];
			temp = ArrTime - problem->nodeSP[endSP].eTW2;
			if (temp > eps)
			{
#if Q_DEBUG
				cout << "Invalida time 2" << endl;
#endif
				return;
			}
			seg[numVeh].Trip[idTrip].leaveSP = PDS_MAX(ArrTime, problem->nodeSP[endSP].sTW2);
			seg[numVeh].Trip[idTrip].waitingS = problem->CWSSP[departSP][endSP];
			seg[numVeh].Trip[idTrip].cost = problem->disCWSSP[departSP][endSP];
		}
	}

	double fee;
    if (typeofINIT==1)
	{
			if (emptyTrip)
				fee = Q*seg[numVeh].Trip[idTrip].cost;
			else
			{
				fee = (problem->nodeSP[endSP].sTW1 - seg[numVeh].Trip[idTrip].endS) / seg[numVeh].Trip[idTrip].capacity;
				fee *= seg[numVeh].Trip[idTrip].cost;
			}
	}
	else if (typeofINIT==2)
	{
			if (emptyTrip)
				fee = Q*seg[numVeh].Trip[idTrip].cost;
			else
			{
				fee = valueFEE*((problem->nodeSP[endSP].sTW1 - seg[numVeh].Trip[idTrip].endS)/seg[numVeh].Trip[idTrip].capacity);
				fee += seg[numVeh].Trip[idTrip].cost;
			}
	}

#if Q_DEBUG
	cout << "Check fee: " << feeMIN << "/" << fee << endl;
#endif
	if (feeMIN > fee)
	{
		    feeMIN=fee; int ll = idTrip+1;
			seg[numVeh].Trip[ll] = seg[numVeh].Trip[idTrip];
			//cout<<"UPDATE pick BUC QUA: ("<<numVeh<<", "<<ll<<"): assSP = "<<seg[numVeh].Trip[ll].assSP<<"; cost = "<<seg[numVeh].Trip[ll].cost<<"; assSP = "<<seg[numVeh].Trip[idTrip].assSP<<endl;
			NULLTrip = emptyTrip;
			if (!emptyTrip)
			{
				int curC = seg[numVeh].Trip[idTrip].firstCus;
				while (curC >0)
				{
					nextArrB[curC] = nextArrTemp[curC];
					curC = nextArrB[curC];
				}
				seg[numVeh].Trip[ll].Type = 0;
			}
		    canRoute = 1; nextSP = endSP;
	}
}

/********************************************* CALCULATE INFORMATION *****************************************/

void Solution::calCostFromBeginning() //cal from the beginning, don't use calCostTripP, calCostTripD:
{
	int idVeh, idTrip,curC, nextC, nextTrip;
	double cTemp=0; double buc, bucT;
	cout<<"=====================   INSIDE calCostFromBeginning ==================="<<endl;
	for (idVeh=0;idVeh<numVeh;idVeh++)
	{
		buc = cTemp; bucT = cTemp;
		if (seg[idVeh].Trip[0].Type) cTemp += problem->c[0][seg[idVeh].Trip[0].assSP];
		else cTemp += problem->c[0][seg[idVeh].Trip[0].firstCus];
        for (idTrip=0;idTrip<seg[idVeh].numTrips;idTrip++)
		{
			if (seg[idVeh].Trip[idTrip].Type==1) //delivery trip
			{
				curC = seg[idVeh].Trip[idTrip].firstCus;
				cTemp += problem->c[seg[idVeh].Trip[idTrip].assSP][curC];
				nextC = nextArr[curC];
				while (nextC > 0)
				{
					cTemp += problem->c[curC][nextC];
					curC = nextC; nextC = nextArr[nextC];
				}
				nextTrip = idTrip+1;
				if (nextTrip < seg[idVeh].numTrips)
				{
					if (seg[idVeh].Trip[nextTrip].Type==1) //next trip is delivery trip --> delivery trip - delivery trip:
					{
						if (seg[idVeh].Trip[idTrip].waitingS == NO_WS) 
							 cTemp += problem->c[curC][seg[idVeh].Trip[nextTrip].assSP];
						else cTemp += problem->disCWSSP[curC][seg[idVeh].Trip[nextTrip].assSP];
					}
					else//next trip is pickup trip --> delivery trip - pickup trip:
	                    cTemp += problem->c[curC][seg[idVeh].Trip[nextTrip].firstCus];
				}
				bucT = cTemp - bucT;
				cout<<"Del trip("<<idVeh<<", "<<idTrip<<"): cost = "<<bucT<<"; assSP = "<<seg[idVeh].Trip[idTrip].assSP<<endl;
				bucT = cTemp;
			}
			else if (seg[idVeh].Trip[idTrip].Type==0) //pickup trip
			{
				curC = seg[idVeh].Trip[idTrip].firstCus;
				nextC = nextArr[curC];
				//cout<<"First cus = "<<curC<<"; numC = "<<seg[idVeh].Trip[idTrip].numCus<<";nextC = "<<nextC<<"; ";
				while (nextC > 0)
				{
					cTemp += problem->c[curC][nextC];
					curC = nextC; nextC = nextArr[nextC];
				}
				//cout<<"CurC =  "<<curC<<"; sp = "<<seg[idVeh].Trip[idTrip].assSP<<endl;
				if (seg[idVeh].Trip[idTrip].waitingS == NO_WS) 
					cTemp += problem->c[curC][seg[idVeh].Trip[idTrip].assSP];
				else cTemp += problem->disCWSSP[curC][seg[idVeh].Trip[idTrip].assSP];
				
				nextTrip = idTrip + 1;
				if (nextTrip < seg[idVeh].numTrips)
				{
					if (seg[idVeh].Trip[nextTrip].Type==0) //next trip is pickup trip --> pickup trip - pickup trip:
					{
						cTemp += problem->c[seg[idVeh].Trip[nextTrip].firstCus][seg[idVeh].Trip[idTrip].assSP];
					   // cout<<"firstC = "<<seg[idVeh].Trip[nextTrip].firstCus<<"; assSP = "<<seg[idVeh].Trip[idTrip].assSP<<"; dis = "<<problem->cPSP[seg[idVeh].Trip[nextTrip].firstCus][seg[idVeh].Trip[idTrip].assSP]<<"; ";
					}
					else if (seg[idVeh].Trip[nextTrip].assSP != seg[idVeh].Trip[idTrip].assSP) //next trip is NULL trip --> pickup - SP - SP':
					{
				        if (seg[idVeh].Trip[idTrip].waitingS1 == NO_WS)
							cTemp += problem->c[seg[idVeh].Trip[idTrip].assSP][seg[idVeh].Trip[nextTrip].assSP];
						else
						  cTemp += problem->disCWSSP[seg[idVeh].Trip[idTrip].assSP][seg[idVeh].Trip[nextTrip].assSP];
					}
				}
				bucT = cTemp - bucT;
				cout<<"Pick trip("<<idVeh<<", "<<idTrip<<"): cost = "<<bucT<<"; ws = "<<seg[idVeh].Trip[idTrip].waitingS<<"; endS = "<<seg[idVeh].Trip[idTrip].endS<<"; assSP = "<<seg[idVeh].Trip[idTrip].assSP<<endl;
				bucT = cTemp;
			}
		}
		int lastT = seg[idVeh].numTrips - 1;
		if (seg[idVeh].Trip[lastT].Type) cTemp += problem->c[seg[idVeh].Trip[lastT].lastCus][0];
		else cTemp += problem->c[seg[idVeh].Trip[lastT].assSP][0];
		buc = cTemp - buc;
		cout<<"Cost of vehicle "<<idVeh<<": =  "<<buc<<endl;
	}
   	cost = cTemp;
}

void Solution::CalInfromationTripD(int idVeh, int idTrip) 
{
	int startSP = seg[idVeh].Trip[idTrip].assSP; 
   	int nextTrip = idTrip + 1;

	double cArrTime, cArrTimeI;
	int curC, nextC;
	int i;
	double temp, tempC;

    //Update coordinate, leaveSP, 
	//Update predArrD, route_numD, trip_numD, posD, 
	//startSD, departD, waitTimeD, FvioTWCusD, vioTWCusD, vioCAP, vioTWSP
	//FCAPD, BCAPD
	//connectCost, cost, fitness, leaveSP,  endS,waitingS, arriveSP (if avail:SP-d-SP)

	if (idTrip==0)
	{
		seg[idVeh].Trip[idTrip].coordinate = 0;
		seg[idVeh].Trip[idTrip].leaveSP = problem->leaveSP[startSP][4]; //just load
		seg[idVeh].Trip[idTrip].vioTWSP = 0;
		tempC = problem->c[0][startSP];
	}
	else tempC =0 ;


	pos[startSP] = 0;
		//Create predArr:
		curC = seg[idVeh].Trip[idTrip].firstCus;
		predArr[curC]=-1;
		route_num[curC] = idVeh; trip_num[curC] = idTrip; pos[curC] = 1;

		//Update startS and waitTime for each customer:
    	cArrTime = seg[idVeh].Trip[idTrip].leaveSP + problem->c[startSP][curC];
		vioTWCus[curC] = PDS_MAX(0, cArrTime - problem->node[curC].eTW);
		FvioTWCus[curC] = vioTWCus[curC];
        if (vioTWCus[curC] > eps)
		{
			startS[curC] = problem->node[curC].eTW;
			depart[curC] = problem->node[curC].eTW + problem->node[curC].duration;
		}
		else
		{
		    startS[curC] = PDS_MAX(cArrTime, problem->node[curC].sTW);
		    depart[curC] = startS[curC] + problem->node[curC].duration;
		}
		FCAP[curC] = problem->node[curC].capacity;
		nextC = nextArr[curC];
		tempC += problem->c[startSP][curC];
		//cout<<"CurCost = "<<tempC<<endl;
		
		int numC = seg[idVeh].Trip[idTrip].numCus; 
		for (i=2;i<=numC;i++)
		{
			predArr[nextC] = curC; route_num[nextC] = idVeh; trip_num[nextC] = idTrip;
			pos[nextC] = i; FCAP[nextC] = FCAP[curC] + problem->node[nextC].capacity;
			cArrTime = depart[curC] + problem->c[curC][nextC];
			vioTWCus[nextC] = PDS_MAX(0, cArrTime - problem->node[nextC].eTW);
            if (vioTWCus[nextC] > eps)
			{
				FvioTWCus[nextC] = FvioTWCus[curC] + vioTWCus[nextC];
				startS[nextC] = problem->node[nextC].eTW;
				depart[nextC] = problem->node[nextC].depart;
			}
			else
			{
			    FvioTWCus[nextC] = FvioTWCus[curC];
				startS[nextC] = PDS_MAX(cArrTime, problem->node[nextC].sTW);
			    depart[nextC] = startS[nextC] + problem->node[nextC].duration;
			}
			tempC += problem->c[curC][nextC];
			curC = nextC; nextC=nextArr[curC];
		}
		nextArr[curC] = -1;

		if (PDSDIF(depart[curC], seg[idVeh].Trip[idTrip].endS))
		{
			cout<<"ERROR CalInfromationTripD("<<idVeh<<", "<<idTrip<<"): correct endS = "<<depart[curC]<<"; wrong from init sol= "<<seg[idVeh].Trip[idTrip].endS<<"; leave_startSP = "<<seg[idVeh].Trip[idTrip].leaveSP<<endl;
			exit(-1);
		}
		seg[idVeh].Trip[idTrip].endS = depart[curC];
		seg[idVeh].Trip[idTrip].vioTWC = FvioTWCus[curC];
		seg[idVeh].Trip[idTrip].vioCAP = PDS_MAX(FCAP[curC] - Q,0);

		if (nextTrip < seg[idVeh].numTrips) //idTrip is not the last trip
		{
			if (seg[idVeh].Trip[nextTrip].Type == 1) //next trip is delivery trip
			{	
				seg[idVeh].Trip[nextTrip].coordinate = 0;
				int nextSP = seg[idVeh].Trip[nextTrip].assSP;
				cArrTime = depart[curC] + problem->c[curC][nextSP];
				if (PDSINRANGE(cArrTime, problem->nodeSP[nextSP].sTW2, problem->nodeSP[nextSP].eTW2))
				{
					if (seg[idVeh].Trip[idTrip].waitingS != NO_WS)
					{	cout<<"Solution::CalInfromationTripD("<<idVeh<<", "<<idTrip<<") ERRROR: correct: noWS, wrong from init sol: waitS = "<<seg[idVeh].Trip[idTrip].waitingS<<endl;exit(-1);}
					seg[idVeh].Trip[idTrip].waitingS = NO_WS;
					seg[idVeh].Trip[idTrip].connectCost = problem->c[curC][nextSP];
					seg[idVeh].Trip[idTrip].arriveSP = cArrTime;

					seg[idVeh].Trip[nextTrip].leaveSP = cArrTime + problem->nodeSP[nextSP].load;
					seg[idVeh].Trip[nextTrip].vioTWSP = 0;
				}
				else
				{
					temp = cArrTime - problem->nodeSP[nextSP].eTW2;
					if (temp > eps) //too late to go to sp directly:
					{
						if (seg[idVeh].Trip[idTrip].waitingS != NO_WS)
						{	cout<<"Solution::CalInfromationTripD("<<idVeh<<", "<<idTrip<<" ERRROR: correct: noWS, wrong from init sol: waitS = "<<seg[idVeh].Trip[idTrip].waitingS<<endl;exit(-1);}
						seg[idVeh].Trip[idTrip].waitingS = NO_WS;
						seg[idVeh].Trip[idTrip].connectCost = problem->c[curC][nextSP];
						seg[idVeh].Trip[idTrip].arriveSP = problem->nodeSP[nextSP].eTW2;

						seg[idVeh].Trip[nextTrip].leaveSP = problem->leaveSP[nextSP][1]; //just load at eTW2
						seg[idVeh].Trip[nextTrip].vioTWSP = temp;
					}
					else // too soon to go to sp directly:
					{
						cArrTimeI = depart[curC] + problem->disCWSSP[curC][nextSP];
						temp = cArrTimeI - problem->nodeSP[nextSP].eTW2;
						if (temp > eps) // too soon to go to sp directly, too late to go through WS: --> go to sp directly INFEASIBILITY
						{
							if (seg[idVeh].Trip[idTrip].waitingS != NO_WS)
							{	cout<<"Solution::CalInfromationTripD("<<idVeh<<", "<<idTrip<<") ERRROR: correct: NO_WS, wrong from init sol: waitS = "<<seg[idVeh].Trip[idTrip].waitingS<<endl;exit(-1);}
							seg[idVeh].Trip[idTrip].waitingS = NO_WS;
							seg[idVeh].Trip[idTrip].connectCost = problem->c[curC][nextSP];
							seg[idVeh].Trip[idTrip].arriveSP = problem->nodeSP[nextSP].eTW2;

							seg[idVeh].Trip[nextTrip].leaveSP = problem->leaveSP[nextSP][1]; //just load at eTW2
							seg[idVeh].Trip[nextTrip].vioTWSP = problem->nodeSP[nextSP].sTW2 - cArrTime;
						}
						else //go to sp through WS: feasibility
						{
							if (seg[idVeh].Trip[idTrip].waitingS != problem->CWSSP[curC][nextSP])
							{	cout<<"Solution::CalInfromationTripD("<<idVeh<<", "<<idTrip<<") ERRROR: correct: "<<problem->CWSSP[curC][nextSP]<<", wrong from init sol: waitS = "<<seg[idVeh].Trip[idTrip].waitingS<<endl;exit(-1);}

							seg[idVeh].Trip[idTrip].waitingS = problem->CWSSP[curC][nextSP];
							seg[idVeh].Trip[idTrip].connectCost = problem->disCWSSP[curC][nextSP];
							seg[idVeh].Trip[idTrip].arriveSP = PDS_MAX(cArrTimeI, problem->nodeSP[nextSP].sTW2);
						
							seg[idVeh].Trip[nextTrip].leaveSP = seg[idVeh].Trip[idTrip].arriveSP + problem->nodeSP[nextSP].load; //just load
							seg[idVeh].Trip[nextTrip].vioTWSP = 0;
						}
					}
				}
				//seg[idVeh].Trip[idTrip].arriveSP = PDS_MAX(depart[curC] + seg[idVeh].Trip[idTrip].connectCost, problem->nodeSP[startSP].sTW2);
			}
			else  //next trip is pickup trip / C2C trip
			{
				seg[idVeh].Trip[nextTrip].coordinate = 0;
				seg[idVeh].Trip[idTrip].waitingS = NO_WS;
				seg[idVeh].Trip[idTrip].connectCost = problem->c[curC][seg[idVeh].Trip[nextTrip].firstCus];
			}
		}
		else seg[idVeh].Trip[idTrip].connectCost = problem->c[curC][0]; //lastTrip --> connectCost = dis(lastCus, depot)
		tempC += seg[idVeh].Trip[idTrip].connectCost;
		seg[idVeh].Trip[idTrip].cost = tempC;

		
		seg[idVeh].Trip[idTrip].fitness = tempC + COEFCAP * seg[idVeh].Trip[idTrip].vioCAP + COEFTWC * seg[idVeh].Trip[idTrip].vioTWC + COEFTWSP * seg[idVeh].Trip[idTrip].vioTWSP;
	 
		int lC = seg[idVeh].Trip[idTrip].lastCus; int BCTemp=0; double BvioTWTemp = 0;
		for (int kk=1; kk <= numC; kk++)
		{
		   BCTemp += problem->node[lC].capacity;
		   BCAP[lC] = BCTemp;
		   BvioTWTemp += vioTWCus[lC];
		   BvioTWCus[lC] = BvioTWTemp;
		   lC = predArr[lC];
		}
}


void Solution::CalInfromationTripP(int idVeh, int idTrip) 
{
	int assSP = seg[idVeh].Trip[idTrip].assSP; 
   	int nextTrip = idTrip + 1;

	double cArrTime, cArrTimeI;
	int curC, nextC;
	int i;
	double temp, tempC;

	//Update predArrP, route_numP, trip_numP, posP, 
	//startSP, departP, waitTimeP, vioTWCusP
	//endS, leaveSP, arriveSP (if avail:SP-d-SP)
	//FCAPP, BCAPP
	//connectCost, cost, fitness, vioTWSP, vioTWC, vioCAP, FvioTWC

	//Create predArr:
	curC = seg[idVeh].Trip[idTrip].firstCus;
	predArr[curC]=0;
	route_num[curC] = idVeh; trip_num[curC] = idTrip; pos[curC] = 1;

	if (idTrip==0)
	{
		/*cArrTime = problem->node[curC].sTW + problem->node[curC].duration + problem->c[curC][assSP];
        if (PDSINRANGE(cArrTime, problem->nodeSP[assSP].sTW1, problem->nodeSP[assSP].eTW1))
	        cArrTime = problem->node[curC].sTW;
		else
		{
			 cArrTime = problem->node[curC].sTW + problem->node[curC].duration + problem->disCWSSP[curC][assSP];
			 double temp = cArrTime - problem->nodeSP[assSP].eTW1;
			 if (temp > eps)
				 cArrTime = problem->nodeSP[assSP].eTW1 - problem->node[curC].duration - problem->c[curC][assSP];
			 else
		       cArrTime = problem->node[curC].sTW;
		}*/
        cArrTime = PDS_MAX(problem->c[0][curC], problem->node[curC].sTW);
	    tempC = problem->c[0][curC];
	}
	else
	{
		tempC = 0;
	    int preT = idTrip - 1;
		if (seg[idVeh].Trip[preT].Type == 0)
			cArrTime = seg[idVeh].Trip[preT].leaveSP + problem->c[seg[idVeh].Trip[preT].assSP][curC];
		else //if (seg[idVeh].Trip[preT].Type == 1)
		    cArrTime = depart[seg[idVeh].Trip[preT].lastCus] + problem->c[seg[idVeh].Trip[preT].lastCus][curC];
	}

	//Update startS and waitTime for each customer:
	vioTWCus[curC] = PDS_MAX(0, cArrTime - problem->node[curC].eTW);
	FvioTWCus[curC] = vioTWCus[curC];
    if (vioTWCus[curC] > eps)
	{
			startS[curC] = problem->node[curC].eTW;
			depart[curC] = startS[curC] + problem->node[curC].duration;
	}
	else
	{
		    startS[curC] = PDS_MAX(cArrTime, problem->node[curC].sTW);
		    depart[curC] = startS[curC] + problem->node[curC].duration;
	}
	FCAP[curC] = problem->node[curC].capacity;
	nextC = nextArr[curC];

		
		int numC = seg[idVeh].Trip[idTrip].numCus; 
		for (i=2;i<=numC;i++)
		{
			predArr[nextC] = curC; route_num[nextC] = idVeh; trip_num[nextC] = idTrip;
			pos[nextC] = i; FCAP[nextC] = FCAP[curC] + problem->node[nextC].capacity;
			cArrTime = depart[curC] + problem->c[curC][nextC];
			vioTWCus[nextC] = PDS_MAX(0, cArrTime - problem->node[nextC].eTW);
            if (vioTWCus[nextC] > eps)
			{
				FvioTWCus[nextC] = FvioTWCus[curC] + vioTWCus[nextC];
				startS[nextC] = problem->node[nextC].eTW;
				depart[nextC] = problem->node[nextC].depart;
			}
			else
			{
			    FvioTWCus[nextC] = FvioTWCus[curC];
				startS[nextC] = PDS_MAX(cArrTime, problem->node[nextC].sTW);
			    depart[nextC] = startS[nextC] + problem->node[nextC].duration;
			}
			tempC += problem->c[curC][nextC];
			curC = nextC; nextC=nextArr[curC];
		}

		if (PDSDIF(depart[curC], seg[idVeh].Trip[idTrip].endS))
		{
			cout<<"ERROR CalInfromationTripP("<<idVeh<<", "<<idTrip<<"): correct endS = "<<depart[curC]<<"; wrong from init sol= "<<seg[idVeh].Trip[idTrip].endS<<endl;
			exit(-1);
		}

		seg[idVeh].Trip[idTrip].endS = depart[curC];
		seg[idVeh].Trip[idTrip].vioTWC = FvioTWCus[curC];
		seg[idVeh].Trip[idTrip].vioCAP = PDS_MAX(FCAP[curC] - Q,0);

		cArrTime = depart[curC] + problem->c[curC][assSP];
		if (PDSINRANGE(cArrTime, problem->nodeSP[assSP].sTW1, problem->nodeSP[assSP].eTW1))
		{
			seg[idVeh].Trip[idTrip].vioTWSP = 0;
			if (seg[idVeh].Trip[idTrip].waitingS != NO_WS)
			{	
				cout<<"Solution::CalInfromationTripP("<<idVeh<<", "<<idTrip<<")ERRROR: correct: NO_WS, wrong from init sol: waitS = "<<seg[idVeh].Trip[idTrip].waitingS<<endl;
                cout<<"numC = "<<seg[idVeh].Trip[idTrip].numCus<<"; endS = "<<depart[curC]<<"; lastC = "<<curC<<"; assSP = "<<assSP<<"; disD = "<<problem->c[curC][assSP]<<"; sTW = "<<problem->nodeSP[assSP].sTW1<<"; eTW = "<<problem->nodeSP[assSP].eTW1<<endl; 			
				cout<<"arrTime= "<<cArrTime<<endl;
				exit(-1);
			}

			seg[idVeh].Trip[idTrip].waitingS = NO_WS;
			tempC += problem->c[curC][assSP];
			seg[idVeh].Trip[idTrip].leaveSP = cArrTime + problem->nodeSP[assSP].unload;
		}
		else
		{
			temp = cArrTime - problem->nodeSP[assSP].eTW1;
			if (temp > eps) //too late to go sp directly
			{
				seg[idVeh].Trip[idTrip].vioTWSP = temp;
				if (seg[idVeh].Trip[idTrip].waitingS != NO_WS)
				{	
					cout<<"Solution::CalInfromationTripP("<<idVeh<<", "<<idTrip<<") ERRROR: correct: NO_WS, wrong from init sol: waitS = "<<seg[idVeh].Trip[idTrip].waitingS<<endl;
					cout<<"numC = "<<seg[idVeh].Trip[idTrip].numCus<<"; endS = "<<depart[curC]<<"; lastC = "<<curC<<"; assSP = "<<assSP<<"; disD = "<<problem->c[curC][assSP]<<"; sTW = "<<problem->nodeSP[assSP].sTW1<<"; eTW = "<<problem->nodeSP[assSP].eTW1<<endl; 			
					cout<<"arrTime= "<<cArrTime<<"-->vioTWSP = "<<seg[idVeh].Trip[idTrip].vioTWSP<<endl;
		
					exit(-1);
				}

				seg[idVeh].Trip[idTrip].waitingS = NO_WS;
				tempC += problem->c[curC][assSP];
				seg[idVeh].Trip[idTrip].leaveSP = problem->leaveSP[assSP][0];
			}
			else
			{
				cArrTimeI = depart[curC] + problem->disCWSSP[curC][assSP];
				temp = cArrTimeI - problem->nodeSP[assSP].eTW1;
				if (temp > eps) //go to sp directly: unfeasibility (too soon to go to sp directly, too late to go through WS)
				{
					seg[idVeh].Trip[idTrip].vioTWSP = problem->nodeSP[assSP].sTW1 - cArrTime;
					if (seg[idVeh].Trip[idTrip].waitingS != NO_WS)
					{	cout<<"Solution::CalInfromationTripP("<<idVeh<<", "<<idTrip<<") ERRROR: correct: NO_WS; wrong from init sol: waitS = "<<seg[idVeh].Trip[idTrip].waitingS<<"; endS = "<<seg[idVeh].Trip[idTrip].endS<<"; startS = "<< depart[seg[idVeh].Trip[idTrip-1].lastCus]<<endl;exit(-1);}

					seg[idVeh].Trip[idTrip].waitingS = NO_WS;
					tempC += problem->c[curC][assSP];
					seg[idVeh].Trip[idTrip].leaveSP = problem->leaveSP[assSP][0]; //unload only at eTW1
				}
				else //go through WS: feasibility
				{
					seg[idVeh].Trip[idTrip].vioTWSP = 0;
					if (seg[idVeh].Trip[idTrip].waitingS != problem->CWSSP[curC][assSP])
					{	cout<<"Solution::CalInfromationTripP("<<idVeh<<", "<<idTrip<<") ERRROR: correct: "<<problem->CWSSP[curC][assSP]<<", wrong from init sol: waitS = "<<seg[idVeh].Trip[idTrip].waitingS<<"; endS = "<<seg[idVeh].Trip[idTrip].endS<<"; startS = "<< depart[seg[idVeh].Trip[idTrip-1].lastCus]<<endl;exit(-1);}
					seg[idVeh].Trip[idTrip].waitingS = problem->CWSSP[curC][assSP];
					tempC += problem->disCWSSP[curC][assSP];
					seg[idVeh].Trip[idTrip].leaveSP = PDS_MAX(cArrTimeI, problem->nodeSP[assSP].sTW1) + problem->nodeSP[assSP].unload;		
				}
			}
		}

		if (nextTrip < seg[idVeh].numTrips) //idTrip is not the last trip
		{
			if (seg[idVeh].Trip[nextTrip].Type ==1) //next trip is delivery trip
			{	
				int nextSP = seg[idVeh].Trip[nextTrip].assSP;
				if (nextSP == assSP)
				{
				    seg[idVeh].Trip[idTrip].connectCost = 0;

				    seg[idVeh].Trip[nextTrip].coordinate = 1; 
					seg[idVeh].Trip[nextTrip].leaveSP = seg[idVeh].Trip[idTrip].leaveSP + problem->nodeSP[nextSP].load;
					seg[idVeh].Trip[nextTrip].vioTWSP = seg[idVeh].Trip[idTrip].vioTWSP;
				}
				else
				{
					seg[idVeh].Trip[nextTrip].coordinate = 0; 
					cArrTime = seg[idVeh].Trip[idTrip].leaveSP + problem->c[assSP][nextSP];
					if (PDSINRANGE(cArrTime, problem->nodeSP[nextSP].sTW2, problem->nodeSP[nextSP].eTW2))
					{
						seg[idVeh].Trip[idTrip].connectCost = problem->c[assSP][nextSP];
						seg[idVeh].Trip[idTrip].waitingS1 = NO_WS;
						seg[idVeh].Trip[idTrip].arriveSP = cArrTime;

						seg[idVeh].Trip[nextTrip].vioTWSP = 0;
						seg[idVeh].Trip[nextTrip].leaveSP = cArrTime + problem->nodeSP[nextSP].load; //just load
					}
					else
					{
						temp = cArrTime - problem->nodeSP[nextSP].eTW2;
						if (temp > eps) //too late to go to sp directly:
						{
							seg[idVeh].Trip[idTrip].connectCost = problem->c[assSP][nextSP];
							seg[idVeh].Trip[idTrip].waitingS1 = NO_WS;
							seg[idVeh].Trip[idTrip].arriveSP = cArrTime;

							seg[idVeh].Trip[nextTrip].vioTWSP = temp;
							seg[idVeh].Trip[nextTrip].leaveSP = problem->leaveSP[nextSP][1]; //just load
						}
						else
						{
							cArrTimeI = seg[idVeh].Trip[idTrip].leaveSP + problem->disCWSSP[assSP][nextSP];
							temp = cArrTimeI - problem->nodeSP[nextSP].eTW2;
							if (temp > eps) //too soon to go to sp directly, too late to go sp through WS:
							{
								seg[idVeh].Trip[idTrip].connectCost = problem->c[assSP][nextSP];
								seg[idVeh].Trip[idTrip].waitingS1 = NO_WS;
								seg[idVeh].Trip[idTrip].arriveSP = problem->nodeSP[nextSP].sTW2;

								seg[idVeh].Trip[nextTrip].vioTWSP = problem->nodeSP[nextSP].sTW2 - cArrTime;
								seg[idVeh].Trip[nextTrip].leaveSP = problem->leaveSP[nextSP][1]; //just load
							}
							else //go to sp through WS: feasibility:
							{
								seg[idVeh].Trip[idTrip].connectCost = problem->disCWSSP[assSP][nextSP];
								seg[idVeh].Trip[idTrip].waitingS1 = problem->CWSSP[assSP][nextSP];
								seg[idVeh].Trip[idTrip].arriveSP = PDS_MAX(cArrTimeI, problem->nodeSP[nextSP].sTW2);

								seg[idVeh].Trip[idTrip].vioTWSP = 0;
								seg[idVeh].Trip[nextTrip].leaveSP = seg[idVeh].Trip[idTrip].arriveSP + problem->nodeSP[nextSP].load; //just load
							}
						}
					}
				}
			}
			else //if (seg[idVeh].Trip[nextTrip].Type == 0) //next trip is pickup trip
				seg[idVeh].Trip[idTrip].connectCost = problem->c[seg[idVeh].Trip[nextTrip].firstCus][assSP];
		}
		else seg[idVeh].Trip[idTrip].connectCost = problem->c[assSP][0]; //last pickup trip

		tempC += seg[idVeh].Trip[idTrip].connectCost;
		seg[idVeh].Trip[idTrip].cost = tempC;

		
		seg[idVeh].Trip[idTrip].fitness = tempC + COEFCAP * seg[idVeh].Trip[idTrip].vioCAP + COEFTWC * seg[idVeh].Trip[idTrip].vioTWC + COEFTWSP * seg[idVeh].Trip[idTrip].vioTWSP;
	 
		int lC = seg[idVeh].Trip[idTrip].lastCus; int BCTemp=0; double BvioTWTemp = 0;
		for (int kk=1; kk <= numC; kk++)
		{
		   BCTemp += problem->node[lC].capacity;
		   BCAP[lC] = BCTemp;
		   BvioTWTemp += vioTWCus[lC];
		   BvioTWCus[lC] = BvioTWTemp;
		   lC = predArr[lC];
		}
}

void Solution::calFitCostSumTrip()
{
	double cTemp = 0;
	double fTemp = 0;
	for (int i = 0;i <numVeh;i++)
		for (int j=0;j<seg[i].numTrips;j++)
		{
           cTemp += seg[i].Trip[j].cost;
		   fTemp += seg[i].Trip[j].fitness;
		}
	cost = cTemp;
	fitness = fTemp;
}

void Solution::UpdateCostFitnessFeasible()
{
	int i,j; cost=0; fitness=0; 
	vioCAPC=0; vioTWCC=0; vioTWSPC=0; //Current
	feasible=1; int numT, numTT=0; 
	bool stop, buon = false;

	for (i=0;i<numVeh;i++)
	{
		seg[i].vioCAP = 0; seg[i].vioTWC = 0; seg[i].vioTWSP = 0;
		seg[i].cost = 0; seg[i].fitness = 0;
		numT = seg[i].numTrips;
		numTT += numT;
		for (j=0;j<numT;j++)
		{
			seg[i].cost += seg[i].Trip[j].cost;
			seg[i].fitness += seg[i].Trip[j].fitness;
			if (seg[i].Trip[j].fitness < eps)
			{
				cout<<"ERROR fitness of trip ("<<i<<", "<<j<<") = "<<seg[i].Trip[j].fitness<<" < 0 "<<endl;
				buon = true;
			}
			if (!seg[i].Trip[j].feasible)
			{
				seg[i].feasible = 0;
				feasible=0; 
				seg[i].vioCAP += seg[i].Trip[j].vioCAP;
				seg[i].vioTWC += seg[i].Trip[j].vioTWC;
				seg[i].vioTWSP += seg[i].Trip[j].vioTWSP;
			}
			if (seg[i].Trip[j].Type)
			{
				stop = checkTripD_ALLFIELDS(i,j);
				if (stop) {cout<<"Solution::UpdateCostFitnessFeasible() Exit after call checkTripD tripD ("<<i<<", "<<j<<")..................."; exit(-1);}
			}
			else 
			{
				stop  = checkTripP_ALLFIELDS(i,j);
				if (stop) {cout<<"Solution::UpdateCostFitnessFeasible() Exit after call checkTripP tripP ("<<i<<", "<<j<<")..................."; exit(-1);}
			}

		}
		cost += seg[i].cost; fitness += seg[i].fitness;
		vioCAPC += seg[i].vioCAP; vioTWCC += seg[i].vioTWC;vioTWSPC += seg[i].vioTWSP; 
	}
	vioCAP = vioCAPC; vioTWC = vioTWCC; vioTWSP = vioTWSPC; //of Solution
	fitness += (F*numVehUsed);
	numTrips = numTT;
	//if (buon) {showSolution(); cout<<"ERRORRRRRRRRRRRRRR FIT < 0"<<endl;exit(-1);}
}

void Solution::UpdateCostFitnessFeasible1()
{
	int i,j; cost=0; fitness=0; 
	vioCAPC=0; vioTWCC=0; vioTWSPC=0; //Current
	feasible=1; int numT; 
	for (i=0;i<numVeh;i++)
	{
		seg[i].vioCAP = 0; seg[i].vioTWC = 0; seg[i].vioTWSP = 0;
		seg[i].cost = 0; seg[i].fitness = 0;
		numT = seg[i].numTrips;
		for (j=0;j<numT;j++)
		{
			seg[i].cost += seg[i].Trip[j].cost;
			if (!seg[i].Trip[j].feasible)
			{
				seg[i].feasible = 0;
				feasible=0; 
				seg[i].vioCAP += seg[i].Trip[j].vioCAP;
				seg[i].vioTWC += seg[i].Trip[j].vioTWC;
				seg[i].vioTWSP += seg[i].Trip[j].vioTWSP;
				seg[i].Trip[j].fitness = seg[i].Trip[j].cost + VCAP * seg[i].Trip[j].vioCAP + VTWCUS * seg[i].Trip[j].vioTWC + VTWSP * seg[i].Trip[j].vioTWSP; 
			}
			seg[i].fitness += seg[i].Trip[j].fitness;
		}
		cost += seg[i].cost; fitness += seg[i].fitness;
		vioCAPC += seg[i].vioCAP; vioTWCC += seg[i].vioTWC;vioTWSPC += seg[i].vioTWSP; 
	}
	vioCAP = vioCAPC; vioTWC = vioTWCC; vioTWSP = vioTWSPC; //of Solution
	fitness += (F*numVehUsed);
}

void Solution::UpdatePos(int idVeh, int idTrip)
{
	int i, curC = seg[idVeh].Trip[idTrip].firstCus;
	for (i=1; i<= seg[idVeh].Trip[idTrip].numCus; i++)
	{
		pos[curC] = i;
		curC = nextArr[curC];
	}
}

//------------------------------------------- SHOW SOLUTION-------------------------------//
void Solution::showTripCostTemp(int idVeh, int idTrip)
{
	int i;
	if (seg[idVeh].Trip[idTrip].Type==1) //delivery trip
	{
		cout<<"SP = "<<seg[idVeh].Trip[idTrip].assSP<<": ";
		int firstCus= seg[idVeh].Trip[idTrip].firstCus;
	    int lastCus = seg[idVeh].Trip[idTrip].lastCus;
		i=firstCus;
		while (i!=lastCus)
		{
				cout<<i<<", ";
				i = nextArrTemp[i];
		}
		cout<<lastCus<<endl;
	}
	else //pickup trip:
	{
		int firstCus= seg[idVeh].Trip[idTrip].firstCus;
	    int lastCus = seg[idVeh].Trip[idTrip].lastCus;
		i=firstCus;
		while (i!=lastCus)
		{
				cout<<i<<", ";
				i = nextArrTemp[i];
		}
		cout<<lastCus<<", ";
		if (seg[idVeh].Trip[idTrip].waitingS != NO_WS) cout<<"("<<seg[idVeh].Trip[idTrip].waitingS<<"), ";
		cout<<" sp = "<<seg[idVeh].Trip[idTrip].assSP<<endl;
	}
}

void Solution::showTripCost(int idVeh, int idTrip)
{
	int i;
	if (seg[idVeh].Trip[idTrip].Type==1) //delivery trip
	{
		if (seg[idVeh].Trip[idTrip].coordinate)
		  cout<<"CORDelivery trip: sp = "<<seg[idVeh].Trip[idTrip].assSP<<", cap = "<<seg[idVeh].Trip[idTrip].capacity<<", cost = "<<seg[idVeh].Trip[idTrip].cost<<", connectCost = "<<seg[idVeh].Trip[idTrip].connectCost<<" (numC = "<<seg[idVeh].Trip[idTrip].numCus<<"): ";
		else
		  cout<<"NOTCORDelivery trip: sp = "<<seg[idVeh].Trip[idTrip].assSP<<", cap = "<<seg[idVeh].Trip[idTrip].capacity<<", cost = "<<seg[idVeh].Trip[idTrip].cost<<", connectCost = "<<seg[idVeh].Trip[idTrip].connectCost<<" (numC = "<<seg[idVeh].Trip[idTrip].numCus<<"): ";
		int firstCus= seg[idVeh].Trip[idTrip].firstCus;
	    int lastCus = seg[idVeh].Trip[idTrip].lastCus;
		i=firstCus;
		while (i!=lastCus)
		{
				cout<<i<<", ";
				i = nextArr[i];
		}
		cout<<lastCus;
		int nextTrip = idTrip+1;
		if (seg[idVeh].numTrips == nextTrip) cout<<", depot"<<endl;
		else
			if (seg[idVeh].Trip[nextTrip].Type)
			{
				if (seg[idVeh].Trip[idTrip].waitingS != NO_WS) cout<<", (WS = "<<seg[idVeh].Trip[idTrip].waitingS<<")"<<endl;
				else cout<<endl;
			}
			else cout<<", pickcus = "<<seg[idVeh].Trip[nextTrip].firstCus<<endl;
	}
	else //pickup trip:
	{
		cout<<"Pickup trip ("<<idVeh<<", "<<idTrip<<"): cap  = "<<seg[idVeh].Trip[idTrip].capacity<<", cost = "<<seg[idVeh].Trip[idTrip].cost<<", connectCost =  "<<seg[idVeh].Trip[idTrip].connectCost<<": ";
		int firstCus= seg[idVeh].Trip[idTrip].firstCus;
	    int lastCus = seg[idVeh].Trip[idTrip].lastCus;
		i=firstCus;
		while (i!=lastCus)
		{
				cout<<i<<", ";
				i = nextArr[i];
		}
		cout<<lastCus<<", ";
		if (seg[idVeh].Trip[idTrip].waitingS != NO_WS) cout<<"("<<seg[idVeh].Trip[idTrip].waitingS<<"), ";
		cout<<" sp = "<<seg[idVeh].Trip[idTrip].assSP<<endl;
		//cout<<"BUON WS = "<<seg[idVeh].Trip[idTrip].waitingS<<"; vioCAP = "<<seg[idVeh].Trip[idTrip].vioCAP<<"; vioTWSP = "<<seg[idVeh].Trip[idTrip].vioTWSP<<"; fea = "<<seg[idVeh].Trip[idTrip].feasible<<"; lastC = "<<seg[idVeh].Trip[idTrip].lastCus<<"; endS = "<<seg[idVeh].Trip[idTrip].endS<<"; connectCost = "<<seg[idVeh].Trip[idTrip].connectCost<<"; dur = "<<seg[idVeh].Trip[idTrip].duration<<endl;

	}
}

/*
 * Export a solution to file
 * First line contains the following information:
 * costTot		:Total of cost
 * numVeh	:Total of used vehicles
 * Information of trips are represented in following lines. Each used vehicle contains 6 lines:
 * tripTot		Number of trip
 * Each trip contains 5 lines with following information:
 * tripType	tripCost		: Type of trip (pickup/delivery/c2c) and cost of trip
 * startNode	leaveTime	:  
 * endNode	endTime	:
 * tripNodeTot			: Total of nodes in trip (excluded startNode and endNode)
 * The list of nodes in trip
 */
void Solution::exportSolution(void)
{
    int i,j,curC;
    double dbStartTime;
    int arrSol[2000]; //TODO
    int inSolNode;

	ofstream infile;

	cout << "Exporting SOLUTION to file solution.sol" << endl;

	// Open file for writing
    infile.open("solution.sol",ios::out); 
    if (!infile){	 
		cout << "\n\tInput file not found !!!!!!" << endl; 		
		exit(-1);
	}

	/* First line contains the following information:
	 * costTot		:Total of cost
	 * numVeh	    :Total of used vehicles
	 */
	infile << cost << " " << (numVeh-1) << endl;


	/* Information of trips are represented in following lines. Each used vehicle contains 6 lines:
	 * tripTot		Number of trip
	 * Each trip contains 5 lines with following information:
	 * tripType	tripCost		: Type of trip (pickup/delivery/c2c) and cost of trip
	 * startNode	leaveTime	:  
	 * endNode	endTime	:
	 * tripNodeTot			: Total of nodes in trip (excluded startNode and endNode)
	 * The list of nodes in trip
	 */
   for (i = 1; i <= numVeh; i++) // to consildation, we do not use 0 index.
   {
	   //tripTot		Number of trip
       infile << seg[i].numTrips << endl;
	   
	   for (j = 1; j <= seg[i].numTrips; j++)
	   {
		   //tripType	tripCost		: Type of trip (pickup/delivery/c2c) and cost of trip
		   infile << seg[i].Trip[j].Type << " " << seg[i].Trip[j].cost << endl;

		   //startNode	leaveTime	:  
		   infile << seg[i].Trip[j].startNodeIdx << " " << seg[i].Trip[j].leaveSP << endl;

		   //endNode	endTime	:
		   infile << seg[i].Trip[j].endNodeIdx << " " << seg[i].Trip[j].endS << endl;

		   // tripNodeTot			: Total of nodes in trip (excluded startNode and endNode)
		   infile << seg[i].Trip[j].numCus << endl;
		   // The list of nodes in trip
 		   curC = seg[i].Trip[j].firstCus;
		   int preNode = seg[i].Trip[j].startNodeIdx;
		   double db_TimePoint = seg[i].Trip[j].leaveSP;
		   while (curC > 0)
			{
				db_TimePoint += problem->c[preNode][curC];
				infile << curC << " ";
				preNode = curC;
				db_TimePoint += problem->node[curC].duration;
				
				curC = nextArr[curC];
			}
		   infile << endl;
	   }
   }

	// Finish exporting
	cout << "\t... OK!" << endl;
}
/*
 * Get transportation cost of a leg
 */
double Solution::getLegCost(int inStartNodeIdx, int inEndNodeIdx, int inWSId, int *arrPath, int pathSz)
{
	double dbCost;
	int preNode;
	
	dbCost = problem->c[inStartNodeIdx][arrPath[1]];

	for (int i = 2; i <= pathSz; i++)
	{
		dbCost += problem->c[arrPath[i-1]][arrPath[i]];
	}

	if (inWSId != -1) 
	{
		dbCost += problem->c[arrPath[pathSz]][inWSId];
		dbCost += problem->c[inWSId][inEndNodeIdx];
	} else
	{
		dbCost += problem->c[arrPath[pathSz]][inEndNodeIdx];
	}
	
	return dbCost;
}
void Solution::postOptimzation(void)
{
	int i, j;
	double dbTotalCostTmp;

	for (i = 1; i <= numVeh; i++) // to consildation, we do not use 0 index.
    {
	   for (j = 1; j <= seg[i].numTrips; j++)
	   {
		   if (seg[i].Trip[j].Type != TRIP_C2C) //TODO: Support delivery trip first
		   {
				//localSearchLeg(i, j);
				localSearchLeg2(i, j);
		   }
	   }
	}
#if Q_DEBUG_POST_OPT
	Check_Solution(&dbTotalCostTmp);
	cout << "Local Search for Delivery cost: " << dbTotalCostTmp << endl;
#endif
}

/* 
 * Apply local search to a Leg (Pickup/delivery/C2c)
 */
void Solution::localSearchLeg2(int inVehIdx, int inTripIdx)
{
	double dbStartTime = 0;
	double dbEndTime = 0;
	int inTripSzTmp = 0;
	int inTripSz = 0;
	int arrTripTmp[300];
	int arrTripSaved[300];
	int arrTrip[300];
	bool bRetVal;
	double arrBeginIime[2000];
	int inWSId;
	int inVehCap;
	double dbEndS;
	int inNonImpCnt = 0;
	double dbStartTimeTmp;
	double dbNewCost;
	double dbCurrCost;
	double dbBestCost;
	int inBetterMove = 0;
	bool bImproved;
	int arrBestPath[300];
	bool bBestCost;
	double dbTotalCostTmp;

#if Q_DEBUG_POST_OPT
	//Show_A_Trip(inVehIdx, inTripIdx);
	//Show_A_Vehicle(inVehIdx);
#endif

	//Main loop of local search
	do {
		
		//memcpy(&seg[MAX_VEH+1], &seg[inVehIdx], sizeof(VRPSegment));
		//memcpy(&seg[MAX_VEH+2], &seg[inVehIdx], sizeof(VRPSegment)); // save a copy

		// Check stop conditons
		if (inNonImpCnt > inTripSzTmp*inTripSzTmp) // Break after certain moves that cannot improve
		{
			break;
		}

		// Rebuil path: firstCust -> ... -> lastCus
		int curC = seg[inVehIdx].Trip[inTripIdx].firstCus;
		inTripSz = 0;
		while (curC > 0)
		{
			inTripSz++;
			arrTrip[inTripSz] = curC;
			curC = nextArr[curC];
		}

#if Q_DEBUG_POST_OPT
		cout << "Current trip: " << endl;
		for (int i =1; i <= inTripSz; i++)
		{
			if (i < inTripSz)
			{
				cout << arrTrip[i] << "->";
			} else
			{
				cout << arrTrip[i] << endl;
			}
		}
#endif
		// Get current vehicle cost
		//dbBestCost = Get_Cost_A_Vehice(inVehIdx);
		Check_Solution(&dbBestCost);
#if Q_DEBUG_POST_OPT
		cout << "Current cost: " << dbBestCost << endl;
#endif

		// arrTrip keeps current solution, arrTripTmp keeps mirror for manipulation
		memcpy(arrTripTmp, arrTrip, sizeof(arrTrip));
		inTripSzTmp = inTripSz;

		if (2 >= inTripSzTmp) break; //TODO: Support more

		// Generate a candidate: randomly, TODO: Using move approach, the most "useless node"
		int inNodeIdx = rand()%(inTripSzTmp)+1;

		bImproved = false;
		for (int i = 1; i <= inTripSzTmp; i++) 		
		{
			memcpy(arrTripTmp, arrTrip, sizeof(arrTrip));
			inTripSzTmp = inTripSz;
			
			if (i != inNodeIdx)
			{			
				int inTmp = arrTripTmp[i];
				arrTripTmp[i] = arrTripTmp[inNodeIdx];
				arrTripTmp[inNodeIdx] = inTmp;

#if Q_DEBUG_POST_OPT
					printf("\nCandidate: swap %d/%d \n", i, inNodeIdx);
					for (int j = 1; j <= inTripSzTmp; j++)
					{						
						if (j < inTripSzTmp)
							printf("%d->", arrTripTmp[j]);
						else 
							printf("%d", arrTripTmp[j]);
					}
					printf("\n");
#endif
				
									
					//Update leg
					seg[inVehIdx].Trip[inTripIdx].firstCus = arrTripTmp[1];
  				    seg[inVehIdx].Trip[inTripIdx].lastCus = arrTripTmp[inTripSz];
					curC = seg[inVehIdx].Trip[inTripIdx].firstCus;
					routed[curC] = 1;
					for (int j = 2; j <= inTripSz; j++)
					{
						routed[arrTripTmp[j]] = 1;
						nextArr[curC] = arrTripTmp[j];
						curC = arrTripTmp[j];
					}
					nextArr[curC] = -1;		

					//Show_A_Vehicle(MAX_VEH+1);
					//Show_A_Vehicle2(seg[MAX_VEH+1]);
					bRetVal = Re_Set_Joint_For_A_Vehicle(inVehIdx);
					if (true == bRetVal)
					{
						//Show_A_Vehicle2(seg[MAX_VEH+1]);
						//Show_A_Vehicle(MAX_VEH+1);
						//bRetVal = Re_Set_Time_For_A_Vehicle(seg[MAX_VEH+1], 0);
						bRetVal = Set_Time_For_A_Vehicle(inVehIdx, 1, 0, true);
						if (true == bRetVal)
						{
							
							//memcpy(&seg[inVehIdx], &seg[MAX_VEH+1], sizeof(VRPSegment));
							if (true == Check_Solution(&dbTotalCostTmp))
							{
							//	dbCurrCost = Get_Cost_A_Vehice(inVehIdx);
								if (dbTotalCostTmp >= dbBestCost)
								{
									// Roll back																		
									inNonImpCnt++;
#if Q_DEBUG_POST_OPT
									cout << "feasible sol. but worse: " << dbTotalCostTmp << endl;
#endif
								} else
								{
									//Got better solution
#if Q_DEBUG_POST_OPT
									cout << "Improve " << dbTotalCostTmp - dbBestCost << endl;
#endif
									//Check_Solution(&dbTotalCostTmp);

									dbBestCost = dbTotalCostTmp;
									inNonImpCnt = 0; 
									memcpy(arrTripSaved, arrTripTmp, sizeof(arrTripTmp));
									bImproved = true;
									break;
								}
							} else {
								// Roll back
								
								inNonImpCnt++;
#if Q_DEBUG_POST_OPT
								cout << "Failed, infeasible sol. " << endl;
#endif
							}
							
							//Show_A_Vehicle(MAX_VEH+1);
						} else
						{
#if Q_DEBUG_POST_OPT
							cout << "Failed. can not reset time " << endl;
#endif							
							inNonImpCnt++;							
						}
					} else 
					{
#if Q_DEBUG_POST_OPT
						cout << "Failed, cannot joint " << endl;
#endif
						//memcpy(&seg[inVehIdx], &seg[MAX_VEH+2], sizeof(VRPSegment)); 
						inNonImpCnt++;
					}
			}
		}
	
		if (true == bImproved)
		{
			seg[inVehIdx].Trip[inTripIdx].firstCus = arrTripSaved[1];
  			seg[inVehIdx].Trip[inTripIdx].lastCus = arrTripSaved[inTripSz];
			curC = seg[inVehIdx].Trip[inTripIdx].firstCus;
			routed[curC] = 1;
			for (int j = 2; j <= inTripSz; j++)
			{
				routed[arrTripSaved[j]] = 1;
				nextArr[curC] = arrTripSaved[j];
				curC = arrTripSaved[j];
			}
			nextArr[curC] = -1;		

			bRetVal = Re_Set_Joint_For_A_Vehicle(inVehIdx);
			if (false == bRetVal)
			{
				printf("%d", __LINE__); getchar();
			}

			bRetVal = Set_Time_For_A_Vehicle(inVehIdx, 1, 0, true);
			if (false == bRetVal)
			{
				printf("%d", __LINE__); getchar();
			}
			Check_Solution(&dbTotalCostTmp);
		} else { // Roll-back
			seg[inVehIdx].Trip[inTripIdx].firstCus = arrTrip[1];
  			seg[inVehIdx].Trip[inTripIdx].lastCus = arrTrip[inTripSz];
			curC = seg[inVehIdx].Trip[inTripIdx].firstCus;
			routed[curC] = 1;
			for (int j = 2; j <= inTripSz; j++)
			{
				routed[arrTrip[j]] = 1;
				nextArr[curC] = arrTrip[j];
				curC = arrTrip[j];
			}
			nextArr[curC] = -1;		

			bRetVal = Re_Set_Joint_For_A_Vehicle(inVehIdx);
			if (false == bRetVal)
			{
				printf("%d", __LINE__); getchar();
			}
			bRetVal = Set_Time_For_A_Vehicle(inVehIdx, 1, 0, true);
			if (false == bRetVal)
			{
				printf("%d", __LINE__); getchar();
			}
			Check_Solution(&dbTotalCostTmp);

		}
	} while (1);

	// If got better solution, apply to current one

#if Q_DEBUG_POST_OPT
//	double dbTotalCostTmp;
//	Check_Solution(&dbTotalCostTmp);
//	cout << "Local Search Veh " << inVehIdx << " trip " << inTripIdx << " cost: " << dbTotalCostTmp << endl;
#endif	
}

/* 
 * Apply local search to a Leg (Pickup/delivery/C2c)
 */
void Solution::localSearchLeg(int inVehIdx, int inTripIdx)
{
	double dbStartTime = 0;
	double dbEndTime = 0;
	int inTripSzTmp = 0;
	int inTripSz = 0;
	int arrTripTmp[300];
	int arrTrip[300];
	bool bRetVal;
	double arrBeginIime[2000];
	int inWSId;
	int inVehCap;
	double dbEndS;
	int inNonImpCnt = 0;
	double dbStartTimeTmp;
	double dbNewCost;
	double dbCurrCost;
	double dbBestCost;
	int inBetterMove = 0;
	bool bImproved;
	int arrBestPath[300];
	bool bBestCost;

	//VRPSegment segTemp;

	//memcpy(&segTemp, &seg[inVehIdx], sizeof(VRPSegment));

#if Q_DEBUG_POST_OPT
	Show_A_Trip(inVehIdx, inTripIdx);
#endif

#if Q_DEBUG_POST_OPT
	double dbTotalCostTmp;
	Check_Solution(&dbTotalCostTmp);
	cout << "Before applying Local Search Veh " << inVehIdx << " trip " << inTripIdx << " cost: " << dbTotalCostTmp << endl;
#endif

	// Depends on leg, need to calculate start time and end time
	//switch (seg[idVeh].Trip[idTrip].Type)
	//{
	//case TRIP_DELIVERY:
	//	dbStartTime = seg[idVeh].Trip[idTrip].leaveSP + problem->nodeSP[seg[idVeh].Trip[idTrip].startNodeIdx].load;
	//	dbEndTime = seg[idVeh].Trip[idTrip].endS;
	//	break;
	//case TRIP_PICKUP:
	//	dbStartTime = seg[idVeh].Trip[idTrip].leaveSP;
	//	dbEndTime = seg[idVeh].Trip[idTrip].endS;
	//	break;
	//case TRIP_C2C:
	//	dbStartTime = seg[idVeh].Trip[idTrip].leaveSP;
	//	dbEndTime = seg[idVeh].Trip[idTrip].endS;
	//	break;
	//default:
	//	cout << "Critical err, unknown leg" << endl;
	//	break;
	//}

	// Rebuil path: firstCust -> ... -> lastCus
	int curC = seg[inVehIdx].Trip[inTripIdx].firstCus;
	inTripSz = 0;
	while (curC > 0)
	{
		inTripSz++;
		arrTrip[inTripSz] = curC;
		curC = nextArr[curC];
	}
	// Get transportation cost of current path
	dbCurrCost = getLegCost(seg[inVehIdx].Trip[inTripIdx].startNodeIdx, seg[inVehIdx].Trip[inTripIdx].endNodeIdx, seg[inVehIdx].Trip[inTripIdx].waitingS, arrTrip, inTripSz);
	dbBestCost = dbCurrCost;
#if Q_DEBUG_POST_OPT
	printf("\nCurrent path with cost %f\n", dbCurrCost);
	for (int i = 1; i <= inTripSz; i++)
	{
		if (i < inTripSz)
			printf("%d->", arrTrip[i]);
		else
			printf("%d", arrTrip[i]);
	}
	printf("\n");
#endif

	//Main loop of local search
	do {

		// arrTrip keeps current solution, arrTripTmp keeps mirror for manipulation
		memcpy(arrTripTmp, arrTrip, sizeof(arrTrip));
		inTripSzTmp = inTripSz;

		// Check stop conditons
		if (inNonImpCnt > inTripSzTmp*inTripSzTmp) // Break after certain moves that cannot improve
		{
			break;
		}

		if (2 >= inTripSzTmp) break; //TODO: Support more
		// Generate a candidate: randomly, TODO: Using move approach, the most "useless node"
#ifdef SKIP_JOIN_NODE		
		int inNodeIdx = rand()%(inTripSzTmp-2)+2;
#else
		int inNodeIdx = rand()%(inTripSzTmp)+1;
#endif
		bBestCost = false;
		
		// Update leave time in case of DELIVERY TRIP
		dbStartTime = seg[inVehIdx].Trip[inTripIdx].leaveSP;
		if (TRIP_DELIVERY == seg[inVehIdx].Trip[inTripIdx].Type)
		{
			dbStartTime += problem->nodeSP[seg[inVehIdx].Trip[inTripIdx].startNodeIdx].load;
		}

		bImproved = false;
#ifdef SKIP_JOIN_NODE
		for (int i = 2; i < inTripSzTmp; i++) 
#else
		for (int i = 1; i <= inTripSzTmp; i++) 
#endif
		
		{
			memcpy(arrTripTmp, arrTrip, sizeof(arrTrip));
			inTripSzTmp = inTripSz;
			
			if (i != inNodeIdx)
			{			
				int inTmp = arrTripTmp[i];
				arrTripTmp[i] = arrTripTmp[inNodeIdx];
				arrTripTmp[inNodeIdx] = inTmp;

#if Q_DEBUG_POST_OPT
					printf("\nCandidate: swap %d/%d \n", i, inNodeIdx);
					for (int i = 1; i <= inTripSzTmp; i++)
					{						
						if (i < inTripSzTmp)
							printf("%d->", arrTripTmp[i]);
						else 
							printf("%d", arrTripTmp[i]);
					}
					printf("\n");
#endif

				// Reset time
				bRetVal = SetBeginTimeForPath_Q(dbStartTime, seg[inVehIdx].Trip[inTripIdx].startNodeIdx,
								arrTripTmp,
								inTripSzTmp,
								arrBeginIime,
								seg[inVehIdx].Trip[inTripIdx].endNodeIdx,
								&dbEndS,
								&inWSId,
								&inVehCap);

				if (true == bRetVal) // can set time
				{
					dbNewCost = getLegCost(seg[inVehIdx].Trip[inTripIdx].startNodeIdx, seg[inVehIdx].Trip[inTripIdx].endNodeIdx, inWSId, arrTripTmp, inTripSzTmp);
#if Q_DEBUG_POST_OPT
					printf("\t... SetTime: ok!, dbEnds=<%f>, inWSId=<%d>, new cost=<%f>\n", dbEndS, inWSId, dbNewCost);
#endif
					// Check acceptance conditions: 
					if (inTripIdx < seg[inVehIdx].numTrips)
					{
						///showSolution();
						if (TRIP_PICKUP == seg[inVehIdx].Trip[inTripIdx].Type)
						{
							dbEndS += problem->nodeSP[seg[inVehIdx].Trip[inTripIdx].endNodeIdx].unload;
						}
						if (seg[inVehIdx].Trip[inTripIdx+1].startNodeIdx == seg[inVehIdx].Trip[inTripIdx].lastCus)
						{
							dbStartTimeTmp = arrBeginIime[inTripSzTmp];
						} else
						{
							dbStartTimeTmp = dbEndS;
						}

						if (false == Set_Time_For_A_Vehicle(inVehIdx, inTripIdx+1, dbStartTimeTmp, false))
						{
#if Q_DEBUG_POST_OPT
							cout << "\t...FWD slack time::failed *ln" << __LINE__<< endl;
#endif
							//continue;
						} else
						{
							if (dbNewCost >= dbBestCost)
							{
#if Q_DEBUG_POST_OPT
								printf("\tNew soltion but bad quality\n");
#endif
							} else
							{
#if Q_DEBUG_POST_OPT
								printf("\tBetter solution, swap %d -> %d\t, cost %f", i, inNodeIdx, dbNewCost);
#endif
								//TODO: Save this solution
								inBetterMove++;
								bImproved = true;
								dbBestCost = dbNewCost;
								memcpy(arrBestPath, arrTripTmp, sizeof(arrTripTmp));
								bBestCost = true;
							}
						}

						//showSolution();
					}

					//memcpy(arrTrip, arrTripTmp, sizeof(arrTrip));
					//TODO: Check the join nodes, no need in case of last trip
				} else 
				{
#if Q_DEBUG_POST_OPT
					printf("\t... SetTime: failed!\n");
#endif
				}

			}
		}

		if (!bImproved)
		{
			inNonImpCnt++;
		} else 
		{
			// If got better solution, apply to current one
			memcpy(arrTrip, arrBestPath, sizeof(arrBestPath));
			inTripSzTmp = inTripSz;
#if Q_DEBUG_POST_OPT
					printf("\nSelected with cost %f:\n", dbBestCost);
					for (int i = 1; i <= inTripSzTmp; i++)
					{						
						if (i < inTripSzTmp)
							printf("%d->", arrBestPath[i]);
						else 
							printf("%d", arrBestPath[i]);
					}
					printf("\n");
#endif
			inNonImpCnt = 0;

			//printf("Veh %d trip %d can be improved: %d\n", inVehIdx, inTripIdx, inBetterMove);
#if Q_DEBUG_POST_OPT
			printf("\nFound BEST path with cost %f\n", dbBestCost);
			for (int i = 1; i <= inTripSz; i++)
			{
				if (i < inTripSz)
					printf("%d->", arrBestPath[i]);
				else
					printf("%d", arrBestPath[i]);
			}
			printf("\n");
#endif

			// Update solution
			if (bBestCost)
			{
				// Reset time
				bRetVal = SetBeginTimeForPath_Q(dbStartTime, seg[inVehIdx].Trip[inTripIdx].startNodeIdx,
								arrBestPath,
								inTripSz,
								arrBeginIime,
								seg[inVehIdx].Trip[inTripIdx].endNodeIdx,
								&dbEndS,
								&inWSId,
								&inVehCap);

				if (true == bRetVal) // can set time
				{
						seg[inVehIdx].Trip[inTripIdx].endS = dbEndS;
						seg[inVehIdx].Trip[inTripIdx].waitingS = inWSId;
			
						seg[inVehIdx].Trip[inTripIdx].firstCus = arrBestPath[1];
						seg[inVehIdx].Trip[inTripIdx].lastCus = arrBestPath[inTripSz];
						curC = seg[inVehIdx].Trip[inTripIdx].firstCus;
						routed[curC] = 1;
						for (int i = 2; i <= inTripSz; i++)
						{
							routed[arrBestPath[i]] = 1;
							nextArr[curC] = arrBestPath[i];
							curC = arrBestPath[i];
						}
						nextArr[curC] = -1;		
#if Q_DEBUG_POST_OPT
						Show_A_Trip(inVehIdx, inTripIdx);
#endif

						if (inTripIdx < seg[inVehIdx].numTrips)
						{
							if (TRIP_PICKUP == seg[inVehIdx].Trip[inTripIdx].Type)
							{
								dbEndS += problem->nodeSP[seg[inVehIdx].Trip[inTripIdx].endNodeIdx].unload;
							}
							if (seg[inVehIdx].Trip[inTripIdx+1].startNodeIdx == seg[inVehIdx].Trip[inTripIdx].lastCus)
							{
								dbStartTimeTmp = arrBeginIime[inTripSzTmp];
							} else
							{
								dbStartTimeTmp = dbEndS;
							}

							if (false == Set_Time_For_A_Vehicle(inVehIdx, inTripIdx+1, dbStartTimeTmp, true))
							{
								cout << "\t...FWD slack time::failed *ln" << __LINE__<< endl; getchar();
							} else
							{
		#if Q_DEBUG_POST_OPT
								cout << "Updated ok" << endl;
		#endif
							}

							//showSolution();
						} else
						{

						}
				} else
				{
					cout << "Critical error *ln" << __LINE__ << endl; getchar();			
				}
			}
		}

		

	} while (1);

	// If got better solution, apply to current one

#if Q_DEBUG_POST_OPT
//	double dbTotalCostTmp;
//	Check_Solution(&dbTotalCostTmp);
//	cout << "Local Search Veh " << inVehIdx << " trip " << inTripIdx << " cost: " << dbTotalCostTmp << endl;
#endif	
}

void Solution::updateBestSolution(int inSegIdx, int inIterations, double dbCost, char *szTestIdx, double dbBestAtTime, char *szTestOffset)
{
   int i,j,curC;
   double dbStartTime;
   int arrSol[2000];
   int inSolNode;
   char szFileName[100];
   char szFileName2[100];
   ofstream infile;
   //ofstream infile2;


   strcpy(szFileName, "sol");
   strcat(szFileName, szTestIdx); 
   strcat(szFileName, "_"); 
   strcat(szFileName, szTestOffset);
   strcat(szFileName, ".bes");

   //strcpy(szFileName2, "sol");
   //strcat(szFileName2, szTestIdx);
   //strcat(szFileName2, ".txt");

    infile.open(szFileName,ios::out); 
    if (!infile){	 
		 cout << "\n\tInput file not found !!!!!!" << endl; 		
		 exit(-1);
	}

 //   infile2.open(szFileName2,ios::out); 
 //   if (!infile2){	 
	//	 cout << "\n\tInput file not found !!!!!!" << endl; 		
	//	 exit(-1);
	//}
	infile << dbCost << "\t" << inIterations << "\t" << dbBestAtTime << endl;	
   infile << "\t Cost: " << dbCost <<endl;	
   infile << "\t Number of used vehicles: " << (numVeh) << endl;
   infile << "\t Segment: " << inSegIdx << endl;
   infile << "\t Iteration: " << inIterations << endl << endl;
   infile << "\t Best at: " << dbBestAtTime << " sec." << endl;
   //TotalCostOfSolution TravelCostOfSolution NumberOfVehicles	
   //infile2 << dbCost << "\t" << numVeh << endl;

   for (i = 1; i <= numVeh; i++) // to consildation, we do not use 0 index.
   {
	   infile << "\t\t Vehicle: " << i << endl;
       infile << "\t\t Trip total: " << seg[i].numTrips << endl;
	   
	   //infile2 << seg[i].numTrips << endl;

	   for (j = 1; j <= seg[i].numTrips; j++)
	   {
		   infile << "\t\t\t >>>Trip: " << j << endl;
		   

		   if (TRIP_DELIVERY == seg[i].Trip[j].Type)
		   {
			   infile << "\t\t\t Type: DELIVERY" << endl;
			   //infile << "\t\t\t Fitness: " << seg[i].Trip[j].fitness << endl;
			   infile << "\t\t\t Cost: " << seg[i].Trip[j].cost << endl;
			   infile << "\t\t\t Capacity: " << seg[i].Trip[j].capacity << endl;
			   infile << "\t\t\t Arrived at: " << seg[i].Trip[j].arriveSP << endl;
			   infile << "\t\t\t Leave at: " << seg[i].Trip[j].leaveSP << endl;
			   infile << "\t\t\t Delivery Nbr: " << seg[i].Trip[j].numCus << endl;
			   infile << "\t\t\t Assigned SP: " << seg[i].Trip[j].assSP << endl;
			   infile << "\t\t\t Started from SP: " << seg[i].Trip[j].startNodeIdx << "(" << seg[i].Trip[j].leaveSP << ")" << endl;
			   infile << "\t\t\t End at: " << seg[i].Trip[j].endNodeIdx << endl;
			   infile << "\t\t\t Waiting station: " << seg[i].Trip[j].waitingS << endl;
			   infile << "\t\t\t EndS: " << seg[i].Trip[j].endS << endl;

			   infile << "\t\t\t ROUTED: ";
			   curC = seg[i].Trip[j].firstCus;
			   int preNode = seg[i].Trip[j].startNodeIdx;
			   double db_TimePoint = seg[i].Trip[j].leaveSP + problem->nodeSP[seg[i].Trip[j].startNodeIdx].load;
			   infile << seg[i].Trip[j].startNodeIdx << "(" << seg[i].Trip[j].leaveSP << "|" << db_TimePoint  <<") -> ";
			   while (curC > 0)
			   {
				   db_TimePoint += problem->c[preNode][curC];
				   if (db_TimePoint < problem->node[curC].sTW)  db_TimePoint = problem->node[curC].sTW;
				   infile << curC << "(" << db_TimePoint << "|" << (db_TimePoint+problem->node[curC].duration) << ")" << "->";
				   preNode = curC;
				   db_TimePoint += problem->node[curC].duration;
				
				   curC = nextArr[curC];
			   }

			   if (seg[i].Trip[j].waitingS > 0)
			   {
				   db_TimePoint += problem->c[seg[i].Trip[j].lastCus][seg[i].Trip[j].waitingS];
				   infile << seg[i].Trip[j].waitingS << "*" << "(" << db_TimePoint << "|" << (seg[i].Trip[j].endS - problem->c[seg[i].Trip[j].waitingS][seg[i].Trip[j].endNodeIdx]) << ") ->";
			   }

			   infile << seg[i].Trip[j].endNodeIdx << "(" << seg[i].Trip[j].endS << ")" << endl;
			   
			   infile << endl << endl;

		   }
		   else if (TRIP_C2C == seg[i].Trip[j].Type)
		   {
			   infile << "\t\t\t Type: C2C" << endl;
			   //infile << "\t\t\t Fitness: " << seg[i].Trip[j].fitness << endl;
			   infile << "\t\t\t Cost: " << seg[i].Trip[j].cost << endl;
			   infile << "\t\t\t Capacity: " << seg[i].Trip[j].capacity << endl;
			   infile << "\t\t\t Arrived at: " << seg[i].Trip[j].arriveSP << endl;
			   infile << "\t\t\t Leave at: " << seg[i].Trip[j].leaveSP << endl;
			   infile << "\t\t\t Delivery Nbr: " << seg[i].Trip[j].numCus << endl;
			   infile << "\t\t\t Assigned SP: " << seg[i].Trip[j].assSP << endl;
			   infile << "\t\t\t Started from: " << seg[i].Trip[j].startNodeIdx << endl;
			   infile << "\t\t\t End at: " << seg[i].Trip[j].endNodeIdx << endl;
			   infile << "\t\t\t Waiting station: " << seg[i].Trip[j].waitingS << endl;
			   infile << "\t\t\t EndS: " << seg[i].Trip[j].endS << endl;

			   infile << "\t\t\t ROUTED: ";
			 
			   curC = seg[i].Trip[j].firstCus;
			   int preNode = seg[i].Trip[j].startNodeIdx;
			   double db_TimePoint = seg[i].Trip[j].leaveSP;

			   infile << seg[i].Trip[j].startNodeIdx << "(" << db_TimePoint << ") -> ";

			   while (curC > 0)
			   {
				   db_TimePoint += problem->c[preNode][curC];
				   if (db_TimePoint < problem->node[curC].sTW)  db_TimePoint = problem->node[curC].sTW;
				   infile << curC << "(" << db_TimePoint << "|" << (db_TimePoint+problem->node[curC].duration) << ")" << "->";
				   preNode = curC;
				   db_TimePoint += problem->node[curC].duration;
				
				   curC = nextArr[curC];
			   }

			   if (seg[i].Trip[j].waitingS > 0)
			   {
				   db_TimePoint += problem->c[seg[i].Trip[j].lastCus][seg[i].Trip[j].waitingS];
				   infile << seg[i].Trip[j].waitingS << "*" << "(" << db_TimePoint << "|" << (seg[i].Trip[j].endS - problem->c[seg[i].Trip[j].waitingS][seg[i].Trip[j].endNodeIdx]) << ") ->";
			   }

			   infile << seg[i].Trip[j].endNodeIdx << "(" << seg[i].Trip[j].endS << ")" << endl;
			   
			   infile << endl << endl;
		   }
		   else if (TRIP_PICKUP == seg[i].Trip[j].Type)
		   {
			   infile << "\t\t\t Type: PICKUP" << endl;
			   //infile << "\t\t\t Fitness: " << seg[i].Trip[j].fitness << endl;
			   infile << "\t\t\t Cost: " << seg[i].Trip[j].cost << endl;
			   infile << "\t\t\t Capacity: " << seg[i].Trip[j].capacity << endl;
			   infile << "\t\t\t Arrived at: " << seg[i].Trip[j].arriveSP << endl;
			   infile << "\t\t\t Leave at: " << seg[i].Trip[j].leaveSP << endl;
			   infile << "\t\t\t Delivery Nbr: " << seg[i].Trip[j].numCus << endl;
			   infile << "\t\t\t Assigned SP: " << seg[i].Trip[j].assSP << endl;
			   infile << "\t\t\t Started from: " << seg[i].Trip[j].startNodeIdx << endl;
			   infile << "\t\t\t End at SP: " << seg[i].Trip[j].endNodeIdx << endl;
			   infile << "\t\t\t Waiting station: " << seg[i].Trip[j].waitingS << endl;
			   infile << "\t\t\t EndS: " << seg[i].Trip[j].endS << endl;

			   infile << "\t\t\t ROUTED: ";
			   curC = seg[i].Trip[j].firstCus;
			   int preNode = seg[i].Trip[j].startNodeIdx;
			   double db_TimePoint = seg[i].Trip[j].leaveSP;
			   
			   infile << seg[i].Trip[j].startNodeIdx << "(" << db_TimePoint << ") -> ";
			   while (curC > 0)
			   {
				   db_TimePoint += problem->c[preNode][curC];
				   if (db_TimePoint < problem->node[curC].sTW)  db_TimePoint = problem->node[curC].sTW;
				   infile << curC << "(" << db_TimePoint << "|" << (db_TimePoint+problem->node[curC].duration) << ")" << "->";
				   preNode = curC;
				   db_TimePoint += problem->node[curC].duration;

				   curC = nextArr[curC];
			   }
			   if (seg[i].Trip[j].waitingS > 0)
			   {
				   db_TimePoint += problem->c[seg[i].Trip[j].lastCus][seg[i].Trip[j].waitingS];
				   infile << seg[i].Trip[j].waitingS << "*" << "(" << db_TimePoint << "|" << (seg[i].Trip[j].endS - problem->nodeSP[seg[i].Trip[j].endNodeIdx].unload - problem->c[seg[i].Trip[j].waitingS][seg[i].Trip[j].endNodeIdx]) << ") ->";
			   }
			   infile << seg[i].Trip[j].endNodeIdx << "(" << (seg[i].Trip[j].endS - problem->nodeSP[seg[i].Trip[j].endNodeIdx].unload) << "|" << seg[i].Trip[j].endS << ")" << endl << endl;			   
			   infile << endl << endl;
		   }
	   }
   }
}

bool Solution::Check_vioTW(void) {
   int i,j,curC;
   double dbStartTime;
   int arrSol[2000];
   int inSolNode;
   
   for (i = 1; i <= numVeh; i++) // to consildation, we do not use 0 index.
   {

	   for (j = 1; j <= seg[i].numTrips; j++)
	   {
		  // if ((i == 13) && (j == 4)) {
				//cout << "unit test" << endl;
		  // }

		   if (TRIP_DELIVERY == seg[i].Trip[j].Type)
		   {
			
			   curC = seg[i].Trip[j].firstCus;
			   int preNode = seg[i].Trip[j].startNodeIdx;
			   double db_TimePoint = seg[i].Trip[j].leaveSP + problem->nodeSP[seg[i].Trip[j].startNodeIdx].load;
			   //infile << seg[i].Trip[j].startNodeIdx << "(" << seg[i].Trip[j].leaveSP << "|" << db_TimePoint  <<") -> ";
			   if ((seg[i].Trip[j-1].Type != TRIP_PICKUP) && (seg[i].Trip[j].endNodeIdx != seg[i].Trip[j-1].startNodeIdx) && (j>1)) {
				   if (false == Check_TW(seg[i].Trip[j].startNodeIdx, seg[i].Trip[j].leaveSP, false)) {
					   Show_A_Trip(i,j-1);
					   Show_A_Trip(i,j);
						return false;   
				   }
			   }
			   while (curC > 0)
			   {
				   db_TimePoint += problem->c[preNode][curC];
				   if (db_TimePoint < problem->node[curC].sTW)  db_TimePoint = problem->node[curC].sTW;
				   //infile << curC << "(" << db_TimePoint << "|" << (db_TimePoint+problem->node[curC].duration) << ")" << "->";
				   	if (false == Check_TW(curC, db_TimePoint, false)) {
						return false;   
					}
				   preNode = curC;
				   db_TimePoint += problem->node[curC].duration;
				
				   curC = nextArr[curC];
			   }

			   if (seg[i].Trip[j].waitingS > 0)
			   {
				   db_TimePoint += problem->c[seg[i].Trip[j].lastCus][seg[i].Trip[j].waitingS];
				   //infile << seg[i].Trip[j].waitingS << "*" << "(" << db_TimePoint << "|" << (seg[i].Trip[j].endS - problem->c[seg[i].Trip[j].waitingS][seg[i].Trip[j].endNodeIdx]) << ") ->";

				   if ((Get_Node_Type(seg[i].Trip[j+1].startNodeIdx) == NODE_SUPPLY_POINT) && (seg[i].Trip[j+1].Type == TRIP_DELIVERY)) { // next trip is delivery
					 db_TimePoint += problem->c[seg[i].Trip[j].waitingS][seg[i].Trip[j+1].startNodeIdx];
						if (false == Check_TW(seg[i].Trip[j+1].startNodeIdx, db_TimePoint, true)) {
							return false;   
						}
				   }
			   } else {
				   db_TimePoint += problem->c[seg[i].Trip[j].lastCus][seg[i].Trip[j].endNodeIdx];
				   if (false == Check_TW(seg[i].Trip[j].endNodeIdx, db_TimePoint, false)) {
						return false;   
					}
			   }
			   

		   }
		   else if (TRIP_C2C == seg[i].Trip[j].Type)
		   {
			 
			   curC = seg[i].Trip[j].firstCus;
			   int preNode = seg[i].Trip[j].startNodeIdx;
			   double db_TimePoint = seg[i].Trip[j].leaveSP;

			   //infile << seg[i].Trip[j].startNodeIdx << "(" << db_TimePoint << ") -> ";

			   while (curC > 0)
			   {
				   db_TimePoint += problem->c[preNode][curC];
				   if (db_TimePoint < problem->node[curC].sTW)  db_TimePoint = problem->node[curC].sTW;
				   //infile << curC << "(" << db_TimePoint << "|" << (db_TimePoint+problem->node[curC].duration) << ")" << "->";
					if (false == Check_TW(curC, db_TimePoint, false)) {
						return false;   
					}
				   preNode = curC;
				   db_TimePoint += problem->node[curC].duration;
				
				   curC = nextArr[curC];
			   }

			   if (seg[i].Trip[j].waitingS > 0)
			   {
				   db_TimePoint += problem->c[seg[i].Trip[j].lastCus][seg[i].Trip[j].waitingS];
				   //infile << seg[i].Trip[j].waitingS << "*" << "(" << db_TimePoint << "|" << (seg[i].Trip[j].endS - problem->c[seg[i].Trip[j].waitingS][seg[i].Trip[j].endNodeIdx]) << ") ->";

				   if ((Get_Node_Type(seg[i].Trip[j+1].startNodeIdx) == NODE_SUPPLY_POINT) && (seg[i].Trip[j+1].Type == TRIP_DELIVERY)) { // next trip is delivery
					 db_TimePoint += problem->c[seg[i].Trip[j].waitingS][seg[i].Trip[j+1].startNodeIdx];
						if (false == Check_TW(seg[i].Trip[j+1].startNodeIdx, db_TimePoint, true)) {
							return false;   
						}
				   }
			   } else {
				   db_TimePoint += problem->c[seg[i].Trip[j].lastCus][seg[i].Trip[j].endNodeIdx];
				   if (false == Check_TW(seg[i].Trip[j].endNodeIdx, db_TimePoint, false)) {
					   Show_A_Trip(i,j);
					   Show_A_Trip(i,j+1);
						return false;   
					}
			   }
			   

		   }
		   else if (TRIP_PICKUP == seg[i].Trip[j].Type)
		   {
			   curC = seg[i].Trip[j].firstCus;
			   int preNode = seg[i].Trip[j].startNodeIdx;
			   double db_TimePoint = seg[i].Trip[j].leaveSP;
			   
//			   infile << seg[i].Trip[j].startNodeIdx << "(" << db_TimePoint << ") -> ";
			 //  	if (false == Check_TW(seg[i].Trip[j].startNodeIdx, db_TimePoint, false)) {
				//	Show_A_Trip(i, j-1);
				//	Show_A_Trip(i, j);
				//	return false;   
				//}

			   while (curC > 0)
			   {
				   db_TimePoint += problem->c[preNode][curC];
				   if (db_TimePoint < problem->node[curC].sTW)  db_TimePoint = problem->node[curC].sTW;
				   //infile << curC << "(" << db_TimePoint << "|" << (db_TimePoint+problem->node[curC].duration) << ")" << "->";
			   		if (false == Check_TW(curC, db_TimePoint, false)) {
						return false;   
					}
				   preNode = curC;
				   db_TimePoint += problem->node[curC].duration;

				   curC = nextArr[curC];
			   }

			   if (seg[i].Trip[j].waitingS > 0)
			   {
				   db_TimePoint += problem->c[seg[i].Trip[j].lastCus][seg[i].Trip[j].waitingS];
				   //infile << seg[i].Trip[j].waitingS << "*" << "(" << db_TimePoint << "|" << (seg[i].Trip[j].endS - problem->c[seg[i].Trip[j].waitingS][seg[i].Trip[j].endNodeIdx]) << ") ->";

				   db_TimePoint += problem->c[seg[i].Trip[j].waitingS][seg[i].Trip[j].endNodeIdx];
				   if (false == Check_TW(seg[i].Trip[j].endNodeIdx, db_TimePoint, true)) {
						return false;   
					}
			   } else {
				   db_TimePoint += problem->c[seg[i].Trip[j].lastCus][seg[i].Trip[j].endNodeIdx];
				   if (false == Check_TW(seg[i].Trip[j].endNodeIdx, db_TimePoint, false)) {
						return false;   
					}
			   }

			   if (j < seg[i].numTrips) { // not last trip: p - sp1 - sp2 - d trip
					if (seg[i].Trip[j+1].Type == TRIP_DELIVERY) {
						if (seg[i].Trip[j].endNodeIdx != seg[i].Trip[j+1].startNodeIdx) {		
							if (seg[i].Trip[j].Type == TRIP_PICKUP)
							{
								db_TimePoint += problem->nodeSP[seg[i].Trip[j].endNodeIdx].unload;
							}
							if (seg[i].Trip[j+1].waitingS1 > 0) {
								db_TimePoint += problem->c[seg[i].Trip[j].endNodeIdx][seg[i].Trip[j+1].waitingS1];
								db_TimePoint += problem->c[seg[i].Trip[j+1].waitingS1][seg[i].Trip[j+1].startNodeIdx];
							
								if (false == Check_TW(seg[i].Trip[j+1].startNodeIdx, db_TimePoint, true)) {
									//cout << "p-d case: failed" << endl;
									//Export_Loaded_Solution("sol.fal");
									return false;   
								} else {
	//								cout << "p-d case: ok" << endl;
								}
							} else {
							
								db_TimePoint += problem->c[seg[i].Trip[j].endNodeIdx][seg[i].Trip[j+1].startNodeIdx];
								if (false == Check_TW(seg[i].Trip[j+1].startNodeIdx, db_TimePoint, false)) {
									//cout << "p-d case: failed" << endl;
									//Export_Loaded_Solution("sol.fal");
									return false;   
								} else {
	//								cout << "p-d case: ok" << endl;
								}
							}
							
						}
					}
			   }
		   }
	   }
   }
	return true;
}
void Solution::showSolution()
{
   int i,j,curC;
   double dbStartTime;
   int arrSol[2000];
   int inSolNode;

   ofstream infile;

#if _DEBUG
   cout << endl << "Export CURR SOLUTION... ";
#endif

    infile.open("solution.cur",ios::out); 
     if (!infile){	 
		 cout << "\n\tInput file not found !!!!!!" << endl; 		
		 exit(-1);
	 }

//   infile << "\t Fitness: " << fitness <<endl;	
   infile << "\t Cost: " << cost <<endl;	
   infile << "\t Number of used vehicles: " << (numVeh) << endl << endl;
   //cout<<fitness<<"   "<<cost<<"   "<<numVeh<<endl;
   
   for (i = 1; i <= numVeh; i++) // to consildation, we do not use 0 index.
   {
	   infile << "\t\t Vehicle: " << i << endl;
       infile << "\t\t Trip total: " << seg[i].numTrips << endl;
	   

	   for (j = 1; j <= seg[i].numTrips; j++)
	   {
		   infile << "\t\t\t >>>Trip: " << j << endl;

		   if (TRIP_DELIVERY == seg[i].Trip[j].Type)
		   {
			   infile << "\t\t\t Type: DELIVERY" << endl;
			   //infile << "\t\t\t Fitness: " << seg[i].Trip[j].fitness << endl;
			   infile << "\t\t\t Cost: " << seg[i].Trip[j].cost << endl;
			   infile << "\t\t\t Capacity: " << seg[i].Trip[j].capacity << endl;
			   infile << "\t\t\t Arrived at: " << seg[i].Trip[j].arriveSP << endl;
			   infile << "\t\t\t Leave at: " << seg[i].Trip[j].leaveSP << endl;
			   infile << "\t\t\t Delivery Nbr: " << seg[i].Trip[j].numCus << endl;
			   infile << "\t\t\t Assigned SP: " << seg[i].Trip[j].assSP << endl;
			   infile << "\t\t\t Started from SP: " << seg[i].Trip[j].startNodeIdx << "(" << seg[i].Trip[j].leaveSP << ")" << endl;
			   infile << "\t\t\t End at: " << seg[i].Trip[j].endNodeIdx << endl;
			   infile << "\t\t\t Waiting station: " << seg[i].Trip[j].waitingS << endl;
			   infile << "\t\t\t EndS: " << seg[i].Trip[j].endS << endl;

			   infile << "\t\t\t ROUTED: ";
			   curC = seg[i].Trip[j].firstCus;
			   int preNode = seg[i].Trip[j].startNodeIdx;
			   double db_TimePoint = seg[i].Trip[j].leaveSP + problem->nodeSP[seg[i].Trip[j].startNodeIdx].load;
			   infile << seg[i].Trip[j].startNodeIdx << "(" << seg[i].Trip[j].leaveSP << "|" << db_TimePoint  <<") -> ";
			   while (curC > 0)
			   {
				   db_TimePoint += problem->c[preNode][curC];
				   if (db_TimePoint < problem->node[curC].sTW)  db_TimePoint = problem->node[curC].sTW;
				   infile << curC << "(" << db_TimePoint << "|" << (db_TimePoint+problem->node[curC].duration) << ")" << "->";
				   preNode = curC;
				   db_TimePoint += problem->node[curC].duration;
				
				   curC = nextArr[curC];
			   }

			   if (seg[i].Trip[j].waitingS > 0)
			   {
				   db_TimePoint += problem->c[seg[i].Trip[j].lastCus][seg[i].Trip[j].waitingS];
				   infile << seg[i].Trip[j].waitingS << "*" << "(" << db_TimePoint << "|" << (seg[i].Trip[j].endS - problem->c[seg[i].Trip[j].waitingS][seg[i].Trip[j].endNodeIdx]) << ") ->";
			   }

			   infile << seg[i].Trip[j].endNodeIdx << "(" << seg[i].Trip[j].endS << ")" << endl;
			   
			   infile << endl << endl;

		   }
		   else if (TRIP_C2C == seg[i].Trip[j].Type)
		   {
			   infile << "\t\t\t Type: C2C" << endl;
			   //infile << "\t\t\t Fitness: " << seg[i].Trip[j].fitness << endl;
			   infile << "\t\t\t Cost: " << seg[i].Trip[j].cost << endl;
			   infile << "\t\t\t Capacity: " << seg[i].Trip[j].capacity << endl;
			   infile << "\t\t\t Arrived at: " << seg[i].Trip[j].arriveSP << endl;
			   infile << "\t\t\t Leave at: " << seg[i].Trip[j].leaveSP << endl;
			   infile << "\t\t\t Delivery Nbr: " << seg[i].Trip[j].numCus << endl;
			   infile << "\t\t\t Assigned SP: " << seg[i].Trip[j].assSP << endl;
			   infile << "\t\t\t Started from: " << seg[i].Trip[j].startNodeIdx << endl;
			   infile << "\t\t\t End at: " << seg[i].Trip[j].endNodeIdx << endl;
			   infile << "\t\t\t Waiting station: " << seg[i].Trip[j].waitingS << endl;
			   infile << "\t\t\t EndS: " << seg[i].Trip[j].endS << endl;

			   infile << "\t\t\t ROUTED: ";
			 
			   curC = seg[i].Trip[j].firstCus;
			   int preNode = seg[i].Trip[j].startNodeIdx;
			   double db_TimePoint = seg[i].Trip[j].leaveSP;

			   infile << seg[i].Trip[j].startNodeIdx << "(" << db_TimePoint << ") -> ";

			   while (curC > 0)
			   {
				   db_TimePoint += problem->c[preNode][curC];
				   if (db_TimePoint < problem->node[curC].sTW)  db_TimePoint = problem->node[curC].sTW;
				   infile << curC << "(" << db_TimePoint << "|" << (db_TimePoint+problem->node[curC].duration) << ")" << "->";
				   preNode = curC;
				   db_TimePoint += problem->node[curC].duration;
				
				   curC = nextArr[curC];
			   }

			   if (seg[i].Trip[j].waitingS > 0)
			   {
				   db_TimePoint += problem->c[seg[i].Trip[j].lastCus][seg[i].Trip[j].waitingS];
				   infile << seg[i].Trip[j].waitingS << "*" << "(" << db_TimePoint << "|" << (seg[i].Trip[j].endS - problem->c[seg[i].Trip[j].waitingS][seg[i].Trip[j].endNodeIdx]) << ") ->";
			   }

			   infile << seg[i].Trip[j].endNodeIdx << "(" << seg[i].Trip[j].endS << ")" << endl;
			   
			   infile << endl << endl;
		   }
		   else if (TRIP_PICKUP == seg[i].Trip[j].Type)
		   {
			   infile << "\t\t\t Type: PICKUP" << endl;
			   //infile << "\t\t\t Fitness: " << seg[i].Trip[j].fitness << endl;
			   infile << "\t\t\t Cost: " << seg[i].Trip[j].cost << endl;
			   infile << "\t\t\t Capacity: " << seg[i].Trip[j].capacity << endl;
			   infile << "\t\t\t Arrived at: " << seg[i].Trip[j].arriveSP << endl;
			   infile << "\t\t\t Leave at: " << seg[i].Trip[j].leaveSP << endl;
			   infile << "\t\t\t Delivery Nbr: " << seg[i].Trip[j].numCus << endl;
			   infile << "\t\t\t Assigned SP: " << seg[i].Trip[j].assSP << endl;
			   infile << "\t\t\t Started from: " << seg[i].Trip[j].startNodeIdx << endl;
			   infile << "\t\t\t End at SP: " << seg[i].Trip[j].endNodeIdx << endl;
			   infile << "\t\t\t Waiting station: " << seg[i].Trip[j].waitingS << endl;
			   infile << "\t\t\t EndS: " << seg[i].Trip[j].endS << endl;

			   infile << "\t\t\t ROUTED: ";
			   curC = seg[i].Trip[j].firstCus;
			   int preNode = seg[i].Trip[j].startNodeIdx;
			   double db_TimePoint = seg[i].Trip[j].leaveSP;
			   
			   infile << seg[i].Trip[j].startNodeIdx << "(" << db_TimePoint << ") -> ";
			   while (curC > 0)
			   {
				   db_TimePoint += problem->c[preNode][curC];
				   if (db_TimePoint < problem->node[curC].sTW)  db_TimePoint = problem->node[curC].sTW;
				   infile << curC << "(" << db_TimePoint << "|" << (db_TimePoint+problem->node[curC].duration) << ")" << "->";
				   preNode = curC;
				   db_TimePoint += problem->node[curC].duration;

				   curC = nextArr[curC];
			   }
			   if (seg[i].Trip[j].waitingS > 0)
			   {
				   db_TimePoint += problem->c[seg[i].Trip[j].lastCus][seg[i].Trip[j].waitingS];
				   infile << seg[i].Trip[j].waitingS << "*" << "(" << db_TimePoint << "|" << (seg[i].Trip[j].endS - problem->nodeSP[seg[i].Trip[j].endNodeIdx].unload - problem->c[seg[i].Trip[j].waitingS][seg[i].Trip[j].endNodeIdx]) << ") ->";
			   }
			   infile << seg[i].Trip[j].endNodeIdx << "(" << (seg[i].Trip[j].endS - problem->nodeSP[seg[i].Trip[j].endNodeIdx].unload) << "|" << seg[i].Trip[j].endS << ")" << endl << endl;			   
			   infile << endl << endl;
		   }
	   }
   }
#if _DEBUG
   cout << "ok!" << endl;
#endif
}

void Solution::showSegment(int idVeh)
{
	int j, curC;

       cout<<seg[idVeh].numTrips<<endl;
	   for (j=0;j<seg[idVeh].numTrips;j++)
	   {
		   if (seg[idVeh].Trip[j].Type)
		   {
			   cout<<idVeh<<"   "<<j<<"   1\t"<<seg[idVeh].Trip[j].fitness<<" \t "<<seg[idVeh].Trip[j].cost<<" \t "<<seg[idVeh].Trip[j].capacity<<" \t "<<seg[idVeh].Trip[j].numCus<<" \t";
			   cout<<seg[idVeh].Trip[j].assSP<<"\t";
			   curC = seg[idVeh].Trip[j].firstCus;
			   while (curC > 0)
			   {
				   cout<<curC<<"\t";
				   curC = nextArr[curC];
			   }
			   cout<<seg[idVeh].Trip[j].waitingS<<endl;
		   }
		   else
		   {
			   cout<<idVeh<<"   "<<j<<"   0\t"<<seg[idVeh].Trip[j].fitness<<" \t "<<seg[idVeh].Trip[j].cost<<" \t "<<seg[idVeh].Trip[j].capacity<<" \t "<<seg[idVeh].Trip[j].numCus<<" \t";
			   curC = seg[idVeh].Trip[j].firstCus;
			   while (curC > 0)
			   {
				   cout<<curC<<"\t";
				   curC = nextArr[curC];
			   }
			   cout<<seg[idVeh].Trip[j].waitingS<<"\t";
			   cout<<seg[idVeh].Trip[j].assSP<<endl;
		   }
	   }
 }

//------------------------------------------- CHECK SOLUTION ----------------------------------//
bool Solution::checkSolution()
{
	int i,j; bool correct = 1;
	int numVehUsedT = 0;
	double costSegT, costT=0;

	checkUsed = new bool[totalNODE1];
	for (i=1;i<=totalNODE;i++) checkUsed[i] = 0;
	

	for (i=0;i<numVeh;i++)
	{
        if (seg[i].numTrips >0)
		{
			numVehUsedT ++; costSegT = 0;
			for (j=0;j<seg[i].numTrips;j++)
			{
				if (seg[i].Trip[j].Type)
				{
					correct = checkTripD_checkSolution(i,j);
					if (correct == 0) 
					{
						cout<<"AT Solution::checkSolution: there is error on delivery trip "<<j<<" of vehicle "<<i<<endl;				
						showTripCost(i,j);
						exit(-1);
					}
				}
				else
				{
					//Checking tat ca cac thuoc tinh cua tripP:
					correct = checkTripP_checkSolution(i,j);
					if (correct == 0) 
					{
						cout<<"AT Solution::checkSolution: there is error on pickup trip ("<<i<<", "<<j<<")"<<endl;
						showTripCost(i,j);
						exit(-1);
					}
					//else cout<<"PICKUP Trip ("<<i<<", "<<j<<", assSP = "<<seg[i].Trip[j].assSP<<") ok after checkTripP_ML_checkSolution"<<endl;
				}//end (i,j) is pickup trip
				costSegT += seg[i].Trip[j].cost;
			}//end for (j=0;j<seg[i].numTrips;j++)
			if (PDSDIF(costSegT, seg[i].cost))
			{
				cout<<"AT Solution::checkSolution: there is error on total cost of vehicle "<<i<<": correct = "<<costSegT<<"; wrong = "<<seg[i].cost<<endl;				
				exit(-1);
			}
			costT += costSegT;
		}//end if (seg[i].numTrips >0) 
   }
   if (numVehUsedT != numVehUsed)
   {
		cout<<"ERROR: numVehUsed correct = "<<numVehUsedT<<"; wrong = "<<numVehUsed<<endl;
		correct = 0;
   }
   if (PDSDIF(costT, cost))
   {
	    cout<<"ERROR: cost of solution: correct = "<<costT<<"; wrong = "<<cost<<endl;
		correct = 0;
   }

	for (i=startidP;i<= endidP;i++) 
		if (checkUsed[i] == 0)
		{
			cout<<"ERROR: pickup customer "<<i<<" not routed yet"<<endl;
			correct = 0;
		}

	for (i=startidD;i<=totalNODE;i++) 
		if (checkUsed[i] == 0)
		{
			cout<<"ERROR: delivery customer "<<i<<" not routed yet"<<endl;
			correct = 0;
		}

	delete [] checkUsed;
	return correct;
}

bool Solution::checkTripD_checkSolution(int idVeh, int idTrip) //just checking field of trip; for FEASIBLE TRIP ONLY
{
	bool correct = 1;
	double cTemp = 0; 
	int assSP = seg[idVeh].Trip[idTrip].assSP;
	double leaveSPT, vioTWSPT, cArrTime,temp;
	int i;

	if (idTrip == 0)
	{
		if (PDSDIF(seg[idVeh].Trip[0].leaveSP, problem->leaveSP[seg[idVeh].Trip[0].assSP][4]))
		{
			cout<<"ERROR checkTripD_checkSolution("<<idVeh<<", "<<idTrip<<") LeaveSP: correct = "<<problem->leaveSP[seg[idVeh].Trip[0].assSP][4]<<"; wrong = "<<seg[idVeh].Trip[0].leaveSP<<endl;
			correct = 0;
		}
		if (seg[idVeh].Trip[idTrip].coordinate==1)
		{
			cout<<"ERROR checkTripD_checkSolution("<<idVeh<<", "<<idTrip<<"): correct = NOT coordinate, but coordinate field = "<<seg[idVeh].Trip[idTrip].coordinate<<endl;
			correct = 0;
		}			 
		cTemp += problem->c[0][assSP];
	}
	else
	{
		 int preT = idTrip - 1; 
		 if (seg[idVeh].Trip[preT].Type)
		 {
			 int lastCpreT = seg[idVeh].Trip[preT].lastCus;
			 if (seg[idVeh].Trip[preT].waitingS == NO_WS)
	 			cArrTime = depart[lastCpreT] + problem->c[lastCpreT][assSP];
			 else cArrTime = depart[lastCpreT] + problem->disCWSSP[lastCpreT][assSP];
			 temp = cArrTime - problem->nodeSP[assSP].eTW2;
			 if (temp > eps) 
			 {
				 vioTWSPT = temp;
				 leaveSPT = problem->nodeSP[assSP].eTW2 + problem->nodeSP[assSP].load;
			 }
			 else
			 {
				 leaveSPT = PDS_MAX(cArrTime, problem->nodeSP[assSP].sTW2) + problem->nodeSP[assSP].load;
				 vioTWSPT = 0;
			 }
			 if (seg[idVeh].Trip[idTrip].coordinate==1)
			 {
				 cout<<"ERROR: checkTripD_checkSolution("<<idVeh<<", "<<idTrip<<"): correct =  NOT coordinate, but field coordinate = "<<seg[idVeh].Trip[idTrip].coordinate<<endl;
				 correct = 0;
			 }			 
		 }
		 else
		 {
			 int assSPpreT = seg[idVeh].Trip[preT].assSP;
			 if (assSPpreT == assSP) cArrTime = seg[idVeh].Trip[preT].leaveSP;
			 else
			 {
				 if (seg[idVeh].Trip[preT].waitingS1 == NO_WS)
	 				cArrTime = seg[idVeh].Trip[preT].leaveSP + problem->c[assSPpreT][assSP];
				 else cArrTime = seg[idVeh].Trip[preT].leaveSP + problem->disCWSSP[assSPpreT][assSP];
			 }
			 temp = cArrTime - problem->nodeSP[assSP].eTW2;
			 if (temp > eps)
			 {
				 vioTWSPT = temp;
				 leaveSPT = problem->nodeSP[assSP].eTW2 + problem->nodeSP[assSP].load;
			 }
			 else
			 {
				 leaveSPT = PDS_MAX(cArrTime, problem->nodeSP[assSP].sTW2) + problem->nodeSP[assSP].load;
				 vioTWSPT = 0;
			 }
			 if (seg[idVeh].Trip[idTrip].coordinate==0)
			 {
				 cout<<"ERROR: checkTripD_checkSolution("<<idVeh<<", "<<idTrip<<"): correct = coordinate, but field coordinate = "<<seg[idVeh].Trip[idTrip].coordinate<<endl;
				 correct = 0;
			 }			 
		 }
		 if (PDSDIF(leaveSPT, seg[idVeh].Trip[idTrip].leaveSP))
		 {
			cout<<"ERRROR checkTripD_checkSolution("<<idVeh<<", "<<idTrip<<"): leaveSP at sp "<<assSP<<": correct = "<<leaveSPT<<"; wrong = "<<seg[idVeh].Trip[idTrip].leaveSP<<endl;
			correct = 0;
		 }
		 if (PDSDIF(vioTWSPT, seg[idVeh].Trip[idTrip].vioTWSP))
		 {
			 cout<<"ERRROR checkTripD_checkSolution("<<idVeh<<", "<<idTrip<<"): vioTWSP at sp "<<assSP<<": correct = "<<temp<<";Field vioTWSP = "<<seg[idVeh].Trip[idTrip].vioTWSP<<endl;
			 cout<<"SP = "<<assSP<<"; [sTW2, eTW2] = "<<problem->nodeSP[assSP].sTW2<<", "<<problem->nodeSP[assSP].eTW2<<"]"<<endl;
			 correct = 0;
		}
	}
	if (correct)
	{
		int preC  = assSP;
		int curC = seg[idVeh].Trip[idTrip].firstCus;
		double endS = seg[idVeh].Trip[idTrip].leaveSP;
		int CAPT = 0; double vioTWCT;

		for (i=1;i <= seg[idVeh].Trip[idTrip].numCus;i++)
		{
			CAPT += problem->node[curC].capacity; 
			cTemp += problem->c[preC][curC];
			endS += problem->c[preC][curC];
			vioTWCT = PDS_MAX(endS - problem->node[curC].eTW, 0);
			if (PDSDIF(vioTWCT, vioTWCus[curC])) 
			{
				correct = 0;
				cout<<"ERROR checkTripD_checkSolution("<<idVeh<<", "<<idTrip<<") vioTWCus["<<curC<<"]: correct = "<<vioTWCT<<"; field vioTWCus wrong = "<<vioTWCus[curC]<<endl;
			}
			if (vioTWCT > eps)
			{
				endS = problem->node[curC].eTW;
				cout<<"ERROR checkTripD_checkSolution("<<idVeh<<", "<<idTrip<<"): FEASIBLE delivery trip but vioTWCus["<<curC<<"] = "<<vioTWCT<<endl;
			    correct = 0;
			}
			else endS = PDS_MAX(endS, problem->node[curC].sTW);
			if (PDSDIF(endS, startS[curC]))
			{
				correct = 0;
				cout<<"ERROR checkTripD_checkSolution("<<idVeh<<", "<<idTrip<<"): startS["<<curC<<"]: correct = "<<endS<<"; field startS wrong = "<<startS[curC]<<endl;
			}
			
			endS += problem->node[curC].duration;
			if (PDSDIF(endS, depart[curC]))
			{
				correct = 0;
				cout<<"ERROR checkTripD_checkSolution("<<idVeh<<", "<<idTrip<<"): depart["<<curC<<"]: correct = "<<endS<<"; field depart wrong = "<<depart[curC]<<endl;
			}
			preC = curC; curC = nextArr[curC];
		}

		if (CAPT != seg[idVeh].Trip[idTrip].capacity)
		{
			cout<<"ERROR checkTripD_checkSolution("<<idVeh<<", "<<idTrip<<") CAP of trip: correct = "<<CAPT<<"; wrong = "<<seg[idVeh].Trip[idTrip].capacity<<endl;
			correct = 0;
		}
		else
		{
			int vioCAPT = PDS_MAX(CAPT - problem->Q, 0);
			if (vioCAPT != seg[idVeh].Trip[idTrip].vioCAP)
			{
				correct = 0;
				cout<<"ERROR checkTripD_checkSolution("<<idVeh<<", "<<idTrip<<") vioCAP: wrong = "<<seg[idVeh].Trip[idTrip].vioCAP<<"; correct = "<<vioCAPT<<endl;
			}
			if (vioCAPT > 0)
			{
				correct = 0;
				cout<<"ERROR checkTripD_checkSolution("<<idVeh<<", "<<idTrip<<"): FEASIBLE DELIVERY TRIP but vioCAP = "<<vioCAPT<<endl;
			}

		}

		double costBetweenCusOnly = seg[idVeh].Trip[idTrip].cost - seg[idVeh].Trip[idTrip].connectCost;
		if (PDSDIF(costBetweenCusOnly, cTemp))
		{
			correct = 1;
			cout<<"ERROR checkTripD_checkSolution("<<idVeh<<", "<<idTrip<<") total cost between customers only: wrong = "<<costBetweenCusOnly<<"; correct = "<<cTemp<<endl;
		    cout<<"Field ConnectCost = "<<seg[idVeh].Trip[idTrip].connectCost<<endl;
		}

		if (PDSDIF(seg[idVeh].Trip[idTrip].endS, endS)==0)
		{
				int nextTrip = idTrip + 1;
				if (nextTrip < seg[idVeh].numTrips) // not last Trip
				{
					if (seg[idVeh].Trip[nextTrip].Type ==0) //next trip is pickup trip:
					{
						 cTemp += problem->c[preC][seg[idVeh].Trip[nextTrip].firstCus];
						 if (PDSDIF(problem->c[preC][seg[idVeh].Trip[nextTrip].firstCus],seg[idVeh].Trip[idTrip].connectCost))
						 {
							 cout<<"ERROR checkTripD_checkSolution("<<idVeh<<", "<<idTrip<<"): Connectcost: correct = "<<problem->c[preC][seg[idVeh].Trip[nextTrip].firstCus]<<"; error = "<<seg[idVeh].Trip[idTrip].connectCost<<endl;
							 cout<<"CASE: "<<assSP<<" - DELIVERY TRIP - PICKUP TRIP"<<endl;
							 correct = 0;
						 }
					 	 if (seg[idVeh].Trip[idTrip].waitingS != NO_WS)
						 {
							 cout<<"ERROR checkTripD_checkSolution("<<idVeh<<", "<<idTrip<<"): Waiting station: correct = noWS"<<"; wrong = "<<seg[idVeh].Trip[idTrip].waitingS<<endl;
							 cout<<"CASE: "<<assSP<<" - DELIVERY TRIP - PICKUP TRIP"<<endl;
							 correct = 0;
						}
					}
					else //next trip is delivery trip:
					{
						 int endSP = seg[idVeh].Trip[nextTrip].assSP;
						 double cArrTime = endS + problem->c[preC][endSP];
						 if (PDSINRANGE(cArrTime, problem->nodeSP[endSP].sTW2, problem->nodeSP[endSP].eTW2))
						 {
							 cTemp +=  problem->c[preC][endSP];

							 if (PDSDIF(problem->c[preC][endSP],seg[idVeh].Trip[idTrip].connectCost))
							 {
								 cout<<"ERROR checkTripD_checkSolution("<<idVeh<<", "<<idTrip<<"): Connectcost : correct = "<<problem->c[preC][endSP]<<"; error = "<<seg[idVeh].Trip[idTrip].connectCost<<endl;
								 cout<<"CASE: "<<assSP<<" - DELIVERY TRIP - sp = "<<(endSP)<<" - DELIVERY TRIP"<<endl;
								 correct = 0;
							 }
							 if (seg[idVeh].Trip[idTrip].waitingS != NO_WS)
							 {
								 cout<<"ERROR checkTripD_checkSolution("<<idVeh<<", "<<idTrip<<"): Waiting station: correct = noWS"<<"; wrong = "<<seg[idVeh].Trip[idTrip].waitingS<<endl;
								 cout<<"CASE: "<<assSP<<" - DELIVERY TRIP - sp = "<<(endSP)<<" - DELIVERY TRIP"<<endl;
								 correct = 0;
							 }
							 if (seg[idVeh].Trip[nextTrip].vioTWSP > eps)
							 {
								 cout<<"ERROR checkTripD_checkSolution("<<idVeh<<", "<<idTrip<<"): vioTWSP : correct = 0; wrong = "<<seg[idVeh].Trip[nextTrip].vioTWSP<<endl;
								 cout<<"CASE: "<<assSP<<" - DELIVERY TRIP - sp = "<<(endSP)<<" - DELIVERY TRIP"<<endl;
								 correct = 0;
							 }
						 }
						 else
						 {
							  temp = cArrTime - problem->nodeSP[endSP].eTW2;
							  if (temp > eps)
							  {
								  if (PDSDIF(problem->c[preC][endSP],seg[idVeh].Trip[idTrip].connectCost))
								  {
									 cout<<"ERROR checkTripD_checkSolution("<<idVeh<<", "<<idTrip<<"): Connectcost : correct = "<<problem->c[preC][endSP]<<"; error = "<<seg[idVeh].Trip[idTrip].connectCost<<endl;
									 cout<<"CASE: "<<assSP<<" - DELIVERY TRIP - sp = "<<(endSP)<<" - DELIVERY TRIP; exceed eTW2"<<endl;
									 correct = 0;
								  }
								  if (seg[idVeh].Trip[idTrip].waitingS != NO_WS)
								  {
									 cout<<"ERROR checkTripD_checkSolution("<<idVeh<<", "<<idTrip<<"): Waiting station: correct = noWS"<<"; wrong = "<<seg[idVeh].Trip[idTrip].waitingS<<endl;
									 cout<<"CASE: "<<assSP<<" - DELIVERY TRIP - sp = "<<(endSP)<<" - DELIVERY TRIP; exceed eTW2"<<endl;
									 correct = 0;
								  }

								  if (PDSDIF(temp, seg[idVeh].Trip[nextTrip].vioTWSP))
								  {
									  cout<<"ERROR checkTripD_checkSolution("<<idVeh<<", "<<idTrip<<"): vioTWSP : correct = "<<temp<<"; wrong = "<<seg[idVeh].Trip[nextTrip].vioTWSP<<endl;
									  cout<<"CASE: "<<assSP<<" - DELIVERY TRIP - sp = "<<(endSP)<<" - DELIVERY TRIP; exceed eTW2"<<endl;
									  correct = 0;
								  }
								  if (temp > eps)
								  {
									  cout<<"ERROR checkTripD_checkSolution("<<idVeh<<", "<<idTrip<<"): feasible trip but vioTWSP = "<<temp<<endl;
									  cout<<"CASE: "<<assSP<<" - DELIVERY TRIP - sp = "<<(endSP)<<" - DELIVERY TRIP; exceed eTW2"<<endl;
									  correct = 0;
								  }
	  							  cTemp +=  problem->c[preC][endSP];
							  }
							  else
							  {
								  double cArrTimeI = endS + problem->disCWSSP[preC][endSP];
								  temp = cArrTimeI - problem->nodeSP[endSP].eTW2;
								  if (temp > eps)
								  {
									  if (PDSDIF(problem->c[preC][endSP],seg[idVeh].Trip[idTrip].connectCost))
									  {
										 cout<<"ERROR checkTripD_checkSolution("<<idVeh<<", "<<idTrip<<"): Connectcost : correct = "<<problem->c[preC][endSP]<<"; error = "<<seg[idVeh].Trip[idTrip].connectCost<<endl;
										 cout<<"CASE: "<<assSP<<" - DELIVERY TRIP - sp = "<<(endSP)<<" - DELIVERY TRIP; too soon to sp directly; too late through WS"<<endl;
										 correct = 0;
									  }
									  if (seg[idVeh].Trip[idTrip].waitingS != NO_WS)
									  {
										 cout<<"ERROR checkTripD_checkSolution("<<idVeh<<", "<<idTrip<<"): Waiting station: correct = noWS"<<"; wrong = "<<seg[idVeh].Trip[idTrip].waitingS<<endl;
										 cout<<"CASE: "<<assSP<<" - DELIVERY TRIP - sp = "<<(endSP)<<" - DELIVERY TRIP; too soon to sp directly; too late through WS"<<endl;
										 correct = 0;
									  }

									  temp = problem->nodeSP[endSP].sTW2 - cArrTime;
									  if (PDSDIF(temp, seg[idVeh].Trip[nextTrip].vioTWSP))
									  {
										  cout<<"ERROR checkTripD_checkSolution("<<idVeh<<", "<<idTrip<<"): vioTWSP : correct = "<<temp<<"; wrong = "<<seg[idVeh].Trip[nextTrip].vioTWSP<<endl;
										 cout<<"CASE: "<<assSP<<" - DELIVERY TRIP - sp = "<<(endSP)<<" - DELIVERY TRIP; too soon to sp directly; too late through WS"<<endl;
										  correct = 0;
									  }
									  
									  cout<<"ERROR checkTripD_checkSolution("<<idVeh<<", "<<idTrip<<"): feasible delivery trip but vioTWSP = "<<temp<<endl;
									  cout<<"CASE: "<<assSP<<" - DELIVERY TRIP - sp = "<<(endSP)<<" - DELIVERY TRIP; too soon to sp directly; too late through WS"<<endl;
									  correct = 0;
									  cTemp +=  problem->c[preC][endSP];
								  }
								  else //through WS:
								  {
									  if (PDSDIF(problem->disCWSSP[preC][endSP],seg[idVeh].Trip[idTrip].connectCost))
									  {
										 cout<<"ERROR checkTripD_checkSolution("<<idVeh<<", "<<idTrip<<"): Connectcost : correct = "<<problem->disCWSSP[preC][endSP]<<"; error = "<<seg[idVeh].Trip[idTrip].connectCost<<endl;
										 cout<<"CASE: "<<assSP<<" - DELIVERY TRIP - sp = "<<(endSP)<<" - DELIVERY TRIP; through WS"<<endl;
										 correct = 0;
									  }
									  if (seg[idVeh].Trip[idTrip].waitingS != problem->CWSSP[preC][endSP])
									  {
										  cout<<"ERROR checkTripD_checkSolution("<<idVeh<<", "<<idTrip<<"): Waiting station: correct = "<<problem->CWSSP[preC][endSP]<<"; wrong = "<<seg[idVeh].Trip[idTrip].waitingS<<endl;
										  cout<<"CASE: "<<assSP<<" - DELIVERY TRIP - sp = "<<(endSP)<<" - DELIVERY TRIP; through WS"<<endl;
										  correct = 0;
									  }

									  if (seg[idVeh].Trip[nextTrip].vioTWSP > eps)
									  {
										  cout<<"ERROR checkTripD_checkSolution("<<idVeh<<", "<<idTrip<<"): vioTWSP : correct = 0; wrong = "<<seg[idVeh].Trip[nextTrip].vioTWSP<<endl;
										  cout<<"CASE: "<<assSP<<" - DELIVERY TRIP - sp = "<<(endSP)<<" - DELIVERY TRIP; through WS"<<endl;
										  correct = 0;
									  }
									  cTemp += problem->disCWSSP[preC][endSP];
								  }//end through WS
							  }
						 }
					}

				}
				else //the lastTrip
				{
					if (PDSDIF(seg[idVeh].Trip[idTrip].connectCost, problem->c[preC][0]))
					{
						cout<<"ERROR checkTripD_checkSolution("<<idVeh<<", "<<idTrip<<"): connectCost of the last delivery Trip: correct = "<<problem->c[preC][0]<<"; wrong = "<<seg[idVeh].Trip[idTrip].connectCost<<endl;
						correct = 0;
					}
					cTemp += problem->c[preC][0];
				}//end the lastTrip
				if (PDSDIF(cTemp,seg[idVeh].Trip[idTrip].cost))
				{
					 cout<<"ERROR checkTripD_checkSolution("<<idVeh<<", "<<idTrip<<") cost: correct = "<<cTemp<<"; error = "<<seg[idVeh].Trip[idTrip].cost<<endl;
					 correct = 0;
				}
		}
		else 
		{
			cout<<"ERROR checkTripD_checkSolution("<<idVeh<<", "<<idTrip<<"): endS: correct = "<<endS<<"; wrong = "<<seg[idVeh].Trip[idTrip].endS<<endl;
			correct = 0;
		}
	}
	return correct;
}

bool Solution::checkTripP_checkSolution(int idVeh, int idTrip) //just checking field of trip; for FEASIBLE TRIP only
{
	bool correct = 1;
	double cTemp = 0; 

	int assSP = seg[idVeh].Trip[idTrip].assSP;
	int preC = seg[idVeh].Trip[idTrip].firstCus;
	int curC, i;
	double endS, cArrTime, cArrTimeI, temp;
	curC = seg[idVeh].Trip[idTrip].firstCus;

	if (idTrip == 0)
	{
		endS = 0;
		preC = 0;
	}
	else
	{
		int preT = idTrip - 1;
		if (seg[idVeh].Trip[preT].Type)
		{
			preC = seg[idVeh].Trip[preT].lastCus;
			endS = depart[preC];
		}
		else
		{
			preC = seg[idVeh].Trip[preT].assSP;
			endS = seg[idVeh].Trip[preT].leaveSP;
		}
		cTemp =-problem->c[preC][curC];

	}

	int CAPT = 0; double vioTWCT;
	for (i=1;i<=seg[idVeh].Trip[idTrip].numCus;i++)
	{
			CAPT += problem->node[curC].capacity; 
			cTemp += problem->c[preC][curC];
			endS += problem->c[preC][curC];
			vioTWCT = PDS_MAX(endS - problem->node[curC].eTW, 0);
			if (PDSDIF(vioTWCT, vioTWCus[curC])) 
			{
				correct = 0;
				cout<<"ERROR checkTripP_checkSolution("<<idVeh<<", "<<idTrip<<"): vioTWCus["<<curC<<"]: wrong = "<<vioTWCus[curC]<<"; correct = "<<vioTWCT<<endl;
			}
			if (vioTWCT > eps)
			{
				endS = problem->node[curC].eTW;
				cout<<"ERROR checkTripP_checkSolution("<<idVeh<<", "<<idTrip<<"): feasible pickup trip but vioTWCus["<<curC<<"] = "<<vioTWCT<<endl;
			    correct = 0;
			}
			else endS = PDS_MAX(endS, problem->node[curC].sTW);

			if (PDSDIF(endS, startS[curC]))
			{
				correct = 0;
				cout<<"ERROR checkTripP_checkSolution("<<idVeh<<", "<<idTrip<<"): startS["<<curC<<"]: wrong = "<<startS[curC]<<"; correct = "<<endS<<endl;
			}
			
			endS += problem->node[curC].duration;
			if (PDSDIF(endS, depart[curC]))
			{
				correct = 0;
				cout<<"ERROR checkTripP_checkSolution("<<idVeh<<", "<<idTrip<<"): depart["<<curC<<"]: wrong = "<<depart[curC]<<"; correct = "<<endS<<endl;
			}
			preC = curC; curC = nextArr[curC];
	}

	if (CAPT != seg[idVeh].Trip[idTrip].capacity)
	{
		cout<<"ERROR checkTripP_checkSolution("<<idVeh<<", "<<idTrip<<"): cap of trip: correct = "<<CAPT<<"; wrong = "<<seg[idVeh].Trip[idTrip].capacity<<endl;
		correct = 0;
	}
	else
	{
		int vioCAPT = PDS_MAX(CAPT - problem->Q, 0);
		if (vioCAPT != seg[idVeh].Trip[idTrip].vioCAP)
		{
			correct = 0;
			cout<<"ERROR checkTripP_checkSolution("<<idVeh<<", "<<idTrip<<"): vioCAP: wrong = "<<seg[idVeh].Trip[idTrip].vioCAP<<"; correct = "<<vioCAPT<<endl;
		}
		if (vioCAPT > 0)
		{
			correct = 0;
			cout<<"ERROR checkTripP_checkSolution("<<idVeh<<", "<<idTrip<<"): feasible pickup trip but vioCAP = "<<vioCAPT<<endl;
		}

	}

		if (PDSDIF(seg[idVeh].Trip[idTrip].endS, endS)==0)
		{
			cArrTime = endS + problem->c[preC][assSP];
			if (PDSINRANGE(cArrTime, problem->nodeSP[assSP].sTW1, problem->nodeSP[assSP].eTW1))
			{
				cTemp += problem->c[preC][assSP];
				if (seg[idVeh].Trip[idTrip].waitingS != NO_WS)
				{
					cout<<"ERROR checkTripP_checkSolution("<<idVeh<<", "<<idTrip<<"): correct waitingS = NO_WS; wrong = "<<seg[idVeh].Trip[idTrip].waitingS<<endl;
					correct = 0;
				}
				if (seg[idVeh].Trip[idTrip].vioTWSP > eps)
				{
					cout<<"ERROR checkTripP_checkSolution("<<idVeh<<", "<<idTrip<<"): correct vioTWSP = 0; wrong = "<<seg[idVeh].Trip[idTrip].vioTWSP<<endl;
					correct = 0;
				}
				endS = cArrTime + problem->nodeSP[assSP].unload;
			}
			else
			{
				temp = cArrTime - problem->nodeSP[assSP].eTW1;
				if (temp > eps)
				{
					if (seg[idVeh].Trip[idTrip].waitingS != NO_WS)
						cout<<"ERROR checkTripP_checkSolution("<<idVeh<<", "<<idTrip<<"): correct waitingS = NO_WS; wrong = "<<seg[idVeh].Trip[idTrip].waitingS<<endl;
					if (PDSDIF(temp, seg[idVeh].Trip[idTrip].vioTWSP))
						cout<<"ERROR checkTripP_checkSolution("<<idVeh<<", "<<idTrip<<"): correct vioTWSP = "<<temp<<"; wrong = "<<seg[idVeh].Trip[idTrip].vioTWSP<<endl;
					
					cout<<"ERROR checkTripP_checkSolution("<<idVeh<<", "<<idTrip<<"): feasible pickup trip but vioTWSP = "<<temp<<endl;
					cout<<"CASE exceed eTW1 of sp "<<assSP<<"; eTW1 = "<<problem->nodeSP[assSP].eTW1<<"; cArrTime = "<<cArrTime<<endl;
					correct = 0;
					endS = problem->leaveSP[assSP][0]; //unload at eTW1
				}
				else
				{
					double cArrTimeI = endS + problem->disCWSSP[preC][assSP];
					temp = cArrTimeI - problem->nodeSP[assSP].eTW1;
					if (temp > eps)
					{
						temp = cArrTime - problem->nodeSP[assSP].sTW1;
						if (PDSDIF(temp, seg[idVeh].Trip[idTrip].vioTWSP))
							cout<<"ERROR checkTripP_checkSolution("<<idVeh<<", "<<idTrip<<"): correct vioTWSP = "<<temp<<"; wrong = "<<seg[idVeh].Trip[idTrip].vioTWSP<<endl;
						if (seg[idVeh].Trip[idTrip].waitingS != NO_WS)
							cout<<"ERROR checkTripP_checkSolution("<<idVeh<<", "<<idTrip<<"): correct waitingS = NO_WS; wrong = "<<seg[idVeh].Trip[idTrip].waitingS<<endl;

						cout<<"ERROR checkTripP_checkSolution("<<idVeh<<", "<<idTrip<<"): feasible pickup trip but vioTWSP = "<<temp<<endl;
						cout<<"CASE too soon to go sp directly; too late through WS: cArrTimeD = "<<cArrTime<<"; cArrTimeIndirectly = "<<cArrTimeI<<"; eTW1 = "<<problem->nodeSP[assSP].eTW1<<endl;
						correct = 0;
						endS = problem->leaveSP[assSP][0]; //unload at eTW1
					}
					else
					{
						cTemp += problem->disCWSSP[preC][assSP];
						if (seg[idVeh].Trip[idTrip].waitingS != problem->CWSSP[preC][assSP])
						{
							cout<<"ERROR checkTripP_checkSolution("<<idVeh<<", "<<idTrip<<"): correct waitingS = "<<problem->CWSSP[preC][assSP]<<"; wrong = "<<seg[idVeh].Trip[idTrip].waitingS<<endl;
							cout<<"LastCus of trip = "<<preC<<" !=? "<<seg[idVeh].Trip[idTrip].lastCus<<endl;
							cout<<"CASE to go through WS"<<endl;
							correct = 0;
						}
						if (seg[idVeh].Trip[idTrip].vioTWSP > eps)
						{
							cout<<"ERROR checkTripP_checkSolution("<<idVeh<<", "<<idTrip<<"): correct vioTWSP = 0; wrong = "<<seg[idVeh].Trip[idTrip].vioTWSP<<endl;
							cout<<"CASE to go through WS"<<endl;
							correct = 0;
						}
						endS = PDS_MAX(cArrTimeI, problem->nodeSP[assSP].sTW1) + problem->nodeSP[assSP].unload;
					}
				}
			}
			if (correct)
			{
				double costT = seg[idVeh].Trip[idTrip].cost - seg[idVeh].Trip[idTrip].connectCost;
				if (PDSDIF(cTemp, costT))
				{
					cout<<"ERROR checkTripP_checkSolution("<<idVeh<<", "<<idTrip<<"): cost (between cus and SP, exclude connectCost): correct = "<<cTemp<<"; wrong = "<<costT<<endl;
					correct = 0;
				}
				else
				{
					int lastT = seg[idVeh].numTrips - 1;
					if (idTrip == lastT)
					{
						if (PDSDIF(problem->c[assSP][0], seg[idVeh].Trip[idTrip].connectCost))
						{
							cout<<"ERROR checkTripP_checkSolution("<<idVeh<<", "<<idTrip<<"): Connectcost: correct = "<<problem->c[assSP][0]<<"; wrong = "<<seg[idVeh].Trip[idTrip].connectCost<<endl;
							cout<<"CASE last pickup trip"<<endl;
							correct = 0;
						}
						if (seg[idVeh].Trip[idTrip].waitingS1 != NO_WS)
						{
							cout<<"ERROR checkTripP_checkSolution("<<idVeh<<", "<<idTrip<<"): waitingS1 = NO_WS; wrong = "<<seg[idVeh].Trip[idTrip].waitingS1<<endl;
							cout<<"CASE last pickup trip"<<endl;
							correct = 0;
						}
						cTemp += problem->c[assSP][0];
					}
					else //not lastTrip
					{
						int nextT = idTrip + 1;
						if (seg[idVeh].Trip[nextT].Type)
						{
							int assSP1 = seg[idVeh].Trip[nextT].assSP;
							if (assSP1 == assSP)
							{
								if (seg[idVeh].Trip[idTrip].connectCost > eps)
								{
									cout<<"ERROR checkTripP_checkSolution("<<idVeh<<", "<<idTrip<<"): Connectcost : correct = 0; wrong = "<<seg[idVeh].Trip[idTrip].connectCost<<endl;
									cout<<"CASE: p - d: sameSP"<<endl;
									correct = 0;
								}
								if (seg[idVeh].Trip[idTrip].waitingS1 != NO_WS)
								{
									cout<<"ERROR checkTripP_checkSolution("<<idVeh<<", "<<idTrip<<"): waitingS1: correct = NO_WS; wrong = "<<seg[idVeh].Trip[idTrip].waitingS1<<endl;
									cout<<"CASE: p - d: sameSP"<<endl;
									correct = 0;
								}
								if (seg[idVeh].Trip[nextT].vioTWSP > eps)
								{
									cout<<"ERROR checkTripP_checkSolution("<<idVeh<<", "<<idTrip<<"): wrong vioTWSP of nextDelivery trip: correct = 0; wrong = "<<seg[idVeh].Trip[nextT].vioTWSP<<endl;
									cout<<"CASE: p - d: sameSP"<<endl;
									correct = 0;
								}
							}
							else
							{
								cArrTime = endS + problem->c[assSP][assSP1];
								if (PDSINRANGE(cArrTime, problem->nodeSP[assSP1].sTW2, problem->nodeSP[assSP1].eTW2))
								{
									cTemp += problem->c[assSP][assSP1];
									if (seg[idVeh].Trip[idTrip].waitingS1 != NO_WS)
									{
										cout<<"ERROR checkTripP_checkSolution("<<idVeh<<", "<<idTrip<<"): correct waitingS1 = NO_WS; wrong = "<<seg[idVeh].Trip[idTrip].waitingS1<<endl;
										cout<<"CASE: p - d: difSP"<<endl;
										correct = 0;
									}
									if (PDSDIF(seg[idVeh].Trip[idTrip].connectCost,problem->c[assSP][assSP1]))
									{
										cout<<"ERROR checkTripP_checkSolution("<<idVeh<<", "<<idTrip<<"): correct = "<<problem->c[assSP][assSP1]<<"; wrong = "<<seg[idVeh].Trip[idTrip].connectCost<<endl;
										cout<<"CASE: p - d: difSP"<<endl;
										correct = 0;
									}
									if (seg[idVeh].Trip[nextT].vioTWSP > eps)
									{
										cout<<"ERROR checkTripP_checkSolution("<<idVeh<<", "<<idTrip<<"): wrong vioTWSP of nextDelivery trip: correct = 0; wrong = "<<seg[idVeh].Trip[nextT].vioTWSP<<endl;
										cout<<"CASE: p - d: difSP"<<endl;
										correct = 0;
									}
								}
								else
								{
									temp = cArrTime - problem->nodeSP[assSP1].eTW2;
									if (temp > eps)
									{
										  cTemp += problem->c[assSP][assSP1];
										  if (seg[idVeh].Trip[idTrip].waitingS1 != NO_WS)
												cout<<"ERROR checkTripP_checkSolution("<<idVeh<<", "<<idTrip<<"): correct waitingS1 = NO_WS; wrong = "<<seg[idVeh].Trip[idTrip].waitingS1<<endl;
										  if (PDSDIF(seg[idVeh].Trip[idTrip].connectCost,problem->c[assSP][assSP1]))
												cout<<"ERROR checkTripP_checkSolution("<<idVeh<<", "<<idTrip<<"): correct = "<<problem->c[assSP][assSP1]<<"; wrong = "<<seg[idVeh].Trip[idTrip].connectCost<<endl;
										  if (PDSDIF(temp, seg[idVeh].Trip[nextT].vioTWSP))
											cout<<"ERROR checkTripP_checkSolution("<<idVeh<<", "<<idTrip<<"): wrong vioTWSP of nextDelivery trip: correct = "<<temp<<"; wrong = "<<seg[idVeh].Trip[nextT].vioTWSP<<endl;

										  cout<<"ERROR checkTripP_checkSolution("<<idVeh<<", "<<idTrip<<"): FEASIBLE (p-d trips) but vioTWSP of nextDelivery trip = "<<seg[idVeh].Trip[nextT].vioTWSP<<endl;
										  cout<<"CASE: p - d: difSP; exceed eTW2 of sp"<<endl;
										  correct = 0;
									}
									else
									{
										cArrTimeI = endS + problem->disCWSSP[assSP][assSP1];
										temp = cArrTimeI - problem->nodeSP[assSP1].eTW2;
										if (temp > eps)
										{
											  cTemp += problem->c[assSP][assSP1];
											  temp = problem->nodeSP[assSP1].sTW2 - cArrTimeI;
											  if (seg[idVeh].Trip[idTrip].waitingS1 != NO_WS)
											  		cout<<"ERROR checkTripP_checkSolution("<<idVeh<<", "<<idTrip<<"): correct waitingS1 = NO_WS; wrong = "<<seg[idVeh].Trip[idTrip].waitingS1<<endl;
											  if (PDSDIF(seg[idVeh].Trip[idTrip].connectCost,problem->c[assSP][assSP1]))
													cout<<"ERROR checkTripP_checkSolution("<<idVeh<<", "<<idTrip<<"): correct = "<<problem->c[assSP][assSP1]<<"; wrong = "<<seg[idVeh].Trip[idTrip].connectCost<<endl;
											  if (PDSDIF(temp, seg[idVeh].Trip[nextT].vioTWSP))
												cout<<"ERROR checkTripP_checkSolution("<<idVeh<<", "<<idTrip<<"): wrong vioTWSP of nextDelivery trip: correct = "<<temp<<"; wrong = "<<seg[idVeh].Trip[nextT].vioTWSP<<endl;
											  
											  cout<<"ERROR checkTripP_checkSolution("<<idVeh<<", "<<idTrip<<"): FEASIBLE (p-d trips) but vioTWSP of nextDelivery trip = "<<seg[idVeh].Trip[nextT].vioTWSP<<endl;
											  cout<<"CASE: p - d: difSP; too soon to sp directly; too late through WS"<<endl;
											  correct = 0;
										}
										else
										{
											cTemp += problem->disCWSSP[assSP][assSP1];
											if (seg[idVeh].Trip[idTrip].waitingS1 != problem->CWSSP[assSP][assSP1])
											{
												cout<<"ERROR checkTripP_checkSolution("<<idVeh<<", "<<idTrip<<"): correct waitingS1 = "<<problem->CWSSP[assSP][assSP1]<<"; wrong = "<<seg[idVeh].Trip[idTrip].waitingS1<<endl;
												cout<<"CASE: p - d: difSP; through WS"<<endl;
												correct = 0;
											}
											if (PDSDIF(seg[idVeh].Trip[idTrip].connectCost,problem->disCWSSP[assSP][assSP1]))
											{
												cout<<"ERROR checkTripP_checkSolution("<<idVeh<<", "<<idTrip<<"): correct = "<<problem->disCWSSP[assSP][assSP1]<<"; wrong = "<<seg[idVeh].Trip[idTrip].connectCost<<endl;
												cout<<"CASE: p - d: difSP; through WS"<<endl;
												correct = 0;
											}
											if (seg[idVeh].Trip[nextT].vioTWSP > eps)
										    {
											    cout<<"ERROR checkTripP_checkSolution("<<idVeh<<", "<<idTrip<<"): wrong vioTWSP of nextDelivery trip: correct = 0; wrong = "<<seg[idVeh].Trip[nextT].vioTWSP<<endl;
											    cout<<"CASE: p - d: difSP; through WS"<<endl;
											    correct = 0;
										    }
										}
									}
								}
							}
						}
						else //nextTrip is pickup trip
						{
							if (PDSDIF(problem->c[assSP][seg[idVeh].Trip[nextT].firstCus],seg[idVeh].Trip[idTrip].connectCost))
							{
								cout<<"ERROR checkTripP_checkSolution("<<idVeh<<", "<<idTrip<<"):ConnectCost correct = "<<problem->c[assSP][seg[idVeh].Trip[nextT].firstCus]<<"; wrong = "<<seg[idVeh].Trip[idTrip].connectCost<<endl;
								cout<<"CASE: p - p"<<endl;
								correct = 0;
							}
							cTemp += problem->c[assSP][seg[idVeh].Trip[nextT].firstCus];
						}
						if (PDSDIF(cTemp, seg[idVeh].Trip[idTrip].cost))
						{
							cout<<"ERROR checkTripP_checkSolution("<<idVeh<<", "<<idTrip<<"):cost correct = "<<cTemp<<"; wrong = "<<seg[idVeh].Trip[idTrip].cost<<endl;
							correct = 0;
						}
					}//end not lastTrip
				}//end not wrong on cost between customers and sp (exclude connectCost)
			}//end if (correct)
		}
		else 
		{
			cout<<"ERROR checkTripP_checkSolution("<<idVeh<<", "<<idTrip<<"): endS : correct = "<<endS<<"; wrong = "<<seg[idVeh].Trip[idTrip].endS<<endl;
			correct = 0;
		}
		return correct;
}

bool Solution::checkTripD_ALLFIELDS(int idVeh, int idTrip) //just checking field of trip; for both FEASIBLE and INFEASIBLE TRIP
{
	bool correct = 1;
	double cTemp = 0; 
	int assSP = seg[idVeh].Trip[idTrip].assSP;
	double leaveSPT, vioTWSPT, cArrTime,temp;
	int i;

	if (idTrip == 0)
	{
		if (PDSDIF(seg[idVeh].Trip[0].leaveSP, problem->leaveSP[seg[idVeh].Trip[0].assSP][4]))
		{
				cout<<"ERROR checkTripD_ALLFIELDS("<<idVeh<<", "<<idTrip<<") LeaveSP: correct = "<<problem->leaveSP[seg[idVeh].Trip[0].assSP][4]<<"; wrong = "<<seg[idVeh].Trip[0].leaveSP<<endl;
				correct = 0;
		}
		if (seg[idVeh].Trip[idTrip].coordinate==1)
		{
				 cout<<"ERROR checkTripD_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): correct = NOT coordinate, but coordinate field = "<<seg[idVeh].Trip[idTrip].coordinate<<endl;
				 correct = 0;
		}			 

		cTemp += problem->c[0][assSP];
	}
	else
	{
		 int preT = idTrip - 1; 
		 if (seg[idVeh].Trip[preT].Type)
		 {
			 int lastCpreT = seg[idVeh].Trip[preT].lastCus;
			 if (seg[idVeh].Trip[preT].waitingS == NO_WS)
	 			cArrTime = depart[lastCpreT] + problem->c[lastCpreT][assSP];
			 else cArrTime = depart[lastCpreT] + problem->disCWSSP[lastCpreT][assSP];
			 temp = cArrTime - problem->nodeSP[assSP].eTW2;
			 if (temp > eps) 
			 {
				 vioTWSPT = temp;
				 leaveSPT = problem->nodeSP[assSP].eTW2 + problem->nodeSP[assSP].load;
			 }
			 else
			 {
				 leaveSPT = PDS_MAX(cArrTime, problem->nodeSP[assSP].sTW2) + problem->nodeSP[assSP].load;
				 vioTWSPT = 0;
			 }
			 if (seg[idVeh].Trip[idTrip].coordinate==1)
			 {
				 cout<<"ERROR: checkTripD_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): correct =  NOT coordinate, but field coordinate = "<<seg[idVeh].Trip[idTrip].coordinate<<endl;
				 correct = 0;
			 }			 
		 }
		 else
		 {
			 int assSPpreT = seg[idVeh].Trip[preT].assSP;
			 if (assSPpreT == assSP) cArrTime = seg[idVeh].Trip[preT].leaveSP;
			 else
			 {
				 if (seg[idVeh].Trip[preT].waitingS1 == NO_WS)
	 				cArrTime = seg[idVeh].Trip[preT].leaveSP + problem->c[assSPpreT][assSP];
				 else cArrTime = seg[idVeh].Trip[preT].leaveSP + problem->disCWSSP[assSPpreT][assSP];
			 }
			 temp = cArrTime - problem->nodeSP[assSP].eTW2;
			 if (temp > eps)
			 {
				 vioTWSPT = temp;
				 leaveSPT = problem->nodeSP[assSP].eTW2 + problem->nodeSP[assSP].load;
			 }
			 else
			 {
				 leaveSPT = PDS_MAX(cArrTime, problem->nodeSP[assSP].sTW2) + problem->nodeSP[assSP].load;
				 vioTWSPT = 0;
			 }
			 if (seg[idVeh].Trip[idTrip].coordinate==0)
			 {
				 cout<<"ERROR: checkTripD_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): correct = coordinate, but field coordinate = "<<seg[idVeh].Trip[idTrip].coordinate<<endl;
				 correct = 0;
			 }			 
		 }
		 if (PDSDIF(leaveSPT, seg[idVeh].Trip[idTrip].leaveSP))
		 {
			cout<<"ERRROR checkTripD_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): leaveSP at sp "<<assSP<<": correct = "<<leaveSPT<<"; wrong = "<<seg[idVeh].Trip[idTrip].leaveSP<<endl;
			correct = 0;
		 }
		 if (PDSDIF(vioTWSPT, seg[idVeh].Trip[idTrip].vioTWSP))
		 {
			 cout<<"ERRROR checkTripD_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): vioTWSP at sp "<<assSP<<": correct = "<<temp<<";Field vioTWSP = "<<seg[idVeh].Trip[idTrip].vioTWSP<<endl;
			 correct = 0;
		}
	}
	if (correct)
	{
		int preC  = assSP;
		int curC = seg[idVeh].Trip[idTrip].firstCus;
		double endS = seg[idVeh].Trip[idTrip].leaveSP;
		int CAPT = 0; double vioTWCT;

		for (i=1;i <= seg[idVeh].Trip[idTrip].numCus;i++)
		{
			CAPT += problem->node[curC].capacity; 
			cTemp += problem->c[preC][curC];
			endS += problem->c[preC][curC];
			vioTWCT = PDS_MAX(endS - problem->node[curC].eTW, 0);
			if (PDSDIF(vioTWCT, vioTWCus[curC])) 
			{
				correct = 0;
				cout<<"ERROR checkTripD_ALLFIELDS("<<idVeh<<", "<<idTrip<<") vioTWCus["<<curC<<"]: correct = "<<vioTWCT<<"; field vioTWCus wrong = "<<vioTWCus[curC]<<endl;
			}
			if (vioTWCT > eps)
				endS = problem->node[curC].eTW;
			else endS = PDS_MAX(endS, problem->node[curC].sTW);
			if (PDSDIF(endS, startS[curC]))
			{
				correct = 0;
				cout<<"ERROR checkTripD_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): startS["<<curC<<"]: correct = "<<endS<<"; field startS wrong = "<<startS[curC]<<endl;
			}
			
			endS += problem->node[curC].duration;
			if (PDSDIF(endS, depart[curC]))
			{
				correct = 0;
				cout<<"ERROR checkTripD_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): depart["<<curC<<"]: correct = "<<endS<<"; field depart wrong = "<<depart[curC]<<endl;
			}
			preC = curC; curC = nextArr[curC];
		}

		if (CAPT != seg[idVeh].Trip[idTrip].capacity)
		{
			cout<<"ERROR checkTripD_ALLFIELDS("<<idVeh<<", "<<idTrip<<") CAP of trip: correct = "<<CAPT<<"; wrong = "<<seg[idVeh].Trip[idTrip].capacity<<endl;
			correct = 0;
		}
		else
		{
			int vioCAPT = PDS_MAX(CAPT - problem->Q, 0);
			if (vioCAPT != seg[idVeh].Trip[idTrip].vioCAP)
			{
				correct = 0;
				cout<<"ERROR checkTripD_ALLFIELDS("<<idVeh<<", "<<idTrip<<") vioCAP: wrong = "<<seg[idVeh].Trip[idTrip].vioCAP<<"; correct = "<<vioCAPT<<endl;
			}
		}

		double costBetweenCusOnly = seg[idVeh].Trip[idTrip].cost - seg[idVeh].Trip[idTrip].connectCost;
		if (PDSDIF(costBetweenCusOnly, cTemp))
		{
			correct = 1;
			cout<<"ERROR checkTripD_ALLFIELDS("<<idVeh<<", "<<idTrip<<") total cost between customers only: wrong = "<<costBetweenCusOnly<<"; correct = "<<cTemp<<endl;
		    cout<<"Field ConnectCost = "<<seg[idVeh].Trip[idTrip].connectCost<<endl;
		}

		if (PDSDIF(seg[idVeh].Trip[idTrip].endS, endS)==0)
		{
				int nextTrip = idTrip + 1;
				if (nextTrip < seg[idVeh].numTrips) // not last Trip
				{
					if (seg[idVeh].Trip[nextTrip].Type ==0) //next trip is pickup trip:
					{
						 cTemp += problem->c[preC][seg[idVeh].Trip[nextTrip].firstCus];
						 if (PDSDIF(problem->c[preC][seg[idVeh].Trip[nextTrip].firstCus],seg[idVeh].Trip[idTrip].connectCost))
						 {
							 cout<<"ERROR checkTripD_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): Connectcost: correct = "<<problem->c[preC][seg[idVeh].Trip[nextTrip].firstCus]<<"; error = "<<seg[idVeh].Trip[idTrip].connectCost<<endl;
							 cout<<"CASE: "<<assSP<<" - DELIVERY TRIP - PICKUP TRIP"<<endl;
							 correct = 0;
						 }
					 	 if (seg[idVeh].Trip[idTrip].waitingS != NO_WS)
						 {
							 cout<<"ERROR checkTripD_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): Waiting station: correct = noWS"<<"; wrong = "<<seg[idVeh].Trip[idTrip].waitingS<<endl;
							 cout<<"CASE: "<<assSP<<" - DELIVERY TRIP - PICKUP TRIP"<<endl;
							 correct = 0;
						}
					}
					else //next trip is delivery trip:
					{
						 int endSP = seg[idVeh].Trip[nextTrip].assSP;
						 double cArrTime = endS + problem->c[preC][endSP];
						 if (PDSINRANGE(cArrTime, problem->nodeSP[endSP].sTW2, problem->nodeSP[endSP].eTW2))
						 {
							 cTemp +=  problem->c[preC][endSP];

							 if (PDSDIF(problem->c[preC][endSP],seg[idVeh].Trip[idTrip].connectCost))
							 {
								 cout<<"ERROR checkTripD_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): Connectcost : correct = "<<problem->c[preC][endSP]<<"; error = "<<seg[idVeh].Trip[idTrip].connectCost<<endl;
								 cout<<"CASE: "<<assSP<<" - DELIVERY TRIP - sp = "<<(endSP)<<" - DELIVERY TRIP"<<endl;
								 correct = 0;
							 }
							 if (seg[idVeh].Trip[idTrip].waitingS != NO_WS)
							 {
								 cout<<"ERROR checkTripD_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): Waiting station: correct = noWS"<<"; wrong = "<<seg[idVeh].Trip[idTrip].waitingS<<endl;
								 cout<<"CASE: "<<assSP<<" - DELIVERY TRIP - sp = "<<(endSP)<<" - DELIVERY TRIP"<<endl;
								 correct = 0;
							 }
							 if (seg[idVeh].Trip[nextTrip].vioTWSP > eps)
							 {
								 cout<<"ERROR checkTripD_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): vioTWSP : correct = 0; wrong = "<<seg[idVeh].Trip[nextTrip].vioTWSP<<endl;
								 cout<<"CASE: "<<assSP<<" - DELIVERY TRIP - sp = "<<(endSP)<<" - DELIVERY TRIP"<<endl;
								 correct = 0;
							 }
						 }
						 else
						 {
							  temp = cArrTime - problem->nodeSP[endSP].eTW2;
							  if (temp > eps)
							  {
								  if (PDSDIF(problem->c[preC][endSP],seg[idVeh].Trip[idTrip].connectCost))
								  {
									 cout<<"ERROR checkTripD_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): Connectcost : correct = "<<problem->c[preC][endSP]<<"; error = "<<seg[idVeh].Trip[idTrip].connectCost<<endl;
									 cout<<"CASE: "<<assSP<<" - DELIVERY TRIP - sp = "<<(endSP)<<" - DELIVERY TRIP; exceed eTW2"<<endl;
									 correct = 0;
								  }
								  if (seg[idVeh].Trip[idTrip].waitingS != NO_WS)
								  {
									 cout<<"ERROR checkTripD_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): Waiting station: correct = noWS"<<"; wrong = "<<seg[idVeh].Trip[idTrip].waitingS<<endl;
									 cout<<"CASE: "<<assSP<<" - DELIVERY TRIP - sp = "<<(endSP)<<" - DELIVERY TRIP; exceed eTW2"<<endl;
									 correct = 0;
								  }

								  if (PDSDIF(temp, seg[idVeh].Trip[nextTrip].vioTWSP))
								  {
									  cout<<"ERROR checkTripD_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): vioTWSP : correct = "<<temp<<"; wrong = "<<seg[idVeh].Trip[nextTrip].vioTWSP<<endl;
									  cout<<"CASE: "<<assSP<<" - DELIVERY TRIP - sp = "<<(endSP)<<" - DELIVERY TRIP; exceed eTW2"<<endl;
									  correct = 0;
								  }
	  							  cTemp +=  problem->c[preC][endSP];
							  }
							  else
							  {
								  double cArrTimeI = endS + problem->disCWSSP[preC][endSP];
								  temp = cArrTimeI - problem->nodeSP[endSP].eTW2;
								  if (temp > eps)
								  {
									  if (PDSDIF(problem->c[preC][endSP],seg[idVeh].Trip[idTrip].connectCost))
									  {
										 cout<<"ERROR checkTripD_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): Connectcost : correct = "<<problem->c[preC][endSP]<<"; error = "<<seg[idVeh].Trip[idTrip].connectCost<<endl;
										 cout<<"CASE: "<<assSP<<" - DELIVERY TRIP - sp = "<<(endSP)<<" - DELIVERY TRIP; too soon to sp directly; too late through WS"<<endl;
										 correct = 0;
									  }
									  if (seg[idVeh].Trip[idTrip].waitingS != NO_WS)
									  {
										 cout<<"ERROR checkTripD_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): Waiting station: correct = noWS"<<"; wrong = "<<seg[idVeh].Trip[idTrip].waitingS<<endl;
										 cout<<"CASE: "<<assSP<<" - DELIVERY TRIP - sp = "<<(endSP)<<" - DELIVERY TRIP; too soon to sp directly; too late through WS"<<endl;
										 correct = 0;
									  }

									  temp = problem->nodeSP[endSP].sTW2 - cArrTime;

									  if (PDSDIF(temp, seg[idVeh].Trip[nextTrip].vioTWSP))
									  {
										  cout<<"ERROR checkTripD_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): vioTWSP : correct = "<<temp<<"; wrong = "<<seg[idVeh].Trip[nextTrip].vioTWSP<<endl;
										 cout<<"CASE: "<<assSP<<" - DELIVERY TRIP - sp = "<<(endSP)<<" - DELIVERY TRIP; too soon to sp directly; too late through WS"<<endl;
										  correct = 0;
									  }
	  								  cTemp +=  problem->c[preC][endSP];
								  }
								  else //through WS:
								  {
									  if (PDSDIF(problem->disCWSSP[preC][endSP],seg[idVeh].Trip[idTrip].connectCost))
									  {
										 cout<<"ERROR checkTripD_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): Connectcost : correct = "<<problem->disCWSSP[preC][endSP]<<"; error = "<<seg[idVeh].Trip[idTrip].connectCost<<endl;
										 cout<<"CASE: "<<assSP<<" - DELIVERY TRIP - sp = "<<(endSP)<<" - DELIVERY TRIP; through WS"<<endl;
										 correct = 0;
									  }
									  if (seg[idVeh].Trip[idTrip].waitingS != problem->CWSSP[preC][endSP])
									  {
										  cout<<"ERROR checkTripD_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): Waiting station: correct = "<<problem->CWSSP[preC][endSP]<<"; wrong = "<<seg[idVeh].Trip[idTrip].waitingS<<endl;
										  cout<<"CASE: "<<assSP<<" - DELIVERY TRIP - sp = "<<(endSP)<<" - DELIVERY TRIP; through WS"<<endl;
										  correct = 0;
									  }

									  if (seg[idVeh].Trip[nextTrip].vioTWSP > eps)
									  {
										  cout<<"ERROR checkTripD_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): vioTWSP : correct = 0; wrong = "<<seg[idVeh].Trip[nextTrip].vioTWSP<<endl;
										  cout<<"CASE: "<<assSP<<" - DELIVERY TRIP - sp = "<<(endSP)<<" - DELIVERY TRIP; through WS"<<endl;
										  correct = 0;
									  }
									  cTemp += problem->disCWSSP[preC][endSP];
								  }//end through WS
							  }
						 }
					}

				}
				else //the lastTrip
				{
					if (PDSDIF(seg[idVeh].Trip[idTrip].connectCost, problem->c[preC][0]))
					{
						cout<<"ERROR checkTripD_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): connectCost of the last delivery Trip: correct = "<<problem->c[preC][0]<<"; wrong = "<<seg[idVeh].Trip[idTrip].connectCost<<endl;
						correct = 0;
					}
					cTemp += problem->c[preC][0];
				}//end the lastTrip
				if (PDSDIF(cTemp,seg[idVeh].Trip[idTrip].cost))
				{
					 cout<<"ERROR checkTripD_ALLFIELDS("<<idVeh<<", "<<idTrip<<") cost: correct = "<<cTemp<<"; error = "<<seg[idVeh].Trip[idTrip].cost<<endl;
					 correct = 0;
				}
		}
		else 
		{
			cout<<"ERROR checkTripD_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): endS: correct = "<<endS<<"; wrong = "<<seg[idVeh].Trip[idTrip].endS<<endl;
			correct = 0;
		}
	}
	return correct;
	//if (correct == 0) exit(-1);

}

bool Solution::checkTripP_ALLFIELDS(int idVeh, int idTrip) //just checking field of trip; for both FEASIBLE and INFEASIBLE TRIP
{
	bool correct = 1;
	double cTemp = 0; 

	int assSP = seg[idVeh].Trip[idTrip].assSP;
	int preC = seg[idVeh].Trip[idTrip].firstCus;
	int curC, i;
	double endS, cArrTime, cArrTimeI, temp;
	curC = seg[idVeh].Trip[idTrip].firstCus;

	if (idTrip == 0)
	{
		endS = 0;
		preC = 0;
	}
	else
	{
		int preT = idTrip - 1;
		if (seg[idVeh].Trip[preT].Type)
		{
			preC = seg[idVeh].Trip[preT].lastCus;
			endS = depart[preC];
		}
		else
		{
			preC = seg[idVeh].Trip[preT].assSP;
			endS = seg[idVeh].Trip[preT].leaveSP;
		}
		cTemp =-problem->c[preC][curC];

	}

	int CAPT = 0; double vioTWCT;
	for (i=1;i<=seg[idVeh].Trip[idTrip].numCus;i++)
	{
			CAPT += problem->node[curC].capacity; 
			cTemp += problem->c[preC][curC];
			endS += problem->c[preC][curC];
			vioTWCT = PDS_MAX(endS - problem->node[curC].eTW, 0);
			if (PDSDIF(vioTWCT, vioTWCus[curC])) 
			{
				correct = 0;
				cout<<"ERROR checkTripP_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): vioTWCus["<<curC<<"]: wrong = "<<vioTWCus[curC]<<"; correct = "<<vioTWCT<<endl;
			}
			if (vioTWCT > eps)
				endS = problem->node[curC].eTW;
			else endS = PDS_MAX(endS, problem->node[curC].sTW);

			if (PDSDIF(endS, startS[curC]))
			{
				correct = 0;
				cout<<"ERROR checkTripP_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): startS["<<curC<<"]: wrong = "<<startS[curC]<<"; correct = "<<endS<<endl;
			}
			
			endS += problem->node[curC].duration;
			if (PDSDIF(endS, depart[curC]))
			{
				correct = 0;
				cout<<"ERROR checkTripP_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): depart["<<curC<<"]: wrong = "<<depart[curC]<<"; correct = "<<endS<<endl;
			}
			preC = curC; curC = nextArr[curC];
	}

	if (CAPT != seg[idVeh].Trip[idTrip].capacity)
	{
		cout<<"ERROR checkTripP_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): cap of trip: correct = "<<CAPT<<"; wrong = "<<seg[idVeh].Trip[idTrip].capacity<<endl;
		correct = 0;
	}
	else
	{
		int vioCAPT = PDS_MAX(CAPT - problem->Q, 0);
		if (vioCAPT != seg[idVeh].Trip[idTrip].vioCAP)
		{
			correct = 0;
			cout<<"ERROR checkTripP_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): vioCAP: wrong = "<<seg[idVeh].Trip[idTrip].vioCAP<<"; correct = "<<vioCAPT<<endl;
		}
	}

		if (PDSDIF(seg[idVeh].Trip[idTrip].endS, endS)==0)
		{
			cArrTime = endS + problem->c[preC][assSP];
			if (PDSINRANGE(cArrTime, problem->nodeSP[assSP].sTW1, problem->nodeSP[assSP].eTW1))
			{
				cTemp += problem->c[preC][assSP];
				if (seg[idVeh].Trip[idTrip].waitingS != NO_WS)
				{
					cout<<"ERROR checkTripP_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): correct waitingS = NO_WS; wrong = "<<seg[idVeh].Trip[idTrip].waitingS<<endl;
					correct = 0;
				}
				if (seg[idVeh].Trip[idTrip].vioTWSP > eps)
				{
					cout<<"ERROR checkTripP_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): correct vioTWSP = 0; wrong = "<<seg[idVeh].Trip[idTrip].vioTWSP<<endl;
					correct = 0;
				}
				endS = cArrTime + problem->nodeSP[assSP].unload;
			}
			else
			{
				temp = cArrTime - problem->nodeSP[assSP].eTW1;
				if (temp > eps)
				{
					if (seg[idVeh].Trip[idTrip].waitingS != NO_WS)
					{
						cout<<"ERROR checkTripP_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): correct waitingS = NO_WS; wrong = "<<seg[idVeh].Trip[idTrip].waitingS<<endl;
						correct = 0;
					}
					if (PDSDIF(temp, seg[idVeh].Trip[idTrip].vioTWSP))
					{
						cout<<"ERROR checkTripP_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): correct vioTWSP = "<<temp<<"; wrong = "<<seg[idVeh].Trip[idTrip].vioTWSP<<endl;
						cout<<"CASE exceed eTW1 of sp "<<assSP<<"; eTW1 = "<<problem->nodeSP[assSP].eTW1<<"; cArrTime = "<<cArrTime<<endl;
						correct = 0;
					}
					endS = problem->leaveSP[assSP][0]; //unload at eTW1
				}
				else
				{
					double cArrTimeI = endS + problem->disCWSSP[preC][assSP];
					temp = cArrTimeI - problem->nodeSP[assSP].eTW1;
					if (temp > eps)
					{
						temp = cArrTime - problem->nodeSP[assSP].sTW1;
						if (PDSDIF(temp, seg[idVeh].Trip[idTrip].vioTWSP))
						{
							cout<<"ERROR checkTripP_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): correct vioTWSP = "<<temp<<"; wrong = "<<seg[idVeh].Trip[idTrip].vioTWSP<<endl;
							cout<<"CASE too soon to go sp directly, too late to go through WS; eTW1 of sp "<<assSP<<"; eTW1 = "<<problem->nodeSP[assSP].eTW1<<"; cArrTimeDirect = "<<cArrTime<<"; cArrTimeIndirect = "<<cArrTimeI<<endl;
							correct = 0;
						}
						if (seg[idVeh].Trip[idTrip].waitingS != NO_WS)
						{
							cout<<"ERROR checkTripP_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): correct waitingS = NO_WS; wrong = "<<seg[idVeh].Trip[idTrip].waitingS<<endl;
							cout<<"CASE too soon to go sp directly, too late to go through WS; eTW1 of sp "<<assSP<<"; eTW1 = "<<problem->nodeSP[assSP].eTW1<<"; cArrTimeDirect = "<<cArrTime<<"; cArrTimeIndirect = "<<cArrTimeI<<endl;
							correct = 0;
						}
						endS = problem->leaveSP[assSP][0]; //unload at eTW1
					}
					else
					{
						cTemp += problem->disCWSSP[preC][assSP];
						if (seg[idVeh].Trip[idTrip].waitingS != problem->CWSSP[preC][assSP])
						{
							cout<<"ERROR checkTripP_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): correct waitingS = "<<problem->CWSSP[preC][assSP]<<"; wrong = "<<seg[idVeh].Trip[idTrip].waitingS<<endl;
							cout<<"LastCus of trip = "<<preC<<" !=? "<<seg[idVeh].Trip[idTrip].lastCus<<endl;
							cout<<"CASE to go through WS"<<endl;
							correct = 0;
						}
						if (seg[idVeh].Trip[idTrip].vioTWSP > eps)
						{
							cout<<"ERROR checkTripP_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): correct vioTWSP = 0; wrong = "<<seg[idVeh].Trip[idTrip].vioTWSP<<endl;
							cout<<"CASE to go through WS"<<endl;
							correct = 0;
						}
						endS = PDS_MAX(cArrTimeI, problem->nodeSP[assSP].sTW1) + problem->nodeSP[assSP].unload;
					}
				}
			}
			if (correct)
			{
				double costT = seg[idVeh].Trip[idTrip].cost - seg[idVeh].Trip[idTrip].connectCost;
				if (PDSDIF(cTemp, costT))
				{
					cout<<"ERROR checkTripP_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): cost (between cus and SP, exclude connectCost): correct = "<<cTemp<<"; wrong = "<<costT<<endl;
					correct = 0;
				}
				else
				{
					int lastT = seg[idVeh].numTrips - 1;
					if (idTrip == lastT)
					{
						if (PDSDIF(problem->c[assSP][0], seg[idVeh].Trip[idTrip].connectCost))
						{
							cout<<"ERROR checkTripP_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): Connectcost: correct = "<<problem->c[assSP][0]<<"; wrong = "<<seg[idVeh].Trip[idTrip].connectCost<<endl;
							cout<<"CASE: last pickup trip"<<endl;
							correct = 0;
						}
						if (seg[idVeh].Trip[idTrip].waitingS1 != NO_WS)
						{
							cout<<"ERROR checkTripP_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): waitingS1: correct = NO_WS; wrong = "<<seg[idVeh].Trip[idTrip].waitingS1<<endl;
							cout<<"CASE: last pickup trip"<<endl;
							correct = 0;
						}
						cTemp += problem->c[assSP][0];
					}
					else //not lastTrip
					{
						int nextT = idTrip + 1;
						if (seg[idVeh].Trip[nextT].Type)
						{
							int assSP1 = seg[idVeh].Trip[nextT].assSP;
							if (assSP1 == assSP)
							{
								if (seg[idVeh].Trip[idTrip].connectCost > eps)
								{
									cout<<"ERROR checkTripP_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): Connectcost : correct = 0; wrong = "<<seg[idVeh].Trip[idTrip].connectCost<<endl;
									cout<<"CASE: p - d: sameSP"<<endl;
									correct = 0;
								}
								if (seg[idVeh].Trip[idTrip].waitingS1 != NO_WS)
								{
									cout<<"ERROR checkTripP_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): waitingS1: correct = NO_WS; wrong = "<<seg[idVeh].Trip[idTrip].waitingS1<<endl;
									cout<<"CASE: p - d: sameSP"<<endl;
									correct = 0;
								}
								if (seg[idVeh].Trip[nextT].vioTWSP > eps)
								{
									cout<<"ERROR checkTripP_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): wrong vioTWSP of nextDelivery trip: correct = 0; wrong = "<<seg[idVeh].Trip[nextT].vioTWSP<<endl;
									cout<<"CASE: p - d: sameSP"<<endl;
									correct = 0;
								}
							}
							else
							{
								cArrTime = endS + problem->c[assSP][assSP1];
								if (PDSINRANGE(cArrTime, problem->nodeSP[assSP1].sTW2, problem->nodeSP[assSP1].eTW2))
								{
									cTemp += problem->c[assSP][assSP1];
									if (seg[idVeh].Trip[idTrip].waitingS1 != NO_WS)
									{
										cout<<"ERROR checkTripP_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): correct waitingS1 = NO_WS; wrong = "<<seg[idVeh].Trip[idTrip].waitingS1<<endl;
										cout<<"CASE: p - d: difSP"<<endl;
										correct = 0;
									}
									if (PDSDIF(seg[idVeh].Trip[idTrip].connectCost,problem->c[assSP][assSP1]))
									{
										cout<<"ERROR checkTripP_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): correct = "<<problem->c[assSP][assSP1]<<"; wrong = "<<seg[idVeh].Trip[idTrip].connectCost<<endl;
										cout<<"CASE: p - d: difSP"<<endl;
										correct = 0;
									}
									if (seg[idVeh].Trip[nextT].vioTWSP > eps)
									{
										cout<<"ERROR checkTripP_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): wrong vioTWSP of nextDelivery trip: correct = 0; wrong = "<<seg[idVeh].Trip[nextT].vioTWSP<<endl;
										cout<<"CASE: p - d: difSP"<<endl;
										correct = 0;
									}
								}
								else
								{
									temp = cArrTime - problem->nodeSP[assSP1].eTW2;
									if (temp > eps)
									{
										  cTemp += problem->c[assSP][assSP1];
										  if (seg[idVeh].Trip[idTrip].waitingS1 != NO_WS)
										  {
												cout<<"ERROR checkTripP_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): correct waitingS1 = NO_WS; wrong = "<<seg[idVeh].Trip[idTrip].waitingS1<<endl;
												cout<<"CASE: p - d: difSP; exceed eTW2 of sp"<<endl;
												correct = 0;
										  }
										  if (PDSDIF(seg[idVeh].Trip[idTrip].connectCost,problem->c[assSP][assSP1]))
										  {
												cout<<"ERROR checkTripP_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): correct = "<<problem->c[assSP][assSP1]<<"; wrong = "<<seg[idVeh].Trip[idTrip].connectCost<<endl;
												cout<<"CASE: p - d: difSP; exceed eTW2 of sp"<<endl;
												correct = 0;
										  }
										  if (PDSDIF(temp, seg[idVeh].Trip[nextT].vioTWSP))
										  {
											cout<<"ERROR checkTripP_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): wrong vioTWSP of nextDelivery trip: correct = "<<temp<<"; wrong = "<<seg[idVeh].Trip[nextT].vioTWSP<<endl;
											cout<<"CASE: p - d: difSP; exceed eTW2 of sp"<<endl;
											correct = 0;
										  }
									}
									else
									{
										cArrTimeI = endS + problem->disCWSSP[assSP][assSP1];
										temp = cArrTimeI - problem->nodeSP[assSP1].eTW2;
										if (temp > eps)
										{
											  cTemp += problem->c[assSP][assSP1];
											  temp = problem->nodeSP[assSP1].sTW2 - cArrTimeI;
											  if (seg[idVeh].Trip[idTrip].waitingS1 != NO_WS)
											  {
													cout<<"ERROR checkTripP_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): correct waitingS1 = NO_WS; wrong = "<<seg[idVeh].Trip[idTrip].waitingS1<<endl;
													cout<<"CASE: p - d: difSP; too soon to sp directly; too late through WS"<<endl;
													correct = 0;
											  }
											  if (PDSDIF(seg[idVeh].Trip[idTrip].connectCost,problem->c[assSP][assSP1]))
											  {
													cout<<"ERROR checkTripP_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): correct = "<<problem->c[assSP][assSP1]<<"; wrong = "<<seg[idVeh].Trip[idTrip].connectCost<<endl;
													cout<<"CASE: p - d: difSP; too soon to sp directly; too late through WS"<<endl;
													correct = 0;
											  }
											  if (PDSDIF(temp, seg[idVeh].Trip[nextT].vioTWSP))
											  {
												cout<<"ERROR checkTripP_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): wrong vioTWSP of nextDelivery trip: correct = "<<temp<<"; wrong = "<<seg[idVeh].Trip[nextT].vioTWSP<<endl;
												cout<<"CASE: p - d: difSP; too soon to sp directly; too late through WS"<<endl;
												correct = 0;
											  }
										}
										else
										{
											cTemp += problem->disCWSSP[assSP][assSP1];
											if (seg[idVeh].Trip[idTrip].waitingS1 != problem->CWSSP[assSP][assSP1])
											{
												cout<<"ERROR checkTripP_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): correct waitingS1 = "<<problem->CWSSP[assSP][assSP1]<<"; wrong = "<<seg[idVeh].Trip[idTrip].waitingS1<<endl;
												cout<<"CASE: p - d: difSP; through WS"<<endl;
												correct = 0;
											}
											if (PDSDIF(seg[idVeh].Trip[idTrip].connectCost,problem->disCWSSP[assSP][assSP1]))
											{
												cout<<"ERROR checkTripP_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): correct = "<<problem->disCWSSP[assSP][assSP1]<<"; wrong = "<<seg[idVeh].Trip[idTrip].connectCost<<endl;
												cout<<"CASE: p - d: difSP; through WS"<<endl;
												correct = 0;
											}
											if (seg[idVeh].Trip[nextT].vioTWSP > eps)
										    {
											    cout<<"ERROR checkTripP_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): wrong vioTWSP of nextDelivery trip: correct = 0; wrong = "<<seg[idVeh].Trip[nextT].vioTWSP<<endl;
											    cout<<"CASE: p - d: difSP; through WS"<<endl;
											    correct = 0;
										    }
										}
									}
								}
							}
						}
						else //nextTrip is pickup trip
						{
							if (PDSDIF(problem->c[assSP][seg[idVeh].Trip[nextT].firstCus],seg[idVeh].Trip[idTrip].connectCost))
							{
								cout<<"ERROR checkTripP_ALLFIELDS("<<idVeh<<", "<<idTrip<<"):ConnectCost correct = "<<problem->c[assSP][seg[idVeh].Trip[nextT].firstCus]<<"; wrong = "<<seg[idVeh].Trip[idTrip].connectCost<<endl;
								cout<<"CASE: p - p"<<endl;
								correct = 0;
							}
							cTemp += problem->c[assSP][seg[idVeh].Trip[nextT].firstCus];
						}
						if (PDSDIF(cTemp, seg[idVeh].Trip[idTrip].cost))
						{
							cout<<"ERROR checkTripP_ALLFIELDS("<<idVeh<<", "<<idTrip<<"):cost correct = "<<cTemp<<"; wrong = "<<seg[idVeh].Trip[idTrip].cost<<endl;
							correct = 0;
						}
					}//end not lastTrip
				}//end not wrong on cost between customers and sp (exclude connectCost)
			}//end if (correct)
		}
		else 
		{
			cout<<"ERROR checkTripP_ALLFIELDS("<<idVeh<<", "<<idTrip<<"): endS : correct = "<<endS<<"; wrong = "<<seg[idVeh].Trip[idTrip].endS<<endl;
			correct = 0;
		}
		return correct;
		//if (correct == 0) exit(-1);
}

/******************************************************* CONSTRUCTOR *****************************************/
Problem* Solution::problem=0 ;

Solution::Solution()
{

}

/*
 * Initiate and compute temporary matrices
 * QuangNN++ specific for MTT-PDTWS with ALNS
 */
void Solution::init_Q(Problem *p){

	int i;

	//Save minimum numlegs required for each supply point; =up(capSP/Q)
	for (i = 0; i <= PDS_MAX_NUM_SUPPLYPOINTS; i++){
		minTripSP[i] = p->minTripSP[i];
	}
	//Save minimum numTrips required to serve all pickup customer; = up(TOTALCAPPICKUPCUSTOMERS/Q)
	minTripCusP = p->minTripCusP;

	//TODO: Update later
}
/*
 * QuangNN++ specific for MTT-PDTWS with ALNS
 */
Solution::Solution(Problem* p, int flag)
{
	problem = p;
	nP=problem->nP; nD=problem->nD; nSP = problem->nSP; nWS = problem->nWS;
	nOrder = problem->nOrder;


	nextArr = new int [endidD+1]; 
	//predArr = new int [totalNODE1];
	//pos = new int [totalNODE1]; 

	for (int i=startidP; i<= endidD;i++) nextArr[i]=0;

	//route_num = new int [totalNODE1]; trip_num = new int[totalNODE1];

	routed = new bool[endidD+1];
	//BCAP = new int[totalNODE1]; FCAP = new int [totalNODE1];

	//vioTWCus = new double [totalNODE1]; 
	//FvioTWCus = new double [totalNODE1];
	//BvioTWCus = new double [totalNODE1];

	for (int i=1; i <= endidD; i++) 
	{
		routed[i]=false; 
		//FCAP[i]=0; BCAP[i]=0; 
		//vioTWCus[i] = 0; FvioTWCus[i]=0; BvioTWCus[i] = 0;
	}

	startS = new double [totalNODE1]; 
	depart = new double [totalNODE1];

	//numTripPSP = new int[nSP1]; numTripDSP = new int[nSP1];

	numCusPRouted = new int [nSP1];
	int TT = nSP + nP + 1 + 2*nOrder;
	SPToCusP = new int [TT]; //SPOFCusPToSP[idCus] = idsp that is assigned to
	numCusPSP = new int[nSP1]; // number of cusP in each supply point
	CusPSP = new int*[nSP1]; // CusPSP[sp][j] = id of customerP #j assigned to sp; j = 1,..,numCusPSP[sp] 

	numCusDRouted = new int[nSP1];
	for (int i=1; i<=nSP; i++) 
	{
		numCusDRouted[i]=0;
		//numTripDSP[i]=0;numTripPSP[i]=0;
		numCusPRouted[i] = 0;
		CusPSP[i] = new int[MAX_NUM_CUSP_ASSIGNSP]; //define in VRPNodeP.h = 500
	}

	////seg = new VRPSegment[MAX_VEH];
	////seg = new VRPSegment[problem->maxVeh+1];

	numVeh=0; numVehUsed=0;
	cost = 0.0; fitness = 0.0;
	vioCAP=0; vioTWC=0; vioTWSP=0; feasible=1;
	numTrips=0;
}

void Solution::init(Problem *p)
{
  problem = p;
  nP=problem->nP; nD=problem->nD; nSP = problem->nSP; nWS = problem->nWS;
  nextArr = new int [totalNODE1]; predArr = new int [totalNODE1];
  pos = new int [totalNODE1]; 

  for (int i=startidP; i<= endidD;i++) nextArr[i]=0;
 
  route_num = new int [totalNODE1]; trip_num = new int[totalNODE1];
  
  routed = new bool[totalNODE1];
  BCAP = new int[totalNODE1]; FCAP = new int [totalNODE1];
 
  vioTWCus = new double [totalNODE1]; 
  FvioTWCus = new double [totalNODE1];
  BvioTWCus = new double [totalNODE1];

  for (int i=1; i <= endidD; i++) 
  {
	  routed[i]=false; 
	  FCAP[i]=0; BCAP[i]=0; 
	  vioTWCus[i] = 0; FvioTWCus[i]=0; BvioTWCus[i] = 0;
  }
  
  startS = new double [totalNODE1]; depart = new double [totalNODE1];

  //arrTime = new double[n+2];

  numTripPSP = new int[nSP1]; numTripDSP = new int[nSP1];
  
  numCusPRouted = new int [nSP1];
  int TT = nSP + nP+1;
  SPToCusP = new int [TT]; //SPOFCusPToSP[idCus] = idsp that is assigned to
  numCusPSP = new int[nSP1]; // number of cusP in each supply point
  CusPSP = new int*[nSP1]; // CusPSP[sp][j] = id of customerP #j assigned to sp; j = 1,..,numCusPSP[sp] 
  
  numCusDRouted = new int[nSP1];
  for (int i=1; i<=nSP; i++) 
  {
	  numCusDRouted[i]=0;numTripDSP[i]=0;numTripPSP[i]=0;
	  numCusPRouted[i] = 0;
	  CusPSP[i] = new int[MAX_NUM_CUSP_ASSIGNSP]; //define in VRPNodeP.h = 500
  }

//  seg = new VRPSegment[MAX_VEH];
  //seg = new VRPSegment[problem->maxVeh+1];
  numVeh=0; numVehUsed=0;
  cost = 0.0; fitness = 0.0;
  vioCAP=0; vioTWC=0; vioTWSP=0; feasible=1;
  numTrips=0;
}

#if CP_PORTING
Solution::Solution(Problem* p)
{
	//ok on 4/12/2013
  problem = p;
  nP=problem->nP; nD=problem->nD; nSP = problem->nSP; nWS = problem->nWS;
  nC2C = problem->nC2C; nOrder = problem->nOrder;
  //cout<<"totalNODE1 = "<<totalNODE1<<endl;
  nextArr = new int [totalNODE1]; predArr = new int [totalNODE1];
  pos = new int [totalNODE1]; 

  route_num = new int [totalNODE1]; trip_num = new int[totalNODE1];
  BCAP = new int[totalNODE1]; FCAP = new int [totalNODE1];
  FvioTWCus = new double [totalNODE1];
  BvioTWCus = new double [totalNODE1];
  vioTWCus = new double [totalNODE1]; 
  startS = new double [totalNODE1]; 
  depart = new double [totalNODE1];
  
  for (int i=0; i < totalNODE1; i++) 
  {
	  nextArr[i] = -1; predArr[i] = -1; pos[i] = -1;
	  route_num[i] = -1; trip_num[i] = -1;
	  FCAP[i]=0; BCAP[i]=0; 
	  vioTWCus[i] = 0; FvioTWCus[i]=0; BvioTWCus[i] = 0;
	  startS[i] = 0; depart[i] = 0;
  }
  

  //numTripPSP = new int[nSP1]; 
  
  numTripDSP = new int[nSP1];
  for (int i=0; i<nSP1; i++) 
	  numTripDSP[i]=0;

  int endIDC2C1 = endidC2C+1;
  vioCAPCus = new int[endIDC2C1];
  //FvioCAPCus = new int[endIDC2C1];BvioCAPCus = new int[endIDC2C1];
  CAPCus = new int[endIDC2C1];

  for (int i = startidC2C; i <= endidC2C; i++)
  {
	  vioCAPCus[i] = 0;
	  //FvioCAPCus[i] = 0;BvioCAPCus[i] = 0;
	  CAPCus[i] = 0;
  }

  //seg = new VRPSegment[MAX_VEH];
  //seg = new VRPSegment[problem->maxVeh+1];
  numVeh=0; numVehUsed=0;
  cost = 0.0; fitness = 0.0;
  vioCAP=0; vioTWC=0; vioTWSP=0; feasible=1;
  numTrips=0;
}
#endif
Solution::Solution(Solution &orig)//copy constructor
{
  //cout<<"call copy constructor"<<endl;
 (*this).nP = orig.nP;(*this).nD = orig.nD;(*this).nSP = orig.nSP;(*this).nWS = orig.nWS;
 (*this).cost = orig.cost; (*this).fitness =  orig.fitness;

  nextArr = new int [totalNODE1];predArr = new int [totalNODE1];
  
  route_num = new int [totalNODE1];trip_num = new int[totalNODE1]; 
  
  routed = new bool[totalNODE1];
  BCAP = new int[totalNODE1]; FCAP = new int [totalNODE1];
 
  startS = new double[totalNODE1]; depart = new double[totalNODE1];
  vioTWCus = new double [totalNODE1];  FvioTWCus = new double [totalNODE1]; BvioTWCus = new double [totalNODE1];

  numCusPRouted = new int [nSP1];
  int TT = nSP + nP + 1;
  SPToCusP = new int [TT]; //SPOFCusPToSP[idCus] = idsp that is assigned to
  numCusPSP = new int[nSP1]; // number of cusP in each supply point
  CusPSP = new int*[nSP1]; // CusPSP[sp][j] = id of customerP #j assigned to sp; j = 1,..,numCusPSP[sp] 

  numCusDRouted = new int[nSP1];
  numTripPSP = new int[nSP1]; numTripDSP = new int[nSP1];

  //Quangnn-
//  for (int i=startidP;i<=endidP;i++) SPToCusP[i] = orig.SPToCusP[i]; //id of sp that customer i is assigned to 

  for (int i=1; i<=nSP; i++)
  {
	  //Quangnn--: 2 lines
	  //numCusDRouted[i]=orig.numCusDRouted[i];
	  //numTripPSP[i] = orig.numTripPSP[i];
	  numTripDSP[i] = orig.numTripDSP[i];

	  //Quangnn--: 2 lines
	  //numCusPRouted[i] = orig.numCusPRouted[i];
	  //numCusPSP[i] = orig.numCusPSP[i];
	  CusPSP[i] = new int[MAX_NUM_CUSP_ASSIGNSP]; //define in VRPNodeP.h = 500
	  for (int j=1;j<=numCusPSP[i];j++){
		  //Quangnn--
		  // CusPSP[i][j] = orig.CusPSP[i][j];
	  }
  }

 
//  seg = new VRPSegment[MAX_VEH];
  numVeh=orig.numVeh;
  numVehUsed = orig.numVehUsed;
  numTrips = orig.numTrips;
  for (int i=0; i<numVeh; i++) (*this).seg[i] = orig.seg[i];
  (*this).vioCAP= orig.vioCAP; (*this).vioTWC= orig.vioTWC; (*this).vioTWSP = orig.vioTWSP;

  for (int i=startidP; i<= endidD; i++)
  {
	  (*this).nextArr[i] = orig.nextArr[i];
	  (*this).predArr[i] = orig.predArr[i];
	  (*this).route_num[i] = orig.route_num[i];
	  (*this).trip_num[i] = orig.trip_num[i];
	  //(*this).routed[i] = orig.routed[i]; //Quangnn--

	  (*this).FCAP[i] = orig.FCAP[i]; (*this).BCAP[i] = orig.BCAP[i];
	  (*this).pos[i] = orig.pos[i];
	  (*this).startS[i] = orig.startS[i];
	  (*this).depart[i] = orig.depart[i];
	  (*this).vioTWCus[i] = orig.vioTWCus[i];
	  (*this).FvioTWCus[i] = orig.FvioTWCus[i];
	  (*this).BvioTWCus[i] = orig.BvioTWCus[i];
  }
}

Solution & Solution::operator = (Solution &orig) //assignment; not copy constructor
{
   // cout<<"Call assignment"<<endl; 
	if (this == &orig) return *this; 
    (*this).nP = orig.nP; (*this).nD = orig.nD;(*this).nSP = orig.nSP;(*this).nWS = orig.nWS;
    (*this).cost=orig.cost; (*this).fitness=orig.fitness;
    (*this).vioCAP= orig.vioCAP; (*this).vioTWC= orig.vioTWC; (*this).vioTWSP = orig.vioTWSP;

	for (int i=startidP;i<= endidP;i++) {
		//Quangnn--
		//SPToCusP[i] = orig.SPToCusP[i]; //id of sp that customer i is assigned to 
	}

	for (int i=1; i<=nSP; i++)
    {
		//Quangnn--: 2 lines
	    //numCusDRouted[i]=orig.numCusDRouted[i];
	    //numTripPSP[i] = orig.numTripPSP[i];
	    numTripDSP[i] = orig.numTripDSP[i];

		//Quangnn--: 3 lines
		//numCusPRouted[i] = orig.numCusPRouted[i];
		//numCusPSP[i] = orig.numCusPSP[i];
	    //for (int j=1;j<=numCusPSP[i];j++) CusPSP[i][j] = orig.CusPSP[i][j];
    }

	(*this).numVeh=orig.numVeh;
    (*this).numVehUsed=orig.numVehUsed;
	(*this).numTrips = orig.numTrips;

    for (int i=0; i<numVeh; i++) (*this).seg[i] = orig.seg[i];
  
    for (int i= startidP; i<= endidD; i++)
    {
	    (*this).nextArr[i] = orig.nextArr[i];
	    (*this).predArr[i] = orig.predArr[i];
	    (*this).route_num[i] = orig.route_num[i];
	    (*this).trip_num[i] = orig.trip_num[i];
	    //(*this).routed[i] = orig.routed[i]; //Quangnn--

	    (*this).FCAP[i] = orig.FCAP[i]; (*this).BCAP[i] = orig.BCAP[i];
	    (*this).pos[i] = orig.pos[i];
	    (*this).startS[i] = orig.startS[i]; (*this).depart[i] = orig.depart[i];
		(*this).vioTWCus[i] = orig.vioTWCus[i];
		(*this).FvioTWCus[i] = orig.FvioTWCus[i];
		(*this).BvioTWCus[i] = orig.BvioTWCus[i];
	}

	 return *this;
}

//Get the pointer to the problem.
Problem* Solution::getProblem( )
{
  return problem;
}

Solution::~Solution() 
{
	//cout<<"Call destroy solution of solution cost = "<<cost<<endl;
	/*delete nextArr;
	delete predArr;
	delete route_num;
	delete leg_num;
	delete routed;
	//delete [] arrTime;
	delete startS;
	delete waitTime;
	delete lb;	delete sbSPD;	delete lbSPD;
	delete [] seg; delete []numLegSP;
	delete FCAP; delete BCAP;*/
}

/*
 * Try to set begin time for nodes in path
 * inStartTime	: DEPARTURE time point at inStartPointIdx
 * arrPath		: consists of node index to set time EXCLUSIVE start and endNode
 * inPathSz		: number of nodes in path
 * arrBeginTime : output
 * inEndpointIdx: 
 * inEndPointType: 0 - depot; 1 - pickup; 2- supply point to delivery
 * odbEndS: arrival time at inEndpointIdx (included waiting time at Waiting Station)
 */
bool Solution::SetBeginTimeForPath_Q(double inStartTime, int inStartPointIdx,
						   int *arrPath,
						   int inPathSz,
						   double *arrBeginTime,
						   int inEndpointIdx,
						   double *odbEndS,
						   int *inWSId,
						   int *ouCapacity)
{
	double dbEndS = -1;
	double sTw = -1;
	double eTw = -1;
	int WSIDtemp = -1;
	int inEndPointType;
	int inCapacity;
	int inMaxCapacity = 0;

	//Vehicle capacity
	inCapacity = 0;
	for (int i = 1; i <= inPathSz; i++)
	{
		//if (problem->node[arrPath[i]].capacity < 0) break; // break if found C2C_DELIVERY demands
		inCapacity += problem->node[arrPath[i]].capacity;
		if (inCapacity > inMaxCapacity) // in case of C2C trip, we saved max capacity
			inMaxCapacity = inCapacity;
		if (inCapacity > Q)
		{
#if Q_DEBUG_SET_TIME
			cout <<"SetBeginTimeForPath_Q::Exceed capacity" << endl; getchar();
#endif
			return false;
		}

	}

	*ouCapacity = inMaxCapacity;

	//if (Get_Node_Type(inStartPointIdx) == NODE_SUPPLY_POINT) {
	//	if(!PDSINRANGE(inStartTime, problem->nodeSP[inStartPointIdx].sTW1, problem->nodeSP[inStartPointIdx].eTW1)) {
	//		return false;
	//	}
	//}

	//Get node type: Depot/SP/Pickup/Delivery/c2c-pickup/c2c-delivery
	inEndPointType = Get_Node_Type(inEndpointIdx);

	// Set arrival time of first node
	if (PDS_INFINITY == problem->c[inStartPointIdx][arrPath[1]])
	{
#if Q_DEBUG_SET_TIME
			cout <<"SetBeginTimeForPath_Q::FirstNode" << endl; getchar();
#endif
		return false;
	}
	arrBeginTime[1] = problem->c[inStartPointIdx][arrPath[1]] + inStartTime;
#if Q_WAITING_AT_CUST
	if (arrBeginTime[1] > problem->node[arrPath[1]].eTW) // allow waiting at customer-demand
#else
	if ((arrBeginTime[1] < problem->node[arrPath[1]].sTW) || (arrBeginTime[1] > problem->node[arrPath[1]].eTW))
#endif
	{
#if Q_DEBUG_SET_TIME
			cout <<"SetBeginTimeForPath_Q::Fist node" << endl; getchar();
			cout <<"arrBeginTime[1]= " << arrBeginTime[1] << endl;
			cout << problem->node[arrPath[1]].sTW <<
				" " << problem->node[arrPath[1]].eTW << endl;
#endif
		return false;
	}

#if Q_WAITING_AT_CUST
	arrBeginTime[1] = PDS_MAX(arrBeginTime[1], problem->node[arrPath[1]].sTW) + problem->node[arrPath[1]].duration;
#else
	arrBeginTime[1] += problem->node[arrPath[1]].duration;
#endif

	//For the other nodes
	for (int inNode=2; inNode<=inPathSz; inNode++)
	{
		if (PDS_INFINITY == problem->c[arrPath[inNode-1]][arrPath[inNode]])
		{
#if Q_DEBUG_SET_TIME
			cout <<"SetBeginTimeForPath_Q::Infinity distance" << endl; getchar();
#endif
			return false;
		}
		arrBeginTime[inNode] = arrBeginTime[inNode-1] + problem->c[arrPath[inNode-1]][arrPath[inNode]];
		// Check time window of inNode
#if Q_WAITING_AT_CUST
		if (arrBeginTime[inNode] > problem->node[arrPath[inNode]].eTW)
#else
		if ((arrBeginTime[inNode] < problem->node[arrPath[inNode]].sTW) || (arrBeginTime[inNode] > problem->node[arrPath[inNode]].eTW))
#endif
		{
#if Q_DEBUG_SET_TIME
			cout <<"SetBeginTimeForPath_Q::Intermediate node" << endl; getchar();
#endif
			return false;
		}
#if Q_WAITING_AT_CUST
	arrBeginTime[inNode] = PDS_MAX(arrBeginTime[inNode], problem->node[arrPath[inNode]].sTW) + problem->node[arrPath[inNode]].duration;
#else
		arrBeginTime[inNode] += problem->node[arrPath[inNode]].duration;
#endif
	}

	if (PDS_INFINITY == problem->c[arrPath[inPathSz]][inEndpointIdx])
	{
#if Q_DEBUG_SET_TIME
			cout <<"SetBeginTimeForPath_Q:: Infinity distance" << endl; getchar();
#endif
		return false;
	}
	dbEndS = arrBeginTime[inPathSz] + problem->c[arrPath[inPathSz]][inEndpointIdx];
	switch (inEndPointType)
	{
		case NODE_DEPOT: //end at depot
			sTw = 0; eTw = PDS_INFINITY;
			break;
		case NODE_SUPPLY_POINT: // end at supply point
			sTw = problem->nodeSP[inEndpointIdx].sTW1; 
			eTw = problem->nodeSP[inEndpointIdx].eTW1;
			break;
		case NODE_WAITING_STATION:
#if Q_DEBUG_SET_TIME
			cout <<"SetBeginTimeForPath_Q::Not supported node" << endl; getchar();
#endif
			return false;
		default: //pickup/delivery/c2c-pickup/c2c-delivery
			sTw = problem->node[inEndpointIdx].sTW; 
			eTw = problem->node[inEndpointIdx].eTW;
			break;
	}

	*odbEndS = dbEndS;
	*inWSId = -1;

	if (NODE_SUPPLY_POINT == inEndPointType)
	{
		//Can waiting at WS
		if (dbEndS < sTw)
		{
			WSIDtemp = problem->CWSSP[arrPath[inPathSz]][inEndpointIdx];
			if (WSIDtemp < 1)
			{
#if Q_DEBUG_SET_TIME
			cout <<"SetBeginTimeForPath_Q::Unavailable parking from " << arrPath[inPathSz] << " to " << inEndpointIdx << endl; getchar();
#endif
				return false; // Can not find possible park from arrPath[inPathSz] --> inEndpointIdx
			}
			*inWSId = WSIDtemp;

			if (PDS_INFINITY == problem->c[arrPath[inPathSz]][WSIDtemp])
			{
#if Q_DEBUG_SET_TIME
			cout <<"SetBeginTimeForPath_Q::Infinity distance" << endl; getchar();
#endif
				return false;
			}
			double dbDistanceTmp = dbEndS + problem->c[arrPath[inPathSz]][WSIDtemp];
			dbDistanceTmp += problem->c[WSIDtemp][inEndpointIdx];

			if(PDSINRANGE(dbDistanceTmp, sTw, eTw))
			{
				*odbEndS = dbDistanceTmp;
			} 
			else if (dbDistanceTmp < sTw)
			{
				*odbEndS = sTw;
			} 
			else
			{
#if Q_DEBUG_SET_TIME
			cout <<"SetBeginTimeForPath_Q::WS failed at *ln" << __LINE__ << endl; getchar();
#endif
				return false;
			}

			return true;
		}

	}

#if Q_WAITING_AT_CUST
	if (dbEndS > eTw)
#else
	if (!PDSINRANGE(dbEndS, sTw, eTw))
#endif
	{
#if Q_DEBUG_SET_TIME
			cout <<"SetBeginTimeForPath_Q::Not in range of endNodeIdx" << endl; getchar();
#endif
		return false;
	}

	return true;
}
/*
 * Try to create new C2c trip from inStartPointIdx to inEndPointIdx using Solomon I1
 * inVehicleIdx			: vehicle index
 * inTripIdx			: trip index
 * inVehCurrCap			: current capacity of vehicle
 * inStartPointIdx		: Start point index ( garage, supply point, delivery
 * inDepartTimeAtStart  : Departure time at start point 
 * inEndPointIdx		: End point index (garage, supply point, pickup
 * inEndPointType		: 0 - depot, 1 - pickup, 2 - supply point to delivery
 * arrC2CPCandiadte		: List of c2c-PICKUPc candidates
 * inCandiadateNbr		: Number of candidates
 */
bool Solution::CreateC2CTripSolomonI1_Q(int inVehicleIdx, int inTripIdx, 
							  int inVehCurrCap,
							  int inStartPointIdx, int inDepartTimeAtStart, 
							  int inEndPointIdx, int inEndPointType, int inSTWAtEndPoint, int inETWAtEndPoing, 
							  int *arrC2CPCandiadte, int inCandiadateNbr)
{

	int inNodeIdx = 0;
	int arrTripTmp[2000];		
	int arrPath[2000];			 
	double arrBeginIime[2000]; 
	double arrSaveBeginTime[2000];
	int inFeaPos; // feasible position for c2c-pickup
	int inBeginTime;
	bool bRetVal;
	int inPathSz;
	int inC2CPickupNbr;
	int inCurrVehCapTemp;
	int inWSId;
	double dbEnds;
	double dbSavedEnds;
	int inSavedVehCap;
	int inVehCap;
	
#if Q_DEBUG_C2C
	cout << "CreateC2CTripSolomonI1_Q" << endl;
#endif

	// Assumption that vehicle has to empty before starting to serve c2c-demands?
	if (inVehCurrCap)
	{
#if Q_DEBUG_C2C
		cout << "The vehicle is not empty!" << endl;
#endif
		return false;
	}
	inCurrVehCapTemp = inVehCurrCap;

	/*
	 * For each candidates:
	 *		- The feasible positions for c2c-pickup are first computed. Insert c2c-pickup as first position found.
	 *		- The best feasible insertion for c2c-delivery is determined using the Solomon I1
	 */
	inC2CPickupNbr = 0;
	for (int inC2CIdx=1; inC2CIdx<=inCandiadateNbr; inC2CIdx++)
	{
		int inC2CDeliveryIdx = arrC2CPCandiadte[inC2CIdx] + nOrder;
		bool isRouted = false;

		//Check capacity if serving c2c-pickup arrC2CPCandiadte[inC2CIdx]
		/*if ((inCurrVehCapTemp + problem->node[arrC2CPCandiadte[inC2CIdx]].capacity) > Q)
		{
			continue;
		}*/

		// This is empty trip
		if (!inC2CPickupNbr)
		{ 
			inPathSz = 0;

			// Add first C2C pair
			inPathSz++;
			arrPath[inPathSz] = arrC2CPCandiadte[inC2CIdx];
			inPathSz++;
			arrPath[inPathSz] = arrC2CPCandiadte[inC2CIdx]+nOrder;
#if Q_DEBUG_C2C
			cout << "Create new trip: " << endl;
			cout << "\tBefore set time: ";
			for (int inLoop=1; inLoop<=inPathSz; inLoop++)
			{
				cout << arrPath[inLoop] << "->";
			}
			cout << endl;
#endif
			bRetVal = SetBeginTimeForPath_Q(inDepartTimeAtStart, inStartPointIdx,
				arrPath,
				inPathSz,
				arrBeginIime,
				inEndPointIdx,
				&dbEnds, 
				&inWSId,
				&inVehCap);
			if (true == bRetVal)
			{
				isRouted = true;
				//inC2CPickupNbr++;
				memcpy(arrTripTmp, arrPath, (inPathSz+1)*sizeof(int));
				memcpy(arrSaveBeginTime, arrBeginIime, (inPathSz+1)*sizeof(double));
				dbSavedEnds = dbEnds;
				inSavedVehCap = inVehCap;
#if Q_DEBUG_C2C
				cout << "\t Create new trip OK!" << endl; 
#endif
			} else
			{
				// Create new C2C trip failed -> continue to consider next node
#if Q_DEBUG_C2C
				cout << "\t Create new trip failed. Next node..." << endl; 
#endif
				continue;
			}
		} else // existed C2C trip with (2*inC2CPickupNbr) already
		{
#if Q_DEBUG_C2C
			cout << "\t Current C2C trip: " << endl;
			for (int inLoop = 1; inLoop <= 2*inC2CPickupNbr; inLoop++)
			{
				cout << arrPath[inLoop] << "->";
			}
			cout << endl;
			cout << "\t Try to insert C2C pair (" << arrC2CPCandiadte[inC2CIdx] << "," << (arrC2CPCandiadte[inC2CIdx]+nOrder) << ")" << endl;
#endif
			/*
			 * Find a place to insert this pair of C2C 
			 * in order to keep LIFO policy
			 */
			inPathSz = 0;
			for (int inPos = 1; inPos <= 2*inC2CPickupNbr+1; inPos++)
			{
				/*
				 * arrTripTmp: holds current C2C trip
				 * arrPath: hold new C2C trip after insert pair (arrC2CPCandiadte[inC2CIdx], arrC2CPCandiadte[inC2CIdx] + nOrder) to arrTripTmp
				 */
				inPathSz = 0;

				// Firstly, copy from 1 to (inPos-1) from arrTripTmp to arrPath
				for (int i = 1; i <= (inPos-1); i++)
				{
					inPathSz++;
					arrPath[inPathSz] = arrTripTmp[i];
				}

				// Second, insert C2C PU candidate to new path
				inPathSz++;
				arrPath[inPathSz] = arrC2CPCandiadte[inC2CIdx];
				int inSaveCurrPos = inPathSz;
				// Third, search all possible place to insert C2C Delivery
				for (int jC2CDEPos = inPos; jC2CDEPos <= 2*inC2CPickupNbr+1; jC2CDEPos++)
				{
					// Roll-back
					inPathSz = inSaveCurrPos;

					// Move from inPos to (jC2CDEPos-1) from arrTripTmp to arrPath
					for (int i = inPos; i <= (jC2CDEPos-1); i++)
					{
						inPathSz++;
						arrPath[inPathSz] = arrTripTmp[i];
					}
					// Insert C2C delivery
						inPathSz++;
						arrPath[inPathSz] = arrC2CPCandiadte[inC2CIdx] + nOrder;
					// Move the remaining of arrTripTmp to arrPath
  				    for (int i = jC2CDEPos; i <= 2*inC2CPickupNbr; i++)
					{
						inPathSz++;
						arrPath[inPathSz] = arrTripTmp[i];
					}

#if Q_DEBUG_C2C
					cout << "\t Suggested C2C trip: ";
					for (int inLoop=1; inLoop<=inPathSz; inLoop++)
					{
						if (arrPath[inLoop] == arrC2CPCandiadte[inC2CIdx])
						{
							cout << arrPath[inLoop] << "*->";
						} else if (arrPath[inLoop] == arrC2CPCandiadte[inC2CIdx] + nOrder)
						{
							cout << arrPath[inLoop] << "**->";
						} else
							cout << arrPath[inLoop] << "->";
					}
					cout << endl;
#endif

					// Check LIFO
					if (false == IsLIFO_Q(arrPath, inPathSz))
					{
#if Q_DEBUG_C2C
						cout << "\t LIFO failed ";
#endif
						continue;
					}

					bRetVal = SetBeginTimeForPath_Q(inDepartTimeAtStart, inStartPointIdx,
						arrPath,
						inPathSz,
						arrBeginIime,
						inEndPointIdx,
						&dbEnds,
						&inWSId,
						&inVehCap);
					if (true == bRetVal)
					{
						isRouted = true;
						memcpy(arrTripTmp, arrPath, (inPathSz+1)*sizeof(int));
						memcpy(arrSaveBeginTime, arrBeginIime, (inPathSz+1)*sizeof(double));
						dbSavedEnds = dbEnds;
						inSavedVehCap = inVehCap;					
						break; // first found
					} else
					{
#if Q_DEBUG_C2C
						cout << "\tSet time failed" << endl;
#endif
					}
				}

				if (true == bRetVal)
					break; // next C2C candidate
			}
		}

		if (true == isRouted)
		{
			inC2CPickupNbr++;
			inCurrVehCapTemp += problem->node[arrC2CPCandiadte[inC2CIdx]].capacity;
#if Q_DEBUG_C2C
			cout << "\t C2C-Pickup " << arrC2CPCandiadte[inC2CIdx] << " is accepted" <<endl;
			cout << "\t Routed: " << endl;
			for (int i = 1; i <= 2*inC2CPickupNbr; i++)
			{
				cout << arrTripTmp[i] << "(" << arrSaveBeginTime[i] << ") -> ";
			}
			cout << endl;
#endif
		}
	}

	if (!inC2CPickupNbr) return false;

#if Q_DEBUG_C2C
	cout <<"Got C2C from " << inStartPointIdx << " to " << inEndPointIdx;
#endif

	//Create new trip
	seg[inVehicleIdx].Trip[inTripIdx+1].startNodeIdx = inStartPointIdx;
	seg[inVehicleIdx].Trip[inTripIdx+1].endNodeIdx = inEndPointIdx;
	seg[inVehicleIdx].Trip[inTripIdx+1].Type = TRIP_C2C;
	seg[inVehicleIdx].Trip[inTripIdx+1].assSP = -1;
	seg[inVehicleIdx].Trip[inTripIdx+1].firstCus = arrTripTmp[1]; //id of the first Customer of Leg
	seg[inVehicleIdx].Trip[inTripIdx+1].lastCus = arrTripTmp[2*inC2CPickupNbr]; //id of the first Customer of Leg
	seg[inVehicleIdx].Trip[inTripIdx+1].numCus = 2*inC2CPickupNbr; //#Customers in the leg
	seg[inVehicleIdx].Trip[inTripIdx+1].capacity = inSavedVehCap;
	seg[inVehicleIdx].Trip[inTripIdx].waitingS = -1;
	//seg[inVehicleIdx].Trip[inTripIdx].cost = costMINI;
	seg[inVehicleIdx].Trip[inTripIdx+1].endS = dbSavedEnds;
	seg[inVehicleIdx].Trip[inTripIdx+1].feasible = 1;
	seg[inVehicleIdx].Trip[inTripIdx+1].leaveSP = inDepartTimeAtStart;

	int curC = seg[inVehicleIdx].Trip[inTripIdx+1].firstCus;
	routed[curC] = 1;
	for (int i = 2; i <= 2*inC2CPickupNbr; i++)
	{
		routed[arrTripTmp[i]] = 1;
		nextArr[curC] = arrTripTmp[i];
		curC = arrTripTmp[i];
	}
	nextArr[curC] = -1;		
	
	seg[inVehicleIdx].numTrips += 1;


	return true;
}
//////////////////////////////////////////////////////////////////////////////////
// IMPLEMENT ADAPTIVE LARGE NEIGHBORHOOD SEARCH
//////////////////////////////////////////////////////////////////////////////////
// Check and join trips at startNodeIdx, endNodeIdx
bool Solution::Join_Trips(int inVehIdx)
{
	//Dump trip first

	for (int j = 1; j <= seg[inVehIdx].numTrips; j++)
	{
		if (1 == j) // the first trip
		{
			seg[inVehIdx].Trip[j].startNodeIdx = 0; // first trip start from  DEPOT
		} else if (seg[inVehIdx].numTrips == j) // the last trip
		{
			seg[inVehIdx].Trip[j].endNodeIdx = 0; // last trip end at DEPOT

			seg[inVehIdx].Trip[j-1].endNodeIdx = seg[inVehIdx].Trip[j].firstCus;
			seg[inVehIdx].Trip[j].startNodeIdx = seg[inVehIdx].Trip[j-1].lastCus;

		} else // intermediate trip 
		{
			seg[inVehIdx].Trip[j-1].endNodeIdx = seg[inVehIdx].Trip[j].firstCus;
			seg[inVehIdx].Trip[j].startNodeIdx = seg[inVehIdx].Trip[j-1].lastCus;
		}
	}
	return true;
}

// Reset all joining node
bool Solution::Re_Set_Joint_For_A_Vehicle(int inVehIDx)
{
	for (int j = 2; j < seg[inVehIDx].numTrips; j++)
	{
		int inLastEndNodeIdx = seg[inVehIDx].Trip[j-1].endNodeIdx;
		int inNextStartNodeIdx = seg[inVehIDx].Trip[j+1].startNodeIdx;

		if ((Get_Node_Type(inLastEndNodeIdx) != NODE_DEPOT) && (Get_Node_Type(inLastEndNodeIdx) != NODE_SUPPLY_POINT) && (Get_Node_Type(inLastEndNodeIdx) != NODE_WAITING_STATION))
		{
			if (inLastEndNodeIdx != seg[inVehIDx].Trip[j].firstCus)
				seg[inVehIDx].Trip[j-1].endNodeIdx = seg[inVehIDx].Trip[j].firstCus;
		}

		if ((Get_Node_Type(inNextStartNodeIdx) != NODE_DEPOT) && (Get_Node_Type(inNextStartNodeIdx) != NODE_SUPPLY_POINT) && (Get_Node_Type(inNextStartNodeIdx) != NODE_WAITING_STATION))
		{
			if (inNextStartNodeIdx != seg[inVehIDx].Trip[j].lastCus)
				seg[inVehIDx].Trip[j+1].startNodeIdx = seg[inVehIDx].Trip[j].lastCus;
		}
	}

	return true;
}

// Re-set time for a vehicle leave depot at dbStartTime
bool Solution::Re_Set_Time_For_A_Vehicle(VRPSegment veh, double dbStartTime)
{
	int inTripSzTmp;
	int arrTripTmp[2000];
	bool bRetVal;
	double arrBeginIime[2000];
	double dbEnds;
	int inWSId;
	int inVehCap;
	double dbStartTimeTmp = dbStartTime;

	for (int j = 1; j <= veh.numTrips; j++)
	{
		// Rebuild trip
		inTripSzTmp = 0;

		int curC = veh.Trip[j].firstCus;
		while (curC > 0)
		{
			inTripSzTmp++;
			arrTripTmp[inTripSzTmp] = curC;
			curC = nextArr[curC];
		}
#if Q_DEBUG_SET_VEH_TIME
		cout << "SetTime: veh " <<  inVehIdx << ", trip " << j << " from " << dbStartTimeTmp << endl;
#endif
		if (TRIP_DELIVERY == veh.Trip[j].Type)
		{
			dbStartTimeTmp += problem->nodeSP[veh.Trip[j].startNodeIdx].load;
#if Q_DEBUG_SET_VEH_TIME
		cout << "\tDelivery trip, time after loading: " <<  dbStartTimeTmp << endl;
#endif			
		}

		bRetVal = SetBeginTimeForPath_Q(dbStartTimeTmp, veh.Trip[j].startNodeIdx,
			arrTripTmp,
			inTripSzTmp,
			arrBeginIime,
			veh.Trip[j].endNodeIdx,
			&dbEnds,
			&inWSId,
			&inVehCap);
		if (false == bRetVal)
			return false;

		if (TRIP_PICKUP == veh.Trip[j].Type)
		{
			dbEnds += problem->nodeSP[veh.Trip[j].endNodeIdx].unload;
		}
#if Q_DEBUG_SET_VEH_TIME
		cout << seg[inVehIdx].Trip[j].startNodeIdx << "(" << dbStartTimeTmp << ")->";
		for (int ii=1; ii <= inTripSzTmp; ii++)
		{
			cout << arrTripTmp[ii] << "(" << arrBeginIime[ii] <<")->";
		}
		cout << seg[inVehIdx].Trip[j].endNodeIdx << "(" << dbEnds << ")" << endl;
#endif


#if Q_DEBUG_SET_VEH_TIME
		cout << "\t ok! End at " << dbEnds << endl;
#endif
//		if (true == bUpdate)
		{
			if (TRIP_DELIVERY == veh.Trip[j].Type)
			{
				veh.Trip[j].leaveSP = dbStartTimeTmp - problem->nodeSP[veh.Trip[j].startNodeIdx].load;
			} else
				veh.Trip[j].leaveSP = dbStartTimeTmp;

			veh.Trip[j].endS = dbEnds;

			veh.Trip[j].waitingS = inWSId;
			veh.Trip[j].capacity = inVehCap;

		}

		if (j < veh.numTrips) // not last trip
		{
			if (veh.Trip[j+1].startNodeIdx == veh.Trip[j].lastCus)
			{
				dbStartTimeTmp = arrBeginIime[inTripSzTmp];
			} else if (veh.Trip[j+1].startNodeIdx == veh.Trip[j].endNodeIdx)
			{
				dbStartTimeTmp = dbEnds;
			} else
			{
				dbStartTimeTmp += problem->c[veh.Trip[j].endNodeIdx][veh.Trip[j+1].startNodeIdx]; 
			}
		}

	}


#if Q_DEBUG_SET_VEH_TIME
	cout << endl << "************************************************************" << endl;
	showSolution();
#endif

	return true;
}
// Assumpe that we updated trip inTripIdx-1 ok and now check time for the remaining trips
bool Solution::Set_Time_For_A_Vehicle(int inVehIdx, int inTripIdx, double dbStartTime, bool bUpdate)
{
	int inTripSzTmp;
	int arrTripTmp[2000];
	bool bRetVal;
	double arrBeginIime[2000];
	double dbEnds;
	int inWSId;
	int inVehCap;
	double dbStartTimeTmp = dbStartTime;

#if Q_DEBUG_SET_VEH_TIME
	cout << endl << "************************************************************" << endl;
	cout << ">> SET TIME for VEH " << inVehIdx << " from trip " << inTripIdx << " at " << dbStartTime << endl;
	cout << ">> Updated? " << bUpdate << endl << endl;
#endif

	for (int j = inTripIdx; j <= seg[inVehIdx].numTrips; j++)
	{
		// Rebuild trip
		inTripSzTmp = 0;

		int curC = seg[inVehIdx].Trip[j].firstCus;
		while (curC > 0)
		{
			inTripSzTmp++;
			arrTripTmp[inTripSzTmp] = curC;
			curC = nextArr[curC];
		}
#if Q_DEBUG_SET_VEH_TIME
		cout << "SetTime: veh " <<  inVehIdx << ", trip " << j << " from " << dbStartTimeTmp << endl;
#endif
		if (TRIP_DELIVERY == seg[inVehIdx].Trip[j].Type)
		{
			dbStartTimeTmp += problem->nodeSP[seg[inVehIdx].Trip[j].startNodeIdx].load;
#if Q_DEBUG_SET_VEH_TIME
		cout << "\tDelivery trip, time after loading: " <<  dbStartTimeTmp << endl;
#endif			
		}

		//if (j < seg[inVehIdx].numTrips) // not last trip
		//{
		//	if ((seg[inVehIdx].Trip[j].Type == TRIP_PICKUP) && (seg[inVehIdx].Trip[j+1].Type == TRIP_DELIVERY)) {
		//		if (seg[inVehIdx].Trip[j].assSP != seg[inVehIdx].Trip[j+1].assSP) {
		//			cout << "Unit test";
		//			Show_A_Trip(inVehIdx,j);
		//			Show_A_Trip(inVehIdx,j+1);
		//		}
		//	}
		//}

		////Quangnn++ 160621
		//if (seg[inVehIdx].Trip[j].Type == TRIP_DELIVERY){
		//		if (Get_Node_Type(seg[inVehIdx].Trip[j].startNodeIdx) == NODE_SUPPLY_POINT) {
		//			if(!PDSINRANGE(dbStartTimeTmp, problem->nodeSP[seg[inVehIdx].Trip[j].startNodeIdx].sTW1, problem->nodeSP[seg[inVehIdx].Trip[j].startNodeIdx].eTW1)) {
		//				return false;
		//			}
		//		}
		//}

		bRetVal = SetBeginTimeForPath_Q(dbStartTimeTmp, seg[inVehIdx].Trip[j].startNodeIdx,
			arrTripTmp,
			inTripSzTmp,
			arrBeginIime,
			seg[inVehIdx].Trip[j].endNodeIdx,
			&dbEnds,
			&inWSId,
			&inVehCap);
		if (false == bRetVal)
			return false;

		if (TRIP_PICKUP == seg[inVehIdx].Trip[j].Type)
		{
			dbEnds += problem->nodeSP[seg[inVehIdx].Trip[j].endNodeIdx].unload;
		}
#if Q_DEBUG_SET_VEH_TIME
		cout << seg[inVehIdx].Trip[j].startNodeIdx << "(" << dbStartTimeTmp << ")->";
		for (int ii=1; ii <= inTripSzTmp; ii++)
		{
			cout << arrTripTmp[ii] << "(" << arrBeginIime[ii] <<")->";
		}
		cout << seg[inVehIdx].Trip[j].endNodeIdx << "(" << dbEnds << ")" << endl;
#endif


#if Q_DEBUG_SET_VEH_TIME
		cout << "\t ok! End at " << dbEnds << endl;
#endif
		if (true == bUpdate)
		{
			if (TRIP_DELIVERY == seg[inVehIdx].Trip[j].Type)
			{
				seg[inVehIdx].Trip[j].leaveSP = dbStartTimeTmp - problem->nodeSP[seg[inVehIdx].Trip[j].startNodeIdx].load;
			} else
				seg[inVehIdx].Trip[j].leaveSP = dbStartTimeTmp;

			seg[inVehIdx].Trip[j].endS = dbEnds;

			seg[inVehIdx].Trip[j].waitingS = inWSId;
			seg[inVehIdx].Trip[j].capacity = inVehCap;

			if (j < seg[inVehIdx].numTrips) {// not last trip: update trip
				if ((seg[inVehIdx].Trip[j].Type == TRIP_PICKUP) && (seg[inVehIdx].Trip[j+1].Type == TRIP_DELIVERY)) {
					if (seg[inVehIdx].Trip[j].assSP != seg[inVehIdx].Trip[j+1].assSP) {
						double dbReachTime = dbStartTimeTmp + problem->c[seg[inVehIdx].Trip[j].endNodeIdx][seg[inVehIdx].Trip[j+1].startNodeIdx]; 
						if (false == PDSINRANGE(dbReachTime, problem->nodeSP[seg[inVehIdx].Trip[j+1].startNodeIdx].sTW1, problem->nodeSP[seg[inVehIdx].Trip[j+1].startNodeIdx].eTW1)) {
							int inWSTmp = problem->CWSSP[seg[inVehIdx].Trip[j].endNodeIdx][seg[inVehIdx].Trip[j+1].startNodeIdx];
							if (inWSTmp < 0) return false;
							double dbTmp1 =  problem->c[seg[inVehIdx].Trip[j].endNodeIdx][inWSTmp]; 
							dbTmp1 += problem->c[inWSTmp][seg[inVehIdx].Trip[j+1].startNodeIdx];
							if (dbTmp1 > problem->nodeSP[seg[inVehIdx].Trip[j+1].startNodeIdx].eTW1)
								return false;

							seg[inVehIdx].Trip[j+1].leaveSP = dbTmp1;
							if (dbTmp1 < problem->nodeSP[seg[inVehIdx].Trip[j+1].startNodeIdx].eTW1) 
								seg[inVehIdx].Trip[j+1].leaveSP = problem->nodeSP[seg[inVehIdx].Trip[j+1].startNodeIdx].eTW1;
						} else {
							seg[inVehIdx].Trip[j+1].leaveSP = dbStartTimeTmp + problem->c[seg[inVehIdx].Trip[j].endNodeIdx][seg[inVehIdx].Trip[j+1].startNodeIdx]; 
						}
					}
				}
			}
		}

		if (j < seg[inVehIdx].numTrips) // not last trip
		{
			if (seg[inVehIdx].Trip[j+1].startNodeIdx == seg[inVehIdx].Trip[j].lastCus)
			{
				dbStartTimeTmp = arrBeginIime[inTripSzTmp];
			} else if (seg[inVehIdx].Trip[j+1].startNodeIdx == seg[inVehIdx].Trip[j].endNodeIdx)
			{
				dbStartTimeTmp = dbEnds;
			} else
			{
				if ((seg[inVehIdx].Trip[j].Type == TRIP_PICKUP) && (seg[inVehIdx].Trip[j+1].Type == TRIP_DELIVERY)) {

					double dbReachTime = dbStartTimeTmp + problem->c[seg[inVehIdx].Trip[j].endNodeIdx][seg[inVehIdx].Trip[j+1].startNodeIdx]; 
					if (false == PDSINRANGE(dbReachTime, problem->nodeSP[seg[inVehIdx].Trip[j+1].startNodeIdx].sTW1, problem->nodeSP[seg[inVehIdx].Trip[j+1].startNodeIdx].eTW1)) {
						int inWSTmp = problem->CWSSP[seg[inVehIdx].Trip[j].endNodeIdx][seg[inVehIdx].Trip[j+1].startNodeIdx];
						if (inWSTmp < 0) return false;
						double dbTmp1 =  problem->c[seg[inVehIdx].Trip[j].endNodeIdx][inWSTmp]; 
						dbTmp1 += problem->c[inWSTmp][seg[inVehIdx].Trip[j+1].startNodeIdx];
						if (dbTmp1 > problem->nodeSP[seg[inVehIdx].Trip[j+1].startNodeIdx].eTW1)
							return false;
					} else {
						dbStartTimeTmp += problem->c[seg[inVehIdx].Trip[j].endNodeIdx][seg[inVehIdx].Trip[j+1].startNodeIdx]; 
					}
				} else {
					dbStartTimeTmp += problem->c[seg[inVehIdx].Trip[j].endNodeIdx][seg[inVehIdx].Trip[j+1].startNodeIdx]; 
				}
			}
		}

	}


#if Q_DEBUG_SET_VEH_TIME
	cout << endl << "************************************************************" << endl;
	showSolution();
#endif

	return true;
}
bool Solution::Valid_A_Trip_With_TimeStart(int inVehIDx, int inTripIdx, double dbStartTime)
{
	int curC;
	int inTripType = seg[inVehIDx].Trip[inTripIdx].Type;
	double dbTimeTmp;
	int inNodeType;
	int inTripSzTmp;
	int arrTripTmp[2000];
	int inCapacity;
	double dbTransportCost = 0;

	// Rebuild trip
	inTripSzTmp = 0;
	inCapacity = 0;

	curC = seg[inVehIDx].Trip[inTripIdx].firstCus;
	while (curC > 0)
	{
		inCapacity += problem->node[curC].capacity;
		inTripSzTmp++;
		arrTripTmp[inTripSzTmp] = curC;
		curC = nextArr[curC];
	}

	// Check vehicle capacity
	if (inCapacity > Q)
	{
		cout << "Valid_A_Trip::Overload!" << endl; getchar();
		Show_A_Trip(inVehIDx, inTripIdx);
		return false;
	}

	// Get transportation cost
	//dbTransportCost += problem->c[seg[inVehIDx].Trip[inTripIdx].startNodeIdx][seg[inVehIDx].Trip[inTripIdx].firstCus];
	for (int i = 1; i < inTripSzTmp; i++)
	{
		dbTransportCost += problem->c[arrTripTmp[i]][arrTripTmp[i+1]];
	}
	//dbTransportCost += problem->c[seg[inVehIDx].Trip[inTripIdx].lastCus][seg[inVehIDx].Trip[inTripIdx].endNodeIdx];

	//Check startNodeIdx, endNodeIdx of specific trip
	if (TRIP_PICKUP == inTripType)
	{
		/*
		 * Because of PICKUP trip so:
		 *	- startNodeIdx can be Depot/SP/delivery/c2c-delivery
		 *  - endNodeIdx has to be SP
		 */
		inNodeType = Get_Node_Type(seg[inVehIDx].Trip[inTripIdx].startNodeIdx);
		switch (inNodeType)
		{
			case NODE_DEPOT:
			case NODE_SUPPLY_POINT:
			case NODE_DELIVERY: 
			case NODE_C2C_DELIVERY:
				break;
			default:
//#if Q_DEBUG_VALID_TRIP
				cout << "Valid_A_Trip::Invalid startNodeIdx of PICKUP trip" << endl; getchar();
//#endif				
				Show_A_Trip(inVehIDx, inTripIdx);
				return false;
		}
		
		inNodeType = Get_Node_Type(seg[inVehIDx].Trip[inTripIdx].endNodeIdx);
		switch (inNodeType)
		{
			case NODE_SUPPLY_POINT:
				break;
			default:
//#if Q_DEBUG_VALID_TRIP
				cout << "Valid_A_Trip::Invalid endNodeIdx of PICKUP trip *l" << __LINE__ << endl; getchar();
//#endif
				Show_A_Trip(inVehIDx, inTripIdx);
				return false;
		}
	} else if (TRIP_DELIVERY == inTripType)
	{
		/*
		 * Because of DELIVERY trip so:
		 *	- startNodeIdx can be SP 
		 *  - endNodeIdx has to be Depot/SP/pickup/c2c-pickup
		 */
		inNodeType = Get_Node_Type(seg[inVehIDx].Trip[inTripIdx].startNodeIdx);
		switch (inNodeType)
		{
			case NODE_SUPPLY_POINT:
				break;
			default:
//#if Q_DEBUG_VALID_TRIP
				cout << "Valid_A_Trip::Invalid startNodeIdx of DELIVERY trip" << endl; getchar();
//#endif				
				Show_A_Trip(inVehIDx, inTripIdx);
				return false;
		}
		
		inNodeType = Get_Node_Type(seg[inVehIDx].Trip[inTripIdx].endNodeIdx);
		switch (inNodeType)
		{
			case NODE_DEPOT:
			case NODE_SUPPLY_POINT:
			case NODE_PICKUP: 
			case NODE_C2C_PICKUP:
				break;
			default:
//#if Q_DEBUG_VALID_TRIP
				cout << "Valid_A_Trip::Invalid endNodeIdx of DELIVERY trip *l" << __LINE__ << endl; getchar();
//#endif				
				Show_A_Trip(inVehIDx, inTripIdx);
				return false;
		}

	} else if (TRIP_C2C == inTripType)
	{
		/*
		 * Because of C2C trip so:
		 *	- startNodeIdx can be Depot/SP/delivery/c2c-delivery 
		 *  - endNodeIdx has to be Depot/SP/pickup/c2c-pickup
		 */
		inNodeType = Get_Node_Type(seg[inVehIDx].Trip[inTripIdx].startNodeIdx);
		switch (inNodeType)
		{
			case NODE_SUPPLY_POINT:
			case NODE_DEPOT:
			case NODE_DELIVERY:
			case NODE_C2C_DELIVERY:
				break;
			default:
//#if Q_DEBUG_VALID_TRIP
				cout << "Valid_A_Trip::Invalid startNodeIdx of C2C trip" << endl;
//#endif
				getchar();
				Show_A_Trip(inVehIDx, inTripIdx);
				return false;
		}
		
		inNodeType = Get_Node_Type(seg[inVehIDx].Trip[inTripIdx].endNodeIdx);
		switch (inNodeType)
		{
			case NODE_SUPPLY_POINT:
			case NODE_DEPOT:
			case NODE_PICKUP:
			case NODE_C2C_PICKUP:
				break;
			default:
//#if Q_DEBUG_VALID_TRIP
				cout << "Valid_A_Trip::Invalid endNodeIdx of C2C trip *l" << __LINE__ << endl; getchar();
//#endif				
				Show_A_Trip(inVehIDx, inTripIdx);
				return false;
		}

	}

#if Q_DEBUG_VALID_TRIP
	if (TRIP_DELIVERY == inTripType)
	{
		cout << seg[inVehIDx].Trip[inTripIdx].startNodeIdx << "(-|" << (seg[inVehIDx].Trip[inTripIdx].leaveSP-problem->nodeSP[seg[inVehIDx].Trip[inTripIdx].startNodeIdx].load)  << "|" << seg[inVehIDx].Trip[inTripIdx].leaveSP << ")->";
	} else
	{
		cout << seg[inVehIDx].Trip[inTripIdx].startNodeIdx << "(-|" << seg[inVehIDx].Trip[inTripIdx].leaveSP << ")->";
	}
#endif
	curC = seg[inVehIDx].Trip[inTripIdx].firstCus;
	int preNode = seg[inVehIDx].Trip[inTripIdx].startNodeIdx;
	double db_TimePoint = dbStartTime;//seg[inVehIDx].Trip[inTripIdx].leaveSP;
	while (curC > 0)
	{
		db_TimePoint += problem->c[preNode][curC];
#if Q_WAITING_AT_CUST
		if (db_TimePoint > problem->node[curC].eTW)
#else
		if(!PDSINRANGE(db_TimePoint, problem->node[curC].sTW, problem->node[curC].eTW))
#endif
		{
#if Q_DEBUG_VALID_TRIP
			cout << "[ERR]: " << db_TimePoint << " not in range [ " << problem->node[curC].sTW << "," << problem->node[curC].eTW << "]" << endl;getchar();
			Show_A_Trip(inVehIDx, inTripIdx);
#endif
			return false;
		}

#if Q_WAITING_AT_CUST
		db_TimePoint = PDS_MAX(db_TimePoint, problem->node[curC].sTW) + problem->node[curC].duration;
#else
		db_TimePoint += problem->node[curC].duration;
#endif	

#if Q_DEBUG_VALID_TRIP
		cout << curC << "(" << (db_TimePoint-problem->node[curC].duration) << "|" << (db_TimePoint) << ")" << "->";
#endif
		preNode = curC;
		curC = nextArr[curC];
	}

	// Consider Waiting at WS before move to SP
	if (seg[inVehIDx].Trip[inTripIdx].waitingS != -1)
	{
		db_TimePoint += problem->c[seg[inVehIDx].Trip[inTripIdx].lastCus][seg[inVehIDx].Trip[inTripIdx].waitingS];
		if (TRIP_PICKUP == inTripType) //pickup
		{
			dbTimeTmp = seg[inVehIDx].Trip[inTripIdx].endS - problem->nodeSP[seg[inVehIDx].Trip[inTripIdx].endNodeIdx].unload;
		} else
			dbTimeTmp = seg[inVehIDx].Trip[inTripIdx].endS;
#if Q_DEBUG_VALID_TRIP
		cout << seg[inVehIDx].Trip[inTripIdx].waitingS << "(" << db_TimePoint << "|" << (dbTimeTmp-problem->c[seg[inVehIDx].Trip[inTripIdx].waitingS][seg[inVehIDx].Trip[inTripIdx].endNodeIdx]) << ")->";
#endif
	}

#if Q_DEBUG_VALID_TRIP
	if (TRIP_PICKUP == inTripType)
	{
		cout << seg[inVehIDx].Trip[inTripIdx].endNodeIdx << "(" << (seg[inVehIDx].Trip[inTripIdx].endS-problem->nodeSP[seg[inVehIDx].Trip[inTripIdx].endNodeIdx].unload) << "|" << seg[inVehIDx].Trip[inTripIdx].endS << "|-)" << endl;
	} else
	{
		cout << seg[inVehIDx].Trip[inTripIdx].endNodeIdx << "(" << seg[inVehIDx].Trip[inTripIdx].endS << "|-)" << endl;
	}
#endif

	if (TRIP_C2C == inTripType)
	{
		if (seg[inVehIDx].Trip[inTripIdx].numCus %2 ==1)
		{
			cout << "Valid_A_Trip::The total node of C2C trip can not odd *ln" << __LINE__ << endl; getchar();
			Show_A_Trip(inVehIDx, inTripIdx);
			return false;
		}
		
		// Check LIFO policy
		//for (int i = 1; i <= seg[inVehIDx].Trip[inTripIdx].numCus/2; i++)
		{
			//if (arrTripTmp[i] + nOrder != arrTripTmp[seg[inVehIDx].Trip[inTripIdx].numCus-i+1])
			if (false == IsLIFO_Q(arrTripTmp, inTripSzTmp))
			{
#if Q_DEBUG_VALID_TRIP
				cout << "**LIFO policy**" << endl;

				cout << "Valid_A_Trip::**LIFO policy**" << endl; getchar();
				Show_A_Trip(inVehIDx, inTripIdx);
#endif
				return false;
			}
		}
	}	

	seg[inVehIDx].Trip[inTripIdx].cost = dbTransportCost;
	
	// Check assignment of PICKUP/DELVERY to SP
	int inAssignedSP = -1;
	switch (inTripType)
	{
	case TRIP_PICKUP:
		inAssignedSP = seg[inVehIDx].Trip[inTripIdx].endNodeIdx;
		break;
	case TRIP_DELIVERY:
		inAssignedSP = seg[inVehIDx].Trip[inTripIdx].startNodeIdx;
		break;		
	default:
		return true;
	}

		/*arrTripTmp[inTripSzTmp]*/
	if (TRIP_PICKUP == inTripType)
	{
		for (int i = 1; i <= inTripSzTmp; i++)
		{
			bool isFound = false;
			for (int j = 1; j <= problem->node[arrTripTmp[i]].numSP; j++)
			{
				if (problem->node[arrTripTmp[i]].sp[j] == inAssignedSP)
				{
					isFound = true;
					break;
				}
			 }
			if (false == isFound)
			{
				cout << "Valid_A_Trip::PICKUP demand " << arrTripTmp[i] << " doesnot assign to SP " << inAssignedSP << " *ln" << __LINE__ << endl; getchar(); 
				Show_A_Trip(inVehIDx, inTripIdx);
				return false;
			}

		}
	}
	else if (TRIP_DELIVERY == inTripType)
	{
		for (int i = 1; i <= inTripSzTmp; i++)
		{
			if (problem->node[arrTripTmp[i]].zone != inAssignedSP)
			{
				cout << "Valid_A_Trip::DELIVERY demand " << arrTripTmp[i] << " doesnot assign to SP " << inAssignedSP << endl; getchar(); 
				Show_A_Trip(inVehIDx, inTripIdx);
				return false;
			}
		}
	}

	return true;
}
/*
 * A trip includes a sequence of one type customer demands (pickup/delivery/c2c)
 * Validate trip: vehicle capacity, time windows, LIFO policy (C2C leg)
 */
bool Solution::Valid_A_Trip(int inVehIDx, int inTripIdx)
{
	int curC;
	int inTripType = seg[inVehIDx].Trip[inTripIdx].Type;
	double dbTimeTmp;
	int inNodeType;
	int inTripSzTmp;
	int arrTripTmp[2000];
	int inCapacity;
	double dbTransportCost = 0;

	//if ((inVehIDx == 2) && (inTripIdx==3)) {
	//	cout << "Unit test";
	//}
	// Rebuild trip
	inTripSzTmp = 0;
	inCapacity = 0;

	curC = seg[inVehIDx].Trip[inTripIdx].firstCus;
	while (curC > 0)
	{
		inCapacity += problem->node[curC].capacity;
		inTripSzTmp++;
		arrTripTmp[inTripSzTmp] = curC;
		curC = nextArr[curC];
	}

	// Check vehicle capacity
	if (inCapacity > Q)
	{
		cout << "Valid_A_Trip::Overload!" << endl; getchar();
		Show_A_Trip(inVehIDx, inTripIdx);
		return false;
	}
	seg[inVehIDx].Trip[inTripIdx].capacity = inCapacity;

	// Get transportation cost
	//dbTransportCost += problem->c[seg[inVehIDx].Trip[inTripIdx].startNodeIdx][seg[inVehIDx].Trip[inTripIdx].firstCus];
	for (int i = 1; i < inTripSzTmp; i++)
	{
		dbTransportCost += problem->c[arrTripTmp[i]][arrTripTmp[i+1]];
	}
	//dbTransportCost += problem->c[seg[inVehIDx].Trip[inTripIdx].lastCus][seg[inVehIDx].Trip[inTripIdx].endNodeIdx];

	//Check startNodeIdx, endNodeIdx of specific trip
	if (TRIP_PICKUP == inTripType)
	{
		/*
		 * Because of PICKUP trip so:
		 *	- startNodeIdx can be Depot/SP/delivery/c2c-delivery
		 *  - endNodeIdx has to be SP
		 */
		inNodeType = Get_Node_Type(seg[inVehIDx].Trip[inTripIdx].startNodeIdx);
		switch (inNodeType)
		{
			case NODE_DEPOT:
			case NODE_SUPPLY_POINT:
			case NODE_DELIVERY: 
			case NODE_C2C_DELIVERY:
				break;
			default:
//#if Q_DEBUG_VALID_TRIP
				cout << "Valid_A_Trip::Invalid startNodeIdx of PICKUP trip" << endl; getchar();
//#endif				
				Show_A_Trip(inVehIDx, inTripIdx);
				return false;
		}
		
		inNodeType = Get_Node_Type(seg[inVehIDx].Trip[inTripIdx].endNodeIdx);
		switch (inNodeType)
		{
			case NODE_SUPPLY_POINT:
				break;
			default:
//#if Q_DEBUG_VALID_TRIP
				cout << "Valid_A_Trip::Invalid endNodeIdx of PICKUP trip *l" << __LINE__  << endl; getchar();
//#endif
				Show_A_Trip(inVehIDx, inTripIdx);
				return false;
		}
	} else if (TRIP_DELIVERY == inTripType)
	{
		/*
		 * Because of DELIVERY trip so:
		 *	- startNodeIdx can be SP 
		 *  - endNodeIdx has to be Depot/SP/pickup/c2c-pickup
		 */
		inNodeType = Get_Node_Type(seg[inVehIDx].Trip[inTripIdx].startNodeIdx);
		switch (inNodeType)
		{
			case NODE_SUPPLY_POINT:
				break;
			default:
//#if Q_DEBUG_VALID_TRIP
				cout << "Valid_A_Trip::Invalid startNodeIdx of DELIVERY trip" << endl; getchar();
//#endif				
				Show_A_Trip(inVehIDx, inTripIdx);
				return false;
		}
		
		inNodeType = Get_Node_Type(seg[inVehIDx].Trip[inTripIdx].endNodeIdx);
		switch (inNodeType)
		{
			case NODE_DEPOT:
			case NODE_SUPPLY_POINT:
			case NODE_PICKUP: 
			case NODE_C2C_PICKUP:
				break;
			default:
//#if Q_DEBUG_VALID_TRIP
				cout << "Valid_A_Trip::Invalid endNodeIdx of DELIVERY trip *l" << __LINE__ << endl; getchar();
//#endif				
				Show_A_Trip(inVehIDx, inTripIdx);
				return false;
		}

	} else if (TRIP_C2C == inTripType)
	{
		/*
		 * Because of C2C trip so:
		 *	- startNodeIdx can be Depot/SP/delivery/c2c-delivery 
		 *  - endNodeIdx has to be Depot/SP/pickup/c2c-pickup
		 */
		inNodeType = Get_Node_Type(seg[inVehIDx].Trip[inTripIdx].startNodeIdx);
		switch (inNodeType)
		{
			case NODE_SUPPLY_POINT:
			case NODE_DEPOT:
			case NODE_DELIVERY:
			case NODE_C2C_DELIVERY:
				break;
			default:
//#if Q_DEBUG_VALID_TRIP
				cout << "Valid_A_Trip::Invalid startNodeIdx of C2C trip" << endl; getchar();
//#endif				
				Show_A_Trip(inVehIDx, inTripIdx);
				return false;
		}
		
		inNodeType = Get_Node_Type(seg[inVehIDx].Trip[inTripIdx].endNodeIdx);
		switch (inNodeType)
		{
			case NODE_SUPPLY_POINT:
			case NODE_DEPOT:
			case NODE_PICKUP:
			case NODE_C2C_PICKUP:
				break;
			default:
//#if Q_DEBUG_VALID_TRIP
				cout << "Valid_A_Trip::Invalid endNodeIdx of C2C trip *l" << __LINE__ << endl; getchar();
//#endif
				Show_A_Trip(inVehIDx, inTripIdx);
				return false;
		}

	}

#if Q_DEBUG_VALID_TRIP
	if (TRIP_DELIVERY == inTripType)
	{
		cout << seg[inVehIDx].Trip[inTripIdx].startNodeIdx << "(-|" << (seg[inVehIDx].Trip[inTripIdx].leaveSP-problem->nodeSP[seg[inVehIDx].Trip[inTripIdx].startNodeIdx].load)  << "|" << seg[inVehIDx].Trip[inTripIdx].leaveSP << ")->";
	} else
	{
		cout << seg[inVehIDx].Trip[inTripIdx].startNodeIdx << "(-|" << seg[inVehIDx].Trip[inTripIdx].leaveSP << ")->";
	}
#endif
	curC = seg[inVehIDx].Trip[inTripIdx].firstCus;
	int preNode = seg[inVehIDx].Trip[inTripIdx].startNodeIdx;
	double db_TimePoint = seg[inVehIDx].Trip[inTripIdx].leaveSP;
	while (curC > 0)
	{
		db_TimePoint += problem->c[preNode][curC];
#if Q_WAITING_AT_CUST
		if (db_TimePoint > problem->node[curC].eTW)
#else
		if(!PDSINRANGE(db_TimePoint, problem->node[curC].sTW, problem->node[curC].eTW))
#endif
		{
#if Q_DEBUG_VALID_TRIP
			cout << "[ERR]: " << db_TimePoint << " not in range [ " << problem->node[curC].sTW << "," << problem->node[curC].eTW << "]" << endl;getchar();
			Show_A_Trip(inVehIDx, inTripIdx);
#endif
			return false;
		}

#if Q_WAITING_AT_CUST
		db_TimePoint = PDS_MAX(db_TimePoint, problem->node[curC].sTW) + problem->node[curC].duration;
#else
		db_TimePoint += problem->node[curC].duration;
#endif	

#if Q_DEBUG_VALID_TRIP
		cout << curC << "(" << (db_TimePoint-problem->node[curC].duration) << "|" << (db_TimePoint) << ")" << "->";
#endif
		preNode = curC;
		curC = nextArr[curC];
	}

	// Consider Waiting at WS before move to SP
	if (seg[inVehIDx].Trip[inTripIdx].waitingS != -1)
	{
		db_TimePoint += problem->c[seg[inVehIDx].Trip[inTripIdx].lastCus][seg[inVehIDx].Trip[inTripIdx].waitingS];
		if (TRIP_PICKUP == inTripType) //pickup
		{
			dbTimeTmp = seg[inVehIDx].Trip[inTripIdx].endS - problem->nodeSP[seg[inVehIDx].Trip[inTripIdx].endNodeIdx].unload;
		} else
			dbTimeTmp = seg[inVehIDx].Trip[inTripIdx].endS;
#if Q_DEBUG_VALID_TRIP
		cout << seg[inVehIDx].Trip[inTripIdx].waitingS << "(" << db_TimePoint << "|" << (dbTimeTmp-problem->c[seg[inVehIDx].Trip[inTripIdx].waitingS][seg[inVehIDx].Trip[inTripIdx].endNodeIdx]) << ")->";
#endif
	}

#if Q_DEBUG_VALID_TRIP
	if (TRIP_PICKUP == inTripType)
	{
		cout << seg[inVehIDx].Trip[inTripIdx].endNodeIdx << "(" << (seg[inVehIDx].Trip[inTripIdx].endS-problem->nodeSP[seg[inVehIDx].Trip[inTripIdx].endNodeIdx].unload) << "|" << seg[inVehIDx].Trip[inTripIdx].endS << "|-)" << endl;
	} else
	{
		cout << seg[inVehIDx].Trip[inTripIdx].endNodeIdx << "(" << seg[inVehIDx].Trip[inTripIdx].endS << "|-)" << endl;
	}
#endif

	if (TRIP_C2C == inTripType)
	{
		if (seg[inVehIDx].Trip[inTripIdx].numCus %2 ==1)
		{
			cout << "Valid_A_Trip::The total node of C2C trip can not odd *ln" << __LINE__ << endl; getchar();
			Show_A_Trip(inVehIDx, inTripIdx);
			return false;
		}
		
		// Check LIFO policy
		//for (int i = 1; i <= seg[inVehIDx].Trip[inTripIdx].numCus/2; i++)
		{
			//if (arrTripTmp[i] + nOrder != arrTripTmp[seg[inVehIDx].Trip[inTripIdx].numCus-i+1])
			if (false == IsLIFO_Q(arrTripTmp, inTripSzTmp))
			{
#if Q_DEBUG_VALID_TRIP
				cout << "**LIFO policy**" << endl;

				cout << "Valid_A_Trip::**LIFO policy**" << endl; getchar();
				Show_A_Trip(inVehIDx, inTripIdx);
#endif
				return false;
			}
		}
	}	

	seg[inVehIDx].Trip[inTripIdx].cost = dbTransportCost;
	
	// Check assignment of PICKUP/DELVERY to SP
	int inAssignedSP = -1;
	switch (inTripType)
	{
	case TRIP_PICKUP:
		inAssignedSP = seg[inVehIDx].Trip[inTripIdx].endNodeIdx;
		break;
	case TRIP_DELIVERY:
		inAssignedSP = seg[inVehIDx].Trip[inTripIdx].startNodeIdx;
		break;		
	default:
		return true;
	}

		/*arrTripTmp[inTripSzTmp]*/
	if (TRIP_PICKUP == inTripType)
	{
		for (int i = 1; i <= inTripSzTmp; i++)
		{
			bool isFound = false;
			for (int j = 1; j <= problem->node[arrTripTmp[i]].numSP; j++)
			{
				if (problem->node[arrTripTmp[i]].sp[j] == inAssignedSP)
				{
					isFound = true;
					break;
				}
			 }
			if (false == isFound)
			{
				cout << "Valid_A_Trip::PICKUP demand " << arrTripTmp[i] << " doesnot assign to SP " << inAssignedSP  << " *ln" << __LINE__ << endl; getchar(); 
				Show_A_Trip(inVehIDx, inTripIdx);
				return false;
			}

		}
	}
	else if (TRIP_DELIVERY == inTripType)
	{
		for (int i = 1; i <= inTripSzTmp; i++)
		{
			if (problem->node[arrTripTmp[i]].zone != inAssignedSP)
			{
				cout << "Valid_A_Trip::DELIVERY demand " << arrTripTmp[i] << " doesnot assign to SP " << inAssignedSP << endl; getchar(); 
				Show_A_Trip(inVehIDx, inTripIdx);
				return false;
			}
		}
	}

	return true;
}

// START IMPLEMENTATION of Neighborhood graph
void Solution::Init_Neighborhood_Graph()
{
	int inTotalNode = nP + nD + 2*nOrder + nSP + nWS + 1;

	for (int i = 1; i <= inTotalNode; i++)
	{
		for (int j= 1; j <= inTotalNode; j++)
		{
			f_star[i][j] = PDS_INFINITY;
		}
	}
}

/*
 * Neighbor Graph stores the historical information
 * f_start(i, j) of an edge (i, j) is the best fitness so far, in the solution used ede (i, j)
 */
bool Solution::Update_Neighborhood_Graph(double dbBestFitness)
{
	K_Elite eliteCandidate;

	eliteCandidate.inNodeTot = 0;
	for (int i = 1; i <= numVeh; i++)
	{
		for (int j = 1; j <= seg[i].numTrips; j++)
		{
			eliteCandidate.inNodeTot += 1;
			eliteCandidate.arrStartNode[eliteCandidate.inNodeTot] = seg[i].Trip[j].startNodeIdx;
			eliteCandidate.arrEndNode[eliteCandidate.inNodeTot] = seg[i].Trip[j].firstCus;
			if (f_star[seg[i].Trip[j].startNodeIdx][seg[i].Trip[j].firstCus] > dbBestFitness)
			{
				f_star[seg[i].Trip[j].startNodeIdx][seg[i].Trip[j].firstCus] = dbBestFitness;
			}

			int curC = seg[i].Trip[j].firstCus;
			while (curC > 0)
			{
				curC = nextArr[curC];
				if (curC > 0)
				{
					eliteCandidate.inNodeTot += 1;
					eliteCandidate.arrStartNode[eliteCandidate.inNodeTot] = eliteCandidate.arrEndNode[eliteCandidate.inNodeTot-1];
					eliteCandidate.arrEndNode[eliteCandidate.inNodeTot] = curC;
					if (f_star[eliteCandidate.arrEndNode[eliteCandidate.inNodeTot-1]][curC] > dbBestFitness)
					{
						f_star[eliteCandidate.arrEndNode[eliteCandidate.inNodeTot-1]][curC] = dbBestFitness;
					}
				}
			}
			eliteCandidate.inNodeTot += 1;
			eliteCandidate.arrStartNode[eliteCandidate.inNodeTot] = seg[i].Trip[j].lastCus;
			eliteCandidate.arrEndNode[eliteCandidate.inNodeTot] = seg[i].Trip[j].endNodeIdx;
			if (f_star[seg[i].Trip[j].lastCus][seg[i].Trip[j].endNodeIdx] > dbBestFitness)
			{
				f_star[seg[i].Trip[j].lastCus][seg[i].Trip[j].endNodeIdx] = dbBestFitness;
			}
		}
	}

	return true;
}

bool Solution::Get_Incident_Of_Node(int inNodeIdx, int *inPredNodeIdx, int *inSucNodeIdx)
{
   int i,j,curC, pred, suc;

   for (i = 1; i <= numVeh; i++) // to consildation, we do not use 0 index.
   {
	   for (j = 1; j <= seg[i].numTrips; j++)
	   {
			curC = seg[i].Trip[j].firstCus;
			pred = curC;
			if (inNodeIdx == seg[i].Trip[j].firstCus)
			{
				*inPredNodeIdx = -1;
				if (inNodeIdx == seg[i].Trip[j].lastCus)
				{
					*inSucNodeIdx = -1;
				} else 
				{
					*inSucNodeIdx = nextArr[curC];
				}

				return true;
			}

			while (curC > 0)
			{
				curC = nextArr[curC];
				if (curC == inNodeIdx)
				{
					*inPredNodeIdx = pred;
					if (inNodeIdx == seg[i].Trip[j].lastCus)
					{
						*inSucNodeIdx = -1;
					}
					else
					{
						*inSucNodeIdx = nextArr[curC];
					}

					return true;
				}
				pred = curC;
			}

	   }
   }

   *inPredNodeIdx = -1;
   *inSucNodeIdx = -1;

	return false;
}
double Solution::Calc_Score_Neighborhood_Graph(int inNodeIdx)
{
	double dbScore = 0;
	int inTotalNode = nP + nD + 2*nOrder + nSP + nWS +1;
	int inPredNodeIdx, inSucNodeIdx;

	int inNodeType = Get_Node_Type(inNodeIdx);

	if ((NODE_PICKUP == inNodeType) || (NODE_DELIVERY == inNodeType))
	{

		if (true == Get_Incident_Of_Node(inNodeIdx, &inPredNodeIdx, &inSucNodeIdx))
		{
			if ((f_star[inPredNodeIdx][inNodeIdx] < PDS_INFINITY) && (inPredNodeIdx > 0))
				dbScore += f_star[inPredNodeIdx][inNodeIdx];

			if ((f_star[inNodeIdx][inSucNodeIdx] < PDS_INFINITY) && (inSucNodeIdx > 0))
				dbScore += f_star[inNodeIdx][inSucNodeIdx];
		}
	} else if (NODE_C2C_PICKUP == inNodeType)
	{

		if (true == Get_Incident_Of_Node(inNodeIdx, &inPredNodeIdx, &inSucNodeIdx))
		{
			if ((f_star[inPredNodeIdx][inNodeIdx] < PDS_INFINITY) && (inPredNodeIdx > 0))
				dbScore += f_star[inPredNodeIdx][inNodeIdx];

			if ((f_star[inNodeIdx][inSucNodeIdx] < PDS_INFINITY) && (inSucNodeIdx > 0))
				dbScore += f_star[inNodeIdx][inSucNodeIdx];
		}

		if (true == Get_Incident_Of_Node(inNodeIdx+nOrder, &inPredNodeIdx, &inSucNodeIdx))
		{
			if ((f_star[inPredNodeIdx][inNodeIdx+nOrder] < PDS_INFINITY) && (inPredNodeIdx > 0))
				dbScore += f_star[inPredNodeIdx][inNodeIdx+nOrder];

			if ((f_star[inNodeIdx+nOrder][inSucNodeIdx] < PDS_INFINITY) && (inSucNodeIdx > 0))
				dbScore += f_star[inNodeIdx+nOrder][inSucNodeIdx];
		}
	} else
	{
		cout << "Calc_Score_Neighborhood_Graph:: Bad node type" << endl; getchar();
		return -1;
	}

	return dbScore;
}
// END OF IMPLEMENTATION of Neighborhood graph

// START IMPLEMENTATION OF ELITE SET >>>
int Solution::Calc_Relatedness_Based_Mem(int inNodeIdx1, int inNodeIdx2)
{
	int score = 0;

	for (int i = 1; i <= g_inEliteSz; i++)
	{
		if (eliteSet[i].inNodeTot == -1)
		{
			break;
		}

		for (int j = 1; j <= eliteSet[i].inNodeTot; j++)
		{
			if ((eliteSet[i].arrStartNode[j] == inNodeIdx1) && (eliteSet[i].arrEndNode[j] == inNodeIdx2))
			{
				score++;
			}
		}
	}
	return score;
}

// The hamming distance between two legs of the same type
double Solution::Calc_Hamming_Dis_Leg(int inVehIdx1, int inTripIdx1, int inVehIdx2, int inTripIdx2)
{
	double dbStartFirstCus1, dbStartEndCus1;
	double dbStartFirstCus2, dbStartEndCus2;
	double dbHammingDis = 0;

	// 2 legs have same type
	if (seg[inVehIdx1].Trip[inTripIdx1].Type != seg[inVehIdx2].Trip[inTripIdx2].Type)
	{
		cout << " has to same type " << endl;
		return PDS_INFINITY;
	}

	Get_Time_For_Hamming_Dis_Calc(inVehIdx1, inTripIdx1, &dbStartFirstCus1, &dbStartEndCus1);
#if Q_D_HAMMING_DIS_LEG	
	Show_A_Trip(inVehIdx1, inTripIdx1);
	cout << "Vehicle " << inVehIdx1 << " trip " << inTripIdx1 << " has " << dbStartFirstCus1 << "/" << dbStartEndCus1 << endl;
#endif

	Get_Time_For_Hamming_Dis_Calc(inVehIdx2, inTripIdx2, &dbStartFirstCus2, &dbStartEndCus2);
#if Q_D_HAMMING_DIS_LEG	
	Show_A_Trip(inVehIdx2, inTripIdx2);
	cout << "Vehicle " << inVehIdx2 << " trip " << inTripIdx2 << " has " << dbStartFirstCus2 << "/" << dbStartEndCus2 << endl;
#endif

	dbHammingDis = fabs(dbStartFirstCus1 - dbStartFirstCus2);
	dbHammingDis += fabs(dbStartEndCus1 - dbStartEndCus2);

	return dbHammingDis;
}

// The Hamming distance between solution z1 and z2 is the total of shared edges.
int Solution::Calc_Hamming_Dis(K_Elite z1, K_Elite z2)
{
	int curC;
	int inEdgeSz1, inEdgeSz2;
	int arrStxEdge1[2000], arrStxEdge2[2000];
	int arrEndEdge1[2000], arrEndEdge2[2000];

	////Re-build path for solution z1
	//for (int j = 1; j <= z1.numTrips; j++)
	//{
	//	inEdgeSz1 = 1;
	//	arrStxEdge1[inEdgeSz1] = z1.Trip[j].startNodeIdx;
	//	arrEndEdge1[inEdgeSz1] = z1.Trip[j].firstCus;

	//	curC = z1.Trip[j].firstCus;
	//	while (curC > 0)
	//	{
	//		curC = nextArr[curC];
	//		if (curC > 0)
	//		{
	//			inEdgeSz1++;
	//			arrStxEdge1[inEdgeSz1] = arrEndEdge1[inEdgeSz1-1];
	//			arrEndEdge1[inEdgeSz1] = curC;
	//		}
	//	}
	//	inEdgeSz1 += 1;
	//	arrStxEdge1[inEdgeSz1] = z1.Trip[j].lastCus;
	//	arrEndEdge1[inEdgeSz1] = z1.Trip[j].endNodeIdx;
	//}


	// Count shared edges as Hamming distance
	int inHammDis = 0;
	for (int i = 1; i <= z1.inNodeTot; i++)
	{
		for (int j = 1; j <= z2.inNodeTot; j++)
		{
			if (z1.arrStartNode[i] == z2.arrStartNode[j]) 
			{
				if (z1.arrEndNode[i] != z2.arrEndNode[j])
				inHammDis++;
				break;
			}
		}
	}

	return inHammDis;
}


// Initiate Elite set
void Solution::Init_Elite_Set()
{
	for (int i = 1; i <= MAX_ELITE_SET; i++)
	{
		eliteSet[i].inNodeTot = -1;
	}
}
void Solution::vdDumpEliseSet()
{
	ofstream fd;
	fd.open("master.log", ios::out | ios::app); 
     if (!fd){	 
		 cout << "\n\tInput file not found !!!!!!" << endl; getchar();
		 exit(-1);
	 }

	for (int i = 1; i <= MAX_ELITE_SET; i++)
	{
		if (-1 == eliteSet[i].inNodeTot)
			break;

		fd << "\t Elite "  << i << ":" << endl;
		fd <<  "\t Node: " << eliteSet[i].inNodeTot << endl;
		
		for (int j = 1; j <= eliteSet[i].inNodeTot; j++)
		{
			fd << "(" << eliteSet[i].arrStartNode[j] << "," << eliteSet[i].arrEndNode[j] << ") ";
			if (0 == eliteSet[i].arrEndNode[j])
				fd << endl;
		}

		fd << endl;
	}

}
bool Solution::Update_Elite_Set()
{
	bool isFull = true;
	int inEliteIdx;
	K_Elite eliteCandidate;
	int curC;
	int inPred, inNext;

	// Convert the best solution to Elite format
	eliteCandidate.inNodeTot = 0;
	for (int i = 1; i <= numVeh; i++)
	{
		inPred = 0; inNext = 0;
		for (int j = 1; j <= seg[i].numTrips; j++)
		{
			if ((inPred == seg[i].Trip[j].startNodeIdx) && (inNext == seg[i].Trip[j].firstCus))
			{
				eliteCandidate.arrStartNode[eliteCandidate.inNodeTot] = seg[i].Trip[j].startNodeIdx;
				eliteCandidate.arrEndNode[eliteCandidate.inNodeTot] = seg[i].Trip[j].firstCus;
				inPred = seg[i].Trip[j].startNodeIdx;
				inNext =seg[i].Trip[j].firstCus;
			} else
			{
				eliteCandidate.inNodeTot += 1;
				eliteCandidate.arrStartNode[eliteCandidate.inNodeTot] = seg[i].Trip[j].startNodeIdx;
				eliteCandidate.arrEndNode[eliteCandidate.inNodeTot] = seg[i].Trip[j].firstCus;
				inPred = seg[i].Trip[j].startNodeIdx;
				inNext =seg[i].Trip[j].firstCus;
			}

			curC = seg[i].Trip[j].firstCus;
			while (curC > 0)
			{
				curC = nextArr[curC];
				if (curC > 0)
				{
					if ((inPred == eliteCandidate.arrEndNode[eliteCandidate.inNodeTot-1]) && (inNext == curC))
					{
						eliteCandidate.arrStartNode[eliteCandidate.inNodeTot] = eliteCandidate.arrEndNode[eliteCandidate.inNodeTot-1];
						eliteCandidate.arrEndNode[eliteCandidate.inNodeTot] = curC;
					} else 
					{
						eliteCandidate.inNodeTot += 1;
						eliteCandidate.arrStartNode[eliteCandidate.inNodeTot] = eliteCandidate.arrEndNode[eliteCandidate.inNodeTot-1];
						eliteCandidate.arrEndNode[eliteCandidate.inNodeTot] = curC;
					}

					inPred = eliteCandidate.arrEndNode[eliteCandidate.inNodeTot-1];
					inNext = curC;
				}
			}

			if ((inPred == seg[i].Trip[j].lastCus) && (inNext == seg[i].Trip[j].endNodeIdx))
			{
				eliteCandidate.arrStartNode[eliteCandidate.inNodeTot] = seg[i].Trip[j].lastCus;
				eliteCandidate.arrEndNode[eliteCandidate.inNodeTot] = seg[i].Trip[j].endNodeIdx;
				inPred = seg[i].Trip[j].lastCus;
				inNext = seg[i].Trip[j].endNodeIdx;

			} else
			{
				eliteCandidate.inNodeTot += 1;
				eliteCandidate.arrStartNode[eliteCandidate.inNodeTot] = seg[i].Trip[j].lastCus;
				eliteCandidate.arrEndNode[eliteCandidate.inNodeTot] = seg[i].Trip[j].endNodeIdx;
				inPred = seg[i].Trip[j].lastCus;
				inNext = seg[i].Trip[j].endNodeIdx;

			}
		}
	}

	inEliteIdx = -1;
	// Check if Elite set is full or not
	for (int i = 1; i <= g_inEliteSz; i++)
	{
		if (-1 == eliteSet[i].inNodeTot)
		{
			isFull = false;
			inEliteIdx = i;
			break;
		}
	}

	if (false == isFull)
	{
		// Insert at inEliteIdx
	} else  // full!s
	{
		inEliteIdx = -1;
		// Elimate the nearest elite one to the best solution
		int inSmallestHammDis = PDS_INFINITY_INT;
		for (int i = 1; i <= g_inEliteSz; i++)
		{
			int inHamDisTmp = Calc_Hamming_Dis(eliteCandidate, eliteSet[i]);
			if (inHamDisTmp < inSmallestHammDis)
			{
				inSmallestHammDis = inHamDisTmp;
				inEliteIdx = i;
			}
		}
	}

	if (-1 == inEliteIdx)
	{
		cout << "Update_Elite_Set:: get Elite idx failed" ; getchar();
		return false;
	}

	// Insert at inEliteIdx
	memcpy(&eliteSet[inEliteIdx], &eliteCandidate, sizeof(K_Elite));

	return true;
}
// END OF IMPLEMENTATION OF ELITE SET <<<

/*
 * Calculate the relatedness betweentwo customer demands inNodeIdx1 and inNodeIdx2
 * PICKUP/DELIVERY used a same formulation
 * C2C used sligtly diffrence
 * TODO: Can be extended to calc. differnces
 */
double Solution::Calc_Relatedness(int inNodeIdx1, int inNodeIdx2, double dbMaxCij, double dbDeltaTime, double dbDeltaCap)
{
	double dbAlpha1, dbAlpha2, dbAlpha3, dbAlpha4;
	int inT_ij;  // =0 if i and j are same leg; 1 - otherwise
	int inNodeType1;
	int inNodeType2;
	double dbTime2Served1;
	int inVehicleIdx1;
	int inTripIdx1;
	double dbTime2Served2;
	int inVehicleIdx2;
	int inTripIdx2;
	double dbTime2Served3;
	int inVehicleIdx3;
	int inTripIdx3;
	double dbTime2Served4;
	int inVehicleIdx4;
	int inTripIdx4;
	double dbRelateness = 0;

	dbAlpha1 = g_dbAlpha1;
	dbAlpha2 = g_dbAlpha2;
	dbAlpha3 = g_dbAlpha3;
	dbAlpha4 = g_dbAlpha4;

	// Those nodes must be same customer-demands type
	inNodeType1 = Get_Node_Type(inNodeIdx1);
	inNodeType2 = Get_Node_Type(inNodeIdx2);
	if (inNodeType1 != inNodeType2)
	{
		cout << "Calc_Relatedness:: has to same nodeType" << endl; getchar();
		return -PDS_INFINITY;
	}
	switch (inNodeType1)
	{
	case NODE_PICKUP:
	case NODE_DELIVERY:
	case NODE_C2C_PICKUP:
	//case NODE_C2C_DELIVERY:
		break;
	default:
		cout << "Calc_Relatedness:: invalid nodeType" << endl; getchar();
		return -PDS_INFINITY;
	}

	/*
	 * Delivery-customer demands must have same SP
	 * Pickup-customer demands must share at least one SP
	 */
	if (false == Check_Shared_SP(inNodeIdx1, inNodeIdx2))
		return 0; 

	// Get node info
	if (false == Get_Node_Info(inNodeIdx1, &dbTime2Served1, &inVehicleIdx1, &inTripIdx1))
	{
#if Q_DEBUG_CALC_RELATEDNESS
		cout << "Calc_Relatedness:: Cannot get node info" << endl; getchar();
#endif
		return -PDS_INFINITY;
	}
	if (false == Get_Node_Info(inNodeIdx2, &dbTime2Served2, &inVehicleIdx2, &inTripIdx2))
	{
#if Q_DEBUG_CALC_RELATEDNESS
		cout << "Calc_Relatedness:: Cannot get node info" << endl; getchar();
#endif
		return -PDS_INFINITY;
	}
	if (NODE_C2C_PICKUP == inNodeType1)
	{
		if (false == Get_Node_Info(inNodeIdx1+nOrder, &dbTime2Served3, &inVehicleIdx3, &inTripIdx3))
		{
#if Q_DEBUG_CALC_RELATEDNESS
			cout << "Calc_Relatedness:: Cannot get node info" << endl; getchar();
#endif
			return -PDS_INFINITY;
		}
		if (false == Get_Node_Info(inNodeIdx2+nOrder, &dbTime2Served4, &inVehicleIdx4, &inTripIdx4))
		{
#if Q_DEBUG_CALC_RELATEDNESS
			cout << "Calc_Relatedness:: Cannot get node info" << endl; getchar();
#endif
			return -PDS_INFINITY;
		}
	}

	// Apply formulation based on type of node
	if ((inVehicleIdx1 == inVehicleIdx2) && (inTripIdx1 == inTripIdx2)){ // same leg
		inT_ij = 0;
	} else
	{
		inT_ij = 1;
	}

	double dbTmp;
	if (NODE_C2C_PICKUP != inNodeType1)
	{
		// R(i,j) = alpha1*c_{i,j} + alpha2*abs(t_i-t_j) + alpha3*T_{i,j} + alpha4*abs(q_i-q_j)
		// i: inNodeIdx1, j: inNodeIdx2
		dbRelateness = dbAlpha1 * problem->c[inNodeIdx1][inNodeIdx2]; dbRelateness /= dbMaxCij;

		dbTmp = dbAlpha2 * fabs(dbTime2Served1-dbTime2Served2); dbTmp /= dbDeltaTime;
		dbRelateness += dbTmp;

		dbRelateness += dbAlpha3 * inT_ij;
		
		dbTmp = dbAlpha4 * abs(problem->node[inNodeIdx1].capacity - problem->node[inNodeIdx2].capacity); dbTmp /= dbDeltaCap;
		dbRelateness += dbTmp;
		
		return dbRelateness;
	} else
	{
		dbRelateness = dbAlpha1 * problem->c[inNodeIdx1][inNodeIdx2]; dbRelateness /= dbMaxCij;

		dbTmp = dbAlpha1 * problem->c[inNodeIdx1+nOrder][inNodeIdx2+nOrder]; dbTmp /= dbMaxCij;
		dbRelateness += dbTmp;
		
		dbTmp = dbAlpha2 * fabs(dbTime2Served1-dbTime2Served2); dbTmp /= dbDeltaTime;
		dbRelateness += dbTmp;		
		dbTmp = dbAlpha2 * fabs(dbTime2Served3-dbTime2Served4); dbTmp /= dbDeltaTime;
		dbRelateness += dbTmp;

		dbRelateness += dbAlpha3 * inT_ij;
		
		dbTmp = dbAlpha4 * abs(problem->node[inNodeIdx1].capacity - problem->node[inNodeIdx2].capacity); dbTmp /= dbDeltaCap;
		dbRelateness += dbTmp;
		return dbRelateness;
	}

	return -1; // if cannot calculate relatedness
}
void Solution::Where_Are_Nodes()
{
	double dbTime2Served;
	int inVehicleIdx;
	int inTripIdx;

	cout << "Where are nodes? ";
	for (int inNodeIdx = 5; inNodeIdx <= 740; inNodeIdx++)
	{
		if (false == Get_Node_Info(inNodeIdx, &dbTime2Served, &inVehicleIdx, &inTripIdx))
		{
			cout << inNodeIdx << " ";
		} else
		{
			cout << inNodeIdx << " " << inVehicleIdx << " " << inTripIdx << endl;
		}

		if (inNodeIdx % 20 == 0) getchar();
	}

	cout << endl;
}
/* Accept pickup/delivery/c2c inNodeIdx
 * and return node information
 */
bool Solution::Get_Node_Info(int inNodeIdx, double *dbTime2Served, int *inVehicleIdx, int *inTripIdx)
{
	int inNodeType = Get_Node_Type(inNodeIdx);
	int inNodeIdxSz;
	int arrNodeIdx[2000];
	bool isFound;
	double arrBeginIime[2000];
	bool bRetVal;
	double leaveDepot;
	double dbEndS;
	int inWSId;
	int inVehCap;

	switch (inNodeType)
	{
		case NODE_PICKUP:
		case NODE_DELIVERY:
		case NODE_C2C_PICKUP:
		case NODE_C2C_DELIVERY:
			break;
		default:
			cout << "Get_Node_Info: Not support" << endl; getchar();
			return false;
	}

	 for (int i = 1; i <= numVeh; i++)
    {
	   for (int j = 1; j <= seg[i].numTrips; j++)
	   {
		   	inNodeIdxSz = 0;
		   	isFound = false;
		   // Rebuild path		   
		   int curC = seg[i].Trip[j].firstCus;
			while (curC > 0)
			{
				inNodeIdxSz++;
				arrNodeIdx[inNodeIdxSz] = curC;
				if (curC == inNodeIdx) isFound = true;
				curC = nextArr[curC];
			}

			if (true == isFound) // this trip has NodeIdx
		   {
			   *inVehicleIdx = i;
			   *inTripIdx = j;

			   // Reset path 
			   leaveDepot = seg[i].Trip[j].leaveSP;
			   if (seg[i].Trip[j].Type == TRIP_DELIVERY)
			   {
				   leaveDepot += problem->nodeSP[seg[i].Trip[j].startNodeIdx].load; 
			   }
			   	bRetVal = SetBeginTimeForPath_Q(leaveDepot, seg[i].Trip[j].startNodeIdx,
					arrNodeIdx,
					inNodeIdxSz,
					arrBeginIime,
					seg[i].Trip[j].endNodeIdx,
					&dbEndS,
					&inWSId,
					&inVehCap);
				if (false == bRetVal)
				{
#if Q_DEBUG_GET_NODE_INFO
					cout << "Get_Node_Info: SetBeginTime Failed" << endl; getchar();
#endif
					return false;
				}

				for (int inBeginTimeNodeIdx = 1; inBeginTimeNodeIdx <= inNodeIdxSz; inBeginTimeNodeIdx++)
				{
					if (arrNodeIdx[inBeginTimeNodeIdx] == inNodeIdx)
					{
						*dbTime2Served = arrBeginIime[inBeginTimeNodeIdx];
						return true;
					}
				}
#if Q_DEBUG_GET_NODE_INFO				
				cout << "Get_Node_Info: SetBeginTime Cannot find node" << endl; getchar();
#endif
			   return false;
		   }
	   }

	 }
#if Q_DEBUG_GET_NODE_INFO
	 cout << "Get_Node_Info: Node does not exist!" << endl; getchar();
#endif
	return false;
}
/*
 * Calc. constant to NORMALIZE Cij, ti, tj, qi, qj for calc. relatedness in SHAW DESTROY
 */
bool Solution::Calc_Delta_Norm_Shaw_Destroy(int inTripType, double *dbDeltaTime)
{
   int i,j,curC;
   double dbStartTime;
   int arrSol[2000];
   int inSolNode;
   double dbMinTime, dbMaxTime;
   double dbDeltaTimeTmp;

//#if _DEBUG
//   cout << endl << "Calc_Delta_Norm_Shaw_Destroy_Vio";
//#endif

   dbMinTime = PDS_INFINITY; dbMaxTime = -PDS_INFINITY;
   for (i = 1; i <= numVeh; i++) 
   {
	   for (j = 1; j <= seg[i].numTrips; j++)
	   {
		   if (TRIP_DELIVERY == seg[i].Trip[j].Type)
		   {
			   curC = seg[i].Trip[j].firstCus;
			   int preNode = seg[i].Trip[j].startNodeIdx;
			   double db_TimePoint = seg[i].Trip[j].leaveSP + problem->nodeSP[seg[i].Trip[j].startNodeIdx].load;
			   //infile << seg[i].Trip[j].startNodeIdx << "(" << seg[i].Trip[j].leaveSP << "|" << db_TimePoint  <<") -> ";
			   while (curC > 0)
			   {
				   db_TimePoint += problem->c[preNode][curC];
				   if (db_TimePoint < problem->node[curC].sTW)  db_TimePoint = problem->node[curC].sTW;

				   if (seg[i].Trip[j].Type == inTripType)
				   {
					   if (seg[i].Trip[j].firstCus == curC)
					   {
						   if (db_TimePoint < dbMinTime)
							   dbMinTime = db_TimePoint;
					   } else if (seg[i].Trip[j].lastCus == curC)
					   {
					   		if (db_TimePoint > dbMaxTime)
							   dbMaxTime = db_TimePoint;
					   }
				   }
				   //infile << curC << "(" << db_TimePoint << "|" << (db_TimePoint+problem->node[curC].duration) << ")" << "->";
				   preNode = curC;
				   db_TimePoint += problem->node[curC].duration;
				
				   curC = nextArr[curC];
			   }

			   if (seg[i].Trip[j].waitingS > 0)
			   {
				   db_TimePoint += problem->c[seg[i].Trip[j].lastCus][seg[i].Trip[j].waitingS];
				   //infile << seg[i].Trip[j].waitingS << "*" << "(" << db_TimePoint << "|" << (seg[i].Trip[j].endS - problem->c[seg[i].Trip[j].waitingS][seg[i].Trip[j].endNodeIdx]) << ") ->";
			   }

			   //infile << seg[i].Trip[j].endNodeIdx << "(" << seg[i].Trip[j].endS << ")" << endl;			   
			   //infile << endl << endl;


		   }
		   else if (TRIP_C2C == seg[i].Trip[j].Type)
		   {
			   curC = seg[i].Trip[j].firstCus;
			   int preNode = seg[i].Trip[j].startNodeIdx;
			   double db_TimePoint = seg[i].Trip[j].leaveSP;

			   //infile << seg[i].Trip[j].startNodeIdx << "(" << db_TimePoint << ") -> ";

			   while (curC > 0)
			   {
				   db_TimePoint += problem->c[preNode][curC];
				   if (db_TimePoint < problem->node[curC].sTW)  db_TimePoint = problem->node[curC].sTW;
				   
				   if (seg[i].Trip[j].Type == inTripType)
				   {
					   if (seg[i].Trip[j].firstCus == curC)
					   {
						   if (db_TimePoint < dbMinTime)
							   dbMinTime = db_TimePoint;
					   } else if (seg[i].Trip[j].lastCus == curC)
					   {
					   		if (db_TimePoint > dbMaxTime)
							   dbMaxTime = db_TimePoint;
					   }
				   }				   
				   //infile << curC << "(" << db_TimePoint << "|" << (db_TimePoint+problem->node[curC].duration) << ")" << "->";
				   preNode = curC;
				   db_TimePoint += problem->node[curC].duration;
				
				   curC = nextArr[curC];
			   }

			   if (seg[i].Trip[j].waitingS > 0)
			   {
				   db_TimePoint += problem->c[seg[i].Trip[j].lastCus][seg[i].Trip[j].waitingS];
				   //infile << seg[i].Trip[j].waitingS << "*" << "(" << db_TimePoint << "|" << (seg[i].Trip[j].endS - problem->c[seg[i].Trip[j].waitingS][seg[i].Trip[j].endNodeIdx]) << ") ->";
			   }

			   //infile << seg[i].Trip[j].endNodeIdx << "(" << seg[i].Trip[j].endS << ")" << endl;			   
			   //infile << endl << endl;
		   }
		   else if (TRIP_PICKUP == seg[i].Trip[j].Type)
		   {
			   curC = seg[i].Trip[j].firstCus;
			   int preNode = seg[i].Trip[j].startNodeIdx;
			   double db_TimePoint = seg[i].Trip[j].leaveSP;
			   
			   //infile << seg[i].Trip[j].startNodeIdx << "(" << db_TimePoint << ") -> ";
			   while (curC > 0)
			   {
				   db_TimePoint += problem->c[preNode][curC];
				   if (db_TimePoint < problem->node[curC].sTW)  db_TimePoint = problem->node[curC].sTW;

 				   if (seg[i].Trip[j].Type == inTripType)
				   {
					   if (seg[i].Trip[j].firstCus == curC)
					   {
						   if (db_TimePoint < dbMinTime)
							   dbMinTime = db_TimePoint;
					   } else if (seg[i].Trip[j].lastCus == curC)
					   {
					   		if (db_TimePoint > dbMaxTime)
							   dbMaxTime = db_TimePoint;
					   }
				   }				   

				   //infile << curC << "(" << db_TimePoint << "|" << (db_TimePoint+problem->node[curC].duration) << ")" << "->";
				   preNode = curC;
				   db_TimePoint += problem->node[curC].duration;

				   curC = nextArr[curC];
			   }
			   if (seg[i].Trip[j].waitingS > 0)
			   {
				   db_TimePoint += problem->c[seg[i].Trip[j].lastCus][seg[i].Trip[j].waitingS];
				   //infile << seg[i].Trip[j].waitingS << "*" << "(" << db_TimePoint << "|" << (seg[i].Trip[j].endS - problem->nodeSP[seg[i].Trip[j].endNodeIdx].unload - problem->c[seg[i].Trip[j].waitingS][seg[i].Trip[j].endNodeIdx]) << ") ->";
			   }
			   //infile << seg[i].Trip[j].endNodeIdx << "(" << (seg[i].Trip[j].endS - problem->nodeSP[seg[i].Trip[j].endNodeIdx].unload) << "|" << seg[i].Trip[j].endS << ")" << endl << endl;			   
			   //infile << endl << endl;
		   }
	   }
   }

   if ((dbMinTime < PDS_INFINITY) && (dbMaxTime > 0))
   {
	   *dbDeltaTime = dbMaxTime - dbMinTime;
	   return true;
   } else
	   return false;
}

// Check delivery/pickup nodes share same SP or not
bool Solution::Check_Shared_SP(int inNodeIdx1, int inNodeIdx2)
{
	int arrSP1[100];
	int arrSP2[100];
	int inSP1NodeTot;
	int inSP2NodeTot;
	int inNodeType1;
	int inNodeType2;

	inNodeType1 = Get_Node_Type(inNodeIdx1);
	inNodeType2 = Get_Node_Type(inNodeIdx2);
	if (inNodeType1 != inNodeType2)
	{
		cout << "Check_Shared_SP::mismatch type of nodes" << endl; getchar();
		return false;
	}
	switch (inNodeType1)
	{
		case NODE_PICKUP:
		case NODE_DELIVERY:
			break;
		case NODE_C2C_PICKUP:
		case NODE_C2C_DELIVERY:
			return true;
		default:
			return false;
	}

	if (false == Get_Assigned_SP_List(inNodeIdx1, arrSP1, &inSP1NodeTot))
	{
		return false;
	}

	if (false == Get_Assigned_SP_List(inNodeIdx2, arrSP2, &inSP2NodeTot))
	{
		return false;
	}

	for (int i = 1; i <= inSP1NodeTot; i++)
	{
		for (int j = 1; j <= inSP2NodeTot; j++)
		{
			if (arrSP1[i] == arrSP2[j])
				return true;
		}
	}

	return false;
}
//Check if inNodeIdx can be served by SP inSPIdx
bool Solution::Belong_To_SP(int inNodeIdx, int inSPIdx)
{
	int inNodeType;

	inNodeType = Get_Node_Type(inNodeIdx);
	switch (inNodeType)
	{
	case NODE_PICKUP:
		for (int i = 1; i <= problem->node[inNodeIdx].numSP; i++)
		{
			if (inSPIdx == problem->node[inNodeIdx].sp[i])
				return true;
		}
		return false;
	case NODE_DELIVERY:
		if (inSPIdx == problem->node[inNodeIdx].zone)
		{
			return true;
		} else
		{
			return false;
		}
		break;
	case NODE_C2C_PICKUP:
	case NODE_C2C_DELIVERY:
		return true;
	default:
		return false;
	}

	return false;
}
// Check if inNodeIdx (pickup/delivery) assigned to inSPIdx
bool Solution::Check_Assign_SP(int inNodeIdx, int inSPIdx)
{
	int inNodeType;

	inNodeType = Get_Node_Type(inNodeIdx);
	switch (inNodeType)
	{
	case NODE_PICKUP:
		for (int i = 1; i <= nSP; i++)
		{
			for (int j = 1; j <= numCusPSP[i]; j++)
			{
				if (inNodeIdx == CusPSP[i][j])
				{
					if (i == inSPIdx)
					{
						return true;
					} else 
					{
						return false;
					}
				}
			}
		}

		break;
	case NODE_DELIVERY:
		if (inSPIdx == problem->node[inNodeIdx].zone)
		{
			return true;
		} else
		{
			return false;
		}
		break;

	default:
		return false;
	}

	return false;
}
int Solution::Get_Assigned_SP(int inNodeIdx)
{
	int inNodeType;
	
	inNodeType = Get_Node_Type(inNodeIdx);
	switch (inNodeType)
	{
		case NODE_PICKUP:
			for (int i = 1; i <= nSP; i++)
			{
				for (int j = 1; j <= numCusPSP[i]; j++)
				{
					if (inNodeIdx == CusPSP[i][j])
					{
						return i;
					}
				}
			}

			break;
		case NODE_DELIVERY:
			return (problem->node[inNodeIdx].zone);
			break;

		default:
			return -1;
	}

	return -1;
}
/*
 * Get assigned SUPPLY POINT of node inNodeIdx
 * Either PICKUP or DELIVERY node is assigned to SUPPLY POINT
 */
bool Solution::Get_Assigned_SP_List(int inNodeIdx, int *arrAssignedSP, int *inSPnbr)
{
	int inNodeType;
	int arrTmp[100];
	int inNodeTot;
	
	inNodeTot = 0;
	inNodeType = Get_Node_Type(inNodeIdx);
	switch (inNodeType)
	{
	case NODE_PICKUP:
		//for (int i = 1; i <= nSP; i++)
		//{
		//	for (int j = 1; j <= numCusPSP[i]; j++)
		//	{
		//		if (inNodeIdx == CusPSP[i][j])
		//		{
		//			inNodeTot++;
		//			arrTmp[inNodeTot] = i;
		//		}
		//	}
		//}
		for (int i = 1; i <= problem->node[inNodeIdx].numSP; i++)
				{
					inNodeTot++;
				arrTmp[inNodeTot] = problem->node[inNodeIdx].sp[i];
		}

		break;
	case NODE_DELIVERY:
		 //for (int i = startidD; i <= endidD; i++){
			// if (inNodeIdx == problem->node[i].zone)
			// {
			//	 return i;
			// }
		 //}
		inNodeTot++;
		arrTmp[inNodeTot] = problem->node[inNodeIdx].zone;
		break;

	default:
		return false;
	}

	*inSPnbr = inNodeTot;
	for (int i = 1; i <= inNodeTot; i++)
	{
		arrAssignedSP[i] = arrTmp[i];
	}

	return true;
}

// Evaluate cost of trip in case of inserteing the inNodeIdx to trip
double Solution::Evaluate_InsertedNode_Cost(int *arrTrip, int inTripSz, int inStartNodeIdx, int inEndNodeIdx, int inNodeIdx)
{
	double dbGap = PDS_INFINITY; //trip with inNodeIdx - trip w/o inNodeIdx

	if (inTripSz < 2) return PDS_INFINITY;
	
	{
		if (arrTrip[1] == inNodeIdx) // firstCus
		{
			dbGap = problem->c[inStartNodeIdx][inNodeIdx] + problem->c[inNodeIdx][arrTrip[2]];
			//dbGap -= problem->c[inStartNodeIdx][arrTrip[2]];
		} else if (arrTrip[inTripSz] == inNodeIdx) // lastCus
		{
			dbGap = problem->c[arrTrip[inTripSz-1]][inNodeIdx] + problem->c[inNodeIdx][inEndNodeIdx];
			//dbGap -= problem->c[arrTrip[inTripSz-1]][inEndNodeIdx];
		} else  // intermediate node
		{
			for (int i = 2; i < inTripSz; i++)
			{
				if (arrTrip[i] == inNodeIdx)
				{
					dbGap = problem->c[arrTrip[i-1]][inNodeIdx] + problem->c[inNodeIdx][arrTrip[i+1]];
					//dbGap -= problem->c[arrTrip[i-1]][arrTrip[i+1]];
					break;
				}
			}
		}
	}

	return dbGap;
}
// Calc. cost of inNodeIdx
double Solution::Get_InsertedNode_Cost(int inVehIdx, int inTripIdx, int inNodeIdx)
{
	int arrTripTmp[1000];
	int inTripSzTmp;
	double dbCostTmp;

	// Build current PICKUP trip
	inTripSzTmp = 0;
	int curC = seg[inVehIdx].Trip[inTripIdx].firstCus;
	while (curC > 0)
	{
		inTripSzTmp++;
		arrTripTmp[inTripSzTmp] = curC;
		curC = nextArr[curC];
	}

	for (int i = 1; i <= inTripSzTmp; i++)
	{
		if (arrTripTmp[i] == inNodeIdx)
		{
			int inStartNodeTmp;
			if (1 == i)
			{
				inStartNodeTmp = seg[inVehIdx].Trip[inTripIdx].startNodeIdx;
			} else
			{
				inStartNodeTmp = arrTripTmp[i-1];
			}

			int inEndNodeTmp;
			if (inTripSzTmp == i)
			{
				inEndNodeTmp = seg[inVehIdx].Trip[inTripIdx].endNodeIdx;
			} else
			{
				inEndNodeTmp = arrTripTmp[i+1];
			}

			dbCostTmp = problem->c[inStartNodeTmp][i] + problem->c[i][inEndNodeTmp];
			dbCostTmp -= problem->c[inStartNodeTmp][inEndNodeTmp];

			return dbCostTmp;
		}
	}

	cout << "Get_InsertedNode_Cost" << endl; getchar();
	return -1;
}

/* Node type
 * Depot	   : 0
 * SP		   : 1								-> nSP
 * C2C-PICKUP  : nSP + 1						-> nOrder + nSP
 * C2C-DELIVERY: nOrder + nSP + 1				-> nOrder + nOrder + nSP
 * PICKUP	   : nOrder + nOrder + nSP + 1		-> nP + nOrder + nOrder + nSP
 * DELIVERY	   : nP + nOrder + nOrder + nSP + 1 -> nD + nP + nOrder + nOrder + nSP
 * WAITING S   : nD + nP + nOrder + nOrder + nSP + 1 -> nWS + nD + nP + nOrder + nOrder + nSP
 */
int Solution::Get_Node_Type(int inNodeIdx)
{
	if (0 == inNodeIdx)
		return NODE_DEPOT;

	if (inNodeIdx <= nSP) return NODE_SUPPLY_POINT;

	if ((nSP+1 <= inNodeIdx) && (inNodeIdx <= nOrder+nSP)) return NODE_C2C_PICKUP;

	if ((nOrder+nSP+1 <= inNodeIdx) && (inNodeIdx <= nOrder + nOrder + nSP)) return NODE_C2C_DELIVERY;

	if ((nOrder + nOrder + nSP + 1 <= inNodeIdx) && (inNodeIdx <= nP + nOrder + nOrder + nSP)) return NODE_PICKUP;

	if ((nP + nOrder + nOrder + nSP + 1 <= inNodeIdx) && (inNodeIdx <=  nD + nP + nOrder + nOrder + nSP)) return NODE_DELIVERY;

	if ((nD + nP + nOrder + nOrder + nSP + 1 <= inNodeIdx) && (inNodeIdx <=  nWS + nD + nP + nOrder + nOrder + nSP)) return NODE_WAITING_STATION;

	return -1;
}
int Solution::Show_Demands_Status(void)
{
	int inRoutedDemands;
	int inRoutedTot = 0;

	cout << endl << "\t\t\t***********DEMAND Status******************" << endl;

	// Scan PICKUP demands
	inRoutedDemands = 0;
	for (int i = nOrder + nOrder + nSP + 1; i <= nP + nOrder + nOrder + nSP; i++)
	{
		if (1 == routed[i])
		{
			inRoutedDemands++;
		}
	}
	inRoutedTot +=  inRoutedDemands;
	cout << "\t\t\t>> Routed PICKUP demands: " << inRoutedDemands << "/" << nP << endl;

	// Scan DELIVERY demands
	inRoutedDemands = 0;
	for (int i = nP + nOrder + nOrder + nSP + 1; i <= nD + nP + nOrder + nOrder + nSP; i++)
	{
		if (1 == routed[i])
		{
			inRoutedDemands++;
		}
	}
	inRoutedTot +=  inRoutedDemands;
	cout << "\t\t\t>> Routed DELIVERY demands: " << inRoutedDemands << "/" << nD << endl;

	// Scan C2C demands
	inRoutedDemands = 0;
	for (int i = problem->startidC2C; i <= problem->endidC2CP; i++)
	{
		if (1 == routed[i])
		{
			inRoutedDemands++;
		}
	}
	inRoutedTot +=  inRoutedDemands;
	cout << "\t\t\t>> Routed C2C demands: " << inRoutedDemands << "/" << nOrder << endl;

	cout << "\t\t\t>> Total ROUTED demands: " << inRoutedTot << "/" << (nP + nD + nOrder) << endl;

	cout << "\t\t\t*********End of Demand Status*************" << endl << endl;

	if (inRoutedTot == (nP + nD + nOrder)) return 1;

	return 0;
}
/* Scan un-routed PICKUP/DELIVERY demands and update assigned SP
 * return values:
 *		-1 : internal error
 *		 0 : still has unrouted customer demands
 *		 1 : all customer demands are ROUTED 
 */
// TODO: We can find anthoer way to speed up
int Solution::Update_SP_Status(void)
{
	int inRoutedDemands;
	int inRoutedTot = 0;

	cout << endl << "\t\t\t**************SP Status*********************" << endl;

	for (int i = 1; i <= nSP; i++)
	{
		numCusPRouted[i] = 0;
		numCusDRouted[i] = 0;
	}

	// Scan PICKUP demands
	inRoutedDemands = 0;
	for (int i = nOrder + nOrder + nSP + 1; i <= nP + nOrder + nOrder + nSP; i++)
	{
		if (1 == routed[i])
		{
			int inAssighedSP = Get_Assigned_SP(i);
			if ((1 > inAssighedSP) || (nSP < inAssighedSP))
				return -1;
			numCusPRouted[inAssighedSP]++;
			inRoutedDemands++;
		}
	}
	inRoutedTot +=  inRoutedDemands;
	cout << "\t\t\t>> Routed PICKUP demands: " << inRoutedDemands << "/" << nP << endl;

	// Scan DELIVERY demands
	inRoutedDemands = 0;
	for (int i = nP + nOrder + nOrder + nSP + 1; i <= nD + nP + nOrder + nOrder + nSP; i++)
	{
		if (1 == routed[i])
		{
			int inAssighedSP = Get_Assigned_SP(i);
			if ((1 > inAssighedSP) || (nSP < inAssighedSP))
				return -1;
			numCusDRouted[inAssighedSP]++;
			inRoutedDemands++;
		}
	}
	inRoutedTot +=  inRoutedDemands;
	cout << "\t\t\t>> Routed DELIVERY demands: " << inRoutedDemands << "/" << nD << endl;

	// Scan C2C demands
	inRoutedDemands = 0;
	for (int i = problem->startidC2C; i <= problem->endidC2CP; i++)
	{
		if (1 == routed[i])
		{
			inRoutedDemands++;
		}
	}
	inRoutedTot +=  inRoutedDemands;
	cout << "\t\t\t>> Routed C2C demands: " << inRoutedDemands << "/" << nOrder << endl;

	cout << "\t\t\t>> Total ROUTED demands: " << inRoutedTot << "/" << (nP + nD + nOrder) << endl;

	cout << "\t\t\t**************End of SP Status**************" << endl;

	if (inRoutedTot == (nP + nD + nOrder)) return 1;

	return 0;
}

// Try to insert Pickup inPickupIdx to trip inTripIdx of vehicke inVehIdx
bool Solution::Insert_A_Pickup(int inPickupIdx, int inVehIdx, int inTripIdx, bool isCreated, double *dbEvaluatdCost)
{
	int arrTripTmp[1000];
	int arrTripTmp2[1000];
	int inTripSzTmp;
	int inTripSzTmp2;
	double arrBeginIime[1000];
	bool bRetVal;
	double leaveDepot;
	double dbEndS;
	int inWSId;
	int inNodeType;
	int inVehCap;
	double dbStartTimeTmp;
	int inStartPos, inEndPos;

	/*
	 * Because of PICKUP trip so:
	 *	- endNodeIdx has to a SP
	 *	- startNodeIdx can be  DEPOT/delivery/c2c-delivery/SP
	 */
	inNodeType = Get_Node_Type(seg[inVehIdx].Trip[inTripIdx].startNodeIdx);
	switch (inNodeType)
	{
		case NODE_DEPOT:
		case NODE_DELIVERY:
		case NODE_C2C_DELIVERY:
		case NODE_SUPPLY_POINT:
			break;
		default:
#if Q_DEBUG_PICKUP_INS
			cout << "Invalid type of startNode in current PICKUP trip!!" << endl;
#endif
			return false;
	}

	inNodeType = Get_Node_Type(seg[inVehIdx].Trip[inTripIdx].endNodeIdx);
	switch (inNodeType)
	{
		case NODE_SUPPLY_POINT:
			break;
		default:
#if Q_DEBUG_PICKUP_INS
			cout << "Invalid type of startNode in current PICKUP trip!!" << endl;
#endif
			return false;
	}

	// Build current PICKUP trip
	inTripSzTmp = 0;
	int curC = seg[inVehIdx].Trip[inTripIdx].firstCus;
	while (curC > 0)
	{
		inTripSzTmp++;
		arrTripTmp[inTripSzTmp] = curC;
		curC = nextArr[curC];
	}

#if Q_DEBUG_PICKUP_INS
	cout << "Before inserting a pickup";
	showSolution();
#endif
	inStartPos = 1; inEndPos = inTripSzTmp;
#if !Q_JOINT_POINT_ALLOWANCE
	//if (inTripIdx < seg[inVehIdx].numTrips) // not last trip
	//{
	//	if (seg[inVehIdx].Trip[inTripIdx].lastCus == seg[inVehIdx].Trip[inTripIdx+1].startNodeIdx)
	//	{
	//		inEndPos--;
	//	}
	//}
	//if (inTripIdx > 1) // not first trip
	//{
	//	if (seg[inVehIdx].Trip[inTripIdx].startNodeIdx == seg[inVehIdx].Trip[inTripIdx-1].lastCus)
	//	{
	//		inStartPos++;
	//	}
	//}
	inStartPos = 2; inEndPos = inTripSzTmp;
#endif

	leaveDepot = seg[inVehIdx].Trip[inTripIdx].leaveSP;
	for (int i = inStartPos; i <= inEndPos; i++)
	{
		/* 2 -> k : arrTripTmp
		 *
		 */
		inTripSzTmp2 = 0;
		for (int j = 1; j <= i-1; j++)
		{
			inTripSzTmp2++;
			arrTripTmp2[inTripSzTmp2] = arrTripTmp[j];
		}
		inTripSzTmp2++;
		arrTripTmp2[inTripSzTmp2] = inPickupIdx;
		for (int j = i; j <= inTripSzTmp; j++)
		{
			inTripSzTmp2++;
			arrTripTmp2[inTripSzTmp2] = arrTripTmp[j];
		}

		bRetVal = SetBeginTimeForPath_Q(leaveDepot, seg[inVehIdx].Trip[inTripIdx].startNodeIdx,
						arrTripTmp2,
						inTripSzTmp2,
						arrBeginIime,
						seg[inVehIdx].Trip[inTripIdx].endNodeIdx,
						&dbEndS,
						&inWSId,
						&inVehCap);

		if (bRetVal)
		{
			// Check time-forward slack
			if (inTripIdx < seg[inVehIdx].numTrips)
			{
				if (TRIP_PICKUP == seg[inVehIdx].Trip[inTripIdx].Type)
				{
					dbEndS += problem->nodeSP[seg[inVehIdx].Trip[inTripIdx].endNodeIdx].unload;
				}
				if (seg[inVehIdx].Trip[inTripIdx+1].startNodeIdx == seg[inVehIdx].Trip[inTripIdx].lastCus)
				{

					dbStartTimeTmp = arrBeginIime[inTripSzTmp2];
				} else
				{
					dbStartTimeTmp = dbEndS;
				}

				if (false == Set_Time_For_A_Vehicle(inVehIdx, inTripIdx+1, dbStartTimeTmp, false))
				{
#if Q_DEBUG_PICKUP_INS
					cout << "Set_Time_For_A_Vehicle::failed" << endl;
#endif
					continue;
				}
			}


			if (false == isCreated)
			{
				double dbEvaluatedCostTmp = Evaluate_InsertedNode_Cost(arrTripTmp2, inTripSzTmp2, 
																	   seg[inVehIdx].Trip[inTripIdx].startNodeIdx, seg[inVehIdx].Trip[inTripIdx].endNodeIdx, 
																	   inPickupIdx);
				*dbEvaluatdCost = dbEvaluatedCostTmp;
				return true;
			}
			*dbEvaluatdCost = 0;

#if Q_DEBUG_PICKUP_INS
			//Show_A_Trip(inVehIdx, inTripIdx);
#endif
			seg[inVehIdx].Trip[inTripIdx].numCus++;
			seg[inVehIdx].Trip[inTripIdx].endS = dbEndS;
			seg[inVehIdx].Trip[inTripIdx].waitingS = inWSId;
			seg[inVehIdx].Trip[inTripIdx].capacity = inVehCap;
			seg[inVehIdx].Trip[inTripIdx].firstCus = arrTripTmp2[1];
			seg[inVehIdx].Trip[inTripIdx].lastCus = arrTripTmp2[inTripSzTmp2];
			curC = seg[inVehIdx].Trip[inTripIdx].firstCus;
			routed[curC] = 1;
			for (int i = 2; i <= inTripSzTmp2; i++)
			{
				routed[arrTripTmp2[i]] = 1;
				nextArr[curC] = arrTripTmp2[i];
				curC = arrTripTmp2[i];
			}
			nextArr[curC] = -1;		

#if Q_DEBUG_PICKUP_INS
			//Show_A_Trip(inVehIdx, inTripIdx);
#endif
			if (inTripIdx < seg[inVehIdx].numTrips)
			{
				if (false == Set_Time_For_A_Vehicle(inVehIdx, inTripIdx+1, dbStartTimeTmp, true))
				{
					cout << "Set_Time_For_A_Vehicle::failed" << endl; getchar();
					return false;
				}
			}

#if Q_DEBUG_PICKUP_INS
	cout << "AFTER inserting a pickup";
	showSolution();
#endif
			return true;
		} 

	}

	return false;
}
// Insert delivery inDeliveryIdx into trip inTripIdx of vehicle inVehIdx
bool Solution::Insert_A_Delivery(int inDeliveryIdx, int inVehIdx, int inTripIdx, bool isCreated, double *dbEvaluatdCost)
{
	int arrTripTmp[1000];
	int arrTripTmp2[1000];
	int inTripSzTmp;
	int inTripSzTmp2;
	double arrBeginIime[1000];
	bool bRetVal;
	double leaveDepot;
	double dbEndS;
	int inWSId;
	int inNodeType;
	int inVehCap;
	double dbStartTimeTmp;
	int inStartPos; 
	int inEndPos;
	double dbEvaluatdCostTmp;

	if (seg[inVehIdx].Trip[inTripIdx].Type != TRIP_DELIVERY)
	{
		cout << "Halt!" << endl; getchar();
		return false;
	}
#if Q_DEBUG_DELIVERY_INS
	cout << "Try to insert delivery " <<  inDeliveryIdx << " to trip" << inTripIdx << " of vehicle " << inVehIdx << endl;
#endif
	/*
	 * Because of DELIVERY trip so:
	 *	- endNodeIdx can be pickup/depot/sp/c2c-pickup
	 *	- startNodeIdx has to be a SP
	 */
	inNodeType = Get_Node_Type(seg[inVehIdx].Trip[inTripIdx].startNodeIdx);
	switch (inNodeType)
	{
		case NODE_SUPPLY_POINT:
			break;
		default:
#if Q_DEBUG_DELIVERY_INS
			cout << "\t Invalid type of startNode in current DELIVERY trip!!" << endl;
#endif
			return false;
	}

	inNodeType = Get_Node_Type(seg[inVehIdx].Trip[inTripIdx].endNodeIdx);
	switch (inNodeType)
	{
	case NODE_PICKUP:
	case NODE_DEPOT:
	case NODE_SUPPLY_POINT:
	case NODE_C2C_PICKUP: 
			break;
		default:
#if Q_DEBUG_DELIVERY_INS
			cout << "\t Invalid type of startNode in current DELIVERY trip!!" << endl;
#endif
			return false;
	}

#if Q_DEBUG_DELIVERY_INS
	cout << "Before inserting delivery" << endl;
	Show_A_Trip(inVehIdx, inTripIdx);
#endif

	// Build current DELIVERY trip
	inTripSzTmp = 0;
	int curC = seg[inVehIdx].Trip[inTripIdx].firstCus;
	while (curC > 0)
	{
		inTripSzTmp++;
		arrTripTmp[inTripSzTmp] = curC;
		curC = nextArr[curC];
	}


	leaveDepot = seg[inVehIdx].Trip[inTripIdx].leaveSP;
	leaveDepot += problem->nodeSP[seg[inVehIdx].Trip[inTripIdx].startNodeIdx].load;

	// Find possible position to insert
	inStartPos = 1; inEndPos = inTripSzTmp;
#if !Q_JOINT_POINT_ALLOWANCE
	//if (inTripIdx < seg[inVehIdx].numTrips) // not last trip
	//{
	//	if (seg[inVehIdx].Trip[inTripIdx].lastCus == seg[inVehIdx].Trip[inTripIdx+1].startNodeIdx)
	//	{
	//		inEndPos--;
	//	}
	//}
	//if (inTripIdx > 1) // not first trip
	//{
	//	if (seg[inVehIdx].Trip[inTripIdx].startNodeIdx == seg[inVehIdx].Trip[inTripIdx-1].lastCus)
	//	{
	//		inStartPos++;
	//	}
	//}
	inStartPos = 2; inEndPos = inTripSzTmp;
#endif

	for (int i = inStartPos; i <= inEndPos; i++)
	{
		/* 2 -> k : arrTripTmp
		 *
		 */
		inTripSzTmp2 = 0;
		for (int j = 1; j <= i-1; j++)
		{
			inTripSzTmp2++;
			arrTripTmp2[inTripSzTmp2] = arrTripTmp[j];
		}
		inTripSzTmp2++;
		arrTripTmp2[inTripSzTmp2] = inDeliveryIdx;
		for (int j = i; j <= inTripSzTmp; j++)
		{
			inTripSzTmp2++;
			arrTripTmp2[inTripSzTmp2] = arrTripTmp[j];
		}

		bRetVal = SetBeginTimeForPath_Q(leaveDepot, seg[inVehIdx].Trip[inTripIdx].startNodeIdx,
						arrTripTmp2,
						inTripSzTmp2,
						arrBeginIime,
						seg[inVehIdx].Trip[inTripIdx].endNodeIdx,
						&dbEndS,
						&inWSId,
						&inVehCap);

		if (true == bRetVal)
		{

			// Check time-forward slack
			if (inTripIdx < seg[inVehIdx].numTrips)
			{
				///showSolution();
				if (TRIP_PICKUP == seg[inVehIdx].Trip[inTripIdx].Type)
				{
					dbEndS += problem->nodeSP[seg[inVehIdx].Trip[inTripIdx].endNodeIdx].unload;
				}
				if (seg[inVehIdx].Trip[inTripIdx+1].startNodeIdx == seg[inVehIdx].Trip[inTripIdx].lastCus)
				{
					dbStartTimeTmp = arrBeginIime[inTripSzTmp2];
				} else
				{
					dbStartTimeTmp = dbEndS;
				}

				if (false == Set_Time_For_A_Vehicle(inVehIdx, inTripIdx+1, dbStartTimeTmp, false))
				{
#if Q_DEBUG_DELIVERY_INS
					cout << "Set_Time_For_A_Vehicle::failed *ln" << __LINE__<< endl;
#endif
					continue;
				}

				//showSolution();
			}

			if (false == isCreated)
			{
				dbEvaluatdCostTmp = Evaluate_InsertedNode_Cost(arrTripTmp2, inTripSzTmp2,
															   seg[inVehIdx].Trip[inTripIdx].startNodeIdx,
															   seg[inVehIdx].Trip[inTripIdx].endNodeIdx,
															   inDeliveryIdx);
				*dbEvaluatdCost = dbEvaluatdCostTmp;
				return true;
			}
			*dbEvaluatdCost = 0;

			seg[inVehIdx].Trip[inTripIdx].numCus++;
			seg[inVehIdx].Trip[inTripIdx].endS = dbEndS;
			seg[inVehIdx].Trip[inTripIdx].waitingS = inWSId;
			
			seg[inVehIdx].Trip[inTripIdx].firstCus = arrTripTmp2[1];
			seg[inVehIdx].Trip[inTripIdx].lastCus = arrTripTmp2[inTripSzTmp2];
			curC = seg[inVehIdx].Trip[inTripIdx].firstCus;
			routed[curC] = 1;
			for (int i = 2; i <= inTripSzTmp2; i++)
			{
				routed[arrTripTmp2[i]] = 1;
				nextArr[curC] = arrTripTmp2[i];
				curC = arrTripTmp2[i];
			}
			nextArr[curC] = -1;		

#if Q_DEBUG_DELIVERY_INS
			Show_A_Trip(inVehIdx, inTripIdx);
#endif

			if (inTripIdx < seg[inVehIdx].numTrips)
			{
				//showSolution();
				if (false == Set_Time_For_A_Vehicle(inVehIdx, inTripIdx+1, dbStartTimeTmp, true))
				{
					cout << "Set_Time_For_A_Vehicle::failed *ln" << __LINE__ << endl; getchar();
					return false;
				}
				//showSolution();
			}

			return true; 
		}
	}

	return false;

}
/*
 * A C2C can be insert as a new trip before pickup trip or after delivery trip
 * or in a current C2C Trip
 */
bool Solution::Insert_A_C2C(int inC2CPickupIdx, int inVehIdx, int inTripIdx, bool isCreated, double *dbEvaluatdCost)
{
	int inTripType = seg[inVehIdx].Trip[inTripIdx].Type;
	int inRetVal;
	int arrTripTmp[1000];
	int arrTripTmp2[1000];
	int inTripSzTmp;
	int inTripSzTmp2;
	double arrBeginIime[1000];
	bool bRetVal;
	double dbEndS;
	int inWSId;
	int inVehCap;
	double dbStartTimeTmp;
	double dbEvaluatdCostTmp;


#if Q_DEBUG_C2C_INS
	cout << "Try to insert C2C pickup " <<  inC2CPickupIdx << " to trip" << inTripIdx << " of vehicle " << inVehIdx << endl;
#endif

	if (TRIP_C2C ==  inTripType)
	{
		if (seg[inVehIdx].Trip[inTripIdx].numCus %2 ==1)
		{
#if Q_DEBUG_C2C_INS
			cout << "Invalid node nbr of C2C trip" << endl; getchar();
#endif
			return false;
		}

		// Get current C2C trip
		inTripSzTmp = 0;
		int curC = seg[inVehIdx].Trip[inTripIdx].firstCus;
		while (curC > 0)
		{
			inTripSzTmp++;
			arrTripTmp[inTripSzTmp] = curC;
			curC = nextArr[curC];
		}
#if Q_DEBUG_C2C_INS
		cout << "Current C2C trip: ";
		for (int i = 1; i <= inTripSzTmp; i++)
		{
			cout << arrTripTmp[i] << "->";
		}
		cout << endl;
#endif
		//
		inTripSzTmp2 = 0;
#if !Q_JOINT_POINT_ALLOWANCE
		for (int inPos = 2; inPos <= inTripSzTmp; inPos++)
#else
		for (int inPos = 1; inPos <= inTripSzTmp+1; inPos++)
#endif
		{
  		   /*
			* arrTripTmp: holds current C2C trip
			* arrTripTmp2: hold new C2C trip after insert pair (inC2CPickupIdx, inC2CPickupIdx + nOrder) to arrTripTmp
			*/
			inTripSzTmp2 = 0;

			// Firstly, copy from 1 to (inPos-1) from arrTripTmp to arrPath
			for (int i = 1; i <= (inPos-1); i++)
			{
				inTripSzTmp2++;
				arrTripTmp2[inTripSzTmp2] = arrTripTmp[i];
			}
			// Second, insert C2C PU candidate to new path
			inTripSzTmp2++;
			arrTripTmp2[inTripSzTmp2] = inC2CPickupIdx;
			int inSaveCurrPos = inTripSzTmp2;

			// Third, search all possible place to insert C2C Delivery
#if !Q_JOINT_POINT_ALLOWANCE
			for (int jC2CDEPos = inPos; jC2CDEPos <= inTripSzTmp; jC2CDEPos++)
#else
			for (int jC2CDEPos = inPos; jC2CDEPos <= inTripSzTmp+1; jC2CDEPos++)
#endif
			{
				// Roll-back
				inTripSzTmp2 = inSaveCurrPos;

				// Move from inPos to (jC2CDEPos-1) from arrTripTmp to arrPath
				for (int i = inPos; i <= (jC2CDEPos-1); i++)
				{
					inTripSzTmp2++;
					arrTripTmp2[inTripSzTmp2] = arrTripTmp[i];
				}
				// Insert C2C delivery
					inTripSzTmp2++;
					arrTripTmp2[inTripSzTmp2] = inC2CPickupIdx + nOrder;
				// Move the remaining of arrTripTmp to arrPath
  				for (int i = jC2CDEPos; i <= inTripSzTmp; i++)
				{
					inTripSzTmp2++;
					arrTripTmp2[inTripSzTmp2] = arrTripTmp[i];
				}

#if Q_DEBUG_C2C_INS
				cout << "\t Suggested C2C trip: ";
				for (int inLoop=1; inLoop<=inTripSzTmp2; inLoop++)
				{
					if (arrTripTmp2[inLoop] == inC2CPickupIdx)
					{
						cout << arrTripTmp2[inLoop] << "*->";
					} else if (arrTripTmp2[inLoop] == inC2CPickupIdx + nOrder)
					{
						cout << arrTripTmp2[inLoop] << "**->";
					} else
						cout << arrTripTmp2[inLoop] << "->";
				}
				cout << endl;
#endif

				// Check LIFO
				if (false == IsLIFO_Q(arrTripTmp2, inTripSzTmp2))
				{
#if Q_DEBUG_C2C_INS
					cout << "\t LIFO failed ";
#endif
					continue;
				}

				//if ((Get_Node_Type(seg[inVehIdx].Trip[inTripIdx].endNodeIdx) == NODE_SUPPLY_POINT) && ((seg[inVehIdx].Trip[inTripIdx+1].Type) == TRIP_DELIVERY)) {
				//	cout << "Unit test";
				//}

				bRetVal = SetBeginTimeForPath_Q(seg[inVehIdx].Trip[inTripIdx].leaveSP, seg[inVehIdx].Trip[inTripIdx].startNodeIdx,
											arrTripTmp2,
											inTripSzTmp2,
											arrBeginIime,
											seg[inVehIdx].Trip[inTripIdx].endNodeIdx,
											&dbEndS,
											&inWSId,
											&inVehCap);
				if (bRetVal)
				{

					// Check time-forward slack
					if (inTripIdx < seg[inVehIdx].numTrips)
					{
						///showSolution();
						if (seg[inVehIdx].Trip[inTripIdx+1].startNodeIdx == seg[inVehIdx].Trip[inTripIdx].lastCus)
						{
							dbStartTimeTmp = arrBeginIime[inTripSzTmp2];
						} else
							dbStartTimeTmp = dbEndS;

						if (false == Set_Time_For_A_Vehicle(inVehIdx, inTripIdx+1, dbStartTimeTmp, false))
						{
#if Q_DEBUG_C2C_INS
							cout << "Set_Time_For_A_Vehicle::failed *ln" << __LINE__ << endl;
#endif
							continue;
						}

						//showSolution();
					}

					if (false == isCreated)
					{
						dbEvaluatdCostTmp = Evaluate_InsertedNode_Cost(arrTripTmp2, inTripSzTmp2,
																		seg[inVehIdx].Trip[inTripIdx].startNodeIdx, seg[inVehIdx].Trip[inTripIdx].endNodeIdx,
																		inC2CPickupIdx);
						dbEvaluatdCostTmp += Evaluate_InsertedNode_Cost(arrTripTmp2, inTripSzTmp2,
												seg[inVehIdx].Trip[inTripIdx].startNodeIdx, seg[inVehIdx].Trip[inTripIdx].endNodeIdx,
												inC2CPickupIdx+nOrder);
						*dbEvaluatdCost = dbEvaluatdCostTmp;
						return true;
					}
					*dbEvaluatdCost = 0;

					seg[inVehIdx].Trip[inTripIdx].firstCus = arrTripTmp2[1];
					seg[inVehIdx].Trip[inTripIdx].lastCus = arrTripTmp2[inTripSzTmp2];
					seg[inVehIdx].Trip[inTripIdx].capacity = inVehCap;
					seg[inVehIdx].Trip[inTripIdx].numCus += 2; 
					seg[inVehIdx].Trip[inTripIdx].waitingS = inWSId;
					seg[inVehIdx].Trip[inTripIdx].endS = dbEndS;
					seg[inVehIdx].Trip[inTripIdx].feasible = 1;		

					//if (inWSId > -1) {
					//	cout << "Unit test";
					//}

					for (int i=1;i<seg[inVehIdx].Trip[inTripIdx].numCus;i++)
					{
						routed[arrTripTmp2[i]]=1;
						nextArr[arrTripTmp2[i]]= arrTripTmp2[i+1];
					}
					routed[arrTripTmp2[seg[inVehIdx].Trip[inTripIdx].numCus]]=1;
					nextArr[arrTripTmp2[seg[inVehIdx].Trip[inTripIdx].numCus]]= 0;

					if (inTripIdx < seg[inVehIdx].numTrips)
					{
						//showSolution();
						if (false == Set_Time_For_A_Vehicle(inVehIdx, inTripIdx+1, dbStartTimeTmp, true))
						{
							cout << "Set_Time_For_A_Vehicle::failed" << endl; getchar();
							return false;
						}
						//showSolution();
					}

					return true;
				} else
				{
#if Q_DEBUG_C2C_INS
					cout << "Set time failed!" << endl;
#endif
				}
			}
		}

		return false;

	} 

	return false;
}

// START OF IMPLEMENTATION REPAIRER //
/*
 * The cheapest position in the solution and the associated insertion cost are EVALUATED.
 * The neighborhood then inserts the one with the LOWEST insertion COST first.
 */
bool Solution::Best_First_Repair()
{
	int arr_Repair_List[2000];
	int inRepairLstSz;
	int arr_Permutation[2000];
	bool bRetVal;
	double dbBestTmp;
	int inBestVehIdx;
	int inBestTripIdx;
	double dbEvaluatedCostTmp;

#if Q_DEBUG_BEST_FIRST_REP
	cout << "\t\t\t BEST FIRST REPAIR" << endl;
#endif
	/*
	 * For removed pickup-customer, allow to re-insert to any existing pickup legs of the solution,
	 * for which the collected freight is brought to assignment supply point
	 */
	//Build the remvoved list.
	inRepairLstSz = 0;
	for (int i = nSP + 1; i <= nD + nP + nOrder + nOrder + nSP; i++) // all customer-demands
	{
		if ((i >= nOrder+nSP+1) && (i <= nOrder + nOrder + nSP)) continue; // skip c2c-delivery because we consider c2c-pickup already
		if (0 == routed[i]) // means this customer-demand is not be routed
		{
			inRepairLstSz++;
			arr_Repair_List[inRepairLstSz] = i;
		}
	}
#if Q_DEBUG_BEST_FIRST_REP
	cout << "\t\t\t Removed list: ";
	for (int i = 1; i <= inRepairLstSz; i++)
	{
		cout << arr_Repair_List[i] <<  " ";
	}
	cout << endl;
#endif

	// Make permutation of the list
	RandPermutation(inRepairLstSz, arr_Repair_List, arr_Permutation);
#if Q_DEBUG_BEST_FIRST_REP
	cout << "\t\t\t A PERMUTATION of removed list: ";
	for (int i = 1; i <= inRepairLstSz; i++)
	{
		cout << arr_Permutation[i] <<  " ";
	}
	cout << endl;
#endif

	// Scan and route all customer-demands in the list
	for (int i = 1; i <= inRepairLstSz; i++)
	{
		inBestVehIdx = -1;
		inBestTripIdx = -1;
		dbBestTmp = PDS_INFINITY;

		//Get node type: pickup or delivery or c2c
		int inNodeType = Get_Node_Type(arr_Permutation[i]);
		switch (inNodeType)
		{
			case NODE_PICKUP:
#if Q_DEBUG_BEST_FIRST_REP
				cout << "\t\t\t Evaluate PICKUP "<< arr_Permutation[i] << "... " << endl; 
#endif
				for (int inVehIdx = 1; inVehIdx <= numVeh; inVehIdx++)
				{
					for (int inTripIdx=1; inTripIdx<=seg[inVehIdx].numTrips; inTripIdx++)
					{
						//This assigned SP can serve this pikcup node also
						if ((TRIP_PICKUP == seg[inVehIdx].Trip[inTripIdx].Type)  && (true == Belong_To_SP(arr_Permutation[i], seg[inVehIdx].Trip[inTripIdx].endNodeIdx)))
						{
#if Q_DEBUG_BEST_FIRST_REP
							cout << "\t\t\t\t to vehicle " << inVehIdx << " trip " << inTripIdx;
#endif
							bRetVal = Insert_A_Pickup(arr_Permutation[i], inVehIdx, inTripIdx, false, &dbEvaluatedCostTmp);
							if (bRetVal)
							{
#if Q_DEBUG_BEST_FIRST_REP
								cout << " with " << dbEvaluatedCostTmp << endl;
#endif
								//double dbTmp = Get_InsertedNode_Cost(inVehIdx, inTripIdx, arr_Permutation[i]);
								if (dbBestTmp > dbEvaluatedCostTmp)
								{
									dbBestTmp = dbEvaluatedCostTmp;
									inBestVehIdx = inVehIdx;
									inBestTripIdx = inTripIdx;
								}
							} else 
							{
#if Q_DEBUG_BEST_FIRST_REP
								cout << " failed" << endl;
#endif
							}
						}
					}				
				}
				if (inBestVehIdx > 0)
				{
#if Q_DEBUG_BEST_FIRST_REP
				cout << "\t\t\t Insert PICKUP "<< arr_Permutation[i] << " to vehicle " << inBestVehIdx << " trip..." << inBestTripIdx << endl;
#endif
					bRetVal = Insert_A_Pickup(arr_Permutation[i], inBestVehIdx, inBestTripIdx, true, &dbEvaluatedCostTmp);
					if (bRetVal)
					{
						if (false == Valid_A_Trip(inBestVehIdx, inBestTripIdx))
						{
							cout << " failed at *ln" << __LINE__ << endl; getchar();
							return false;
						} else
						{
#if Q_DEBUG_BEST_FIRST_REP
							cout << " ok!" << endl;
#endif
						}
					} else
					{
						cout << " failed at ln" << __LINE__ << endl; getchar();
					}
				} else
				{
#if Q_DEBUG_BEST_FIRST_REP
					cout << endl << "\t\t\t\t Critical ERR --> Create SINGLE/ROLLBACK" << endl;
#endif
					if (i == 1)
					{
#if Q_CRIT_SKIP
						cout << "\t\t\t\t First Insert must be ok! *ln" << __LINE__ << endl; getchar();
#endif
					}
					return false;

				}

				break;

			case NODE_DELIVERY:
#if Q_DEBUG_BEST_FIRST_REP
				cout << "\t\t\t Evaluate DELIVERY "<< arr_Permutation[i] << "... " << endl; 
#endif
				for (int inVehIdx = 1; inVehIdx <= numVeh; inVehIdx++)
				{
					for (int inTripIdx=1; inTripIdx<=seg[inVehIdx].numTrips; inTripIdx++)
					{
						if ((TRIP_DELIVERY == seg[inVehIdx].Trip[inTripIdx].Type) && (true == Belong_To_SP(arr_Permutation[i], seg[inVehIdx].Trip[inTripIdx].startNodeIdx)))
						{
#if Q_DEBUG_BEST_FIRST_REP
							cout << "\t\t\t\t to vehicle " << inVehIdx << " trip " << inTripIdx;
#endif
							bRetVal = Insert_A_Delivery(arr_Permutation[i], inVehIdx, inTripIdx, false, &dbEvaluatedCostTmp);
							if (bRetVal)
							{
#if Q_DEBUG_BEST_FIRST_REP
								cout << " with " << dbEvaluatedCostTmp << endl;
#endif
								//double dbTmp = Get_InsertedNode_Cost(inVehIdx, inTripIdx, arr_Permutation[i]);
								if (dbBestTmp > dbEvaluatedCostTmp)
								{
									dbBestTmp = dbEvaluatedCostTmp;
									inBestVehIdx = inVehIdx;
									inBestTripIdx = inTripIdx;
								}
							} else 
							{
#if Q_DEBUG_BEST_FIRST_REP
								cout << " failed" << endl;
#endif
							}
						}
					}
				}
				if (inBestVehIdx > 0)
				{
#if Q_DEBUG_BEST_FIRST_REP
				cout << "\t\t\t Insert DELIVERY "<< arr_Permutation[i] << " to vehicle " << inBestVehIdx << " trip..." << inBestTripIdx << endl;
#endif
					bRetVal = Insert_A_Delivery(arr_Permutation[i], inBestVehIdx, inBestTripIdx, true, &dbEvaluatedCostTmp);
					if (bRetVal)
					{
						if (false == Valid_A_Trip(inBestVehIdx, inBestTripIdx))
						{
							cout << " failed at *l" << __LINE__ << endl; getchar();
							return false;
						} else
						{
#if Q_DEBUG_BEST_FIRST_REP
							cout << " ok!" << endl;
#endif
						}
					} else
					{
						cout << " failed at *l" << __LINE__ << endl; getchar();
					}
				} else
				{
#if Q_DEBUG_BEST_FIRST_REP
					cout << endl << "\t\t\t\t Critical ERR --> Create SINGLE/ROLLBACK" << endl;
#endif
					if (i == 1)
					{
#if Q_CRIT_SKIP
						cout << "\t\t\t\t First Insert must be ok! *ln" << __LINE__ << endl; getchar();
#endif
					}
					return false;

				}
			
				break;

			case NODE_C2C_PICKUP:
#if Q_DEBUG_BEST_FIRST_REP
				cout << "\t\t\t Evaluate C2C "<< arr_Permutation[i] << "... " << endl;
#endif
				bRetVal = false;
				for (int inVehIdx = 1; inVehIdx <= numVeh; inVehIdx++)
				{
					for (int inTripIdx=1; inTripIdx<=seg[inVehIdx].numTrips; inTripIdx++)
					{
						if (TRIP_C2C == seg[inVehIdx].Trip[inTripIdx].Type)
						{
#if Q_DEBUG_BEST_FIRST_REP
							cout << "\t\t\t\t to vehicle " << inVehIdx << " trip " << inTripIdx;
#endif
							bRetVal = Insert_A_C2C(arr_Permutation[i], inVehIdx, inTripIdx, false, &dbEvaluatedCostTmp);
							if (bRetVal)
							{
#if Q_DEBUG_BEST_FIRST_REP
								cout << " with " << dbEvaluatedCostTmp << endl;
#endif
		//						double dbTmp = Get_InsertedNode_Cost(inVehIdx, inTripIdx, arr_Permutation[i]);
								if (dbBestTmp > dbEvaluatedCostTmp)
								{
									dbBestTmp = dbEvaluatedCostTmp;
									inBestVehIdx = inVehIdx;
									inBestTripIdx = inTripIdx;
								}
							} else
							{
#if Q_DEBUG_BEST_FIRST_REP
								cout << " failed" << endl;
#endif
							}
						}
					}
				}
				if (inBestVehIdx > 0)
				{
#if Q_DEBUG_BEST_FIRST_REP
				cout << "\t\t\t Insert C2C "<< arr_Permutation[i] << " to vehicle " << inBestVehIdx << " trip... " << inBestTripIdx << endl;
#endif
					bRetVal = Insert_A_C2C(arr_Permutation[i], inBestVehIdx, inBestTripIdx, true, &dbEvaluatedCostTmp);
					if (bRetVal)
					{
						if (false == Valid_A_Trip(inBestVehIdx, inBestTripIdx))
						{
#if Q_CRIT_SKIP
							cout << " failed at *ln" << __LINE__ << endl; getchar();
#endif
							return false;
						} else
						{
#if Q_DEBUG_BEST_FIRST_REP
							cout << " ok!" << endl;
#endif
						}
					} else
					{
						cout << " failed at *l" << __LINE__ << endl; getchar();
					}
				} else
				{
#if Q_DEBUG_BEST_FIRST_REP
					cout << endl << "\t\t\t\t Critical ERR --> Create SINGLE/ROLLBACK" << endl;
#endif
					if (i == 1)
					{
#if Q_CRIT_SKIP
						cout << "\t\t\t\t First Insert must be ok! *ln" << __LINE__ << endl; getchar();
#endif
					}
					return false;
				}
				break;

			case NODE_C2C_DELIVERY:
				cout << "Not supported *ln" << __LINE__ << endl; getchar();
				break;
			default:
				cout << "Not supported *ln" << __LINE__ << endl; getchar();
				return false;
		}
	}

	return true;
}
// Calc. REGRET Value
double Solution::Calc_Regret_Value(int inNodeIdx)
{
	double dbEvaluatedCostTmp;
	bool bRetVal;
	double dbBestInsertion, dbSecondBest;

	int inNodeType = Get_Node_Type(inNodeIdx);
	dbBestInsertion = PDS_INFINITY;
	dbSecondBest = PDS_INFINITY;

	switch (inNodeType)
	{
		case NODE_PICKUP:
#if Q_DEBUG_2_REGRET_VAL
				cout << "\t\t\t Calc. regret value PICKUP "<< inNodeIdx << "... " << endl; 
#endif
				for (int inVehIdx = 1; inVehIdx <= numVeh; inVehIdx++)
				{
					for (int inTripIdx=1; inTripIdx<=seg[inVehIdx].numTrips; inTripIdx++)
					{
						//This assigned SP can serve this pikcup node also
						if ((TRIP_PICKUP == seg[inVehIdx].Trip[inTripIdx].Type)  && (true == Belong_To_SP(inNodeIdx, seg[inVehIdx].Trip[inTripIdx].endNodeIdx)))
						{
#if Q_DEBUG_2_REGRET_VAL
							cout << "\t\t\t\t to vehicle " << inVehIdx << " trip " << inTripIdx;
#endif
							bRetVal = Insert_A_Pickup(inNodeIdx, inVehIdx, inTripIdx, false, &dbEvaluatedCostTmp);
							if (bRetVal)
							{
#if Q_DEBUG_2_REGRET_VAL
								cout << " with " << dbEvaluatedCostTmp << endl;
#endif
								if (dbBestInsertion > dbEvaluatedCostTmp)
								{
									dbBestInsertion = dbEvaluatedCostTmp;
								} else if (dbSecondBest > dbEvaluatedCostTmp)
								{
									dbSecondBest = dbEvaluatedCostTmp;
								}
							} else 
							{
#if Q_DEBUG_2_REGRET_VAL
								cout << " failed" << endl;
#endif
							}
						}
					}				
				}

				if ((PDS_INFINITY == dbBestInsertion) || (PDS_INFINITY == dbSecondBest))
				{
#if Q_DEBUG_2_REGRET_VAL
					cout << "\t\t\t\t " << (-PDS_INFINITY) << endl;
#endif
					return (-PDS_INFINITY);
				}

#if Q_DEBUG_2_REGRET_VAL
				cout << "\t\t\t\t " << (dbBestInsertion - dbSecondBest) << " (" << dbBestInsertion << "|" << dbSecondBest << ")" << endl;
#endif
				return (dbBestInsertion - dbSecondBest);
			break;

		case NODE_DELIVERY:
#if Q_DEBUG_2_REGRET_VAL
				cout << "\t\t\t Calc. regret value DELIVERY "<< inNodeIdx << "... " << endl; 
#endif
				for (int inVehIdx = 1; inVehIdx <= numVeh; inVehIdx++)
				{
					for (int inTripIdx=1; inTripIdx<=seg[inVehIdx].numTrips; inTripIdx++)
					{
						if ((TRIP_DELIVERY == seg[inVehIdx].Trip[inTripIdx].Type) && (true == Belong_To_SP(inNodeIdx, seg[inVehIdx].Trip[inTripIdx].startNodeIdx)))
						{
#if Q_DEBUG_2_REGRET_VAL
							cout << "\t\t\t\t to vehicle " << inVehIdx << " trip " << inTripIdx;
#endif
							bRetVal = Insert_A_Delivery(inNodeIdx, inVehIdx, inTripIdx, false, &dbEvaluatedCostTmp);
							if (bRetVal)
							{
#if Q_DEBUG_2_REGRET_VAL
								cout << " with " << dbEvaluatedCostTmp << endl;
#endif
								if (dbBestInsertion > dbEvaluatedCostTmp)
								{
									dbBestInsertion = dbEvaluatedCostTmp;
								} else if (dbSecondBest > dbEvaluatedCostTmp)
								{
									dbSecondBest = dbEvaluatedCostTmp;
								}
							} else 
							{
#if Q_DEBUG_2_REGRET_VAL
								cout << " failed" << endl;
#endif
							}
						}
					}
				}
				if ((PDS_INFINITY == dbBestInsertion) || (PDS_INFINITY == dbSecondBest))
				{
#if Q_DEBUG_2_REGRET_VAL
					cout << "\t\t\t\t " << (-PDS_INFINITY) << endl;
#endif
					return (-PDS_INFINITY);
				}

#if Q_DEBUG_2_REGRET_VAL
					cout << "\t\t\t\t " << (dbBestInsertion - dbSecondBest) << " (" << dbBestInsertion << "|" << dbSecondBest << ")" << endl;
#endif
				return (dbBestInsertion - dbSecondBest);
			break;

		case NODE_C2C_PICKUP:
#if Q_DEBUG_2_REGRET_VAL
				cout << "\t\t\t Calc. regret value DELIVERY "<< inNodeIdx << "... " << endl; 
#endif
				for (int inVehIdx = 1; inVehIdx <= numVeh; inVehIdx++)
				{
					for (int inTripIdx=1; inTripIdx<=seg[inVehIdx].numTrips; inTripIdx++)
					{
						if (TRIP_C2C == seg[inVehIdx].Trip[inTripIdx].Type) 
						{
#if Q_DEBUG_2_REGRET_VAL
							cout << "\t\t\t\t to vehicle " << inVehIdx << " trip " << inTripIdx;
#endif
							bRetVal = Insert_A_C2C(inNodeIdx, inVehIdx, inTripIdx, false, &dbEvaluatedCostTmp);
							if (bRetVal)
							{
#if Q_DEBUG_2_REGRET_VAL
								cout << " with " << dbEvaluatedCostTmp << endl;
#endif
								if (dbBestInsertion > dbEvaluatedCostTmp)
								{
									dbBestInsertion = dbEvaluatedCostTmp;
								} else if (dbSecondBest > dbEvaluatedCostTmp)
								{
									dbSecondBest = dbEvaluatedCostTmp;
								}
							} else
							{
#if Q_DEBUG_2_REGRET_VAL
								cout << " failed" << endl;
#endif
							}
						}
					}
				}

				if ((PDS_INFINITY == dbBestInsertion) || (PDS_INFINITY == dbSecondBest))
				{
#if Q_DEBUG_2_REGRET_VAL
					cout << "\t\t\t\t " << (-PDS_INFINITY) << endl;
#endif
					return (-PDS_INFINITY);
				}

#if Q_DEBUG_2_REGRET_VAL
					cout << "\t\t\t\t " << (dbBestInsertion - dbSecondBest) << " (" << dbBestInsertion << "|" << dbSecondBest << ")" << endl;
#endif
				return (dbBestInsertion - dbSecondBest);

				break;
		default:
			break;
	}

	return (-PDS_INFINITY);
}
/*
 * This neighborhoods (Ropke and Pisinger) order demands in the removed list by decreasing REGRET value
 * The REGRET value is the fitness difference between the best insertion and the second best
 * The neighborhood first inserts the one that creates the largest regret value
 */
bool Solution::Two_Regret_Repair()
{
	
	int arr_Repair_List[1000];
	int inRepairLstSz;
	int arr_Permutation[1000];
	double arr_Regret_Value[1000];
	bool bRetVal;
	double dbBestTmp;
	int inBestVehIdx;
	int inBestTripIdx;
	double dbEvaluatedCostTmp;
	double dbRegretValue;

#if Q_DEBUG_2_REGRET_REP
	cout << "\t\t\t 2-REGRET REPAIR" << endl;
#endif

	/*
	 * For removed pickup-customer, allow to re-insert to any existing pickup legs of the solution,
	 * for which the collected freight is brought to assignment supply point
	 */
	//Build the remvoved list.
	inRepairLstSz = 0;
	for (int i = nSP + 1; i <= nD + nP + nOrder + nOrder + nSP; i++) // all customer-demands
	{
		if ((i >= nOrder+nSP+1) && (i <= nOrder + nOrder + nSP)) continue; // skip c2c-delivery because we consider c2c-pickup already
		if (0 == routed[i]) // means this customer-demand is not be routed
		{
			inRepairLstSz++;
			arr_Repair_List[inRepairLstSz] = i;
		}
	}
#if Q_DEBUG_2_REGRET_REP
	cout << "\t\t\t Removed list: ";
	for (int i = 1; i <= inRepairLstSz; i++)
	{
		cout << arr_Repair_List[i] <<  " ";
	}
	cout << endl;
#endif

	for (int i = 1; i <= inRepairLstSz; i++)
	{
		arr_Permutation[i] = arr_Repair_List[i];
	}
	// Cacl. REGRET VALUE for removed demand --> copy to arr_Permutation
	for (int i = 1; i <= inRepairLstSz; i++)
	{
		arr_Regret_Value[i] = Calc_Regret_Value(arr_Repair_List[i]);
	}
#if Q_DEBUG_2_REGRET_REP
	cout << "\t\t\t Removed with regret value list: ";
	for (int i = 1; i <= inRepairLstSz; i++)
	{
		cout << arr_Permutation[i] <<  "(" << arr_Regret_Value[i] << ") ";
	}
	cout << endl;
#endif

	// Sort decrease - BB sort for easy implementation
	for (int i = 1; i <= inRepairLstSz; i++)
	{
		for (int j = i+1; j <= inRepairLstSz; j++)
		{
			if (arr_Regret_Value[i] < arr_Regret_Value[j])
			{
				double dbRegTmp = arr_Regret_Value[i];
				arr_Regret_Value[i] = arr_Regret_Value[j];
				arr_Regret_Value[j] = dbRegTmp;

				int inNodeIdxTmp = arr_Permutation[i];
				arr_Permutation[i] = arr_Permutation[j];
				arr_Permutation[j] = inNodeIdxTmp;
			}
		}
	}


	// Make permutation of the list
	//RandPermutation(inRepairLstSz, arr_Repair_List, arr_Permutation);
#if Q_DEBUG_2_REGRET_REP
	cout << "\t\t\t The sorted decrease by regret value of removed list: ";
	for (int i = 1; i <= inRepairLstSz; i++)
	{
		cout << arr_Permutation[i] <<  "(" << arr_Regret_Value[i] << ") ";
	}
	cout << endl;
#endif

	// Scan and route all customer-demands in the list
	for (int i = 1; i <= inRepairLstSz; i++)
	{
		inBestVehIdx = -1;
		inBestTripIdx = -1;
		dbBestTmp = PDS_INFINITY;

		//Get node type: pickup or delivery or c2c
		int inNodeType = Get_Node_Type(arr_Permutation[i]);
		switch (inNodeType)
		{
			case NODE_PICKUP:
#if Q_DEBUG_2_REGRET_REP
				cout << "\t\t\t Evaluate PICKUP "<< arr_Permutation[i] << "... " << endl; 
#endif
				for (int inVehIdx = 1; inVehIdx <= numVeh; inVehIdx++)
				{
					for (int inTripIdx=1; inTripIdx<=seg[inVehIdx].numTrips; inTripIdx++)
					{
						//This assigned SP can serve this pikcup node also
						if ((TRIP_PICKUP == seg[inVehIdx].Trip[inTripIdx].Type)  && (true == Belong_To_SP(arr_Permutation[i], seg[inVehIdx].Trip[inTripIdx].endNodeIdx)))
						{
#if Q_DEBUG_2_REGRET_REP
							cout << "\t\t\t\t to vehicle " << inVehIdx << " trip " << inTripIdx;
#endif
							bRetVal = Insert_A_Pickup(arr_Permutation[i], inVehIdx, inTripIdx, false, &dbEvaluatedCostTmp);
							if (bRetVal)
							{
#if Q_DEBUG_2_REGRET_REP
								cout << " with " << dbEvaluatedCostTmp << endl;
#endif
								//double dbTmp = Get_InsertedNode_Cost(inVehIdx, inTripIdx, arr_Permutation[i]);
								if (dbBestTmp > dbEvaluatedCostTmp)
								{
									dbBestTmp = dbEvaluatedCostTmp;
									inBestVehIdx = inVehIdx;
									inBestTripIdx = inTripIdx;
								}
							} else 
							{
#if Q_DEBUG_2_REGRET_REP
								cout << " failed *ln" << __LINE__ << endl;
#endif
							}
						}
					}				
				}
				if (inBestVehIdx > 0)
				{
#if Q_DEBUG_2_REGRET_REP
				cout << "\t\t\t Insert PICKUP "<< arr_Permutation[i] << "... "; 
#endif
					bRetVal = Insert_A_Pickup(arr_Permutation[i], inBestVehIdx, inBestTripIdx, true, &dbEvaluatedCostTmp);
					if (bRetVal)
					{
						if (false == Valid_A_Trip(inBestVehIdx, inBestTripIdx))
						{
#if Q_DEBUG_2_REGRET_REP
							cout << " failed *ln" << __LINE__ << endl;
#endif
							return false;
						} else
						{
#if Q_DEBUG_2_REGRET_REP
							cout << " to vehicle " << inBestVehIdx << " trip " << inBestTripIdx << endl;
#endif
						}
					}
				} else
				{
#if Q_DEBUG_2_REGRET_REP
					cout << endl << "\t\t\t\t Critical ERR --> Create SINGLE/ROLLBACK" << endl;
#endif
					if (i == 1)
					{
#if Q_CRIT_SKIP
						cout << "\t\t\t\t First Insert must be ok! *ln" << __LINE__ << endl; getchar();
#endif
					}
					return false;

				}

				break;

			case NODE_DELIVERY:
#if Q_DEBUG_2_REGRET_REP
				cout << "\t\t\t Evaluate DELIVERY "<< arr_Permutation[i] << "... " << endl; 
#endif
				for (int inVehIdx = 1; inVehIdx <= numVeh; inVehIdx++)
				{
					for (int inTripIdx=1; inTripIdx<=seg[inVehIdx].numTrips; inTripIdx++)
					{
						if ((TRIP_DELIVERY == seg[inVehIdx].Trip[inTripIdx].Type) && (true == Belong_To_SP(arr_Permutation[i], seg[inVehIdx].Trip[inTripIdx].startNodeIdx)))
						{
#if Q_DEBUG_2_REGRET_REP
							cout << "\t\t\t\t to vehicle " << inVehIdx << " trip " << inTripIdx;
#endif
							bRetVal = Insert_A_Delivery(arr_Permutation[i], inVehIdx, inTripIdx, false, &dbEvaluatedCostTmp);
							if (bRetVal)
							{
#if Q_DEBUG_2_REGRET_REP
								cout << " with " << dbEvaluatedCostTmp << endl;
#endif
								//double dbTmp = Get_InsertedNode_Cost(inVehIdx, inTripIdx, arr_Permutation[i]);
								if (dbBestTmp > dbEvaluatedCostTmp)
								{
									dbBestTmp = dbEvaluatedCostTmp;
									inBestVehIdx = inVehIdx;
									inBestTripIdx = inTripIdx;
								}
							} else 
							{
#if Q_DEBUG_2_REGRET_REP
								cout << " failed *ln" << __LINE__ << endl;
#endif
							}
						}
					}
				}
				if (inBestVehIdx > 0)
				{
#if Q_DEBUG_2_REGRET_REP
				cout << "\t\t\t Insert DELIVERY "<< arr_Permutation[i] << "... "; 
#endif
					bRetVal = Insert_A_Delivery(arr_Permutation[i], inBestVehIdx, inBestTripIdx, true, &dbEvaluatedCostTmp);
					if (bRetVal)
					{
						if (false == Valid_A_Trip(inBestVehIdx, inBestTripIdx))
						{
#if Q_DEBUG_2_REGRET_REP
							cout << " failed *ln" << __LINE__ << endl;
#endif
							return false;
						} else
						{
#if Q_DEBUG_2_REGRET_REP
							cout << " to vehicle " << inBestVehIdx << " trip " << inBestTripIdx << endl;
#endif
						}
					}
				} else
				{
#if Q_DEBUG_2_REGRET_REP
					cout << endl << "\t\t\t\t Critical ERR --> Create SINGLE/ROLLBACK *ln" << __LINE__ << endl;
#endif
					if (i == 1)
					{
#if Q_CRIT_SKIP
						cout << "\t\t\t\t First Insert must be ok! *ln" << __LINE__  << endl; getchar();
#endif
					}
					return false;

				}
			
				break;

			case NODE_C2C_PICKUP:
#if Q_DEBUG_2_REGRET_REP
				cout << "\t\t\t Evaluate C2C "<< arr_Permutation[i] << "... " << endl;
#endif
				bRetVal = false;
				for (int inVehIdx = 1; inVehIdx <= numVeh; inVehIdx++)
				{
					for (int inTripIdx=1; inTripIdx<=seg[inVehIdx].numTrips; inTripIdx++)
					{
						if (TRIP_C2C == seg[inVehIdx].Trip[inTripIdx].Type) // For Debuging only, sperate trip
						{
#if Q_DEBUG_2_REGRET_REP
							cout << "\t\t\t\t to vehicle " << inVehIdx << " trip " << inTripIdx;
#endif
							bRetVal = Insert_A_C2C(arr_Permutation[i], inVehIdx, inTripIdx, false, &dbEvaluatedCostTmp);
							if (bRetVal)
							{
#if Q_DEBUG_2_REGRET_REP
								cout << " with " << dbEvaluatedCostTmp << endl;
#endif
		//						double dbTmp = Get_InsertedNode_Cost(inVehIdx, inTripIdx, arr_Permutation[i]);
								if (dbBestTmp > dbEvaluatedCostTmp)
								{
									dbBestTmp = dbEvaluatedCostTmp;
									inBestVehIdx = inVehIdx;
									inBestTripIdx = inTripIdx;
								}
							} else
							{
#if Q_DEBUG_2_REGRET_REP
								cout << " failed *ln" << __LINE__ << endl;
#endif
							}
						}
					}
				}
				if (inBestVehIdx > 0)
				{
#if Q_DEBUG_2_REGRET_REP
				cout << "\t\t\t Insert C2C "<< arr_Permutation[i] << "... "; 
#endif
					bRetVal = Insert_A_C2C(arr_Permutation[i], inBestVehIdx, inBestTripIdx, true, &dbEvaluatedCostTmp);
					if (bRetVal)
					{
						if (false == Valid_A_Trip(inBestVehIdx, inBestTripIdx))
						{
#if Q_DEBUG_2_REGRET_REP
							cout << " failed *ln" << __LINE__ << endl;
#endif
							return false;
						} else
						{
#if Q_DEBUG_2_REGRET_REP
							cout << " to vehicle " << inBestVehIdx << " trip " << inBestTripIdx << endl;
#endif
						}
					}
				} else
				{
#if Q_DEBUG_2_REGRET_REP
					cout << endl << "\t\t\t\t Critical ERR --> Create SINGLE/ROLLBACK *ln" << __LINE__ << endl;
#endif
					if (i == 1)
					{
#if Q_CRIT_SKIP
						cout << "\t\t\t\t First Insert must be ok! *ln" << __LINE__ << endl; getchar();
#endif
					}
					return false;
				}
				break;

			case NODE_C2C_DELIVERY:
				cout << "Not supported *ln" << __LINE__ << endl; getchar();
				return false;
			default:
				cout << "Not supported *ln" << __LINE__ << endl; getchar();
				return false;
		}
	}

	return true;
}
// Insert removed pickup trip at the beginning of the current pickup trip that has same supply point.
bool Solution::Insert_A_Pick_Leg_At_Begin(int inVehIdx, int inTripIdx, int inRemovedTripIdx, bool isEvaluated, double *dbEvaluatedCost)
{
	int inTmp;
#if Q_D_INS_A_LEG_BEGINNING
	cout << "Before inserting..." << endl;
	Show_A_Vehicle(inVehIdx);
#endif
	// save a copy
	memcpy(&seg[MAX_VEH+1], &seg[inVehIdx], sizeof(VRPSegment));

	int inLastCus = removedTrip[inRemovedTripIdx].lastCus;
	inTmp = nextArr[inLastCus];
	nextArr[inLastCus] = seg[inVehIdx].Trip[inTripIdx].firstCus;

	seg[inVehIdx].Trip[inTripIdx].firstCus = removedTrip[inRemovedTripIdx].firstCus;
	seg[inVehIdx].Trip[inTripIdx].numCus += removedTrip[inRemovedTripIdx].numCus;
	
	//Update endNodeIdx of previous trip
	if (inTripIdx > 1)
	{
		if (seg[inVehIdx].Trip[inTripIdx-1].Type != TRIP_PICKUP)
		{
			seg[inVehIdx].Trip[inTripIdx-1].endNodeIdx = seg[inVehIdx].Trip[inTripIdx].firstCus;
		}
	}

	// Reset time for vehicle 
		if (false == Set_Time_For_A_Vehicle(inVehIdx, 1, 0, true))
		{
#if Q_D_INS_A_LEG_BEGINNING
			cout << "After inserting vehicle " << inVehIdx << " trip " << inTripIdx <<" at the beginning leg " << endl;
			Show_A_Vehicle(inVehIdx);
			cout << "Reset time failed" << endl;
#endif

			// Roll-back
			memcpy(&seg[inVehIdx], &seg[MAX_VEH+1], sizeof(VRPSegment));
			nextArr[inLastCus] = inTmp;
			return false;
		} else
		{
#if Q_D_INS_A_LEG_BEGINNING
			Show_A_Vehicle(inVehIdx);
#endif
			double dbTotalCostTmp;
			Check_Solution(&dbTotalCostTmp);
			*dbEvaluatedCost = dbTotalCostTmp;

			if (isEvaluated) // in case of evaluation, roll back after get cost
			{
				memcpy(&seg[inVehIdx], &seg[MAX_VEH+1], sizeof(VRPSegment));
				nextArr[inLastCus] = inTmp;
			}
			return true;

		}

	return false;
}
bool Solution::Insert_A_Pick_Leg_At_End(int inVehIdx, int inTripIdx, int inRemovedTripIdx, bool isEvaluated, double *dbEvaluatedCost)
{
	int inTmp;
#if Q_D_INS_A_LEG_END
	cout << "Before inserting ... " << endl;
	Show_A_Vehicle(inVehIdx);
#endif
	// save a copy
	memcpy(&seg[MAX_VEH+1], &seg[inVehIdx], sizeof(VRPSegment));

	int inLastCus = seg[inVehIdx].Trip[inTripIdx].lastCus;
	inTmp = nextArr[inLastCus];
	nextArr[inLastCus] = removedTrip[inRemovedTripIdx].firstCus;

	seg[inVehIdx].Trip[inTripIdx].lastCus = removedTrip[inRemovedTripIdx].lastCus;
	seg[inVehIdx].Trip[inTripIdx].numCus += removedTrip[inRemovedTripIdx].numCus;
	
	// Reset time for vehicle 
		if (false == Set_Time_For_A_Vehicle(inVehIdx, 1, 0, true))
		{
#if Q_D_INS_A_LEG_END
			cout << "After inserting vehicle " << inVehIdx << " trip " << inTripIdx <<" at the end leg " << endl;
			Show_A_Vehicle(inVehIdx);
			cout << "Reset time failed" << endl;
#endif

			// Roll-back
			memcpy(&seg[inVehIdx], &seg[MAX_VEH+1], sizeof(VRPSegment));
			nextArr[inLastCus] = inTmp;
			return false;
		} else
		{
#if Q_D_INS_A_LEG_END
			Show_A_Vehicle(inVehIdx);
#endif
			double dbTotalCostTmp;
			Check_Solution(&dbTotalCostTmp);
			*dbEvaluatedCost = dbTotalCostTmp;

			if (isEvaluated) // in case of evaluation, roll back after get cost
			{
				memcpy(&seg[inVehIdx], &seg[MAX_VEH+1], sizeof(VRPSegment));
				nextArr[inLastCus] = inTmp;
			}
			return true;

		}

	return false;
}
bool Solution::Insert_A_Del_Leg_At_End(int inVehIdx, int inTripIdx, int inRemovedTripIdx, bool isEvaluated, double *dbEvaluatedCost)
{
	int inTmp;
#if Q_D_INS_A_LEG_END
	Show_A_Vehicle(inVehIdx);
#endif
	// save a copy
	memcpy(&seg[MAX_VEH+1], &seg[inVehIdx], sizeof(VRPSegment));

	int inLastCus = seg[inVehIdx].Trip[inTripIdx].lastCus;
	inTmp = nextArr[inLastCus];
	nextArr[inLastCus] = removedTrip[inRemovedTripIdx].firstCus;

	seg[inVehIdx].Trip[inTripIdx].lastCus = removedTrip[inRemovedTripIdx].lastCus;
	seg[inVehIdx].Trip[inTripIdx].numCus += removedTrip[inRemovedTripIdx].numCus;
	
	// Update startNodeIdx of next trip: inTripIdx+1
	if (seg[inVehIdx].numTrips > inTripIdx)
	{
		if (TRIP_DELIVERY != seg[inVehIdx].Trip[inTripIdx+1].Type)
		{
			seg[inVehIdx].Trip[inTripIdx+1].startNodeIdx = seg[inVehIdx].Trip[inTripIdx].lastCus;
		}
	}

#if Q_D_INS_A_LEG_END
	Show_A_Vehicle(inVehIdx);
#endif
	// Reset time for vehicle 
		if (false == Set_Time_For_A_Vehicle(inVehIdx, 1, 0, true))
		{
#if Q_D_INS_A_LEG_END
			cout << "After inserting vehicle " << inVehIdx << " trip " << inTripIdx <<" at the end leg " << endl;
			Show_A_Vehicle(inVehIdx);
			cout << "Reset time failed" << endl;
#endif

			// Roll-back
			memcpy(&seg[inVehIdx], &seg[MAX_VEH+1], sizeof(VRPSegment));
			nextArr[inLastCus] = inTmp;
			return false;
		} else
		{
#if Q_D_INS_A_LEG_END
			Show_A_Vehicle(inVehIdx);
#endif
			double dbTotalCostTmp;
			Check_Solution(&dbTotalCostTmp);
			*dbEvaluatedCost = dbTotalCostTmp;

			if (isEvaluated) // in case of evaluation, roll back after get cost
			{
				memcpy(&seg[inVehIdx], &seg[MAX_VEH+1], sizeof(VRPSegment));
				nextArr[inLastCus] = inTmp;
			}
			return true;

		}

	return false;
}
// Insert removed delivery trip at the beginning of the current delivery trip that has same supply point.
bool Solution::Insert_A_Del_Leg_At_Begin(int inVehIdx, int inTripIdx, int inRemovedTripIdx, bool isEvaluated, double *dbEvaluatedCost)
{
	int inTmp;
#if Q_D_INS_A_LEG_BEGINNING
	Show_A_Vehicle(inVehIdx);
#endif
	// save a copy
	memcpy(&seg[MAX_VEH+1], &seg[inVehIdx], sizeof(VRPSegment));

	int inLastCus = removedTrip[inRemovedTripIdx].lastCus;
	inTmp = nextArr[inLastCus];
	nextArr[inLastCus] = seg[inVehIdx].Trip[inTripIdx].firstCus;

	seg[inVehIdx].Trip[inTripIdx].firstCus = removedTrip[inRemovedTripIdx].firstCus;
	seg[inVehIdx].Trip[inTripIdx].numCus += removedTrip[inRemovedTripIdx].numCus;
	
	// Reset time for vehicle 
		if (false == Set_Time_For_A_Vehicle(inVehIdx, 1, 0, true))
		{
#if Q_D_INS_A_LEG_BEGINNING
			cout << "After inserting vehicle " << inVehIdx << " trip " << inTripIdx <<" at the beginning leg " << endl;
			Show_A_Vehicle(inVehIdx);
			cout << "Reset time failed" << endl;
#endif

			// Roll-back
			memcpy(&seg[inVehIdx], &seg[MAX_VEH+1], sizeof(VRPSegment));
			nextArr[inLastCus] = inTmp;
			return false;
		} else
		{
#if Q_D_INS_A_LEG_BEGINNING
			Show_A_Vehicle(inVehIdx);
#endif
			double dbTotalCostTmp;
			Check_Solution(&dbTotalCostTmp);
			*dbEvaluatedCost = dbTotalCostTmp;

			if (isEvaluated) // in case of evaluation, roll back after get cost
			{
				memcpy(&seg[inVehIdx], &seg[MAX_VEH+1], sizeof(VRPSegment));
				nextArr[inLastCus] = inTmp;
			}
			return true;

		}

	return false;
}
// Insert a leg at position tripIdx
bool Solution::Insert_A_Leg(int inVehIdx, int inTripIdx, int inRemovedTripIdx, bool isEvaluated, double *dbEvaluatedCost)
{

#if Q_D_INS_A_LEG
	Show_A_Vehicle(inVehIdx);
#endif
	

	memcpy(&seg[MAX_VEH+1], &seg[inVehIdx], sizeof(VRPSegment));

	if (inTripIdx == seg[inVehIdx].numTrips)
	{ // insert at the end of trips
#if 0 
		cout << "insert at the end of trips " << __LINE__ << endl;
#endif
		seg[inVehIdx].numTrips++;
		memcpy(&seg[inVehIdx].Trip[seg[inVehIdx].numTrips], &removedTrip[inRemovedTripIdx], sizeof(VRPTrip));

		//Update startNodeIdx of last trip
		if (seg[inVehIdx].Trip[seg[inVehIdx].numTrips].Type != TRIP_DELIVERY)
		{
			if (seg[inVehIdx].Trip[seg[inVehIdx].numTrips-1].Type == TRIP_PICKUP)
			{
				seg[inVehIdx].Trip[seg[inVehIdx].numTrips].startNodeIdx = seg[inVehIdx].Trip[seg[inVehIdx].numTrips-1].endNodeIdx;
			} else
			{
				seg[inVehIdx].Trip[seg[inVehIdx].numTrips].startNodeIdx = seg[inVehIdx].Trip[seg[inVehIdx].numTrips-1].lastCus;
			}
		}

		//Update endNodeIdx of last trip
		if (seg[inVehIdx].Trip[seg[inVehIdx].numTrips].Type != TRIP_PICKUP)
		{
			seg[inVehIdx].Trip[seg[inVehIdx].numTrips].endNodeIdx = 0;
		}

		// Update endNodeIdx of ...
		if (seg[inVehIdx].Trip[seg[inVehIdx].numTrips-1].Type != TRIP_PICKUP)
		{
			if (seg[inVehIdx].Trip[seg[inVehIdx].numTrips].Type == TRIP_DELIVERY)
			{
				seg[inVehIdx].Trip[seg[inVehIdx].numTrips-1].endNodeIdx = seg[inVehIdx].Trip[seg[inVehIdx].numTrips].startNodeIdx;
			} else
			{
				seg[inVehIdx].Trip[seg[inVehIdx].numTrips-1].endNodeIdx = seg[inVehIdx].Trip[seg[inVehIdx].numTrips].firstCus;
			}
		}
		// Reset time for vehicle 
			if (false == Set_Time_For_A_Vehicle(inVehIdx, 1, 0, true))
			{
#if Q_D_INS_A_LEG
				cout << "After inserting leg " << inTripIdx << endl;
				Show_A_Vehicle(inVehIdx);
				cout << "Reset time failed" << endl;
#endif

				// Roll-back
				memcpy(&seg[inVehIdx], &seg[MAX_VEH+1], sizeof(VRPSegment));
				return false;
			} else
			{
#if Q_D_INS_A_LEG
				Show_A_Vehicle(inVehIdx);
#endif
				double dbTotalCostTmp;
				Check_Solution(&dbTotalCostTmp);
				*dbEvaluatedCost = dbTotalCostTmp;

				if (isEvaluated) // in case of evaluation, roll back after get cost
				{
					memcpy(&seg[inVehIdx], &seg[MAX_VEH+1], sizeof(VRPSegment));
				}
				return true;
			}
	} else if (1 == inTripIdx)
	{ // insert at the beginning of trips
#if 0
		cout << "insert at the beginning of trips " << __LINE__ << endl;
#endif	
		seg[inVehIdx].numTrips++;
		for (int i = seg[inVehIdx].numTrips-1; i >= 1; i--)
		{
			memcpy(&seg[inVehIdx].Trip[i+1], &seg[inVehIdx].Trip[i], sizeof(VRPTrip));
		}
		memcpy(&seg[inVehIdx].Trip[1], &removedTrip[inRemovedTripIdx], sizeof(struct VRPTrip));

		// Update startNode of first trip
		if (seg[inVehIdx].Trip[1].Type != TRIP_DELIVERY)
		{
			seg[inVehIdx].Trip[1].startNodeIdx = 0;
		}
		// Update endNode of first trip
		if (seg[inVehIdx].Trip[1].Type != TRIP_PICKUP)
		{
			if (seg[inVehIdx].Trip[2].Type == TRIP_DELIVERY)
			{
				seg[inVehIdx].Trip[1].endNodeIdx = seg[inVehIdx].Trip[2].startNodeIdx;
			} else
			{
				seg[inVehIdx].Trip[1].endNodeIdx = seg[inVehIdx].Trip[2].firstCus;
			}
		}

		// Update startNode of second trip
		if (seg[inVehIdx].Trip[2].Type != TRIP_DELIVERY)
		{
			if (seg[inVehIdx].Trip[1].Type == TRIP_PICKUP)
			{
				seg[inVehIdx].Trip[2].startNodeIdx = seg[inVehIdx].Trip[1].endNodeIdx;
			} else
			{
				seg[inVehIdx].Trip[2].startNodeIdx = seg[inVehIdx].Trip[1].lastCus;
			}
		}
#if Q_D_INS_A_LEG
	//Show_A_Trip(inVehIdx, 1);
#endif
#if Q_D_INS_A_LEG
		/*cout << "Before setting time: " << endl;
		Show_A_Vehicle(inVehIdx);*/
		//Show_A_Trip();
#endif

		// Reset time for vehicle 
			if (false == Set_Time_For_A_Vehicle(inVehIdx, 1, 0, true))
			{
#if Q_D_INS_A_LEG
				cout << "After inserting leg " << inTripIdx << endl;
				Show_A_Vehicle(inVehIdx);
				cout << "Reset time failed" << endl;
#endif

				// Roll-back
				memcpy(&seg[inVehIdx], &seg[MAX_VEH+1], sizeof(VRPSegment));
				return false;
			} else
			{
#if Q_D_INS_A_LEG
				Show_A_Vehicle(inVehIdx);
#endif
				double dbTotalCostTmp;
				Check_Solution(&dbTotalCostTmp);
				*dbEvaluatedCost = dbTotalCostTmp;

				if (isEvaluated) // in case of evaluation, roll back after get cost
				{
					memcpy(&seg[inVehIdx], &seg[MAX_VEH+1], sizeof(VRPSegment));
				}
				return true;

			}
	} else
	{ // here in the intermediate of trip
#if 0 
		cout << "insert in the intermediate of trips " << __LINE__ << endl;
#endif
#if Q_D_INS_A_LEG
		cout << "Insert to trip " << inTripIdx << endl;
#endif
		seg[inVehIdx].numTrips++;
		// Move back
		for (int i = seg[inVehIdx].numTrips-1; i >= inTripIdx; i--)
		{
			memcpy(&seg[inVehIdx].Trip[i+1], &seg[inVehIdx].Trip[i], sizeof(VRPTrip));
		}
		memcpy(&seg[inVehIdx].Trip[inTripIdx], &removedTrip[inRemovedTripIdx], sizeof(struct VRPTrip));

		// Update endNodeIdx of inTripIdx-1;
		if (seg[inVehIdx].Trip[inTripIdx-1].Type != TRIP_PICKUP)
		{
			if (seg[inVehIdx].Trip[inTripIdx].Type == TRIP_DELIVERY)
			{
				seg[inVehIdx].Trip[inTripIdx-1].endNodeIdx = seg[inVehIdx].Trip[inTripIdx].startNodeIdx;
			} else
			{
				seg[inVehIdx].Trip[inTripIdx-1].endNodeIdx = seg[inVehIdx].Trip[inTripIdx].firstCus;
			}
		}

		//Update startNodeIdx of inTripIdx
		if (seg[inVehIdx].Trip[inTripIdx].Type != TRIP_DELIVERY)
		{
			if (seg[inVehIdx].Trip[inTripIdx-1].Type == TRIP_PICKUP)
			{
				seg[inVehIdx].Trip[inTripIdx].startNodeIdx = seg[inVehIdx].Trip[inTripIdx-1].endNodeIdx;
			} else
			{
				seg[inVehIdx].Trip[inTripIdx].startNodeIdx = seg[inVehIdx].Trip[inTripIdx-1].lastCus;
			}
		}
		//Update endNodeIdx of inTripIdx
		if (seg[inVehIdx].Trip[inTripIdx].Type != TRIP_PICKUP)
		{
			if (seg[inVehIdx].Trip[inTripIdx+1].Type == TRIP_DELIVERY)
			{
				seg[inVehIdx].Trip[inTripIdx].endNodeIdx = seg[inVehIdx].Trip[inTripIdx+1].startNodeIdx;
			} else
			{
				seg[inVehIdx].Trip[inTripIdx].endNodeIdx = seg[inVehIdx].Trip[inTripIdx+1].firstCus;
			}
		}


		//UPdate startNodeIdx of inTripIdx+1;
		if (seg[inVehIdx].Trip[inTripIdx+1].Type != TRIP_DELIVERY)
		{
			if (seg[inVehIdx].Trip[inTripIdx].Type == TRIP_PICKUP)
			{
				seg[inVehIdx].Trip[inTripIdx+1].startNodeIdx = seg[inVehIdx].Trip[inTripIdx].endNodeIdx;
			} else
			{
				seg[inVehIdx].Trip[inTripIdx+1].startNodeIdx = seg[inVehIdx].Trip[inTripIdx].lastCus;
			}
		}

	// Reset time for vehicle 
			if (false == Set_Time_For_A_Vehicle(inVehIdx, 1, 0, true))
			{
#if Q_D_INS_A_LEG
				cout << "After inserting leg " << inTripIdx << endl;
				Show_A_Vehicle(inVehIdx);
				cout << "Reset time failed" << endl;
#endif

				// Roll-back
				memcpy(&seg[inVehIdx], &seg[MAX_VEH+1], sizeof(VRPSegment));
				return false;
			} else
			{
#if Q_D_INS_A_LEG
				Show_A_Vehicle(inVehIdx);
#endif
				double dbTotalCostTmp;
				Check_Solution(&dbTotalCostTmp);
				*dbEvaluatedCost = dbTotalCostTmp;

				if (isEvaluated) // in case of evaluation, roll back after get cost
				{
					memcpy(&seg[inVehIdx], &seg[MAX_VEH+1], sizeof(VRPSegment));
				}
				return true;

			}
	}
}
// Check if vehicle inVehIdx has pickup trip end at supply point inSupplyPoint
bool Solution::isHasPickupTrip(int inVehIdx, int inSupplyPoint)
{
	for (int j = 1; j <= seg[inVehIdx].numTrips; j++)
	{
		if (TRIP_PICKUP == seg[inVehIdx].Trip[j].Type)
		{
			if (inSupplyPoint == seg[inVehIdx].Trip[j].endNodeIdx)
			{
				return true;
			}
		}
	}

	return false;
}
// Check if vehicle inVehIdx has delivery trip start from supply point inSupplyPoint
bool Solution::isHasDeliveryTrip(int inVehIdx, int inSupplyPoint)
{
	for (int j = 1; j <= seg[inVehIdx].numTrips; j++)
	{
		if (TRIP_DELIVERY == seg[inVehIdx].Trip[j].Type)
		{
			if (inSupplyPoint == seg[inVehIdx].Trip[j].startNodeIdx)
			{
				return true;
			}
		}
	}

	return false;
}
// Get shared SPs from list of pickup demands
void Solution::Get_Shared_SP_Pick_Demands(int inRemovedTripIdx, int *arrSP, int *inSPSz)
{
	int inNodeIdxSz;
	int arrNodeIdx[300];
	int arrCandidate[300];
	int inCandidateSz = 0;
	int j;
	int inSPSzTmp = 0;

	// Rebuild path	
	inNodeIdxSz = 0;
	int curC = removedTrip[inRemovedTripIdx].firstCus;
	while (curC > 0)
	{
		inNodeIdxSz++;
		arrNodeIdx[inNodeIdxSz] = curC;
		curC = nextArr[curC];
	}

	//Initiate.
	for (int j = 1; j <= problem->node[arrNodeIdx[1]].numSP; j++){
		if (problem->belong[arrNodeIdx[1]][problem->node[arrNodeIdx[1]].sp[j]] == 1)
		{
			//cout << problem->node[arrNodeIdx[1]].sp[j] << " ";
			inCandidateSz++;
			arrCandidate[inCandidateSz] = problem->node[arrNodeIdx[1]].sp[j];
		}
	}

	for (int k = 1; k <= inCandidateSz; k++)
	{
		bool bShared = true;
		for (int i = 2; i <= inNodeIdxSz; i++)
		{
			for (j = 1; j <= problem->node[arrNodeIdx[i]].numSP; j++){
				if (problem->belong[arrNodeIdx[i]][problem->node[arrNodeIdx[i]].sp[j]] == 1)
				{
					if (arrCandidate[k] == problem->node[arrNodeIdx[i]].sp[j])
					{
						break;
					}
				}
			}

			if (j > problem->node[arrNodeIdx[i]].numSP)
			{
				bShared = false;
			}

			if (false == bShared)
				break;
			
		}

		if (true == bShared)
		{
			inSPSzTmp++;
			arrSP[inSPSzTmp] = arrCandidate[k];
		}
	}

	*inSPSz = inSPSzTmp;

	//for (int i = 2; i <= inNodeIdxSz; i++)
	//{
	//	cout << "pickup demands: " << arrNodeIdx[i] << " has SPs: ";
	//	for (int j = 1; j <= problem->node[arrNodeIdx[i]].numSP; j++){
	//		if (problem->belong[arrNodeIdx[i]][problem->node[arrNodeIdx[i]].sp[j]] == 1)
	//		{
	//			cout << problem->node[arrNodeIdx[i]].sp[j] << " ";
	//		}
	//	}
	//	cout << endl;
	//}

}

//
bool Solution::Random_Greedy_Repair_Leg()
{
	int i, j, k;
	double dbTotalCostTmp;
	int arrSPs[100];
	int inSPSz;
	double dbBestCost;
	int inBestVehicleIdx;
	int inBestTripIdx;
	int inBestPos;
	int inReplamentSP;

#if Q_D_RAND_REPAIR_LEG
	cout << "Random greedy repair (LEG)" << endl;
#endif
	for (int k = 1; k < removeTripNbr; k++)
	{
		dbBestCost = PDS_INFINITY;
		inBestVehicleIdx = -1;
		inBestTripIdx = -1;
		inBestPos = -1;
		inReplamentSP = -1;

#if Q_D_RAND_REPAIR_LEG
	cout << "   Considering removed leg " << k  << endl;
#endif
			int inTripType =  removedTrip[k].Type;
#if Q_D_RAND_REPAIR_LEG
			cout << "     Leg type(pickup/delivery/c2c-0/1/2): " << inTripType  << endl;
#endif

			if (TRIP_DELIVERY == inTripType)
			{
				//In the former case, the whole leg {s, di, ..., dj}  is inserted to any vehicle in which there is no delivery leg starting from the supply point s
				for (i = 1; i <= numVeh; i++)
				{
					if (false == isHasDeliveryTrip(i, removedTrip[k].startNodeIdx))
					{ // vehice i has no delivery trip start from supply point removedTrip[k].startNodeIdx
						#if Q_D_RAND_REPAIR_LEG
									cout << "       Case1: Vehicle " << i << " has no delivery leg starting from SP" << removedTrip[k].startNodeIdx  << endl;
						#endif
						for (j = 1; j <= seg[i].numTrips; j++)
						{
							if (true == Insert_A_Leg(i, j, k, 1, &dbTotalCostTmp))
							{
								//Check the whole solution -> get new benefit				
								#if Q_D_RAND_REPAIR_LEG
								cout << "         Inserted to vehicle " << i << " leg " << j << " ..ok with new cost " << dbTotalCostTmp << endl;
								#endif
								// Update best 
								if (dbBestCost > dbTotalCostTmp)
								{
									dbBestCost = dbTotalCostTmp;
									inBestVehicleIdx = i;
									inBestTripIdx = j;
									inBestPos = -1;
								}
								
							} else 
							{
								#if Q_D_RAND_REPAIR_LEG
								cout << "         Inserted to vehicle " << i << " leg " << j << " ..failed!" << endl; 
								#endif
							}
						}
					} else
					{ // In the latter, the sequence of delivery customer demands {di, ..., dj} is concatenated either to the beginning or at the end of any delivery leg starting from s in the solution
						#if Q_D_RAND_REPAIR_LEG
									cout << "       Case2: Vehicle " << i << " has delivery legs starting from SP" << removedTrip[k].startNodeIdx  << endl;
						#endif
						for (j = 1; j <= seg[i].numTrips; j++)
						{
							if ((seg[i].Trip[j].Type == TRIP_DELIVERY) && (seg[i].Trip[j].startNodeIdx == removedTrip[k].startNodeIdx))
							{
								if (true == Insert_A_Del_Leg_At_Begin(i, j, k, 1, &dbTotalCostTmp))
								{
									#if Q_D_RAND_REPAIR_LEG
									cout << "         Inserted delivery to beginning vehicle " << i << " leg " << j << " ..ok with new cost " << dbTotalCostTmp << endl;
									#endif
									// Update best 
									if (dbBestCost > dbTotalCostTmp)
									{
										dbBestCost = dbTotalCostTmp;
										inBestVehicleIdx = i;
										inBestTripIdx = j;
										inBestPos = 0; //begining
									}
								} else
								{
									#if Q_D_RAND_REPAIR_LEG
									cout << "         Inserted delivery to beginning vehicle " << i << " leg " << j << " ..failed" << endl;
									#endif
								}
								if (true == Insert_A_Del_Leg_At_End(i, j, k, 1, &dbTotalCostTmp))
								{
									#if Q_D_RAND_REPAIR_LEG
									cout << "         Inserted delivery to end of vehicle " << i << " leg " << j << " ..ok with new cost " << dbTotalCostTmp << endl;
									#endif
									// Update best 
									if (dbBestCost > dbTotalCostTmp)
									{
										dbBestCost = dbTotalCostTmp;
										inBestVehicleIdx = i;
										inBestTripIdx = j;
										inBestPos = 1; //end
									}

								} else
								{
									#if Q_D_RAND_REPAIR_LEG
									cout << "         Inserted delivery to end vehicle " << i << " leg " << j << " ..failed" << endl;
									#endif
								}
							}
						}
					}
				}

			} else if (TRIP_PICKUP == inTripType)
			{
				//  Find all possible supply point
				inSPSz = 0;
				Get_Shared_SP_Pick_Demands(k, arrSPs, &inSPSz);
				if (inSPSz == 1)
				{
					#if Q_D_RAND_REPAIR_LEG
					cout << "       Case1: Vehicle " << i << " has one shared SP for all!"<< endl;
					#endif
				} else
				{
					#if Q_D_RAND_REPAIR_LEG
					cout << "       Case2 (Re-assigment): Vehicle " << i << " has " << inSPSz << " shared SP for all!"<< endl;
					#endif
				}
				int inSaveSP = removedTrip[k].endNodeIdx;
				for (int iSp = 1; iSp <= inSPSz; iSp++)
				{
					removedTrip[k].endNodeIdx = arrSPs[iSp];

					#if Q_D_RAND_REPAIR_LEG
						cout <<  "         SP " << arrSPs[iSp] << endl;
					#endif
					
					//In the former case, the whole leg {pi, ..., pj, s}  is inserted to any vehicle in which there is no pickup leg end at the supply point s
					for (i = 1; i <= numVeh; i++)
					{
						if (false == isHasPickupTrip(i, removedTrip[k].endNodeIdx))
						{ // vehice i has no delivery trip start from supply point removedTrip[k].startNodeIdx
							#if Q_D_RAND_REPAIR_LEG
							cout << "           Case1: Vehicle " << i << " has no pickup leg end at SP" << removedTrip[k].endNodeIdx  << endl;
							#endif
							for (j = 1; j <= seg[i].numTrips; j++)
							{
								if (true == Insert_A_Leg(i, j, k, 1, &dbTotalCostTmp))
								{
									//Check the whole solution -> get new benefit				
									#if Q_D_RAND_REPAIR_LEG
									cout << "             Inserted to vehicle " << i << " leg " << j << " ..ok with new cost " << dbTotalCostTmp << endl;
									#endif
									// Update best 
									if (dbBestCost > dbTotalCostTmp)
									{
										dbBestCost = dbTotalCostTmp;
										inBestVehicleIdx = i;
										inBestTripIdx = j;
										inBestPos = -1;
										inReplamentSP = arrSPs[iSp];
									}
								} else 
								{
									#if Q_D_RAND_REPAIR_LEG
									cout << "             Inserted to vehicle " << i << " leg " << j << " ..failed!" << endl; 
									#endif
								}
							}
						} else
						{ // In the latter, the sequence of delivery customer demands {pi, ..., pj} is concatenated either to the beginning or at the end of any pickup leg starting from s in the solution
							#if Q_D_RAND_REPAIR_LEG
							cout << "           Case2: Vehicle " << i << " has pickup legs end at SP" << removedTrip[k].endNodeIdx  << endl;
							#endif							
							for (j = 1; j <= seg[i].numTrips; j++)
							{
								if ((seg[i].Trip[j].Type == TRIP_PICKUP) && (seg[i].Trip[j].endNodeIdx == removedTrip[k].endNodeIdx))
								{
									if (true == Insert_A_Pick_Leg_At_Begin(i, j, k, 1, &dbTotalCostTmp))
									{
										#if Q_D_RAND_REPAIR_LEG
										cout << "             Inserted pickup to beginning vehicle " << i << " leg " << j << " ..ok with new cost " << dbTotalCostTmp << endl;
										#endif
										// Update best 
										if (dbBestCost > dbTotalCostTmp)
										{
											dbBestCost = dbTotalCostTmp;
											inBestVehicleIdx = i;
											inBestTripIdx = j;
											inBestPos = 0;
											inReplamentSP = arrSPs[iSp];
										}
									} else 
									{
										#if Q_D_RAND_REPAIR_LEG
										cout << "             Inserted pickup to beginning vehicle " << i << " leg " << j << " ..failed" << endl;
										#endif
									}
									if (true == Insert_A_Pick_Leg_At_End(i, j, k, 1, &dbTotalCostTmp))
									{
										#if Q_D_RAND_REPAIR_LEG
										cout << "             Inserted pickup to end vehicle " << i << " leg " << j << " ..ok with new cost " << dbTotalCostTmp << endl;
										#endif
										// Update best 
										if (dbBestCost > dbTotalCostTmp)
										{
											dbBestCost = dbTotalCostTmp;
											inBestVehicleIdx = i;
											inBestTripIdx = j;
											inBestPos = 1;
											inReplamentSP = arrSPs[iSp];
										}
									} else
									{
										#if Q_D_RAND_REPAIR_LEG
										cout << "             Inserted pickup to end vehicle " << i << " leg " << j << " ..failed" << endl;
										#endif
									}
								}
							}
						}
					}
				}
				removedTrip[k].endNodeIdx = inSaveSP; // roll-back for removed trip
			} else if (TRIP_C2C == inTripType)
			{
				for (i = 1; i <= numVeh; i++)
				{				
					for (j = 1; j <= seg[i].numTrips; j++)
					{
						if (true == Insert_A_Leg(i, j, k, 1, &dbTotalCostTmp))
						{
							#if Q_D_RAND_REPAIR_LEG
							cout << "       Insert c2c to vehicle " << i << " leg " << j << " ..ok with new cost " << dbTotalCostTmp << endl;
							#endif
							// Update best 
							if (dbBestCost > dbTotalCostTmp)
							{
								dbBestCost = dbTotalCostTmp;
								inBestVehicleIdx = i;
								inBestTripIdx = j;
								inBestPos = -1;
							}
						} else
						{
							#if Q_D_RAND_REPAIR_LEG
							cout << "       Insert c2c to vehicle " << i << " leg " << j << " ..failed" << endl;
							#endif
						}
					}				
				}
			} else
			{
				cout << __LINE__ << endl;
			}

		if ((-1 == inBestVehicleIdx) && (-1 == inBestTripIdx))
		{
			return false;
		}
		// TODO: Apply the best one
		#if Q_D_RAND_REPAIR_LEG
			cout << "Best cost: " << dbBestCost << endl;
			cout << "Best vehicle: " << inBestVehicleIdx << endl;
			cout << "Best trip: " << inBestTripIdx << endl;
			cout << "Best pos: " << inBestPos << endl;
			cout << "Replacement: " << inReplamentSP << endl;
		#endif
		
		if (inTripType == TRIP_DELIVERY)
		{
			if (inBestPos == -1)
			{
				if (true == Insert_A_Leg(inBestVehicleIdx, inBestTripIdx, k, 0, &dbTotalCostTmp))
				{
					#if Q_D_RAND_REPAIR_LEG
					cout << "Apply to vehicle " << inBestVehicleIdx << " trip " << inBestTripIdx << " with cost " << dbTotalCostTmp << endl;
					#endif
				} else
				{					
					cout << "Apply to vehicle " << inBestVehicleIdx << " trip " << inBestTripIdx << " failed" << endl; getchar();
					return false;
				}
			} else if (inBestPos == 0)
			{
				if (true == Insert_A_Del_Leg_At_Begin(inBestVehicleIdx, inBestTripIdx, k, 0, &dbTotalCostTmp))
				{
					#if Q_D_RAND_REPAIR_LEG
					cout << "Apply to vehicle " << inBestVehicleIdx << " trip " << inBestTripIdx << " with cost " << dbTotalCostTmp << endl;
					#endif
				} else
				{
					cout << "Apply to vehicle " << inBestVehicleIdx << " trip " << inBestTripIdx << " failed" << endl; getchar();
					return false;
				}
			} else if (inBestPos == 1)
			{
				if (true == Insert_A_Del_Leg_At_End(inBestVehicleIdx, inBestTripIdx, k, 0, &dbTotalCostTmp))
				{
					#if Q_D_RAND_REPAIR_LEG
					cout << "Apply to vehicle " << inBestVehicleIdx << " trip " << inBestTripIdx << " with cost " << dbTotalCostTmp << endl;
					#endif
				} else
				{
					cout << "Apply to vehicle " << inBestVehicleIdx << " trip " << inBestTripIdx << " failed" << endl; getchar();
					return false;
				}
			}
		} else if (inTripType == TRIP_PICKUP)
		{
			if (inReplamentSP > 0)
				removedTrip[k].endNodeIdx = inReplamentSP;
			if (inBestPos == -1)
			{
				if (true == Insert_A_Leg(inBestVehicleIdx, inBestTripIdx, k, 0, &dbTotalCostTmp))
				{
					#if Q_D_RAND_REPAIR_LEG
					cout << "Apply to vehicle " << inBestVehicleIdx << " trip " << inBestTripIdx << " with cost " << dbTotalCostTmp << endl;
					#endif
				} else
				{
					cout << "Apply to vehicle " << inBestVehicleIdx << " trip " << inBestTripIdx << " failed" << endl; getchar();
					return false;
				}
			} else if (inBestPos == 0)
			{
				if (true == Insert_A_Pick_Leg_At_Begin(inBestVehicleIdx, inBestTripIdx, k, 0, &dbTotalCostTmp))
				{
					#if Q_D_RAND_REPAIR_LEG
					cout << "Apply to vehicle " << inBestVehicleIdx << " trip " << inBestTripIdx << " with cost " << dbTotalCostTmp << endl;
					#endif
				} else
				{
					cout << "Apply to vehicle " << inBestVehicleIdx << " trip " << inBestTripIdx << " failed" << endl; getchar();
					return false;
				}
			} else if (inBestPos == 1)
			{
				if (true == Insert_A_Pick_Leg_At_End(inBestVehicleIdx, inBestTripIdx, k, 0, &dbTotalCostTmp))
				{
					#if Q_D_RAND_REPAIR_LEG
					cout << "Apply to vehicle " << inBestVehicleIdx << " trip " << inBestTripIdx << " with cost " << dbTotalCostTmp << endl;
					#endif
				} else
				{
					cout << "Apply to vehicle " << inBestVehicleIdx << " trip " << inBestTripIdx << " failed" << endl; getchar();
					return false;
				}
			}
		} else if (inTripType == TRIP_C2C)
		{
			if (true == Insert_A_Leg(inBestVehicleIdx, inBestTripIdx, k, 0, &dbTotalCostTmp))
			{
				#if Q_D_RAND_REPAIR_LEG
				cout << "Apply to vehicle " << inBestVehicleIdx << " trip " << inBestTripIdx << " with cost " << dbTotalCostTmp << endl;
				#endif
			} else
			{
				cout << "Apply to vehicle " << inBestVehicleIdx << " trip " << inBestTripIdx << " failed" << endl; getchar();
				return false;
			}
		}
	}

	return true;
}
/*
 * A customer selected from the removed list and inserted into the selection.
 * implements the one producing the new solution with least fitness
 * The process is repeated until the removed list is empty
 */
bool Solution::Random_Greedy_Repair()
{
	int arr_Repair_List[1000];
	int inRepairLstSz;
	int arr_Permutation[1000];
	bool bRetVal;
	double dbEvaluatedCostTmp;

#if Q_DEBUG_RANDOM_REP
	cout << "\t\t\t RANDOM REPAIR" << endl;
#endif
	/*
	 * For removed pickup-customer, allow to re-insert to any existing pickup legs of the solution,
	 * for which the collected freight is brought to assignment supply point
	 */
	//Build the remvoved list.
	inRepairLstSz = 0;
	for (int i = nSP + 1; i <= nD + nP + nOrder + nOrder + nSP; i++) // all customer-demands
	{
		if ((i >= nOrder+nSP+1) && (i <= nOrder + nOrder + nSP)) continue; // skip c2c-delivery because we consider c2c-pickup already
		if (0 == routed[i]) // means this customer-demand is not be routed
		{
			inRepairLstSz++;
			arr_Repair_List[inRepairLstSz] = i;
		}
	}
#if Q_DEBUG_RANDOM_REP
	cout << "\t\t\t The removed list: ";
	for (int i = 1; i <= inRepairLstSz; i++)
	{
		cout << arr_Repair_List[i] <<  " ";
	}
	cout << endl;
#endif

	// Make permutation of the list
	RandPermutation(inRepairLstSz, arr_Repair_List, arr_Permutation);
#if Q_DEBUG_RANDOM_REP
	cout << "\t\t\t A PERMUTATION of removed list: ";
	for (int i = 1; i <= inRepairLstSz; i++)
	{
		arr_Permutation[i] = arr_Repair_List[i];
		cout << arr_Permutation[i] <<  " ";
	}
	cout << endl;
#endif

	// Scan and route all customer-demands in the list
	for (int i = 1; i <= inRepairLstSz; i++)
	{
		//Get node type: pickup or delivery or c2c
		int inNodeType = Get_Node_Type(arr_Permutation[i]);
		switch (inNodeType)
		{
			case NODE_PICKUP:
#if Q_DEBUG_RANDOM_REP
				cout << "\t\t\t Repair PICKUP "<< arr_Permutation[i] << "... "; 
#endif
				bRetVal = false;
				for (int inVehIdx = 1; inVehIdx <= numVeh; inVehIdx++)
				{
					for (int inTripIdx=1; inTripIdx<=seg[inVehIdx].numTrips; inTripIdx++)
					{
						//This assigned SP can serve this pikcup node also
						if ((TRIP_PICKUP == seg[inVehIdx].Trip[inTripIdx].Type)  && (true == Belong_To_SP(arr_Permutation[i], seg[inVehIdx].Trip[inTripIdx].endNodeIdx)))
						{
							bRetVal = Insert_A_Pickup(arr_Permutation[i], inVehIdx, inTripIdx, true, &dbEvaluatedCostTmp);
							if (bRetVal)
							{
								if (false == Valid_A_Trip(inVehIdx, inTripIdx))
								{
#if Q_DEBUG_RANDOM_REP
									cout << " failed" << endl; 
#endif
									bRetVal = false;
									continue;
								} else
								{
#if Q_DEBUG_RANDOM_REP
									cout << " to vehicle " << inVehIdx << " trip " << inTripIdx << endl;
#endif
								}
								break;
							}
						}
					}
					if (bRetVal) break;
				}
				if (!bRetVal)
				{
#if Q_DEBUG_RANDOM_REP
					// Cannot inserting --> Create-single-pickup
					cout << endl << "\t\t\t\t Critical ERR --> Create SINGLE/ROLLBACK" << endl;
#endif
					if (i == 1)
					{
#if Q_CRIT_SKIP
						cout << "\t\t\t\t First Insert must be ok! *ln" << __LINE__ << endl; getchar();
#endif
					}
					return false;

				}

				break;
			case NODE_DELIVERY:
#if Q_DEBUG_RANDOM_REP
				cout << "\t\t\t Repair DELIVERY "<< arr_Permutation[i] << "... "; 
				//showSolution();
#endif
				bRetVal = false;
				for (int inVehIdx = 1; inVehIdx <= numVeh; inVehIdx++)
				{
					for (int inTripIdx=1; inTripIdx<=seg[inVehIdx].numTrips; inTripIdx++)
					{
						if ((TRIP_DELIVERY == seg[inVehIdx].Trip[inTripIdx].Type) && (true == Belong_To_SP(arr_Permutation[i], seg[inVehIdx].Trip[inTripIdx].startNodeIdx)))
						{
							bRetVal = Insert_A_Delivery(arr_Permutation[i], inVehIdx, inTripIdx, true, &dbEvaluatedCostTmp);
							if (bRetVal)
							{
								if (false == Valid_A_Trip(inVehIdx, inTripIdx))
								{
#if Q_DEBUG_RANDOM_REP
									cout << " failed" << endl;
#endif
									bRetVal = false;
									continue;
								} else
								{
#if Q_DEBUG_RANDOM_REP
									cout << " to vehicle " << inVehIdx << " trip " << inTripIdx << endl;
#endif
									//showSolution();
								}

								break;
							}
						}
					}
					if (bRetVal) break;
				}
				if (!bRetVal)
				{
#if Q_DEBUG_RANDOM_REP
					// Cannot inserting -->  Create-single-delivery
					cout << "\t\t\t\t Critical ERR --> Create SINGLE/ROLLBACK" << endl;
#endif
					if (i == 1)
					{
#if Q_CRIT_SKIP
						cout << "\t\t\t\t First Insert must be ok! *ln" << __LINE__ << endl; getchar();
#endif
					}
					return false;

				}
				break;
			case NODE_C2C_PICKUP:
#if Q_DEBUG_RANDOM_REP
				cout << "\t\t\t Repair C2C "<< arr_Permutation[i] << "... "; 
#endif
				bRetVal = false;
				for (int inVehIdx = 1; inVehIdx <= numVeh; inVehIdx++)
				{
					for (int inTripIdx=1; inTripIdx<=seg[inVehIdx].numTrips; inTripIdx++)
					{
						if (TRIP_C2C == seg[inVehIdx].Trip[inTripIdx].Type) // For Debuging only, sperate trip
						{
							bRetVal = Insert_A_C2C(arr_Permutation[i], inVehIdx, inTripIdx, true, &dbEvaluatedCostTmp);
							if (bRetVal)
							{
								if (false == Valid_A_Trip(inVehIdx, inTripIdx))
								{
#if Q_DEBUG_RANDOM_REP
									cout << " failed" << endl;
#endif
									bRetVal = false;
									continue;
								} else
								{
#if Q_DEBUG_RANDOM_REP
									// Insert OK
									cout << " to vehicle " << inVehIdx << " trip " << inTripIdx << endl;
#endif
								}

								break;
							}
						}
					}
					if (bRetVal) break;
				}
				if (!bRetVal)
				{
#if Q_DEBUG_RANDOM_REP
					// Cannot insert --> Create-single-C2C
					cout << "\t\t\t\t Critical ERR --> Create SINGLE/ROLLBACK" << endl; 
#endif
					if (i == 1)
					{
#if Q_CRIT_SKIP
						cout << "\t\t\t\t First Insert must be ok! *ln" << __LINE__ << endl; getchar();
#endif
					}
					
					return false;
				}

				break;
			case NODE_C2C_DELIVERY:
				break; // skip
			default:
				cout << "Not supported" << endl; getchar();
				return false;
				break;
		}
	}

	return true;
}
// END OF IMPLEMENTATION REPAIRER //


bool Solution::Remove_A_Leg(int inVehIdx, int inTripIdx)
{

#if Q_D_REMOVE_A_LEG
	Show_A_Vehicle(inVehIdx);
#endif
	memcpy(&seg[MAX_VEH+1], &seg[inVehIdx], sizeof(VRPSegment));

	// Consider first, last leg
	if (seg[inVehIdx].numTrips == 1) // has one trip
	{
		//TODO: Later
		cout << "Vehicle " << inVehIdx << " has one trip!" << endl;
		return false;
	} else 
	{
		if (1 == inTripIdx) // the first trip
		{		
#if Q_D_REMOVE_A_LEG
			cout << "Revove the first trip" << endl;
#endif
			if (TRIP_DELIVERY != seg[inVehIdx].Trip[inTripIdx+1].Type)
			{
				seg[inVehIdx].Trip[inTripIdx+1].startNodeIdx = 0; // start from depot
			} else
			{
				// Delivery trip is no need to update
			}

						// Shift legs to left
			for (int i = inTripIdx; i < seg[inVehIdx].numTrips; i++)
			{
				memcpy(&seg[inVehIdx].Trip[i], &seg[inVehIdx].Trip[i+1], sizeof(VRPTrip));
			}
			// Update numTrips
			seg[inVehIdx].numTrips--;

			// Reset time for vehicle 
			if (false == Set_Time_For_A_Vehicle(inVehIdx, 1, 0, true))
			{
#if Q_D_REMOVE_A_LEG
				cout << "After deleteing leg " << inTripIdx << endl;
				Show_A_Vehicle(inVehIdx);
				cout << "Reset time failed" << endl;
#endif

				// Roll-back
				memcpy(&seg[inVehIdx], &seg[MAX_VEH+1], sizeof(VRPSegment));
				return false;
			} else
			{
#if Q_D_REMOVE_A_LEG
				Show_A_Vehicle(inVehIdx);
#endif
				return true;
			}

		} else if (seg[inVehIdx].numTrips ==  inTripIdx) // the last trip
		{
#if Q_D_REMOVE_A_LEG
			cout << "Revove the last trip" << endl;
#endif
			if (TRIP_PICKUP != seg[inVehIdx].Trip[inTripIdx-1].Type)
			{
				seg[inVehIdx].Trip[inTripIdx-1].endNodeIdx = 0; // start from depot
			} else
			{
				// Delivery trip is no need to update
			}

			// Update numTrips
			seg[inVehIdx].numTrips--;

			// Reset time for vehicle 
			if (false == Set_Time_For_A_Vehicle(inVehIdx, 1, 0, true))
			{
#if Q_D_REMOVE_A_LEG
				cout << "After deleteing leg " << inTripIdx << endl;
				Show_A_Vehicle(inVehIdx);
				cout << "Reset time failed" << endl;
#endif

				// Roll-back
				memcpy(&seg[inVehIdx], &seg[MAX_VEH+1], sizeof(VRPSegment));
				return false;
			} else
			{
#if Q_D_REMOVE_A_LEG
				Show_A_Vehicle(inVehIdx);
#endif
				return true;
			}
		} else 
		{ // joint (inTripIdx-1) & (inTripIdx+1), update numTrips
			//int inPreEndNodeIdx = seg[inVehIdx].Trip[inTripIdx-1].endNodeIdx;
			int inPreLastCus = seg[inVehIdx].Trip[inTripIdx-1].lastCus;

			if ((TRIP_DELIVERY == seg[inVehIdx].Trip[inTripIdx-1].Type) || (TRIP_C2C == seg[inVehIdx].Trip[inTripIdx-1].Type))
			{ // joint node is EndNodeIdx
				if (TRIP_DELIVERY == seg[inVehIdx].Trip[inTripIdx+1].Type)
				{
					seg[inVehIdx].Trip[inTripIdx-1].endNodeIdx = seg[inVehIdx].Trip[inTripIdx+1].startNodeIdx;
				} else
				{
					seg[inVehIdx].Trip[inTripIdx-1].endNodeIdx = seg[inVehIdx].Trip[inTripIdx+1].firstCus;
				}
			}

			if ((TRIP_PICKUP == seg[inVehIdx].Trip[inTripIdx+1].Type) || (TRIP_C2C == seg[inVehIdx].Trip[inTripIdx+1].Type))
			{ // joint node is StartNodeIdx
				if (TRIP_PICKUP == seg[inVehIdx].Trip[inTripIdx-1].Type)
				{
					seg[inVehIdx].Trip[inTripIdx+1].startNodeIdx = seg[inVehIdx].Trip[inTripIdx-1].endNodeIdx;
				} else
				{
					seg[inVehIdx].Trip[inTripIdx+1].startNodeIdx = inPreLastCus;
				}
			}

			//if (TRIP_DELIVERY == seg[inVehIdx].Trip[inTripIdx].Type)
			//{ // joint node is EndNodeIdx
			//	

			//} else if (TRIP_PICKUP == seg[inVehIdx].Trip[inTripIdx].Type)
			//{ // joint node is StarNodeIdx

			//} else if (TRIP_C2C == seg[inVehIdx].Trip[inTripIdx].Type)
			//{ // joint node are both of startNodeIdx and EndNodeIdx

			//} else
			//{
			//	cout << __LINE__ << endl; getchar();
			//}

			//if (seg[inVehIdx].Trip[inTripIdx-1].endNodeIdx == seg[inVehIdx].Trip[inTripIdx].firstCus)
			//{
			//	seg[inVehIdx].Trip[inTripIdx-1].endNodeIdx = seg[inVehIdx].Trip[inTripIdx+1].firstCus;
			//}

			//if (seg[inVehIdx].Trip[inTripIdx].lastCus == seg[inVehIdx].Trip[inTripIdx+1].startNodeIdx)
			//{
			//	seg[inVehIdx].Trip[inTripIdx+1].startNodeIdx = seg[inVehIdx].Trip[inTripIdx-1].lastCus;
			//}

			// Shift legs to left
			for (int i = inTripIdx; i < seg[inVehIdx].numTrips; i++)
			{
				memcpy(&seg[inVehIdx].Trip[i], &seg[inVehIdx].Trip[i+1], sizeof(VRPTrip));
			}
			// Update numTrips
			seg[inVehIdx].numTrips--;

			// Reset time for vehicle 
			if (false == Set_Time_For_A_Vehicle(inVehIdx, 1, 0, true))
			{
#if Q_D_REMOVE_A_LEG
				cout << "After deleteing leg " << inTripIdx << endl;
				Show_A_Vehicle(inVehIdx);
				cout << "Reset time failed" << endl;
#endif

				// Roll-back
				memcpy(&seg[inVehIdx], &seg[MAX_VEH+1], sizeof(VRPSegment));
				return false;
			} else
			{
#if Q_D_REMOVE_A_LEG
				Show_A_Vehicle(inVehIdx);
#endif
				return true;
			}



			//TODO: Mark up deleted trip of free all demnads in this one?
		}
	}


}


//Remove a trip
void Solution::Remove_A_Trip(int inVehIdx, int inTripIdx, int flag)
{
	int inNodeType;

	return; //TODO: Support later

	// Update supply point status
	int inTripType = seg[inVehIdx].Trip[inTripIdx].Type;
	switch (inTripType)
	{
		case TRIP_PICKUP:
			numCusPRouted[seg[inVehIdx].Trip[inTripIdx].endNodeIdx] -= seg[inVehIdx].Trip[inTripIdx].numCus;
			break;
		case TRIP_DELIVERY:
			numCusDRouted[seg[inVehIdx].Trip[inTripIdx].startNodeIdx] -= seg[inVehIdx].Trip[inTripIdx].numCus;
			break;
		default:
			break;
	}
	//Consider firstNode
	inNodeType = Get_Node_Type(seg[inVehIdx].Trip[inTripIdx].startNodeIdx);
	switch (inNodeType)
	{
	case NODE_C2C_PICKUP:
	case NODE_C2C_DELIVERY:
	case NODE_PICKUP:
	case NODE_DELIVERY:
		routed[seg[inVehIdx].Trip[inTripIdx].startNodeIdx] = 0;
		break;
	default:
		break;
	}  
	//Consider endNodeIdx
	inNodeType = Get_Node_Type(seg[inVehIdx].Trip[inTripIdx].endNodeIdx);
	switch (inNodeType)
	{
	case NODE_C2C_PICKUP:
	case NODE_C2C_DELIVERY:
	case NODE_PICKUP:
	case NODE_DELIVERY:
		routed[seg[inVehIdx].Trip[inTripIdx].endNodeIdx] = 0;
		break;
	default:
		break;
	}  
	// Unrouting all customer-demands
	int curC = seg[inVehIdx].Trip[inTripIdx].firstCus;
	routed[curC] = 0;
	while (curC > 0)
	{
		curC = nextArr[curC];
		if (curC >0)
			routed[curC] = 0;
	}

	// Remove trip
	if (flag > 0){
		for (int i = inTripIdx; i <= seg[inVehIdx].numTrips-1; i++)
		{
			memcpy(&seg[inVehIdx].Trip[i], &seg[inVehIdx].Trip[i+1], sizeof(VRPTrip));
		}
		seg[inVehIdx].numTrips--;
	}
}
// Remove a vehicle and it trips
void Solution::Remove_A_Vehicle(int inVehIdx)
{
	int inNodeType;
	int inTripType;

	return; //TODO: Support later

	// Free all demands in trips
	for (int i = 1; i <= seg[inVehIdx].numTrips; i++)
	{
		Remove_A_Trip(inVehIdx, i, 0);
	}

	//Move trip from inVehNum
	for (int i = inVehIdx; i <= numVeh-1; i++)
	{
		memcpy(&seg[i], &seg[i+1], sizeof(VRPSegment));
	}
}

/* Find and remove a pickup
 * 3 scenarios:
 *  - Remove a vehicle if have one trip and one node
 *  - Remove a trip if this trip has one node
 *  - Remove a pickup node only
 */
int Solution::Remove_A_Pickup(int inPickupIdx)
{
	double leaveDepot;
	bool bRetVal;
	int inVehIdx;
	int inTripIdx;
	bool got = false;
	int arrTripTmp[2000];
	int	inTripSzTmp;
	double arrBeginIime[2000];
	double dbEndS;
	int inWSId, inVehCap;
	double dbStartTimeTmp;


#if Q_DEBUG_PICKUP_DES
	cout << "Remove-A-Pickup: try to remove " << inPickupIdx << endl;
#endif

	//Spot the pickup
	if (routed[inPickupIdx] == 0)
	{
#if Q_DEBUG_PICKUP_DES
		cout << "\t This pickup " << inPickupIdx << " does not route yet"  << endl;
#endif
		return REMOVE_ALREADY; // not routed
	}

	for (inVehIdx=1; inVehIdx<=numVeh; inVehIdx++)
	{
		for (inTripIdx=1; inTripIdx<=seg[inVehIdx].numTrips; inTripIdx++)
		{
			if (seg[inVehIdx].Trip[inTripIdx].Type != TRIP_PICKUP) continue;

			int curC = seg[inVehIdx].Trip[inTripIdx].firstCus;
			while (curC > 0)
			{
				if (curC == inPickupIdx)
				{
					got = true;
					//if ((inTripIdx < seg[inVehIdx].numTrips) && (inPickupIdx == seg[inVehIdx].Trip[inTripIdx].lastCus) && (seg[inVehIdx].Trip[inTripIdx].lastCus == seg[inVehIdx].Trip[inTripIdx+1].startNodeIdx))
					//{
					//	return REMOVE_SPE_CUST; // in case of PICKUP inPickupIdx is both of lastCust and startNodeIdx of 2 consecutive trips.
					//}
					//if ((inTripIdx > 1) && (inPickupIdx == seg[inVehIdx].Trip[inTripIdx-1].lastCus) && (seg[inVehIdx].Trip[inTripIdx-1].lastCus == seg[inVehIdx].Trip[inTripIdx].startNodeIdx))
					//{
					//	return REMOVE_SPE_CUST; // in case of DELIVERY inDeliveryIdx is both of firstCus and startNodeIdx of 2 consecutive trips.
					//}
#if !Q_JOINT_POINT_ALLOWANCE
					//if ((inPickupIdx == seg[inVehIdx].Trip[inTripIdx].lastCus))  || (inPickupIdx == seg[inVehIdx].Trip[inTripIdx].firstCus))
					//	return REMOVE_SPE_CUST;
#endif
					break;
				}
				curC = nextArr[curC];
			}
			if (got) break;
		}
		if (got) break;
	}
	if (!got)
	{
#if Q_DEBUG_PICKUP_DES
		cout << "\t Can not find pickup " << inPickupIdx << " to remove" << endl;
#endif
		return -1;
	}
	
	//Join_Trips(inVehIdx);

	// Now, we found inDeliveryIdx in trip inTripIdx of vehicle inVehIdx

	// Screnario 1: This vehicle has ONE trip and ONE customer --> Remove-a-Vehicle
	if ((1 == seg[inVehIdx].numTrips) && ((1 == seg[inVehIdx].Trip[inTripIdx].numCus))) // this vehicle has ONE trip --> Remove vehicle
	{
#if Q_DEBUG_PICKUP_DES
		cout << "\t This vehicle has ONE trip and ONE customer-demand --> Remove-A-Vehicle" << endl;
#endif
		Remove_A_Vehicle(inVehIdx);
		return REMOVE_VEHICLE;
	}

	// Scenario 2: This vehicle has more than one trip and this trip has ONE customer demand
	if (((1 < seg[inVehIdx].numTrips)) && (1 == seg[inVehIdx].Trip[inTripIdx].numCus))
	{		
#if Q_DEBUG_PICKUP_DES
		cout << "\t This vehicle has mutiple trips and this trip has ONE customer-demand --> Remove-A-Trip" << endl;
#endif
		Remove_A_Trip(inVehIdx, 1, 1);		
		return REMOVE_TRIP;
	}	

	// Scenario 3: This vehicle has more than one trip and this trip has more than one customer demands
#if 1 //Q_JOINT_POINT_ALLOWANCE
	if (inPickupIdx == seg[inVehIdx].Trip[inTripIdx].firstCus)
	{
		if (inTripIdx > 1) //not first trip
		{ 
			if (seg[inVehIdx].Trip[inTripIdx-1].endNodeIdx == seg[inVehIdx].Trip[inTripIdx].firstCus)
			{
				seg[inVehIdx].Trip[inTripIdx-1].endNodeIdx = nextArr[seg[inVehIdx].Trip[inTripIdx].firstCus];
			}
		}
	} else if (inPickupIdx == seg[inVehIdx].Trip[inTripIdx].lastCus)
	{
		//if (inTripIdx < seg[inVehIdx].numTrips) // not last trip
		//{
		//	if (seg[inVehIdx].Trip[inTripIdx+1].startNodeIdx == seg[inVehIdx].Trip[inTripIdx].lastCus)
		//	{
		//		seg[inVehIdx].Trip[inTripIdx+1].startNodeIdx = nextArr[seg[inVehIdx].Trip[inTripIdx].firstCus];
		//	}
		//}
	}
#endif
#if Q_DEBUG_PICKUP_DES
	cout << "\t Before applying destroy..." << endl;
	Show_A_Trip(inVehIdx, inTripIdx);
#endif
	int curC = seg[inVehIdx].Trip[inTripIdx].firstCus;
	if (curC == inPickupIdx) 
	{
		seg[inVehIdx].Trip[inTripIdx].firstCus = nextArr[curC];
	} else
	{
		while (curC > 0)
		{
			if (nextArr[curC] == inPickupIdx)
			{
				nextArr[curC] = nextArr[inPickupIdx];
				nextArr[inPickupIdx] = -1;
#if 1 //Q_JOINT_POINT_ALLOWANCE
				if (inPickupIdx == seg[inVehIdx].Trip[inTripIdx].lastCus)
				{
					if (inTripIdx < seg[inVehIdx].numTrips) // not last trip
					{
						if (seg[inVehIdx].Trip[inTripIdx+1].startNodeIdx == seg[inVehIdx].Trip[inTripIdx].lastCus)
						{
							seg[inVehIdx].Trip[inTripIdx+1].startNodeIdx = curC;
						}
					}
					seg[inVehIdx].Trip[inTripIdx].lastCus = curC;
				}
#endif
			}
			curC = nextArr[curC];
		}
	}
	seg[inVehIdx].Trip[inTripIdx].numCus--;
	routed[inPickupIdx] = 0;
	
#if Q_DEBUG_PICKUP_DES
	cout << "\t Got new trip: " << endl;
	Show_A_Trip(inVehIdx, inTripIdx);
#endif

	// Rebuild current trip and re-set time
	curC = seg[inVehIdx].Trip[inTripIdx].firstCus;
	inTripSzTmp = 0;
	while (curC > 0)
	{
		inTripSzTmp++;
		arrTripTmp[inTripSzTmp] = curC;
		curC = nextArr[curC];
	}

	bRetVal = SetBeginTimeForPath_Q(seg[inVehIdx].Trip[inTripIdx].leaveSP, seg[inVehIdx].Trip[inTripIdx].startNodeIdx,
					arrTripTmp,
					inTripSzTmp,
					arrBeginIime,
					seg[inVehIdx].Trip[inTripIdx].endNodeIdx,
					&dbEndS,
					&inWSId,
					&inVehCap);

	if (false == bRetVal)
	{
#if Q_CRIT_SKIP
		cout << "Reset time for Pickup trip after destroy... failed *ln" << __LINE__ << endl; getchar();
		//Show_A_Trip(inVehIdx, inTripIdx);
#endif
		return -1;
	}

	seg[inVehIdx].Trip[inTripIdx].waitingS = inWSId;

	// Check time-forward slack	
	if (inTripIdx < seg[inVehIdx].numTrips)
	{
		if (TRIP_PICKUP == seg[inVehIdx].Trip[inTripIdx].Type)
		{
			dbEndS += problem->nodeSP[seg[inVehIdx].Trip[inTripIdx].endNodeIdx].unload;
		}

		seg[inVehIdx].Trip[inTripIdx].endS = dbEndS;

		if (seg[inVehIdx].Trip[inTripIdx+1].startNodeIdx == seg[inVehIdx].Trip[inTripIdx].lastCus)
		{

			dbStartTimeTmp = arrBeginIime[inTripSzTmp];
		} else
		{
			dbStartTimeTmp = dbEndS;
		}

		//if (false == Set_Time_For_A_Vehicle(inVehIdx, inTripIdx+1, dbStartTimeTmp, true))
		if (false == Set_Time_For_A_Vehicle(inVehIdx, 1, dbStartTimeTmp, true))
		{
#if Q_DEBUG_PICKUP_DES
			cout << "Set_Time_For_A_Vehicle_Vio::failed" << endl;
#endif
		} else
		{
#if Q_DEBUG_PICKUP_DES
			cout << "\t From trip " << inTripIdx << " to " << seg[inVehIdx].numTrips << " new dbVioVal=" << (dbVioVal+dbNewVioVal) << endl;
#endif
			//// TODO: Calc fitness of solution anh saved the least fitness
			//if (dbLeastFitnest > (dbVioVal+dbNewVioVal-dbVioVal+dbNewVioVal))
			//{
			//	dbLeastFitnest = dbVioVal+dbNewVioVal-dbVioVal+dbNewVioVal;
			//	inBestPos = i;
			//}
		}				

		//showSolution();
	} 



	if (false == Valid_A_Trip(inVehIdx, inTripIdx))
	{
#if Q_DEBUG_PICKUP_DES
	cout << "\t Remove_A_Pickup failed: " << inPickupIdx << endl;
#endif
		return -1;
	}


	return REMOVE_CUSTOMER; // If we allow to wait at customer-pickup so removing a pick-up valid though
}

/* Find and remove a delivery
 * 3 scenarios:
 *  - Remove a vehicle if have one trip and one node
 *  - Remove a trip if this trip has one node
 *  - Remove a delivery node only
 */
int Solution::Remove_A_Delivery(int inDeliveryIdx)
{
	double leaveDepot;
	bool bRetVal;
	int inVehIdx;
	int inTripIdx;
	bool got = false;
	int arrTripTmp[2000];
	int	inTripSzTmp;
	double arrBeginIime[2000];
	double dbEndS;
	int inWSId, inVehCap;
	double dbStartTimeTmp;


#if Q_DEBUG_DELIVERY_RM
	cout << "Remove-A-Delivery: try to remove " << inDeliveryIdx << endl;
#endif

	//Spot the deliveryIdx
	if (routed[inDeliveryIdx] == 0)
	{
#if Q_DEBUG_DELIVERY_RM
		cout << "\t This delivery " << inDeliveryIdx << " does not route yet"  << endl;
#endif
		return REMOVE_ALREADY; // this deliveryIdx does not route -> no need to process
	}

	for (inVehIdx=1; inVehIdx<=numVeh; inVehIdx++) // scan all vehicles
	{
		for (inTripIdx=1; inTripIdx<=seg[inVehIdx].numTrips; inTripIdx++) // scan all trips
		{
			if (seg[inVehIdx].Trip[inTripIdx].Type != TRIP_DELIVERY) continue;

			int curC = seg[inVehIdx].Trip[inTripIdx].firstCus;
			while (curC > 0)
			{
				if (curC == inDeliveryIdx)
				{
					//if ((inTripIdx < seg[inVehIdx].numTrips) && (inDeliveryIdx == seg[inVehIdx].Trip[inTripIdx].lastCus) && (seg[inVehIdx].Trip[inTripIdx].lastCus == seg[inVehIdx].Trip[inTripIdx+1].startNodeIdx))
					//{
					//	return REMOVE_CUSTOMER; // in case of DELIVERY inDeliveryIdx is both of lastCust and startNodeIdx of 2 consecutive trips.
					//}
					//if ((inTripIdx > 1) && (inDeliveryIdx == seg[inVehIdx].Trip[inTripIdx-1].lastCus) && (seg[inVehIdx].Trip[inTripIdx-1].lastCus == seg[inVehIdx].Trip[inTripIdx].startNodeIdx))
					//{
					//	return REMOVE_CUSTOMER; // in case of DELIVERY inDeliveryIdx is both of firstCus and startNodeIdx of 2 consecutive trips.
					//}
#if !Q_JOINT_POINT_ALLOWANCE
					/*if ((inDeliveryIdx == seg[inVehIdx].Trip[inTripIdx].lastCus) || (inDeliveryIdx == seg[inVehIdx].Trip[inTripIdx].firstCus))
						return REMOVE_SPE_CUST;*/
#endif
					got = true;
					break;
				}
				curC = nextArr[curC];
			}
			if (got) break;
		}
		if (got) break;
	}
	if (!got)
	{
#if Q_DEBUG_DELIVERY_RM
		cout << "\t Can not find delivery " << inDeliveryIdx << " to remove" << endl;
#endif
		return -1;
	}

	// Now, we found inDeliveryIdx in trip inTripIdx of vehicle inVehIdx

	// Screnario 1: This vehicle has ONE trip and ONE customer --> Remove-a-Vehicle
	if ((1 == seg[inVehIdx].numTrips) && ((1 == seg[inVehIdx].Trip[inTripIdx].numCus)))
	{
#if Q_DEBUG_DELIVERY_RM
		cout << "\t This vehicle has ONE trip and ONE customer-demand --> Remove-A-Vehicle" << endl;
#endif
		Remove_A_Vehicle(inVehIdx);
		return REMOVE_VEHICLE;
	}

	// Scenario 2: This vehicle has more than one trip and this trip has ONE customer demand
	if (((1 < seg[inVehIdx].numTrips)) && (1 == seg[inVehIdx].Trip[inTripIdx].numCus))
	{		
#if Q_DEBUG_DELIVERY_RM
		cout << "\t This vehicle has mutiple trips and this trip has ONE customer-demand --> Remove-A-Trip" << endl;
#endif
		Remove_A_Trip(inVehIdx, 1, 1);		
		return REMOVE_TRIP;
	}

#if 1 //Q_JOINT_POINT_ALLOWANCE
	if (inDeliveryIdx == seg[inVehIdx].Trip[inTripIdx].firstCus)
	{
		if (inTripIdx > 1) //not first trip
		{ 
			if (seg[inVehIdx].Trip[inTripIdx-1].endNodeIdx == seg[inVehIdx].Trip[inTripIdx].firstCus)
			{
				seg[inVehIdx].Trip[inTripIdx-1].endNodeIdx = nextArr[seg[inVehIdx].Trip[inTripIdx].firstCus];
			}
		}
	} else if (inDeliveryIdx == seg[inVehIdx].Trip[inTripIdx].lastCus)
	{
		//if (inTripIdx < seg[inVehIdx].numTrips) // not last trip
		//{
		//	if (seg[inVehIdx].Trip[inTripIdx+1].startNodeIdx == seg[inVehIdx].Trip[inTripIdx].lastCus)
		//	{
		//		seg[inVehIdx].Trip[inTripIdx+1].startNodeIdx = nextArr[seg[inVehIdx].Trip[inTripIdx].firstCus];
		//	}
		//}
	}
#endif

	// Scenario 3: This vehicle has more than one trip and this trip has more than one customer demands
#if Q_DEBUG_DELIVERY_RM
	cout << "\t Before applying destroy..." << endl;  getchar();
	Show_A_Trip(inVehIdx, inTripIdx);
#endif
	int curC = seg[inVehIdx].Trip[inTripIdx].firstCus;
	if (curC == inDeliveryIdx) 
	{
		seg[inVehIdx].Trip[inTripIdx].firstCus = nextArr[curC];
	} else
	{
		while (curC > 0)
		{
			if (nextArr[curC] == inDeliveryIdx)
			{
				nextArr[curC] = nextArr[inDeliveryIdx];
				nextArr[inDeliveryIdx] = -1;
#if 1 //Q_JOINT_POINT_ALLOWANCE
				if (inDeliveryIdx == seg[inVehIdx].Trip[inTripIdx].lastCus)
				{
					if (inTripIdx < seg[inVehIdx].numTrips) // not last trip
					{
						if (seg[inVehIdx].Trip[inTripIdx+1].startNodeIdx == seg[inVehIdx].Trip[inTripIdx].lastCus)
						{
							seg[inVehIdx].Trip[inTripIdx+1].startNodeIdx = curC;
						}
					}
					seg[inVehIdx].Trip[inTripIdx].lastCus = curC;
				}
#endif

			}
			curC = nextArr[curC];
		}
	}
	seg[inVehIdx].Trip[inTripIdx].numCus--;
	routed[inDeliveryIdx] = 0;
	//TODO: Update assigned SP
#if Q_DEBUG_DELIVERY_RM
	cout << "\t Got new trip: " << endl; getchar();
	Show_A_Trip(inVehIdx, inTripIdx);
#endif

	// Rebuild current trip and re-set time
	curC = seg[inVehIdx].Trip[inTripIdx].firstCus;
	inTripSzTmp = 0;
	while (curC > 0)
	{
		inTripSzTmp++;
		arrTripTmp[inTripSzTmp] = curC;
		curC = nextArr[curC];
	}

	bRetVal = SetBeginTimeForPath_Q(seg[inVehIdx].Trip[inTripIdx].leaveSP+problem->nodeSP[seg[inVehIdx].Trip[inTripIdx].startNodeIdx].load, seg[inVehIdx].Trip[inTripIdx].startNodeIdx,
					arrTripTmp,
					inTripSzTmp,
					arrBeginIime,
					seg[inVehIdx].Trip[inTripIdx].endNodeIdx,
					&dbEndS,
					&inWSId,
					&inVehCap);

	if (false == bRetVal)
	{
#if Q_CRIT_SKIP
		cout << "Reset time for Pickup trip after destroy... failed *ln" << __LINE__ << endl; getchar();
		Show_A_Trip(inVehIdx, inTripIdx);
#endif
		return -1;
	}

	seg[inVehIdx].Trip[inTripIdx].waitingS = inWSId;
	// Check time-forward slack	
	if (inTripIdx < seg[inVehIdx].numTrips)
	{
		if (TRIP_PICKUP == seg[inVehIdx].Trip[inTripIdx].Type)
		{
			dbEndS += problem->nodeSP[seg[inVehIdx].Trip[inTripIdx].endNodeIdx].unload;
		}
		
		seg[inVehIdx].Trip[inTripIdx].endS = dbEndS;

		if (seg[inVehIdx].Trip[inTripIdx+1].startNodeIdx == seg[inVehIdx].Trip[inTripIdx].lastCus)
		{

			dbStartTimeTmp = arrBeginIime[inTripSzTmp];
		} else
		{
			dbStartTimeTmp = dbEndS;
		}

		//if (false == Set_Time_For_A_Vehicle(inVehIdx, inTripIdx+1, dbStartTimeTmp, true))
		if (false == Set_Time_For_A_Vehicle(inVehIdx, 1, dbStartTimeTmp, true))
		{
#if Q_DEBUG_DELIVERY_RM
			cout << "Set_Time_For_A_Vehicle_Vio::failed" << endl;
#endif
		} else
		{
#if Q_DEBUG_DELIVERY_RM
			cout << "\t From trip " << inTripIdx << " to " << seg[inVehIdx].numTrips << " new dbVioVal=" << (dbVioVal+dbNewVioVal) << endl;
#endif
			//// TODO: Calc fitness of solution anh saved the least fitness
			//if (dbLeastFitnest > (dbVioVal+dbNewVioVal-dbVioVal+dbNewVioVal))
			//{
			//	dbLeastFitnest = dbVioVal+dbNewVioVal-dbVioVal+dbNewVioVal;
			//	inBestPos = i;
			//}
		}				

		//showSolution();
	} 

	if (false == Valid_A_Trip(inVehIdx, inTripIdx))
	{
#if Q_DEBUG_DELIVERY_RM
	cout << "\t Remove_A_Delivery failed: " << inDeliveryIdx << endl;
#endif
		return -1;
	}
	return REMOVE_CUSTOMER; // If we allow to wait at customer-pickup so removing a pick-up valid though
}

/* Find and remove a c2c
 * 3 scenarios:
 *  - Remove a vehicle if have one trip and one c2c-node
 *  - Remove a trip if this trip has one c2c-node
 *  - Remove a c2c-node only
 */
int Solution::Remove_A_C2C_Pair(int inC2CPickupIdx)
{
	double leaveDepot;
	bool bRetVal;
	int inVehIdx;
	int inTripIdx;
	bool got = false;
	int inC2CDeliveryIdx;
	double dbStartTimeTmp, dbEndS;
	double arrBeginIime[2000];
	int  inWSId, inVehCap;


#if Q_DEBUG_C2C_DES
	cout << "Remove_A_C2C_Pair: try to remove " << inC2CPickupIdx << endl;
#endif

	//Spot the deliveryIdx
	if (routed[inC2CPickupIdx] == 0)
	{
#if Q_DEBUG_C2C_DES
		cout << "\t This c2c " << inC2CPickupIdx << " does not route yet"  << endl;
#endif
		return REMOVE_ALREADY; // this deliveryIdx does not route -> no need to process
	}

	inC2CDeliveryIdx = inC2CPickupIdx + nOrder;

	for (inVehIdx=1; inVehIdx<=numVeh; inVehIdx++) // scan all vehicles
	{
		for (inTripIdx=1; inTripIdx<=seg[inVehIdx].numTrips; inTripIdx++) // scan all trips
		{
			if (seg[inVehIdx].Trip[inTripIdx].Type != TRIP_C2C) continue;

			int curC = seg[inVehIdx].Trip[inTripIdx].firstCus;
			while (curC > 0)
			{
				if (curC == inC2CPickupIdx)
				{
					//if ((inTripIdx < seg[inVehIdx].numTrips) && (inC2CPickupIdx+nOrder == seg[inVehIdx].Trip[inTripIdx].lastCus) && (seg[inVehIdx].Trip[inTripIdx].lastCus == seg[inVehIdx].Trip[inTripIdx+1].startNodeIdx))
					//{
					//	return REMOVE_CUSTOMER; // in case of C2C inDeliveryIdx is both of lastCust and startNodeIdx of 2 consecutive trips.
					//}
					//if ((inTripIdx > 1) && (inC2CPickupIdx == seg[inVehIdx].Trip[inTripIdx-1].lastCus) && (seg[inVehIdx].Trip[inTripIdx-1].lastCus == seg[inVehIdx].Trip[inTripIdx].startNodeIdx))
					//{
					//	return REMOVE_CUSTOMER; // in case of DELIVERY inDeliveryIdx is both of firstCus and startNodeIdx of 2 consecutive trips.
					//}
#if !Q_JOINT_POINT_ALLOWANCE
					if ((inC2CPickupIdx+nOrder == seg[inVehIdx].Trip[inTripIdx].lastCus) || (inC2CPickupIdx == seg[inVehIdx].Trip[inTripIdx].firstCus))
						return REMOVE_SPE_CUST;
					if ((inC2CPickupIdx+nOrder == seg[inVehIdx].Trip[inTripIdx].lastCus))
						return REMOVE_SPE_CUST;
#endif
					got = true;
					break;
				}
				curC = nextArr[curC];
			}
			if (got) break;
		}
		if (got) break;
	}
	if (!got)
	{
#if Q_DEBUG_C2C_DES
		cout << "\t Can not find c2c " << inC2CPickupIdx << " to remove" << endl;
#endif
		Where_Are_Nodes();
		return -1;
	}

	// Now, we found inDeliveryIdx in trip inTripIdx of vehicle inVehIdx

	// Screnario 1: This vehicle has ONE trip and ONE c2c-customer --> Remove-a-Vehicle
	if ((1 == seg[inVehIdx].numTrips) && ((2 == seg[inVehIdx].Trip[inTripIdx].numCus)))
	{
#if Q_DEBUG_C2C_DES
		cout << "\t This vehicle has ONE trip and ONE c2c-customer-demand --> Remove-A-Vehicle" << endl;
#endif
		Remove_A_Vehicle(inVehIdx);
		return REMOVE_VEHICLE;
	}

	// Scenario 2: This vehicle has more than one trip and this trip has ONE c2c-customer demand
	if (((1 < seg[inVehIdx].numTrips)) && (2 == seg[inVehIdx].Trip[inTripIdx].numCus))
	{		
#if Q_DEBUG_C2C_DES
		cout << "\t This vehicle has mutiple trips and this trip has ONE customer-demand --> Remove-A-Trip" << endl;
#endif
		Remove_A_Trip(inVehIdx, 1, 1);		
		return REMOVE_TRIP;
	}

	// Scenario 3: This vehicle has more than one trip and this trip has more than one customer demands
#if Q_DEBUG_C2C_DES
	cout << "\t Before applying destroy..." << endl;
	Show_A_Trip(inVehIdx, inTripIdx);
#endif
	//int curC = seg[inVehIdx].Trip[inTripIdx].firstCus;
	//if (curC == inC2CPickupIdx) 
	//{
	//	seg[inVehIdx].Trip[inTripIdx].firstCus = nextArr[curC];
	//} else
	//{
	//	while (curC > 0)
	//	{
	//		if (nextArr[curC] == inC2CPickupIdx)
	//		{
	//			nextArr[curC] = nextArr[inC2CPickupIdx];
	//			nextArr[inC2CPickupIdx] = -1;
	//		} else if (nextArr[curC] == inC2CDeliveryIdx)
	//		{
	//			nextArr[curC] = nextArr[inC2CDeliveryIdx];
	//			nextArr[inC2CDeliveryIdx] = -1;
	//		}
	//		curC = nextArr[curC];
	//	}
	//}

	
	int inTripSzTmp = 0;
	int arrTripTmp[1000];
	int curC;

	// Build current C2C trip exclude C2CPickup and C2CDelivery
	curC = seg[inVehIdx].Trip[inTripIdx].firstCus;
	if (curC == inC2CPickupIdx)
	{
		//seg[inVehIdx].Trip[inTripIdx].firstCus = nextArr[curC];
	}
	while (curC > 0)
	{
		if ((curC != inC2CPickupIdx) && (curC != inC2CDeliveryIdx))
		{
			inTripSzTmp++;
			arrTripTmp[inTripSzTmp] = curC;
		}
		curC = nextArr[curC];
	}
	// Update trip
	curC = arrTripTmp[1];
	routed[curC] = 1;
	for (int i = 2; i <= inTripSzTmp; i++)
	{
		routed[arrTripTmp[i]] = 1;
		nextArr[curC] = arrTripTmp[i];
		curC = arrTripTmp[i];
	}
	nextArr[curC] = -1;		


	seg[inVehIdx].Trip[inTripIdx].numCus -= 2;
	routed[inC2CPickupIdx] = 0;
	routed[inC2CDeliveryIdx] = 0;

#if 1 //Q_JOINT_POINT_ALLOWANCE
	if (inC2CPickupIdx == seg[inVehIdx].Trip[inTripIdx].firstCus)
	{
		if (inTripIdx > 1) //not first trip
		{ 
			if (seg[inVehIdx].Trip[inTripIdx-1].endNodeIdx == seg[inVehIdx].Trip[inTripIdx].firstCus)
			{
				seg[inVehIdx].Trip[inTripIdx-1].endNodeIdx = arrTripTmp[1];
			}
		}
		seg[inVehIdx].Trip[inTripIdx].firstCus = arrTripTmp[1];
		seg[inVehIdx].Trip[inTripIdx].lastCus = arrTripTmp[inTripSzTmp];
	}
#endif

	// Reset time for this trip
	bRetVal = SetBeginTimeForPath_Q(seg[inVehIdx].Trip[inTripIdx].leaveSP, seg[inVehIdx].Trip[inTripIdx].startNodeIdx,
					arrTripTmp,
					inTripSzTmp,
					arrBeginIime,
					seg[inVehIdx].Trip[inTripIdx].endNodeIdx,
					&dbEndS,
					&inWSId,
					&inVehCap);

	if (false == bRetVal)
	{
#if Q_CRIT_SKIP
		cout << "Reset time for C2C trip after destroy... failed *ln" << __LINE__ << endl; getchar();
		Show_A_Trip(inVehIdx, inTripIdx);
#endif
		return -1;
	}

	seg[inVehIdx].Trip[inTripIdx].waitingS = inWSId;

	// Check time-forward slack	
	if (inTripIdx < seg[inVehIdx].numTrips)
	{
		if (TRIP_PICKUP == seg[inVehIdx].Trip[inTripIdx].Type)
		{
			dbEndS += problem->nodeSP[seg[inVehIdx].Trip[inTripIdx].endNodeIdx].unload;
		}

		seg[inVehIdx].Trip[inTripIdx].endS = dbEndS;
		
		if (seg[inVehIdx].Trip[inTripIdx+1].startNodeIdx == seg[inVehIdx].Trip[inTripIdx].lastCus)
		{

			dbStartTimeTmp = arrBeginIime[inTripSzTmp];
		} else
		{
			dbStartTimeTmp = dbEndS;
		}

		//if (false == Set_Time_For_A_Vehicle(inVehIdx, inTripIdx+1, dbStartTimeTmp, true))
		if (false == Set_Time_For_A_Vehicle(inVehIdx, 1, dbStartTimeTmp, true))
		{
#if Q_DEBUG_C2C_DES
			cout << "Set_Time_For_A_Vehicle_Vio::failed" << endl;
#endif
		} else
		{
#if Q_DEBUG_C2C_DES
			cout << "\t From trip " << inTripIdx << " to " << seg[inVehIdx].numTrips << " new dbVioVal=" << (dbVioVal+dbNewVioVal) << endl;
#endif
			//// TODO: Calc fitness of solution anh saved the least fitness
			//if (dbLeastFitnest > (dbVioVal+dbNewVioVal-dbVioVal+dbNewVioVal))
			//{
			//	dbLeastFitnest = dbVioVal+dbNewVioVal-dbVioVal+dbNewVioVal;
			//	inBestPos = i;
			//}
		}				

		//showSolution();
	} 

#if Q_DEBUG_C2C_DES
	cout << "\t Got new trip: " << endl;
	Show_A_Trip(inVehIdx, inTripIdx);
#endif

	if (false == Valid_A_Trip(inVehIdx, inTripIdx))
	{
#if Q_DEBUG_C2C_DES
		cout << "\t Remove_A_C2C_Pair failed: " << inC2CPickupIdx << endl;
#endif
		return -1;
	}

	return REMOVE_CUSTOMER; // If we allow to wait at customer-pickup so removing a pick-up valid though
}

// Return total of customer-demands of vehice inVehIdx
int Solution::Get_Node_Tot_In_Veh(int inVehIdx)
{
	int inNodeTot = 0;
	for (int i = 1; i <= seg[inVehIdx].numTrips; i++)
	{
		inNodeTot += seg[inVehIdx].Trip[i].numCus;
	}

	return (inNodeTot);
}


//Check LIFO policy
bool Solution::IsLIFO_Q(int* arrC2CTrip, int inNodeNbr)
{
    int Pickup[500];
	int pointP = 0; 
	int idP;
	
#if Q_DEBUG_CHK_LIFO
	cout << "\tCheck LIFO" << endl;
	//cout << "\t\t C2C trip for checking LIFO policy: " << endl;
	//for (int i = 1; i <= inNodeNbr; i++)
	//{
	//	cout << arrC2CTrip[i] << " ";
	//}
	//cout << endl;
#endif

	for (int i = 1; i <= inNodeNbr; i++)
	{
		switch (Get_Node_Type(arrC2CTrip[i]))
		{
		case NODE_C2C_PICKUP:
			pointP ++; 
			Pickup[pointP] = arrC2CTrip[i];
			break;
		case NODE_C2C_DELIVERY:
			if (Pickup[pointP] == arrC2CTrip[i] - nOrder)
			{
				pointP--;
			}
			else
			{
#if Q_DEBUG_CHK_LIFO
				cout<<"\t\t Not LIFO at " << arrC2CTrip[i] << endl;
#endif
				return false;
			}
		break;
		default:
			cout << "IsLIFO: Does not support this kind of node " << arrC2CTrip[i] << endl; getchar;				
			return false;
		}
	}
	
#if Q_DEBUG_CHK_LIFO
	cout << "\t\tCheck LIFO... ok!" << endl;
#endif

	return true;
}

//int Solution::Select_Probability_By_Weight(double *weights, int n) {
//    // This step only necessary if weights can be arbitrary
//    // (we know total = 1.0 for probabilities)
//    double total = 0;
//    for (int i = 0; i < n; ++i) {
//        total += weights[i];
//    }
//
//    // Cast RAND_MAX to avoid overflow
//    double r = (double) rand() * total / ((double) RAND_MAX + 1);
//    total = 0;
//    for (int i = 0; i < n; ++i) {
//        // Guaranteed to fire before loop exit
//        if (total <= r && total + weights[i] > r) {
//            return i;
//        }
//
//        total += weights[i];
//    }
//}


int Solution::Select_Probability_By_Weight2(double *OperWeights, int StartIdx, int OperNbr, bool isRandom)
{
	double arrProbab[2000];
	double inSum;

	inSum = 0;
	for (int i = StartIdx; i <= OperNbr; i++)
	{
		inSum += OperWeights[i];
	}

	if (0 == inSum) // in case of all nodes are ZERO
	{
		int inRndTmp = rand() % (OperNbr-StartIdx) + StartIdx;
#if Q_DEBUG_PROB_SEL
		if (inRndTmp < 1)
		{
			cout << "Select_Probability_By_Weight:: Negative value!" << endl; getchar;
		}
#endif

		return (inRndTmp); 
	}


	for (int i = StartIdx; i <= OperNbr; i++)
	{
		arrProbab[i] = OperWeights[i]/inSum;
		arrProbab[i] *= 100;
	}

	int inSeed = rand() % 100 +1;
	inSum = 0;
	for (int i = StartIdx; i <= OperNbr; i++)
	{
		inSum += arrProbab[i];
		if (inSum >= inSeed)
		{
#if Q_DEBUG_PROB_SEL
		if (i < 1)
		{
			cout << "Select_Probability_By_Weight:: Negative value2!" << endl; getchar;
		}
#endif
			return i;
		}
	}

	return OperNbr;
}
/* The more weight, the more probability to be selected
 * Roulette-wheel mechanism?
 */
int Solution::Select_Probability_By_Weight(double *OperWeights, int OperNbr, bool isRandom)
{
	double arrProbab[2000];
	double inSum;

	if (true == isRandom)
	{
#if Q_DEBUG_PROB_SEL
		cout << "Select_Probability_By_Weight:: Randomly" << endl;
#endif
		return (rand()%OperNbr+1);
	}

#if Q_DEBUG_PROB_SEL
	cout << "Array: ";
	for (int i=1; i<=OperNbr; i++) {
		cout << OperWeights[i] << " ";
	}
	cout << endl;
#endif

	inSum = 0;
	for (int i = 1; i <= OperNbr; i++)
	{
		inSum += OperWeights[i];
	}
#if Q_DEBUG_PROB_SEL
	cout << "Sum = " << inSum << endl;
#endif

	if (0 == inSum) // in case of all nodes are ZERO
	{
		int inRndTmp = rand() % OperNbr + 1;
#if Q_DEBUG_PROB_SEL
		if (inRndTmp < 1)
		{
			cout << "Select_Probability_By_Weight:: Negative value!" << endl; getchar;
		}
#endif

		return (inRndTmp); 
	}


	for (int i = 1; i <= OperNbr; i++)
	{
		arrProbab[i] = OperWeights[i]/inSum;
		arrProbab[i] *= 100;
	}
#if Q_DEBUG_PROB_SEL
	cout << "Array (Prob.): ";
	for (int i=1; i<=OperNbr; i++) {
		cout << arrProbab[i] << " ";
	}
	cout << endl;
#endif

#if Q_DEBUG_PROB_SEL
	cout << "Array (Prob.) - added: ";
	inSum = 0;
	for (int i=1; i<=OperNbr; i++) {
		inSum += arrProbab[i];
		cout << inSum << " ";
	}
	cout << endl;
#endif

	int inSeed = rand() % 100 +1;
#if Q_DEBUG_PROB_SEL
	cout << "Seed = " << inSeed << endl;
#endif
	inSum = 0;
	for (int i = 1; i <= OperNbr; i++)
	{
		inSum += arrProbab[i];
		if (inSum >= inSeed)
		{
#if Q_DEBUG_PROB_SEL
		if (i < 1)
		{
			cout << "Select_Probability_By_Weight:: Negative value2!" << endl; getchar;
		}
#endif
#if Q_DEBUG_PROB_SEL
			cout << "Selected " << i << endl;
#endif
			return i;
		}
	}

#if Q_DEBUG_PROB_SEL
	cout << "Should not come here -> bug " << inSeed << endl;
#endif
	return OperNbr;
}

//int Solution::Select_ALNS_Operator(int *OperWeights, int OperNbr) //(1) Random, (2) Worst-cost, (3) Shaw, (4) Relatedness, (5) Wrong-Position
//{
//	int inBestVal, inBestIdx;
//	int inCounter = 1;
//	int RandIdx;
//
//	inBestVal = OperWeights[1];
//	inBestIdx = 1;
//	inCounter = 1;
//	for (int i = 2; i <= OperNbr; i++)
//	{
//		if (OperWeights[i] == inBestVal)
//		{
//			inCounter++;
//		} else if (OperWeights[i] > inBestVal)
//		{
//			inBestVal = OperWeights[i];
//			inBestIdx = i;
//			inCounter = 1;
//		}
//	}
//
//	if (1 == inCounter) return inBestIdx;
//
//	RandIdx = rand() % inCounter + 1;
//	inCounter = 0;
//	for (int i = 1; i <= OperNbr; i++)
//	{
//		if (OperWeights[i] == inBestVal)
//		{
//			inCounter++;
//		}
//		if (inCounter == RandIdx)
//			return i;
//	}
//}

/*
 * Change the size of the destroy
 * The larger value of removed customer demands, the more diversified the neighborhood being searched
 */
int Solution::Select_Cus_Demand_Nbr(int cusDemandType, bool bChanged)
{
	int inTotalNode = 0;
	double n_ru;
	double n_rl1; // n^'_{rl}
	double n_ru1; // n^'_{ru}
	int inLeftB;
	int inRightB;

	
	//return rand()%6 +1; // fixed [1 .. 5]


	n_ru = g_dbN_ru;
	n_rl1 = g_dbN_rl_com;
	n_ru1 = g_dbN_ru_com;

	inTotalNode = nP + nD + 2*nOrder;

	switch (cusDemandType)
	{
	case TYPE_CUST_C2C:
		inTotalNode = nOrder;
		break;
	case TYPE_CUST_PICKUP:
		inTotalNode = nP;
		break;
	case TYPE_CUST_DELIVERY:
		inTotalNode = nD;
		break;
	default:
		break;
	}

	if (false == bChanged)
	{
		// n_r customer demands in the range [1, inTotalNode * n_{ru}]
#if Q_D_CUS_DEMAND_NBR
		cout << " in range of [" << g_dbN_rl << "," << g_dbN_ru0 << "]" << endl;
#endif
		inLeftB = g_dbN_rl;
		inRightB = g_dbN_ru0;
	} else
	{
		inLeftB = (int)(inTotalNode * n_rl1);
		inRightB = (int)(inTotalNode * n_ru1);
	}
	
	int n_r;
	if (inRightB < 1)
	{
		n_r = 1;
	} else
		n_r = rand() % inRightB + inLeftB;
	
	if (TYPE_CUST_C2C == cusDemandType)	//C2C
	{
		if (n_r > nOrder) return nOrder;
	} else if (TYPE_CUST_PICKUP == cusDemandType) //Pickup
	{
		if (n_r > nP) return nP;
	} else // Delivery
	{
		if (n_r > nD) return nD;
	}

#if Q_D_CUS_DEMAND_NBR
	//cout << n_r << " customer demands" << endl;
#endif
	return n_r;
}

/*
 * START IMPLEMENTATION OF DESTROY OPERATION
 */

/*
 * Randomly select n_r customer demands of the chosen type to remove from the current solution
 * The randomness of this neighborhood creates different solutions, thus introduces a degree of diversity
 */
bool Solution::Random_Destroy(int inCusDemandType, int inCusDemandNbr)
{

#if Q_DEBUG_RANDOM_DES
	cout << "\t\t\t RANDOM DESTROY" << endl;
#endif

	if (TYPE_CUST_C2C == inCusDemandType) // C2C-customer-demands
	{ 
#if Q_DEBUG_RANDOM_DES
		cout << "\tApply to " << inCusDemandNbr << " C2C" << endl;
#endif
		for (int inDestroyCounter=1; inDestroyCounter<=inCusDemandNbr; inDestroyCounter++)
		{
			//* C2C-PICKUP  : nSP + 1						-> nOrder + nSP
			//* C2C-DELIVERY: nOrder + nSP + 1				-> nOrder + nOrder + nSP
			int inC2CPickupRnd = rand() % (nOrder);
			inC2CPickupRnd += nSP + 1;
#if Q_DEBUG_RANDOM_DES
			cout << "\t\t\t Destroying C2C " << inC2CPickupRnd << "...";
#endif
			if (!routed[inC2CPickupRnd])
			{
#if Q_DEBUG_RANDOM_DES
				cout << "NOT ROUTED alreay!" << endl;
#endif
				continue;
			}


			int inRetVal = Remove_A_C2C_Pair(inC2CPickupRnd);
			if (-1 == inRetVal)
			{
#if Q_DEBUG_RANDOM_DES
				cout << " CANNOT destroy!" << endl;
#endif
				continue;
			}

			if (REMOVE_VEHICLE == inRetVal){
#if Q_DEBUG_RANDOM_DES
				cout << " remove a vehicle: SKIPPED!"<< endl;
#endif
				continue;
				numVeh--; // TODO: remove a vehicle
			} else if (REMOVE_TRIP == inRetVal){
#if Q_DEBUG_RANDOM_DES
				cout << " remove a trip: SKIPPED!" << endl;
#endif
				//TODO: remove a trip 
			} else if (REMOVE_CUSTOMER == inRetVal)
			{
#if Q_DEBUG_RANDOM_DES
				cout << " ok!" << endl;
#endif
			} else if (REMOVE_SPE_CUST == inRetVal)
			{
#if Q_DEBUG_RANDOM_DES
				cout << " ok!!" << endl;
#endif
			} else
			{
				cout << " Unknown error! *ln" << __LINE__ << endl; getchar();
			}
		}
	} else if (TYPE_CUST_PICKUP == inCusDemandType) // Pickup-customer-demands
	{ 
#if Q_DEBUG_RANDOM_DES
		cout << "\tApply to " << inCusDemandNbr << " Pickup" << endl;
#endif
		for (int inDestroyCounter=1; inDestroyCounter<=inCusDemandNbr; inDestroyCounter++)
		{
			// * PICKUP	   : nOrder + nOrder + nSP + 1		-> nP + nOrder + nOrder + nSP
			int inPickupRnd = rand() % (nP);
			inPickupRnd += nOrder + nOrder + nSP + 1;

#if Q_DEBUG_RANDOM_DES
			cout << "\t\t\t Destroying PICKUP " << inPickupRnd << "...";
#endif

			if (!routed[inPickupRnd])
			{
#if Q_DEBUG_RANDOM_DES
				cout << "NOT ROUTED alreay!" << endl;
#endif
				continue;
			}

			int inRetVal = Remove_A_Pickup(inPickupRnd);			
			if (-1 == inRetVal)
			{
#if Q_DEBUG_RANDOM_DES
				cout << " CANNOT destroy!" << endl;
#endif
				continue;
			}

			if (REMOVE_VEHICLE == inRetVal){
#if Q_DEBUG_RANDOM_DES
				cout << " remove VEHICLE: SKIPPED!" << endl; 
#endif
				continue;
				numVeh--; // TODO: remove a vehicle
			} else if (REMOVE_TRIP == inRetVal){
#if Q_DEBUG_RANDOM_DES
				cout << " remove TRIP: SKIPPED!" << endl;
#endif
			} else if (REMOVE_CUSTOMER == inRetVal)
			{
#if Q_DEBUG_RANDOM_DES
				cout << " ok!" << endl;
#endif
			} else if (REMOVE_SPE_CUST == inRetVal)
			{
#if Q_DEBUG_RANDOM_DES
				cout << " ok!!" << endl;
#endif
			} else
			{
				cout << " Unknown error! *ln" << __LINE__ << endl; getchar();
			}
		}
	} else if (TYPE_CUST_DELIVERY == inCusDemandType) // Delivery-customer-demands
	{ 
#if Q_DEBUG_RANDOM_DES
		cout << "\tApply to " << inCusDemandNbr << " Delivery" << endl;
#endif
		for (int inDestroyCounter=1; inDestroyCounter<=inCusDemandNbr; inDestroyCounter++)
		{
			// * DELIVERY	   : nP + nOrder + nOrder + nSP + 1 -> nD + nP + nOrder + nOrder + nSP
			int inDeliveryRnd = rand() % (nD);
			inDeliveryRnd += nP + nOrder + nOrder + nSP + 1;
#if Q_DEBUG_RANDOM_DES
			cout << "\t\t\t Destroying DELIVERY " << inDeliveryRnd << "...";
#endif
			//inDeliveryRnd = 528;
			if (!routed[inDeliveryRnd])
			{
#if Q_DEBUG_RANDOM_DES
				cout << "NOT ROUTED alreay!" << endl;
#endif
				continue;
			}

			int inRetVal = Remove_A_Delivery(inDeliveryRnd);
			if (-1 == inRetVal)
			{
#if Q_DEBUG_RANDOM_DES
				cout << " CANNOT destroy!" << endl;
#endif
				continue;
			}

			if (REMOVE_VEHICLE == inRetVal){
#if Q_DEBUG_RANDOM_DES
				cout << " remove vehicle: SKIPPED!" << endl;
#endif
				continue;
				numVeh--; //TODO remove a vehicle
			} else if (REMOVE_TRIP == inRetVal){
#if Q_DEBUG_RANDOM_DES
				cout << " remove trip: SKIPPED!" << endl;
#endif
			} else if (REMOVE_CUSTOMER == inRetVal)
			{
#if Q_DEBUG_RANDOM_DES
				cout << " ok!" << endl;
#endif
			} else if (REMOVE_SPE_CUST == inRetVal)
			{
#if Q_DEBUG_RANDOM_DES
				cout << " ok!!" << endl;
#endif
			} else
			{
				cout << " Unknown error! *ln" << __LINE__ << endl; getchar();
			}
		}
	}

	return true;
}

/*
 * First computes the detour caused by each customer demand of the SELECTED type
 * f(z): denote the fitness value of the current solution z
 * f(z,i): denote the fitness value of this solution without the customer demand i
 * D(z, i) = f(z) - f(z,i): value of detour
 * Remove n_r customer demands with the HIGHEST value of the detour
 */
bool Solution::Worst_Cost_Destroy(int inCusDemandType, int inCusDemandNbr)
{
	int arrNodeIdx[2000];
	double dbDetourValue[2000];
	int inNodeIdxSz;
	int inRetVal;
	int inTripType;
	int inNodeOffset;
	int inC2CPickupRnd;

#if Q_DEBUG_WORST_COST_DES
	cout << "\t\t\t WORST COST DESTROY" << endl;
#endif

	// Get tripType by customer demand type
	switch (inCusDemandType)
	{
	case TYPE_CUST_DELIVERY:
		inTripType = TRIP_DELIVERY;
		break;
	case TYPE_CUST_PICKUP:
		inTripType = TRIP_PICKUP;
		break;
	case TYPE_CUST_C2C:
		inTripType = TRIP_C2C;
		break;
	default:
		cout << "Worst_Cost_Destroy: Bad CusDemandType *ln" << __LINE__ << endl; getchar();
		return false;
	}

	inNodeIdxSz = 0;
	// Calculate the D(z,i) of all inCusDemandType demands
   for (int i = 1; i <= numVeh; i++)
   {
	   for (int j = 1; j <= seg[i].numTrips; j++)
	   {
		   if (seg[i].Trip[j].Type != inTripType) continue;
		   // Rebuild path	
		   inNodeOffset = inNodeIdxSz;
		   int curC = seg[i].Trip[j].firstCus;
			while (curC > 0)
			{
				//if (NODE_C2C_DELIVERY != Get_Node_Type(curC))
				{
					inNodeIdxSz++;
					arrNodeIdx[inNodeIdxSz] = curC;					
				}
				curC = nextArr[curC];
			}

#if Q_DEBUG_WORST_COST_DES
			cout << "Path of vehilce " << i << " trip " << j;
			for (int loop = inNodeOffset+1; loop <= inNodeIdxSz; loop++)
			{
				cout << arrNodeIdx[loop] << " ";
			}
			cout << endl;
#endif

			if (seg[i].Trip[j].numCus > 1) // more than 1 customer
			{
				dbDetourValue[inNodeOffset+1] = problem->c[seg[i].Trip[j].startNodeIdx][arrNodeIdx[inNodeOffset+1]] + problem->c[arrNodeIdx[inNodeOffset+1]][arrNodeIdx[inNodeOffset+2]];
				for (int inNode = inNodeOffset+2; inNode < inNodeIdxSz; inNode++)
				{
					dbDetourValue[inNode] = problem->c[arrNodeIdx[inNode-1]][arrNodeIdx[inNode]] + problem->c[arrNodeIdx[inNode]][arrNodeIdx[inNode+1]];
				}
				dbDetourValue[inNodeIdxSz] = problem->c[arrNodeIdx[inNodeIdxSz-1]][arrNodeIdx[inNodeIdxSz]] + problem->c[arrNodeIdx[inNodeIdxSz]][seg[i].Trip[j].endNodeIdx];
			} else // has one customer: startNodeIdx -> customer -> endNodeIdx
			{
				dbDetourValue[inNodeOffset+1] = problem->c[seg[i].Trip[j].startNodeIdx][arrNodeIdx[inNodeOffset+1]] + problem->c[arrNodeIdx[inNodeOffset+1]][seg[i].Trip[j].endNodeIdx];
			}
#if Q_DEBUG_WORST_COST_DES
			cout << "Detour " << i << " trip " << j;
			for (int loop = inNodeOffset+1; loop <= inNodeIdxSz; loop++)
			{
				cout << dbDetourValue[loop] << " ";
			}
			cout << endl;
#endif
	   }
   }
	
   // Get inCusDemandNbr with highest value of D(z, i)
   for (int i = 1; i < inNodeIdxSz; i++)
   {
	   for (int j = i+1; j <= inNodeIdxSz; j++)
	   {
		   if (dbDetourValue[i] < dbDetourValue[j])
		   {
			   int inTmp = arrNodeIdx[i];
			   arrNodeIdx[i] = arrNodeIdx[j];
			   arrNodeIdx[j] = inTmp;
			   double dbTmp = dbDetourValue[i];
			   dbDetourValue[i] = dbDetourValue[j];
			   dbDetourValue[j] = dbTmp;
		   }
	   }
   }
#if Q_DEBUG_WORST_COST_DES
		cout << "Sorted Detour: ";
		for (int loop = 1; loop <= inNodeIdxSz; loop++)
		{
			cout << arrNodeIdx[loop] << "(" << dbDetourValue[loop] << ") ";
		}
		cout << endl;
#endif
   

   if (inNodeIdxSz < inCusDemandNbr)
   {
	   cout << "Check size *ln" << __LINE__ << endl; getchar();
	   return false;
   }

   // Remove inCusDemandNbr 
   for (int i = 1; i <= inCusDemandNbr; i++)
   {
	   int inNodeType = Get_Node_Type(arrNodeIdx[i]);
	  
	   switch (inTripType)
	   {
		   case TRIP_DELIVERY:
#if Q_DEBUG_WORST_COST_DES
				cout << "\t\t\t Destroying DELIVERY " << arrNodeIdx[i] << "...";
#endif
				if (!routed[arrNodeIdx[i]])
				{
#if Q_DEBUG_WORST_COST_DES
					cout << "NOT ROUTED alreay!" << endl;
#endif
					continue;
				}

				inRetVal = Remove_A_Delivery(arrNodeIdx[i]);
				if (-1 == inRetVal)
				{
#if Q_DEBUG_WORST_COST_DES
					cout << " CANNOT destroy!" << endl;
#endif
					continue;
				}

				if (REMOVE_VEHICLE == inRetVal){
#if Q_DEBUG_WORST_COST_DES
					cout << " remove vehicle: SKIPPED!" << endl;
#endif
					continue;
					numVeh--; // TODO: remove a vehicle
				} else if (REMOVE_TRIP == inRetVal){
#if Q_DEBUG_WORST_COST_DES
					cout << " remove trip: SKIPPED!" << endl;
#endif
				} else if (REMOVE_CUSTOMER == inRetVal)
				{
#if Q_DEBUG_WORST_COST_DES
					cout << " ok!" << endl;
#endif
				} else if (REMOVE_SPE_CUST == inRetVal)
				{
#if Q_DEBUG_WORST_COST_DES
					cout << " ok!!" << endl;
#endif
				} else
				{
					cout << " Unknown error! *ln" << __LINE__ << endl; getchar();
				}
			   break;

		   case TRIP_PICKUP:
#if Q_DEBUG_WORST_COST_DES
				cout << "\t\t\t Destroying PICKUP " << arrNodeIdx[i] << "...";
#endif
				if (!routed[arrNodeIdx[i]])
				{
#if Q_DEBUG_WORST_COST_DES
					cout << "NOT ROUTED alreay!" << endl;
#endif
					continue;
				}

				inRetVal = Remove_A_Pickup(arrNodeIdx[i]);
				//Update_SP_Status();
				if (-1 == inRetVal)
				{
#if Q_DEBUG_WORST_COST_DES
					cout << " CANNOT destroy!" << endl;
#endif
					continue;
				}

				if (REMOVE_VEHICLE == inRetVal){
#if Q_DEBUG_WORST_COST_DES
					cout << " remove VEHICLE: SKIPPED!" << endl; 
#endif
					continue;
					numVeh--; // TODO: remove a vehicle
				} else if (REMOVE_TRIP == inRetVal){
#if Q_DEBUG_WORST_COST_DES
					cout << " remove TRIP: SKIPPED!" << endl;
#endif
				} else if (REMOVE_CUSTOMER == inRetVal)
				{
#if Q_DEBUG_WORST_COST_DES
					cout << " ok!" << endl;
#endif					
				} else if (REMOVE_SPE_CUST == inRetVal)
				{
#if Q_DEBUG_WORST_COST_DES
					cout << " ok!!" << endl;
#endif
				} else
				{
					cout << " Unknown error! *ln" << __LINE__ << endl; getchar();
				}
			   break;

		   case TRIP_C2C:		  
			   if (NODE_C2C_DELIVERY == inNodeType)
			   {
				   inC2CPickupRnd = arrNodeIdx[i]-nOrder;
			   } else
			   {
				   inC2CPickupRnd = arrNodeIdx[i];
			   }
#if Q_DEBUG_WORST_COST_DES
				cout << "\t\t\t Destroying C2C " << inC2CPickupRnd << "...";
#endif
				if (!routed[inC2CPickupRnd])
				{
#if Q_DEBUG_WORST_COST_DES
					cout << "NOT ROUTED alreay!" << endl;
#endif
					continue;
				}

				inRetVal = Remove_A_C2C_Pair(inC2CPickupRnd);
				if (-1 == inRetVal)
				{
#if Q_DEBUG_WORST_COST_DES
					cout << " CANNOT destroy!" << endl;
#endif
					continue;
				}

				if (REMOVE_VEHICLE == inRetVal){
#if Q_DEBUG_WORST_COST_DES
					cout << " remove a vehicle: SKIPPED!"<< endl;
#endif
					continue;
					numVeh--; //TODO: remove a vehicle
				} else if (REMOVE_TRIP == inRetVal){
#if Q_DEBUG_WORST_COST_DES
					cout << " remove a trip: SKIPPED!" << endl;
#endif
				} else if (REMOVE_CUSTOMER == inRetVal)
				{
#if Q_DEBUG_WORST_COST_DES
					cout << " ok!" << endl;
#endif
				} else if (REMOVE_SPE_CUST == inRetVal)
				{
#if Q_DEBUG_WORST_COST_DES
					cout << " ok!!" << endl;
#endif
				} else
				{
					cout << " Unknown error! *ln" << __LINE__ << endl; getchar();
				}

			   break;
		   default:
			   cout << " Unknown error! *ln" << __LINE__ << endl; getchar();
			   return false;
	   }

   }
	
   return true;
}

/*
 * Alias name as Related destroy
 * Idea to remove customer demands that are somewhat similar to each other (e.g. close together, similar time window..)
 * 
 */
bool Solution::Shaw_Destroy(int inCusDemandType, int inCusDemandNbr)
{
	int arrNodeIdx[1000];
	int inNodeIdxSz;
	int inRetVal;
	int inTripType;
	double arrRelateness[1000];
	int inNodeType;
	int inC2CPickupRnd;

#if Q_DEBUG_SHAW_DES
	cout << "\t\t\t SHAW DESTROY"  << endl;
#endif
	// Get tripType by customer demand type
	switch (inCusDemandType)
	{
	case TYPE_CUST_DELIVERY:
		inTripType = TRIP_DELIVERY;
		break;
	case TYPE_CUST_PICKUP:
		inTripType = TRIP_PICKUP;
		break;
	case TYPE_CUST_C2C:
		inTripType = TRIP_C2C;
		break;
	default:
		cout << "\t\t\tBad CusDemandType *ln" << __LINE__ << endl; getchar();
		return false;
	}

	inNodeIdxSz = 0;
	// Calculate the D(z,i) of all inCusDemandType demands
   for (int i = 1; i <= numVeh; i++)
   {
	   for (int j = 1; j <= seg[i].numTrips; j++)
	   {
		   if (seg[i].Trip[j].Type != inTripType) continue;
		   // Rebuild path	
		   int curC = seg[i].Trip[j].firstCus;
			while (curC > 0)
			{
				if (NODE_C2C_DELIVERY != Get_Node_Type(curC))
				{
					inNodeIdxSz++;
					arrNodeIdx[inNodeIdxSz] = curC;
				}
				curC = nextArr[curC];
			}
	   }
   }

#if Q_DEBUG_SHAW_DES
   cout << "\t\t\tList of candidates: ";
   for (int i = 1; i <= inNodeIdxSz; i++)
   {
	   cout << arrNodeIdx[i] << " ";
   }
   cout << endl;
#endif

   
	/* 
	 * Normalized parameters in the range [0, 1]
	 */
	// MaxCij
	double dbMaxCij = -PDS_INFINITY;
	for (int i = 1; i < inNodeIdxSz; i++)
	{
		for (int j = i+1; j <= inNodeIdxSz; j++)
		{
			if (problem->c[arrNodeIdx[i]][arrNodeIdx[j]] <= 0) continue;
			if (problem->c[arrNodeIdx[i]][arrNodeIdx[j]] == PDS_INFINITY) continue;

			if (dbMaxCij < problem->c[arrNodeIdx[i]][arrNodeIdx[j]])
			{
				dbMaxCij = problem->c[arrNodeIdx[i]][arrNodeIdx[j]];
			}
		}
	}
	// DeltaCap
	double dbMinCap = PDS_INFINITY;
	double dbMaxCap = -PDS_INFINITY;
	for (int i = 1; i <= inNodeIdxSz; i++)
	{
		if (problem->node[arrNodeIdx[i]].capacity < dbMinCap)
		{
			dbMinCap = problem->node[arrNodeIdx[i]].capacity;
		}
		if (problem->node[arrNodeIdx[i]].capacity > dbMaxCap)
		{
			dbMaxCap = problem->node[arrNodeIdx[i]].capacity;
		}
	}
	double dbDeltaCap = dbMaxCap-dbMinCap;
	// Deltatime
	double dbDeltaTime = 0;
	if (false == Calc_Delta_Norm_Shaw_Destroy(inTripType, &dbDeltaTime))
	{
		cout << "Calc_Delta_Norm_Shaw_Destroy" << endl; getchar();
		return false;
	}
#if Q_DEBUG_SHAW_DES
	cout << "\t MaxCij = " << dbMaxCij << endl;
	cout << "\t DeltaCap = " << dbDeltaCap << endl;
	cout << "\t DeltaTime = " << dbDeltaTime << endl;
#endif

   // Select a SEED randomly
   int inSeed = rand() % (inNodeIdxSz) + 1;

   // Calculate the relateness between seed and the others
   for (int i = 1; i <= inNodeIdxSz; i++)
   {
	   if (inSeed == i)
	   {
		   arrRelateness[i] = 0;//PDS_INFINITY;
	   } else
	   {
		   arrRelateness[i] = Calc_Relatedness(arrNodeIdx[inSeed], arrNodeIdx[i], dbMaxCij, dbDeltaTime, dbDeltaCap);
	   }
   }
 #if Q_DEBUG_SHAW_DES
   cout << "\t\t\tList of Relatedness candidates: ";
   for (int i = 1; i <= inNodeIdxSz; i++)
   {
	   cout << arrRelateness[i] << " ";
   }
   cout << endl;
#endif

   // Remove
   for (int i = 1; i <= inCusDemandNbr; i++)
   {
		int inRemoveNode = Select_Probability_By_Weight(arrRelateness, inNodeIdxSz, false);
		if (-1 == arrRelateness[inRemoveNode]) continue;
		if (1 == i)
		{
			inRemoveNode = arrNodeIdx[inSeed]; //Remove seed
		} else
		{
			inRemoveNode = arrNodeIdx[inRemoveNode];
		}

		//////////////////////////
	   switch (inTripType)
	   {
		   case TRIP_DELIVERY:
#if Q_DEBUG_SHAW_DES
				cout << "\t\t\t Destroying DELIVERY " << inRemoveNode << "...";
#endif
				if (!routed[inRemoveNode])
				{
#if Q_DEBUG_SHAW_DES
					cout << "NOT ROUTED alreay!" << endl;
#endif
					continue;
				}

				inRetVal = Remove_A_Delivery(inRemoveNode);
				if (-1 == inRetVal)
				{
#if Q_DEBUG_SHAW_DES
					cout << " CANNOT destroy!" << endl;
#endif
					continue;
				}
				if (REMOVE_VEHICLE == inRetVal){
#if Q_DEBUG_SHAW_DES
					cout << " remove vehicle: SKIPPED!" << endl;
#endif
					continue;
					numVeh--; // TODO: remove a vehicle
				} else if (REMOVE_TRIP == inRetVal){
#if Q_DEBUG_SHAW_DES
					cout << " remove trip: SKIPPED!" << endl;
#endif
				} else if (REMOVE_CUSTOMER == inRetVal)
				{
#if Q_DEBUG_SHAW_DES
					cout << " ok!" << endl;
#endif
				} else if (REMOVE_SPE_CUST == inRetVal)
				{
#if Q_DEBUG_SHAW_DES
					cout << " ok!!" << endl;
#endif
				} else
				{
					cout << " Unknown error! *ln" << __LINE__ << endl; getchar();
				}
			   break;

		   case TRIP_PICKUP:
#if Q_DEBUG_SHAW_DES
				cout << "\t\t\t Destroying PICKUP " << inRemoveNode << "...";
#endif
				if (!routed[inRemoveNode])
				{
#if Q_DEBUG_SHAW_DES
					cout << "NOT ROUTED alreay!" << endl;
#endif
					continue;
				}

				inRetVal = Remove_A_Pickup(inRemoveNode);
				//Update_SP_Status();
				if (-1 == inRetVal)
				{
#if Q_DEBUG_SHAW_DES
					cout << " CANNOT destroy!" << endl;
#endif
					continue;
				}

				if (REMOVE_VEHICLE == inRetVal){
#if Q_DEBUG_SHAW_DES
					cout << " remove VEHICLE: SKIPPED!" << endl; 
#endif
					continue;
					numVeh--; //TODO: remove a vehicle
				} else if (REMOVE_TRIP == inRetVal){
#if Q_DEBUG_SHAW_DES
					cout << " remove TRIP: SKIPPED!" << endl;
#endif
				} else if (REMOVE_CUSTOMER == inRetVal)
				{
#if Q_DEBUG_SHAW_DES
					cout << " ok!" << endl;
#endif
				} else if (REMOVE_SPE_CUST == inRetVal)
				{
#if Q_DEBUG_SHAW_DES
					cout << " ok!!" << endl;
#endif
				} else
				{
					cout << " Unknown error! *ln" << __LINE__ << endl; getchar();
				}
			   break;

		   case TRIP_C2C:		  
			   if (NODE_C2C_DELIVERY == Get_Node_Type(inRemoveNode))
			   {
				   inC2CPickupRnd = inRemoveNode-nOrder;
			   } else
			   {
				   inC2CPickupRnd = inRemoveNode;
			   }

#if Q_DEBUG_SHAW_DES
				cout << "\t\t\t Destroying C2C " << inC2CPickupRnd << "...";
#endif
				if (!routed[inC2CPickupRnd])
				{
#if Q_DEBUG_SHAW_DES
					cout << "NOT ROUTED alreay!" << endl;
#endif
					continue;
				}

				inRetVal = Remove_A_C2C_Pair(inC2CPickupRnd);
				if (-1 == inRetVal)
				{
#if Q_DEBUG_SHAW_DES
					cout << " CANNOT destroy!" << endl;
#endif
					continue;
				}

				if (REMOVE_VEHICLE == inRetVal){
#if Q_DEBUG_SHAW_DES
					cout << " remove a vehicle: SKIPPED!"<< endl;
#endif
					continue;
					numVeh--; //TODO: remove a vehicle
				} else if (REMOVE_TRIP == inRetVal){
#if Q_DEBUG_SHAW_DES
					cout << " remove a trip: SKIPPED!" << endl;
#endif
				} else if (REMOVE_CUSTOMER == inRetVal)
				{
#if Q_DEBUG_SHAW_DES
					cout << " ok!" << endl;
#endif
				} else if (REMOVE_SPE_CUST == inRetVal)
				{
#if Q_DEBUG_SHAW_DES
					cout << " ok!!" << endl;
#endif
				} else
				{
					cout << " Unknown error! *ln" << __LINE__ << endl; getchar();
				}

			   break;
		   default:
			   cout << " Unknown error! *ln" << __LINE__ << endl; getchar();
			   return false;
	   }
   }

	return true;
}

/*
 * using the idea of Shaw destroy, relatedness calculation between customer demands is 
 * calculated based on the historial information of the search
 * Using an elite set and a relatedness-based memory.
 * The elite set is a diversified pool of high-quality solutions found during the ALNS.
 * The elite set starts empty and is limited in size.
 * The quality and diversity of the elite set is controlled by the insertion of new best solution 
 * and the elimination of solutions in the elite set.
 */
bool Solution::Relatedness_Destroy(int inCusDemandType, int inCusDemandNbr)
{
	int inTripType;
	int inNodeIdxSz;
	int arrNodeIdx[2000];
	K_Elite eliteTmp;
	int arrRij[2000]; // the number of times customer demands (i, j) are served in Elite set
	int inNodeType;
	int inRetVal;
	int inC2CPickupRnd;

#if Q_DEBUG_RELATENESS_DES
	cout << "\t\t\t RELATEDNESS DESTROY" << endl;
#endif
	// Get tripType by customer demand type
	switch (inCusDemandType)
	{
	case TYPE_CUST_DELIVERY:
		inTripType = TRIP_DELIVERY;
		break;
	case TYPE_CUST_PICKUP:
		inTripType = TRIP_PICKUP;
		break;
	case TYPE_CUST_C2C:
		inTripType = TRIP_C2C;
		break;
	default:
		cout << "\t\t\tBad CusDemandType *ln" << __LINE__ << endl; getchar();
		return false;
	}

	// Create list of edges or an elite candidate
	inNodeIdxSz = 0;
	eliteTmp.inNodeTot = 0;
   for (int i = 1; i <= numVeh; i++)
   {
	   for (int j = 1; j <= seg[i].numTrips; j++)
	   {
		   if (seg[i].Trip[j].Type != inTripType) continue;
		   // Rebuild path	
			//eliteTmp.inNodeTot += 1;
			//eliteTmp.arrStartNode[eliteTmp.inNodeTot] = seg[i].Trip[j].startNodeIdx;
			//eliteTmp.arrEndNode[eliteTmp.inNodeTot] = seg[i].Trip[j].firstCus;

		   int curC = seg[i].Trip[j].firstCus;
			while (curC > 0)
			{
				if (NODE_C2C_DELIVERY != Get_Node_Type(curC))
				{
					inNodeIdxSz++;
					arrNodeIdx[inNodeIdxSz] = curC;
				}
				curC = nextArr[curC];
				if (curC > 0)
				{
			eliteTmp.inNodeTot += 1;
					eliteTmp.arrStartNode[eliteTmp.inNodeTot] = eliteTmp.arrEndNode[eliteTmp.inNodeTot-1];
					eliteTmp.arrEndNode[eliteTmp.inNodeTot] = curC;
				}
			}
			//eliteTmp.inNodeTot += 1;
			//eliteTmp.arrStartNode[eliteTmp.inNodeTot] = seg[i].Trip[j].lastCus;
			//eliteTmp.arrEndNode[eliteTmp.inNodeTot] = seg[i].Trip[j].endNodeIdx;

	   }
   }
#if Q_DEBUG_RELATENESS_DES
   cout << "\t\t\t The Elite candidate: ";
   for (int i = 1; i <= eliteTmp.inNodeTot; i++)
   {
	   cout << "(" << eliteTmp.arrStartNode[i] << "," << eliteTmp.arrEndNode[i] << ") ";
   }
   cout << endl;
#endif

   // Calc. relateness value
   for (int i = 1; i <= eliteTmp.inNodeTot; i++)
   {
	   arrRij[i] = Calc_Relatedness_Based_Mem(eliteTmp.arrStartNode[i], eliteTmp.arrEndNode[i]);
   }
#if Q_DEBUG_RELATENESS_DES
   cout << "\t\t\t The relatedness value of candidates: ";
   for (int i = 1; i <= eliteTmp.inNodeTot; i++)
   {
	   cout << arrRij[i] << " ";
   }
   cout << endl;
#endif

      // Remove
   for (int i = 1; i <= inCusDemandNbr; i++)
   {
		int inRemoveNode = Select_Probability_By_Weight((double *)arrRij, eliteTmp.inNodeTot, false);
		if (0 == arrRij[inRemoveNode]) continue;
		inRemoveNode = eliteTmp.arrStartNode[i];

		inNodeType = Get_Node_Type(inRemoveNode);
		if ((inNodeType == NODE_SUPPLY_POINT) || (inNodeType == NODE_DEPOT) || (inNodeType == NODE_WAITING_STATION) || (inNodeType == -1))
			continue;

				//////////////////////////
	   switch (inNodeType)
	   {
	   case NODE_DELIVERY:
#if Q_DEBUG_RELATENESS_DES
				cout << "\t\t\t Destroying DELIVERY " << inRemoveNode << "...";
#endif
				if (!routed[inRemoveNode])
				{
#if Q_DEBUG_RELATENESS_DES
					cout << "NOT ROUTED alreay!" << endl;
#endif
					continue;
				}

				inRetVal = Remove_A_Delivery(inRemoveNode);
				if (-1 == inRetVal)
				{
#if Q_DEBUG_RELATENESS_DES
					cout << " CANNOT destroy!" << endl;
#endif
					continue;
				}

				if (REMOVE_VEHICLE == inRetVal){
#if Q_DEBUG_RELATENESS_DES
					cout << " remove vehicle: SKIPPED!" << endl;
#endif
					continue;
					numVeh--; //TODO: remove a vehicle
				} else if (REMOVE_TRIP == inRetVal){
#if Q_DEBUG_RELATENESS_DES
					cout << " remove trip: SKIPPED!" << endl;
#endif
				} else if (REMOVE_CUSTOMER == inRetVal)
				{
#if Q_DEBUG_RELATENESS_DES
					cout << " ok!" << endl;
#endif
				} else if (REMOVE_SPE_CUST == inRetVal)
				{
#if Q_DEBUG_RELATENESS_DES
					cout << " ok!!" << endl;
#endif
				} else
				{
					cout << " Unknown error! *ln" << __LINE__ << endl; getchar();
				}
			   break;

	   case NODE_PICKUP:
#if Q_DEBUG_RELATENESS_DES
				cout << "\t\t\t Destroying PICKUP " << inRemoveNode << "...";
#endif

				if (!routed[inRemoveNode])
				{
#if Q_DEBUG_RELATENESS_DES
					cout << "NOT ROUTED alreay!" << endl;
#endif
					continue;
				}

				inRetVal = Remove_A_Pickup(inRemoveNode);
		
				if (-1 == inRetVal)
				{
#if Q_DEBUG_RELATENESS_DES
					cout << " CANNOT destroy!" << endl;
#endif
					continue;
				}

				if (REMOVE_VEHICLE == inRetVal){
#if Q_DEBUG_RELATENESS_DES
					cout << " remove VEHICLE: SKIPPED!" << endl; 
#endif
					continue;
					numVeh--; //TODO: remove a vehicle
				} else if (REMOVE_TRIP == inRetVal){
#if Q_DEBUG_RELATENESS_DES
					cout << " remove TRIP: SKIPPED!" << endl;
#endif
				} else if (REMOVE_CUSTOMER == inRetVal)
				{
#if Q_DEBUG_RELATENESS_DES
					cout << " ok!" << endl;
#endif
				} else if (REMOVE_SPE_CUST == inRetVal)
				{
#if Q_DEBUG_RELATENESS_DES
					cout << " ok!!" << endl;
#endif
				} else
				{
					cout << " Unknown error! *ln" << __LINE__ << endl; getchar();
				}
			   break;

	   case NODE_C2C_DELIVERY:
	   case NODE_C2C_PICKUP:
			   if (NODE_C2C_DELIVERY == Get_Node_Type(inRemoveNode))
			   {
				   inC2CPickupRnd = inRemoveNode-nOrder;
			   } else
			   {
				   inC2CPickupRnd = inRemoveNode;
			   }
#if Q_DEBUG_RELATENESS_DES
				cout << "\t\t\t Destroying C2C " << inC2CPickupRnd << "...";
#endif
				if (!routed[inC2CPickupRnd])
				{
#if Q_DEBUG_RELATENESS_DES
					cout << "NOT ROUTED alreay!" << endl;
#endif
					continue;
				}

				inRetVal = Remove_A_C2C_Pair(inC2CPickupRnd);
				if (-1 == inRetVal)
				{
#if Q_DEBUG_RELATENESS_DES
					cout << " CANNOT destroy!" << endl;
#endif
					continue;
				}

				if (REMOVE_VEHICLE == inRetVal){
#if Q_DEBUG_RELATENESS_DES
					cout << " remove a vehicle: SKIPPED!"<< endl;
#endif
					continue;
					numVeh--; // TODO: remove a vehicle
				} else if (REMOVE_TRIP == inRetVal){
#if Q_DEBUG_RELATENESS_DES
					cout << " remove a trip: SKIPPED!" << endl;
#endif
				} else if (REMOVE_CUSTOMER == inRetVal)
				{
#if Q_DEBUG_RELATENESS_DES
					cout << " ok!" << endl;
#endif
				} else if (REMOVE_SPE_CUST == inRetVal)
				{
#if Q_DEBUG_RELATENESS_DES
					cout << " ok!!" << endl;
#endif
				} else
				{
					cout << " Unknown error! *ln" << __LINE__ << endl; getchar();
				}

			   break;
		   default:
			   cout << " Unknown error! *ln" << __LINE__ << endl; getchar();
			   return false;
	   }
   }

	return true;
}

/*
 * Goal to remove customer-demands that are currently assigned to improper position of the solution
 */
bool Solution::Wrong_Position_Destroy(int inCusDemandType, int inCusDemandNbr)
{
	int arrNodeIdx[2000];
	int inNodeIdxSz;
	int inRetVal;
	int inTripType;
	double arrScore[2000];
	int inNodeType;
	int inC2CPickupRnd;

#if Q_DEBUG_WRONG_POS_DES
	cout << "\t\t\t WRONG POSITION DESTROY" << endl;
#endif
	// Get tripType by customer demand type
	switch (inCusDemandType)
	{
	case TYPE_CUST_DELIVERY:
		inTripType = TRIP_DELIVERY;
		break;
	case TYPE_CUST_PICKUP:
		inTripType = TRIP_PICKUP;
		break;
	case TYPE_CUST_C2C:
		inTripType = TRIP_C2C;
		break;
	default:
		cout << "\t\t\tWrong_Position_Destroy: Bad CusDemandType" << endl; getchar();
		return false;
	}

	inNodeIdxSz = 0;
	// Calculate the D(z,i) of all inCusDemandType demands
   for (int i = 1; i <= numVeh; i++)
   {
	   for (int j = 1; j <= seg[i].numTrips; j++)
	   {
		   if (seg[i].Trip[j].Type != inTripType) continue;
		   // Rebuild path	
		   int curC = seg[i].Trip[j].firstCus;
			while (curC > 0)
			{
				if (NODE_C2C_DELIVERY != Get_Node_Type(curC))
				{
					inNodeIdxSz++;
					arrNodeIdx[inNodeIdxSz] = curC;
				}
				curC = nextArr[curC];
			}
	   }
   }

#if Q_DEBUG_WRONG_POS_DES
   cout << "\t\t\tCandidate nodes: ";
   for (int i = 1; i <= inNodeIdxSz; i++)
   {
	   cout << arrNodeIdx[i] << " ";
   }
   cout << endl;
#endif
   for (int i = 1; i <= inNodeIdxSz; i++)
   {
	   arrScore[i] = Calc_Score_Neighborhood_Graph(arrNodeIdx[i]);
   }
#if Q_DEBUG_WRONG_POS_DES
   cout << "\t\t\tScored nodes: ";
   for (int i = 1; i <= inNodeIdxSz; i++)
   {
	   cout << arrScore[i] << " ";
   }
   cout << endl;
#endif

   //Remove
   for (int i = 1; i <= inCusDemandNbr; i++)
   {
		int inRemoveNode = Select_Probability_By_Weight((double *)arrScore, inNodeIdxSz, false);
		//if (0 == arrScore[inRemoveNode]) continue;
		inRemoveNode = arrNodeIdx[inRemoveNode];

		inNodeType = Get_Node_Type(inRemoveNode);
		if ((inNodeType == NODE_SUPPLY_POINT) || (inNodeType == NODE_DEPOT) || (inNodeType == NODE_WAITING_STATION))
			continue;
		
	   switch (inNodeType)
	   {
	   case NODE_DELIVERY:
#if Q_DEBUG_WRONG_POS_DES
				cout << "\t\t\t Destroying DELIVERY " << inRemoveNode << "...";
#endif
				if (!routed[inRemoveNode])
				{
#if Q_DEBUG_WRONG_POS_DES
					cout << "NOT ROUTED alreay!" << endl;
#endif
					continue;
				}

				inRetVal = Remove_A_Delivery(inRemoveNode);
				if (-1 == inRetVal)
				{
#if Q_DEBUG_WRONG_POS_DES
					cout << " CANNOT destroy!" << endl;
#endif
					continue;
				}

				if (REMOVE_VEHICLE == inRetVal){
#if Q_DEBUG_WRONG_POS_DES
					cout << " remove vehicle: SKIPPED!" << endl;
#endif
					continue;
					numVeh--; //TODO: remove a vehicle
				} else if (REMOVE_TRIP == inRetVal){
#if Q_DEBUG_WRONG_POS_DES
					cout << " remove trip: SKIPPED!" << endl;
#endif
				} else if (REMOVE_CUSTOMER == inRetVal)
				{
#if Q_DEBUG_WRONG_POS_DES
					cout << " ok!" << endl;
#endif
				} else if (REMOVE_SPE_CUST == inRetVal)
				{
#if Q_DEBUG_WRONG_POS_DES
					cout << " ok!!" << endl;
#endif
				} else
				{
					cout << " Unknown error! *ln" << __LINE__ << endl; getchar();
				}
			   break;

	   case NODE_PICKUP:
#if Q_DEBUG_WRONG_POS_DES
				cout << "\t\t\t Destroying PICKUP " << inRemoveNode << "...";
#endif
				if (!routed[inRemoveNode])
				{
#if Q_DEBUG_WRONG_POS_DES
					cout << "NOT ROUTED alreay!" << endl;
#endif
					continue;
				}

				inRetVal = Remove_A_Pickup(inRemoveNode);

				if (-1 == inRetVal)
				{
#if Q_DEBUG_WRONG_POS_DES
					cout << " CANNOT destroy!" << endl;
#endif
					continue;
				}

				if (REMOVE_VEHICLE == inRetVal){
#if Q_DEBUG_WRONG_POS_DES
					cout << " remove VEHICLE: SKIPPED!" << endl; 
#endif
					continue;
					numVeh--; //TODO: remove a vehicle
				} else if (REMOVE_TRIP == inRetVal){
#if Q_DEBUG_WRONG_POS_DES
					cout << " remove TRIP: SKIPPED!" << endl;
#endif
				} else if (REMOVE_CUSTOMER == inRetVal)
				{
#if Q_DEBUG_WRONG_POS_DES
					cout << " ok!" << endl;
#endif
				} else if (REMOVE_SPE_CUST == inRetVal)
				{
#if Q_DEBUG_WRONG_POS_DES
					cout << " ok!!" << endl;
#endif
				} else
				{
					cout << " Unknown error! *ln" << __LINE__ << endl; getchar();
				}
			   break;

	   case NODE_C2C_DELIVERY:
	   case NODE_C2C_PICKUP:
			   if (NODE_C2C_DELIVERY == Get_Node_Type(inRemoveNode))
			   {
				   inC2CPickupRnd = inRemoveNode-nOrder;
			   } else
			   {
				   inC2CPickupRnd = inRemoveNode;
			   }
#if Q_DEBUG_WRONG_POS_DES
				cout << "\t\t\t Destroying C2C " << inC2CPickupRnd << "...";
#endif
				if (!routed[inC2CPickupRnd])
				{
#if Q_DEBUG_WRONG_POS_DES
					cout << "NOT ROUTED alreay!" << endl;
#endif
					continue;
				}

				inRetVal = Remove_A_C2C_Pair(inC2CPickupRnd);
				if (-1 == inRetVal)
				{
#if Q_DEBUG_WRONG_POS_DES
					cout << " CANNOT destroy!" << endl;
#endif
					continue;
				}

				if (REMOVE_VEHICLE == inRetVal){
#if Q_DEBUG_WRONG_POS_DES
					cout << " remove a vehicle: SKIPPED!"<< endl;
#endif
					continue;
					numVeh--; // TODO: remove a vehicle
				} else if (REMOVE_TRIP == inRetVal){
#if Q_DEBUG_WRONG_POS_DES
					cout << " remove a trip: SKIPPED!" << endl;
#endif
				} else if (REMOVE_CUSTOMER == inRetVal)
				{
#if Q_DEBUG_WRONG_POS_DES
					cout << " ok!" << endl;
#endif
				} else if (REMOVE_SPE_CUST == inRetVal)
				{
#if Q_DEBUG_WRONG_POS_DES
					cout << " ok!!" << endl;
#endif
				} else
				{
					cout << " Unknown error! *ln" << __LINE__ << endl; getchar();
				}

			   break;
		   default:
			   cout << " Unknown error! *ln" << __LINE__ << endl; getchar();
			   return false;
	   }
   }

	return true;
}

void Solution::Calc_Leg_Utilization()
{
	double dbLegCost;
	int inTotDemands;

	for (int i = 1; i <= numVeh; i++)
	{
		for (int j = 1; j <= seg[i].numTrips; j++)
		{
			dbLegCost = Calc_Leg_Cost(i, j);
			inTotDemands = Get_Total_Demands(i, j);
			if (0 > inTotDemands)
			{
				cout << __LINE__ << endl; getchar();
			}
			seg[i].Trip[j].dbUtilization = dbLegCost/inTotDemands;
		}
	}

#if Q_D_CALC_LEG_UTILIZATION
	for (int i = 1; i <= numVeh; i++)
	{
		for (int j = 1; j <= seg[i].numTrips; j++)
		{
			cout << "Leg " << j << " of vehicle " << i <<  " has utilization: " << seg[i].Trip[j].dbUtilization << endl;
		}
	}
#endif
	
}

int Solution::Get_Total_Demands(int inVehIdx, int inTripIdx)
{
	int inTotalDemands = 0;
	int arrTrip[300];

	//Re-build trip
	int curC = seg[inVehIdx].Trip[inTripIdx].firstCus;
	int inTripSz = 0;
	while (curC > 0)
	{
		inTripSz++;
		arrTrip[inTripSz] = curC;
		curC = nextArr[curC];
	}

#if Q_D_GET_TOT_DEMANDS
	Show_A_Trip(inVehIdx, inTripIdx);
#endif

	for (int i = 1; i <= inTripSz; i++)
	{
		if (problem->node[arrTrip[i]].capacity > 0) // skip c2c-delivery demands
			inTotalDemands += problem->node[arrTrip[i]].capacity;
		
	}

#if Q_D_GET_TOT_DEMANDS
	cout << "Total demands of leg " << inTripIdx << " of vehicle " << inVehIdx << " : " << inTotalDemands << endl;
#endif

	return (inTotalDemands);
}

/*
 * For the delivery leg {s, d_i, di+1, ..., dj}, the cost is equal to
 *		c(s,di) + c (di,di+1) + ... + c(dj-1,dj)
 * For the pickup leg
 * For the c2c leg
 */
double Solution::Calc_Leg_Cost(int inVehIdx, int inTripIdx)
{
	double dbCost = 0;
	int inTripType = seg[inVehIdx].Trip[inTripIdx].Type;
	int arrTrip[300];

	//Re-build trip
	int curC = seg[inVehIdx].Trip[inTripIdx].firstCus;
	int inTripSz = 0;
	while (curC > 0)
	{
		inTripSz++;
		arrTrip[inTripSz] = curC;
		curC = nextArr[curC];
	}
#if Q_D_CALC_LEG_COST
	Show_A_Trip(inVehIdx, inTripIdx);
#endif

	if (inTripSz > 1)
	{
		for (int i=1; i < inTripSz; i++)
		{
			dbCost += problem->c[arrTrip[i]][arrTrip[i+1]];
		}
	}

	if (TRIP_DELIVERY == inTripType)
	{
		dbCost += problem->c[seg[inVehIdx].Trip[inTripIdx].startNodeIdx][arrTrip[1]];
	} else if (TRIP_PICKUP == inTripType)
	{
		dbCost += problem->c[arrTrip[inTripSz]][seg[inVehIdx].Trip[inTripIdx].endNodeIdx];
	} else if (TRIP_C2C == inTripType)
	{
		//Do nothing
	} else
	{
		cout << __LINE__ << endl; getchar();
	}

#if Q_D_CALC_LEG_COST
	cout << "Cost of leg " << inTripIdx << " of vehicle " << inVehIdx << " : " << dbCost << endl;
#endif
	return (dbCost);
}
/*
 * The utilization of a leg is defined as the ratio of the leg's cost over the total demand of the leg
 * n_l legs are removed randomly with probabilities that are inversely proportial to their utilization
 */
bool Solution::Worst_Util_Leg_Destroy()
{
	double arrLegUtilization[500];
	int arrLegIdx[500];
	int inLegCnt = 0;
	int arrVehIdx[500];
	int arrTripIdx[500];
	int inSelectedLegIdx;
	bool arrSelected[500];



	removeTripNbr = 1;
	// Update utilication of legs		
	Calc_Leg_Utilization();

#if Q_D_WORST_COST_LEG_DESTROY
	for (int i = 1; i <= inLegCnt; i++)
	{
		cout << arrLegUtilization[i] << " ";
	}
	cout << endl;
#endif

	for (int i = 1; i <= numVeh; i++)
	{
		for (int j = 1; j <= seg[i].numTrips; j++)
		{
			inLegCnt++;
			arrLegUtilization[inLegCnt] = seg[i].Trip[j].dbUtilization;
			arrVehIdx[inLegCnt] = i;
			arrTripIdx[inLegCnt] = j;
		}
	}

	// Now we got utilization and do sorting  - buble sort
	for (int i = 1; i <= inLegCnt; i++)
	{
		for (int j = i+1; j <= inLegCnt; j++)
		{
			if (arrLegUtilization[i] > arrLegUtilization[j])
			{
				double dbTmp = arrLegUtilization[i];
				arrLegUtilization[i] = arrLegUtilization[j];
				arrLegUtilization[j] = dbTmp;
				
				int inTmp = arrVehIdx[i];
				arrVehIdx[i] = arrVehIdx[j];
				arrVehIdx[j] = inTmp;

				inTmp = arrTripIdx[i];
				arrTripIdx[i] = arrTripIdx[j];
				arrTripIdx[j] = inTmp;
			}
		}
	}
#if Q_D_WORST_COST_LEG_DESTROY
	for (int i = 1; i <= inLegCnt; i++)
	{
		cout << arrLegUtilization[i] << " ";
	}
	cout << endl;
#endif

	memset(arrSelected, false, sizeof(arrSelected));
	for (int loop=g_inN_ll; loop<=g_inN_lu; loop++)
	{
		do
		{
			inSelectedLegIdx = Select_Probability_By_Weight((double *)arrLegUtilization, inLegCnt, false);
		} while (arrSelected[inSelectedLegIdx] == true);
		
		arrSelected[inSelectedLegIdx] = true;
	#if Q_D_WORST_COST_LEG_DESTROY
		cout << "Selected leg of vehicle " << arrVehIdx[inSelectedLegIdx] << " and trip " <<  arrTripIdx[inSelectedLegIdx] << " with utilization " << arrLegUtilization[inSelectedLegIdx] << endl;
	#endif

		//TODO: Remove this leg, if new solution is infeasible , how come we control?
#if 0 //TODO: unit-test
		//arrVehIdx[inSelectedLegIdx] = 7; arrTripIdx[inSelectedLegIdx] = 2; // Deliver trip
		//arrVehIdx[inSelectedLegIdx] = 7; arrTripIdx[inSelectedLegIdx] = 3; // C2C trip
		arrVehIdx[inSelectedLegIdx] = 7; arrTripIdx[inSelectedLegIdx] = 4; // Pickup trip
		
#endif
		memcpy(&removedTrip[removeTripNbr], &seg[arrVehIdx[inSelectedLegIdx]].Trip[arrTripIdx[inSelectedLegIdx]], sizeof(VRPTrip));
		if (true == Remove_A_Leg(arrVehIdx[inSelectedLegIdx], arrTripIdx[inSelectedLegIdx]))
			removeTripNbr++;

	}

#if Q_D_WORST_COST_LEG_DESTROY
	cout << "Removed " << removeTripNbr  <<" leg: " << arrVehIdx[inSelectedLegIdx] << " trip " << arrTripIdx[inSelectedLegIdx]  << endl;
#endif

	if (removeTripNbr > 1)
		return true;

	return false;
}

bool Solution::Time_Related_Leg_Destroy()
{
	int inVehIdx;
	int inTripIdx;
	double arrHammingDis[300];
	int arrVehIdx[300];
	int arrTripIdx[300];
	int inLegCnt = 0;
	double dbDisTot = 0;

	// Select vehicle randomly
	inVehIdx = rand()%(numVeh)+1;
#if Q_D_TIME_RELATED_DES_LEG
	cout << "Selected vehicle " << inVehIdx << endl;
#endif

	// Select trip randomly
	inTripIdx = rand()%(seg[inVehIdx].numTrips)+1;
#if Q_D_TIME_RELATED_DES_LEG
	cout << "Selected trip " << inVehIdx << endl;
#endif

	memset(arrHammingDis, PDS_INFINITY, sizeof(arrHammingDis));
	// Calc. hamming distance of leg
	for (int i = 1; i <= numVeh; i++)
	{
		for (int j = 1; j <= seg[i].numTrips; j++)
		{
			if ((i != inVehIdx) && (j != inTripIdx) && (seg[inVehIdx].Trip[inTripIdx].Type == seg[i].Trip[j].Type))
			{
				double dbDisTmp = Calc_Hamming_Dis_Leg(inVehIdx, inTripIdx, i, j);
				if (dbDisTmp < PDS_INFINITY)
				{
					inLegCnt++;
					arrHammingDis[inLegCnt] = dbDisTmp;
					arrVehIdx[inLegCnt] = i;
					arrTripIdx[inLegCnt] = j;
					dbDisTot += dbDisTmp;

				}
			}
		}
	}
#if Q_D_TIME_RELATED_DES_LEG
	cout << "Hamming distance: " << endl;
	for (int i = 1; i <= inLegCnt; i++)
	{
		cout << arrHammingDis[i] << " ";
	}
	cout << endl;
#endif


	// Reserve
	for (int i = 1; i <= inLegCnt; i++)
	{
		arrHammingDis[i] = dbDisTot - arrHammingDis[i];
	}
#if Q_D_TIME_RELATED_DES_LEG
	cout << "Hamming distance(-1): " << endl;
	for (int i = 1; i <= inLegCnt; i++)
	{
		cout << arrHammingDis[i] << " ";
	}
	cout << endl;
#endif

	//
	removeTripNbr = 1;
	for (int i=g_inN_ll; i<=g_inN_lu; i++)
	//for (int i = 1; i <= 1; i++)
    {
		int inRemoveNode = Select_Probability_By_Weight(arrHammingDis, inLegCnt, false);
		memcpy(&removedTrip[removeTripNbr], &seg[arrVehIdx[inRemoveNode]].Trip[arrTripIdx[inRemoveNode]], sizeof(VRPTrip));
		if (true == Remove_A_Leg(arrVehIdx[inRemoveNode], arrTripIdx[inRemoveNode]))
			removeTripNbr++;
		//if (true == Remove_A_Leg(4, 8))
		//	removeTripNbr++;
		
	}
	
	// TODO: Remove leg -> smaller -> easier to be 
	if (removeTripNbr > 1)
		return true;
	
	return false;
}
/*
 * END OF IMPLEMENTATION OF DESTROY OPERATORS
 */

// Get random type of customer demands: 0 - c2c; 1 - pickup; 2 - delivery
int Solution::Select_Cus_Demand_Type(void) 
{
	int seed;

	seed = rand() % (2*nOrder + nP + nD);

	if (seed <= 2*nOrder)
	{
		return TYPE_CUST_C2C;
	} else if ((seed > 2*nOrder) && (seed <= 2*nOrder + nP))
	{ 
		return TYPE_CUST_PICKUP;
	} else
	{		
		return TYPE_CUST_DELIVERY;
	}
}
/*
 * Acceptance and stopping criteria
 * Idea: same as in the simulated annealing
 * allowing sometimes to accept worse solution to avoid the search becoming 
 * too easily trapped in local optima
 */
bool Solution::Acceptance_Criteria(double dbCurTotalCost, double dbNewTotalCost, double dbTemperature)
{
	double dbGap;
	if (dbNewTotalCost < dbCurTotalCost)
	{
		return true;
	}

	// Select seed randomly in [0, 1]
	double r = ((double)rand() / (double)(RAND_MAX)); //TODO: Debug

	dbGap = dbCurTotalCost - dbNewTotalCost;
	dbGap /= dbTemperature;

	double dbGapTmp = exp(dbGap);
	
	if (r < dbGapTmp)
	//if (r < 0.5) // Fixed
	{
		return true;
	} else 
	{
		return false; // keep the current solution
	}

}

bool Solution::Acceptance_Criteria2(double dbCurTotalCost, double dbNewTotalCost, double dbTemperature)
{
	double dbGap;
	if (dbNewTotalCost < dbCurTotalCost)
	{
		return true;
	}

	// Select seed randomly in [0, 1]
	double r = ((double)rand() / (double)(RAND_MAX)); //TODO: Debug

	dbGap = dbCurTotalCost - dbNewTotalCost;
	dbGap /= dbTemperature;

	double dbGapTmp = exp(dbGap);
	
	if (r < dbTemperature)
	//if (r < 0.5) // Fixed
	{
		return true;
	} else 
	{
		return false; // keep the current solution
	}

}
/*
 * The algorithm stops when either a specified number of ALNS iteration ITmax has passed
 * OR no new best solution has been produced after a given number of iteration ITimpSTOP
 */
bool Solution::Stop_Condition_ALNS(int inSegmentCounter, int inNoNewBestSolCounter)
{
	if (inSegmentCounter > g_inITmax)
	{
#if _DEBUG
		cout << endl << "ITmax hits --> STOP THE ALGORITHM" << endl;
#endif
		return true;
	}

	if (inNoNewBestSolCounter > g_inITimpSTOP)
	{
#if _DEBUG
		cout << endl <<  "ITmipSTOP hits --> STOP THE ALGORITHM" << endl;
#endif
		return true;
	}

	return false;
}
bool Solution::Reset_Time_For_Loaded_Solution()
{
	double dbStartTime = 0;
	bool bRetVal;
	int arrPath[2000];
	int inPathSz;
	double arrBeginIime[2000];
	double dbEnds;
	int inWSId;
	int inVehCap;
	int inNodeType;

#if Q_DEBUG_RESET_TIME_LOADED_SOL
	cout << "Reset time for loaded solution" << endl;
#endif

	for (int i = 1; i <= numVeh; i++)
    {
#if Q_DEBUG_RESET_TIME_LOADED_SOL
		cout << "\t VEHICLE " << i << endl;
#endif
		if (seg[i].Trip[1].startNodeIdx == 0)
		{
			dbStartTime = 0;
		} else {
			dbStartTime = problem->c[0][seg[i].Trip[1].startNodeIdx];
			switch (Get_Node_Type(seg[i].Trip[1].startNodeIdx))
			{
			case NODE_SUPPLY_POINT:
				if (dbStartTime < problem->nodeSP[seg[i].Trip[1].startNodeIdx].sTW1)
					dbStartTime = problem->nodeSP[seg[i].Trip[1].startNodeIdx].sTW1;
				break;
			case NODE_C2C_PICKUP: 
			case NODE_PICKUP:
				if (dbStartTime < problem->node[seg[i].Trip[1].startNodeIdx].sTW)
					dbStartTime = problem->node[seg[i].Trip[1].startNodeIdx].sTW;
				break;
			default:
#if Q_DEBUG_RESET_TIME_LOADED_SOL
		cout << "\t\t Unknown node " << endl; getchar();
#endif
				return false;
			}
		}
	   for (int j = 1; j <= seg[i].numTrips; j++)
	   {		 

#if Q_DEBUG_RESET_TIME_LOADED_SOL
		   cout << "\t\t Trip " << j << endl;
		   switch (seg[i].Trip[j].Type)
		   {
		   case 0:
			   cout << "\t\t\t Type: PICKUP " << endl;
			   break;
		   case 1:
			   cout << "\t\t\t Type: DELIVERY " << endl;
			   break;
		   case 2:
			   cout << "\t\t\t Type: C2C " << endl;
			   break;
		   default:
			   break;
		   }

#endif
		   // Rebuild trip
		   inPathSz = 0;
  			int curC = seg[i].Trip[j].firstCus;
			while (curC > 0)
			{
				inPathSz++;
				arrPath[inPathSz] = curC;
				curC = nextArr[curC];
			}
#if Q_DEBUG_RESET_TIME_LOADED_SOL
			cout << "\t\t Path: " << endl;
			cout << seg[i].Trip[j].startNodeIdx <<"*->";
			for (int loop = 1; loop <= inPathSz; loop++)
			{
				cout << arrPath[loop] << "->";
			}
			cout << seg[i].Trip[j].endNodeIdx << "**";
			cout << endl;
#endif
			//// Move SP - SP in case of PICKUP - DELIVERY
			//if (j > 1) // not first trip
			//{
			//	if ((seg[i].Trip[j].Type == TRIP_DELIVERY) && (seg[i].Trip[j-1].Type == TRIP_PICKUP))
			//	{
			//		if (seg[i].Trip[j].startNodeIdx != seg[i].Trip[j-1].endNodeIdx)
			//		{
			//			dbStartTime += problem->c[seg[i].Trip[j-1].endNodeIdx][seg[i].Trip[j].startNodeIdx];
			//		}
			//	}
			//}



   			if (seg[i].Trip[j].Type == TRIP_DELIVERY)
			{
				dbStartTime += problem->nodeSP[seg[i].Trip[j].startNodeIdx].load;
			}
#if Q_DEBUG_RESET_TIME_LOADED_SOL
			cout << "\t\t Leave time (after unload/load): " << dbStartTime << endl;
#endif
			//if ((i == 13) && (j ==5)) {
			//	cout << "unit test";
			//}
			// Re-set time for trip
		   bRetVal = SetBeginTimeForPath_Q(dbStartTime, seg[i].Trip[j].startNodeIdx,
				arrPath,
				inPathSz,
				arrBeginIime,
				seg[i].Trip[j].endNodeIdx,
				&dbEnds, 
				&inWSId,
				&inVehCap);
			if (true == bRetVal)
			{
				seg[i].Trip[j].waitingS = inWSId;
#if Q_DEBUG_RESET_TIME_LOADED_SOL
				cout << "\t\t End at: " << dbEnds << endl;
#endif
				// Calc. leaveSP			
				seg[i].Trip[j].leaveSP = dbStartTime;
				if (seg[i].Trip[j].Type == TRIP_DELIVERY)
				{
					seg[i].Trip[j].leaveSP = dbStartTime - problem->nodeSP[seg[i].Trip[j].startNodeIdx].load;
				}
				
				//Calc. endS
				seg[i].Trip[j].endS = dbEnds;
				dbStartTime = arrBeginIime[inPathSz];
				if (seg[i].Trip[j].Type == TRIP_PICKUP)
				{
					dbStartTime = dbEnds + problem->nodeSP[seg[i].Trip[j].endNodeIdx].unload;
					seg[i].Trip[j].endS = dbEnds + problem->nodeSP[seg[i].Trip[j].endNodeIdx].unload;
#if Q_DEBUG_RESET_TIME_LOADED_SOL
					cout << "\t\t End of unload at: " << dbStartTime << endl;
#endif

					// p - sp1 - sp2 -d
					if (j < seg[i].numTrips) { // not last trip
						if ((seg[i].Trip[j+1].Type == TRIP_DELIVERY) && (seg[i].Trip[j+1].assSP != seg[i].Trip[j].assSP)) {
							if (seg[i].Trip[j+1].waitingS1 > 0) { // p - sp1 - ws - sp2 - d
								dbStartTime += problem->c[seg[i].Trip[j].endNodeIdx][seg[i].Trip[j+1].waitingS1];
								dbStartTime += problem->c[seg[i].Trip[j+1].waitingS1][seg[i].Trip[j+1].startNodeIdx];
								if (dbStartTime > problem->nodeSP[seg[i].Trip[j+1].startNodeIdx].eTW1){
									cout << "Reset failed at *ln" << __LINE__ << endl; 
									//exit (1);
									getchar(); 
									Show_A_Trip(i, j);
									return false;
								} else if (dbStartTime <  problem->nodeSP[seg[i].Trip[j+1].startNodeIdx].sTW1) {
									dbStartTime = problem->nodeSP[seg[i].Trip[j+1].startNodeIdx].sTW1;
								}
							} else {
								dbStartTime += problem->c[seg[i].Trip[j].endNodeIdx][seg[i].Trip[j+1].startNodeIdx];    // p - sp1 - sp2 -d
								if (Check_TW(seg[i].Trip[j+1].startNodeIdx, dbStartTime, false)) {
									cout << "Reset failed at *ln" << __LINE__ << endl; 
									//exit (1);
									getchar(); 
									Show_A_Trip(i, j);
									return false;
								}
							}
						}
					}

				} else
				{
					if (j < seg[i].numTrips) // not last trip
					{
						if (TRIP_DELIVERY == seg[i].Trip[j+1].Type)
							dbStartTime = dbEnds;
					}
				}

#if Q_DEBUG_RESET_TIME_LOADED_SOL
				Show_A_Trip(i, j);
#endif
			} else
			{
				cout << "Reset failed at *ln" << __LINE__ << endl; 
				//exit (1);
				getchar(); //TODO:
				Show_A_Trip(i, j);
				return false;
			}
		   
			//if ((i == 6) && (j ==2)) {
			//	Show_A_Trip(i, j);
			//	cout << "Unit testing " << endl;
			//}

	   }
	}

	return true;

}
/*
 *
 * 1. The first line contains the following information of the solution:
 *	TotlCostOfSolution TravelCostOfSolution NumberOfVehicles
 * 2. For each vehicle:
 * 2a. The first line contains:
 * NumberOfTrips
 * 2b.Next NumberOfTrips lines contain the following information for each trip:
 * If pickup trip:
 * #Vehicle    #Trip     0     FitnessOfTrip TravelCostOfTrip CapacityOfTrip TimeVehicleLeavesSupplyPoint NumberOfCustomerDemandsInTheTrip  ListOfCustomerDemands_SeparatedbyATab #WaitingStation #SupplyPointWhereVehicleUnloadsDemands
 * If delivery trip:
 * #Vehicle    #Trip     1     FitnessOfTrip TravelCostOfTrip CapacityOfTrip TimeVehicleArrivesAtSupplyPoint NumberOfCustomerDemandsInTheTrip #SupplyPointWhereVehicleLoadsDemands  ListOfCustomerDemands_SeparatedbyATab #WaitingStation
 * If  C2C trip and its next trip is a delivery trip:
 * #Vehicle     #Trip    2     FitnessOfTrip    TravelCostOfTrip TimeVehicleArrivesAtSupplyPointOfItsNextDeliveryTrip    NumberOfCustomerDemandsInTheTrip  ListOfCustomerDemands_SeparatedbyATab    #WaitingStation     #SupplyPointOfItsNextDeliveryTrip
 * If  C2C trip and its next trip is NOT a delivery trip (i.e., its next trip is a pickup trip or this C2C trip is the last trip of the vehicle):
 * #Vehicle     #Trip    2     FitnessOfTrip TravelCostOfTrip TimeVehicleLeavesTheLastCustomerDemandInTheTrip NumberOfCustomerDemandsInTheTrip  ListOfCustomerDemands_SeparatedbyATab    -1        -1
 */
void Solution::showSolutionNewFormat(char *szTestIdx, char *szTestOffset, bool bOpt)
{
   int i,j,curC;
   double dbStartTime;
   int arrSol[2000];
   int inSolNode;

   ofstream infile;

   char szFileName[100];
   

   strcpy(szFileName, "sol");
   strcat(szFileName, szTestIdx); 
   strcat(szFileName, "_"); 
   strcat(szFileName, szTestOffset);
   if (bOpt)
   {
	   strcat(szFileName, ".besopt");
   } else
		strcat(szFileName, ".besstd");

    infile.open(szFileName,ios::out); 
     if (!infile){	 
		 cout << "\n\tInput file not found !!!!!!" << endl; 		
		 exit(-1);
	 }

	 //TotlCostOfSolution TravelCostOfSolution NumberOfVehicles
	 if (!strcmp(szTestIdx, "99")) {
		 infile << g_dbBestTotalCost << "\t" << (g_dbBestTotalCost-problem->g_inFixedCost*numVeh) << "\t" << numVeh << "\t" << numVeh <<endl;	
	 } else
		infile << g_dbBestTotalCost << "\t" << (g_dbBestTotalCost-problem->g_inFixedCost*numVeh) << "\t" << numVeh <<endl;	
   
   for (i = 1; i <= numVeh; i++) // to consildation, we do not use 0 index.
   {
	   // 2a. The first line contains: NumberOfTrips
       infile << seg[i].numTrips << endl;	   

	   for (j = 1; j <= seg[i].numTrips; j++)
	   {
		    /* If delivery trip:
			 * #Vehicle    #Trip     1     FitnessOfTrip TravelCostOfTrip CapacityOfTrip TimeVehicleArrivesAtSupplyPoint NumberOfCustomerDemandsInTheTrip \\
			 *						#SupplyPointWhereVehicleLoadsDemands  ListOfCustomerDemands_SeparatedbyATab #WaitingStation
			 *
			 */
		   if (TRIP_DELIVERY == seg[i].Trip[j].Type)
		   {
			   infile << i-1 << "   " << j-1 << "   " << 1 << "\t";								// #Vehicle    #Trip     1 
			   infile << (seg[i].Trip[j].cost) << "\t" << seg[i].Trip[j].cost << " \t ";  // FitnessOfTrip TravelCostOfTrip
			   infile << seg[i].Trip[j].capacity << "\t";									// CapacityOfTrip
			   infile << (seg[i].Trip[j].leaveSP + problem->nodeSP[seg[i].Trip[j].startNodeIdx].load) << "\t";									// TimeVehicleArrivesAtSupplyPoint
			   infile << seg[i].Trip[j].numCus << "\t";									    // NumberOfCustomerDemandsInTheTrip
			   infile << seg[i].Trip[j].startNodeIdx << "\t";								// #SupplyPointWhereVehicleLoadsDemands
			   // ListOfCustomerDemands_SeparatedbyATab
			   curC = seg[i].Trip[j].firstCus;			 
			   while (curC > 0)
			   {
					infile << curC << "\t";													
				    curC = nextArr[curC];
			   }
			   infile << seg[i].Trip[j].waitingS << endl;

			   //infile << "\t\t\t Arrived at: " << seg[i].Trip[j].arriveSP << endl;
			   //infile << "\t\t\t Leave at: " << seg[i].Trip[j].leaveSP << endl;
			   //infile << "\t\t\t Delivery Nbr: " << seg[i].Trip[j].numCus << endl;
			   //infile << "\t\t\t Assigned SP: " << seg[i].Trip[j].assSP << endl;
			   //infile << "\t\t\t Started from SP: " << seg[i].Trip[j].startNodeIdx << "(" << seg[i].Trip[j].leaveSP << ")" << endl;
			   //infile << "\t\t\t End at: " << seg[i].Trip[j].endNodeIdx << endl;
			   //infile << "\t\t\t Waiting station: " << seg[i].Trip[j].waitingS << endl;
			   //infile << "\t\t\t EndS: " << seg[i].Trip[j].endS << endl;

			   //curC = seg[i].Trip[j].firstCus;
			   //int preNode = seg[i].Trip[j].startNodeIdx;
			   //double db_TimePoint = seg[i].Trip[j].leaveSP + problem->nodeSP[seg[i].Trip[j].startNodeIdx].load;
			   ////infile << seg[i].Trip[j].startNodeIdx << "(" << seg[i].Trip[j].leaveSP << "|" << db_TimePoint  <<") -> ";
			   //while (curC > 0)
			   //{
				  // db_TimePoint += problem->c[preNode][curC];
				  // if (db_TimePoint < problem->node[curC].sTW)  db_TimePoint = problem->node[curC].sTW;
				  // //infile << curC << "(" << db_TimePoint << "|" << (db_TimePoint+problem->node[curC].duration) << ")" << "->";
				  // preNode = curC;
				  // db_TimePoint += problem->node[curC].duration;
				
				  // curC = nextArr[curC];
			   //}

			   //if (seg[i].Trip[j].waitingS > 0)
			   //{
				  // db_TimePoint += problem->c[seg[i].Trip[j].lastCus][seg[i].Trip[j].waitingS];
				  // //infile << seg[i].Trip[j].waitingS << "*" << "(" << db_TimePoint << "|" << (seg[i].Trip[j].endS - problem->c[seg[i].Trip[j].waitingS][seg[i].Trip[j].endNodeIdx]) << ") ->";
			   //}

			   //infile << seg[i].Trip[j].endNodeIdx << "(" << seg[i].Trip[j].endS << ")" << endl;
			   
			   //infile << endl << endl;

		   }
		   else if (TRIP_C2C == seg[i].Trip[j].Type)
		   {
			   if ((j < seg[i].numTrips) && (seg[i].Trip[j+1].Type == TRIP_DELIVERY))
			   {
				   //#Vehicle     #Trip    2     FitnessOfTrip    TravelCostOfTrip TimeVehicleArrivesAtSupplyPointOfItsNextDeliveryTrip    
				   //NumberOfCustomerDemandsInTheTrip  ListOfCustomerDemands_SeparatedbyATab    #WaitingStation     #SupplyPointOfItsNextDeliveryTrip
				   infile << i-1 << "   " << j-1 << "   " << 2 << "\t";								// #Vehicle    #Trip     1 
				   infile << (seg[i].Trip[j].cost) << "\t" << seg[i].Trip[j].cost << " \t ";  // FitnessOfTrip TravelCostOfTrip
				   infile << seg[i].Trip[j+1].leaveSP << "\t";									//TimeVehicleArrivesAtSupplyPointOfItsNextDeliveryTrip					  
				   infile << seg[i].Trip[j].numCus << "\t";									    // NumberOfCustomerDemandsInTheTrip
				   // ListOfCustomerDemands_SeparatedbyATab
				   curC = seg[i].Trip[j].firstCus;			 
				   while (curC > 0)
				   {
						infile << curC << "\t";													
						curC = nextArr[curC];
				   }
			   
				   infile << seg[i].Trip[j].waitingS << "\t";
				   infile << seg[i].Trip[j+1].startNodeIdx << endl;

			   } else 
			   {
					 /* If  C2C trip and its next trip is NOT a delivery trip (i.e., its next trip is a pickup trip or this C2C trip is the last trip of the vehicle):
					 * #Vehicle     #Trip    2     FitnessOfTrip TravelCostOfTrip TimeVehicleLeavesTheLastCustomerDemandInTheTrip NumberOfCustomerDemandsInTheTrip  ListOfCustomerDemands_SeparatedbyATab    -1        -1
					 */
				   infile << i-1 << "   " << j-1 << "   " << 2 << "\t";								// #Vehicle    #Trip     1 
				   infile << (seg[i].Trip[j].cost) << "\t" << seg[i].Trip[j].cost << " \t ";  // FitnessOfTrip TravelCostOfTrip
				   //TimeVehicleLeavesTheLastCustomerDemandInTheTrip
				   curC = seg[i].Trip[j].firstCus;
				   int preNode = seg[i].Trip[j].startNodeIdx;
				   double db_TimePoint = seg[i].Trip[j].leaveSP;
				   while (curC > 0)
				   {
					   db_TimePoint += problem->c[preNode][curC];
					   if (db_TimePoint < problem->node[curC].sTW)  db_TimePoint = problem->node[curC].sTW;
					   //infile << curC << "(" << db_TimePoint << "|" << (db_TimePoint+problem->node[curC].duration) << ")" << "->";
					   preNode = curC;
					   db_TimePoint += problem->node[curC].duration;
				
					   curC = nextArr[curC];
				   }
				   infile << db_TimePoint << "\t";
			  
				   infile << seg[i].Trip[j].numCus << "\t";									    // NumberOfCustomerDemandsInTheTrip
				   // ListOfCustomerDemands_SeparatedbyATab
				   curC = seg[i].Trip[j].firstCus;			 
				   while (curC > 0)
				   {
						infile << curC << "\t";													
						curC = nextArr[curC];
				   }
			   
				   infile << "-1\t-1" << endl;
			   }
			   //infile << "\t\t\t Type: C2C" << endl;
			   ////infile << "\t\t\t Fitness: " << seg[i].Trip[j].fitness << endl;
			   //infile << "\t\t\t Cost: " << seg[i].Trip[j].cost << endl;
			   //infile << "\t\t\t Capacity: " << seg[i].Trip[j].capacity << endl;
			   //infile << "\t\t\t Arrived at: " << seg[i].Trip[j].arriveSP << endl;
			   //infile << "\t\t\t Leave at: " << seg[i].Trip[j].leaveSP << endl;
			   //infile << "\t\t\t Delivery Nbr: " << seg[i].Trip[j].numCus << endl;
			   //infile << "\t\t\t Assigned SP: " << seg[i].Trip[j].assSP << endl;
			   //infile << "\t\t\t Started from: " << seg[i].Trip[j].startNodeIdx << endl;
			   //infile << "\t\t\t End at: " << seg[i].Trip[j].endNodeIdx << endl;
			   //infile << "\t\t\t Waiting station: " << seg[i].Trip[j].waitingS << endl;
			   //infile << "\t\t\t EndS: " << seg[i].Trip[j].endS << endl;

			   //infile << "\t\t\t ROUTED: ";
			 
			   //curC = seg[i].Trip[j].firstCus;
			   //int preNode = seg[i].Trip[j].startNodeIdx;
			   //double db_TimePoint = seg[i].Trip[j].leaveSP;

			   //infile << seg[i].Trip[j].startNodeIdx << "(" << db_TimePoint << ") -> ";

			   //while (curC > 0)
			   //{
				  // db_TimePoint += problem->c[preNode][curC];
				  // if (db_TimePoint < problem->node[curC].sTW)  db_TimePoint = problem->node[curC].sTW;
				  // infile << curC << "(" << db_TimePoint << "|" << (db_TimePoint+problem->node[curC].duration) << ")" << "->";
				  // preNode = curC;
				  // db_TimePoint += problem->node[curC].duration;
				
				  // curC = nextArr[curC];
			   //}

			   //if (seg[i].Trip[j].waitingS > 0)
			   //{
				  // db_TimePoint += problem->c[seg[i].Trip[j].lastCus][seg[i].Trip[j].waitingS];
				  // infile << seg[i].Trip[j].waitingS << "*" << "(" << db_TimePoint << "|" << (seg[i].Trip[j].endS - problem->c[seg[i].Trip[j].waitingS][seg[i].Trip[j].endNodeIdx]) << ") ->";
			   //}

			   //infile << seg[i].Trip[j].endNodeIdx << "(" << seg[i].Trip[j].endS << ")" << endl;
			   //
			   //infile << endl << endl;
		   }
		   else if (TRIP_PICKUP == seg[i].Trip[j].Type)
		   {
				 /* If pickup trip:
				 * #Vehicle    #Trip     0     FitnessOfTrip TravelCostOfTrip CapacityOfTrip TimeVehicleLeavesSupplyPoint NumberOfCustomerDemandsInTheTrip  
				 *								ListOfCustomerDemands_SeparatedbyATab #WaitingStation #SupplyPointWhereVehicleUnloadsDemands
				 */
			   infile << i-1 << "   " << j-1 << "   " << 0 << "\t";								// #Vehicle    #Trip     1 
			   infile << (seg[i].Trip[j].cost) << "\t" << seg[i].Trip[j].cost << " \t ";  // FitnessOfTrip TravelCostOfTrip
			   infile << seg[i].Trip[j].capacity << "\t";									// CapacityOfTrip
			   infile << seg[i].Trip[j].endS << "\t";									// TimeVehicleArrivesAtSupplyPoint
			   infile << seg[i].Trip[j].numCus << "\t";									    // NumberOfCustomerDemandsInTheTrip
			   // ListOfCustomerDemands_SeparatedbyATab
			   curC = seg[i].Trip[j].firstCus;			 
			   while (curC > 0)
			   {
					infile << curC << "\t";													
				    curC = nextArr[curC];
			   }
			   infile << seg[i].Trip[j].waitingS << "\t";
			   infile << seg[i].Trip[j].endNodeIdx << endl;								// #SupplyPointWhereVehicleUnloadsDemands

			   //infile << "\t\t\t Type: PICKUP" << endl;
			   ////infile << "\t\t\t Fitness: " << seg[i].Trip[j].fitness << endl;
			   //infile << "\t\t\t Cost: " << seg[i].Trip[j].cost << endl;
			   //infile << "\t\t\t Capacity: " << seg[i].Trip[j].capacity << endl;
			   //infile << "\t\t\t Arrived at: " << seg[i].Trip[j].arriveSP << endl;
			   //infile << "\t\t\t Leave at: " << seg[i].Trip[j].leaveSP << endl;
			   //infile << "\t\t\t Delivery Nbr: " << seg[i].Trip[j].numCus << endl;
			   //infile << "\t\t\t Assigned SP: " << seg[i].Trip[j].assSP << endl;
			   //infile << "\t\t\t Started from: " << seg[i].Trip[j].startNodeIdx << endl;
			   //infile << "\t\t\t End at SP: " << seg[i].Trip[j].endNodeIdx << endl;
			   //infile << "\t\t\t Waiting station: " << seg[i].Trip[j].waitingS << endl;
			   //infile << "\t\t\t EndS: " << seg[i].Trip[j].endS << endl;

			   //infile << "\t\t\t ROUTED: ";
			   //curC = seg[i].Trip[j].firstCus;
			   //int preNode = seg[i].Trip[j].startNodeIdx;
			   //double db_TimePoint = seg[i].Trip[j].leaveSP;
			   //
			   //infile << seg[i].Trip[j].startNodeIdx << "(" << db_TimePoint << ") -> ";
			   //while (curC > 0)
			   //{
				  // db_TimePoint += problem->c[preNode][curC];
				  // if (db_TimePoint < problem->node[curC].sTW)  db_TimePoint = problem->node[curC].sTW;
				  // infile << curC << "(" << db_TimePoint << "|" << (db_TimePoint+problem->node[curC].duration) << ")" << "->";
				  // preNode = curC;
				  // db_TimePoint += problem->node[curC].duration;

				  // curC = nextArr[curC];
			   //}
			   //if (seg[i].Trip[j].waitingS > 0)
			   //{
				  // db_TimePoint += problem->c[seg[i].Trip[j].lastCus][seg[i].Trip[j].waitingS];
				  // infile << seg[i].Trip[j].waitingS << "*" << "(" << db_TimePoint << "|" << (seg[i].Trip[j].endS - problem->nodeSP[seg[i].Trip[j].endNodeIdx].unload - problem->c[seg[i].Trip[j].waitingS][seg[i].Trip[j].endNodeIdx]) << ") ->";
			   //}
			   //infile << seg[i].Trip[j].endNodeIdx << "(" << (seg[i].Trip[j].endS - problem->nodeSP[seg[i].Trip[j].endNodeIdx].unload) << "|" << seg[i].Trip[j].endS << ")" << endl << endl;			   
			   //infile << endl << endl;
		   }
	   }
   }
#if _DEBUG
   //cout << "ok!" << endl;
#endif
}

bool Solution::Save_Best_As_StdFormat(double dbCost, char *szTestIdx, char *szTestOffset)
{
   int i,j,curC;
   ofstream infile;
   char szFileName[100];

   //Check_Solution(&dbCost);

    strcpy(szFileName, "sol");
   strcat(szFileName, szTestIdx); 
   strcat(szFileName, "_"); 
   strcat(szFileName, szTestOffset);
   strcat(szFileName, ".besStd");

   //strcpy(szFileName2, "sol");
   //strcat(szFileName2, szTestIdx);
   //strcat(szFileName2, ".txt");

    infile.open(szFileName,ios::out); 
    if (!infile){	 
		 cout << "\n\tInput file not found !!!!!!" << endl; 		
		 exit(-1);
	}

   infile<<dbCost<<"   "<<dbCost<<"   "<<numVeh<<"	"<<numVeh<<endl;
   for (i=1;i<=numVeh;i++)
   {
       infile<<seg[i].numTrips<<endl;
	   for (j=1;j<=seg[i].numTrips;j++)
	   {
		   if (seg[i].Trip[j].Type == 1)
		   {
			   infile<<i<<"   "<<j<<"   1\t"<<seg[i].Trip[j].fitness<<" \t "<<seg[i].Trip[j].cost<<" \t "<<seg[i].Trip[j].capacity<<" \t "<<seg[i].Trip[j].leaveSP<<" \t "<<seg[i].Trip[j].numCus<<" \t";
			   infile<<seg[i].Trip[j].assSP<<"\t";
			   curC = seg[i].Trip[j].firstCus;
			   while (curC > 0)
			   {
				   infile<<curC<<"\t";
				   curC = nextArr[curC];
			   }
			   infile<<seg[i].Trip[j].waitingS<<endl;
		   }
		   else if (seg[i].Trip[j].Type == 0)
		   {
			   infile<<i<<"   "<<j<<"   0\t"<<seg[i].Trip[j].fitness<<" \t "<<seg[i].Trip[j].cost<<" \t "<<seg[i].Trip[j].capacity<<" \t "<<seg[i].Trip[j].leaveSP<<" \t "<<seg[i].Trip[j].numCus<<" \t";
			   curC = seg[i].Trip[j].firstCus;
			   
			   while (curC > 0)
			   {
				   infile<<curC<<"\t";
				   if (curC > endidP)
			     	   infile<<"ERROR: idCusP = "<<curC<<" exceed limit = "<<endidP<<endl;
			   	   curC = nextArr[curC];
			   }
			   infile<<seg[i].Trip[j].waitingS<<"\t ";
			   infile<<seg[i].Trip[j].assSP<<endl;
		   }
		   else
		   {
			   int nextT = j + 1;
			   if (nextT <= seg[i].numTrips)
			   {
				   if (seg[i].Trip[nextT].Type == TRIP_DELIVERY) 
				   {
					   infile<<i<<"   "<<j<<"   2\t"<<seg[i].Trip[j].fitness<<" \t "<<seg[i].Trip[j].cost<<" \t "<<seg[i].Trip[j].arriveSP<<" \t "<<seg[i].Trip[j].numCus<<" \t";
					   curC = seg[i].Trip[j].firstCus;
					   while (curC > 0)
					   {
						   infile<<curC<<"\t";
						   curC = nextArr[curC];
					   }
					   infile<<seg[i].Trip[j].waitingS<<"\t";
					   infile<<seg[i].Trip[nextT].assSP<<endl;
				   }
				   else
				   {
					   infile<<i<<"   "<<j<<"   2\t"<<seg[i].Trip[j].fitness<<" \t "<<seg[i].Trip[j].cost<<" \t "<<seg[i].Trip[j].endS<<" \t "<<seg[i].Trip[j].numCus<<" \t";
					   curC = seg[i].Trip[j].firstCus;
					   while (curC > 0)
					   {
						   infile<<curC<<"\t";
						   curC = nextArr[curC];
					   }
					   infile<<seg[i].Trip[j].waitingS<<"\t -1"<<endl;
				   }
			   }
			   else
			   {
				   infile<<i<<"   "<<j<<"   2\t"<<seg[i].Trip[j].fitness<<" \t "<<seg[i].Trip[j].cost<<" \t "<<seg[i].Trip[j].endS<<" \t "<<seg[i].Trip[j].numCus<<" \t";
				   //infile<<seg[i].Trip[j].assSP<<"\t";
				   curC = seg[i].Trip[j].firstCus;
				   while (curC > 0)
				   {
					   infile<<curC<<"\t";
					   curC = nextArr[curC];
				   }
				   infile<<seg[i].Trip[j].waitingS<<"\t -1"<<endl;
			   }
		   }
	   }
   }
   //infile<<fitness<<"   "<<cost<<"   "<<numVehUsed<<endl;
}

bool Solution::Export_Loaded_Solution(char *szFileName)
{
   int i,j,curC;
   ofstream infile;


   infile.open(szFileName, ios::out); 
     if (!infile){	 
		 cout << "\n\tInput file not found !!!!!!" << endl; 		
		 exit(-1);
	 }

   infile<<fitness<<"   "<<cost<<"   "<<numVehUsed<<"	"<<numVeh<<endl;
   for (i=1;i<=numVeh;i++)
   {
       infile<<seg[i].numTrips<<endl;
	   for (j=1;j<=seg[i].numTrips;j++)
	   {
		   if (seg[i].Trip[j].Type == 1)
		   {
			   infile<<i<<"   "<<j<<"   1\t"<<seg[i].Trip[j].fitness<<" \t "<<seg[i].Trip[j].cost<<" \t "<<seg[i].Trip[j].capacity<<" \t "<<seg[i].Trip[j].leaveSP<<" \t "<<seg[i].Trip[j].numCus<<" \t";
			   infile<<seg[i].Trip[j].assSP<<"\t";
			   curC = seg[i].Trip[j].firstCus;
			   while (curC > 0)
			   {
				   infile<<curC<<"\t";
				   curC = nextArr[curC];
			   }
			   infile<<seg[i].Trip[j].waitingS<<endl;
		   }
		   else if (seg[i].Trip[j].Type == 0)
		   {
			   infile<<i<<"   "<<j<<"   0\t"<<seg[i].Trip[j].fitness<<" \t "<<seg[i].Trip[j].cost<<" \t "<<seg[i].Trip[j].capacity<<" \t "<<seg[i].Trip[j].leaveSP<<" \t "<<seg[i].Trip[j].numCus<<" \t";
			   curC = seg[i].Trip[j].firstCus;
			   
			   while (curC > 0)
			   {
				   infile<<curC<<"\t";
				   if (curC > endidP)
			     	   infile<<"ERROR: idCusP = "<<curC<<" exceed limit = "<<endidP<<endl;
			   	   curC = nextArr[curC];
			   }
			   infile<<seg[i].Trip[j].waitingS<<"\t ";
			   infile<<seg[i].Trip[j].assSP<<endl;
		   }
		   else
		   {
			   int nextT = j + 1;
			   if (nextT <= seg[i].numTrips)
			   {
				   if (seg[i].Trip[nextT].Type == TRIP_DELIVERY) 
				   {
					   infile<<i<<"   "<<j<<"   2\t"<<seg[i].Trip[j].fitness<<" \t "<<seg[i].Trip[j].cost<<" \t "<<seg[i].Trip[j].arriveSP<<" \t "<<seg[i].Trip[j].numCus<<" \t";
					   curC = seg[i].Trip[j].firstCus;
					   while (curC > 0)
					   {
						   infile<<curC<<"\t";
						   curC = nextArr[curC];
					   }
					   infile<<seg[i].Trip[j].waitingS<<"\t";
					   infile<<seg[i].Trip[nextT].assSP<<endl;
				   }
				   else
				   {
					   infile<<i<<"   "<<j<<"   2\t"<<seg[i].Trip[j].fitness<<" \t "<<seg[i].Trip[j].cost<<" \t "<<seg[i].Trip[j].endS<<" \t "<<seg[i].Trip[j].numCus<<" \t";
					   curC = seg[i].Trip[j].firstCus;
					   while (curC > 0)
					   {
						   infile<<curC<<"\t";
						   curC = nextArr[curC];
					   }
					   infile<<seg[i].Trip[j].waitingS<<"\t -1"<<endl;
				   }
			   }
			   else
			   {
				   infile<<i<<"   "<<j<<"   2\t"<<seg[i].Trip[j].fitness<<" \t "<<seg[i].Trip[j].cost<<" \t "<<seg[i].Trip[j].endS<<" \t "<<seg[i].Trip[j].numCus<<" \t";
				   //infile<<seg[i].Trip[j].assSP<<"\t";
				   curC = seg[i].Trip[j].firstCus;
				   while (curC > 0)
				   {
					   infile<<curC<<"\t";
					   curC = nextArr[curC];
				   }
				   infile<<seg[i].Trip[j].waitingS<<"\t -1"<<endl;
			   }
		   }
	   }
   }
   //infile<<fitness<<"   "<<cost<<"   "<<numVehUsed<<endl;
}
// Read a solution from file
bool Solution::Load_A_Solution(char *szFileName)
{
   ifstream infile;
   int i,j,curC;
   //double dbFitness, dbCost;
   //int inNumVehUsed, inNumVeh;
   int inVehIdx, inTripIdx;
   int inTemp;
   int inLastStartNodeIdx, inLastEndNodeIdx;
   double dbVehCost;

   inLastStartNodeIdx = 0; // Depot
   inLastEndNodeIdx = 0; // Depot
   infile.open(szFileName,ios::in); 
	if (!infile){	 
		cout << "\n\tSolution file not found !!!!!!" << endl; getchar();
		exit(-1);
	}

#if Q_DEBUG_CALC_WS_ASSIGN
	for (int i = problem->startidC2C; i <= 2*nOrder+nP+nD; i++)
	{
		switch (Get_Node_Type(i))
		{
		case NODE_C2C_PICKUP:
			cout << "C2C-PICKUP ";
			break;
		case NODE_C2C_DELIVERY:
			cout << "C2C-DELIVERY ";
			break;
		case NODE_PICKUP:
			cout << "PICKUP ";
			break;
		case NODE_DELIVERY:
			cout << "DELIVERY ";
		break;
		default:
			cout << "Unknown node *ln" << __LINE__ << endl; getchar();
			break;
		}
	
		int inCntTmp = 0;
		for (int j = 1; j <= nSP; j++)
		{
			cout << "\t" << i << "->" << j << ": " << problem->CWSSP[i][j] << endl;
			if (-1 == problem->CWSSP[i][j])
				inCntTmp++;
		}
		if (inCntTmp == nSP)
		{
			int quangnn = 0;
		}
	}
#endif
#if Q_DEBUG_LOAD_SOL
	cout << ">>>LOAD INIT. SOLUTION" << endl;
#endif


	infile >> fitness >> cost >> numVeh >> numVehUsed;
#if Q_DEBUG_LOAD_SOL
	cout << "Fitness: " << fitness << endl;
	cout << "Total cost: " << cost << endl;
	cout << "Total vehicles: " << numVehUsed << endl;
   cout << "Init. vehicles: " << numVeh << endl << endl;
#endif
   //numVeh = inNumVeh;
   for (i = 1; i <= numVeh;i++)
   {
       infile >> seg[i].numTrips;
#if Q_DEBUG_LOAD_SOL
	   cout << "VEHICLE " << i << " has " << seg[i].numTrips << " trips" << endl;
#endif
	   dbVehCost = 0;
	   for (j = 1; j <= seg[i].numTrips; j++)
	   {
		  // if ((i == 13) && (j ==4)) {
				//cout << "unit test" <<endl ;
		  // }
		   
		   seg[i].Trip[j].arriveSP = 0;
		   seg[i].Trip[j].leaveSP = 0;
		   seg[i].Trip[j].endS = 0;
#if Q_DEBUG_LOAD_SOL
		   cout << "\t TRIP " << j << endl;
#endif
		   if (j == seg[i].numTrips)
			   seg[i].Trip[j].endNodeIdx = 0; // last trip back to depot
		   //#Vehicle    #Trip     1     FitnessOfTrip TravelCostOfTrip CapacityOfTrip TimeVehicleArrivesAtSupplyPoint NumberOfCustomerDemandsInTheTrip
		   infile >> inVehIdx >> inTripIdx >> seg[i].Trip[j].Type >> seg[i].Trip[j].fitness >> seg[i].Trip[j].cost; 
		   if (TRIP_C2C != seg[i].Trip[j].Type)
		   {
			   infile >> seg[i].Trip[j].capacity >> seg[i].Trip[j].leaveSP >> seg[i].Trip[j].numCus;
		   } else
		   {
			   infile >> seg[i].Trip[j].endS >> seg[i].Trip[j].numCus;
		   }
		   dbVehCost += seg[i].Trip[j].cost;
		   
#if Q_DEBUG_LOAD_SOL
		   switch (seg[i].Trip[j].Type)
		   {
		   case 0:
			   cout << "\t\t Type: PICKUP " << endl;
			   break;
		   case 1:
			   cout << "\t\t Type: DELIVERY " << endl;
			   break;
		   case 2:
			   cout << "\t\t Type: C2C " << endl;
			   break;
		   default:
			   break;
		   }
		   cout << "\t\t Cost: " << seg[i].Trip[j].cost << endl;
		   cout << "\t\t Capacity: " << seg[i].Trip[j].capacity << endl;
		   cout << "\t\t leaveSP: " << seg[i].Trip[j].leaveSP << endl;
#endif
		   if (seg[i].Trip[j].Type == TRIP_DELIVERY)		//1-delivery
		   {
			   // #SupplyPointWhereVehicleLoadsDemands  ListOfCustomerDemands_SeparatedbyATab #WaitingStation
			   infile >> seg[i].Trip[j].assSP;

			   infile >> seg[i].Trip[j].firstCus;
			   curC = seg[i].Trip[j].firstCus;
			   for (int loop = 2; loop <= seg[i].Trip[j].numCus; loop++)
			   {
				   infile >> nextArr[curC];
				   curC = nextArr[curC];
			   }
			   seg[i].Trip[j].lastCus = curC;
			   nextArr[curC] = 0;

			   seg[i].Trip[j].waitingS1 = -1;
			   if (j>1) { // not first trip
				   if ((seg[i].Trip[j-1].Type == TRIP_PICKUP) && (seg[i].Trip[j-1].assSP != seg[i].Trip[j].assSP)) { // p-sp1 - sp2-d
						seg[i].Trip[j].waitingS1 = problem->CWSSP[seg[i].Trip[j-1].assSP][seg[i].Trip[j].assSP];
				   }
			   } 
				infile >> seg[i].Trip[j].waitingS;
			   
			  //StartNodeIdx for current trip
			   seg[i].Trip[j].startNodeIdx = seg[i].Trip[j].assSP;
			  //EndNodeIdx for last trip
			   if (j > 1)
			   {
				   if (seg[i].Trip[j-1].Type == TRIP_PICKUP)
				   {
					   seg[i].Trip[j-1].endNodeIdx = seg[i].Trip[j-1].assSP;
				   }
				   else
				   {
					   seg[i].Trip[j-1].endNodeIdx = seg[i].Trip[j].assSP;
				   }
			   } 

#if Q_DEBUG_LOAD_SOL
			   cout << "\t\t Path: " << endl;
			   cout << seg[i].Trip[j].startNodeIdx <<"->";
			   curC = seg[i].Trip[j].firstCus;			   
			   while (curC > 0)
			   {
				   cout<<curC<<"->";
			   	   curC = nextArr[curC];
			   }
			   if (-1 != seg[i].Trip[j].waitingS)
			   {
				   cout << "(" << seg[i].Trip[j].waitingS << ")->";
			   }
			   cout << endl;
#endif
		   } else if (seg[i].Trip[j].Type == TRIP_PICKUP) // 0 -pickup
		   {
			   //ListOfCustomerDemands_SeparatedbyATab #WaitingStation #SupplyPointWhereVehicleUnloadsDemands
			   infile >> seg[i].Trip[j].firstCus;
			   curC = seg[i].Trip[j].firstCus;
			   for (int loop = 2; loop <= seg[i].Trip[j].numCus; loop++)
			   {
				   infile >> nextArr[curC];
				   curC = nextArr[curC];
			   }
			   nextArr[curC] = 0;
			   seg[i].Trip[j].lastCus = curC;

			   infile >> seg[i].Trip[j].waitingS;
			   infile >> seg[i].Trip[j].assSP;
			   
			   //StartNodeIdx for current trip
			   if (j > 1)
			   {
				   if (seg[i].Trip[j-1].Type == TRIP_PICKUP)
				   {
					   seg[i].Trip[j].startNodeIdx = seg[i].Trip[j-1].assSP;
				   }
				   else
				   {
					   seg[i].Trip[j].startNodeIdx = seg[i].Trip[j-1].lastCus;
				   }
			   } else
				   seg[i].Trip[j].startNodeIdx = 0;
			   //EndNodeIdx for last trip
			   if (j > 1)
			   {
				   if (seg[i].Trip[j-1].Type == TRIP_PICKUP)
				   {
					   seg[i].Trip[j-1].endNodeIdx = seg[i].Trip[j-1].assSP;
				   }
				   else
				   {
					   seg[i].Trip[j-1].endNodeIdx = seg[i].Trip[j].firstCus;
				   }
			   }

			   seg[i].Trip[j].endNodeIdx = seg[i].Trip[j].assSP;
#if Q_DEBUG_LOAD_SOL
			   cout << "\t\t Path: " << endl;
			   curC = seg[i].Trip[j].firstCus;			   
			   while (curC > 0)
			   {
				   cout << curC << "->";
			   	   curC = nextArr[curC];
			   }
			   if (-1 != seg[i].Trip[j].waitingS)
			   {
				   cout << "(" << seg[i].Trip[j].waitingS << ")->";
			   }
			   cout << seg[i].Trip[j].endNodeIdx;
			   cout << endl;
#endif
		   } else if (seg[i].Trip[j].Type == TRIP_C2C) // 2-c2c
		   {
			   //ListOfCustomerDemands_SeparatedbyATab    #WaitingStation     #SupplyPointOfItsNextDeliveryTrip
			   infile >> seg[i].Trip[j].firstCus;
			   curC = seg[i].Trip[j].firstCus;
			   for (int loop = 2; loop <= seg[i].Trip[j].numCus; loop++)
			   {
				   infile >> nextArr[curC];
				   curC = nextArr[curC];
			   }
			   nextArr[curC] = 0;
			   seg[i].Trip[j].lastCus = curC;

			   infile >> seg[i].Trip[j].waitingS;
			   infile >> inTemp;

			   //StartNodeIdx for current trip
   			   if (j > 1)
			   {
				   if (seg[i].Trip[j-1].Type == TRIP_PICKUP)
				   {
					   seg[i].Trip[j].startNodeIdx = seg[i].Trip[j-1].assSP;
				   }
				   else
				   {
					   seg[i].Trip[j].startNodeIdx = seg[i].Trip[j-1].lastCus;
				   }
			   } else
				   seg[i].Trip[j].startNodeIdx = 0; // first C2C trip leaved from DEPOT
			   //EndNodeIdx for last trip
   			   if (j > 1)
			   {
				   if (seg[i].Trip[j-1].Type == TRIP_PICKUP)
				   {
					   seg[i].Trip[j-1].endNodeIdx = seg[i].Trip[j-1].assSP;
				   }
				   else
				   {
					   seg[i].Trip[j-1].endNodeIdx = seg[i].Trip[j].firstCus;
				   }
			   }

#if Q_DEBUG_LOAD_SOL
			   cout << "\t\t Path: " << endl;
			   curC = seg[i].Trip[j].firstCus;			   
			   while (curC > 0)
			   {
				   cout<<curC<<"->";
			   	   curC = nextArr[curC];
			   }
			   if (-1 != seg[i].Trip[j].waitingS)
			   {
				   cout << "(" << seg[i].Trip[j].waitingS << ")->";
			   }
			   cout << endl;
#endif

		   }
	   }
#if Q_DEBUG_LOAD_SOL
	   cout << "Veh " << i << " cost: " << dbVehCost << endl;
#endif
   }
#if Q_DEBUG_LOAD_SOL
   	cout << "<<< END OF LOADING INIT. SOLUTION" << endl;
#endif
	for (i = 1; i <= numVeh; i++)
   {
#if Q_DEBUG_LOAD_SOL
	   cout << "VEHICLE " << i << " has " << seg[i].numTrips << " trips" << endl;
#endif
	   for (j = 1; j <= seg[i].numTrips; j++)
	   {
			if (j < seg[i].numTrips)  // Not the last trip
			{
				if ((TRIP_DELIVERY == seg[i].Trip[j+1].Type) && (seg[i].Trip[j].Type == TRIP_C2C))
				{
					seg[i].Trip[j].arriveSP = seg[i].Trip[j].endS;
					seg[i].Trip[j].endS = 0;
					seg[i].Trip[j].assSP = seg[i].Trip[j+1].assSP;
				}
			}

#if Q_DEBUG_LOAD_SOL
		   cout << "\t TRIP " << j << endl;
		   cout << "\t\t Cost: " << seg[i].Trip[j].cost << endl;
		   cout << "\t\t Capacity: " << seg[i].Trip[j].capacity << endl;
#endif
#if Q_DEBUG_LOAD_SOL
		   switch (seg[i].Trip[j].Type)
		   {
		   case 0:
			   cout << "\t\t Type: PICKUP " << endl;
			   cout << "\t\t leaveSP: " << seg[i].Trip[j].leaveSP << endl;
			   break;
		   case 1:
			   cout << "\t\t Type: DELIVERY " << endl;
			   cout << "\t\t leaveSP: " << seg[i].Trip[j].leaveSP << endl;
			   break;
		   case 2:
			   cout << "\t\t Type: C2C " << endl;
	  			if (j < seg[i].numTrips)  // Not the last trip
				{
					if (TRIP_DELIVERY == seg[i].Trip[j+1].Type)
					{
						cout << "\t\t arriveSP: " << seg[i].Trip[j].arriveSP << endl;
					} else
						cout << "\t\t endS: " << seg[i].Trip[j].endS << endl;
				} else
					cout << "\t\t endS: " << seg[i].Trip[j].endS << endl;

			   break;
		   default:
			   break;
		   }
		   
#endif
#if Q_DEBUG_LOAD_SOL
			   cout << "\t\t Path: " << endl;
			   cout << seg[i].Trip[j].startNodeIdx <<"*->";
			   curC = seg[i].Trip[j].firstCus;			   
			   while (curC > 0)
			   {
				   cout<<curC<<"->";
			   	   curC = nextArr[curC];
			   }
			   if (-1 != seg[i].Trip[j].waitingS)
			   {
				   cout << "->(" << seg[i].Trip[j].waitingS << ")->";
			   }
			   cout << seg[i].Trip[j].endNodeIdx << "**";
			   cout << endl;
#endif
	   }
   }

	// Mark all nodes as served
	for (i = problem->startidC2C; i <= endidD; i++) 
	{
		routed[i] = true;		 // Current status of 
	}
}
// START IMPLEMENTATION OF GLOBAL PARAMETERS
void Solution::vdLoadParameters(void)
{
	ifstream infile;

#if Q_DEBUG_LOAD_PARAM
	cout << "vdLoadParameters..." ;
#endif
	 infile.open("..\\C2CDATA\\parameters.txt",ios::in); 
     if (!infile){	 
		 cout << "\n\tInput file not found !!!!!!" << endl; getchar();
		 exit(-1);
	 }
	 else
	 {//got file
		 infile >> g_dbBeta;
		 infile >> g_dbAlpha1 >> g_dbAlpha2 >> g_dbAlpha3 >> g_dbAlpha4;
		 infile >> g_dbPenta >> g_dbPenta_com;
		 infile >> g_inEliteSz;
		 infile >> g_inAlpha;
		 infile >> g_dbN_rl >> g_dbN_ru0;
		 infile >> g_dbN_ru >> g_dbN_rl_com >> g_dbN_ru_com;
		 infile >> g_inITnonImp;
		 infile >> g_inN_ll >> g_inN_lu;
		 infile >> g_dbSigma1 >> g_dbSigma2 >> g_dbSigma3;
		 infile >> g_dbSigma4;
		 infile >> g_inIs_Iterations;
		 infile >> g_dbTheta0;
		 infile >> g_dbTheta_cool;
		 infile >> g_inITmax;
		 infile >> g_inITimpSTOP;
	 }
#if Q_DEBUG_LOAD_PARAM
	 cout << "OK!" << endl;
#endif
}

void Solution::vdDumpParameters(void)
{
	cout << "***START DUMPING PARAMETERS***" << endl;
	cout << "g_dbBeta: " << g_dbBeta <<endl;
	cout << "g_dbAlpha1, g_dbAlpha2, g_dbAlpha3, g_dbAlpha4: " << g_dbAlpha1 << " " << g_dbAlpha2 << " "<< g_dbAlpha3 << " "<< g_dbAlpha4 << endl;
	cout << "g_dbPenta, g_dbPenta_com: " << g_dbPenta << " "<< g_dbPenta_com << endl;
	cout << "g_inEliteSz: " << g_inEliteSz << endl;
	cout << "g_inAlpha: " << g_inAlpha << endl;
	cout << "g_dbN_rl, g_dbN_ru: " << g_dbN_rl << " "<< g_dbN_ru << endl;
	cout << "g_dbN_ru, g_dbN_rl_com, g_dbN_ru_com: " << g_dbN_ru << " "<< g_dbN_rl_com << " "<< g_dbN_ru_com << endl;
	cout << "g_inITnonImp: " << g_inITnonImp << endl;
	cout << "g_inN_ll, g_inN_lu: " << g_inN_ll << " "<< g_inN_lu << endl;
	cout << "g_dbSigma1, g_dbSigma2, g_dbSigma3: " << g_dbSigma1 << " "<< g_dbSigma2 << " "<< g_dbSigma3 << endl;
	cout << "g_dbSigma4: " << g_dbSigma4 << endl;
	cout << "g_inIs_Iterations: " << g_inIs_Iterations << endl;
	cout << "g_dbTheta0: " << g_dbTheta0 << endl;
	cout << "g_dbTheta_cool: " << g_dbTheta_cool << endl;
	cout << "g_inITmax: " << g_inITmax << endl;
	cout << "g_inITimpSTOP: " << g_inITimpSTOP << endl;
	cout << "***END OF DUMPING PARAMETERS***" << endl;
}
bool Solution::ValidParameters(void)
{
	//TODO: Implement later

	// g_dbBeta in [0, 1]

	// g_dbPenta, g_dbPenta_com >=1

	// g_inAlpha >= 2

	// g_dbN_rl < g_dbN_ru

	// 0 < g_dbN_ru < g_dbN_rl_com < g_dbN_ru_com < 1

	// g_dbSigma1 > g_dbSigma2 > g_dbSigma3 > 0

	// g_dbSigma4 in [0, 1]

	// g_dbTheta0 > 0

	// 0 < g_dbTheta_cool < 1

	return true;
}
// END OF IMPLEMENTATION OF GLOBAL PARAMETERS

// Adaptive large neighborhood search
void Solution::ALNS_Main(char *szOutSolStatFN, char *szTestIdx, char *szTestOffset)
{
	int inUsedVehNum = numVeh;
	int inSelectedCusDemandType;
	int inRemovedCusDemandNbr;
	int inSelectedDestroyOper;
	int inSelectedRepairOper;
	double arrDestroyWeights[MAX_DESTROY_OPERS+1]; //(1) Random, (2) Worst-cost, (3) Shaw, (4) Relatedness, (5) Wrong-Position, (6) Worst-Util-Leg, (7) Time-Related-Leg
	double arrRepairWeightes[MAX_REPAIR_OPERS+1]; // (1) random ;(2) Best-first; (3) 2-regret
	int inSegmentCounter;
	int inITnonImpMax = g_inITnonImp; // user-defined parameter
	int inITnonImpCounter;
	double dbNewSolFitness;
	double arrNeighborhoodScore[MAX_DESTROY_OPERS+MAX_REPAIR_OPERS+1]; //(1) Random, (2) Worst-cost, (3) Shaw, (4) Relatedness, (5) Wrong-Position & (1) random ;(2) Best-first; (3) 2-regret
	int arrNeighborhoodUsedNbr[MAX_DESTROY_OPERS+MAX_REPAIR_OPERS+1]; //(1) Random, (2) Worst-cost, (3) Shaw, (4) Relatedness, (5) Wrong-Position & (1) random ;(2) Best-first; (3) 2-regret
	double dbCurTotalFitness;
	int inNoNewBestSolCounter;
	double dbCurTemperature;
	bool bRepair;
	bool bDestroy;
	bool bGotBestFitnessInSeg;
	int inBestCostSegCnt, inBestCostItCnt;
	double dbCurrTotCost;
	int inRollCnt;
	int inTempratureCnt;
	int inRepeatCnt = 0;
	VRPSegment SavedSeg[MAX_VEH+1];
	int nextArrTmp[2000];

	// Current total cost = Best total cost = Initial cost.
	dbCurTotalFitness = g_dbBestFitness;
	inBestCostSegCnt = 0;
	inBestCostItCnt = 0;
	inRollCnt = 0;
	inTempratureCnt = 0;


#if _DEBUG
	cout << ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>" << endl;
	cout << "Adaptive Large Neighborhood Search is ready to run..." << endl;
	vdDumpMemory(1, "Adaptive Large Neighborhood Search is ready to run...", NULL, 0);
#endif

	// Start timing for algorithm
	clock_t startTime = clock();

	// Initialize weights for repair neighborhoods are equals to 1	 
#if Q_DEBUG_ALNS
	cout << "\t Initiate weight of DESTROY operations, set to 1" << endl;
	vdDumpMemory(1, "\t Initiate weight of DESTROY operations, set to 1", NULL, 0);
#endif
	for (int i = 0; i <= MAX_DESTROY_OPERS; i++)
	{
		arrDestroyWeights[i] = 1;
	}

	// Initialize weights for repair neighborhoods are equals to 1
#if Q_DEBUG_ALNS
	cout << "\t Initiate weight of REPAIR operations, set to 1" << endl;
	vdDumpMemory(1, "\t Initiate weight of REPAIR operations, set to 1", NULL, 0);
#endif
	for (int i = 0; i <= MAX_REPAIR_OPERS; i++)
	{
		arrRepairWeightes[i] = 1;
	}

	// Init. Neighbor Graph to Infity for WRONG-POISTION-BASED-HISTORY DESTROY
#if Q_DEBUG_ALNS
	cout << "\t Init. Neighbor Graph to Infity for WRONG-POISTION-BASED-HISTORY DESTROY" << endl;
	vdDumpMemory(1, "\t Init. Neighbor Graph to Infity for WRONG-POISTION-BASED-HISTORY DESTROY", NULL, 0);
#endif
	Init_Neighborhood_Graph(); 
	Update_Neighborhood_Graph(dbCurTotalFitness);
	
	// Init. elite set
#if Q_DEBUG_ALNS
	cout << "\t Init. elite and push init. sol as first eliter" << endl;
	vdDumpMemory(1, "\t Init. elite set", NULL, 0);
#endif	
	Init_Elite_Set(); // Init. elite set
	Update_Elite_Set(); // Push the initialization solution as the first in elite set
#if Q_DEBUG_ALNS
	vdDumpMemory(1, "\t Dump Elite set", NULL, 0);
	vdDumpEliseSet();
#endif	

	inSegmentCounter = 0;	   // Segment counter
	inITnonImpCounter = 0;	   // Non-improvement counter
	inNoNewBestSolCounter = 0;  
	inTempratureCnt = 0; // counter for temperature decreasing

	int I_s = g_inIs_Iterations; //  Number of iterations in one SEGMENT
		
	// Reset score and number of used neighborhood -> this will be updated at every iteration of a segment
	for (int i = 0; i <= MAX_DESTROY_OPERS+MAX_REPAIR_OPERS; i++)
	{
		arrNeighborhoodScore[i] = 0;
		arrNeighborhoodUsedNbr[i] = 0;
	}
	// The temperature is started at default value (for ACCEPTANCE_CRITERIA())
	dbCurTemperature = g_dbTheta0;
#if Q_DEBUG_ALNS
		cout << "\t Initial temperature: " << dbCurTemperature << endl;
#endif
	do
	{
		inSegmentCounter++;
		I_s = 1;
#if Q_DEBUG_ALNS
		cout << "SEGMENT [" << inSegmentCounter << "] with " <<  I_s << " iterations..." << endl;
#else
		cout << ". ";
#endif
		
		// Flag for incoming NEW BEST FITNESS SOLUTION
		bGotBestFitnessInSeg = false;

#if Q_DEBUG_ALNS
		cout << "\t Current temperature: " << dbCurTemperature << endl;
#endif
		I_s = 1;
		for (int iteration = 0; iteration < I_s; iteration++)
		{
#if Q_DEBUG_ALNS
			cout << "\t Iteration ... " << iteration << endl;
#endif
			//Reset_Penalty_Param(); //TODO: Here or before call iterations
			
			// The temperature is decreased by a cooling rate at every Is iteration (for ACCEPTANCE_CRITERIA())
			if ((inRepeatCnt % 100 == 0) && (inRepeatCnt >0))
			{
				dbCurTemperature *= g_dbTheta_cool;
				if (dbCurTemperature < 0.0001)
					dbCurTemperature = 0.0001;
#if Q_DEBUG_ALNS
				cout << "Iteration " << inRepeatCnt << " decrease temperature to " << dbCurTemperature << endl;
#endif
			}
			inRepeatCnt++;

			// Select DESTROY oper based on weight (probabilistically) or RANDOM method
			inSelectedDestroyOper = Select_Probability_By_Weight((double *)arrDestroyWeights, 6, false); // random, worst-cost, shaw, relateness, wrong-position, time-related destroy			
			//inSelectedDestroyOper = 6;
#if Q_DEBUG_ALNS
			cout << "\t Select DESTROY oper probabilistically: " << inSelectedDestroyOper << endl;
#endif

			// Select REPAIR oper based on weight (probabilistically) or RANDOM method
			inSelectedRepairOper = Select_Probability_By_Weight((double *)arrRepairWeightes, 3, false); // random, 2-regret, best-first, random for leg
		
			if ((inSelectedDestroyOper == 6))
				inSelectedRepairOper = 4; 
#if Q_DEBUG_ALNS
			cout << "\t Select REPAIR oper probabilistically: " << inSelectedRepairOper << endl;
#endif			
			// Select customer demand RANDOMLY
			inSelectedCusDemandType = Select_Cus_Demand_Type();
			//inSelectedCusDemandType = TYPE_CUST_DELIVERY; // Enable this for allowing UNIT-TEST

#if Q_DEBUG_ALNS
			cout << "\t\t Selected demand type(0-C2C|1-PICKUP|2-DELIVERY): " << inSelectedCusDemandType << endl;
#endif

			//Change the size of the destroy
#if Q_DEBUG_ALNS
			cout << "\t\t Use fixed size of the destroy...";
#endif
//			if (inITnonImpCounter < inITnonImpMax)
//			{
//				// The case not change the size of the destroy
//				inRemovedCusDemandNbr = Select_Cus_Demand_Nbr(inSelectedCusDemandType, false);
//#if Q_DEBUG_ALNS
//			cout << "NO ImpCnt/ImpMax = " << inITnonImpCounter <<  "/" << inITnonImpMax;
//#endif
//			} else
//			{
//				// Change the size of the destroy
//				inRemovedCusDemandNbr = Select_Cus_Demand_Nbr(inSelectedCusDemandType, true);
//				inITnonImpCounter = 0;
//#if Q_DEBUG_ALNS
//			cout << "YES and reset ImpCnt";
//#endif
//			}
			inRemovedCusDemandNbr = Select_Cus_Demand_Nbr(inSelectedCusDemandType, false); // fixed size of destroy
			//inRemovedCusDemandNbr = 1; // Enable this for allowing UNIT-TEST
#if Q_DEBUG_ALNS
			cout << "\t\t\t Total of removed customer demands: " << inRemovedCusDemandNbr << endl;
#endif			


			/*
			 * Saved current solution, nextArr
			 */
			for (int inSegCnt=1; inSegCnt <= numVeh; inSegCnt++)
			{
				memcpy(&SavedSeg[inSegCnt], &seg[inSegCnt], sizeof(VRPSegment));
			}
			for (int ii=1; ii <= endidD; ii++) 
			{
				nextArrTmp[ii] = nextArr[ii];
			}
			

			//TODO: Testing only
			//showSolution(); 
			//Export_Loaded_Solution("sol.bfr");

			/*
			 * Apply the SELECTED DESTROY and REPAIR neighborhood to z to obtain z'
			 */
			// Apply destroying			
			switch (inSelectedDestroyOper) //(1) Random, (2) Worst-cost, (3) Shaw, (4) Relatedness, (5) Wrong-Position
			{
				case 1:
#if Q_DEBUG_ALNS
					cout << "\t Apply RANDOM DES for " << inRemovedCusDemandNbr << " demands " << inSelectedCusDemandType << endl;
#endif
					Random_Destroy(inSelectedCusDemandType, inRemovedCusDemandNbr);
					break;
				case 2:
#if Q_DEBUG_ALNS
					cout << "\t Apply WORST COST DES for " << inRemovedCusDemandNbr << " demands " << inSelectedCusDemandType << endl;
#endif
					Worst_Cost_Destroy(inSelectedCusDemandType, inRemovedCusDemandNbr);
					break;
				case 3:
#if Q_DEBUG_ALNS
					cout << "\t Apply SHAW DES for " << inRemovedCusDemandNbr << " demands " << inSelectedCusDemandType << endl;
#endif
					Shaw_Destroy(inSelectedCusDemandType, inRemovedCusDemandNbr);
					break;
				case 4:
#if Q_DEBUG_ALNS
					cout << "\t Apply RELATEDNESS DES for " << inRemovedCusDemandNbr << " demands " << inSelectedCusDemandType << endl;
#endif
					Relatedness_Destroy(inSelectedCusDemandType, inRemovedCusDemandNbr);
					break;
				case 5:
#if Q_DEBUG_ALNS
					cout << "\t Apply WRONG POSITION DES for " << inRemovedCusDemandNbr << " demands " << inSelectedCusDemandType << endl;
#endif
					Wrong_Position_Destroy(inSelectedCusDemandType, inRemovedCusDemandNbr);
					break;
				case 6:
#if Q_DEBUG_ALNS
					cout << "\t Apply TIME RELATED LEG DES for " << inRemovedCusDemandNbr << " demands " << inSelectedCusDemandType << endl;
#endif
					bDestroy = Time_Related_Leg_Destroy(); // LEG level
					break;
				default:
					cout << "\t >>>UNKNOWN DESTROYER***" << endl; getchar();			
					return;
			}

			if (false == bDestroy)
			{
				// Vehicle status
				for (int inSegCnt=1; inSegCnt <= numVeh; inSegCnt++)
				{
					memcpy(&seg[inSegCnt], &SavedSeg[inSegCnt], sizeof(VRPSegment));
				}
				// Routed 
	            for (int ii=1; ii <= endidD; ii++) 
				{
					routed[ii]=true; 
					nextArr[ii] = nextArrTmp[ii];
				}

				inRollCnt++;
				//showSolution();
#if Q_DEBUG_ALNS
				cout << "\t\t\t Destroyed failed -> Rollback!" << endl;
#endif
				//Quangnn++ 160113
				//inNoNewBestSolCounter++;
				//if (inNoNewBestSolCounter >= g_inITimpSTOP) break;

				continue;
			}

			//showSolution();

			// Apply repairing
			switch (inSelectedRepairOper) // (1) random ;(2) Best-first; (3) 2-regret
			{
			case 1:
#if Q_DEBUG_ALNS
				cout << "\t Apply GREEDY REP for " << inRemovedCusDemandNbr << " demands " << inSelectedCusDemandType << endl;
#endif
				bRepair = Random_Greedy_Repair();
				break;
			case 2:
#if Q_DEBUG_ALNS
				cout << "\t Apply BEST FIRST REP for " << inRemovedCusDemandNbr << " demands " << inSelectedCusDemandType << endl;
#endif
				bRepair = Best_First_Repair();
				break;
			case 3:
#if Q_DEBUG_ALNS
				cout << "\t Apply TWO REGRET REP for " << inRemovedCusDemandNbr << " demands " << inSelectedCusDemandType << endl;
#endif
				bRepair = Two_Regret_Repair();
				break;
			case 4:
#if Q_DEBUG_ALNS
				cout << "\t Apply GREEDY-LEG REP for " << inRemovedCusDemandNbr << " demands " << inSelectedCusDemandType << endl;
#endif
				bRepair = Random_Greedy_Repair_Leg();
				break;
			 default:
				 cout << "\t >>>UNKNOWN REPAIRER***" << endl; getchar();			
				return;
			}
			/*
			 * END OF Applying the SELECTED DESTROY and REPAIR neighborhood to z to obtain z'
			 */

			// Resuming
			if ((false == bRepair) || (false == Check_Solution(&dbCurrTotCost)))
			{
				// Vehicle status
				for (int inSegCnt=1; inSegCnt <= numVeh; inSegCnt++)
				{
					memcpy(&seg[inSegCnt], &SavedSeg[inSegCnt], sizeof(VRPSegment));
				}
				// Routed 
	            for (int ii=1; ii <= endidD; ii++) 
				{
					routed[ii]=true; 
					nextArr[ii] = nextArrTmp[ii];
				}

				inRollCnt++;
				//showSolution();
#if Q_DEBUG_ALNS
				cout << "\t\t\t Repaired failed -> Rollback!" << endl;
#endif
				//Quangnn++ 160113
				//inNoNewBestSolCounter++;
				//if (inNoNewBestSolCounter >= g_inITimpSTOP) break;

				continue;
			}	
			dbNewSolFitness = dbCurrTotCost;
			// Let check SP, Demand status after applying repairing
   //         if (false == Show_Demands_Status())
			//{
			//	cout << "Some demands donot be served *ln" << __LINE__ << endl; getchar();
			//}

			//showSolution();
			//if (-1 == Update_SP_Status()) // Affect for initialization solution while pickup assignment
			//{
			//	cout << "\t\t SP status crashed after repairing" << endl;
			//	getchar();
			//}

			/* In bad situation, some demands can not be served so
			 * Search and create single trips for unrouted customer demands
			 */
			//TODO:
			//CheckAndCreateSingleTrip();

			//showSolution();

			//dbCurrTotCost = PDS_INFINITY;
			//if (true == Check_Solution(&dbCurrTotCost))
			{
				//cout << "\t\t " << iteration << "-Feasible! " << dbCurrTotCost << endl; //getchar();
				
				//showSolution();
			}
#if Q_DEBUG_ALNS
			/*cout << "\t\t\t Save current solution" << endl;
			showSolution();*/
#endif

			/*
			 * While a new solution is found, Update Neighbor Graph (Ropke and Pisinger) for WRONG-POSITION-BASED-HISTORY DESTROY
			 */
#if Q_DEBUG_ALNS
			cout << "\t Update neighbor graph" << endl;
#endif
			Update_Neighborhood_Graph(dbNewSolFitness);

			/*
			 * Adaptive Weight Adjustment based on the new solution (PER-INTERATION)
			 *	arrNeighborhoodUsedNbr indicates counter of used Destroy/Repair operations
			 *  arrNeighborhoodScore indicates current scores of Destroy/Repair operations
			 */
#if Q_DEBUG_ALNS
			cout << "\t Adaptive Weight Adjustment" << endl;
#endif
			arrNeighborhoodUsedNbr[inSelectedDestroyOper] += 1;
			arrNeighborhoodUsedNbr[inSelectedRepairOper+6] += 1;

#if Q_DEBUG_ALNS
			cout << "\t New solution is checking..." << endl;
#endif
			if (dbNewSolFitness < g_dbBestFitness) // a new best solution is produced
			{
#if Q_DEBUG_ALNS
				cout << "\t\t A new best solution! " << dbNewSolFitness << "/" << g_dbBestFitness << endl; //getchar();
#endif
				arrNeighborhoodScore[inSelectedDestroyOper] += g_dbSigma1;
				arrNeighborhoodScore[inSelectedRepairOper+6] += g_dbSigma1;				
			} else if (dbNewSolFitness < dbCurTotalFitness)	// the solution produced is better than the current one
			{
#if Q_DEBUG_ALNS
				cout << "\t\t The produced solution is better! " << dbNewSolFitness << "/" << g_dbBestFitness << endl; //getchar();
#endif
				arrNeighborhoodScore[inSelectedDestroyOper] += g_dbSigma2;
				arrNeighborhoodScore[inSelectedRepairOper+6] += g_dbSigma2;
			} else // the solution produced is accepted but it is worse than the current one
			{
#if Q_DEBUG_ALNS
				cout << "\t\t The produced sol is worse -> acceptance? " << dbNewSolFitness << "/" << g_dbBestFitness << endl; //getchar();
#endif
				arrNeighborhoodScore[inSelectedDestroyOper] += g_dbSigma3;
				arrNeighborhoodScore[inSelectedRepairOper+6] += g_dbSigma3;
			}

			// Found a new best solution (fitness)
			if (dbNewSolFitness < g_dbBestFitness)
			{
				g_dbBestFitness = dbNewSolFitness;
				g_inUsedVehNum = numVeh;
				//exportSolution();
				inITnonImpCounter = 0;
				inNoNewBestSolCounter = 0;
				Update_Elite_Set();
				inTempratureCnt = 0;
#if Q_DEBUG_ALNS
	//vdDumpMemory(1, "\t Dump Elite set", NULL, 0);
	//vdDumpEliseSet();
#endif	

				if (dbCurrTotCost < g_dbBestTotalCost) // feasible sol.
				{
					g_dbBestTotalCost = dbCurrTotCost;
					double dbGotBestAt = double( clock() - startTime ) / (double)CLOCKS_PER_SEC;
					updateBestSolution(inSegmentCounter, iteration+1, g_dbBestTotalCost, szTestIdx, dbGotBestAt, szTestOffset);
					//Save_Best_As_StdFormat(g_dbBestTotalCost, szTestIdx, szTestOffset);
					inBestCostSegCnt = inSegmentCounter;
					inBestCostItCnt = iteration+1;

#if 0 //_DEBUG
					cout << "\t\t " << iteration << "-Feasible! " << dbCurrTotCost << " and temprature " << dbCurTemperature << endl; //getchar();
#endif
//#if _DEBUG
					showSolutionNewFormat(szTestIdx, szTestOffset, false);
//#endif-
				}
				bGotBestFitnessInSeg = true;
			} else
			{
				inITnonImpCounter++;
				inTempratureCnt++;
				bGotBestFitnessInSeg = false;
			}

			// Update current solution cost
#if Q_DEBUG_ALNS
			cout << "\t Appectance criteria: " << endl;
#endif
			if (true == Acceptance_Criteria2(dbCurTotalFitness, dbNewSolFitness, dbCurTemperature))
			{
#if Q_DEBUG_ALNS
				cout << "\t\t Accepted new solution " << dbNewSolFitness << endl;
#endif
				dbCurTotalFitness = dbNewSolFitness;
			} else 
			{
#if Q_DEBUG_ALNS
				cout << "\t\t Reject new solution. Keep current one! " << dbCurTotalFitness << endl;
#endif
				// Vehicle status
				for (int inSegCnt=1; inSegCnt <= numVeh; inSegCnt++)
				{
					memcpy(&seg[inSegCnt], &SavedSeg[inSegCnt], sizeof(VRPSegment));
				}
				// Routed 
	            for (int ii=1; ii <= endidD; ii++) 
				{
					routed[ii]=true; 
					nextArr[ii] = nextArrTmp[ii];
				}

			}

			if (false == bGotBestFitnessInSeg)
			{
				inNoNewBestSolCounter++;
			}


			//Quangnn++ 160113
			if (inNoNewBestSolCounter >= g_inITimpSTOP)
				break;
		} // End of a SEGMENT


		//Quangnn++ 160113
		if (inNoNewBestSolCounter >= g_inITimpSTOP)
			break;

		/*
		 * Adjust weights for all destroy and repair neighborhoods (ONCE A SEGEMENT IS COMPLETED)
		 */
#if Q_DEBUG_ALNS
		cout << "\t Adjust weights" << endl;
#endif
#if Q_DEBUG_ALNS
		cout << "\t\t Neighborhoods used: ";
		for (int i = 1; i <= 10; i++)
		{
			cout << arrNeighborhoodUsedNbr[i] <<  " ";
		}
		cout << endl;

		cout << "\t\t Neighborhoods scoring: ";
		for (int i = 1; i <= 10; i++)
		{
			cout << arrNeighborhoodScore[i] <<  " ";
		}
		cout << endl;
#endif

		for (int i = 1; i <= 6; i++) // for destroy operations
		{
			if (arrNeighborhoodUsedNbr[i] == 0) continue;
			double dbTmp;
			dbTmp = (1 - g_dbSigma4);
			dbTmp *= arrDestroyWeights[i];
			arrDestroyWeights[i] = dbTmp;

			dbTmp = g_dbSigma4*arrNeighborhoodScore[i];
			dbTmp /= arrNeighborhoodUsedNbr[i];
			arrDestroyWeights[i] += dbTmp;
		}
#if Q_DEBUG_ALNS
		cout << "\t\t Destroys: ";
		for (int i = 1; i <= 6; i++)
		{
			cout << arrDestroyWeights[i] <<  " ";
		}
		cout << endl;
#endif
		for (int i = 1; i <= 4; i++) // for repair operations
		{
			if (arrNeighborhoodUsedNbr[i+6] == 0) continue;
			double dbTmp;
			dbTmp = (1 - g_dbSigma4);
			dbTmp *= arrRepairWeightes[i];
			arrRepairWeightes[i] = dbTmp;

			dbTmp = g_dbSigma4*arrNeighborhoodScore[i+6];
			dbTmp /= arrNeighborhoodUsedNbr[i+6];
			arrRepairWeightes[i] += dbTmp;
		}
#if Q_DEBUG_ALNS
		cout << "\t\t Repairs: ";
		for (int i = 1; i <= 4; i++)
		{
			cout << arrRepairWeightes[i] <<  " ";
		}
		cout << endl;
#endif

		//showSolution();
		//exportSolution();	
#if Q_DEBUG_ALNS
		vdDumpMemory(1, "\t Used neighbor: ", (double *)arrNeighborhoodUsedNbr, 8);
		vdDumpMemory(1, "\t Neighbor scoring: ", arrNeighborhoodScore, 8);
#endif		
	//} while (0 == Stop_Condition_ALNS(inSegmentCounter, inNoNewBestSolCounter)); // stop when the stopping condition is met
		}while (inNoNewBestSolCounter < g_inITimpSTOP);

	//TODO: Post-optimization, try to remove all waiting station

	//Re-check solution after ALNS
	double dbTotalCostTmp;
	Check_Solution(&dbTotalCostTmp);
	showSolution();
	//exportSolution();

	//cout << double( clock() - startTime ) / (double)CLOCKS_PER_SEC<< " seconds." << endl;
	double dbRunningTime = double( clock() - startTime ) / (double)CLOCKS_PER_SEC;
	// Statistic of result
	ExportStatSol(szOutSolStatFN,
				 inBestCostSegCnt, inBestCostItCnt, 
				 inSegmentCounter, inNoNewBestSolCounter, 
				 dbRunningTime, // Running time
				 g_dbBestTotalCost,
				 dbCurTotalFitness,
				NULL); //TODO: Sum up used neighbors
}


void Solution::Get_Time_For_Hamming_Dis_Calc(int inVehIDx, int inTripIdx, double *dbStartFirstCus, double *dbStartLastCus)
{
	double dbStartTime;
	int curC;
	int i, j;
	int arrSol[2000];
	int inSolNode;

   {
	   i = inVehIDx;
	   
	   //cout << "\t\t Vehicle: " << i << endl;
	   

	   {
		   j = inTripIdx;
		   //cout << "\t\t\t >>>Trip: " << j << endl;

		   if (TRIP_DELIVERY == seg[i].Trip[j].Type)
		   {
	/*		   cout << "\t\t\t Type: DELIVERY" << endl;
			   cout << "\t\t\t Fitness: " << seg[i].Trip[j].fitness << endl;
			   cout << "\t\t\t Cost: " << seg[i].Trip[j].cost << endl;
			   cout << "\t\t\t Capacity: " << seg[i].Trip[j].capacity << endl;
			   cout << "\t\t\t Arrived at: " << seg[i].Trip[j].arriveSP << endl;
			   cout << "\t\t\t Leave at: " << seg[i].Trip[j].leaveSP << endl;
			   cout << "\t\t\t Node Nbr: " << seg[i].Trip[j].numCus << endl;
			   cout << "\t\t\t Assigned SP: " << seg[i].Trip[j].assSP << endl;
			   cout << "\t\t\t Started from: " << seg[i].Trip[j].startNodeIdx << "(" << seg[i].Trip[j].leaveSP << ")" << endl;
			   cout << "\t\t\t End at: " << seg[i].Trip[j].endNodeIdx << endl;
			   cout << "\t\t\t Waiting station: " << seg[i].Trip[j].waitingS << endl;
			   cout << "\t\t\t EndS: " << seg[i].Trip[j].endS << endl;

			   cout << "\t\t\t ROUTED: ";*/
			   curC = seg[i].Trip[j].firstCus;
			   int preNode = seg[i].Trip[j].startNodeIdx;
			   double db_TimePoint = seg[i].Trip[j].leaveSP + problem->nodeSP[seg[i].Trip[j].startNodeIdx].load;
			   //StartNodeIdx
			   //cout << seg[i].Trip[j].startNodeIdx << "*(" << seg[i].Trip[j].leaveSP << "," << db_TimePoint << ")->";
			   while (curC > 0)
			   {
				   db_TimePoint += problem->c[preNode][curC];
				   if (db_TimePoint < problem->node[curC].sTW)
					   db_TimePoint = problem->node[curC].sTW;

				   if (curC == seg[i].Trip[j].firstCus)
				   {
					   *dbStartFirstCus = db_TimePoint;
				   }
				   if (curC == seg[i].Trip[j].lastCus)
				   {
					   *dbStartLastCus = db_TimePoint;
				   }
				   //cout << curC << "(" << db_TimePoint << "|" << (db_TimePoint+problem->node[curC].duration) << ")" << "->";
				 
				   preNode = curC;
				   db_TimePoint += problem->node[curC].duration;
				
				   curC = nextArr[curC];
			   }
			   //Waiting station
			   if (seg[i].Trip[j].waitingS > 0)
			   {
				   db_TimePoint += problem->c[seg[i].Trip[j].lastCus][seg[i].Trip[j].waitingS];
				   //cout << seg[i].Trip[j].waitingS << "^" << "(" << db_TimePoint << "|" << (seg[i].Trip[j].endS - problem->c[seg[i].Trip[j].waitingS][seg[i].Trip[j].endNodeIdx]) << ") ->";
			   }
			   //EndNodeIdx
			   //cout << seg[i].Trip[j].endNodeIdx << "**(" << seg[i].Trip[j].endS << ")" << endl << endl;

		   }
		   else if (TRIP_C2C == seg[i].Trip[j].Type)
		   {
			   //cout << "\t\t\t Type: C2C" << endl;
			   //cout << "\t\t\t Fitness: " << seg[i].Trip[j].fitness << endl;
			   //cout << "\t\t\t Cost: " << seg[i].Trip[j].cost << endl;
			   //cout << "\t\t\t Capacity: " << seg[i].Trip[j].capacity << endl;
			   //cout << "\t\t\t Arrived at: " << seg[i].Trip[j].arriveSP << endl;
			   //cout << "\t\t\t Leave at: " << seg[i].Trip[j].leaveSP << endl;
			   //cout << "\t\t\t Node Nbr: " << seg[i].Trip[j].numCus << endl;
			   //cout << "\t\t\t Assigned SP: " << seg[i].Trip[j].assSP << endl;
			   //cout << "\t\t\t Started from: " << seg[i].Trip[j].startNodeIdx << endl;
			   //cout << "\t\t\t End at: " << seg[i].Trip[j].endNodeIdx << endl;
			   //cout << "\t\t\t Waiting station: " << seg[i].Trip[j].waitingS << endl;
			   //cout << "\t\t\t EndS: " << seg[i].Trip[j].endS << endl;

			   //cout << "\t\t\t ROUTED: ";
			   curC = seg[i].Trip[j].firstCus;
			   int preNode = seg[i].Trip[j].startNodeIdx;
			   double db_TimePoint = seg[i].Trip[j].leaveSP;
			   //cout << seg[i].Trip[j].startNodeIdx << "*(" << seg[i].Trip[j].leaveSP << ")->";
			   while (curC > 0)
			   {
				   db_TimePoint += problem->c[preNode][curC];
				   if (db_TimePoint < problem->node[curC].sTW)
					   db_TimePoint = problem->node[curC].sTW;

				   if (curC == seg[i].Trip[j].firstCus)
				   {
					   *dbStartFirstCus = db_TimePoint;
				   }
				   if (curC == seg[i].Trip[j].lastCus)
				   {
					   *dbStartLastCus = db_TimePoint;
				   }

				   //cout << curC << "(" << db_TimePoint << "|" << (db_TimePoint+problem->node[curC].duration) << ")" << "->";
				   preNode = curC;
				   db_TimePoint += problem->node[curC].duration;
				
				   curC = nextArr[curC];
			   }
			   //Waiting station
			   if (seg[i].Trip[j].waitingS > 0)
			   {
				   db_TimePoint += problem->c[seg[i].Trip[j].lastCus][seg[i].Trip[j].waitingS];
				   //cout << seg[i].Trip[j].waitingS << "^" << "(" << db_TimePoint << "|" << (seg[i].Trip[j].endS - problem->c[seg[i].Trip[j].waitingS][seg[i].Trip[j].endNodeIdx]) << ")->";
			   }
			   //EndNodeIdx
			   //cout << seg[i].Trip[j].endNodeIdx << "**(" << seg[i].Trip[j].endS << ")" << endl << endl;
		   }
		   else if (TRIP_PICKUP == seg[i].Trip[j].Type)
		   {
//			   cout << "\t\t\t Type: PICKUP" << endl;
////			   cout << "\t\t\t Fitness: " << seg[i].Trip[j].fitness << endl;
////			   cout << "\t\t\t Cost: " << seg[i].Trip[j].cost << endl;
//			   cout << "\t\t\t Capacity: " << seg[i].Trip[j].capacity << endl;
//			   //cout << "\t\t\t Arrived at: " << seg[i].Trip[j].arriveSP << endl;
//			   cout << "\t\t\t Total nodes: " << seg[i].Trip[j].numCus << endl;
//			   cout << "\t\t\t Assigned SP: " << seg[i].Trip[j].assSP << endl;
//			   cout << "\t\t\t Started from node " << seg[i].Trip[j].startNodeIdx << " at " << seg[i].Trip[j].leaveSP << endl;
//			   cout << "\t\t\t Waiting station: " << seg[i].Trip[j].waitingS << endl;
//			   cout << "\t\t\t Finshed at node " << seg[i].Trip[j].endNodeIdx <<  " at " << seg[i].Trip[j].endS << endl;			  
//			   cout << "\t\t\t\t Reached at " << seg[i].Trip[j].endS -  problem->nodeSP[seg[i].Trip[j].endNodeIdx].unload<< endl;
//			   cout << "\t\t\t\t Finished unloading at " << seg[i].Trip[j].endS << endl;
			   
			   //Calc. starting time
			   curC = seg[i].Trip[j].firstCus;
			   arrSol[1] = curC; inSolNode = 1;
			   while (curC > 0)
			   {
				   curC = nextArr[curC];

				   if (curC > 0)
				   {
						inSolNode++;
						arrSol[inSolNode] = curC;
				   }
			   }
			

			   dbStartTime = seg[i].Trip[j].leaveSP;

			 //  cout << "\t\t\t ROUTED: ";
			   curC = seg[i].Trip[j].firstCus;
			   int preNode = seg[i].Trip[j].startNodeIdx;
			   double db_TimePoint = dbStartTime;
			   //cout << seg[i].Trip[j].startNodeIdx << "*(-," << seg[i].Trip[j].leaveSP << ")->";
			   while (curC > 0)
			   {
				   db_TimePoint += problem->c[preNode][curC];
				   if (db_TimePoint < problem->node[curC].sTW)
					   db_TimePoint = problem->node[curC].sTW;

				   if (curC == seg[i].Trip[j].firstCus)
				   {
					   *dbStartFirstCus = db_TimePoint;
				   }
				   if (curC == seg[i].Trip[j].lastCus)
				   {
					   *dbStartLastCus = db_TimePoint;
				   }
				   //cout << curC << "(" << db_TimePoint << "|" << (db_TimePoint+problem->node[curC].duration) << ")" << "->";
				   preNode = curC;
				   db_TimePoint += problem->node[curC].duration;

				   curC = nextArr[curC];
			   }
			   //Waiting station
			   if (seg[i].Trip[j].waitingS > 0)
			   {
				   db_TimePoint += problem->c[seg[i].Trip[j].lastCus][seg[i].Trip[j].waitingS];
				   //cout << seg[i].Trip[j].waitingS << "^" << "(" << db_TimePoint << "|" << (seg[i].Trip[j].endS - problem->c[seg[i].Trip[j].waitingS][seg[i].Trip[j].endNodeIdx]) << ")->";
			   }
			   //EndNodeIdx
			   //cout << seg[i].Trip[j].endNodeIdx << "**(" << (seg[i].Trip[j].endS-problem->nodeSP[seg[i].Trip[j].endNodeIdx].unload) <<"," << seg[i].Trip[j].endS << ")" << endl << endl;
			  
		   }
	   }
   }
}
//
void Solution::Show_A_Trip(int inVehIDx, int inTripIdx)
{
	double dbStartTime;
	int curC;
	int i, j;
	int arrSol[2000];
	int inSolNode;

   //for (i = 1; i <= numVeh; i++) // to consildation, we do not use 0 index.
   {
	   i = inVehIDx;
	   cout << "\t\t Vehicle: " << i << endl;
	   

	   //for (j = 1; j <= seg[i].numTrips; j++)
	   {
		   j = inTripIdx;
		   cout << "\t\t\t >>>Trip: " << j << endl;

		   if (TRIP_DELIVERY == seg[i].Trip[j].Type)
		   {
			   cout << "\t\t\t Type: DELIVERY" << endl;
			   cout << "\t\t\t Fitness: " << seg[i].Trip[j].fitness << endl;
			   cout << "\t\t\t Cost: " << seg[i].Trip[j].cost << endl;
			   cout << "\t\t\t Capacity: " << seg[i].Trip[j].capacity << endl;
			   cout << "\t\t\t Arrived at: " << seg[i].Trip[j].arriveSP << endl;
			   cout << "\t\t\t Leave at: " << seg[i].Trip[j].leaveSP << endl;
			   cout << "\t\t\t Node Nbr: " << seg[i].Trip[j].numCus << endl;
			   cout << "\t\t\t Assigned SP: " << seg[i].Trip[j].assSP << endl;
			   cout << "\t\t\t Started from: " << seg[i].Trip[j].startNodeIdx << "(" << seg[i].Trip[j].leaveSP << ")" << endl;
			   cout << "\t\t\t End at: " << seg[i].Trip[j].endNodeIdx << endl;
			   cout << "\t\t\t Waiting station: " << seg[i].Trip[j].waitingS << endl;
			   cout << "\t\t\t EndS: " << seg[i].Trip[j].endS << endl;

			   cout << "\t\t\t ROUTED: ";
			   curC = seg[i].Trip[j].firstCus;
			   int preNode = seg[i].Trip[j].startNodeIdx;
			   double db_TimePoint = seg[i].Trip[j].leaveSP + problem->nodeSP[seg[i].Trip[j].startNodeIdx].load;
			   //StartNodeIdx
			   cout << seg[i].Trip[j].startNodeIdx << "*(" << seg[i].Trip[j].leaveSP << "," << db_TimePoint << ")->";
			   while (curC > 0)
			   {
				   db_TimePoint += problem->c[preNode][curC];
				   if (db_TimePoint < problem->node[curC].sTW)
					   db_TimePoint = problem->node[curC].sTW;

				   cout << curC << "(" << db_TimePoint << "|" << (db_TimePoint+problem->node[curC].duration) << ")" << "->";
				   preNode = curC;
				   db_TimePoint += problem->node[curC].duration;
				
				   curC = nextArr[curC];
			   }
			   //Waiting station
			   if (seg[i].Trip[j].waitingS > 0)
			   {
				   db_TimePoint += problem->c[seg[i].Trip[j].lastCus][seg[i].Trip[j].waitingS];
				   cout << seg[i].Trip[j].waitingS << "^" << "(" << db_TimePoint << "|" << (seg[i].Trip[j].endS - problem->c[seg[i].Trip[j].waitingS][seg[i].Trip[j].endNodeIdx]) << ") ->";
			   }
			   //EndNodeIdx
			   cout << seg[i].Trip[j].endNodeIdx << "**(" << seg[i].Trip[j].endS << ")" << endl << endl;

		   }
		   else if (TRIP_C2C == seg[i].Trip[j].Type)
		   {
			   cout << "\t\t\t Type: C2C" << endl;
			   cout << "\t\t\t Fitness: " << seg[i].Trip[j].fitness << endl;
			   cout << "\t\t\t Cost: " << seg[i].Trip[j].cost << endl;
			   cout << "\t\t\t Capacity: " << seg[i].Trip[j].capacity << endl;
			   cout << "\t\t\t Arrived at: " << seg[i].Trip[j].arriveSP << endl;
			   cout << "\t\t\t Leave at: " << seg[i].Trip[j].leaveSP << endl;
			   cout << "\t\t\t Node Nbr: " << seg[i].Trip[j].numCus << endl;
			   cout << "\t\t\t Assigned SP: " << seg[i].Trip[j].assSP << endl;
			   cout << "\t\t\t Started from: " << seg[i].Trip[j].startNodeIdx << endl;
			   cout << "\t\t\t End at: " << seg[i].Trip[j].endNodeIdx << endl;
			   cout << "\t\t\t Waiting station: " << seg[i].Trip[j].waitingS << endl;
			   cout << "\t\t\t EndS: " << seg[i].Trip[j].endS << endl;

			   cout << "\t\t\t ROUTED: ";
			   curC = seg[i].Trip[j].firstCus;
			   int preNode = seg[i].Trip[j].startNodeIdx;
			   double db_TimePoint = seg[i].Trip[j].leaveSP;
			   cout << seg[i].Trip[j].startNodeIdx << "*(" << seg[i].Trip[j].leaveSP << ")->";
			   while (curC > 0)
			   {
				   db_TimePoint += problem->c[preNode][curC];
				   if (db_TimePoint < problem->node[curC].sTW)
					   db_TimePoint = problem->node[curC].sTW;

				   cout << curC << "(" << db_TimePoint << "|" << (db_TimePoint+problem->node[curC].duration) << ")" << "->";
				   preNode = curC;
				   db_TimePoint += problem->node[curC].duration;
				
				   curC = nextArr[curC];
			   }
			   //Waiting station
			   if (seg[i].Trip[j].waitingS > 0)
			   {
				   db_TimePoint += problem->c[seg[i].Trip[j].lastCus][seg[i].Trip[j].waitingS];
				   cout << seg[i].Trip[j].waitingS << "^" << "(" << db_TimePoint << "|" << (seg[i].Trip[j].endS - problem->c[seg[i].Trip[j].waitingS][seg[i].Trip[j].endNodeIdx]) << ")->";
			   }
			   //EndNodeIdx
			   cout << seg[i].Trip[j].endNodeIdx << "**(" << seg[i].Trip[j].endS << ")" << endl << endl;
		   }
		   else if (TRIP_PICKUP == seg[i].Trip[j].Type)
		   {
			   cout << "\t\t\t Type: PICKUP" << endl;
//			   cout << "\t\t\t Fitness: " << seg[i].Trip[j].fitness << endl;
//			   cout << "\t\t\t Cost: " << seg[i].Trip[j].cost << endl;
			   cout << "\t\t\t Capacity: " << seg[i].Trip[j].capacity << endl;
			   //cout << "\t\t\t Arrived at: " << seg[i].Trip[j].arriveSP << endl;
			   cout << "\t\t\t Total nodes: " << seg[i].Trip[j].numCus << endl;
			   cout << "\t\t\t Assigned SP: " << seg[i].Trip[j].assSP << endl;
			   cout << "\t\t\t Started from node " << seg[i].Trip[j].startNodeIdx << " at " << seg[i].Trip[j].leaveSP << endl;
			   cout << "\t\t\t Waiting station: " << seg[i].Trip[j].waitingS << endl;
			   cout << "\t\t\t Finshed at node " << seg[i].Trip[j].endNodeIdx <<  " at " << seg[i].Trip[j].endS << endl;			  
			   cout << "\t\t\t\t Reached at " << seg[i].Trip[j].endS -  problem->nodeSP[seg[i].Trip[j].endNodeIdx].unload<< endl;
			   cout << "\t\t\t\t Finished unloading at " << seg[i].Trip[j].endS << endl;
			   
			   //Calc. starting time
			   curC = seg[i].Trip[j].firstCus;
			   arrSol[1] = curC; inSolNode = 1;
			   while (curC > 0)
			   {
				   curC = nextArr[curC];

				   if (curC > 0)
				   {
						inSolNode++;
						arrSol[inSolNode] = curC;
				   }
			   }
			

			   dbStartTime = seg[i].Trip[j].leaveSP;

			   cout << "\t\t\t ROUTED: ";
			   curC = seg[i].Trip[j].firstCus;
			   int preNode = seg[i].Trip[j].startNodeIdx;
			   double db_TimePoint = dbStartTime;
			   cout << seg[i].Trip[j].startNodeIdx << "*(-," << seg[i].Trip[j].leaveSP << ")->";
			   while (curC > 0)
			   {
				   db_TimePoint += problem->c[preNode][curC];
				   if (db_TimePoint < problem->node[curC].sTW)
					   db_TimePoint = problem->node[curC].sTW;

				   cout << curC << "(" << db_TimePoint << "|" << (db_TimePoint+problem->node[curC].duration) << ")" << "->";
				   preNode = curC;
				   db_TimePoint += problem->node[curC].duration;

				   curC = nextArr[curC];
			   }
			   //Waiting station
			   if (seg[i].Trip[j].waitingS > 0)
			   {
				   db_TimePoint += problem->c[seg[i].Trip[j].lastCus][seg[i].Trip[j].waitingS];
				   cout << seg[i].Trip[j].waitingS << "^" << "(" << db_TimePoint << "|" << (seg[i].Trip[j].endS - problem->c[seg[i].Trip[j].waitingS][seg[i].Trip[j].endNodeIdx]) << ")->";
			   }
			   //EndNodeIdx
			   cout << seg[i].Trip[j].endNodeIdx << "**(" << (seg[i].Trip[j].endS-problem->nodeSP[seg[i].Trip[j].endNodeIdx].unload) <<"," << seg[i].Trip[j].endS << ")" << endl << endl;
			  
		   }
	   }
   }
}

void Solution::ExportStatSeg( int inCurrSeg,
					  int inBestSegCnt, int inBestItCnt, double dbBestCost,
					  int inRollBackCnt,
					  int * arrUsedNeighbor)
{
	ofstream infile;

	infile.open("seg.sta", ios::out | ios::app); 
     if (!infile){	 
		 cout << "\n\tInput file not found !!!!!!" << endl; 		
		 exit(-1);
	 }
	 infile << "Segment " << inCurrSeg << endl;
	 infile << "\t Best cost: " << dbBestCost << endl;
	 infile << "\t Best segment: " << inBestSegCnt << endl;
	 infile << "\t Best iteration: " << inBestItCnt << endl;
	 infile << "\t Rollback counter: " << inRollBackCnt << endl;

 	 infile << "\tRandom Destroy: " << arrUsedNeighbor[1] << endl;
	 infile << "\tWo0rst cost Destroy: " << arrUsedNeighbor[2] << endl;
	 infile << "\tShaw Destroy: " << arrUsedNeighbor[3] << endl;
	 infile << "\tRelatedness-based-history Destroy: " << arrUsedNeighbor[4] << endl;
	 infile << "\tWrong-position-based-history Destroy: " << arrUsedNeighbor[5] << endl;
	 infile << "\tRandom Repair: " << arrUsedNeighbor[6] << endl;
	 infile << "\tBest-first Repair: " << arrUsedNeighbor[7] << endl;
	 infile << "\t2-regret Repair: " << arrUsedNeighbor[8] << endl;


}

void Solution::ExportStatPO(char *szTestIdx, char *szTestOffset, double dbRunningTime) 
{
	ofstream infile;
	char szFileName[100];
   

   strcpy(szFileName, "sol");
   strcat(szFileName, szTestIdx); 
   strcat(szFileName, "_"); 
   strcat(szFileName, szTestOffset);
   strcat(szFileName, ".staopt");

	infile.open(szFileName, ios::out); 
     if (!infile){	 
		 cout << "\n\tInput file not found !!!!!!" << endl; 		
		 exit(-1);
	 }
	infile << "Total PO time: " << dbRunningTime << " seconds" << endl;
}

void Solution::ExportStatSol( char *szFileName,
					  int inBestSegCnt, int inBestItCnt, 
					  int inLastITMax, int inLastImpIT, 
					  double dbRunningTime,
					  double dbBestCost,
					  double dbFitness,
					  int * arrUsedNeighbor)
{
	ofstream infile;

	infile.open(szFileName, ios::out); 
     if (!infile){	 
		 cout << "\n\tInput file not found !!!!!!" << endl; 		
		 exit(-1);
	 }
	 infile << "Best cost: " << dbBestCost << endl;
	 infile << "Got the best cost at ITERATION/SEGMENT: " << inBestItCnt << "/" << inBestSegCnt <<  endl;
	 infile << "Stopped with SEGMENT/ITMAX: " << inLastITMax << "/" << g_inITmax << endl;
	 infile << "Stopped with nonImp/ITnonImpMAX: " << inLastImpIT << "/" << g_inITimpSTOP << endl;
	 infile << "Total running time: " << dbRunningTime << " seconds" << endl;
	 infile << "\t Last fitness: " << dbFitness << endl;
	 infile << dbBestCost << "\t" << inBestSegCnt << "\t" << dbRunningTime << endl;
	 //infile << "\t Last Alpha_q: " << g_dbAlpha_q << endl;
  //   infile << "\t Last Alpha_c: " << g_dbAlpha_c << endl;
  //   infile << "\t Last Alpha_s: " << g_dbAlpha_s << endl;
	 //infile << "Nbr of used operator: " << endl;
	 //infile << "\tRandom Destroy: " << arrUsedNeighbor[1] << endl;
	 //infile << "\tWo0rst cost Destroy: " << arrUsedNeighbor[2] << endl;
	 //infile << "\tShaw Destroy: " << arrUsedNeighbor[3] << endl;
	 //infile << "\tRelatedness-based-history Destroy: " << arrUsedNeighbor[4] << endl;
	 //infile << "\tWrong-position-based-history Destroy: " << arrUsedNeighbor[5] << endl;
	 //infile << "\tRandom Repair: " << arrUsedNeighbor[6] << endl;
	 //infile << "\tBest-first Repair: " << arrUsedNeighbor[7] << endl;
	 //infile << "\t2-regret Repair: " << arrUsedNeighbor[8] << endl;
}

// Export solution as old format
void Solution::showSolution_Old(char *szSuffFn)
{
  int i,j,curC;
   double dbStartTime;
   int arrSol[2000];
   int inSolNode;
   char szFileName[30];
   double dbTotalCost;
   ofstream infile;

   strcpy(szFileName, "sol_");
   strcat(szFileName, szSuffFn);
   strcat(szFileName, ".bes");

   infile.open(szFileName, ios::out); 
     if (!infile){	 
		 cout << "\n\tInput file not found !!!!!!" << endl; 		
		 exit(-1);
	 }
   
   // Get cost
   Check_Solution(&dbTotalCost);
   infile << "Cost: " << dbTotalCost << endl;
   infile << "Vehicle: " << numVeh-1 << endl;

   for (i = 1; i < numVeh; i++) // to consildation, we do not use 0 index.
   {
	   infile << i << " " << seg[i].numTrips << " " <<  seg[i].cost << endl;
	   for (j = 1; j <= seg[i].numTrips; j++)
	   {
		   infile << i << " " << j ;

		   if (TRIP_DELIVERY == seg[i].Trip[j].Type)
		   {
			   infile << "\tDELIVERY";
			   //infile << "\t\t\t Cost: " << seg[i].Trip[j].cost << endl;
			   //infile << "\t\t\t Capacity: " << seg[i].Trip[j].capacity << endl;
			   //infile << "\t\t\t Arrived at: " << seg[i].Trip[j].arriveSP << endl;
			   //infile << "\t\t\t Leave at: " << seg[i].Trip[j].leaveSP << endl;
			   //infile << "\t\t\t Delivery Nbr: " << seg[i].Trip[j].numCus << endl;
			   //infile << "\t\t\t Assigned SP: " << seg[i].Trip[j].assSP << endl;
			   //infile << "\t\t\t Started from SP: " << seg[i].Trip[j].startNodeIdx << "(" << seg[i].Trip[j].leaveSP << ")" << endl;
			   //infile << "\t\t\t End at: " << seg[i].Trip[j].endNodeIdx << endl;
			   //infile << "\t\t\t Waiting station: " << seg[i].Trip[j].waitingS << endl;
			   //infile << "\t\t\t EndS: " << seg[i].Trip[j].endS << endl;

			   //infile << "\t\t\t ROUTED: ";
			   infile << "\t(nCus = " << seg[i].Trip[j].numCus << ")";
			   //infile << "\t" << seg[i].Trip[j].cost;
			   infile << "\t" << seg[i].Trip[j].capacity;
			   infile << "\t" << seg[i].Trip[j].leaveSP;
			   curC = seg[i].Trip[j].firstCus;
			   int preNode = seg[i].Trip[j].startNodeIdx;
			   double db_TimePoint = seg[i].Trip[j].leaveSP + problem->nodeSP[seg[i].Trip[j].startNodeIdx].load;
			   //infile << seg[i].Trip[j].startNodeIdx << "(" << seg[i].Trip[j].leaveSP << "|" << db_TimePoint  <<") -> ";
			   infile << "\tSP = " << seg[i].Trip[j].startNodeIdx;
			   while (curC > 0)
			   {
				   db_TimePoint += problem->c[preNode][curC];
				   if (db_TimePoint < problem->node[curC].sTW)  db_TimePoint = problem->node[curC].sTW;
				   //infile << curC << "(" << db_TimePoint << "|" << (db_TimePoint+problem->node[curC].duration) << ")" << "->";
				   infile << "\t" << curC;
				   preNode = curC;
				   db_TimePoint += problem->node[curC].duration;
				
				   curC = nextArr[curC];
			   }

			   if (seg[i].Trip[j].waitingS > 0)
			   {
				   db_TimePoint += problem->c[seg[i].Trip[j].lastCus][seg[i].Trip[j].waitingS];
				   //infile << seg[i].Trip[j].waitingS << "*" << "(" << db_TimePoint << "|" << (seg[i].Trip[j].endS - problem->c[seg[i].Trip[j].waitingS][seg[i].Trip[j].endNodeIdx]) << ") ->";
				   infile << "\t(" << seg[i].Trip[j].waitingS << ")";
			   }

			   //infile << seg[i].Trip[j].endNodeIdx << "(" << seg[i].Trip[j].endS << ")" << endl;
				infile << "\t(-1)" << endl;
			   //infile << endl << endl;

		   }
		   else if (TRIP_C2C == seg[i].Trip[j].Type)
		   {
			   infile << "\tC2C     ";
			   //infile << "\t\t\t Fitness: " << seg[i].Trip[j].fitness << endl;
			   //infile << "\t\t\t Cost: " << seg[i].Trip[j].cost << endl;
			   //infile << "\t\t\t Capacity: " << seg[i].Trip[j].capacity << endl;
			   //infile << "\t\t\t Arrived at: " << seg[i].Trip[j].arriveSP << endl;
			   //infile << "\t\t\t Leave at: " << seg[i].Trip[j].leaveSP << endl;
			   //infile << "\t\t\t Delivery Nbr: " << seg[i].Trip[j].numCus << endl;
			   //infile << "\t\t\t Assigned SP: " << seg[i].Trip[j].assSP << endl;
			   //infile << "\t\t\t Started from: " << seg[i].Trip[j].startNodeIdx << endl;
			   //infile << "\t\t\t End at: " << seg[i].Trip[j].endNodeIdx << endl;
			   //infile << "\t\t\t Waiting station: " << seg[i].Trip[j].waitingS << endl;
			   //infile << "\t\t\t EndS: " << seg[i].Trip[j].endS << endl;

			   infile << "\t(nCus = " << seg[i].Trip[j].numCus << ")";
			   //infile << "\t\t\t ROUTED: ";
			   //infile << "\t" << seg[i].Trip[j].cost;
			   infile << "\t" << seg[i].Trip[j].capacity;
			   infile << "\t" << seg[i].Trip[j].leaveSP;

			   curC = seg[i].Trip[j].firstCus;
			   int preNode = seg[i].Trip[j].startNodeIdx;
			   double db_TimePoint = seg[i].Trip[j].leaveSP;

			   //infile << seg[i].Trip[j].startNodeIdx << "(" << db_TimePoint << ") -> ";
			   //infile << "\tSP = " << seg[i].Trip[j].startNodeIdx << endl;

			   while (curC > 0)
			   {
				   db_TimePoint += problem->c[preNode][curC];
				   if (db_TimePoint < problem->node[curC].sTW)  db_TimePoint = problem->node[curC].sTW;
				   //infile << curC << "(" << db_TimePoint << "|" << (db_TimePoint+problem->node[curC].duration) << ")" << "->";
				   infile << "\t" << curC;
				   preNode = curC;
				   db_TimePoint += problem->node[curC].duration;
				
				   curC = nextArr[curC];
			   }

			   if (seg[i].Trip[j].waitingS > 0)
			   {
				   db_TimePoint += problem->c[seg[i].Trip[j].lastCus][seg[i].Trip[j].waitingS];
				   //infile << seg[i].Trip[j].waitingS << "*" << "(" << db_TimePoint << "|" << (seg[i].Trip[j].endS - problem->c[seg[i].Trip[j].waitingS][seg[i].Trip[j].endNodeIdx]) << ") ->";
				   infile << "\t(" << seg[i].Trip[j].waitingS << ")";
			   }

			   //infile << seg[i].Trip[j].endNodeIdx << "(" << seg[i].Trip[j].endS << ")" << endl;
			   infile << "\t(-1)" << endl;
			   //infile << endl << endl;
		   }
		   else if (TRIP_PICKUP == seg[i].Trip[j].Type)
		   {
			   infile << "\tPICKUP  ";
			   //infile << "\t\t\t Fitness: " << seg[i].Trip[j].fitness << endl;
			   //infile << "\t\t\t Cost: " << seg[i].Trip[j].cost << endl;
			   //infile << "\t\t\t Capacity: " << seg[i].Trip[j].capacity << endl;
			   //infile << "\t\t\t Arrived at: " << seg[i].Trip[j].arriveSP << endl;
			   //infile << "\t\t\t Leave at: " << seg[i].Trip[j].leaveSP << endl;
			   //infile << "\t\t\t Delivery Nbr: " << seg[i].Trip[j].numCus << endl;
			   //infile << "\t\t\t Assigned SP: " << seg[i].Trip[j].assSP << endl;
			   //infile << "\t\t\t Started from: " << seg[i].Trip[j].startNodeIdx << endl;
			   //infile << "\t\t\t End at SP: " << seg[i].Trip[j].endNodeIdx << endl;
			   //infile << "\t\t\t Waiting station: " << seg[i].Trip[j].waitingS << endl;
			   //infile << "\t\t\t EndS: " << seg[i].Trip[j].endS << endl;
			   infile << "\t(nCus = " << seg[i].Trip[j].numCus << ")";
			   //infile << "\t\t\t ROUTED: ";
			   //infile << "\t" << seg[i].Trip[j].cost;
			   infile << "\t" << seg[i].Trip[j].capacity;
			   infile << "\t" << seg[i].Trip[j].leaveSP;

			   curC = seg[i].Trip[j].firstCus;
			   int preNode = seg[i].Trip[j].startNodeIdx;
			   double db_TimePoint = seg[i].Trip[j].leaveSP;
			   
			   //infile << seg[i].Trip[j].startNodeIdx << "(" << db_TimePoint << ") -> ";
			   
			   while (curC > 0)
			   {
				   db_TimePoint += problem->c[preNode][curC];
				   if (db_TimePoint < problem->node[curC].sTW)  db_TimePoint = problem->node[curC].sTW;
				   //infile << curC << "(" << db_TimePoint << "|" << (db_TimePoint+problem->node[curC].duration) << ")" << "->";
				   infile << "\t" << curC;
				   preNode = curC;
				   db_TimePoint += problem->node[curC].duration;

				   curC = nextArr[curC];
			   }
			   if (seg[i].Trip[j].waitingS > 0)
			   {
				   db_TimePoint += problem->c[seg[i].Trip[j].lastCus][seg[i].Trip[j].waitingS];
				   //infile << seg[i].Trip[j].waitingS << "*" << "(" << db_TimePoint << "|" << (seg[i].Trip[j].endS - problem->nodeSP[seg[i].Trip[j].endNodeIdx].unload - problem->c[seg[i].Trip[j].waitingS][seg[i].Trip[j].endNodeIdx]) << ") ->";
				   infile << "\t(" << seg[i].Trip[j].waitingS << ")";
			   }
			   //infile << seg[i].Trip[j].endNodeIdx << "(" << (seg[i].Trip[j].endS - problem->nodeSP[seg[i].Trip[j].endNodeIdx].unload) << "|" << seg[i].Trip[j].endS << ")" << endl << endl;	
			   infile << "\tSP = " << seg[i].Trip[j].endNodeIdx << endl;
			   //infile << endl << endl;
		   }
	   }
   }

   // Solution format
   infile << "For each vehicle: " << endl;
   infile << "\t Vehicle Id \t Number of trips \t Cost of Vehicle " << endl;
   infile << "\t Vehicle Id \t Trip Id \t Type of trip \t Number of customers \t Max capacity \t leaveSP" << endl;
}

bool Solution::Check_TW(int inNodeIdx, double db_TimePoint, bool isWaiting)
{
	switch (Get_Node_Type(inNodeIdx))
	{
	case NODE_PICKUP:
	case NODE_DELIVERY:
	case NODE_C2C_PICKUP:
	case NODE_C2C_DELIVERY:
		//if(!PDSINRANGE(db_TimePoint, problem->node[inNodeIdx].sTW, problem->node[inNodeIdx].eTW))
		if (db_TimePoint > problem->node[inNodeIdx].eTW)
			return false;
		break;
	case NODE_SUPPLY_POINT:
		if (isWaiting){ // 
			if (db_TimePoint > problem->nodeSP[inNodeIdx].eTW1)
				return false; 
		} else { // no waiting -> in time windows
			if(!PDSINRANGE(db_TimePoint, problem->nodeSP[inNodeIdx].sTW1, problem->nodeSP[inNodeIdx].eTW1))
			return false;
		}
	default:
		break;
	}

	return true;
}

double Solution::Get_Cost_A_Vehice_160616(int inVehIdx)
{
	double dbCostTmp = 0;
	double dbLegCost = 0;

    {  
	
		if (inVehIdx == 3) {
			//cout << "unit test" <<endl;
		//	Show_A_Trip(inVehIdx, 1);
		//	Show_A_Trip(inVehIdx, 2);
		//	Show_A_Trip(inVehIdx, 3);
		//	Show_A_Trip(inVehIdx, 4);
		//	Show_A_Trip(inVehIdx, 5);
		//	Show_A_Trip(inVehIdx, 6);
		//	Show_A_Trip(inVehIdx, 7);
		//	Show_A_Trip(inVehIdx, 8);
		}
		//Show_A_Vehicle(inVehIdx);
#if Q_DEBUG_GET_COST
	   cout << "Edges of vehicle " << inVehIdx << ": ";
#endif
	   for (int j = 1; j <= seg[inVehIdx].numTrips; j++)
	   {
		   if (PDS_INFINITY == dbCostTmp)
		   {
			   cout << endl << "Get_Cost_A_Vehice::Check vehicle " << inVehIdx << " trip " << (j-1) << endl; getchar();
			   Show_A_Trip(inVehIdx, j-1);
			   Show_A_Trip(inVehIdx, j);
		   }

		   if ((1 == j) && (seg[inVehIdx].Trip[j].startNodeIdx != 0)) // first trip, check 0 -> startNodeIdx
		   {
#if Q_DEBUG_GET_COST
			   cout << "(0," << seg[inVehIdx].Trip[j].startNodeIdx << "," << problem->c[0][seg[inVehIdx].Trip[j].startNodeIdx] << ") ";
#endif
			   dbCostTmp += problem->c[0][seg[inVehIdx].Trip[j].startNodeIdx];
		   } 



		   // Check startNodeIdx -> firstCus
		   if ((1 == j) && (seg[inVehIdx].Trip[j].startNodeIdx == 0)) {
#if Q_DEBUG_GET_COST
				   cout << "(" << seg[inVehIdx].Trip[j].startNodeIdx << "," << seg[inVehIdx].Trip[j].firstCus << "," << problem->c[seg[inVehIdx].Trip[j].startNodeIdx][seg[inVehIdx].Trip[j].firstCus] << ") ";
#endif
				   dbCostTmp += problem->c[seg[inVehIdx].Trip[j].startNodeIdx][seg[inVehIdx].Trip[j].firstCus];

		   } else {
			   if (((Get_Node_Type(seg[inVehIdx].Trip[j].startNodeIdx) == NODE_SUPPLY_POINT)) && (seg[inVehIdx].Trip[j].Type == TRIP_DELIVERY)) {
#if Q_DEBUG_GET_COST
				   cout << "(" << seg[inVehIdx].Trip[j].startNodeIdx << "," << seg[inVehIdx].Trip[j].firstCus << "," << problem->c[seg[inVehIdx].Trip[j].startNodeIdx][seg[inVehIdx].Trip[j].firstCus] << ") ";
#endif
				   dbCostTmp += problem->c[seg[inVehIdx].Trip[j].startNodeIdx][seg[inVehIdx].Trip[j].firstCus];

			   }
		   }


		   // firstCus -> ... -> lastCust
		   {
   	 		   int curC = seg[inVehIdx].Trip[j].firstCus;
			   int preNode = curC;
			   while (curC > 0)
			   {
					curC = nextArr[curC];
					if (curC > 0)
					{
#if Q_DEBUG_GET_COST
						cout << "(" << preNode << "," << curC << "," << problem->c[preNode][curC] << ") ";
#endif
						dbCostTmp += problem->c[preNode][curC];


					}
					preNode = curC;
			   }

		   } // end of first cust -> ... -> lastcust

		   // lastCust -> next StartNodeIdx 
		   if (seg[inVehIdx].numTrips == j) // last trip
			{
				   if (seg[inVehIdx].Trip[j].waitingS > 0)
				   {
#if Q_DEBUG_GET_COST
					   cout << "(" << seg[inVehIdx].Trip[j].lastCus << "," << seg[inVehIdx].Trip[j].waitingS << "," << problem->c[seg[inVehIdx].Trip[j].lastCus][seg[inVehIdx].Trip[j].waitingS] << ") ";
#endif
					   dbCostTmp += problem->c[seg[inVehIdx].Trip[j].lastCus][seg[inVehIdx].Trip[j].waitingS];
#if Q_DEBUG_GET_COST
					   cout << "(" << seg[inVehIdx].Trip[j].waitingS << "," << seg[inVehIdx].Trip[j].endNodeIdx << "," << problem->c[seg[inVehIdx].Trip[j].waitingS][seg[inVehIdx].Trip[j].endNodeIdx] << ") ";
#endif
					   dbCostTmp += problem->c[seg[inVehIdx].Trip[j].waitingS][seg[inVehIdx].Trip[j].endNodeIdx];

				   } else
				   {
#if Q_DEBUG_GET_COST
						cout << "(" << seg[inVehIdx].Trip[j].lastCus << "," << seg[inVehIdx].Trip[j].endNodeIdx << "," << problem->c[seg[inVehIdx].Trip[j].lastCus][seg[inVehIdx].Trip[j].endNodeIdx] << ") ";
#endif
						dbCostTmp += problem->c[seg[inVehIdx].Trip[j].lastCus][seg[inVehIdx].Trip[j].endNodeIdx];


				   }
				   // if last trip is pickup so move SP to Depot
				   if (seg[inVehIdx].Trip[j].Type == TRIP_PICKUP)
				   {
#if Q_DEBUG_GET_COST
					   cout << "(" << seg[inVehIdx].Trip[j].endNodeIdx << "," << 0 << ") ";
#endif
					   dbCostTmp += problem->c[seg[inVehIdx].Trip[j].endNodeIdx][0];
				   }

			   } else // check joint-point between current trip and next trip because this is not last trip
			   {
				   if ((seg[inVehIdx].Trip[j].Type == TRIP_C2C) || (seg[inVehIdx].Trip[j].Type == TRIP_DELIVERY)) {
					   if (Get_Node_Type(seg[inVehIdx].Trip[j].endNodeIdx) == NODE_SUPPLY_POINT) {
						    if (seg[inVehIdx].Trip[j].waitingS > 0) {
#if Q_DEBUG_GET_COST
							   cout << "(" << seg[inVehIdx].Trip[j].lastCus << "," << seg[inVehIdx].Trip[j].waitingS << "," << problem->c[seg[inVehIdx].Trip[j].lastCus][seg[inVehIdx].Trip[j].waitingS] << ") ";
#endif
							   dbCostTmp += problem->c[seg[inVehIdx].Trip[j].lastCus][seg[inVehIdx].Trip[j].waitingS];
#if Q_DEBUG_GET_COST
							   cout << "(" << seg[inVehIdx].Trip[j].waitingS << "," << seg[inVehIdx].Trip[j].endNodeIdx << "," << problem->c[seg[inVehIdx].Trip[j].waitingS][seg[inVehIdx].Trip[j].endNodeIdx] << ") ";
#endif
							   dbCostTmp += problem->c[seg[inVehIdx].Trip[j].waitingS][seg[inVehIdx].Trip[j].endNodeIdx];



							} else {
#if Q_DEBUG_GET_COST
						   cout << "(" << seg[inVehIdx].Trip[j].lastCus << "," << seg[inVehIdx].Trip[j].endNodeIdx << "," << problem->c[seg[inVehIdx].Trip[j].lastCus][seg[inVehIdx].Trip[j].endNodeIdx] << ") ";
#endif
						   dbCostTmp += problem->c[seg[inVehIdx].Trip[j].lastCus][seg[inVehIdx].Trip[j].endNodeIdx];


							}
					   } else {
#if Q_DEBUG_GET_COST
						   cout << "(" << seg[inVehIdx].Trip[j].lastCus << "," << seg[inVehIdx].Trip[j].endNodeIdx << "," << problem->c[seg[inVehIdx].Trip[j].lastCus][seg[inVehIdx].Trip[j].endNodeIdx] << ") ";
#endif
						   dbCostTmp += problem->c[seg[inVehIdx].Trip[j].lastCus][seg[inVehIdx].Trip[j].endNodeIdx];


					   }
				   } else if (seg[inVehIdx].Trip[j].Type == TRIP_PICKUP) {
						if (seg[inVehIdx].Trip[j].waitingS > 0) {
#if Q_DEBUG_GET_COST
						cout << "(" << seg[inVehIdx].Trip[j].lastCus << "," << seg[inVehIdx].Trip[j].waitingS << "," << problem->c[seg[inVehIdx].Trip[j].lastCus][seg[inVehIdx].Trip[j].waitingS] << ") ";
#endif
						dbCostTmp += problem->c[seg[inVehIdx].Trip[j].lastCus][seg[inVehIdx].Trip[j].waitingS];
#if Q_DEBUG_GET_COST
						cout << "(" << seg[inVehIdx].Trip[j].waitingS << "," << seg[inVehIdx].Trip[j].endNodeIdx << "," << problem->c[seg[inVehIdx].Trip[j].waitingS][seg[inVehIdx].Trip[j].endNodeIdx] << ") ";
#endif
						dbCostTmp += problem->c[seg[inVehIdx].Trip[j].waitingS][seg[inVehIdx].Trip[j].endNodeIdx];


						} else {
#if Q_DEBUG_GET_COST
						   cout << "(" << seg[inVehIdx].Trip[j].lastCus << "," << seg[inVehIdx].Trip[j].endNodeIdx << "," << problem->c[seg[inVehIdx].Trip[j].lastCus][seg[inVehIdx].Trip[j].endNodeIdx] << ") ";
#endif
						   dbCostTmp += problem->c[seg[inVehIdx].Trip[j].lastCus][seg[inVehIdx].Trip[j].endNodeIdx];		


						}

					   if (seg[inVehIdx].Trip[j+1].Type == TRIP_DELIVERY) { // case p - sp - sp -d
						   if (seg[inVehIdx].Trip[j].endNodeIdx != seg[inVehIdx].Trip[j+1].startNodeIdx) {
							   if (seg[inVehIdx].Trip[j+1].waitingS1 > 0) {
#if Q_DEBUG_GET_COST
									cout << "(*" << seg[inVehIdx].Trip[j].endNodeIdx << "," << seg[inVehIdx].Trip[j+1].waitingS1 << "*," << problem->c[seg[inVehIdx].Trip[j].endNodeIdx][seg[inVehIdx].Trip[j+1].waitingS1] << ") ";
#endif
									dbCostTmp += problem->c[seg[inVehIdx].Trip[j].endNodeIdx][seg[inVehIdx].Trip[j+1].waitingS1];
#if Q_DEBUG_GET_COST
									cout << "(*" << seg[inVehIdx].Trip[j+1].waitingS1 << "," << seg[inVehIdx].Trip[j+1].startNodeIdx << "*," << problem->c[seg[inVehIdx].Trip[j+1].waitingS1][seg[inVehIdx].Trip[j+1].startNodeIdx] << ") ";
#endif
									dbCostTmp += problem->c[seg[inVehIdx].Trip[j+1].waitingS1][seg[inVehIdx].Trip[j+1].startNodeIdx];

							   } else {
#if Q_DEBUG_GET_COST
									cout << "(*" << seg[inVehIdx].Trip[j].endNodeIdx << "," << seg[inVehIdx].Trip[j+1].startNodeIdx << "*," << problem->c[seg[inVehIdx].Trip[j].endNodeIdx][seg[inVehIdx].Trip[j+1].startNodeIdx] << ") ";
#endif
									dbCostTmp += problem->c[seg[inVehIdx].Trip[j].endNodeIdx][seg[inVehIdx].Trip[j+1].startNodeIdx];
							   }
						   }

					   } else {
#if Q_DEBUG_GET_COST
						   cout << "(" << seg[inVehIdx].Trip[j].endNodeIdx << "," << seg[inVehIdx].Trip[j+1].firstCus << "," << problem->c[seg[inVehIdx].Trip[j].endNodeIdx][seg[inVehIdx].Trip[j+1].firstCus] << ") ";
#endif
						   dbCostTmp += problem->c[seg[inVehIdx].Trip[j].endNodeIdx][seg[inVehIdx].Trip[j+1].firstCus];
	//				   		if (false == (Check_TW(seg[inVehIdx].Trip[j+1].firstCus, dbCostTmp))) { //check time window for endNodeIdx
	//#if Q_DEBUG_GET_COST
	//					   cout << "vioTWSP" << endl;
	//#endif
	//					   return -1;
	//						}

					   }
				   }
			   }


#if Q_DEBUG_CHK_SOL	   
		   cout << endl << "\t Trip " << j << " cost=fitness = " << dbCostTmp - dbLegCost << endl << endl;
#endif
		   seg[inVehIdx].Trip[j].cost = dbCostTmp - dbLegCost;
		   dbLegCost = dbCostTmp;
	}
#if Q_DEBUG_GET_COST
	   cout << endl;
#endif
	}

	return dbCostTmp;
}

//This is good
double Solution::Get_Cost_A_Vehice(int inVehIdx)
{
	double dbCostTmp = 0;
	double dbLegCost = 0;

    {  
#if Q_DEBUG_GET_COST
	   cout << "Edges of vehicle " << inVehIdx << ": ";
#endif
	   //if (6 == inVehIdx)
	   //{
		  // int quangnn=0;
		  // Show_A_Vehicle(inVehIdx);
	   //}
	   for (int j = 1; j <= seg[inVehIdx].numTrips; j++)
	   {
		   if (PDS_INFINITY == dbCostTmp)
		   {
			   cout << endl << "Get_Cost_A_Vehice::Check vehicle " << inVehIdx << " trip " << (j-1) << endl; getchar();
			   Show_A_Trip(inVehIdx, j-1);
			   Show_A_Trip(inVehIdx, j);
		   }

		   if ((1 == j) && (seg[inVehIdx].Trip[j].startNodeIdx != 0)) // first trip
		   {
#if Q_DEBUG_GET_COST
			   cout << "(0," << seg[inVehIdx].Trip[j].startNodeIdx << "," << problem->c[0][seg[inVehIdx].Trip[j].startNodeIdx] << ") ";
#endif
			   dbCostTmp += problem->c[0][seg[inVehIdx].Trip[j].startNodeIdx];
		   }

		   {
#if Q_DEBUG_GET_COST
			   cout << "(" << seg[inVehIdx].Trip[j].startNodeIdx << "," << seg[inVehIdx].Trip[j].firstCus << "," << problem->c[seg[inVehIdx].Trip[j].startNodeIdx][seg[inVehIdx].Trip[j].firstCus] << ") ";
#endif
			   dbCostTmp += problem->c[seg[inVehIdx].Trip[j].startNodeIdx][seg[inVehIdx].Trip[j].firstCus];
	 		   int curC = seg[inVehIdx].Trip[j].firstCus;
			   int preNode = curC;
			   while (curC > 0)
			   {
					curC = nextArr[curC];
					if (curC > 0)
					{
#if Q_DEBUG_GET_COST
						cout << "(" << preNode << "," << curC << "," << problem->c[preNode][curC] << ") ";
#endif
						dbCostTmp += problem->c[preNode][curC];
					}
					preNode = curC;
			   }
			   if (seg[inVehIdx].numTrips == j) // last trip
			   {
				   if (seg[inVehIdx].Trip[j].waitingS > 0)
				   {
#if Q_DEBUG_GET_COST
					   cout << "(" << seg[inVehIdx].Trip[j].lastCus << "," << seg[inVehIdx].Trip[j].waitingS << "," << problem->c[seg[inVehIdx].Trip[j].lastCus][seg[inVehIdx].Trip[j].waitingS] << ") ";
#endif
					   dbCostTmp += problem->c[seg[inVehIdx].Trip[j].lastCus][seg[inVehIdx].Trip[j].waitingS];
#if Q_DEBUG_GET_COST
					   cout << "(" << seg[inVehIdx].Trip[j].waitingS << "," << seg[inVehIdx].Trip[j].endNodeIdx << "," << problem->c[seg[inVehIdx].Trip[j].waitingS][seg[inVehIdx].Trip[j].endNodeIdx] << ") ";
#endif
					   dbCostTmp += problem->c[seg[inVehIdx].Trip[j].waitingS][seg[inVehIdx].Trip[j].endNodeIdx];
				   } else
				   {
#if Q_DEBUG_GET_COST
						cout << "(" << seg[inVehIdx].Trip[j].lastCus << "," << seg[inVehIdx].Trip[j].endNodeIdx << "," << problem->c[seg[inVehIdx].Trip[j].lastCus][seg[inVehIdx].Trip[j].endNodeIdx] << ") ";
#endif
						dbCostTmp += problem->c[seg[inVehIdx].Trip[j].lastCus][seg[inVehIdx].Trip[j].endNodeIdx];
				   }
				   // if last trip is pickup so move SP to Depot
				   if (seg[inVehIdx].Trip[j].Type == TRIP_PICKUP)
				   {
#if Q_DEBUG_GET_COST
					   cout << "(" << seg[inVehIdx].Trip[j].endNodeIdx << "," << 0 << ") ";
#endif
					   dbCostTmp += problem->c[seg[inVehIdx].Trip[j].endNodeIdx][0];
				   }

			   } else // check joint-point between 2 trips
			   {
				   if (seg[inVehIdx].Trip[j].lastCus == seg[inVehIdx].Trip[j+1].startNodeIdx)
				   {
				   } else if (seg[inVehIdx].Trip[j].endNodeIdx == seg[inVehIdx].Trip[j+1].startNodeIdx)
				   {
					   if (seg[inVehIdx].Trip[j].waitingS > 0)
					   {
#if Q_DEBUG_GET_COST
						   cout << "(" << seg[inVehIdx].Trip[j].lastCus << "," << seg[inVehIdx].Trip[j].waitingS << "," << problem->c[seg[inVehIdx].Trip[j].lastCus][seg[inVehIdx].Trip[j].waitingS] << ") ";
#endif
						   dbCostTmp += problem->c[seg[inVehIdx].Trip[j].lastCus][seg[inVehIdx].Trip[j].waitingS];
#if Q_DEBUG_GET_COST
						   cout << "(" << seg[inVehIdx].Trip[j].waitingS << "," << seg[inVehIdx].Trip[j].endNodeIdx << "," << problem->c[seg[inVehIdx].Trip[j].waitingS][seg[inVehIdx].Trip[j].endNodeIdx] << ") ";
#endif
						   dbCostTmp += problem->c[seg[inVehIdx].Trip[j].waitingS][seg[inVehIdx].Trip[j].endNodeIdx];
					   } else
					   {
#if Q_DEBUG_GET_COST
						   cout << "(" << seg[inVehIdx].Trip[j].lastCus << "," << seg[inVehIdx].Trip[j].endNodeIdx << "," << problem->c[seg[inVehIdx].Trip[j].lastCus][seg[inVehIdx].Trip[j].endNodeIdx] << ") ";
#endif
						   dbCostTmp += problem->c[seg[inVehIdx].Trip[j].lastCus][seg[inVehIdx].Trip[j].endNodeIdx];
					   }

				   } else 
				   {
#if Q_DEBUG_GET_COST
					   cout << "(" << seg[inVehIdx].Trip[j].lastCus << "," << seg[inVehIdx].Trip[j].endNodeIdx << "," << problem->c[seg[inVehIdx].Trip[j].lastCus][seg[inVehIdx].Trip[j].endNodeIdx] << ") ";
#endif
					   dbCostTmp += problem->c[seg[inVehIdx].Trip[j].lastCus][seg[inVehIdx].Trip[j].endNodeIdx];
#if Q_DEBUG_GET_COST
					   cout << "(*" << seg[inVehIdx].Trip[j].endNodeIdx << "," << seg[inVehIdx].Trip[j+1].startNodeIdx << "*," << problem->c[seg[inVehIdx].Trip[j].endNodeIdx][seg[inVehIdx].Trip[j+1].startNodeIdx] << ") ";
#endif
					   dbCostTmp += problem->c[seg[inVehIdx].Trip[j].endNodeIdx][seg[inVehIdx].Trip[j+1].startNodeIdx];
				   }
			   }
		   }
#if Q_DEBUG_CHK_SOL	   
		   cout << endl << "\t Trip " << j << " cost=fitness = " << dbCostTmp - dbLegCost << endl;
#endif
		   dbLegCost = dbCostTmp;
	}
#if Q_DEBUG_GET_COST
	   cout << endl;
#endif
	}

	return dbCostTmp;
}

void Solution::Show_A_Vehicle2(VRPSegment veh)
{
	//for (int i = 1; i <= numVeh; i++) // to consildation, we do not use 0 index.
    {  

	   cout << "Edges of specific vehicle: ";
	   for (int j = 1; j <= veh.numTrips; j++)
	   {
		   //if (1 == j) // first trip
		   {
			   cout << "(" << veh.Trip[j].startNodeIdx << "," << veh.Trip[j].firstCus << ") ";
	 		   int curC = veh.Trip[j].firstCus;
			   int preNode = curC;
			   while (curC > 0)
			   {
					curC = nextArr[curC];
					if (curC > 0)
					{
						cout << "(" << preNode << "," << curC << ") ";
					}
					preNode = curC;
			   }
			   if (veh.numTrips == j) // last trip
			   {
				   if (veh.Trip[j].waitingS > 0)
				   {
					   cout << "(" << veh.Trip[j].lastCus << "," << veh.Trip[j].waitingS << ") ";
					   cout << "(" << veh.Trip[j].waitingS << "," << veh.Trip[j].endNodeIdx << ") ";
				   } else
				   {
						cout << "(" << veh.Trip[j].lastCus << "," << veh.Trip[j].endNodeIdx << ") ";
				   }

				   // if last trip is pickup so move SP to Depot
				   if (veh.Trip[j].Type == TRIP_PICKUP)
				   {
					   cout << "(" << veh.Trip[j].endNodeIdx << "," << 0 << ") ";
				   }
			   } else // check joint-point between 2 trips
			   {
				   if (veh.Trip[j].lastCus == veh.Trip[j+1].startNodeIdx)
				   {
					   //cout << "(" << seg[inVehIdx].Trip[j].lastCus << "," << seg[inVehIdx].Trip[j+1].startNodeIdx << ") ";
				   } else if (veh.Trip[j].endNodeIdx == veh.Trip[j+1].startNodeIdx)
				   {
					   if (veh.Trip[j].waitingS > 0)
					   {
						   cout << "(" << veh.Trip[j].lastCus << "," << veh.Trip[j].waitingS << ") ";
						   cout << "(" << veh.Trip[j].waitingS << "," << veh.Trip[j].endNodeIdx << ") ";
					   } else
					   {
							cout << "(" << veh.Trip[j].lastCus << "," << veh.Trip[j].endNodeIdx << ") ";
					   }

				   } else 
				   {
					   cout << "(" << veh.Trip[j].lastCus << "," << veh.Trip[j].endNodeIdx << ") ";
					   cout << "(*" << veh.Trip[j].endNodeIdx << "," << veh.Trip[j+1].startNodeIdx << "*) ";
				   }
			   }
		   }
	   }
	   cout << endl;
	}
	
}

void Solution::Show_A_Vehicle(int inVehIdx)
{
	//for (int i = 1; i <= numVeh; i++) // to consildation, we do not use 0 index.
    {  

	   cout << "Edges of vehicle " << inVehIdx << ": ";
	   for (int j = 1; j <= seg[inVehIdx].numTrips; j++)
	   {
		   //if (1 == j) // first trip
		   {
			   cout << "(" << seg[inVehIdx].Trip[j].startNodeIdx << "," << seg[inVehIdx].Trip[j].firstCus << ") ";
	 		   int curC = seg[inVehIdx].Trip[j].firstCus;
			   int preNode = curC;
			   while (curC > 0)
			   {
					curC = nextArr[curC];
					if (curC > 0)
					{
						cout << "(" << preNode << "," << curC << ") ";
					}
					preNode = curC;
			   }
			   if (seg[inVehIdx].numTrips == j) // last trip
			   {
				   if (seg[inVehIdx].Trip[j].waitingS > 0)
				   {
					   cout << "(" << seg[inVehIdx].Trip[j].lastCus << "," << seg[inVehIdx].Trip[j].waitingS << ") ";
					   cout << "(" << seg[inVehIdx].Trip[j].waitingS << "," << seg[inVehIdx].Trip[j].endNodeIdx << ") ";
				   } else
				   {
						cout << "(" << seg[inVehIdx].Trip[j].lastCus << "," << seg[inVehIdx].Trip[j].endNodeIdx << ") ";
				   }

				   // if last trip is pickup so move SP to Depot
				   if (seg[inVehIdx].Trip[j].Type == TRIP_PICKUP)
				   {
					   cout << "(" << seg[inVehIdx].Trip[j].endNodeIdx << "," << 0 << ") ";
				   }
			   } else // check joint-point between 2 trips
			   {
				   if (seg[inVehIdx].Trip[j].lastCus == seg[inVehIdx].Trip[j+1].startNodeIdx)
				   {
					   //cout << "(" << seg[inVehIdx].Trip[j].lastCus << "," << seg[inVehIdx].Trip[j+1].startNodeIdx << ") ";
				   } else if (seg[inVehIdx].Trip[j].endNodeIdx == seg[inVehIdx].Trip[j+1].startNodeIdx)
				   {
					   if (seg[inVehIdx].Trip[j].waitingS > 0)
					   {
						   cout << "(" << seg[inVehIdx].Trip[j].lastCus << "," << seg[inVehIdx].Trip[j].waitingS << ") ";
						   cout << "(" << seg[inVehIdx].Trip[j].waitingS << "," << seg[inVehIdx].Trip[j].endNodeIdx << ") ";
					   } else
					   {
							cout << "(" << seg[inVehIdx].Trip[j].lastCus << "," << seg[inVehIdx].Trip[j].endNodeIdx << ") ";
					   }

				   } else 
				   {
					   cout << "(" << seg[inVehIdx].Trip[j].lastCus << "," << seg[inVehIdx].Trip[j].endNodeIdx << ") ";
					   cout << "(*" << seg[inVehIdx].Trip[j].endNodeIdx << "," << seg[inVehIdx].Trip[j+1].startNodeIdx << "*) ";
				   }
			   }
		   }
	   }
	   cout << endl;
	}
	
}
 /* C2C-PICKUP  : nSP + 1						-> nOrder + nSP
 * C2C-DELIVERY: nOrder + nSP + 1				-> nOrder + nOrder + nSP
 * PICKUP	   : nOrder + nOrder + nSP + 1		-> nP + nOrder + nOrder + nSP
 * DELIVERY	   : nP + nOrder + nOrder + nSP + 1 -> nD + nP + nOrder + nOrder + nSP
 */
bool Solution::Check_Solution(double *dbTotalCost)
{
	bool bOK = true;
	double dbTransCostTot = 0;
	int inFixedCost = problem->g_inFixedCost;
	
#if Q_DEBUG_CHK_SOL
	cout << "Check solution " << endl;
#endif
	// All demands must be routed
	for (int i=nSP + 1; i<=nD + nP + nOrder + nOrder + nSP; i++)
	{
		if (!routed[i])
		{
			cout << "\t demand " << i << " not routed" << endl; getchar();
			Where_Are_Nodes();
			bOK = false;
			return false;
		}
	}

	if (false == Check_vioTW()) {
#if Q_DEBUG_CHK_SOL
		cout << "vioTW" << endl;
#endif
		return false;
	}

	// Check all trips, capacity, return cost of each trip
	for (int i = 1; i <= numVeh; i++) // to consildation, we do not use 0 index.
    {  
#if Q_DEBUG_CHK_SOL
	   cout << ">> Checking vehicle" << i << endl;
#endif
	   seg[i].cost = 0;
	   for (int j = 1; j <= seg[i].numTrips; j++)
	   {
		   //Backhaul
		   //if (j>1)
		   //{
			  // if ((seg[i].Trip[j].Type == seg[i].Trip[j-1].Type) && (seg[i].Trip[j].Type == TRIP_C2C))
			  // {
				 //  cout << "Hit backhaul" << endl; getchar();
				 //  return false;
			  // }
		   //}

		   if (false == Valid_A_Trip(i, j))
		   {
			   //Show_A_Trip(i, j);		
#if Q_CRIT_SKIP
			   cout << "Vehicle " << i << " trip " << j << " failed *ln" << __LINE__; getchar();
#endif
			   return false; 
			   //showSolution();
		   }

		   // Check joint-trip

		   //dbTransCostTot += seg[i].Trip[j].cost;
		   //seg[i].cost += seg[i].Trip[j].cost;

		   //if ((j > 1))
		   //{
			  // if ((seg[i].Trip[j].startNodeIdx != seg[i].Trip[j-1].endNodeIdx) && (seg[i].Trip[j].startNodeIdx != seg[i].Trip[j-1].lastCus))
			  // {
				 //  dbTransCostTot += problem->c[seg[i].Trip[j-1].endNodeIdx][seg[i].Trip[j].startNodeIdx];
				 //  seg[i].cost += problem->c[seg[i].Trip[j-1].endNodeIdx][seg[i].Trip[j].startNodeIdx];
			  // } else if (seg[i].Trip[j].startNodeIdx == seg[i].Trip[j-1].lastCus)
			  // {
				 //  dbTransCostTot -= problem->c[seg[i].Trip[j-1].lastCus][seg[i].Trip[j-1].endNodeIdx];
				 //  dbTransCostTot += problem->c[seg[i].Trip[j-1].lastCus][seg[i].Trip[j].startNodeIdx];

				 //  seg[i].cost -= problem->c[seg[i].Trip[j-1].lastCus][seg[i].Trip[j-1].endNodeIdx];
				 //  seg[i].cost += problem->c[seg[i].Trip[j-1].lastCus][seg[i].Trip[j].startNodeIdx];
			  // }
		   //}
	   }
	   seg[i].cost = Get_Cost_A_Vehice_160616(i);

	   if (seg[i].cost == -1) {
			return false;
	   }
#if Q_DEBUG_CHK_SOL
	   cout << ">> Total trans cost of vehicle" << i << ": " << seg[i].cost << endl << endl;
#endif
	   if (seg[i].cost == PDS_INFINITY)
	   {
		   cout << " Infinity cost for vehicle *ln" << __LINE__ << i; getchar();
		   for (int ii = 1; ii <= seg[i].numTrips; ii++)
		   {
			   Show_A_Trip(i, ii);
		   }
		   return false;
	   }

	   dbTransCostTot += seg[i].cost;
   }

	if (true == bOK)
	{
#if Q_DEBUG_CHK_SOL
		cout << "\t ... OK!" << endl;
		cout << "\t\t Total vehicle: " << numVeh << endl;
		cout << "\t\t Cost: " << (dbTransCostTot + (numVeh)*inFixedCost) << endl;
#endif
	}
	*dbTotalCost = dbTransCostTot + numVeh*inFixedCost;

	//cout << dbTransCostTot << endl; getchar();

	return (bOK);
}
#if CP_PORTING
void Solution::initSol_CP(int typeofseed, int typeofINIT, int typeofAssCusPToSP, int valueFEE)
{
   int i,j, nSP1 = nSP + 1;
   numCusPRouted = new int[nSP1];
   numCusDRouted = new int[nSP1];
   numCusPSP = new int[nSP1]; // number of cusP in each supply point
   CusPSP = new int*[nSP1]; // CusPSP[sp][j] = id of customerP #j assigned to sp; j = 1,..,numCusPSP[sp] 
  
   CusPSP[0] = new int[1];
   for (int i=1; i<=nSP; i++) 
   {
	  //numTripDSP[i]=0;
	  CusPSP[i] = new int[MAX_NUM_CUSP_ASSIGNSP]; //define in VRPNodeP.h = 500
  }
   
   for (i=1; i<=nSP; i++) 
   {   
       numCusDRouted[i]=0; 
	   numCusPRouted[i]=0;
   }
   numCusC2CRouted = 0;
   
   routed = new bool[totalNODE1];

   for (i=startidC2C;i<=endidD;i++) {routed[i]=false;nextArr[i]=0;}
  
   nextArrTemp = new int[totalNODE1];
   nextArrB = new int [totalNODE1];
   routedTemp = new bool[totalNODE1];
   
  
   numVeh=0; 			   							
   bool cont=1;
   int numTrip, startSP, nextSP,type;
   double leave_SP;
   

   AssignCusPToSP(typeofAssCusPToSP);
   cout<<"FINISH OUTSIDE AssignCusPToSP"<<endl;
   while (cont) //each loop create one vehicle which consists P OR/AND D:
   {
	   numTrip = -1;
	   for (startSP = 1;startSP<=nSP;startSP++)
		   if (numCusPRouted[startSP] < numCusPSP[startSP] || numCusDRouted[startSP] < problem->numCusDSP[startSP]) break;

       if (startSP <= nSP) // still exists unrouted customers:
	   {
		   if (numCusPRouted[startSP] < numCusPSP[startSP]) // exist unrouted pickup customers:
		   {
			   //cout<<"Create_FirstPickupTripLeavingDepot,,,"<<endl;
			   Create_FirstPickupTripLeavingDepot(startSP,numTrip);
			   //cout<<"CALL CreateC2CTrip_BeforePickupTrip"<<endl;
			   if (CreateC2CTrip_BeforePickupTrip(numVeh,numTrip,startSP,0,0)) 
			   {
				   numTrip++;
				   /*cout<<"First C2C trip of veh "<<numVeh<<": cost = "<<seg[numVeh].Trip[0].cost<<"; firstC = "<<seg[numVeh].Trip[0].firstCus<<"; lastC = "<<seg[numVeh].Trip[0].lastCus<<endl;
				   cout<<"Next is Ptrip: cost = "<<seg[numVeh].Trip[1].cost<<"; endS = "<<seg[numVeh].Trip[1].endS<<"; assSP = "<<seg[numVeh].Trip[1].assSP<<"; lastC = "<<seg[numVeh].Trip[1].lastCus<<endl;
			       */
			   }
			   //cout<<"XONG CreateC2CTrip_BeforePickupTrip"<<endl;
			   //else  cout<<"First pickup trip of veh "<<numVeh<<": cost = "<<seg[numVeh].Trip[0].cost<<"; endS = "<<seg[numVeh].Trip[0].endS<<"; leaveSP = "<<seg[numVeh].Trip[0].leaveSP<<"; assSP = "<<seg[numVeh].Trip[0].assSP<<"; lastC = "<<seg[numVeh].Trip[0].lastCus<<endl;
			   if (numCusDRouted[startSP] < problem->numCusDSP[startSP]) //exist also delivery customers not routed:
			   {
			       leave_SP =  seg[numVeh].Trip[numTrip].leaveSP + problem->nodeSP[startSP].load; //ok 10/11/2013
				   //cout<<"@initSol: leaveSP of Trip("<<numVeh<<", "<<numTrip<<") = "<<leave_SP<<endl;
	   			   numTrip ++; 
				   //cout<<"CALL Create_DeliveryTrip"<<endl;
			  	   type = Create_DeliveryTrip(startSP, numTrip, leave_SP, nextSP, typeofseed, typeofINIT, valueFEE);
				   //cout<<"FINI Create_DeliveryTrip"<<endl;
				   //returns 0 or 1 or 2: 0: create startSP-d - (C2C)-depot; 1: create startSP-d-(C2C)-p-nextSP; 2: create startSP-d-(C2C)-nextSP
			   }
			   else
			   {
			       leave_SP =  seg[numVeh].Trip[numTrip].leaveSP;
				   int preT = numTrip;
				   //BIET LAM THE NAO: Goi ham create ca P or D connect with previous Ptrip(P,startSP)
				   //cout<<"CALL Create_PickupTrip"<<endl;
			  	   type = Create_PickupTrip(preT, startSP, numTrip, leave_SP, nextSP, typeofseed, typeofINIT, valueFEE);
				   //returns 0 or 1 or 2: 0: cannot create new trip --> (p-startSP) already last trip; 1: created a new pickup trip leaving startSP; 2: a NULL trip connecting 2 sp (startSP, nextSP) 
			      // cout<<"FINI Create_PickupTrip"<<endl;
			   }
		   }
		   else //only unrouted delivery customers
		   {
			   numTrip = 0; 
			   bool create = CreateC2CTrip_BeforeSP_Temp(numVeh,0,0,0,numTrip,0,startSP);
			   if (create == 0) //can't create C2C before Dtrip
			       leave_SP = problem->leaveSP[startSP][4]; //prolem->nodeSP[startSP].sTW2 + problem->nodeSP[startSP].load;
			   else //can create C2C before DTrip
			   {
				   /*cout<<"First C2C trip of veh "<<numVeh<<": cost = "<<seg[numVeh].Trip[0].cost<<"; firstC = "<<seg[numVeh].Trip[0].firstCus<<"; lastC = "<<seg[numVeh].Trip[0].lastCus<<endl;
				   cout<<"Next is Dtrip @startSP = "<<startSP<<endl;*/
				   leave_SP = seg[numVeh].Trip[numTrip].leaveSP + problem->nodeSP[startSP].load; 
				   int curC = seg[numVeh].Trip[numTrip].firstCus; routed[curC] = 1;
				   int nextC = nextArrTemp[curC];
				   while (nextC > 0)
				   {
					   nextArr[curC] = nextC;
					   routed[nextC] = 1;
					   curC = nextC; nextC = nextArrTemp[nextC];
				   }
				   nextArr[curC] = 0;
				   numCusC2CRouted += seg[numVeh].Trip[numTrip].numCus;
				   numTrip++;
			   }
			   //cout<<"...CALL Create_DeliveryTrip"<<endl;
			   type = Create_DeliveryTrip(startSP, numTrip, leave_SP, nextSP, typeofseed, typeofINIT, valueFEE);
			   //cout<<"...FINI Create_DeliveryTrip"<<endl;
		   }//end only unrouted delivery customers
		  
		   while (type > 0) //type = 0: already last trip; =1 or = 2: not last trip yet
		   {
			   startSP = nextSP;
			   if (type == 1) //having: pickup trip - startSP.....
			   {
				   if (numCusDRouted[startSP] < problem->numCusDSP[startSP]) //nextTrip is deliverytrip
				   {
                       leave_SP = seg[numVeh].Trip[numTrip].leaveSP + problem->nodeSP[startSP].load;
					   //cout<<"Having pick("<<numVeh<<", "<<numTrip<<") -startSP(="<<startSP<<"): leaveSPofPTrip = "<<seg[numVeh].Trip[numTrip].leaveSP<<"; leave_SP = "<<leave_SP<<endl;
					   numTrip++;
		   			  // cout<<"1) CALL Create_DeliveryTrip"<<endl;
				       type = Create_DeliveryTrip(startSP,numTrip, leave_SP, nextSP, typeofseed, typeofINIT, valueFEE);
		   			   //cout<<"FIN Create_DeliveryTrip"<<endl;
				   }
				   else
				   {
					   leave_SP = seg[numVeh].Trip[numTrip].leaveSP;
					   //BIET LAM THE NAO create P OR D Trip to connect with previous PTrip(P,startSP)
		   			   //cout<<"1) CALL Create_PickupTrip"<<endl;
				       type = Create_PickupTrip(numTrip,startSP,numTrip, leave_SP, nextSP, typeofseed, typeofINIT, valueFEE);
   		   			   //cout<<"1) FIN Create_PickupTrip"<<endl;
				   }
			   }
			   else //if (type==2) //having: delivery trip - (C2C) - startSP.... OR having pickup-SP -(c2C)-- startSP OR (Dtrip) - startSP... --> nextTrip is delivery trip of startSP
			   {
				  leave_SP = seg[numVeh].Trip[numTrip].arriveSP + problem->nodeSP[startSP].load;
			      //cout<<"Having C2C("<<numVeh<<", "<<numTrip<<") - startSP(="<<startSP<<"): leaveSP_of_C2CTrip = "<<seg[numVeh].Trip[numTrip].arriveSP<<"; leave_SP = "<<leave_SP<<endl;
		          numTrip++;
	   			  //cout<<"1) CALL Create_DeliveryTrip"<<endl;
				  type = Create_DeliveryTrip(startSP,numTrip, leave_SP, nextSP, typeofseed, typeofINIT, valueFEE);
	   			  //cout<<"FIN Create_DeliveryTrip"<<endl;
			   }
		   }
		   seg[numVeh].numTrips = numTrip+1;
		   //cout<<"----------Finish create vehicle "<<numVeh<<"; numTrips = "<<seg[numVeh].numTrips<<endl;
		   double cost11 = 0;
		   for (j=0;j<seg[numVeh].numTrips;j++)
		   {
			   if (seg[numVeh].Trip[j].Type == 0) 
			   {
				   //cout<<"Checking PTrip("<<j<<"): "; showTripCus(numVeh,j);
				   CalInfromationTripP(numVeh, j); 
				  // cout<<" -->cost = "<<seg[numVeh].Trip[j].cost<<"-->fini"<<endl;
			   }
			   else if (seg[numVeh].Trip[j].Type == 1) 
			   {
				   //cout<<"Checking DTrip("<<j<<"): "; showTripCus(numVeh,j);
				   CalInfromationTripD(numVeh, j); 
				   //cout<<" -->cost = "<<seg[numVeh].Trip[j].cost<<"-->fini"<<endl;
			   }
			   else if (seg[numVeh].Trip[j].Type == 2)
			   {
				   //cout<<"Checking C2CTrip("<<j<<"): "; showTripCus(numVeh,j);
				   CalInfromationTripC2C(numVeh, j); 
				   //cout<<" -->cost = "<<seg[numVeh].Trip[j].cost<<"-->fini"<<endl;
			   }
			   cost11 += seg[numVeh].Trip[j].cost;
		   }
		   //cout<<"---------------------------cost = "<<cost11<<"-----------------------------------------"<<endl;
		   numVeh++;
	   }//still has unrouted customers
	   else cont = 0;
   }//end while (cont) //each loop create one vehicle


   while (numCusC2CRouted < nC2C) //there is still C2C not routed
   {
	   //cout<<"#cusC2C_routed = "<<numCusC2CRouted<<"; nC2C = "<<nC2C<<endl;
	   CreateVehicle_C2COnly();
	   //cout<<"Cost of C2Ctrip = "<<seg[numVeh].Trip[0].cost;
	   CalInfromationTripC2C(numVeh,0);
	   //cout<<"--> updated Cost = "<<seg[numVeh].Trip[0].cost<<endl;
	   numVeh++;
   }
   //cout<<"Checking: #cusC2C_routed = "<<numCusC2CRouted<<"; nC2C = "<<nC2C<<"; P.c2C = "<<problem->nC2C<<endl;

   //Update all information for the created solution:
   double CC = 0; //double buon;
   for (i=0;i<numVeh;i++)
   {
	   //buon = CC;
	   for (j=0;j<seg[i].numTrips;j++)
		   CC += seg[i].Trip[j].cost;
	   /*if (seg[i].Trip[0].Type==1)
		   CC += problem->c[0][seg[i].Trip[0].assSP];
	   //else buon += problem->cP[0][seg[i].Trip[0].firstCus];
	   int lastT = seg[i].numTrips -1;
	   if (seg[i].Trip[lastT].Type == 0)
		   CC += problem->c[seg[i].Trip[lastT].assSP][0];*/
	   /*buon = CC - buon;
	   cout<<"Cost of vehicle "<<i<<" =  "<<buon<<endl;*/
   }
   //cout<<"CALL calCostFrom Beginning"<<endl;
   calCostFromBeginning();

   if (PDSDIF(CC, cost))
   {
	   cout<<"Solution::initSol   ERROR cost of solution: calCostFromBeginning = "<<cost<<" != cost from initSol = "<<CC<<endl;
	   //exit(-1);
   }

   double checkC = cost;
   for (i=0;i<numVeh;i++)
   {
	   double costSeg = 0; double fitSeg = 0;
	   for (j=0;j<seg[i].numTrips;j++)
	   {
		   if (seg[i].Trip[j].Type == 0) 
		   {
			   CalInfromationTripP(i, j); 
			   //cout<<"Pick("<<i<<", "<<j<<"): "<<seg[i].Trip[j].cost<<endl; 
		   }
		   else if (seg[i].Trip[j].Type == 1) 
		   {
			   CalInfromationTripD(i, j); 
		   	   //cout<<"Delivery("<<i<<", "<<j<<"): "<<seg[i].Trip[j].cost<<endl;
		   }
		   else if (seg[i].Trip[j].Type == 2)
		   {
			   CalInfromationTripC2C(i, j); 
		   	   //cout<<"C2C("<<i<<", "<<j<<"): "<<seg[i].Trip[j].cost<<endl;
		   }
		   costSeg += seg[i].Trip[j].cost; fitSeg += seg[i].Trip[j].fitness;
	   }
	  // cout<<"----- COST OF VEH "<<i<<": "<<costSeg<<endl;
	   seg[i].cost = costSeg; seg[i].fitness = fitSeg;
   }
   numVehUsed = numVeh;
   calFitCostSumTrip();
   for (i = 1; i <= nSP; i++) pos[i] = 0;
   if (PDSDIF(checkC, cost))
   {
	   cout<<"Solution::initSol   ERROR cost of solution: calCostFromBeginning = "<<checkC<<"; calCostSumTrip = "<<cost<<endl;
	   exit(-1);
   }
   delete [] nextArrTemp;
   delete [] nextArrB;
   delete [] routedTemp;
   delete [] routed;
   delete [] numCusPRouted;
   delete [] numCusDRouted;
   delete [] numCusPSP;
   for (int i = 0; i < nSP1; i++) delete [] CusPSP[i];
   delete [] CusPSP;

 }
 bool Solution::CreateC2CTrip_BeforePickupTrip(int idVeh, int idTrip, int assSP, int preC, double depart_preC)
{
	//Update 7/11/2013: Create a C2C Trip before pickup trip(idVeh, idTrip): such that all trips are feasible; 
	//will try to insert C2C right after preC

	double cStartS = depart_preC;

	int idCusP, idCusD;
	double ArrTime;

	//cout<<"TRYING TO Create C2C trip before PTrip("<<idVeh<<", "<<idTrip<<")"<<endl;
   
    //1.Insert a C2C as the first customer of current trip:
	 double costT;
	 double costMINI = PDS_INFINITY; double temp; int seed=-1;
	 bool changedSEED, changed;
	 int firstC_nextT = seg[idVeh].Trip[idTrip].firstCus;
	 
	 for (idCusP = startidC2C;idCusP <= endidC2CP; idCusP ++)
	 {
		 if (routed[idCusP] == 0 && problem->belong[idCusP][assSP])
		 { 
			 idCusD = problem->node[idCusP].delID;
			 costT = problem->c[preC][idCusP] + problem->c[idCusP][idCusD] + problem->c[idCusD][firstC_nextT];
			 if (costT > costMINI) continue;
			 ArrTime = PDS_MAX(cStartS + problem->c[preC][idCusP], problem->node[idCusP].sTW); 
			 temp = ArrTime - problem->node[idCusP].eTW;
			 if (temp > eps) continue;
			 ArrTime += (problem->node[idCusP].duration + problem->c[idCusP][idCusD]);
			 temp = ArrTime - problem->node[idCusD].eTW;
			 if (temp > eps) continue;
			 ArrTime = PDS_MAX(ArrTime, problem->node[idCusD].sTW) + problem->node[idCusD].duration;
             bool cont = 0;
			 changed = 0;
			 cont = checkPickupTripFeasible_AfterInsertC2C(idCusD,ArrTime,costT,idVeh,idTrip,changed);
			 if (cont)
			 {
				 if (costT < costMINI)
				 {
					 seed = idCusP;
					 costMINI = costT;
					 changedSEED = changed;
				 }
			 }
		 }
	 }

	 if (seed == -1)
	 {
		 //cout<<"CANNOT insert C2C trip before PTrip("<<idVeh<<", "<<idTrip<<")"<<endl;
		 return 0;
	 }

	 idCusD = problem->node[seed].delID;
	 //cout<<"-->CAN Create C2C trip before PTrip("<<idVeh<<", "<<idTrip<<"): firstC2CD = "<<idCusD<<endl;
	 routed[seed]=1; routed[idCusD] = 1;
	 int nextT = idTrip + 1;
	 seg[idVeh].Trip[nextT] = seg[idVeh].Trip[idTrip];
	 seg[idVeh].Trip[idTrip].Type = 2;
	 seg[idVeh].Trip[idTrip].firstCus = seed;
	 seg[idVeh].Trip[idTrip].lastCus = idCusD;
	 int preT = idTrip - 1;
	 if (idTrip == 0)
	 {
		 seg[idVeh].Trip[idTrip].cost = problem->c[0][seed] + problem->c[seed][idCusD] + problem->c[idCusD][firstC_nextT];
	 }
	 else
	 {
		 seg[idVeh].Trip[preT].cost += (problem->c[preC][seed] - seg[idVeh].Trip[preT].connectCost);
		 seg[idVeh].Trip[preT].connectCost = problem->c[preC][seed];
		 seg[idVeh].Trip[idTrip].cost = problem->c[seed][idCusD] + problem->c[idCusD][firstC_nextT];
	 }
	 seg[idVeh].Trip[idTrip].connectCost = problem->c[idCusD][firstC_nextT];
	 startS[seed] = PDS_MAX(cStartS + problem->c[preC][seed], problem->node[seed].sTW);
	 depart[seed] = startS[seed] + problem->node[seed].duration;
     startS[idCusD] = PDS_MAX(depart[seed] + problem->c[seed][idCusD], problem->node[idCusD].sTW);
	 depart[idCusD] = startS[idCusD] + problem->node[idCusD].duration;

	 seg[idVeh].Trip[idTrip].numCus = 2;
	 seg[idVeh].Trip[idTrip].feasible = 1;
	 seg[idVeh].Trip[idTrip].endS = depart[idCusD];
	 numCusC2CRouted += 2;
	 nextArr[seed] = idCusD; nextArr[idCusD] = 0;
	 pos[seed] = 1; pos[idCusD] = 2;
	 FCAP[seed] = problem->node[seed].capacity;
	 FCAP[idCusD] = 0;

	 //STILL NEED to update the cost and WS of (idVeh, nextT):
	 if (changedSEED) //because this is insertion --> before insert go to sp through WS, after insert go to sp directly
	 {
		 seg[idVeh].Trip[nextT].waitingS = NO_WS;
		 int lastC = seg[idVeh].Trip[nextT].lastCus;
		 seg[idVeh].Trip[nextT].cost += (problem->c[lastC][assSP] - problem->disCWSSP[lastC][assSP]);
	 }
	 //cout<<"CALL updatePTrip_InitSol"<<endl;showTripCost(idVeh,nextT);
	 //cout<<"seed = "<<seed<<"; idCusD = "<<idCusD<<"; firstC_nextT = "<<firstC_nextT<<endl;*/
	 updatePTrip_InitSol(idVeh, nextT, idCusD,firstC_nextT,changedSEED);

	 //Now trying to insert more C2C to trip(idVeh,idTrip):
     if (numCusC2CRouted < problem->nC2C)
	 {
		 double costT1, depart_idCusP, costMINI1, costC2C;
		 int i,j, firstC_C2C, idCus, insert_afterP, insert_afterD, curC, nextC, preINS, nextINS, IDinsert, FCAPT;
		 double *departTemp = new double[250];
		 bool cont = 1; bool ok;
		 do //each loop insert a pair of C2C
		 {
			 IDinsert = -1; costMINI = PDS_INFINITY;
			 firstC_C2C = seg[idVeh].Trip[idTrip].firstCus;
			 for (idCusP = startidC2C; idCusP <= endidC2CP; idCusP ++)
			 {
				 if (routed[idCusP] == 0 && problem->belong[idCusP][assSP])
				 {
					 //1. First try to insert at the beginning of the trip:
					 nextINS = firstC_C2C;
					 FCAPT = problem->node[idCusP].capacity;
					 ArrTime = PDS_MAX(depart_preC + problem->c[preC][idCusP], problem->node[idCusP].sTW); 
					 temp = ArrTime - problem->node[idCusP].eTW;
					 if (temp > eps) continue;
					 //Insert idCusP at the beginning of the trip, now find place to insert idCusD
					 idCusD = problem->node[idCusP].delID;
					 depart_idCusP = ArrTime + problem->node[idCusP].duration;
					 //1.1 Insert idCusD right after idCusP: then capacity of vehicle is ok since already ok when inserting idCusP
					 ArrTime = depart_idCusP + problem->c[idCusP][idCusD];
					 temp = ArrTime - problem->node[idCusD].eTW;
					 if (temp > eps) continue;
					 //cout<<"D rightafter P"<<"; ";
					 ok = 1;
					 ArrTime = PDS_MAX(ArrTime, problem->node[idCusD].sTW) + problem->node[idCusD].duration + problem->c[idCusD][firstC_C2C];
					 costT = problem->c[preC][idCusP] + problem->c[idCusP][firstC_C2C] - problem->c[preC][firstC_C2C];
					 temp = problem->node[firstC_C2C].eTW - ArrTime;
						 if (temp > 0) 
						 {
							 ArrTime = PDS_MAX(ArrTime, problem->node[nextINS].sTW) + problem->node[nextINS].duration;
							 curC = nextINS; nextC = nextArr[nextINS];
							 while (nextC > 0)
							 {
								 ArrTime += problem->c[curC][nextC];
								 temp = ArrTime - problem->node[nextC].eTW;
								 if (temp > eps) {ok = 0; break;} //vioTW at nextC
								 else
								 {
									 ArrTime = PDS_MAX(ArrTime, problem->node[nextC].sTW) + problem->node[nextC].duration;
									 curC = nextC; nextC = nextArr[curC];
								 }
							 }
							 if (ok) //curC is now pointed to lastC
							 {
								 costC2C = costT + problem->c[idCusP][idCusD] + problem->c[idCusD][nextINS] - problem->c[idCusP][nextINS];
								 costT1 = costC2C;
								 changed = 0;
								 ok = checkPickupTripFeasible_AfterInsertC2C(curC,ArrTime,costT1,idVeh,nextT,changed);
	                             if (ok)
								 {
									 if (costT1 < costMINI)
									 {
										 costMINI = costT1;
										 costMINI1 = costC2C;
										 IDinsert = idCusP;
										 insert_afterP = 0;
										 insert_afterD = idCusP;
										 changedSEED = changed;
									 }
								 }
							 }//end if (ok)
						 }//else vioTW at cus nextINS
						 
						 //1.2 Find place to insert idCusD from position after nextINS assuming that idCusP is inserted at the beginning of the trip:
                          ok = checkC2CAndPTripFeasible_AfterInsertC2C(idCusP, depart_idCusP,firstC_C2C,1,departTemp,idVeh,nextT);
						  if (ok) //TW is ok for all customers in trip C2C and next PTrip(idVeh, nextT) after inserting idCusP to the trip C2C
						  {
							 int i = 1; curC = firstC_C2C;
							 while (i <= seg[idVeh].Trip[idTrip].numCus) //insert idCusD after curC at position i of idTrip
							 {
								 //1.2 Insert idCusD right after place i
								 if (curC < startidC2CD) //curC is a C2CP
								 {
									 curC = problem->node[curC].delID;
									 i = pos[curC];
								 }
								 else //curC is a C2CD:
								 {
									 idCus = problem->node[curC].pickID;
									 if (pos[idCus] > 0)
									 {
										 //Insert idCusD after curC: check capacity and vioTW
										 ok = checkCapacity_C2CTrip_InitSol(firstC_C2C, curC,FCAPT);
										 if (ok)
										 {
											 ArrTime = departTemp[i] + problem->c[curC][idCusD];
											 temp = problem->node[idCusD].eTW - ArrTime;
											 if (temp > eps)
											 {
												 ArrTime = PDS_MAX(ArrTime, problem->node[idCusD].sTW) + problem->node[idCusD].duration;
												 changed = 0;
												 costC2C = costT;
												 ok = checkC2CAndPTripFeasibleCostChange_AfterInsertC2C(idCusD,ArrTime, nextArr[curC], costT1, idVeh,nextT,changed);
												 if (ok) //it's ok to insert idCusD after curC
												 {
													 nextC = nextArr[curC];
													 if (nextC > 0)
														costC2C += (problem->c[curC][idCusD] + problem->c[idCusD][nextC] - problem->c[curC][nextC]);
													 else
														 costC2C += (problem->c[curC][idCusD] + problem->c[idCusD][firstC_nextT] - problem->c[curC][firstC_nextT]);

													 costT1 += costC2C;
													 if (costT1 < costMINI)
													 {	
														 costMINI = costT1;
														 costMINI1 = costC2C;
														 IDinsert = idCusP;
														 insert_afterP = 0;
														 insert_afterD = curC;
														 changedSEED = changed;
													 }
												 }
											 }

										 }//else not ok capacity of vehicle
										 i ++; curC = nextArr[curC];
									 }
									 else break;
								 }
							 }
						  }
					 //2. Insert idCusP in the middle of the trip
					 preINS = firstC_C2C;
					 nextINS = nextArr[preINS];
                     for (j=1;j<seg[idVeh].Trip[idTrip].numCus;j++) //insert idCusP between preINS and nextINS
					 {
						 FCAPT = FCAP[preINS] + problem->node[idCusP].capacity;
						 if (FCAPT <= problem->Q)
						 {
	 						costT = problem->c[preINS][idCusP] + problem->c[idCusP][nextINS] - problem->c[preINS][nextINS];
							cStartS = depart[preINS] + problem->c[preINS][idCusP];
							temp = problem->node[idCusP].eTW - cStartS;
							if (temp > eps)
							{
								 depart_idCusP = PDS_MAX(cStartS, problem->node[idCusP].sTW) + problem->node[idCusP].duration;
								 //2.1 Insert idCusD right after idCusP: don't need to check capacity of vehicle
 								 ArrTime = PDS_MAX(depart_idCusP + problem->c[idCusP][idCusD], problem->node[idCusD].sTW) + problem->node[idCusD].duration + problem->c[idCusD][nextINS];
								 temp = problem->node[nextINS].eTW - ArrTime;
								 if (temp > 0) 
								 {
									 ArrTime = PDS_MAX(ArrTime, problem->node[nextINS].sTW) + problem->node[nextINS].duration;
									 curC = nextINS; nextC = nextArr[nextINS];
									 ok = 1;
									 while (nextC > 0)
									 {
										 ArrTime += problem->c[curC][nextC];
										 temp = ArrTime - problem->node[nextC].eTW;
										 if (temp > eps) {ok = 0; break;} //vioTW at nextC
										 else
										 {
											 ArrTime = PDS_MAX(ArrTime, problem->node[nextC].sTW) + problem->node[nextC].duration;
											 curC = nextC; nextC = nextArr[curC];
										 }
									 }
									 if (ok) //curC is now pointed to lastC
									 {
										 costC2C = costT + problem->c[idCusP][idCusD] + problem->c[idCusD][nextINS] - problem->c[idCusP][nextINS];
										 changed = 0;
										 costT1 = costC2C;
										 ok = checkPickupTripFeasible_AfterInsertC2C(curC,ArrTime,costT1,idVeh,nextT,changed);
										 if (ok)
										 {
											 if (costT1 < costMINI)
											 {
												 costMINI = costT1;
												 costMINI1 = costC2C;
												 IDinsert = idCusP;
												 insert_afterP = preINS;
												 insert_afterD = idCusP;
												 changedSEED = changed;
											 }
										 }
									 }//end if (ok)
								 }//else vioTW at cus nextINS
		 						 //2.2 Find place to insert idCusD from position after nextINS assuming that idCusP is inserted between preINS and nextINS:
          						 ok = checkC2CAndPTripFeasible_AfterInsertC2C(idCusP,depart_idCusP,nextINS,j+1,departTemp,idVeh,nextT);
								 if (ok) //TW is ok for all customers in trip C2C and next PTrip(idVeh, nextT) after inserting idCusP to the trip C2C between preINS and nextINS
								 {
									 i = j + 1; curC = nextINS;
									 while (i <= seg[idVeh].Trip[idTrip].numCus) //insert idCusD after curC at position i of idTrip
									 {
										 //2.2 Insert idCusD right after place i:
										 if (curC < startidC2CD) //curC is a C2CP
										 {
											 curC = problem->node[curC].delID;
											 i = pos[curC];
										 }
										 else //curC is a C2CD
										 {
                                              idCus = problem->node[curC].pickID;
											  if (pos[idCus] > j)
											  {
												  //Insert idCusD after curC: check capacity of vehicle and vioTW
												  ok = checkCapacity_C2CTrip_InitSol(nextINS,curC, FCAPT);
												  if (ok)
												  {
													  ArrTime = departTemp[i] + problem->c[curC][idCusD];
													  temp = problem->node[idCusD].eTW - ArrTime;
													  if (temp > eps)
													  {
															 ArrTime = PDS_MAX(ArrTime, problem->node[idCusD].sTW) + problem->node[idCusD].duration;
															 changed = 0;
															 costC2C = costT;
															 ok = checkC2CAndPTripFeasibleCostChange_AfterInsertC2C(idCusD,ArrTime, nextArr[curC],costT1, idVeh,nextT,changed);
															 if (ok) //it's ok to insert idCusD after curC
															 {
																 nextC = nextArr[curC];
																 if (nextC > 0)
																	costC2C += (problem->c[curC][idCusD] + problem->c[idCusD][nextC] - problem->c[curC][nextC]);
																 else
																	 costC2C += (problem->c[curC][idCusD] + problem->c[idCusD][firstC_nextT] - problem->c[curC][firstC_nextT]);

																 costT1 += costC2C;
																 if (costT1 < costMINI)
																 {	
																	 costMINI = costT1;
																	 costMINI1 = costC2C;
																	 IDinsert = idCusP;
																	 insert_afterP = preINS;
																	 insert_afterD = curC;
																	 changedSEED = changed;
																 }
															 }
													  }//else vioTW at idCusD
												  }//else vio capacity of vehicle
												  i++; curC = nextArr[curC];
											  }
											  else break;
										 }//end curC is a C2CD
									 }//end while
								 }//else TW is NOT ok for all customers in trip C2C and next PTrip(idVeh, nextT) after inserting idCusP to the trip C2C between preINS and nextINS
							}//else vioTW at idCusP
						 }//else can't insert between preINS and nextINS due to the capacity of the trip
						 preINS = nextINS; nextINS = nextArr[preINS];
					 }//end for j

					 //3. Insert idCusP at the end of the trip C2C: [after preINS] --> dont need to check CAPACITY of vehicle
 					 cStartS = depart[preINS] + problem->c[preINS][idCusP];
					 temp = problem->node[idCusP].eTW - cStartS;
					 if (temp > eps)
					 {
								 depart_idCusP = PDS_MAX(cStartS, problem->node[idCusP].sTW) + problem->node[idCusP].duration;
								 //3.1 Insert idCusD right after idCusP:
 								 ArrTime = PDS_MAX(depart_idCusP + problem->c[idCusP][idCusD], problem->node[idCusD].sTW) + problem->node[idCusD].duration;
								 costC2C = problem->c[preINS][idCusP] + problem->c[idCusP][idCusD] + problem->c[idCusD][firstC_nextT] - problem->c[preINS][firstC_nextT];
								 costT1 = costC2C;
								 changed = 0;
								 ok = checkPickupTripFeasible_AfterInsertC2C(idCusD,ArrTime,costT1,idVeh,nextT,changed);
								 if (ok)
								 {
									 if (costT1 < costMINI)
									 {
										 costMINI = costT1;
										 costMINI1 = costC2C;
										 IDinsert = idCusP;
										 insert_afterP = preINS;
										 insert_afterD = idCusP;
										 changedSEED = changed;
									 }
								 }//end if (ok)
					 }//else vioTW at idCusP
				 } //else idCusP already routed 
			 }//end for idCusP: try all unrouted C2C
			 if (IDinsert != -1)
			 {
				 idCusD = problem->node[IDinsert].delID;
				 //cout<<"Insert C2CP customer "<<IDinsert<<" after "<<insert_afterP<<" and insert C2CD "<<idCusD<<" after "<<insert_afterD<<": "<<endl;
				 if (insert_afterP == seg[idVeh].Trip[idTrip].lastCus) //insert at the end of the trip:
				 {
 					  nextArr[insert_afterP] = IDinsert; 
					  nextArr[IDinsert] = idCusD; 
					  seg[idVeh].Trip[idTrip].lastCus = idCusD;nextArr[idCusD] = 0;
  					  startS[IDinsert] = PDS_MAX(depart[insert_afterP] + problem->c[insert_afterP][IDinsert], problem->node[IDinsert].sTW);
					  depart[IDinsert] = startS[IDinsert] + problem->node[IDinsert].duration;
					  FCAP[IDinsert] = problem->node[IDinsert].capacity;
					  FCAP[idCusD] = 0;
					  pos[IDinsert] = pos[insert_afterP] + 1; pos[idCusD] = pos[IDinsert] + 1;
					  startS[idCusD] = PDS_MAX(depart[IDinsert] + problem->c[IDinsert][idCusD], problem->node[idCusD].sTW);
					  depart[idCusD] = startS[idCusD] + problem->node[idCusD].duration;
					  updatePTrip_InitSol(idVeh,nextT, idCusD, firstC_nextT,changedSEED);
				 }
				 else //not insert at the end of the trip C2C
				 {
					 if (insert_afterP == 0)
					 {
						 seg[idVeh].Trip[idTrip].firstCus = IDinsert;
						 nextArr[IDinsert] = firstC_C2C;
						 startS[IDinsert] = PDS_MAX(depart_preC + problem->c[preC][IDinsert], problem->node[IDinsert].sTW);
						 depart[IDinsert] = startS[IDinsert] + problem->node[IDinsert].duration;
						 pos[IDinsert] = 1; FCAP[IDinsert] = problem->node[IDinsert].capacity;
						 //Update 26/11/2013
						 if (idTrip > 0)
						 {
							 double deltaC = (problem->c[preC][IDinsert] - problem->c[preC][firstC_C2C]);
							 seg[idVeh].Trip[preT].cost += deltaC;
							 seg[idVeh].Trip[preT].connectCost = problem->c[preC][IDinsert];
							 seg[idVeh].Trip[idTrip].cost -= deltaC;
						 }
					 }
					 else //insert in the middle
					 {
 						  int tt=nextArr[insert_afterP];
						  nextArr[insert_afterP]=IDinsert;
						  nextArr[IDinsert]=tt;
  						  startS[IDinsert] = PDS_MAX(depart[insert_afterP] + problem->c[insert_afterP][IDinsert], problem->node[IDinsert].sTW);
						  depart[IDinsert] = startS[IDinsert] + problem->node[IDinsert].duration;
						  pos[IDinsert] = pos[insert_afterP] + 1; FCAP[IDinsert] = FCAP[insert_afterP] + problem->node[IDinsert].capacity;
					 }//end insert in the middle

					 if (insert_afterD == IDinsert) //insert idCusD right after idCusP
					 {
						 startS[idCusD] = PDS_MAX(depart[IDinsert] + problem->c[IDinsert][idCusD], problem->node[idCusD].sTW);
						 depart[idCusD] = startS[idCusD] + problem->node[idCusD].duration;
						 int tt = nextArr[IDinsert];
						 nextArr[IDinsert] = idCusD; nextArr[idCusD] = tt; 
						 pos[idCusD] = pos[IDinsert] + 1; 
						 FCAP[idCusD] = FCAP[IDinsert] + problem->node[idCusD].capacity;
					 }
					 else //insert idCusD after insert_afterD:
					 {
						 curC = IDinsert; nextC = nextArr[IDinsert];
						 do
						 {
							 startS[nextC] = PDS_MAX(depart[curC] + problem->c[curC][nextC], problem->node[nextC].sTW);
							 depart[nextC] = startS[nextC] + problem->node[nextC].duration;
							 pos[nextC] ++; FCAP[nextC] = FCAP[curC] + problem->node[nextC].capacity;
							 curC = nextC; nextC = nextArr[curC];
						 }while (curC != insert_afterD);
						 //Insert idCusD after insert_afterD:
						 startS[idCusD] = PDS_MAX(depart[insert_afterD] + problem->c[insert_afterD][idCusD], problem->node[idCusD].sTW);
						 depart[idCusD] = startS[idCusD] + problem->node[idCusD].duration;
						 nextArr[idCusD] = nextArr[insert_afterD]; nextArr[insert_afterD] = idCusD; 
						 pos[idCusD] = pos[insert_afterD] + 1; FCAP[idCusD] = FCAP[insert_afterD] + problem->node[idCusD].capacity;
					 }//end insert idCusD after insert_afterD:
					 nextC = nextArr[idCusD];
					 if (nextC > 0)	 updateStartS_pos_FCAP_FEASIBLETRIP(idVeh,idTrip,idCusD,nextC,pos[idCusD]);
					 else seg[idVeh].Trip[idTrip].lastCus = idCusD;
					 updatePTrip_InitSol(idVeh, nextT, seg[idVeh].Trip[idTrip].lastCus, firstC_nextT,changedSEED);
				 }//end not insert at the end of the trip C2C

				  seg[idVeh].Trip[idTrip].numCus +=2; 
				  routed[IDinsert] = 1; routed[idCusD] = 1;
				  numCusC2CRouted += 2;
				  if (numCusC2CRouted == nC2C) cont = 0;
				  seg[idVeh].Trip[idTrip].cost += costMINI1;
				  seg[idVeh].Trip[idTrip].endS = depart[seg[idVeh].Trip[idTrip].lastCus];
				  ok = checkC2C_P_FeasibleTrip_InitSol(idVeh,idTrip, preC, depart_preC,nextT);
				  if (ok == 0) exit(-1);
			 } else cont = 0; //can't route any C2C anymore
		 }while (cont);
		 delete [] departTemp;
	 }
	 return 1;

}
bool Solution::CreateC2CTrip_BeforePickupTrip_Temp(int idVeh, int preT, int preC, double depart_preC, int &idTrip, int value_assign_idTrip, int idTripP, int assSP)
{
	//OK 13/11/2013
	//Update 11/11/2013: Create a C2C Trip between Trip(idVeh, preT) and PTrip(idVeh, idTripP, assSP): such that all trips are feasible; 
	//will try to insert C2C right after Customer preC
	//if preC = 0 --> depot and preT doesn't exist

	double cStartS = depart_preC;

	int idCusP, idCusD;
	double ArrTime;

	//cout<<"@CreateC2CTrip_BeforePickupTrip_Temp: TRYING TO Create C2C trip before Pickup trip("<<idVeh<<", "<<idTripP<<"); after preC = "<<preC<<endl;
   
    //1.Insert a C2C as the first customer of current trip:
	 double costT;
	 double costMINI = PDS_INFINITY; double temp; int seed=-1;
	 bool changedSEED, changed;
	 int firstC_nextT = seg[idVeh].Trip[idTripP].firstCus;
	 
	 for (idCusP = startidC2C;idCusP <= endidC2CP; idCusP ++)
	 {
		 routedTemp[idCusP] = routed[idCusP];
		 if (routedTemp[idCusP] == 0 && problem->belong[idCusP][assSP])
		 { 
			 idCusD = problem->node[idCusP].delID;
			 costT = problem->c[preC][idCusP] + problem->c[idCusP][idCusD] + problem->c[idCusD][firstC_nextT];
			 if (costT > costMINI) continue;
			 ArrTime = PDS_MAX(cStartS + problem->c[preC][idCusP], problem->node[idCusP].sTW); 
			 temp = ArrTime - problem->node[idCusP].eTW;
			 if (temp > eps) continue;
			 ArrTime += (problem->node[idCusP].duration + problem->c[idCusP][idCusD]);
			 temp = ArrTime - problem->node[idCusD].eTW;
			 if (temp > eps) continue;
			 ArrTime = PDS_MAX(ArrTime, problem->node[idCusD].sTW) + problem->node[idCusD].duration;
             bool cont = 0;
			 changed = 0;
			 cont = checkPickupTripFeasible_AfterInsertC2C_Temp(idCusD,ArrTime,costT,idVeh,idTripP,changed);
			 if (cont)
			 {
				 if (costT < costMINI)
				 {
					 seed = idCusP;
					 costMINI = costT;
					 changedSEED = changed;
				 }
			 }
		 }
	 }

	 if (seed == -1)
	 {
	 	 //cout<<"Cant create C2CTrip before PTrip("<<idVeh<<", "<<idTripP<<")"<<endl;
		 return 0;
	 }

	 idCusD = problem->node[seed].delID;
	 //cout<<"CAN insert C2C before PTrip("<<idVeh<<", "<<idTripP<<"): firstC2C = ("<<seed<<", "<<idCusD<<")"<<endl;
	 routedTemp[seed]=1; routedTemp[idCusD] = 1;
	 idTrip = value_assign_idTrip;
	 seg[idVeh].Trip[idTrip].Type = 2;
	 seg[idVeh].Trip[idTrip].firstCus = seed;
	 seg[idVeh].Trip[idTrip].lastCus = idCusD;


	 /*if (preC > 0)
	 {
	    seg[idVeh].Trip[preT].cost += (problem->c[preC][seed] - seg[idVeh].Trip[preT].connectCost);
	    seg[idVeh].Trip[preT].connectCost = problem->c[preC][seed];
	    seg[idVeh].Trip[idTrip].cost = problem->c[seed][idCusD] + problem->c[idCusD][firstC_nextT];
	 }
	 else
	 {
		 seg[idVeh].Trip[idTrip].cost = problem->c[preC][seed] + problem->c[seed][idCusD] + problem->c[idCusD][firstC_nextT];
	 }*/
 
	 seg[idVeh].Trip[idTrip].cost = problem->c[preC][seed] + problem->c[seed][idCusD] + problem->c[idCusD][firstC_nextT];
	 //seg[idVeh].Trip[idTrip].connectCost = problem->c[idCusD][firstC_nextT];
	 startS[seed] = PDS_MAX(cStartS + problem->c[preC][seed], problem->node[seed].sTW);
	 depart[seed] = startS[seed] + problem->node[seed].duration;
     startS[idCusD] = PDS_MAX(depart[seed] + problem->c[seed][idCusD], problem->node[idCusD].sTW);
	 depart[idCusD] = startS[idCusD] + problem->node[idCusD].duration;

	 seg[idVeh].Trip[idTrip].numCus = 2;
	 seg[idVeh].Trip[idTrip].feasible = 1;
	 seg[idVeh].Trip[idTrip].endS = depart[idCusD];
	 int numCusC2CRoutedTemp = numCusC2CRouted;
	 numCusC2CRoutedTemp += 2;
	 nextArrTemp[seed] = idCusD; nextArrTemp[idCusD] = 0;
	 pos[seed] = 1; pos[idCusD] = 2;
	 FCAP[seed] = problem->node[seed].capacity;
	 FCAP[idCusD] = 0;
	 seg[idVeh].Trip[idTrip].capacity = problem->node[seed].capacity;

	 //STILL NEED to update the cost and WS of (idVeh, nextT):
	 if (changedSEED) //because this is insertion AND lastCus of the trip doesn't change --> before insert go to sp through WS, after insert go to sp directly
	 {
		 seg[idVeh].Trip[idTripP].waitingS = NO_WS;
		 int lastC = seg[idVeh].Trip[idTripP].lastCus;
		 seg[idVeh].Trip[idTripP].cost += (problem->c[lastC][assSP] - problem->disCWSSP[lastC][assSP]);
	 }
	 //cout<<"endS of PTrip("<<idVeh<<", "<<idTripP<<") = "<<seg[idVeh].Trip[idTripP].endS<<"; depart[idCusD] = "<<depart[idCusD]<<"; ";
	 updatePTrip_InitSol_Temp(idVeh, idTripP,idCusD,firstC_nextT,changedSEED);
	 //cout<<"--> Update endS = "<<seg[idVeh].Trip[idTripP].endS<<endl;

	 //Now trying to insert more C2C to trip(idVeh,idTrip):
     if (numCusC2CRoutedTemp < problem->nC2C)
	 {
		 double costT1, depart_idCusP, costMINI1, costC2C;
		 int i,j, firstC_C2C, idCus, insert_afterP, insert_afterD, curC, nextC, preINS, nextINS, IDinsert, FCAPT;
		 double departTemp[500];
		 bool cont = 1; bool ok;
		 do //each loop insert a pair of C2C
		 {
			 IDinsert = -1; costMINI = PDS_INFINITY;
			 firstC_C2C = seg[idVeh].Trip[idTrip].firstCus;
			 for (idCusP = startidC2C; idCusP <= endidC2CP; idCusP ++)
			 {
				 if (routedTemp[idCusP] == 0 && problem->belong[idCusP][assSP])
				 {
					 idCusD = problem->node[idCusP].delID;
					 //cout<<"Trying to insert C2C("<<idCusP<<"="<<problem->node[idCusP].id<<", "<<idCusD<<"="<<problem->node[idCusD].id<<"): ";
					 //cout<<" at the begin of the trip; ";
					 //1. First try to insert at the beginning of the trip:
					 FCAPT = problem->node[idCusP].capacity;
					 ArrTime = PDS_MAX(depart_preC + problem->c[preC][idCusP], problem->node[idCusP].sTW); 
					 temp = ArrTime - problem->node[idCusP].eTW;
					 if (temp > eps) continue;
					 //Insert idCusP at the beginning of the trip, now find place to insert idCusD
					 depart_idCusP = ArrTime + problem->node[idCusP].duration;
					 //1.1 Insert idCusD right after idCusP: then capacity of vehicle is ok since already ok when inserting idCusP
					 ArrTime = depart_idCusP + problem->c[idCusP][idCusD];
					 temp = ArrTime - problem->node[idCusD].eTW;
					 if (temp > eps) continue;
					 //cout<<"D rightafter P"<<"; ";
					 ok = 1;
					 ArrTime = PDS_MAX(ArrTime, problem->node[idCusD].sTW) + problem->node[idCusD].duration + problem->c[idCusD][firstC_C2C];
					 costT = problem->c[preC][idCusP] + problem->c[idCusP][firstC_C2C] - problem->c[preC][firstC_C2C];
					 temp = problem->node[firstC_C2C].eTW - ArrTime;
					 if (temp > 0) 
					 {
							 ArrTime = PDS_MAX(ArrTime, problem->node[firstC_C2C].sTW) + problem->node[firstC_C2C].duration;
							 curC = firstC_C2C; nextC = nextArrTemp[firstC_C2C];
							 while (nextC > 0)
							 {
								 ArrTime += problem->c[curC][nextC];
								 temp = ArrTime - problem->node[nextC].eTW;
								 if (temp > eps) {ok = 0; break;} //vioTW at nextC
								 else
								 {
									 ArrTime = PDS_MAX(ArrTime, problem->node[nextC].sTW) + problem->node[nextC].duration;
									 curC = nextC; nextC = nextArrTemp[curC];
								 }
							 }
							 if (ok) //curC is now pointed to lastC
							 {
								 costC2C = costT + problem->c[idCusP][idCusD] + problem->c[idCusD][firstC_C2C] - problem->c[idCusP][firstC_C2C];
								 costT1 = costC2C;
								 changed = 0;
								 ok = checkPickupTripFeasible_AfterInsertC2C_Temp(curC,ArrTime,costT1,idVeh,idTripP,changed);
	                             if (ok)
								 {
									 if (costT1 < costMINI)
									 {
										 costMINI = costT1;
										 costMINI1 = costC2C;
										 IDinsert = idCusP;
										 insert_afterP = 0;
										 insert_afterD = idCusP;
										 changedSEED = changed;
									 }
								 }
							 }//end if (ok)
						 }//else vioTW at cus nextINS
						 
						 //1.2 Find place to insert idCusD from position after nextINS assuming that idCusP is inserted at the beginning of the trip:
                          ok = checkC2CAndPTripFeasible_AfterInsertC2C_Temp(idCusP, depart_idCusP,firstC_C2C,1,departTemp,idVeh,idTripP);
						  if (ok) //TW is ok for all customers in trip C2C and next PTrip(idVeh, nextT) after inserting idCusP to the trip C2C
						  {
							 int i = 1; curC = firstC_C2C;
							 while (i <= seg[idVeh].Trip[idTrip].numCus) //insert idCusD after curC at position i of idTrip
							 {
								 //cout<<" OR D after "<<curC<<"; ";
								 //1.2 Insert idCusD right after place i
								 if (curC < startidC2CD) //curC is a C2CP
								 {
									 curC = problem->node[curC].delID;
									 i = pos[curC];
								 }
								 else //curC is a C2CD:
								 {
									 idCus = problem->node[curC].pickID;
									 if (pos[idCus] > 0)
									 {
										 //Insert idCusD after curC: check capacity and vioTW
										 ok = checkCapacity_C2CTrip_InitSol_Temp(firstC_C2C, curC,FCAPT);
										 if (ok)
										 {
											 ArrTime = departTemp[i] + problem->c[curC][idCusD];
											 temp = problem->node[idCusD].eTW - ArrTime;
											 if (temp > eps)
											 {
												 ArrTime = PDS_MAX(ArrTime, problem->node[idCusD].sTW) + problem->node[idCusD].duration;
												 changed = 0;
												 costC2C = costT;
												 ok = checkC2CAndPTripFeasibleCostChange_AfterInsertC2C_Temp(idCusD,ArrTime, nextArrTemp[curC], costT1, idVeh,idTripP,changed);
												 if (ok) //it's ok to insert idCusD after curC
												 {
													 nextC = nextArrTemp[curC];
													 if (nextC > 0)
														costC2C += (problem->c[curC][idCusD] + problem->c[idCusD][nextC] - problem->c[curC][nextC]);
													 else
														 costC2C += (problem->c[curC][idCusD] + problem->c[idCusD][firstC_nextT] - problem->c[curC][firstC_nextT]);

													 costT1 += costC2C;
													 if (costT1 < costMINI)
													 {	
														 costMINI = costT1;
														 costMINI1 = costC2C;
														 IDinsert = idCusP;
														 insert_afterP = 0;
														 insert_afterD = curC;
														 changedSEED = changed;
													 }
												 }
											 }

										 }//else not ok capacity of vehicle
										 i ++; curC = nextArrTemp[curC];
									 }
									 else break;
								 }
								 //cout<<endl;
							 }
						  }
					 //2. Insert idCusP in the middle of the trip
					 //cout<<" in the middle of the trip: ";
					 preINS = firstC_C2C;
					 nextINS = nextArrTemp[preINS];
                     for (j=1;j<seg[idVeh].Trip[idTrip].numCus;j++) //insert idCusP between preINS and nextINS
					 {
						 FCAPT = FCAP[preINS] + problem->node[idCusP].capacity;
						 if (FCAPT <= problem->Q)
						 {
                            //cout<<"P after "<<preINS<<";";
	 						costT = problem->c[preINS][idCusP] + problem->c[idCusP][nextINS] - problem->c[preINS][nextINS];
							cStartS = depart[preINS] + problem->c[preINS][idCusP];
							temp = problem->node[idCusP].eTW - cStartS;
							if (temp > eps)
							{
								 depart_idCusP = PDS_MAX(cStartS, problem->node[idCusP].sTW) + problem->node[idCusP].duration;
								 //2.1 Insert idCusD right after idCusP: don't need to check capacity of vehicle
 								 //cout<<" and (D after P; ";
								 ArrTime = PDS_MAX(depart_idCusP + problem->c[idCusP][idCusD], problem->node[idCusD].sTW) + problem->node[idCusD].duration + problem->c[idCusD][nextINS];
								 temp = problem->node[nextINS].eTW - ArrTime;
								 if (temp > 0) 
								 {
									 ArrTime = PDS_MAX(ArrTime, problem->node[nextINS].sTW) + problem->node[nextINS].duration;
									 curC = nextINS; nextC = nextArrTemp[nextINS];
									 ok = 1;
									 while (nextC > 0)
									 {
										 ArrTime += problem->c[curC][nextC];
										 temp = ArrTime - problem->node[nextC].eTW;
										 if (temp > eps) {ok = 0; break;} //vioTW at nextC
										 else
										 {
											 ArrTime = PDS_MAX(ArrTime, problem->node[nextC].sTW) + problem->node[nextC].duration;
											 curC = nextC; nextC = nextArrTemp[curC];
										 }
									 }
									 if (ok) //curC is now pointed to lastC
									 {
										 costC2C = costT + problem->c[idCusP][idCusD] + problem->c[idCusD][nextINS] - problem->c[idCusP][nextINS];
										 changed = 0;
										 costT1 = costC2C;
										 ok = checkPickupTripFeasible_AfterInsertC2C_Temp(curC,ArrTime,costT1,idVeh,idTripP,changed);
										 if (ok)
										 {
											 if (costT1 < costMINI)
											 {
												 costMINI = costT1;
												 costMINI1 = costC2C;
												 IDinsert = idCusP;
												 insert_afterP = preINS;
												 insert_afterD = idCusP;
												 changedSEED = changed;
											 }
										 }
									 }//end if (ok)
								 }//else vioTW at cus nextINS
		 						 //2.2 Find place to insert idCusD from position after nextINS assuming that idCusP is inserted between preINS and nextINS:
          						 ok = checkC2CAndPTripFeasible_AfterInsertC2C_Temp(idCusP,depart_idCusP,nextINS,j+1,departTemp,idVeh,idTripP);
								 if (ok) //TW is ok for all customers in trip C2C and next PTrip(idVeh, nextT) after inserting idCusP to the trip C2C between preINS and nextINS
								 {
									 i = j + 1; curC = nextINS;
									 while (i <= seg[idVeh].Trip[idTrip].numCus) //insert idCusD after curC at position i of idTrip
									 {
										 //2.2 Insert idCusD right after place i:
										 //cout<<" OR D after "<<curC<<"; ";
										 if (curC < startidC2CD) //curC is a C2CP
										 {
											 curC = problem->node[curC].delID;
											 i = pos[curC];
										 }
										 else //curC is a C2CD
										 {
                                              idCus = problem->node[curC].pickID;
											  //cout<<"idCusP = "<<idCus<<"; startidC2C = "<<startidC2C<<"; endidC2CP = "<<endidC2CP<<"; j = "<<j<<"; pos = "<<pos[idCus]<<endl;
											  if (pos[idCus] > j)
											  {
												  //Insert idCusD after curC: check capacity of vehicle and vioTW
												  ok = checkCapacity_C2CTrip_InitSol_Temp(nextINS,curC, FCAPT);
												  if (ok)
												  {
													  ArrTime = departTemp[i] + problem->c[curC][idCusD];
													  temp = problem->node[idCusD].eTW - ArrTime;
													  if (temp > eps)
													  {
															 ArrTime = PDS_MAX(ArrTime, problem->node[idCusD].sTW) + problem->node[idCusD].duration;
															 changed = 0;
															 costC2C = costT;
															 ok = checkC2CAndPTripFeasibleCostChange_AfterInsertC2C_Temp(idCusD,ArrTime, nextArrTemp[curC],costT1, idVeh,idTripP,changed);
															 if (ok) //it's ok to insert idCusD after curC
															 {
																 nextC = nextArrTemp[curC];
																 if (nextC > 0)
																	costC2C += (problem->c[curC][idCusD] + problem->c[idCusD][nextC] - problem->c[curC][nextC]);
																 else
																	 costC2C += (problem->c[curC][idCusD] + problem->c[idCusD][firstC_nextT] - problem->c[curC][firstC_nextT]);

																 costT1 += costC2C;
																 if (costT1 < costMINI)
																 {	
																	 costMINI = costT1;
																	 costMINI1 = costC2C;
																	 IDinsert = idCusP;
																	 insert_afterP = preINS;
																	 insert_afterD = curC;
																	 changedSEED = changed;
																 }
															 }
													  }//else vioTW at idCusD
												  }//else vio capacity of vehicle
												  i++; curC = nextArrTemp[curC];
											  }
											  else break;
										 }//end curC is a C2CD
									 }//end while
									// cout<<")"<<endl;
								 }//else TW is NOT ok for all customers in trip C2C and next PTrip(idVeh, nextT) after inserting idCusP to the trip C2C between preINS and nextINS
							}//else vioTW at idCusP
						 }//else can't insert between preINS and nextINS due to the capacity of the trip
						 preINS = nextINS; nextINS = nextArrTemp[preINS];
					 }//end for j

					 //3. Insert idCusP at the end of the trip C2C: [after preINS] --> dont need to check CAPACITY of vehicle
					 //cout<<"at the end of the trip"<<endl;
 					 cStartS = depart[preINS] + problem->c[preINS][idCusP];
					 temp = problem->node[idCusP].eTW - cStartS;
					 if (temp > eps)
					 {
								 depart_idCusP = PDS_MAX(cStartS, problem->node[idCusP].sTW) + problem->node[idCusP].duration;
								 //3.1 Insert idCusD right after idCusP:
 								 ArrTime = PDS_MAX(depart_idCusP + problem->c[idCusP][idCusD], problem->node[idCusD].sTW) + problem->node[idCusD].duration;
								 costC2C = problem->c[preINS][idCusP] + problem->c[idCusP][idCusD] + problem->c[idCusD][firstC_nextT] - problem->c[preINS][firstC_nextT];
								 costT1 = costC2C;
								 changed = 0;
								 ok = checkPickupTripFeasible_AfterInsertC2C_Temp(idCusD,ArrTime,costT1,idVeh,idTripP,changed);
								 if (ok)
								 {
									 if (costT1 < costMINI)
									 {
										 costMINI = costT1;
										 costMINI1 = costC2C;
										 IDinsert = idCusP;
										 insert_afterP = preINS;
										 insert_afterD = idCusP;
										 changedSEED = changed;
									 }
								 }//end if (ok)
					 }//else vioTW at idCusP
				 } //else idCusP already routed 
			 }//end for idCusP: try all unrouted C2C
			 if (IDinsert != -1)
			 {
				 idCusD = problem->node[IDinsert].delID;
				 //cout<<"CreateC2CTrip_BeforePickupTrip_Temp: Insert C2CP customer "<<IDinsert<<" after "<<insert_afterP<<" and insert C2CD "<<idCusD<<" after "<<insert_afterD<<": ";
				 if (insert_afterP == seg[idVeh].Trip[idTrip].lastCus) //insert at the end of the trip:
				 {
 					  nextArrTemp[insert_afterP] = IDinsert; 
					  nextArrTemp[IDinsert] = idCusD; nextArrTemp[idCusD] = 0;
					  seg[idVeh].Trip[idTrip].lastCus = idCusD;
  					  startS[IDinsert] = PDS_MAX(depart[insert_afterP] + problem->c[insert_afterP][IDinsert], problem->node[IDinsert].sTW);
					  depart[IDinsert] = startS[IDinsert] + problem->node[IDinsert].duration;
					  FCAP[IDinsert] = problem->node[IDinsert].capacity;
					  FCAP[idCusD] = 0;
					  pos[IDinsert] = pos[insert_afterP] + 1; pos[idCusD] = pos[IDinsert] + 1;
					  startS[idCusD] = PDS_MAX(depart[IDinsert] + problem->c[IDinsert][idCusD], problem->node[idCusD].sTW);
					  depart[idCusD] = startS[idCusD] + problem->node[idCusD].duration;
					  updatePTrip_InitSol_Temp(idVeh,idTripP, idCusD, firstC_nextT,changedSEED);
					  seg[idVeh].Trip[idTrip].cost += costMINI1;
				 }
				 else //not insert at the end of the trip C2C
				 {
					 if (insert_afterP == 0)
					 {
						 /*if (preC > 0)
						 {
						    double deltaCost = problem->c[preC][IDinsert] - problem->c[preC][firstC_C2C];
						    seg[idVeh].Trip[preT].connectCost = problem->c[preC][IDinsert];
						    seg[idVeh].Trip[preT].cost += deltaCost;
						    seg[idVeh].Trip[idTrip].cost += (costMINI1 - deltaCost);
						 }
						 else seg[idVeh].Trip[idTrip].cost += costMINI1;*/
						 seg[idVeh].Trip[idTrip].cost += costMINI1;
						 seg[idVeh].Trip[idTrip].firstCus = IDinsert;
						 nextArrTemp[IDinsert] = firstC_C2C;
						 startS[IDinsert] = PDS_MAX(depart_preC + problem->c[preC][IDinsert], problem->node[IDinsert].sTW);
						 depart[IDinsert] = startS[IDinsert] + problem->node[IDinsert].duration;
						 pos[IDinsert] = 1;
						 FCAP[IDinsert] = problem->node[IDinsert].capacity;
					 }
					 else //insert in the middle
					 {
 						  int tt=nextArrTemp[insert_afterP];
						  nextArrTemp[insert_afterP]=IDinsert;
						  nextArrTemp[IDinsert]=tt;
  						  startS[IDinsert] = PDS_MAX(depart[insert_afterP] + problem->c[insert_afterP][IDinsert], problem->node[IDinsert].sTW);
						  depart[IDinsert] = startS[IDinsert] + problem->node[IDinsert].duration;
						  pos[IDinsert] = pos[insert_afterP] + 1;
						  FCAP[IDinsert] = FCAP[insert_afterP] + problem->node[IDinsert].capacity;
						  seg[idVeh].Trip[idTrip].cost += costMINI1;
					 }//end insert in the middle

					 if (insert_afterD == IDinsert) //insert idCusD right after idCusP
					 {
						 startS[idCusD] = PDS_MAX(depart[IDinsert] + problem->c[IDinsert][idCusD], problem->node[idCusD].sTW);
						 depart[idCusD] = startS[idCusD] + problem->node[idCusD].duration;
						 int tt = nextArrTemp[IDinsert];
						 nextArrTemp[IDinsert] = idCusD; nextArrTemp[idCusD] = tt; 
						 pos[idCusD] = pos[IDinsert] + 1;
						 FCAP[idCusD] = FCAP[IDinsert] + problem->node[idCusD].capacity;
					 }
					 else //insert idCusD after insert_afterD:
					 {
						 curC = IDinsert; nextC = nextArrTemp[IDinsert];
						 do
						 {
							 startS[nextC] = PDS_MAX(depart[curC] + problem->c[curC][nextC], problem->node[nextC].sTW);
							 depart[nextC] = startS[nextC] + problem->node[nextC].duration;
							 pos[nextC] ++; FCAP[nextC] = FCAP[curC] + problem->node[nextC].capacity;
							 curC = nextC; nextC = nextArrTemp[curC];
						 }while (curC != insert_afterD);
						 //Insert idCusD after insert_afterD:
						 startS[idCusD] = PDS_MAX(depart[insert_afterD] + problem->c[insert_afterD][idCusD], problem->node[idCusD].sTW);
						 depart[idCusD] = startS[idCusD] + problem->node[idCusD].duration;
						 nextArrTemp[idCusD] = nextArrTemp[insert_afterD];
						 nextArrTemp[insert_afterD] = idCusD; 
 						 pos[idCusD] = pos[insert_afterD] + 1;
						 FCAP[idCusD] = FCAP[insert_afterD] + problem->node[idCusD].capacity;
					 }//end insert idCusD after insert_afterD:
					 nextC = nextArrTemp[idCusD];
					 if (nextC > 0)	 updateStartS_pos_FCAP_FEASIBLETRIP_Temp(idVeh,idTrip,idCusD,nextC,pos[idCusD]);
					 else seg[idVeh].Trip[idTrip].lastCus = idCusD;
					 updatePTrip_InitSol_Temp(idVeh, idTripP, seg[idVeh].Trip[idTrip].lastCus, firstC_nextT,changedSEED);
				 }//end not insert at the end of the trip C2C

				  seg[idVeh].Trip[idTrip].numCus +=2; 
				  //cout<<"--> numCus = "<<seg[idVeh].Trip[idTrip].numCus<<endl;
				  routedTemp[IDinsert] = 1; routedTemp[idCusD] = 1;
				  numCusC2CRoutedTemp += 2;
				  if (numCusC2CRoutedTemp == problem->nC2C) cont = 0;
				  //seg[idVeh].Trip[idTrip].cost += costMINI1;
				  seg[idVeh].Trip[idTrip].endS = depart[seg[idVeh].Trip[idTrip].lastCus];
				  seg[idVeh].Trip[idTrip].capacity += problem->node[IDinsert].capacity;
				  //cout<<"CALL checkC2C_P_FeasibleTrip_InitSol_Temp"<<endl;
				  ok = checkC2C_P_FeasibleTrip_InitSol_Temp(idVeh,idTrip, preC, depart_preC,idTripP);
				  //cout<<"DA GOI XONG checkC2C_P_FeasibleTrip_InitSol_Temp"<<endl;
				  if (ok == 0) exit(-1);
			 } else cont = 0; //can't route any C2C anymore
		 }while (cont);
		 //delete [] departTemp;
	 }
	 return 1;
}
bool Solution::CreateC2CTrip_BeforeSP_Temp(int idVeh, int preT, int preC, double depart_preC, int &idTrip, int value_assign_idTrip, int endSP)
{
	//ok 13/11/2013
	//Update 11/11/2013: Create a C2C Trip between PreTrip(idVeh, preT) and SP endSP: such that all trips are feasible; 
	//will try to insert C2C right after customer preC
    //Note: if (preC == 0) --> insert at the beginning of vehicle [after the depot] --> preT ko co gia tri gi ca vi ko co trip nao o truoc

	double cStartS = depart_preC;

	int idCusP, idCusD;
	double ArrTime;
	int type_preT;

	if (preC == 0) 
	{
		//cout<<"TRYING TO Create C2C trip at the begin of the vehicle "<<idVeh<<endl;
		type_preT = 2;
	}
	else if (seg[idVeh].Trip[preT].Type == 1)
	{
		//cout<<"Trying to create C2C trip between DTrip("<<idVeh<<", "<<preT<<") and SP "<<endSP<<endl;
		type_preT = 1;
	}
	else if (seg[idVeh].Trip[preT].Type == 0)
	{
		//cout<<"Trying to create C2C trip between PTrip("<<idVeh<<", "<<preT<<") and SP "<<endSP<<endl;
		type_preT = 0;
	}
    //1.Insert a C2C as the first customer of current trip:
	 double costT;
	 double costMINI = PDS_INFINITY; double temp; int seed=-1;
	 bool goWS, goWSSEED;
	 
	 for (idCusP = startidC2C;idCusP <= endidC2CP; idCusP ++)
	 {
		 routedTemp[idCusP] = routed[idCusP];
		 if (routedTemp[idCusP] == 0 && problem->belong[idCusP][endSP])
		 { 
			 idCusD = problem->node[idCusP].delID;
			 costT = problem->c[preC][idCusP] + problem->c[idCusP][idCusD] + problem->c[idCusD][endSP];
			 if (costT > costMINI) continue;
			 ArrTime = PDS_MAX(cStartS + problem->c[preC][idCusP], problem->node[idCusP].sTW); 
			 temp = ArrTime - problem->node[idCusP].eTW;
			 if (temp > eps) continue;
			 ArrTime += (problem->node[idCusP].duration + problem->c[idCusP][idCusD]);
			 temp = ArrTime - problem->node[idCusD].eTW;
			 if (temp > eps) continue;
			 ArrTime = PDS_MAX(ArrTime, problem->node[idCusD].sTW) + problem->node[idCusD].duration;
             bool cont = 0;
			 cont = checkFeasible_ConnectC2CDToSP(idCusD,ArrTime,costT,endSP,goWS);
			 if (cont)
			 {
				 if (costT < costMINI)
				 {
					 seed = idCusP;
					 costMINI = costT;
					 goWSSEED = goWS;
				 }
			 }
		 }
	 }

	 if (seed == -1)
	 {
	 	 //cout<<"Cant create C2C "<<endl;
		 return 0;
	 }

	 idCusD = problem->node[seed].delID;
	 routedTemp[seed]=1; routedTemp[idCusD] = 1;
	 idTrip = value_assign_idTrip;
	 seg[idVeh].Trip[idTrip].Type = 2;
	 seg[idVeh].Trip[idTrip].firstCus = seed;
	 seg[idVeh].Trip[idTrip].lastCus = idCusD;

	 /*seg[idVeh].Trip[preT].connectCost = problem->c[preC][seed];
	 if (type_preT == 1)
	 {
		 if (seg[idVeh].Trip[preT].waitingS == NO_WS)
			seg[idVeh].Trip[preT].cost += (problem->c[preC][seed] - problem->c[preC][endSP]);
		 else
			seg[idVeh].Trip[preT].cost += (problem->c[preC][seed] - problem->disCWSSP[preC][endSP]);
	 }
	 else if (type_preT == 0)
	 {
		 if (seg[idVeh].Trip[preT].waitingS1 == NO_WS)
			seg[idVeh].Trip[preT].cost += (problem->c[preC][seed] - problem->c[preC][endSP]);
		 else
			seg[idVeh].Trip[preT].cost += (problem->c[preC][seed] - problem->disCWSSP[preC][endSP]);
	 }
     if (goWSSEED) 
	 {
		 seg[idVeh].Trip[idTrip].cost = problem->c[seed][idCusD] + problem->disCWSSP[idCusD][endSP];
		 seg[idVeh].Trip[idTrip].waitingS = problem->CWSSP[idCusD][endSP];
	 }
	 else
	 {
		 seg[idVeh].Trip[idTrip].cost = problem->c[seed][idCusD] + problem->c[idCusD][endSP];
		 seg[idVeh].Trip[idTrip].waitingS = NO_WS;
	 }
	 */
	 if (type_preT == 1)
	 {
		 if (seg[idVeh].Trip[preT].waitingS == NO_WS)
			 seg[idVeh].Trip[preT].cost -= problem->c[preC][endSP];
		 else seg[idVeh].Trip[preT].cost -= problem->disCWSSP[preC][endSP];
	 }
	 else if (type_preT == 0)
	 {
		 if (seg[idVeh].Trip[preT].waitingS1 == NO_WS)
			 seg[idVeh].Trip[preT].cost -= problem->c[preC][endSP];
		 else seg[idVeh].Trip[preT].cost -= problem->disCWSSP[preC][endSP];
	 }
	 
     if (goWSSEED) 
	 {
		 seg[idVeh].Trip[idTrip].cost = problem->c[preC][seed] + problem->c[seed][idCusD] + problem->disCWSSP[idCusD][endSP];
		 //seg[idVeh].Trip[idTrip].connectCost = problem->disCWSSP[idCusD][endSP];
		 seg[idVeh].Trip[idTrip].waitingS = problem->CWSSP[idCusD][endSP];
	 }
	 else
	 {
		 seg[idVeh].Trip[idTrip].cost = problem->c[preC][seed] + problem->c[seed][idCusD] + problem->c[idCusD][endSP];
		 //seg[idVeh].Trip[idTrip].connectCost = problem->c[idCusD][endSP];
		 seg[idVeh].Trip[idTrip].waitingS = NO_WS;
	 }
	 startS[seed] = PDS_MAX(cStartS + problem->c[preC][seed], problem->node[seed].sTW);
	 depart[seed] = startS[seed] + problem->node[seed].duration;
     startS[idCusD] = PDS_MAX(depart[seed] + problem->c[seed][idCusD], problem->node[idCusD].sTW);
	 depart[idCusD] = startS[idCusD] + problem->node[idCusD].duration;
	// cout<<"Can create C2C("<<seed<<", "<<idCusD<<"): cost = "<<seg[idVeh].Trip[idTrip].cost<<"WS = "<<seg[idVeh].Trip[idTrip].waitingS<<"; preC = "<<preC<<endl;

	 seg[idVeh].Trip[idTrip].numCus = 2;
	 seg[idVeh].Trip[idTrip].feasible = 1;
	 seg[idVeh].Trip[idTrip].endS = depart[idCusD];
	 int numCusC2CRoutedTemp = numCusC2CRouted;
	 numCusC2CRoutedTemp += 2;
	 nextArrTemp[seed] = idCusD; nextArrTemp[idCusD] = 0;
	 pos[seed] = 1; pos[idCusD] = 2;
	 FCAP[seed] = problem->node[seed].capacity;
	 FCAP[idCusD] = 0;
	 seg[idVeh].Trip[idTrip].capacity = problem->node[seed].capacity;

	 //Now trying to insert more C2C to trip(idVeh,idTrip):
     if (numCusC2CRoutedTemp < problem->nC2C)
	 {
		 double costT1, depart_idCusP;
		 int i,j, firstC_C2C, idCus, insert_afterP, insert_afterD, curC, nextC, preINS, nextINS, IDinsert, FCAPT;
		 double *departTemp = new double[250];
		 bool cont = 1; bool ok,changeWS,changeWSSEED;
		 do //each loop insert a pair of C2C
		 {
			 IDinsert = -1; costMINI = PDS_INFINITY;
			 firstC_C2C = seg[idVeh].Trip[idTrip].firstCus;
			 for (idCusP = startidC2C; idCusP <= endidC2CP; idCusP ++)
			 {
				 if (routedTemp[idCusP] == 0 && problem->belong[idCusP][endSP])
				 {
					 //1. First try to insert at the beginning of the trip:
					 FCAPT = problem->node[idCusP].capacity;
					 ArrTime = PDS_MAX(depart_preC + problem->c[preC][idCusP], problem->node[idCusP].sTW); 
					 temp = ArrTime - problem->node[idCusP].eTW;
					 if (temp > eps) continue;
					 //Insert idCusP at the beginning of the trip, now find place to insert idCusD
					 idCusD = problem->node[idCusP].delID;
					 depart_idCusP = ArrTime + problem->node[idCusP].duration;
					 //1.1 Insert idCusD right after idCusP: then capacity of vehicle is ok since already ok when inserting idCusP
					 ArrTime = depart_idCusP + problem->c[idCusP][idCusD];
					 temp = ArrTime - problem->node[idCusD].eTW;
					 if (temp > eps) continue;
					 ok = 1;
					 //cout<<"D rightafter P"<<"; ";

					 ArrTime = PDS_MAX(ArrTime, problem->node[idCusD].sTW) + problem->node[idCusD].duration;
					 costT = problem->c[preC][idCusP] + problem->c[idCusP][firstC_C2C] - problem->c[preC][firstC_C2C];
					 costT1 = costT; double buct1 = costT1;
					 ok = checkC2CTripFeasibleCostChange_AfterInsertC2C_Temp(idCusD,ArrTime, firstC_C2C,costT1,idVeh,idTrip,endSP,changeWS);
					 if (ok)
					 {
						 double buct2 = costT1;
						 costT1 += (problem->c[idCusP][idCusD] + problem->c[idCusD][firstC_C2C] - problem->c[idCusP][firstC_C2C]);
						 if (costT1 < costMINI)
						 {
							 costMINI = costT1;
							 IDinsert = idCusP;
							 insert_afterP = 0;
							 insert_afterD = idCusP;
							 changeWSSEED = changeWS;
							// cout<<"C2CPD together at the first: preC = "<<preC<<"; connect P = "<<buct1<<"; connectSP = "<<(buct2-buct1)<<"; connectD = "<<(costT1-buct2)<<"; deltaCost = "<<costT1<<endl;
						 }
					 }

					 /*ArrTime = PDS_MAX(ArrTime, problem->node[idCusD].sTW) + problem->node[idCusD].duration + problem->c[idCusD][firstC_C2C];
					 costT = problem->c[preC][idCusP] + problem->c[idCusP][firstC_C2C] - problem->c[preC][firstC_C2C];

					 temp = problem->node[firstC_C2C].eTW - ArrTime;
					 if (temp > 0) 
					 {
							 ArrTime = PDS_MAX(ArrTime, problem->node[firstC_C2C].sTW) + problem->node[firstC_C2C].duration;
							 curC = firstC_C2C; nextC = nextArrTemp[firstC_C2C];
							 while (nextC > 0)
							 {
								 ArrTime += problem->c[curC][nextC];
								 temp = ArrTime - problem->node[nextC].eTW;
								 if (temp > eps) {ok = 0; break;} //vioTW at nextC
								 else
								 {
									 ArrTime = PDS_MAX(ArrTime, problem->node[nextC].sTW) + problem->node[nextC].duration;
									 curC = nextC; nextC = nextArrTemp[curC];
								 }
							 }
							 if (ok) //curC is now pointed to lastC
							 {
								 costT1 = costT + problem->c[idCusP][idCusD] + problem->c[idCusD][firstC_C2C] - problem->c[idCusP][firstC_C2C];
								 //changeWS = 0;
								 ok = checkFeasibleCostChange_ConnectC2CDToSP(curC,ArrTime,costT1,endSP,seg[idVeh].Trip[idTrip].waitingS, changeWS);
								 if (ok)
								 {
									 if (costT1 < costMINI)
									 {
										 costMINI = costT1;
										 IDinsert = idCusP;
										 insert_afterP = 0;
										 insert_afterD = idCusP;
										 changeWSSEED = changeWS;
									 }
								 }
							 }//end if (ok)
						 }//else vioTW at cus nextINS*/
						 
						 //1.2 Find place to insert idCusD from position after firstC_C2C assuming that idCusP is inserted at the beginning of the trip:
                          ok = checkC2CTripFeasible_AfterInsertC2C_Temp(idCusP, depart_idCusP,firstC_C2C,1,departTemp,endSP);
						  if (ok) //TW is ok for all customers in trip C2C and next PTrip(idVeh, nextT) after inserting idCusP to the trip C2C
						  {
							 int i = 1; curC = firstC_C2C;
							 while (i <= seg[idVeh].Trip[idTrip].numCus) //insert idCusD after curC at position i of idTrip
							 {
								 //1.2 Insert idCusD right after place i
								 if (curC < startidC2CD) //curC is a C2CP
								 {
									 curC = problem->node[curC].delID;
									 i = pos[curC];
								 }
								 else //curC is a C2CD:
								 {
									 idCus = problem->node[curC].pickID;
									 if (pos[idCus] > 0)
									 {
										 //Insert idCusD after curC: check capacity and vioTW
										 ok = checkCapacity_C2CTrip_InitSol_Temp(firstC_C2C, curC,FCAPT);
										 if (ok)
										 {
											 ArrTime = departTemp[i] + problem->c[curC][idCusD];
											 temp = problem->node[idCusD].eTW - ArrTime;
											 if (temp > eps)
											 {
												 ArrTime = PDS_MAX(ArrTime, problem->node[idCusD].sTW) + problem->node[idCusD].duration;
												 costT1 = costT; double buc1 = costT1;
												 ok = checkC2CTripFeasibleCostChange_AfterInsertC2C_Temp(idCusD,ArrTime, nextArrTemp[curC],costT1,idVeh,idTrip,endSP,changeWS);
												 if (ok) //it's ok to insert idCusD after curC
												 {
													 nextC = nextArrTemp[curC]; double buc2 = costT1;
													 if (nextC > 0)
														costT1 += (problem->c[curC][idCusD] + problem->c[idCusD][nextC] - problem->c[curC][nextC]);
													 else
														costT1 += problem->c[curC][idCusD];

													 if (costT1 < costMINI)
													 {	
														 costMINI = costT1;
														 IDinsert = idCusP;
														 insert_afterP = 0;
														 insert_afterD = curC;
														 changeWSSEED = changeWS;
														 //cout<<"cost change at connect cusP = "<<buc1<<" cost change at SP = "<<(buc2-buc1)<<"; cost change to connect cusD = "<<(costT1-buc2)<<"; endSP = "<<endSP<<"; costMINI = "<<costMINI<<endl;
													 }
												 }
											 }

										 }//else not ok capacity of vehicle
										 i ++; curC = nextArrTemp[curC];
									 }
									 else break;
								 }
							 }
						  }
					 //2. Insert idCusP in the middle of the trip
					 preINS = firstC_C2C;
					 nextINS = nextArrTemp[preINS];
                     for (j=1;j<seg[idVeh].Trip[idTrip].numCus;j++) //insert idCusP between preINS and nextINS
					 {
						 FCAPT = FCAP[preINS] + problem->node[idCusP].capacity;
						 if (FCAPT <= problem->Q)
						 {
	 						costT = problem->c[preINS][idCusP] + problem->c[idCusP][nextINS] - problem->c[preINS][nextINS];
							cStartS = depart[preINS] + problem->c[preINS][idCusP];
							temp = problem->node[idCusP].eTW - cStartS;
							if (temp > eps)
							{
								 depart_idCusP = PDS_MAX(cStartS, problem->node[idCusP].sTW) + problem->node[idCusP].duration;
								 //2.1 Insert idCusD right after idCusP: don't need to check capacity of vehicle
								 ArrTime = PDS_MAX(depart_idCusP + problem->c[idCusP][idCusD], problem->node[idCusD].sTW) + problem->node[idCusD].duration;
								 costT1 = costT;
								 ok = checkC2CTripFeasibleCostChange_AfterInsertC2C_Temp(idCusD,ArrTime,nextINS,costT1,idVeh,idTrip,endSP,changeWS);
							     if (ok) //it's ok to insert idCusD right after idCusP
								 {
									 costT1 += (problem->c[idCusP][idCusD] + problem->c[idCusD][nextINS] - problem->c[idCusP][nextINS]);
									 if (costT1 < costMINI)
									 {
										 costMINI = costT1;
										 IDinsert = idCusP;
										 insert_afterP = preINS;
										 insert_afterD = idCusP;
										 changeWSSEED = changeWS;
									 }
								 }
		 						 //2.2 Find place to insert idCusD from position after nextINS assuming that idCusP is inserted between preINS and nextINS:
          						 ok = checkC2CTripFeasible_AfterInsertC2C_Temp(idCusP,depart_idCusP,nextINS,j+1,departTemp,endSP);
								 if (ok) //TW is ok for all customers in trip C2C and next PTrip(idVeh, nextT) after inserting idCusP to the trip C2C between preINS and nextINS
								 {
									 i = j + 1; curC = nextINS;
									 while (i <= seg[idVeh].Trip[idTrip].numCus) //insert idCusD after curC at position i of idTrip
									 {
										 //2.2 Insert idCusD right after place i:
										 if (curC < startidC2CD) //curC is a C2CP
										 {
											 curC = problem->node[curC].delID;
											 i = pos[curC];
										 }
										 else //curC is a C2CD
										 {
                                              idCus = problem->node[curC].pickID;
											  if (pos[idCus] > j)
											  {
												  //Insert idCusD after curC: check capacity of vehicle and vioTW
												  ok = checkCapacity_C2CTrip_InitSol_Temp(nextINS,curC, FCAPT);
												  if (ok)
												  {
													  ArrTime = departTemp[i] + problem->c[curC][idCusD];
													  temp = problem->node[idCusD].eTW - ArrTime;
													  if (temp > eps)
													  {
															 ArrTime = PDS_MAX(ArrTime, problem->node[idCusD].sTW) + problem->node[idCusD].duration;
															 costT1 = costT;
															 ok = checkC2CTripFeasibleCostChange_AfterInsertC2C_Temp(idCusD,ArrTime,nextArrTemp[curC],costT1,idVeh,idTrip,endSP,changeWS);
															 if (ok) //it's ok to insert idCusD after curC
															 {
																 nextC = nextArrTemp[curC];
																 if (nextC > 0)
																	costT1 += (problem->c[curC][idCusD] + problem->c[idCusD][nextC] - problem->c[curC][nextC]);
																 else
																	 costT1 += problem->c[curC][idCusD];

																 if (costT1 < costMINI)
																 {	
																	 costMINI = costT1;
																	 IDinsert = idCusP;
																	 insert_afterP = preINS;
																	 insert_afterD = curC;
																	 changeWSSEED = changeWS;
																 }
															 }
													  }//else vioTW at idCusD
												  }//else vio capacity of vehicle
												  i++; curC = nextArrTemp[curC];
											  }
											  else break;
										 }//end curC is a C2CD
									 }//end while
								 }//else TW is NOT ok for all customers in trip C2C and next PTrip(idVeh, nextT) after inserting idCusP to the trip C2C between preINS and nextINS
							}//else vioTW at idCusP
						 }//else can't insert between preINS and nextINS due to the capacity of the trip
						 preINS = nextINS; nextINS = nextArrTemp[preINS];
					 }//end for j

					 //3. Insert idCusP at the end of the trip C2C: [after preINS] --> dont need to check CAPACITY of vehicle
 					 cStartS = depart[preINS] + problem->c[preINS][idCusP];
					 temp = problem->node[idCusP].eTW - cStartS;
					 if (temp > eps)
					 {
								 depart_idCusP = PDS_MAX(cStartS, problem->node[idCusP].sTW) + problem->node[idCusP].duration;
								 //3.1 Insert idCusD right after idCusP:
 								 ArrTime = PDS_MAX(depart_idCusP + problem->c[idCusP][idCusD], problem->node[idCusD].sTW) + problem->node[idCusD].duration;
								 costT1 = problem->c[preINS][idCusP] + problem->c[idCusP][idCusD];
								 ok = checkFeasible_ConnectC2CDToSP_AfterInsertC2C(idCusD,ArrTime,costT1,seg[idVeh].Trip[idTrip].lastCus,endSP,seg[idVeh].Trip[idTrip].waitingS,changeWS); 
								 if (ok)
								 {
									 if (costT1 < costMINI)
									 {
										 costMINI = costT1;
										 IDinsert = idCusP;
										 insert_afterP = preINS;
										 insert_afterD = idCusP;
										 changeWSSEED = changeWS;
									 }
								 }//end if (ok)
					 }//else vioTW at idCusP
				 } //else idCusP already routed 
			 }//end for idCusP: try all unrouted C2C
			 if (IDinsert != -1)
			 {
		  
				 idCusD = problem->node[IDinsert].delID;
				 //cout<<"Insert C2CP customer "<<IDinsert<<" after "<<insert_afterP<<" and insert C2CD "<<idCusD<<" after "<<insert_afterD<<": "<<endl;
				 if (insert_afterP == seg[idVeh].Trip[idTrip].lastCus) //insert at the end of the trip:
				 {
 					  nextArrTemp[insert_afterP] = IDinsert; 
					  nextArrTemp[IDinsert] = idCusD; 
					  seg[idVeh].Trip[idTrip].lastCus = idCusD;nextArrTemp[idCusD] = 0;
  					  startS[IDinsert] = PDS_MAX(depart[insert_afterP] + problem->c[insert_afterP][IDinsert], problem->node[IDinsert].sTW);
					  depart[IDinsert] = startS[IDinsert] + problem->node[IDinsert].duration;
					  FCAP[IDinsert] = problem->node[IDinsert].capacity;
					  FCAP[idCusD] = 0;
					  pos[IDinsert] = pos[insert_afterP] + 1; pos[idCusD] = pos[IDinsert] + 1;
					  startS[idCusD] = PDS_MAX(depart[IDinsert] + problem->c[IDinsert][idCusD], problem->node[idCusD].sTW);
					  depart[idCusD] = startS[idCusD] + problem->node[idCusD].duration;
					  seg[idVeh].Trip[idTrip].cost += costMINI;
					  if (changeWSSEED) //gotoWS:
						  seg[idVeh].Trip[idTrip].waitingS = problem->CWSSP[idCusD][endSP];
					  else seg[idVeh].Trip[idTrip].waitingS = NO_WS;
					  
				 }
				 else //not insert at the end of the trip C2C
				 {
					 if (insert_afterP == 0)
					 {
						 /*if (preC > 0)
						 {
							 double deltaCost = problem->c[preC][IDinsert] - problem->c[preC][firstC_C2C];
							 seg[idVeh].Trip[preT].connectCost = problem->c[preC][IDinsert];
							 seg[idVeh].Trip[preT].cost += deltaCost;
							 seg[idVeh].Trip[idTrip].cost += (costMINI - deltaCost);
						 }
						 else
						 {
							 seg[idVeh].Trip[idTrip].cost += costMINI;
						 }*/
						 seg[idVeh].Trip[idTrip].cost += costMINI;
						 seg[idVeh].Trip[idTrip].firstCus = IDinsert;
						 nextArrTemp[IDinsert] = firstC_C2C;
						 startS[IDinsert] = PDS_MAX(depart_preC + problem->c[preC][IDinsert], problem->node[IDinsert].sTW);
						 depart[IDinsert] = startS[IDinsert] + problem->node[IDinsert].duration;
						 pos[IDinsert] = 1;
						 FCAP[IDinsert] = problem->node[IDinsert].capacity;
					 }
					 else //insert in the middle
					 {
 						  int tt=nextArrTemp[insert_afterP];
						  nextArrTemp[insert_afterP]=IDinsert;
						  nextArrTemp[IDinsert]=tt;
  						  startS[IDinsert] = PDS_MAX(depart[insert_afterP] + problem->c[insert_afterP][IDinsert], problem->node[IDinsert].sTW);
						  depart[IDinsert] = startS[IDinsert] + problem->node[IDinsert].duration;
						  pos[IDinsert] = pos[insert_afterP] + 1;
						  seg[idVeh].Trip[idTrip].cost += costMINI;
						  FCAP[IDinsert] = FCAP[insert_afterP] + problem->node[IDinsert].capacity;
					 }//end insert in the middle

					 if (insert_afterD == IDinsert) //insert idCusD right after idCusP
					 {
						 startS[idCusD] = PDS_MAX(depart[IDinsert] + problem->c[IDinsert][idCusD], problem->node[idCusD].sTW);
						 depart[idCusD] = startS[idCusD] + problem->node[idCusD].duration;
						 int tt = nextArrTemp[IDinsert];
						 nextArrTemp[IDinsert] = idCusD; nextArrTemp[idCusD] = tt; 
						 pos[idCusD] = pos[IDinsert] + 1;
						 FCAP[idCusD] = FCAP[IDinsert] + problem->node[idCusD].capacity;
					 }
					 else //insert idCusD after insert_afterD:
					 {
						 curC = IDinsert; nextC = nextArrTemp[IDinsert];
						 do
						 {
							 startS[nextC] = PDS_MAX(depart[curC] + problem->c[curC][nextC], problem->node[nextC].sTW);
							 depart[nextC] = startS[nextC] + problem->node[nextC].duration;
							 pos[nextC] ++; FCAP[nextC] = FCAP[curC] + problem->node[nextC].capacity;
							 curC = nextC; nextC = nextArrTemp[curC];
						 }while (curC != insert_afterD);
						 //Insert idCusD after insert_afterD:
						 startS[idCusD] = PDS_MAX(depart[insert_afterD] + problem->c[insert_afterD][idCusD], problem->node[idCusD].sTW);
						 depart[idCusD] = startS[idCusD] + problem->node[idCusD].duration;
						 nextArrTemp[idCusD] = nextArrTemp[insert_afterD];
						 nextArrTemp[insert_afterD] = idCusD; 
						 pos[idCusD] = pos[insert_afterD] + 1;
						 FCAP[idCusD] = FCAP[insert_afterD] + problem->node[idCusD].capacity;
					 }//end insert idCusD after insert_afterD:
					 nextC = nextArrTemp[idCusD];
					 if (nextC > 0)
					 {
						 updateStartS_pos_FCAP_FEASIBLETRIP_Temp(idVeh,idTrip,idCusD,nextC,pos[idCusD]);
						 //lastCus of C2C doesn't change
						 if (changeWSSEED) seg[idVeh].Trip[idTrip].waitingS = NO_WS;
					 }
					 else
					 {
						 seg[idVeh].Trip[idTrip].lastCus = idCusD;
						 //lastCus of C2C has changed:
						 if (changeWSSEED) seg[idVeh].Trip[idTrip].waitingS = problem->CWSSP[idCusD][endSP];
						 else seg[idVeh].Trip[idTrip].waitingS = NO_WS;
					 }
				 }//end not insert at the end of the trip C2C

				  seg[idVeh].Trip[idTrip].numCus +=2; 
				  //cout<<"Now #customer of C2Ctrip = "<<seg[idVeh].Trip[idTrip].numCus<<endl;
				  routedTemp[IDinsert] = 1; routedTemp[idCusD] = 1;
				  numCusC2CRoutedTemp += 2;
				  if (numCusC2CRoutedTemp == problem->nC2C) cont = 0;
				  seg[idVeh].Trip[idTrip].capacity += problem->node[IDinsert].capacity;
				  //seg[idVeh].Trip[idTrip].cost += costMINI1;
				  seg[idVeh].Trip[idTrip].endS = depart[seg[idVeh].Trip[idTrip].lastCus];
				  ok = checkC2C_FeasibleTrip_InitSol_Temp(idVeh,idTrip,preC,depart_preC,1,endSP);
				  if (ok == 0) exit(-1);
			 } else cont = 0; //can't route any C2C anymore
		 }while (cont);
		 delete [] departTemp;

	 }
	 int lastC2C = seg[idVeh].Trip[idTrip].lastCus;
	 if (seg[idVeh].Trip[idTrip].waitingS == NO_WS)
		seg[idVeh].Trip[idTrip].arriveSP = depart[lastC2C] + problem->c[lastC2C][endSP];
	 else
        seg[idVeh].Trip[idTrip].arriveSP = PDS_MAX(depart[lastC2C] + problem->disCWSSP[lastC2C][endSP], problem->nodeSP[endSP].sTW2);
     seg[idVeh].Trip[idTrip].leaveSP = seg[idVeh].Trip[idTrip].leaveSP;	
	 return 1;
}
bool Solution::checkCapacity_C2CTrip_InitSol_Temp(int fromC, int tillC, int CAPINS)
{
	int nextC = fromC;
	while (nextC != tillC)
	{
		CAPINS += problem->node[nextC].capacity;
		if (CAPINS > problem->Q) return 0;
		nextC = nextArrTemp[nextC];
	}
	CAPINS += problem->node[tillC].capacity;
	if (CAPINS > problem->Q) return 0;
	return 1;

}

bool Solution::checkCapacity_C2CTrip_InitSol(int fromC, int tillC, int CAPINS)
{
	int nextC = fromC;
	while (nextC != tillC)
	{
		CAPINS += problem->node[nextC].capacity;
		if (CAPINS > problem->Q) return 0;
		nextC = nextArr[nextC];
	}
	CAPINS += problem->node[tillC].capacity;
	if (CAPINS > problem->Q) return 0;
	return 1;

}

void Solution::CreateVehicle_C2COnly()
{
	//Create vehicle with only C2C:
	int idCusP = startidC2C; int idCusD;
	double costMINI = PDS_INFINITY; int seed = -1;
	double costC2C;

	//1. Insert first C2C into the vehicle:
	for (idCusP = startidC2C; idCusP <= endidC2CP; idCusP++)
	{
		if (routed[idCusP] == 0)
		{
			 idCusD = problem->node[idCusP].delID;
			 costC2C = problem->c[0][idCusP] + problem->c[idCusP][idCusD] + problem->c[idCusD][0];
			 //cout<<"cost to route C2C("<<idCusP<<", "<<idCusD<<") = "<<costC2C<<" = "<<problem->c[0][idCusP]<<" + "<<problem->c[idCusP][idCusD]<<" + "<<problem->c[idCusD][0]<<endl;
			 if (costC2C < costMINI)
			 {
				 seed = idCusP;
				 costMINI = costC2C;
			 }
		}//else idCusP already routed
	}//end for idCusP
	if (seed == -1)
	{
		cout<<"ERROR why there is still unrouted C2C, but can't routed them"<<endl;
		cout<<"List C2CP not routed yet: "<<endl;
		for (idCusP = startidC2C; idCusP <= endidC2CP; idCusP++)
			if (routed[idCusP] == 0) cout<<idCusP<<"; ";
		cout<<endl;

		cout<<"List C2CD not routed yet: "<<endl;
		for (idCusP = startidC2CD; idCusP <= endidC2C; idCusP++)
			if (routed[idCusP] == 0) cout<<idCusP<<"; ";
		cout<<endl;
		cout<<"startidC2C = "<<startidC2C<<"; endidC2CP = "<<endidC2CP<<endl;
		exit(-1);
	}

	seg[numVeh].numTrips = 1;

	 //cout<<"Create a vehicle "<<numVeh<<" with only C2C: ";
	 idCusD = problem->node[seed].delID;
	 routed[seed]=1; routed[idCusD] = 1;
	 seg[numVeh].Trip[0].Type = 2;
	 seg[numVeh].Trip[0].firstCus = seed;
	 seg[numVeh].Trip[0].lastCus = idCusD;
	 seg[numVeh].Trip[0].cost = costMINI;
	 seg[numVeh].Trip[0].connectCost = problem->c[idCusD][0];

	 startS[seed] = problem->node[seed].startS_depot;
	 depart[seed] = problem->node[seed].depart_depot;
     startS[idCusD] = PDS_MAX(depart[seed] + problem->c[seed][idCusD], problem->node[idCusD].sTW);
	 depart[idCusD] = startS[idCusD] + problem->node[idCusD].duration;
	 seg[numVeh].Trip[0].numCus = 2;
	 seg[numVeh].Trip[0].feasible = 1;
	 seg[numVeh].Trip[0].endS = depart[idCusD];
	 numCusC2CRouted += 2;
	 nextArr[seed] = idCusD; nextArr[idCusD] = 0;
	 pos[seed] = 1; pos[idCusD] = 2;
	 FCAP[seed] = problem->node[seed].capacity;
	 FCAP[idCusD] = 0;
	 //cout<<"("<<seed<<"="<<problem->node[seed].id<<", "<<idCusD<<"="<<problem->node[idCusD].id<<"); dis = "<<problem->c[seed][idCusD]<<endl;
	 //cout<<"C2CP: ("<<startS[seed]<<", "<<depart[seed]<<"); C2CD: ("<<startS[idCusD]<<", "<<depart[idCusD]<<")"<<endl;

	 //Now trying to insert more C2C to trip(idVeh,idTrip):
     if (numCusC2CRouted < problem->nC2C)
	 {
		 double depart_idCusP, costT, ArrTime, temp, cStartS;
		 int i,j, firstC_C2C, idCus, insert_afterP, insert_afterD, curC, nextC, preINS, nextINS, IDinsert, FCAPT;
		 double *departTemp = new double[250];
		 bool cont = 1; bool ok;
		 do //each loop insert a pair of C2C
		 {
			 IDinsert = -1; costMINI = PDS_INFINITY;
			 firstC_C2C = seg[numVeh].Trip[0].firstCus;
			 for (idCusP = startidC2C; idCusP <= endidC2CP; idCusP ++)
			 {
				 if (routed[idCusP] == 0)
				 {
					 idCusD = problem->node[idCusP].delID;
					 //1. First try to insert at the beginning of the trip:
					 nextINS = firstC_C2C;
					 FCAPT = problem->node[idCusP].capacity;
					 ok = 1;
					 costT = problem->c[0][idCusP] + problem->c[idCusP][firstC_C2C] - problem->c[0][firstC_C2C];
					 //Insert idCusP at the beginning of the trip, now find place to insert idCusD
					 depart_idCusP = PDS_MAX(problem->c[0][idCusP], problem->node[idCusP].sTW) + problem->node[idCusP].duration;
					 //1.1 Insert idCusD right after idCusP: then capacity of vehicle is ok since already ok when inserting idCusP
 					 ArrTime = PDS_MAX(depart_idCusP + problem->c[idCusP][idCusD], problem->node[idCusD].sTW) + problem->node[idCusD].duration + problem->c[idCusD][nextINS];
					 temp = problem->node[nextINS].eTW - ArrTime;
					 if (temp > 0) 
					 {
							 ArrTime = PDS_MAX(ArrTime, problem->node[nextINS].sTW) + problem->node[nextINS].duration;
							 curC = nextINS; nextC = nextArr[nextINS];
							 while (nextC > 0)
							 {
								 ArrTime += problem->c[curC][nextC];
								 temp = ArrTime - problem->node[nextC].eTW;
								 if (temp > eps) {ok = 0; break;} //vioTW at nextC
								 else
								 {
									 ArrTime = PDS_MAX(ArrTime, problem->node[nextC].sTW) + problem->node[nextC].duration;
									 curC = nextC; nextC = nextArr[curC];
								 }
							 }
							 if (ok) //curC is now pointed to lastC
							 {
								 costC2C = costT + problem->c[idCusP][idCusD] + problem->c[idCusD][nextINS] - problem->c[idCusP][nextINS];
								 if (costC2C < costMINI)
								 {
									 costMINI = costC2C;
									 IDinsert = idCusP;
									 insert_afterP = 0;
									 insert_afterD = idCusP;
								 }
							 }//end if (ok)
						 }//else vioTW at cus nextINS
						 
						 //1.2 Find place to insert idCusD from position after nextINS assuming that idCusP is inserted at the beginning of the trip:
                          ok = checkC2CVehicleFeasible(idCusP,depart_idCusP,firstC_C2C,1,departTemp);
						  if (ok) //TW is ok for all C2C customers after inserting idCusP
						  {
							 int i = 1; curC = firstC_C2C;
							 while (i <= seg[numVeh].Trip[0].numCus) //insert idCusD after curC at position i of idTrip
							 {
								 //1.2 Insert idCusD right after place i
								 if (curC < startidC2CD) //curC is a C2CP
								 {
									 curC = problem->node[curC].delID;
									 i = pos[curC];
								 }
								 else //curC is a C2CD:
								 {
									 idCus = problem->node[curC].pickID;
									 if (pos[idCus] > 0)
									 {
										 //Insert idCusD after curC: check capacity and vioTW
										 ok = checkCapacity_C2CTrip_InitSol(firstC_C2C, curC,FCAPT);
										 if (ok)
										 {
											 ArrTime = departTemp[i] + problem->c[curC][idCusD];
											 temp = problem->node[idCusD].eTW - ArrTime;
											 if (temp > eps)
											 {
												 ArrTime = PDS_MAX(ArrTime, problem->node[idCusD].sTW) + problem->node[idCusD].duration;
												 nextC = nextArr[curC]; //nextC = 0--> depot
												 //need to check from nextC till the depot:
												 ok = 1;
												 if (nextC > 0)
												 {
                                                   int curC1 = idCusD; int nextC1 = nextC;
												   while (nextC1 > 0)
												   {
															 ArrTime = PDS_MAX(ArrTime + problem->c[curC1][nextC1],problem->node[nextC1].sTW);
															 if (PDSDIF(ArrTime, startS[nextC1])==0) break;
															 temp = ArrTime - problem->node[nextC1].eTW;
															 if (temp > eps) {ok = 0; break;} //vioTW at nextC1
															 ArrTime += problem->node[nextC1].duration;
															 curC1 = nextC1; nextC1 = nextArr[curC1];
													}
												 }
												 if (ok)
												 {
													 costC2C = costT + (problem->c[curC][idCusD] + problem->c[idCusD][nextC] - problem->c[curC][nextC]);
													 if (costC2C < costMINI)
													 {	
														 costMINI = costC2C;
														 IDinsert = idCusP;
														 insert_afterP = 0;
														 insert_afterD = curC;
													 }
												 }
											 }
										 }//else not ok capacity of vehicle
										 i ++; curC = nextArr[curC];
									 }
									 else break;
								 }
							 }
						  }
					 //2. Insert idCusP in the middle of the trip
					 preINS = firstC_C2C;
					 nextINS = nextArr[preINS];
                     for (j=1;j<seg[numVeh].Trip[0].numCus;j++) //insert idCusP between preINS and nextINS
					 {
						 FCAPT = FCAP[preINS] + problem->node[idCusP].capacity;
						 if (FCAPT <= problem->Q)
						 {
	 						costT = problem->c[preINS][idCusP] + problem->c[idCusP][nextINS] - problem->c[preINS][nextINS];
							cStartS = depart[preINS] + problem->c[preINS][idCusP];
							temp = problem->node[idCusP].eTW - cStartS;
							if (temp > eps)
							{
								 depart_idCusP = PDS_MAX(cStartS, problem->node[idCusP].sTW) + problem->node[idCusP].duration;
								 //2.1 Insert idCusD right after idCusP: don't need to check capacity of vehicle
 								 ArrTime = PDS_MAX(depart_idCusP + problem->c[idCusP][idCusD], problem->node[idCusD].sTW) + problem->node[idCusD].duration + problem->c[idCusD][nextINS];
								 temp = problem->node[nextINS].eTW - ArrTime;
								 if (temp > 0) 
								 {
									 ArrTime = PDS_MAX(ArrTime, problem->node[nextINS].sTW) + problem->node[nextINS].duration;
									 curC = nextINS; nextC = nextArr[nextINS];
									 ok = 1;
									 while (nextC > 0)
									 {
										 ArrTime += problem->c[curC][nextC];
										 temp = ArrTime - problem->node[nextC].eTW;
										 if (temp > eps) {ok = 0; break;} //vioTW at nextC
										 else
										 {
											 ArrTime = PDS_MAX(ArrTime, problem->node[nextC].sTW) + problem->node[nextC].duration;
											 curC = nextC; nextC = nextArr[curC];
										 }
									 }
									 if (ok) //curC is now pointed to lastC
									 {
										 costC2C = costT + problem->c[idCusP][idCusD] + problem->c[idCusD][nextINS] - problem->c[idCusP][nextINS];
										 if (costC2C < costMINI)
										 {
										     costMINI = costC2C;
											 IDinsert = idCusP;
											 insert_afterP = preINS;
											 insert_afterD = idCusP;
										 }
									 }//end if (ok)
								 }//else vioTW at cus nextINS
		 						 //2.2 Find place to insert idCusD from position after nextINS assuming that idCusP is inserted between preINS and nextINS:
          						 ok = checkC2CVehicleFeasible(idCusP,depart_idCusP,nextINS,j+1,departTemp);
								 if (ok) //TW is ok for all C2C customers after inserting idCusP between preINS and nextINS
								 {
									 i = j + 1; curC = nextINS;
									 while (i <= seg[numVeh].Trip[0].numCus) //insert idCusD after curC at position i of idTrip
									 {
										 //2.2 Insert idCusD right after place i:
										 if (curC < startidC2CD) //curC is a C2CP
										 {
											 curC = problem->node[curC].delID;
											 i = pos[curC];
										 }
										 else //curC is a C2CD
										 {
                                              idCus = problem->node[curC].pickID;
											  if (pos[idCus] > j)
											  {
												  //Insert idCusD after curC: check capacity of vehicle and vioTW
												  ok = checkCapacity_C2CTrip_InitSol(nextINS,curC, FCAPT);
												  if (ok)
												  {
													  ArrTime = departTemp[i] + problem->c[curC][idCusD];
													  temp = problem->node[idCusD].eTW - ArrTime;
													  if (temp > eps)
													  {
															 ArrTime = PDS_MAX(ArrTime, problem->node[idCusD].sTW) + problem->node[idCusD].duration;
															 nextC = nextArr[curC]; int curC1 = idCusD; int nextC1 = nextC;
															 while (nextC1 > 0)
															 {
																 ArrTime = PDS_MAX(ArrTime + problem->c[curC1][nextC1],problem->node[nextC1].sTW);
																 if (PDSDIF(ArrTime, startS[nextC1])==0) break;
																 temp = ArrTime - problem->node[nextC1].eTW;
																 if (temp > eps) {ok = 0; break;} //vioTW at nextC1
																 ArrTime += problem->node[nextC1].duration;
																 curC1 = nextC1; nextC1 = nextArr[curC1];
															 }
															 if (ok) //it's ok to insert idCusD after curC
															 {
																 costC2C = costT + (problem->c[curC][idCusD] + problem->c[idCusD][nextC] - problem->c[curC][nextC]);
																 if (costC2C < costMINI)
																 {	
																	 costMINI = costC2C;																	 
																	 IDinsert = idCusP;
																	 insert_afterP = preINS;
																	 insert_afterD = curC;
																 }
															 }
													  }//else vioTW at idCusD
												  }//else vio capacity of vehicle
												  i++; curC = nextArr[curC];
											  }
											  else break;
										 }//end curC is a C2CD
										 
									 }//end while
								 }//else TW is NOT ok for all customers in trip C2C and next PTrip(idVeh, nextT) after inserting idCusP to the trip C2C between preINS and nextINS
							}//else vioTW at idCusP
						 }//else can't insert between preINS and nextINS due to the capacity of the trip
						 preINS = nextINS; nextINS = nextArr[preINS];
					 }//end for j

					 //3. Insert idCusP at the end of the trip C2C: [after preINS] --> dont need to check CAPACITY of vehicle
					 //cout<<"Trying to insert ("<<idCusP<<", "<<idCusD<<") at the end of the trip (after "<<preINS<<"): ";
 					 cStartS = depart[preINS] + problem->c[preINS][idCusP];
					 temp = problem->node[idCusP].eTW - cStartS;
					 if (temp > eps)
					 {
						 depart_idCusP = PDS_MAX(cStartS, problem->node[idCusP].sTW) + problem->node[idCusP].duration;
						 //3.1 Insert idCusD right after idCusP:
						 ArrTime = PDS_MAX(depart_idCusP + problem->c[idCusP][idCusD], problem->node[idCusD].sTW) + problem->node[idCusD].duration;
						 costC2C = problem->c[preINS][idCusP] + problem->c[idCusP][idCusD] + problem->c[idCusD][0] - problem->c[preINS][0];
						 if (costC2C < costMINI)
						 {
							 costMINI = costC2C;
							 IDinsert = idCusP;
							 insert_afterP = preINS;
							 insert_afterD = idCusP;
						 }
						// else cout<<"OK but costC2C = "<<costC2C<<" > costMIN(="<<costMINI<<")"<<endl;
					 }//else vioTW at idCusP
					 //else cout<<" vioTW @ idCusP("<<idCusP<<") = "<<temp<<": cStartS = "<<cStartS<<"; dis = "<<problem->c[preINS][idCusP]<<endl;
				 } //else idCusP already routed 
			 }//end for idCusP: try all unrouted C2C
			 if (IDinsert != -1)
			 {
				 idCusD = problem->node[IDinsert].delID;
				// cout<<"Insert C2CP customer "<<IDinsert<<" after "<<insert_afterP<<" and insert C2CD "<<idCusD<<" after "<<insert_afterD<<": "<<endl;
				 if (insert_afterP == seg[numVeh].Trip[0].lastCus) //insert at the end of the trip:
				 {
 					  nextArr[insert_afterP] = IDinsert; 
					  nextArr[IDinsert] = idCusD; 
					  seg[numVeh].Trip[0].lastCus = idCusD;nextArr[idCusD] = 0;
  					  startS[IDinsert] = PDS_MAX(depart[insert_afterP] + problem->c[insert_afterP][IDinsert], problem->node[IDinsert].sTW);
					  depart[IDinsert] = startS[IDinsert] + problem->node[IDinsert].duration;
					  FCAP[IDinsert] = problem->node[IDinsert].capacity;
					  FCAP[idCusD] = 0;
					  pos[IDinsert] = pos[insert_afterP] + 1; pos[idCusD] = pos[IDinsert] + 1;
					  startS[idCusD] = PDS_MAX(depart[IDinsert] + problem->c[IDinsert][idCusD], problem->node[idCusD].sTW);
					  depart[idCusD] = startS[idCusD] + problem->node[idCusD].duration;
				 }
				 else //not insert at the end of the trip C2C
				 {
					 if (insert_afterP == 0)
					 {
						 seg[numVeh].Trip[0].firstCus = IDinsert;
						 nextArr[IDinsert] = firstC_C2C;
						 startS[IDinsert] = problem->node[IDinsert].startS_depot;
						 depart[IDinsert] = problem->node[IDinsert].depart_depot;
						 pos[IDinsert] = 1; FCAP[IDinsert] = problem->node[IDinsert].capacity;
					 }
					 else //insert in the middle
					 {
 						  int tt=nextArr[insert_afterP];
						  nextArr[insert_afterP]=IDinsert;
						  nextArr[IDinsert]=tt;
  						  startS[IDinsert] = PDS_MAX(depart[insert_afterP] + problem->c[insert_afterP][IDinsert], problem->node[IDinsert].sTW);
						  depart[IDinsert] = startS[IDinsert] + problem->node[IDinsert].duration;
						  pos[IDinsert] = pos[insert_afterP] + 1; 
						  FCAP[IDinsert] = FCAP[insert_afterP] + problem->node[IDinsert].capacity;
						  //cout<<"FCAP["<<IDinsert<<"] = FCAP["<<insert_afterP<<"]("<<FCAP[insert_afterP]<<" + cap["<<IDinsert<<"]("<<problem->node[IDinsert].capacity<<" = "<<FCAP[IDinsert];
						  //cout<<"; FCAP[firstC = "<<firstC_C2C<<"] = "<<FCAP[firstC_C2C]<<endl;
					 }//end insert in the middle

					 if (insert_afterD == IDinsert) //insert idCusD right after idCusP
					 {
						 startS[idCusD] = PDS_MAX(depart[IDinsert] + problem->c[IDinsert][idCusD], problem->node[idCusD].sTW);
						 depart[idCusD] = startS[idCusD] + problem->node[idCusD].duration;
						 int tt = nextArr[IDinsert];
						 nextArr[IDinsert] = idCusD; nextArr[idCusD] = tt; 
						 pos[idCusD] = pos[IDinsert] + 1; 
						 FCAP[idCusD] = FCAP[IDinsert] + problem->node[idCusD].capacity;
					 }
					 else //insert idCusD after insert_afterD:
					 {
						 curC = IDinsert; nextC = nextArr[IDinsert];
						 do
						 {
							 startS[nextC] = PDS_MAX(depart[curC] + problem->c[curC][nextC], problem->node[nextC].sTW);
							 depart[nextC] = startS[nextC] + problem->node[nextC].duration;
							 pos[nextC] ++; FCAP[nextC] = FCAP[curC] + problem->node[nextC].capacity;
							 curC = nextC; nextC = nextArr[curC];
						 }while (curC != insert_afterD);
						 //Insert idCusD after insert_afterD:
						 startS[idCusD] = PDS_MAX(depart[insert_afterD] + problem->c[insert_afterD][idCusD], problem->node[idCusD].sTW);
						 depart[idCusD] = startS[idCusD] + problem->node[idCusD].duration;
						 nextArr[idCusD] = nextArr[insert_afterD]; nextArr[insert_afterD] = idCusD; 
						 pos[idCusD] = pos[insert_afterD] + 1; FCAP[idCusD] = FCAP[insert_afterD] + problem->node[idCusD].capacity;
					 }//end insert idCusD after insert_afterD:
					 nextC = nextArr[idCusD];
					 if (nextC > 0)	 updateStartS_pos_FCAP_FEASIBLETRIP(numVeh,0,idCusD,nextC,pos[idCusD]);
					 else seg[numVeh].Trip[0].lastCus = idCusD;
				 }//end not insert at the end of the trip C2C

				  seg[numVeh].Trip[0].numCus +=2; 
				  //cout<<"Vehicle with only C2C: numCus = "<<seg[numVeh].Trip[0].numCus<<endl;
				  routed[IDinsert] = 1; routed[idCusD] = 1;
				  numCusC2CRouted += 2;
				  if (numCusC2CRouted == nC2C) cont = 0;
				  seg[numVeh].Trip[0].cost += costMINI;
				  seg[numVeh].Trip[0].endS = depart[seg[numVeh].Trip[0].lastCus];
				  seg[numVeh].Trip[0].connectCost = problem->c[seg[numVeh].Trip[0].lastCus][0];
				  ok = checkC2C_P_FeasibleTrip_InitSol(numVeh,0, 0, 0,-1);
				  if (ok == 0) exit(-1);
				  //cout<<"FCAP[firstC="<<seg[numVeh].Trip[0].firstCus<<"] = "<<FCAP[seg[numVeh].Trip[0].firstCus]<<endl;
			 } else cont = 0; //can't route any C2C anymore
		 }while (cont);
		 delete [] departTemp;
	 }
	 //showTripCus(numVeh,0);
}
bool Solution::checkC2C_P_FeasibleTrip_InitSol(int idVeh, int idTrip, int preC, double depart_preC, int nextT) //just checking feasible trip
{
	//Check startS, depart, feasibility of capacity, cost, pos
	int curC = seg[idVeh].Trip[idTrip].firstCus;
	double costT = 0;
	if (preC == 0) costT = problem->c[0][curC];
	int FCAPT = 0;

	double ArrTime = depart_preC + problem->c[preC][curC];
	double temp = ArrTime - problem->node[curC].eTW;
	if (temp > eps) {cout<<"ERROR checkC2C_P_FeasibleTrip_InitSol: vioTW at first cus "<<curC<<endl; return 0;}
	ArrTime = PDS_MAX(ArrTime, problem->node[curC].sTW);
	if (PDSDIF(ArrTime, startS[curC])) {cout<<"ERROR checkC2C_P_FeasibleTrip_InitSol: tinh sai startS of cus "<<curC<<": correct = "<<ArrTime<<"; wrong = "<<startS[curC]<<endl; return 0;}
	ArrTime += problem->node[curC].duration;
	if (PDSDIF(ArrTime, depart[curC])) {cout<<"ERROR checkC2C_P_FeasibleTrip_InitSol: tinh sai depart of cus "<<curC<<": correct = "<<ArrTime<<"; wrong = "<<depart[curC]<<endl; return 0;}
	FCAPT += problem->node[curC].capacity;
	if (FCAPT != FCAP[curC]) {cout<<"ERROR checkC2C_P_FeasibleTrip_InitSol: tinh sai FCAP at cus "<<curC<<": correct = "<<FCAPT<<"; field FCAP = "<<FCAP[curC]<<endl; return 0;}
    if (pos[curC] != 1) {cout<<"ERROR checkC2C_P_FeasibleTrip_InitSol: tinh sai pos at cus "<<curC<<"wrong = "<<pos[curC]<<"; correct = 1"<<endl; return 0;}    
	//double cStartS = ArrTime;
	preC = curC; curC = nextArr[curC];
	int curPos = 1;
	while (curC > 0)
	{
		ArrTime += problem->c[preC][curC];
		temp = ArrTime - problem->node[curC].eTW;
		if (temp > eps) {cout<<"ERROR checkC2C_P_FeasibleTrip_InitSol: vioTW at cus "<<curC<<endl; return 0;}
		ArrTime = PDS_MAX(ArrTime, problem->node[curC].sTW);
		if (PDSDIF(ArrTime, startS[curC])) {cout<<"ERROR checkC2C_P_FeasibleTrip_InitSol: tinh sai startS of cus "<<curC<<": correct = "<<ArrTime<<"; wrong = "<<startS[curC]<<endl; return 0;}
		ArrTime += problem->node[curC].duration;
		if (PDSDIF(ArrTime, depart[curC])) {cout<<"ERROR checkC2C_P_FeasibleTrip_InitSol: tinh sai depart of cus "<<curC<<": correct = "<<ArrTime<<"; wrong = "<<depart[curC]<<endl; return 0;}
        costT += problem->c[preC][curC];
		FCAPT += problem->node[curC].capacity;
		if (FCAPT > problem->Q) {cout<<"ERROR checkC2C_P_FeasibleTrip_InitSol: Exceed capacity at cus "<<curC<<endl; return 0;}
		if (FCAPT != FCAP[curC]) {cout<<"ERROR checkC2C_P_FeasibleTrip_InitSol: tinh sai FCAP at cus "<<curC<<endl; return 0;}
		curPos ++;
		if (pos[curC] != curPos)
		{  cout<<"ERROR checkC2C_P_FeasibleTrip_InitSol: tinh sai pos at cus "<<curC<<": correct = "<<pos[curC]<<"; wrong = "<<curPos<<endl; return 0;}
		preC = curC; curC = nextArr[curC];
	}
	//preC now points to the last cus:
	if (nextT > -1) //not the last trip yet
	{
		if (seg[idVeh].Trip[nextT].Type == 1)
		{
			int assSP = seg[idVeh].Trip[nextT].assSP;
			ArrTime = depart[preC] + problem->c[preC][assSP];
			if (PDSINRANGE(ArrTime, problem->nodeSP[assSP].sTW2, problem->nodeSP[assSP].eTW2))
				costT += problem->c[preC][assSP];
			else
			{
				temp = depart[preC] - problem->nodeSP[assSP].eTW2;
				if (temp > eps) return 0; //vioTW at SP of DTrip(idVeh, nextT)
				ArrTime = depart[preC] + problem->disCWSSP[preC][assSP];
				temp =  ArrTime -  problem->nodeSP[assSP].eTW2;
				if (temp > eps) return 0;
				costT += problem->disCWSSP[preC][assSP];
			}
		}
		else if (seg[idVeh].Trip[nextT].Type == 0)
		{
			costT += problem->c[preC][seg[idVeh].Trip[nextT].firstCus];
		}
	}
	return 1;
}


bool Solution::checkC2C_P_FeasibleTrip_InitSol_Temp(int idVeh, int idTrip, int preC, double depart_preC, int nextT) //just checking feasible trip
{
	//Check startS, depart, feasibility of capacity, cost, pos
	int curC = seg[idVeh].Trip[idTrip].firstCus;
	double costT = 0;
	if (preC == 0) costT = problem->c[0][curC]; 
	int FCAPT = 0;

	double ArrTime = depart_preC + problem->c[preC][curC];
	double temp = ArrTime - problem->node[curC].eTW;
	if (temp > eps) {cout<<"ERROR checkC2C_P_FeasibleTrip_InitSol_Temp: vioTW at first cus "<<curC<<endl; return 0;}
	ArrTime = PDS_MAX(ArrTime, problem->node[curC].sTW);
	if (PDSDIF(ArrTime, startS[curC])) {cout<<"ERROR checkC2C_P_FeasibleTrip_InitSol_Temp: tinh sai startS of firstcusP "<<curC<<": correct = "<<ArrTime<<"; wrong = "<<startS[curC]<<endl; return 0;}
	ArrTime += problem->node[curC].duration;
	if (PDSDIF(ArrTime, depart[curC])) {cout<<"ERROR checkC2C_P_FeasibleTrip_InitSol_Temp: tinh sai depart of firstcusP "<<curC<<": correct = "<<ArrTime<<"; wrong = "<<depart[curC]<<endl; return 0;}
	FCAPT += problem->node[curC].capacity;
	if (FCAPT != FCAP[curC]) {cout<<"ERROR checkC2C_P_FeasibleTrip_InitSol_Temp: tinh sai FCAP at cus "<<curC<<endl; return 0;}
    if (pos[curC] != 1) {cout<<"ERROR checkC2C_P_FeasibleTrip_InitSol_Temp: tinh sai pos at cus "<<curC<<"wrong = "<<pos[curC]<<"; correct = 1"<<endl; return 0;}    
	//double cStartS = ArrTime;
	preC = curC; curC = nextArrTemp[curC];
	int curPos = 1;
	while (curC > 0)
	{
		ArrTime += problem->c[preC][curC];
		temp = ArrTime - problem->node[curC].eTW;
		if (temp > eps) {cout<<"ERROR checkC2C_P_FeasibleTrip_InitSol_Temp: vioTW at cus "<<curC<<endl; return 0;}
		ArrTime = PDS_MAX(ArrTime, problem->node[curC].sTW);
		if (PDSDIF(ArrTime, startS[curC])) 
		{
			cout<<"ERROR checkC2C_P_FeasibleTrip_InitSol_Temp: tinh sai startS of cus "<<curC<<": correct = "<<ArrTime<<"; wrong = "<<startS[curC]<<endl; 
			cout<<"depart[preC="<<preC<<"]= "<<depart[preC]<<endl;
			return 0;
		}
		ArrTime += problem->node[curC].duration;
		if (PDSDIF(ArrTime, depart[curC])) {cout<<"ERROR checkC2C_P_FeasibleTrip_InitSol_Temp: tinh sai depart of cus "<<curC<<": correct = "<<ArrTime<<"; wrong = "<<depart[curC]<<endl; return 0;}
        costT += problem->c[preC][curC];
		FCAPT += problem->node[curC].capacity;
		if (FCAPT > problem->Q) {cout<<"ERROR checkC2C_P_FeasibleTrip_InitSol_Temp: Exceed capacity at cus "<<curC<<endl; return 0;}
		if (FCAPT != FCAP[curC]) {cout<<"ERROR checkC2C_P_FeasibleTrip_InitSol_Temp: tinh sai FCAP at cus "<<curC<<endl; return 0;}
		curPos ++;
		if (pos[curC] != curPos)
		{  cout<<"ERROR checkC2C_P_FeasibleTrip_InitSol: tinh sai pos at cus "<<curC<<": correct = "<<pos[curC]<<"; wrong = "<<curPos<<endl; return 0;}
		preC = curC; curC = nextArrTemp[curC];
	}
	//preC now points to the last cus:
	if (nextT > -1) //not the last trip yet
	{
		if (seg[idVeh].Trip[nextT].Type == 1)
		{
			int assSP = seg[idVeh].Trip[nextT].assSP;
			ArrTime = depart[preC] + problem->c[preC][assSP];
			if (PDSINRANGE(ArrTime, problem->nodeSP[assSP].sTW2, problem->nodeSP[assSP].eTW2))
				costT += problem->c[preC][assSP];
			else
			{
				temp = depart[preC] - problem->nodeSP[assSP].eTW2;
				if (temp > eps) return 0; //vioTW at SP of DTrip(idVeh, nextT)
				ArrTime = depart[preC] + problem->disCWSSP[preC][assSP];
				temp =  ArrTime -  problem->nodeSP[assSP].eTW2;
				if (temp > eps) return 0;
				costT += problem->disCWSSP[preC][assSP];
			}
		}
		else if (seg[idVeh].Trip[nextT].Type == 0)
		{
			costT += problem->c[preC][seg[idVeh].Trip[nextT].firstCus];
		}
	}
	return 1;
}
bool Solution::checkC2C_FeasibleTrip_InitSol_Temp(int idVeh, int idTrip, int preC, double depart_preC, bool Add, int endSP) //just checking feasible trip
{
	//Check startS, depart, feasibility of capacity, cost, pos
	int curC = seg[idVeh].Trip[idTrip].firstCus;
	double costT = 0;
	if (Add || preC == 0) costT += problem->c[preC][curC];
	int FCAPT = 0;
	//cout<<costT<<"("<<curC<<"); ";

	double ArrTime = depart_preC + problem->c[preC][curC];
	double temp = ArrTime - problem->node[curC].eTW;
	if (temp > eps) {cout<<"ERROR checkC2CFeasibleTrip_InitSol_Temp: vioTW at first cus "<<curC<<endl; return 0;}
	ArrTime = PDS_MAX(ArrTime, problem->node[curC].sTW);
	if (PDSDIF(ArrTime, startS[curC])) {cout<<"ERROR checkC2CFeasibleTrip_InitSol_Temp: tinh sai startS of cus "<<curC<<": correct = "<<ArrTime<<"; wrong = "<<startS[curC]<<endl; return 0;}
	ArrTime += problem->node[curC].duration;
	if (PDSDIF(ArrTime, depart[curC])) {cout<<"ERROR checkC2CFeasibleTrip_InitSol_Temp: tinh sai depart of cus "<<curC<<": correct = "<<ArrTime<<"; wrong = "<<depart[curC]<<endl; return 0;}
	FCAPT += problem->node[curC].capacity;
	if (FCAPT != FCAP[curC]) {cout<<"ERROR checkC2CFeasibleTrip_InitSol_Temp: tinh sai FCAP at cus "<<curC<<endl; return 0;}
    if (pos[curC] != 1) {cout<<"ERROR checkC2CFeasibleTrip_InitSol_Temp: tinh sai pos at cus "<<curC<<"wrong = "<<pos[curC]<<"; correct = 1"<<endl; return 0;}    
	//double cStartS = ArrTime;

	int nextC = nextArrTemp[curC];
	int curPos = 1;
	while (nextC > 0)
	{
		ArrTime += problem->c[curC][nextC];
		temp = ArrTime - problem->node[nextC].eTW;
		if (temp > eps) {cout<<"ERROR checkC2CFeasibleTrip_InitSol_Temp: vioTW at cus "<<nextC<<endl; return 0;}
		ArrTime = PDS_MAX(ArrTime, problem->node[nextC].sTW);
		if (PDSDIF(ArrTime, startS[nextC])) {cout<<"ERROR checkC2CFeasibleTrip_InitSol_Temp: tinh sai startS of cus "<<nextC<<": correct = "<<ArrTime<<"; wrong = "<<startS[nextC]<<endl; return 0;}
		ArrTime += problem->node[nextC].duration;
		if (PDSDIF(ArrTime, depart[nextC])) {cout<<"ERROR checkC2CFeasibleTrip_InitSol_Temp: tinh sai depart of cus "<<nextC<<": correct = "<<ArrTime<<"; wrong = "<<depart[nextC]<<endl; return 0;}
        costT += problem->c[curC][nextC];
		//cout<<costT<<"("<<nextC<<"); ";
		FCAPT += problem->node[nextC].capacity;
		if (FCAPT > problem->Q) {cout<<"ERROR checkC2CFeasibleTrip_InitSol_Temp: Exceed capacity at cus "<<nextC<<endl; return 0;}
		if (FCAPT != FCAP[nextC]) {cout<<"ERROR checkC2CFeasibleTrip_InitSol_Temp: tinh sai FCAP at cus "<<nextC<<endl; return 0;}
		curPos ++;
		if (pos[nextC] != curPos)
		{  cout<<"ERROR checkC2CFeasibleTrip_InitSol_Temp: tinh sai pos at cus "<<nextC<<": correct = "<<pos[nextC]<<"; wrong = "<<curPos<<endl; return 0;}
		curC = nextC; nextC = nextArrTemp[curC];
	}

	//curC now points to the last cus of C2C:
	if (endSP == 0)
	{
		costT += problem->c[curC][0];
		//cout<<costT<<endl;
		if (PDSDIF(costT, seg[idVeh].Trip[idTrip].cost)) 
		{
			cout<<"ERROR checkC2CFeasibleTrip_InitSol_Temp: tinh sai cost of last C2Ctrip: correct = "<<costT<<"; wrong = "<<seg[idVeh].Trip[idTrip].cost<<endl; 
			return 0;
		}
	}
	else
	{
		double cStartS;
		cStartS = ArrTime + problem->c[curC][endSP];
		if (PDSINRANGE(cStartS,problem->nodeSP[endSP].sTW2, problem->nodeSP[endSP].eTW2)) 
		{
			costT += problem->c[curC][endSP];
			//cout<<costT<<endl;
			if (PDSDIF(costT, seg[idVeh].Trip[idTrip].cost)) 
			{
				cout<<"ERROR checkC2CFeasibleTrip_InitSol_Temp: tinh sai cost of notlast C2Ctrip(case directly to SP): correct = "<<costT<<"; wrong = "<<seg[idVeh].Trip[idTrip].cost<<"; field WS = "<<seg[idVeh].Trip[idTrip].waitingS<<"; lastCNEW = "<<curC<<"; endSP = "<<endSP<<endl; 
				return 0;
			}
		}
		else
		{
			double temp = cStartS - problem->nodeSP[endSP].eTW2;
			if (temp > eps)
			{
				cout<<"ERROR checkC2CFeasibleTrip_InitSol_Temp: vioTWSP(case directly to SP): arr = "<<temp<<"; eTW2 of SP = "<<problem->nodeSP[endSP].eTW2<<endl; 
				return 0;
			}
			cStartS = ArrTime + problem->disCWSSP[curC][endSP];
			temp = cStartS - problem->nodeSP[endSP].eTW2;
			if (temp > eps)
			{
				cout<<"ERROR checkC2CFeasibleTrip_InitSol_Temp: vioTWSP(case through WS): arr = "<<temp<<"; eTW2 of SP = "<<problem->nodeSP[endSP].eTW2<<endl; 
				return 0;
			}
			costT += problem->disCWSSP[curC][endSP];
			//cout<<costT<<endl;
			if (PDSDIF(costT, seg[idVeh].Trip[idTrip].cost)) 
			{
				cout<<"ERROR checkC2CFeasibleTrip_InitSol_Temp: tinh sai cost of NOTlast C2Ctrip(case through WS): correct = "<<costT<<"; wrong = "<<seg[idVeh].Trip[idTrip].cost<<"; field WS = "<<seg[idVeh].Trip[idTrip].waitingS<<endl; 
				return 0;
			}
		}
	}

	return 1;
}



bool Solution::checkFeasible_ConnectC2CDToSP(int curC, double depart_curC, double &costT, int endSP, bool &goWS)
{
	//Check if feasible TW at endSP
	double ArrTime, temp;
	ArrTime = depart_curC + problem->c[curC][endSP];
	temp = ArrTime - problem->nodeSP[endSP].eTW2;
	if (temp > eps) return 0;
	if (PDSINRANGE(ArrTime, problem->nodeSP[endSP].sTW2, problem->nodeSP[endSP].eTW2)) 
	{
		costT += problem->c[curC][endSP];
		goWS = 0;
		return 1;
	}
	ArrTime = depart_curC + problem->disCWSSP[curC][endSP];
	temp = ArrTime - problem->nodeSP[endSP].eTW2;
	if (temp > eps) return 0;
	costT += problem->disCWSSP[curC][endSP]; goWS = 1;
	return 1;
}
//create first pickup trip leaving depot to go to assignSP:
void Solution::Create_FirstPickupTripLeavingDepot(int assignSP, int &numTrip)
{
	//Update 7/11/2013

	int i,j, idCus;
	double ArrTime, ArrTime1;
	int goWS, WSIDtemp, WSID;

    //cout<<"Tao vehicle thu "<<idVeh<<endl;
	seg[numVeh].Trip[0].assSP = assignSP;
   
    //1.Insert a pickup customer as the first customer of current trip:
  
	 double costMINI = PDS_INFINITY; double temp; int seed=-1;
	 for (i=1;i<=numCusPSP[assignSP];i++)
	 {
		 idCus = CusPSP[assignSP][i];
		 if (routed[idCus] == 0)
		 { 
			 //cout<<"i = "<<i<<"; idCusP = "<<idCus<<"; assSP = "<<assignSP<<endl;
			 if (problem->waitingSOneP[idCus][assignSP])
			 {
				 //cout<<"Co van de ???"<<endl;
				 temp = problem->c[0][idCus] + problem->disCWSSP[idCus][assignSP];
				 if (temp < costMINI)
				 {
					 seed = idCus;
					 costMINI = temp;
					 goWS = problem->CWSSP[idCus][assignSP];
					 //startSMINI = problem->startSOneP[idCus][assignSP];
				 }
			 }
			 else
			 {
				 temp = problem->c[0][idCus] + problem->c[idCus][assignSP];
				 if (temp < costMINI)
				 {
					 seed = idCus;
					 costMINI = temp;
					 goWS = NO_WS;
					 //startSMINI = problem->startSOneP[idCus][assignSP];
				 }
			 }
		 }
	 }

	 if (seed == -1)
	 {
		 cout<<"THERE IS THE CASE CANNOT ROUTE PICKUP CUSTOMERS: "<<endl;
		 for (i=1;i<=numCusPSP[assignSP];i++)
		 {
			 idCus = CusPSP[assignSP][i];
			 if (routed[idCus]==0)
				 cout<<"Cus "<<idCus<<" assigned to sp "<<assignSP<<endl;
		 }
		 exit(-1);
	 }

	 routed[seed]=1;  
	 seg[numVeh].Trip[0].Type = 0;
     seg[numVeh].Trip[0].firstCus = seed; //id of the first Customer of Leg
	 seg[numVeh].Trip[0].lastCus = seed; //id of the first Customer of Leg
	 seg[numVeh].Trip[0].numCus = 1; //#Customers in the leg
	 seg[numVeh].Trip[0].capacity = problem->node[seed].capacity;
	 nextArr[seed] = 0; //just correct for initial solution
	 seg[numVeh].Trip[0].cost = costMINI;
     seg[numVeh].Trip[0].waitingS = goWS;
	 //cout<<"CREATE FIRST PICKUP TRIP of veh "<<numVeh<<": "<<seed<<",   WS = "<<goWS<<"; sp = "<<assignSP<<"; cost = "<<costMINI<<endl;
	 seg[numVeh].Trip[0].feasible = 1;
	 startS[seed] = problem->startSOneP[seed][assignSP];
	 depart[seed] = startS[seed] + problem->node[seed].duration;
	 seg[numVeh].Trip[0].endS = depart[seed];
	 //cout<<"startS["<<seed<<"] = "<<startS[seed]<<"; depart["<<seed<<"] = "<<depart[seed]<<"; endS = "<<seg[numVeh].Trip[0].endS<<endl;
	 numCusPRouted[assignSP]++;


     // 2. Continue to insert pickup customers:
     //starting to find pickup customer to insert into the current trip (depot, assignSP):
     bool cont=true;  
	 int curC, nextC, preINS, nextINS, insert_after, IDinsert;
	 double varcost,TOTALTIME,c1, c2, c2OPT;

	 if (numCusPRouted[assignSP] < numCusPSP[assignSP])
	 {
		 do
		 {
			 insert_after = -1; c2OPT = -PDS_INFINITY;
			  /*cout<<"numCusP assign to sp"<<assignSP<<" = "<<numCusPSP[assignSP]<<endl;
			  cout<<"List cusP of sp "<<assignSP<<": ";
			  for (i=1;i<=numCusPSP[assignSP];i++)
				  cout<<CusPSP[assignSP][i]<<", ";
			  cout<<endl;
			  */

		 	 for (i=1;i<=numCusPSP[assignSP];i++)
			 {
					 idCus = CusPSP[assignSP][i];
					 //cout<<"Checking cusP "<<idCus<<endl;
					 if (routed[idCus]==0 && seg[numVeh].Trip[0].capacity + problem->node[idCus].capacity < problem->Q)
					 {
						 bool ok = 1;
						 //cout<<"Try with PCus "<<idCus<<endl;
						 //cout<<"First try to insert at the beginning of the trip:"<<endl;
						 //1. First try to insert at the beginning of the trip:
						 nextINS = seg[numVeh].Trip[0].firstCus;
						 ArrTime = PDS_MAX(problem->c[0][idCus], problem->node[idCus].sTW) + problem->node[idCus].duration + problem->c[idCus][nextINS];
						 temp = problem->node[nextINS].eTW - ArrTime;
						 if (temp > 0) 
						 {
							 ArrTime = PDS_MAX(ArrTime, problem->node[nextINS].sTW) + problem->node[nextINS].duration;
							 curC = nextINS; nextC = nextArr[nextINS];
							 while (nextC > 0)
							 {
								 ArrTime += problem->c[curC][nextC];
								 temp = ArrTime - problem->node[nextC].eTW;
								 if (temp > eps) {ok = 0; break;} //vioTW at nextC
								 else
								 {
									 ArrTime = PDS_MAX(ArrTime, problem->node[nextC].sTW) + problem->node[nextC].duration;
									 curC = nextC; nextC = nextArr[curC];
								 }
							 }
							 if (ok) //curC is now pointed to lastC
							 {
	                             ArrTime1 = ArrTime + problem->c[curC][assignSP];
								 temp =  problem->nodeSP[assignSP].eTW1 - ArrTime1;
								 if (temp > eps) 
								 {
									 if (PDSINRANGE(ArrTime1, problem->nodeSP[assignSP].sTW1, problem->nodeSP[assignSP].eTW1))
										 WSIDtemp = NO_WS;
									 else
									 {
										 ArrTime1 = ArrTime + problem->disCWSSP[curC][assignSP];
										 temp = ArrTime1 - problem->nodeSP[assignSP].eTW1;
										 if (temp > eps) ok = 0; //too late to go to sp through WS
										 else WSIDtemp = problem->CWSSP[curC][assignSP];
									 }
									 if (ok)
									 {
										 c1 = problem->c[0][idCus] + problem->c[idCus][nextINS] - problem->c[0][nextINS];
										 if (goWS != WSIDtemp)
										 {
											 if (goWS != NO_WS) //before go to WS, after insert don't need to go to WS:
												 c1 += (problem->c[curC][assignSP] - problem->disCWSSP[curC][assignSP]);
											 else 
											 {
												 c1 += (problem->disCWSSP[curC][assignSP] - problem->c[curC][assignSP]);
												 /*cout<<"ERROR Create_FirstPickupTripLeavingDepot before insert go to sp, after insert go to WS"<<endl;
												 cout<<"Trying to insert pickup cus "<<idCus<<" at the beginning of: ";
												 showTripCost(numVeh,0);
												 exit(-1);*/
											 }
										 }
										 c2 = problem->c[idCus][assignSP]-c1;
										 if (c2 > c2OPT) {c2OPT=c2; varcost=c1; IDinsert=idCus; 
														  insert_after = 0;WSID=WSIDtemp;
														  TOTALTIME = ArrTime;
														 } 
									 }
								 }							 
							 }//end if (ok)
						 }
						 //else vioTW at first customer of trip
						

						 //cout<<"Try to insert "<<idCus<<" after each pickup customer j of the trip"<<endl;
                         //2. try to insert customer idCus after each pickup customer j of the trip:
						 preINS = seg[numVeh].Trip[0].firstCus;
						 if (seg[numVeh].Trip[0].numCus == 1)
						 {
							  //cout<<"CASE trip has only 1 customer"<<endl;
							  ArrTime = PDS_MAX(problem->c[0][preINS], problem->node[preINS].sTW) + problem->node[preINS].duration;
							  ArrTime += problem->c[preINS][idCus];
							  temp =problem->node[idCus].eTW -  ArrTime;
							  if (temp > eps)
							  {
								  ArrTime = PDS_MAX(ArrTime, problem->node[idCus].sTW) + problem->node[idCus].duration;
								  ArrTime1 = ArrTime + problem->c[idCus][assignSP];
								  temp = problem->nodeSP[assignSP].eTW1 - ArrTime1;
								  if (temp > eps)
								  {
									  if (PDSINRANGE(ArrTime1,problem->nodeSP[assignSP].sTW1, problem->nodeSP[assignSP].eTW1))
									  {
										  c1 = problem->c[idCus][assignSP];
										  c1 += problem->c[preINS][idCus];
										  if (seg[numVeh].Trip[0].waitingS == NO_WS)
											  c1 -= problem->c[preINS][assignSP];
										  else c1 -= problem->disCWSSP[preINS][assignSP];
										  c2 = problem->c[idCus][assignSP]-c1;
										  if (c2 > c2OPT) {c2OPT=c2; varcost=c1; IDinsert=idCus; 
														  insert_after = preINS;WSID=NO_WS;
														  TOTALTIME = ArrTime;} 
									  }
									  else
									  {
										  ArrTime1 = ArrTime + problem->disCWSSP[idCus][assignSP];
										  temp = problem->nodeSP[assignSP].eTW1 -  ArrTime1;
										  if (temp > eps) 
										  {
											  c1 = problem->disCWSSP[idCus][assignSP];
											  c1 += problem->c[preINS][idCus];
											  if (seg[numVeh].Trip[0].waitingS == NO_WS)
												  c1 -= problem->c[preINS][assignSP];
											  else c1 -= problem->disCWSSP[preINS][assignSP];
											  c2 = problem->c[idCus][assignSP]-c1;
											  if (c2 > c2OPT) {c2OPT=c2; varcost=c1; IDinsert=idCus; 
															  insert_after = preINS;WSID=problem->CWSSP[idCus][assignSP];
															  TOTALTIME = ArrTime;} 
										  }
									  }
								  }
							  }
  						 }
						 else
						 {
							 for (j=1;j<=seg[numVeh].Trip[0].numCus;j++)
							 {
								ok = 1;
								ArrTime = depart[preINS] + problem->c[preINS][idCus];
								temp = problem->node[idCus].eTW -  ArrTime;
								if (temp > eps)
								{
									ArrTime = PDS_MAX(ArrTime, problem->node[idCus].sTW) + problem->node[idCus].duration;
									//start checking TW from idCus to the end of the trip:
									curC = idCus; nextC = nextArr[preINS];
									while (nextC > 0)
									{
										ArrTime += problem->c[curC][nextC];
										temp = ArrTime - problem->node[nextC].eTW;
										if (temp > eps) {ok = 0;break;} //vioTW at nextC
										ArrTime = PDS_MAX(ArrTime, problem->node[nextC].sTW) + problem->node[nextC].duration;
										curC = nextC; nextC = nextArr[nextC];
									}
									//now curC point to the last
									if (ok)
									{
										 ArrTime1 = ArrTime + problem->c[curC][assignSP];
										 temp = problem->nodeSP[assignSP].eTW1 - ArrTime1;
										 if (temp > eps)
										 {
											 if (PDSINRANGE(ArrTime1,problem->nodeSP[assignSP].sTW1, problem->nodeSP[assignSP].eTW1))
												 WSIDtemp=NO_WS;
											 else
											 {
												  ArrTime1 = ArrTime + problem->disCWSSP[curC][assignSP];
												  temp = ArrTime1 - problem->nodeSP[assignSP].eTW1;
												  if (temp > eps) ok=0; //too late to go to sp through WS
												  else WSIDtemp = problem->CWSSP[curC][assignSP];
											 }
											 if (ok)
											 {
													 if (j != seg[numVeh].Trip[0].numCus) //nextINS != assignSP								        
													 {
														 nextINS = nextArr[preINS];
														 c1 = problem->c[preINS][idCus] + problem->c[idCus][nextINS] - problem->c[preINS][nextINS];
														 if (goWS != WSIDtemp)
														 {
															 if (goWS != NO_WS) //before go to WS, after insert don't need to go to WS:
																 c1 += (problem->c[curC][assignSP] - problem->disCWSSP[curC][assignSP]);
															 else 
															 {
																 c1 += (problem->disCWSSP[curC][assignSP] - problem->c[curC][assignSP]);
																 /*cout<<"ERROR Create_FirstPickupTripLeavingDepot before insert go to sp directly, after insert go to WS"<<endl;
																 cout<<"Trying to insert pickup "<<idCus<<" after "<<preINS<<": ";
																 showTripCost(numVeh,0);
																 exit(-1);*/
															 }
														 }
													 }
													 else //insert to the end of the leg:
													 {
														 c1 = problem->c[preINS][idCus];
														 if (goWS==NO_WS) //before insert customer idCus, go to sp directly
														 {
															 if (WSIDtemp ==NO_WS) c1 += (problem->c[idCus][assignSP] - problem->c[preINS][assignSP]);
															 else 
															 {
																 c1 += (problem->c[preINS][assignSP] - problem->c[idCus][assignSP]);
																 /*cout<<"Create_FirstPickupTripLeavingDepot  ERROR before insert go to sp directly, after insert need to go to WS"<<endl; 
																 cout<<"Trying to insert pickup "<<idCus<<" at the end of the trip: ";
																 showTripCost(numVeh,0);
																 exit(-1);*/
															 }
														 }
														 else //before insert customer idCus, go to WS:
														 {
															 if (WSIDtemp == NO_WS) c1 += (problem->c[idCus][assignSP] - problem->disCWSSP[preINS][assignSP]);
															 else c1+=(problem->disCWSSP[idCus][assignSP] - problem->disCWSSP[preINS][assignSP]);
														 }
													 }
													 c2 = problem->c[idCus][assignSP]-c1;
													 if (c2 > c2OPT) {c2OPT=c2; varcost=c1; IDinsert=idCus; 
																	  insert_after = preINS;WSID=WSIDtemp;
																	  TOTALTIME = ArrTime;} 
											 }//else too early to go to sp directly, but go through WS too late
										} //else vioTW at assignSP
									}//end if (ok): //everything is fine till last cus
								}//end else:not vioTW at idCus
								preINS = nextArr[preINS];
							 }//end for
						 }
					 }//end if routedP[idCus]==0...
			 }//end for: try all unrouted pickup customers assigned to assignSP

			 if (insert_after!=-1)
			 {
				  //cout<<"Insert customer "<<IDinsert<<" after "<<insert_after<<": "<<endl;
				  if (insert_after == 0)
				  {
					  int pre = seg[numVeh].Trip[0].firstCus;
					  seg[numVeh].Trip[0].firstCus = IDinsert;
					  nextArr[IDinsert] = pre;
					  startS[IDinsert] = problem->node[IDinsert].startS_depot; // PDS_MAX(problem->c[0][IDinsert], problem->node[IDinsert].sTW);
					  depart[IDinsert] = problem->node[IDinsert].depart_depot; //startS[IDinsert] + problem->node[IDinsert].duration;
					  updateStartSP_FEASIBLETRIP(numVeh,0,IDinsert,nextArr[IDinsert]);
				  }
				  else if (insert_after == seg[numVeh].Trip[0].lastCus) //insert at the end of the trip:
				  {
					  nextArr[insert_after] = IDinsert;
					  seg[numVeh].Trip[0].lastCus=IDinsert;
					  nextArr[IDinsert]=0;
					  if (insert_after == seg[numVeh].Trip[0].firstCus)
					  {
			              startS[insert_after] = problem->node[insert_after].startS_depot; //PDS_MAX(problem->c[0][insert_after], problem->node[insert_after].sTW);
			              depart[insert_after] = problem->node[insert_after].depart_depot; //startS[insert_after] + problem->node[insert_after].duration;
						  ArrTime = depart[insert_after] + problem->c[insert_after][IDinsert];
						  startS[IDinsert] = PDS_MAX(ArrTime, problem->node[IDinsert].sTW);
						  depart[IDinsert] = startS[IDinsert] + problem->node[IDinsert].duration;
					  }
					  else
					  {
						  ArrTime = depart[insert_after] + problem->c[insert_after][IDinsert];
						  startS[IDinsert] = PDS_MAX(ArrTime, problem->node[IDinsert].sTW);
						  depart[IDinsert] = startS[IDinsert] + problem->node[IDinsert].duration;
					  }
					  //cout<<"*************Insert customer "<<IDinsert<<" at the end of the leg: after "<<insert_after<<endl;
				  }
				  else //insert at the middile of the leg:
				  {
					  int tt=nextArr[insert_after];
					  nextArr[insert_after]=IDinsert;
					  nextArr[IDinsert]=tt;
					  updateStartSP_FEASIBLETRIP(numVeh,0,insert_after,IDinsert);
					  //cout<<"***********Insert customer "<<IDinsert<<" in the middle of the leg: after "<<insert_after<<endl;
				  }
				  seg[numVeh].Trip[0].numCus++;seg[numVeh].Trip[0].waitingS = WSID;
				  routed[IDinsert]=1;
				  seg[numVeh].Trip[0].capacity += problem->node[IDinsert].capacity;
				  goWS = WSID;
				  seg[numVeh].Trip[0].cost += varcost;

				  seg[numVeh].Trip[0].endS = TOTALTIME;
				  numCusPRouted[assignSP]++;
				  if (numCusPRouted[assignSP] == numCusPSP[assignSP]) cont = 0;
				  checkEndSFirstPT(numVeh);
			}
			else cont = 0;  //can't find any customer to insert into the current leg
		 }while (cont);
	 } //end if (numCusPRouted[assignSP] < numCusPSP[assignSP])
     int lastC = seg[numVeh].Trip[0].lastCus;
	 if (goWS == NO_WS)
		 ArrTime = seg[numVeh].Trip[0].endS + problem->c[lastC][assignSP];
	 else
		 ArrTime = seg[numVeh].Trip[0].endS + problem->disCWSSP[lastC][assignSP];
	 seg[numVeh].Trip[0].leaveSP = PDS_MAX(ArrTime, problem->nodeSP[assignSP].sTW1) + problem->nodeSP[assignSP].unload;
	 numTrip++;
     /*cout<<"The first Pickup trip of Vehicle "<<numVeh<<" has "<<seg[numVeh].Trip[0].numCus<<" Pcustomers; leaveSP = "<<seg[numVeh].Trip[0].leaveSP<<endl;
	 showTripCus(numVeh,0);*/
	 /*if (seg[numVeh].Trip[0].numCus == 1)
	 {
		 int buon = seg[numVeh].Trip[0].firstCus;
		 cout<<"StartS["<<buon<<"] = "<<startS[buon]<<"; depart = "<<depart[buon]<<endl;
		 cout<<"endS = "<<seg[numVeh].Trip[0].endS<<endl;
	 }*/
}
void Solution::checkEndSFirstPT(int idVeh) 
{
	int assSP = seg[idVeh].Trip[0].assSP; 

	double cArrTime;
	int curC, nextC; double departT;
	int i;

	curC = seg[idVeh].Trip[0].firstCus;


	cArrTime = PDS_MAX(problem->c[0][curC], problem->node[curC].sTW);
	//Update startS and waitTime for each customer:
	double vioTWCT = PDS_MAX(0, cArrTime - problem->node[curC].eTW);
	if (vioTWCT > eps) departT = problem->node[curC].depart;
	else departT = PDS_MAX(cArrTime, problem->node[curC].sTW) + problem->node[curC].duration;
	nextC = nextArr[curC];


		
	int numC = seg[idVeh].Trip[0].numCus; 
	for (i=2;i<=numC;i++)
	{
		cArrTime = departT + problem->c[curC][nextC];
		vioTWCT = PDS_MAX(0, cArrTime - problem->node[nextC].eTW);
        if (vioTWCT > eps)
			departT = problem->node[nextC].depart;
		else
			departT = PDS_MAX(cArrTime, problem->node[nextC].sTW) + problem->node[nextC].duration;
		curC = nextC; nextC=nextArr[curC];
	}

	if (PDSDIF(departT, seg[idVeh].Trip[0].endS))
	{
		cout<<"ERROR checkEndSFirstPT("<<idVeh<<"): correct endS = "<<departT<<"; wrong from init sol= "<<seg[idVeh].Trip[0].endS<<endl;
		cout<<"depart[lastC = "<<curC<<"] = "<<departT<<"; c(0, lastC) = "<<problem->c[0][curC]<<"; c(lastC, sp) = "<<problem->c[curC][assSP]<<",c(lastC, WS, sp) = "<<problem->disCWSSP[curC][assSP]<<endl;
		cout<<"[sTW,eTW] of cus = ["<<problem->node[curC].sTW<<", "<<problem->node[curC].eTW<<"], dur = "<<problem->node[curC].duration<<endl;
		cout<<"sp[sTW1, eTW1] = ["<<problem->nodeSP[assSP].sTW1<<", "<<problem->nodeSP[assSP].eTW1<<"]"<<endl;
		showTripCus(idVeh, 0);
		exit(-1);
   }
}
bool Solution::checkPickupTripFeasible_AfterInsertC2C(int idCusD, double departTime, double &costT, int idVeh, int idTrip, bool &changed_idTrip)
{
	//
	int preC = seg[idVeh].Trip[idTrip].firstCus;
	double cStartS, ArrTime, temp;
	cStartS = PDS_MAX(departTime + problem->c[idCusD][preC], problem->node[preC].sTW);
	//cout<<"idCusD = "<<idCusD<<"; firstCofPTrip = "<<preC<<"; startS = "<<cStartS<<"; [sTW, eTW] = ["<<problem->node[preC].sTW<<", "<<problem->node[preC].eTW<<"]"<<endl;
	if (PDSDIF(cStartS, startS[preC])==0) 
	  {/*cout<<"startS of cus "<<preC<<" doesn't change -->ok"<<endl;*/ return 1;}
	temp = cStartS - problem->node[preC].eTW;
	if (temp > eps) {/*cout<<"not ok TW at cus "<<preC<<endl; */return 0;}
    int curC = nextArr[preC];
	while (curC > 0)
	{
		ArrTime = cStartS + problem->node[preC].duration + problem->c[preC][curC];
		cStartS = PDS_MAX(ArrTime, problem->node[curC].sTW);
		if (PDSDIF(cStartS, startS[curC])==0) {/*cout<<"startS of cus "<<curC<<" doesn't change -->ok"<<endl;*/ return 1;}
		temp = cStartS - problem->node[curC].eTW;
		if (temp > eps) {/*cout<<"not ok TW at cus "<<curC<<endl; */return 0;}
		//cout<<curC<<"(startS = "<<cStartS<<"); ";
		preC = curC; curC = nextArr[curC];
	}
	//cout<<"--> ok TW of all Pcus"<<endl;
	//preC now points to the last customers of P(idVeh, idTrip)
	int assSP = seg[idVeh].Trip[idTrip].assSP;
	cStartS += problem->node[preC].duration;
	if (seg[idVeh].Trip[idTrip].waitingS == NO_WS)
	{
		//before insert go directly to sp --> after insert still the same
		ArrTime = cStartS + problem->c[preC][assSP];
		if (PDSINRANGE(ArrTime, problem->nodeSP[assSP].sTW1, problem->nodeSP[assSP].eTW1)) return 1;
		return 0;
	}
	else
	{
		//Before insert, vehicle go to sp through WS:
		ArrTime = cStartS + problem->c[preC][assSP];
		if (PDSINRANGE(ArrTime, problem->nodeSP[assSP].sTW1, problem->nodeSP[assSP].eTW1))
		{
			costT += (problem->c[preC][assSP] - problem->disCWSSP[preC][assSP]); //after insert go to SP directly
			changed_idTrip = 1;
			return 1;
		}
		else
		{
			temp = ArrTime - problem->nodeSP[assSP].eTW1;
			if (temp > eps) return 0; //now vioTWSP
			ArrTime = cStartS + problem->disCWSSP[preC][assSP];
			temp = ArrTime - problem->nodeSP[assSP].eTW1;
			if (temp > eps) return 0; //after insert: go to SP directly too soon, go through WS too late
			return 1; //after insert, still go through WS
		}
	}
}

bool Solution::checkPickupTripFeasible_AfterInsertC2C_Temp(int idCusD, double departTime, double &costT, int idVeh, int idTrip, bool &changed_idTrip)
{
	int preC = seg[idVeh].Trip[idTrip].firstCus;
	double cStartS, ArrTime, temp;
	cStartS = PDS_MAX(departTime + problem->c[idCusD][preC], problem->node[preC].sTW);
	if (PDSDIF(cStartS, startS[preC])==0) return 1;
	temp = cStartS - problem->node[preC].eTW;
	if (temp > eps) return 0;
    int curC = nextArrTemp[preC];
	while (curC > 0)
	{
		ArrTime = cStartS + problem->node[preC].duration + problem->c[preC][curC];
		cStartS = PDS_MAX(ArrTime, problem->node[curC].sTW);
		if (PDSDIF(cStartS, startS[curC])==0) return 1;
		temp = cStartS - problem->node[curC].eTW;
		if (temp > eps) return 0;
		preC = curC; curC = nextArrTemp[curC];
	}
	//preC now points to the last customers of P(idVeh, idTrip)
	int assSP = seg[idVeh].Trip[idTrip].assSP;
	cStartS += problem->node[preC].duration;
	if (seg[idVeh].Trip[idTrip].waitingS == NO_WS)
	{
		//before insert go directly to sp --> after insert still the same
		ArrTime = cStartS + problem->c[preC][assSP];
		if (PDSINRANGE(ArrTime, problem->nodeSP[assSP].sTW1, problem->nodeSP[assSP].eTW1)) return 1;
		return 0;
	}
	else
	{
		//Before insert, vehicle go to sp through WS:
		ArrTime = cStartS + problem->c[preC][assSP];
		if (PDSINRANGE(ArrTime, problem->nodeSP[assSP].sTW1, problem->nodeSP[assSP].eTW1))
		{
			costT += (problem->c[preC][assSP] - problem->disCWSSP[preC][assSP]); //after insert go to SP directly
			changed_idTrip = 1;
			return 1;
		}
		else
		{
			temp = ArrTime - problem->nodeSP[assSP].eTW1;
			if (temp > eps) return 0; //now vioTWSP
			ArrTime = cStartS + problem->disCWSSP[preC][assSP];
			temp = ArrTime - problem->nodeSP[assSP].eTW1;
			if (temp > eps) return 0; //after insert: go to SP directly too soon, go through WS too late
			return 1; //after insert, still go through WS
		}
	}
}

bool Solution::checkFeasible_ConnectC2CDToSP_AfterInsertC2C(int lastC, double depart_lastC, double &costT, int lastCOLD, int endSP, int goWS, bool &changeWSORGoWS)
{
	//Used by CreateC2CTrip_BetweenDTripandSP_Temp
	double ArrTime;
	if (lastCOLD == lastC)
	{
		if (goWS == NO_WS)
		{
			//before insert go directly to sp --> after insert still the same
			changeWSORGoWS = 0;
			ArrTime = depart_lastC + problem->c[lastC][endSP];
			if (PDSINRANGE(ArrTime, problem->nodeSP[endSP].sTW2, problem->nodeSP[endSP].eTW2)) return 1;
			return 0;
		}
		else
		{
			//Before insert, vehicle go to sp through WS:
			ArrTime = depart_lastC + problem->c[lastC][endSP];
			if (PDSINRANGE(ArrTime, problem->nodeSP[endSP].sTW2, problem->nodeSP[endSP].eTW2))
			{
				costT += (problem->c[lastC][endSP] - problem->disCWSSP[lastC][endSP]); //after insert go to SP directly
				changeWSORGoWS = 1;
				return 1;
			}
			else
			{
				double temp = ArrTime - problem->nodeSP[endSP].eTW2;
				if (temp > eps) return 0; //now vioTWSP
				ArrTime = depart_lastC + problem->disCWSSP[lastC][endSP];
				temp = ArrTime - problem->nodeSP[endSP].eTW1;
				if (temp > eps) return 0; //after insert: go to SP directly too soon, go through WS too late
				changeWSORGoWS = 0;
				return 1; //after insert, still go through WS
			}
		}

	}
	else //lastC of C2C has changed
	{
		ArrTime = depart_lastC + problem->c[lastC][endSP];
		if (PDSINRANGE(ArrTime, problem->nodeSP[endSP].sTW2, problem->nodeSP[endSP].eTW2))
		{
			if (goWS == NO_WS)
			{
				costT += (problem->c[lastC][endSP] - problem->c[lastCOLD][endSP]);
			}
			else 
			{
				costT += (problem->c[lastC][endSP] - problem->disCWSSP[lastCOLD][endSP]);
			}
			changeWSORGoWS = 0;
			return 1;
		}
		double temp = ArrTime - problem->nodeSP[endSP].eTW2;
		if (temp > eps) return 0;
		ArrTime = depart_lastC + problem->disCWSSP[lastC][endSP];
		temp = ArrTime - problem->nodeSP[endSP].eTW2;
		if (temp > eps) return 0;
		if (goWS == NO_WS)
			costT += (problem->disCWSSP[lastC][endSP] - problem->c[lastCOLD][endSP]);
		else costT += (problem->disCWSSP[lastC][endSP] - problem->disCWSSP[lastCOLD][endSP]);
		changeWSORGoWS = 1;
		return 1;
	}//end lastC of C2C has changed
}
bool Solution::checkC2CAndPTripFeasible_AfterInsertC2C(int curC, double departTime, int nextC, int pos_nextC, double *departTemp, int idVeh, int idTrip)
{
	//Update 10/11/2013: check TW at all customers of TRip C2C starting from curC with departureTime and then all customers of next Ptrip(idVeh,idTrip)
	//if feasible return 1; otherwise return 0

	double cStartS, ArrTime, temp;
	cStartS = departTime;
	while (nextC > 0)
	{
		ArrTime = cStartS + problem->c[curC][nextC];
		cStartS = PDS_MAX(ArrTime, problem->node[nextC].sTW);
		temp = cStartS - problem->node[nextC].eTW;
		if (temp > eps) return 0;
		cStartS += problem->node[nextC].duration;
		departTemp[pos_nextC] = cStartS;
		pos_nextC++;
		curC = nextC; nextC = nextArr[curC];
	}
	//curC now points to the last customer of trip C2C, now continue checking PTrip
    nextC = seg[idVeh].Trip[idTrip].firstCus;
	while (nextC > 0)
	{
		ArrTime = cStartS + problem->c[curC][nextC];
		cStartS = PDS_MAX(ArrTime, problem->node[nextC].sTW);
		if (PDSDIF(cStartS, startS[nextC])==0) return 1;
		temp = cStartS - problem->node[nextC].eTW;
		if (temp > eps) return 0;
		cStartS += problem->node[nextC].duration;
		curC = nextC; nextC = nextArr[curC];
	}

	//curC now points to the last customers of PTrip
	int assSP = seg[idVeh].Trip[idTrip].assSP;
	ArrTime = cStartS + problem->c[curC][assSP];
	if (PDSINRANGE(ArrTime, problem->nodeSP[assSP].sTW1, problem->nodeSP[assSP].eTW1)) return 1;

	temp = ArrTime - problem->nodeSP[assSP].eTW1;
	if (temp > eps) return 0; //now vioTWSP
	ArrTime = cStartS + problem->disCWSSP[curC][assSP];
	temp = ArrTime - problem->nodeSP[assSP].eTW1;
	if (temp > eps) return 0; //after insert: go to SP directly too soon, go through WS too late
	return 1; //after insert, still go through WS
}



bool Solution::checkC2CAndPTripFeasible_AfterInsertC2C_Temp(int curC, double departTime, int nextC, int pos_nextC, double *departTemp, int idVeh, int idTrip)
{
	//Update 10/11/2013: check TW at all customers of TRip C2C starting from curC with departureTime and then all customers of next Ptrip(idVeh,idTrip)
	//if feasible return 1; otherwise return 0

	double cStartS, ArrTime, temp;
	cStartS = departTime;
	while (nextC > 0)
	{
		ArrTime = cStartS + problem->c[curC][nextC];
		cStartS = PDS_MAX(ArrTime, problem->node[nextC].sTW);
		temp = cStartS - problem->node[nextC].eTW;
		if (temp > eps) return 0;
		cStartS += problem->node[nextC].duration;
		departTemp[pos_nextC] = cStartS;
		pos_nextC++;
		curC = nextC; nextC = nextArrTemp[curC];
	}
	//curC now points to the last customer of trip C2C, now continue checking PTrip
    nextC = seg[idVeh].Trip[idTrip].firstCus;
	while (nextC > 0)
	{
		ArrTime = cStartS + problem->c[curC][nextC];
		cStartS = PDS_MAX(ArrTime, problem->node[nextC].sTW);
		if (PDSDIF(cStartS, startS[nextC])==0) return 1;
		temp = cStartS - problem->node[nextC].eTW;
		if (temp > eps) return 0;
		cStartS += problem->node[nextC].duration;
		curC = nextC; nextC = nextArrTemp[curC];
	}

	//curC now points to the last customers of PTrip
	int assSP = seg[idVeh].Trip[idTrip].assSP;
	ArrTime = cStartS + problem->c[curC][assSP];
	if (PDSINRANGE(ArrTime, problem->nodeSP[assSP].sTW1, problem->nodeSP[assSP].eTW1)) return 1;

	temp = ArrTime - problem->nodeSP[assSP].eTW1;
	if (temp > eps) return 0; //now vioTWSP
	ArrTime = cStartS + problem->disCWSSP[curC][assSP];
	temp = ArrTime - problem->nodeSP[assSP].eTW1;
	if (temp > eps) return 0; //after insert: go to SP directly too soon, go through WS too late
	return 1; //after insert, still go through WS
}

bool Solution::checkC2CTripFeasible_AfterInsertC2C_Temp(int curC, double departTime, int nextC, int pos_nextC, double *departTemp, int endSP)
{
	//Update 10/11/2013: check TW at all customers of TRip C2C starting from curC with departureTime and then all customers of next Ptrip(idVeh,idTrip)
	//if feasible return 1; otherwise return 0

	double cStartS, ArrTime, temp;
	cStartS = departTime;
	while (nextC > 0)
	{
		ArrTime = cStartS + problem->c[curC][nextC];
		cStartS = PDS_MAX(ArrTime, problem->node[nextC].sTW);
		temp = cStartS - problem->node[nextC].eTW;
		if (temp > eps) return 0;
		cStartS += problem->node[nextC].duration;
		departTemp[pos_nextC] = cStartS;
		pos_nextC++;
		curC = nextC; nextC = nextArrTemp[curC];
	}
	//curC now points to the last customers of C2CTrip
	ArrTime = cStartS + problem->c[curC][endSP];
	if (PDSINRANGE(ArrTime, problem->nodeSP[endSP].sTW2, problem->nodeSP[endSP].eTW2)) return 1;
	temp = ArrTime - problem->nodeSP[endSP].eTW2;
	if (temp > eps) return 0; //now vioTWSP
	ArrTime = cStartS + problem->disCWSSP[curC][endSP];
	temp = ArrTime - problem->nodeSP[endSP].eTW2;
	if (temp > eps) return 0; //after insert: go to SP directly too soon, go through WS too late
	return 1; //after insert, still go through WS


}

bool Solution::checkC2CVehicleFeasible(int curC, double departTime, int nextC, int pos_nextC, double *departTemp)
{
	//Update 10/11/2013: check TW at all customers of TRip C2C starting from curC with departureTime and then all customers of next Ptrip(idVeh,idTrip)
	//if feasible return 1; otherwise return 0

	double cStartS, ArrTime, temp;
	cStartS = departTime;
	while (nextC > 0)
	{
		ArrTime = cStartS + problem->c[curC][nextC];
		cStartS = PDS_MAX(ArrTime, problem->node[nextC].sTW);
		temp = cStartS - problem->node[nextC].eTW;
		if (temp > eps) return 0;
		cStartS += problem->node[nextC].duration;
		departTemp[pos_nextC] = cStartS;
		pos_nextC++;
		curC = nextC; nextC = nextArr[curC];
	}
	return 1;
}






bool Solution::checkC2CAndPTripFeasibleCostChange_AfterInsertC2C(int curC, double departTime_curC, int nextC, double &costT, int idVeh, int idTrip, bool &changed_idTrip)
{
	//Update 10/11/2013: check TW at all customers of TRip C2C starting from curC with departureTime and then all customers of next Ptrip(idVeh,idTrip)
	//if feasible return 1; otherwise return 0
	//and calculate the change in cost due to connect to SP of PTrip

	costT = 0;
	double cStartS, ArrTime, temp;
	cStartS = departTime_curC;
	while (nextC > 0)
	{
		ArrTime = cStartS + problem->c[curC][nextC];
		cStartS = PDS_MAX(ArrTime, problem->node[nextC].sTW);
		temp = cStartS - problem->node[nextC].eTW;
		if (temp > eps) return 0;
		cStartS += problem->node[nextC].duration;
		curC = nextC; nextC = nextArr[curC];
	}
	//curC now points to the last customer of trip C2C, now continue checking PTrip
    nextC = seg[idVeh].Trip[idTrip].firstCus;
	while (nextC > 0)
	{
		ArrTime = cStartS + problem->c[curC][nextC];
		cStartS = PDS_MAX(ArrTime, problem->node[nextC].sTW);
		if (PDSDIF(cStartS, startS[nextC])==0) return 1;
		temp = cStartS - problem->node[nextC].eTW;
		if (temp > eps) return 0;
		cStartS += problem->node[nextC].duration;
		curC = nextC; nextC = nextArr[curC];
	}

	//curC now points to the last customers of PTrip
	int assSP = seg[idVeh].Trip[idTrip].assSP;
	if (seg[idVeh].Trip[idTrip].waitingS == NO_WS)
	{
		//before insert go directly to sp --> after insert still the same
		ArrTime = cStartS + problem->c[curC][assSP];
		if (PDSINRANGE(ArrTime, problem->nodeSP[assSP].sTW1, problem->nodeSP[assSP].eTW1)) return 1;
		return 0;
	}
	else
	{
		//Before insert, vehicle go to sp through WS:
		ArrTime = cStartS + problem->c[curC][assSP];
		if (PDSINRANGE(ArrTime, problem->nodeSP[assSP].sTW1, problem->nodeSP[assSP].eTW1))
		{
			costT += (problem->c[curC][assSP] - problem->disCWSSP[curC][assSP]); //after insert go to SP directly
			changed_idTrip = 1;
			return 1;
		}
		else
		{
			temp = ArrTime - problem->nodeSP[assSP].eTW1;
			if (temp > eps) return 0; //now vioTWSP
			ArrTime = cStartS + problem->disCWSSP[curC][assSP];
			temp = ArrTime - problem->nodeSP[assSP].eTW1;
			if (temp > eps) return 0; //after insert: go to SP directly too soon, go through WS too late
			return 1; //after insert, still go through WS
		}
	}
}

bool Solution::checkC2CTripFeasibleCostChange_AfterInsertC2C_Temp(int curC, double departTime_curC, int nextC, double &costT, int idVeh, int idTrip, int endSP, bool &changeWSORGoWS)
{
	//Used by CreateC2CTrip_BetweenDTripandSP_Temp

	//Update 12/11/2013: check TW at all customers of TRip C2C starting from curC with departureTime and at SP endSP
	//if feasible return 1; otherwise return 0
	//and calculate the change in cost due to connect to endSP

	double cStartS, ArrTime, temp;
	cStartS = departTime_curC;
	int idCusD = curC;

		while (nextC > 0)
		{
			ArrTime = cStartS + problem->c[curC][nextC];
			cStartS = PDS_MAX(ArrTime, problem->node[nextC].sTW);
			temp = cStartS - problem->node[nextC].eTW;
			if (temp > eps) return 0;
			cStartS += problem->node[nextC].duration;
			curC = nextC; nextC = nextArrTemp[curC];
		}
		//curC now points to the last customer of trip C2C, now continue checking PTrip
		int lastC2C = seg[idVeh].Trip[idTrip].lastCus;
		if (curC == lastC2C) //lastCus has not changed
		{
			if (seg[idVeh].Trip[idTrip].waitingS == NO_WS)
			{
				//before insert go directly to sp --> after insert still the same
				changeWSORGoWS = 0;
				ArrTime = cStartS + problem->c[curC][endSP];
				if (PDSINRANGE(ArrTime, problem->nodeSP[endSP].sTW2, problem->nodeSP[endSP].eTW2)) 
				{
					//cout<<"idCusD = "<<idCusD<<"; LastCus of C2C NOT changed("<<curC<<"); before go to sp directly --> now has to the same"<<endl;
					return 1;
				}
				return 0;
			}
			else
			{
				//Before insert, vehicle go to sp through WS:
				ArrTime = cStartS + problem->c[curC][endSP];
				if (PDSINRANGE(ArrTime, problem->nodeSP[endSP].sTW2, problem->nodeSP[endSP].eTW2))
				{
					//cout<<"idCusD = "<<idCusD<<"; LastCus of C2C NOT changed("<<curC<<"); before go to WS --> now sp directly"<<endl;
					costT += (problem->c[curC][endSP] - problem->disCWSSP[curC][endSP]); //after insert go to SP directly
					changeWSORGoWS = 1;
					return 1;
				}
				else
				{
					temp = ArrTime - problem->nodeSP[endSP].eTW2;
					if (temp > eps) return 0; //now vioTWSP
					ArrTime = cStartS + problem->disCWSSP[curC][endSP];
					temp = ArrTime - problem->nodeSP[endSP].eTW2;
					if (temp > eps) return 0; //after insert: go to SP directly too soon, go through WS too late
					changeWSORGoWS = 0;
					//cout<<"idCusD = "<<idCusD<<"; LastCus of C2C NOT changed("<<curC<<"); before and after through WS"<<endl;
					return 1; //after insert, still go through WS
				}
			}

		}
		else //lastCus has changed
		{
			ArrTime = cStartS + problem->c[curC][endSP];
			if (PDSINRANGE(ArrTime, problem->nodeSP[endSP].sTW2, problem->nodeSP[endSP].eTW2))
			{
				if (seg[idVeh].Trip[idTrip].waitingS != NO_WS) 
				{
					//cout<<"idCusD = "<<idCusD<<"; LastCus of C2C has changed("<<lastC2C<<"-->"<<curC<<"), now go directly to sp, before through WS: ArrTimeNew = "<<ArrTime<<";[sTW2,eTW2] = ["<<problem->nodeSP[endSP].sTW2<<", "<<problem->nodeSP[endSP].eTW2<<"]"<<endl;
					costT += (problem->c[curC][endSP] - problem->disCWSSP[lastC2C][endSP]);
				}
				else
				{
					//cout<<"idCusD = "<<idCusD<<"; LastCus of C2C has changed("<<lastC2C<<"-->"<<curC<<"), now and before go directly to sp: ArrTimeNew = "<<ArrTime<<";[sTW2,eTW2] = ["<<problem->nodeSP[endSP].sTW2<<", "<<problem->nodeSP[endSP].eTW2<<"]"<<endl;
					costT += (problem->c[curC][endSP] - problem->c[lastC2C][endSP]);
				}
				changeWSORGoWS = 0;
				return 1;
			}
			else
			{
				temp = ArrTime - problem->nodeSP[endSP].eTW2;
				if (temp > eps) return 0;
				ArrTime = cStartS + problem->disCWSSP[curC][endSP];
			    temp = ArrTime - problem->nodeSP[endSP].eTW2;
				if (temp > eps) return 0;
				if (seg[idVeh].Trip[idTrip].waitingS != NO_WS) 
				{
					//cout<<"idCusD = "<<idCusD<<"; LastCus of C2C has changed("<<lastC2C<<"-->"<<curC<<"), now and before through WS:  ArrTimeNew = "<<ArrTime<<";[sTW2,eTW2] = ["<<problem->nodeSP[endSP].sTW2<<", "<<problem->nodeSP[endSP].eTW2<<"]"<<endl;
					costT += (problem->disCWSSP[curC][endSP] - problem->disCWSSP[lastC2C][endSP]);
				}
				else
				{
					//cout<<"idCusD = "<<idCusD<<"; LastCus of C2C has changed("<<lastC2C<<"-->"<<curC<<"), now through WS, before go directly to sp ArrTimeNew = "<<ArrTime<<";[sTW2,eTW2] = ["<<problem->nodeSP[endSP].sTW2<<", "<<problem->nodeSP[endSP].eTW2<<"]"<<endl;
					costT += (problem->disCWSSP[curC][endSP] - problem->c[lastC2C][endSP]);
				}
				changeWSORGoWS = 1;
				return 1;
			}
		}//end lastCus has changed
}

bool Solution::checkC2CAndPTripFeasibleCostChange_AfterInsertC2C_Temp(int curC, double departTime_curC, int nextC, double &costT, int idVeh, int idTrip, bool &changed_idTrip)
{
	//Update 10/11/2013: check TW at all customers of TRip C2C starting from curC with departureTime and then all customers of next Ptrip(idVeh,idTrip)
	//if feasible return 1; otherwise return 0
	//and calculate the change in cost due to connect to SP of PTrip

	costT = 0;
	double cStartS, ArrTime, temp;
	cStartS = departTime_curC;
	while (nextC > 0)
	{
		ArrTime = cStartS + problem->c[curC][nextC];
		cStartS = PDS_MAX(ArrTime, problem->node[nextC].sTW);
		temp = cStartS - problem->node[nextC].eTW;
		if (temp > eps) return 0;
		cStartS += problem->node[nextC].duration;
		curC = nextC; nextC = nextArrTemp[curC];
	}
	//curC now points to the last customer of trip C2C, now continue checking PTrip
    nextC = seg[idVeh].Trip[idTrip].firstCus;
	while (nextC > 0)
	{
		ArrTime = cStartS + problem->c[curC][nextC];
		cStartS = PDS_MAX(ArrTime, problem->node[nextC].sTW);
		if (PDSDIF(cStartS, startS[nextC])==0) return 1;
		temp = cStartS - problem->node[nextC].eTW;
		if (temp > eps) return 0;
		cStartS += problem->node[nextC].duration;
		curC = nextC; nextC = nextArrTemp[curC];
	}

	//curC now points to the last customers of PTrip
	int assSP = seg[idVeh].Trip[idTrip].assSP;
	if (seg[idVeh].Trip[idTrip].waitingS == NO_WS)
	{
		//before insert go directly to sp --> after insert still the same
		ArrTime = cStartS + problem->c[curC][assSP];
		if (PDSINRANGE(ArrTime, problem->nodeSP[assSP].sTW1, problem->nodeSP[assSP].eTW1)) return 1;
		return 0;
	}
	else
	{
		//Before insert, vehicle go to sp through WS:
		ArrTime = cStartS + problem->c[curC][assSP];
		if (PDSINRANGE(ArrTime, problem->nodeSP[assSP].sTW1, problem->nodeSP[assSP].eTW1))
		{
			costT += (problem->c[curC][assSP] - problem->disCWSSP[curC][assSP]); //after insert go to SP directly
			changed_idTrip = 1;
			return 1;
		}
		else
		{
			temp = ArrTime - problem->nodeSP[assSP].eTW1;
			if (temp > eps) return 0; //now vioTWSP
			ArrTime = cStartS + problem->disCWSSP[curC][assSP];
			temp = ArrTime - problem->nodeSP[assSP].eTW1;
			if (temp > eps) return 0; //after insert: go to SP directly too soon, go through WS too late
			return 1; //after insert, still go through WS
		}
	}
}
int Solution::Create_PickupTrip(int idTrip_departSP,int departSP, int &numTrip, double leave_departSP, int &nextSP, int typeofseed, int typeofINIT, int valueFEE)
{
	//Create a pickup trip (idVeh, idTrip) that leaves sp departSP where the time to leave departSP is leave_departSP:
    int endSP;
	int canRoute = 0;
	double feeMIN = PDS_INFINITY;
    bool NULLTrip = 0;

	int idTrip = numTrip+3; //for storing temporary trip during call Init_NewSolomonI1_NewPickupTrip
	for (endSP=departSP+1; endSP<=nSP;endSP++)
	  if (numCusPRouted[endSP] < numCusPSP[endSP] || numCusDRouted[endSP] < problem->numCusDSP[endSP]) //exist unrouted customers in sj
		  Init_NewSolomonI1_NewPickupTrip(idTrip_departSP,departSP, endSP, idTrip,leave_departSP, nextSP, feeMIN, NULLTrip, typeofseed,valueFEE,typeofINIT,canRoute);
 
	if (canRoute==0) return 0; //p-departSP is already last trip

	int idB;
	if (NULLTrip) //p -departSP (-- nextSP)  Note: thing in () is what be created
	{
		idB = idTrip + 1;
		seg[numVeh].Trip[numTrip].connectCost = seg[numVeh].Trip[idB].cost;
		seg[numVeh].Trip[numTrip].cost += seg[numVeh].Trip[numTrip].connectCost;
		seg[numVeh].Trip[numTrip].waitingS1 = seg[numVeh].Trip[idB].waitingS;
		seg[numVeh].Trip[numTrip].arriveSP = seg[numVeh].Trip[idB].leaveSP;
		//cout<<"CREATING p -departSP (-- nextSP): picktrip("<<numVeh<<", "<<numTrip<<") = "<<seg[numVeh].Trip[numTrip].cost<<endl;
		return 2;
	}
	else 
	{
		if (canRoute == 1) //only C2C: p - departSP - (C2C - nextSP)
		{
			int preT = numTrip;
			numTrip ++;  idB = idTrip+1;
			seg[numVeh].Trip[numTrip] = seg[numVeh].Trip[idB]; //best trip is C2C
			   
			//Update all information for new trip:.....
			int curC = seg[numVeh].Trip[numTrip].firstCus;
			   
			seg[numVeh].Trip[preT].connectCost = problem->c[departSP][curC];
			seg[numVeh].Trip[preT].cost += seg[numVeh].Trip[preT].connectCost;
			seg[numVeh].Trip[numTrip].cost -= seg[numVeh].Trip[preT].connectCost;
			  
			while (curC > 0)
			{
				routed[curC]=1;
				nextArr[curC]=nextArrB[curC];
				curC = nextArr[curC];
			}
			curC = seg[numVeh].Trip[numTrip].lastCus;
			numCusC2CRouted += seg[numVeh].Trip[numTrip].numCus; 	
			double ArrTime;
			if (seg[numVeh].Trip[numTrip].waitingS == NO_WS)
				 ArrTime = seg[numVeh].Trip[numTrip].endS + problem->c[curC][nextSP];
			else
			     ArrTime = seg[numVeh].Trip[numTrip].endS + problem->disCWSSP[curC][nextSP];
			seg[numVeh].Trip[numTrip].leaveSP = PDS_MAX(ArrTime, problem->nodeSP[nextSP].sTW2);
			seg[numVeh].Trip[numTrip].arriveSP = seg[numVeh].Trip[numTrip].leaveSP;
			return 2;
		}
		else if (canRoute == 2) //only P: p - departSP - (p - nextSP)
		{
			   int preT = numTrip;
			   numTrip++; idB = idTrip + 2;
			   seg[numVeh].Trip[numTrip] = seg[numVeh].Trip[idB]; //bestTrip is pickup: 
			   //cout<<"Create pickup trip ("<<numVeh<<", "<<numTrip<<"): assSP = "<<seg[numVeh].Trip[numTrip].assSP<<endl;
			  
			   //Update all information for new trip:.....
			   int curC = seg[numVeh].Trip[numTrip].firstCus;
			   
			   seg[numVeh].Trip[preT].connectCost = problem->c[departSP][curC];
			   seg[numVeh].Trip[preT].cost += seg[numVeh].Trip[preT].connectCost;
			   seg[numVeh].Trip[numTrip].cost -= seg[numVeh].Trip[preT].connectCost;
			   //cout<<"CORRECT COST of pickuptrip("<<numVeh<<", "<<preT<<") = "<<seg[numVeh].Trip[preT].cost<<"; ???nextP cost = "<<seg[numVeh].Trip[numTrip].cost<<endl;
			  
			   while (curC > 0)
			   {
					routed[curC]=1;
					nextArr[curC]=nextArrB[curC];
					curC = nextArr[curC];
			   }
			   curC = seg[numVeh].Trip[numTrip].lastCus;
			   //nextArrP[curC]= 0;

			   numCusPRouted[nextSP] += seg[numVeh].Trip[numTrip].numCus; 	
			   double ArrTime;
			   //cout<<"curC = "<<curC<<"; nextSP = "<<nextSP<<endl;
			   if (seg[numVeh].Trip[numTrip].waitingS == NO_WS)
				 ArrTime = seg[numVeh].Trip[numTrip].endS + problem->c[curC][nextSP];
			   else
				 ArrTime = seg[numVeh].Trip[numTrip].endS + problem->disCWSSP[curC][nextSP];
			   ArrTime = PDS_MAX(ArrTime, problem->nodeSP[nextSP].sTW1);
			   seg[numVeh].Trip[numTrip].leaveSP = ArrTime + problem->nodeSP[nextSP].unload;
			   return 1;

		}
		else if (canRoute == 3) //create both C2C and P: p - departSP - (C2C - p - nextSP)
		{
			int preT = numTrip;
			numTrip ++;  idB = idTrip+1;
			seg[numVeh].Trip[numTrip] = seg[numVeh].Trip[idB]; //best trip is C2C
			   
			//Update all information for new C2Ctrip:.....
			int curC = seg[numVeh].Trip[numTrip].firstCus;
			   
			seg[numVeh].Trip[preT].connectCost = problem->c[departSP][curC];
			seg[numVeh].Trip[preT].cost += seg[numVeh].Trip[preT].connectCost;
			seg[numVeh].Trip[numTrip].cost -= seg[numVeh].Trip[preT].connectCost;
			  
			while (curC > 0)
			{
				routed[curC]=1;
				nextArr[curC]=nextArrB[curC];
				curC = nextArr[curC];
			}
			
			int lastC = seg[numVeh].Trip[numTrip].lastCus;
			numCusC2CRouted += seg[numVeh].Trip[numTrip].numCus; 	

			//Update PTrip
			idB++; preT = numTrip; numTrip++;
			seg[numVeh].Trip[numTrip] = seg[numVeh].Trip[idB]; //bestTrip is pickup: 
			  
			//Update all information for new Ptrip:.....
			curC = seg[numVeh].Trip[numTrip].firstCus;
			seg[numVeh].Trip[preT].connectCost = problem->c[lastC][curC];
			  
			while (curC > 0)
			{
					routed[curC]=1;
					nextArr[curC]=nextArrB[curC];
					curC = nextArr[curC];
			}
			curC = seg[numVeh].Trip[numTrip].lastCus;
			
			numCusPRouted[nextSP] += seg[numVeh].Trip[numTrip].numCus; 	
			double ArrTime;
			if (seg[numVeh].Trip[numTrip].waitingS == NO_WS)
				 ArrTime = seg[numVeh].Trip[numTrip].endS + problem->c[curC][nextSP];
			else
				 ArrTime = seg[numVeh].Trip[numTrip].endS + problem->disCWSSP[curC][nextSP];
			ArrTime = PDS_MAX(ArrTime, problem->nodeSP[nextSP].sTW1);
			seg[numVeh].Trip[numTrip].leaveSP = ArrTime + problem->nodeSP[nextSP].unload;
			return 1;
		}
		return -1;
	}
}

void Solution::Init_NewSolomonI1_NewPickupTrip(int idTrip_departSP, int departSP, int endSP, int idTrip, double leave_departSP, int &nextSP, double &feeMIN, bool &NULLTrip, int typeofseed, int valueFEE, int typeofINIT, int &canRoute)
{
	bool emptyTrip = 0;
	double ArrTime, temp;
	int lC2C = -1, lP = -1;
	//When calling this procedure, the vehicle already has: ...p-departSP --> call this procedure
	//to create a trip connecting departSP to endSP:
	//Create: (1) departSP - p - endSP OR (2) departSP - C2C - p - endSP OR (3) departSP - endSP OR (4) departSP - C2C - endSP
	
	//cout<<"Solution::Init_NewSolomonI1_NewPickupTrip departSP = "<<departSP<<"; endSP = "<<endSP<<"; leave_departSP = "<<leave_departSP<<"; eTW = "<<problem->nodeSP[endSP].eTW1<<endl;

	if (numCusPRouted[endSP] < numCusPSP[endSP])
	{
			int i, idCus, seed, insert_after, preINS, nextINS, curC, nextC; 
			int goWS, goWSMINI, WSIDtemp, IDinsert;
			double startSTemp, ArrTime1, costP, TOTALTIME, varcost,c1;
			for (i=1;i<=numCusPSP[endSP];i++)
			{
				idCus = CusPSP[endSP][i];
				routedTemp[idCus] = routed[idCus];                       
			}
			double costMINI = PDS_INFINITY; seed = -1;
			//P1.Insert first pickup customer:
			for (i=1;i<=numCusPSP[endSP];i++)
			{
				idCus = CusPSP[endSP][i];
				if (routedTemp[idCus]==0)
				{
					ArrTime = leave_departSP + problem->c[departSP][idCus];
					temp = ArrTime - problem->node[idCus].eTW;
					if (temp > eps) continue; //vioTW at idCus--> try another idCus
					ArrTime = PDS_MAX(ArrTime, problem->node[idCus].sTW) + problem->node[idCus].duration;
					ArrTime1 = ArrTime + problem->c[idCus][endSP];
					if (PDSINRANGE(ArrTime1, problem->nodeSP[endSP].sTW1, problem->nodeSP[endSP].eTW1)) 
					{
						  goWS=NO_WS;
						  costP = problem->c[departSP][idCus] + problem->c[idCus][endSP];
					}
					else
					{
						temp = ArrTime1 - problem->nodeSP[endSP].eTW1;
						if (temp > eps) continue;
						ArrTime1 = ArrTime + problem->disCWSSP[idCus][endSP];
						temp = ArrTime1 - problem->nodeSP[endSP].eTW1;
						if (temp > eps) continue;
						goWS = problem->CWSSP[idCus][endSP];
						costP = problem->c[departSP][idCus] + problem->disCWSSP[idCus][endSP];
					}
					if (costP < costMINI)
					{
						  seed=idCus;
						  costMINI = costP;
						  goWSMINI = goWS;
						  TOTALTIME = ArrTime;
					}
				}
			}//end for
     		if (seed != -1) //can insert pickup customer 
			{
				routedTemp[seed]=1; lP = idTrip;
				seg[numVeh].Trip[idTrip].Type = 0;
				seg[numVeh].Trip[idTrip].assSP = endSP;
				//cout<<"Pickup seed = "<<seed<<": ASSSP = "<<seg[numVeh].Trip[idTrip].assSP<<endl;
				seg[numVeh].Trip[idTrip].firstCus = seed; //id of the first Customer of Leg
				seg[numVeh].Trip[idTrip].lastCus = seed; //id of the first Customer of Leg
				seg[numVeh].Trip[idTrip].numCus = 1; //#Customers in the leg
				seg[numVeh].Trip[idTrip].capacity = problem->node[seed].capacity;
				seg[numVeh].Trip[idTrip].waitingS = goWSMINI;
				nextArrTemp[seed] = 0; //just correct for initial solution
				seg[numVeh].Trip[idTrip].cost = costMINI;
				seg[numVeh].Trip[idTrip].endS = TOTALTIME;
				seg[numVeh].Trip[idTrip].feasible = 1;
			    goWS = goWSMINI;
	
				// P2. Continue to insert pickup customers:
				//starting to find customer to insert into the current trip (startSP, endSP):
				bool cont=true;  
				int WSID;
				do //each loop insert 1 pickup customer
				{
				    insert_after=-1; varcost = PDS_INFINITY;
				    int lastCP = seg[numVeh].Trip[idTrip].lastCus;  
					bool ok; 
					for (i=1;i<=numCusPSP[endSP];i++)
					{
					   idCus = CusPSP[endSP][i];
					   if (!routedTemp[idCus]  && (seg[numVeh].Trip[idTrip].capacity + problem->node[idCus].capacity <= problem->Q))
					   {
						    //1. try to insert pickup idCus at the beginning of the trip:
							ok=1; nextINS = seg[numVeh].Trip[idTrip].firstCus;
							ArrTime = leave_departSP + problem->c[departSP][idCus];
							temp = ArrTime - problem->node[idCus].eTW;
							if (temp > eps) continue; //check another idCus
							ArrTime = PDS_MAX(ArrTime, problem->node[idCus].sTW) + problem->node[idCus].duration;
							curC = idCus; nextC = seg[numVeh].Trip[idTrip].firstCus;
							while (nextC > 0)
							{
								ArrTime += problem->c[curC][nextC];
								temp = ArrTime - problem->node[nextC].eTW;
								if (temp > eps) {ok=0;break;} //vioTW at customer nextC
								else
								{
									ArrTime = PDS_MAX(ArrTime, problem->node[nextC].sTW) + problem->node[nextC].duration;
									curC = nextC; nextC = nextArrTemp[curC];
								}
							}
                            if (ok) //curC now points to last pick of trip (numVeh, l)
							{
								ArrTime1 = ArrTime + problem->c[curC][endSP];
								temp = problem->nodeSP[endSP].eTW1 - ArrTime1;
								if (temp > eps) //else too late to go to sp directly
								{
								   if (PDSINRANGE(ArrTime1,problem->nodeSP[endSP].sTW1, problem->nodeSP[endSP].eTW1))
									 WSIDtemp = NO_WS;
								   else
								   {
									  ArrTime1 = ArrTime + problem->disCWSSP[curC][endSP];
									  temp = ArrTime1 - problem->nodeSP[endSP].eTW1;
									  if (temp > eps) ok=0; //too late to go to sp through WS
									  else WSIDtemp = problem->CWSSP[curC][endSP];
								   }
								   if (ok) //ok to insert idCus at beginning of trip l
								   {
								 	  c1 = problem->c[departSP][idCus] + problem->c[idCus][nextINS] - problem->c[departSP][nextINS];
					                  if (goWS != WSIDtemp)
									  {
									  	if (goWS != NO_WS) //before go to WS, after insert don't need to go to WS:
											c1 += (problem->c[lastCP][endSP] - problem->disCWSSP[lastCP][endSP]);
										else 
										{
											    cout<<"Solution::Init_NewSolomonI1_NewPickupTrip ERROR before insert pickup customer go to sp, after insert go to WS "<<WSIDtemp<<endl;
												cout<<"Trying to insert pickup cus "<<idCus<<" at the beginning: ";
												showTripCostTemp(numVeh,idTrip);
												cout<<"After sp: "<<departSP<<endl;
												exit(-1);
										}
									 }
									 if (c1 < varcost) {varcost=c1; IDinsert=idCus; insert_after = 0;
														WSID=WSIDtemp;TOTALTIME = ArrTime;}  
														}
								  }//end if (temp > eps) //else too late to go to sp directly
							}//end if(ok) else vioTW at some pickup cus
													
							//2. Try to insert idCus after each customer j of the trip:
							preINS = seg[numVeh].Trip[idTrip].firstCus; 
							ArrTime = leave_departSP + problem->c[departSP][preINS];
							for (int j=1;j<=seg[numVeh].Trip[idTrip].numCus;j++)
							{
								ok=1;
								startSTemp = PDS_MAX(ArrTime, problem->node[preINS].sTW);
								ArrTime = startSTemp + problem->node[preINS].duration + problem->c[preINS][idCus];
								temp = ArrTime - problem->node[idCus].eTW;
								if (temp > eps) break; //vioTW at idCus --> don't need to check any j 
								ArrTime = PDS_MAX(ArrTime, problem->node[idCus].sTW) + problem->node[idCus].duration;
								//start checking TW from idCus to the end of the leg:
								curC = idCus; nextC = nextArrTemp[preINS];
								while (nextC > 0)
								{
									 ArrTime += problem->c[curC][nextC]; 
									 temp = ArrTime - problem->node[nextC].eTW;
									 if (temp > eps) {ok=0;break;}
									 else
									 {
										 ArrTime = PDS_MAX(ArrTime,problem->node[nextC].sTW) + problem->node[nextC].duration;
								    	 curC = nextC; nextC=nextArrTemp[curC];
									 }
							    }
								if (ok) //curC is now pointed to last cus of pickup trip
								{
								     ArrTime1=  ArrTime + problem->c[curC][endSP];
									 temp = problem->nodeSP[endSP].eTW1 - ArrTime1;
									 if (temp > eps)//else too late to go to sp directly
									 {
									     if (PDSINRANGE(ArrTime1,problem->nodeSP[endSP].sTW1, problem->nodeSP[endSP].eTW1))
											  WSIDtemp=NO_WS;
										 else
										 {
											  ArrTime1 = ArrTime + problem->disCWSSP[curC][endSP];
											  temp = ArrTime1 - problem->nodeSP[endSP].eTW1;
											  if (temp > eps) ok=0; //too late to go to sp through WS
											  else WSIDtemp = problem->CWSSP[curC][endSP];
										 }
										 if (ok)
										 {
											 if (j != seg[numVeh].Trip[idTrip].numCus)								        
											 {
												 nextINS = nextArrTemp[preINS];
												 c1 = problem->c[preINS][idCus] + problem->c[idCus][nextINS] - problem->c[preINS][nextINS];
												 if (goWS != WSIDtemp)
												 {
													 if (goWS != NO_WS) //before go to WS, after insert don't need to go to WS:
														 c1 += (problem->c[curC][endSP] - problem->disCWSSP[curC][endSP]);
													 else 
													 {
														 cout<<"Solution::Init_NewSolomonI1_NewPickupTrip ERROR before insert go to sp directly, after insert go to WS"<<endl;
														 cout<<"Trying to insert pickup "<<idCus<<" after "<<preINS<<": ";
														 showTripCostTemp(numVeh,idTrip);
														 exit(-1);
													 }
												 }
											 }
											 else //insert to the end of the trip:
											 {
												 c1 = problem->c[preINS][idCus];
												 if (goWS==NO_WS) //before insert customer idCus, go to sp directly
												 {
													 if (WSIDtemp ==NO_WS) c1 += (problem->c[idCus][endSP] - problem->c[preINS][endSP]);
													 else 
													 {
														 cout<<"Solution::Init_NewSolomonI1_NewPickupTrip  ERROR before insert go to sp directly, after insert need to go to WS"<<endl; 
														 cout<<"Trying to insert pickup "<<idCus<<" at the end of the pickup trip: ";
														 showTripCostTemp(numVeh,idTrip);
														 exit(-1);
													 }
												 }
												 else //before insert customer idCus, go to WS:
												 {
												     if (WSIDtemp == NO_WS) c1 += (problem->c[idCus][endSP] - problem->disCWSSP[preINS][endSP]);
													 else c1+=(problem->disCWSSP[idCus][endSP] - problem->disCWSSP[preINS][endSP]);
												 }
											 }
											 if (c1 < varcost) {varcost=c1; IDinsert=idCus; insert_after = preINS;WSID=WSIDtemp;TOTALTIME = ArrTime;} 
										 }//else too soon to go to sp directly, too late to go to sp through WS
									 }//else too late to go to sp directly													 						
								 }//end if (ok) :else vioTW at one customer of route
								 nextINS = nextArrTemp[preINS];
								 ArrTime = startSTemp + problem->node[preINS].duration + problem->c[preINS][nextINS];
								 preINS = nextINS;
							}//end for (j=1;j<=seg[numVeh].Trip[lP].numCus;j++)
					   }//end if of each pickup customer: if (!routedPTemp[i] && (seg[numVeh].Trip[lP].capacity + problem->nodeP[i].capacity <= problem->Q))
				    }//end for
				    // Now take the best insertion position:
					  if (insert_after!=-1)
					  {
							  //cout<<"Insert customer "<<IDinsert<<" after "<<insert_after<<endl;
							  if (insert_after == 0)
							  {
								  int pre = seg[numVeh].Trip[idTrip].firstCus;
								  seg[numVeh].Trip[idTrip].firstCus = IDinsert;
								  nextArrTemp[IDinsert] = pre;
								  //cout<<"************Insert customer "<<IDinsert<<" beginning of the leg: after delivery cus "<<insert_after<<"; varcost = "<<varcost<<endl;
								  //cout<<"/endS = "<<TOTALTIME<<"; goWS = "<<WSID<<"; (sTW,eTW)= ("<<problem->nodeD[endSPID].sTW<<", "<<problem->nodeD[endSPID].eTW<<")"<<endl;
							  }
							  else if (insert_after == seg[numVeh].Trip[idTrip].lastCus) //insert at the end of the leg:
							  {
								  nextArrTemp[insert_after] = IDinsert;
								  seg[numVeh].Trip[idTrip].lastCus = IDinsert;
								  nextArrTemp[IDinsert]= 0;
								  //cout<<"*************Insert customer "<<IDinsert<<" at the end of the leg: after "<<insert_after<<"; varcost = "<<varcost<<endl;
								  //cout<<"endS = "<<TOTALTIME<<"; goWS = "<<WSID<<"; (sTW,eTW)= ("<<problem->nodeD[endSPID].sTW<<", "<<problem->nodeD[endSPID].eTW<<")"<<endl;
							  }
							  else //insert at the middile of the leg:
							  {
								  int tt=nextArrTemp[insert_after];
								  nextArrTemp[insert_after]=IDinsert;
								  nextArrTemp[IDinsert]=tt;
								  //cout<<"***********Insert customer "<<IDinsert<<" in the middle of the leg: after "<<insert_after<<"; varcost = "<<varcost<<endl;
								  //cout<<"endS = "<<TOTALTIME<<"; goWS = "<<WSID<<"; (sTW,eTW)= ("<<problem->nodeD[endSPID].sTW<<", "<<problem->nodeD[endSPID].eTW<<")"<<endl;
							  }
							  seg[numVeh].Trip[idTrip].numCus++;seg[numVeh].Trip[idTrip].waitingS = WSID;
							  routedTemp[IDinsert]=1;
							  seg[numVeh].Trip[idTrip].capacity += problem->node[IDinsert].capacity;
							  goWS = WSID;
							  seg[numVeh].Trip[idTrip].cost += varcost;
							  seg[numVeh].Trip[idTrip].endS =  TOTALTIME;
					   }//end  if (insert_after != -1)
				       else cont = false; //cannot find any pickup customer to insert into the current trip
			    }while (cont);//end do each loop insert 1 pickup customer
				//Try to create C2C between SP: departSP and this PTrip(numVeh, idTrip):
			    CreateC2CTrip_BeforePickupTrip_Temp(numVeh,idTrip_departSP,departSP,leave_departSP,lC2C,idTrip-1,idTrip,endSP);
			}//end if (seed != -1)
			else
			{
				/*cout<<"CANNOT create pickup trip connect these sp ("<<departSP<<", "<<endSP<<") even still have "<<(numCusPSP[endSP] - numCusPRouted[endSP])<<" unrouted pickup customers"<<endl;*/
				if (numCusDRouted[endSP] < problem->numCusDSP[endSP]) //create empty trip departSP (unload) - endSP
				{
					//Try to create C2C trip between 2SP: departSP - endSP
                    bool create = CreateC2CTrip_BeforeSP_Temp(numVeh,idTrip_departSP,departSP,leave_departSP,lC2C,idTrip-1,endSP);
					if (create == 0) //can;t create C2C:
					{
						emptyTrip = 1;
						ArrTime = seg[numVeh].Trip[idTrip-3].leaveSP + problem->c[departSP][endSP];
						if (PDSINRANGE(ArrTime, problem->nodeSP[endSP].sTW2, problem->nodeSP[endSP].eTW2))
						{
							seg[numVeh].Trip[idTrip].leaveSP = ArrTime;
							seg[numVeh].Trip[idTrip].waitingS = NO_WS;
							seg[numVeh].Trip[idTrip].cost = problem->c[departSP][endSP];
						}
						else
						{
							temp = ArrTime - problem->nodeSP[endSP].eTW2;
							if (temp > eps) return;
							ArrTime = seg[numVeh].Trip[idTrip-3].leaveSP + problem->disCWSSP[departSP][endSP];
							temp = ArrTime - problem->nodeSP[endSP].eTW2;
							if (temp > eps) return;
							seg[numVeh].Trip[idTrip].leaveSP = PDS_MAX(ArrTime, problem->nodeSP[endSP].sTW2);
							seg[numVeh].Trip[idTrip].waitingS = problem->CWSSP[departSP][endSP];
							seg[numVeh].Trip[idTrip].cost = problem->disCWSSP[departSP][endSP];
						}

					}
				}
				else return;
			}
	}
	else //empty trip: departSP (unload) - endSP
	{
		//therefore: numCusDRouted[endSP] < problem->numCusDSP[endSP]:
		//Try to create C2CTrip between 2SP: departSP-endSP:
        bool create = CreateC2CTrip_BeforeSP_Temp(numVeh,idTrip_departSP,departSP,leave_departSP,lC2C,idTrip-1,endSP);
		if (create == 0)
		{
			//cout<<"trying to create empty trip connecting SP "<<departSP<<" and SP "<<endSP<<": ";
			emptyTrip = 1;
			ArrTime = seg[numVeh].Trip[idTrip-3].leaveSP + problem->c[departSP][endSP];
			if (PDSINRANGE(ArrTime, problem->nodeSP[endSP].sTW2, problem->nodeSP[endSP].eTW2))
			{
				seg[numVeh].Trip[idTrip].leaveSP = ArrTime;
				seg[numVeh].Trip[idTrip].waitingS = NO_WS;
				seg[numVeh].Trip[idTrip].cost = problem->c[departSP][endSP];
				//cout<<"ok directly"<<endl;
			}
			else
			{
				temp = ArrTime - problem->nodeSP[endSP].eTW2;
				if (temp > eps) return;
				ArrTime = seg[numVeh].Trip[idTrip-3].leaveSP + problem->disCWSSP[departSP][endSP];
				temp = ArrTime - problem->nodeSP[endSP].eTW2;
				if (temp > eps) return;
				seg[numVeh].Trip[idTrip].leaveSP = PDS_MAX(ArrTime, problem->nodeSP[endSP].sTW2);
				seg[numVeh].Trip[idTrip].waitingS = problem->CWSSP[departSP][endSP];
				seg[numVeh].Trip[idTrip].cost = problem->disCWSSP[departSP][endSP];
				//cout<<"ok throughWS"<<endl;
			}
		}
	}

	double fee;
    if (typeofINIT==1)
	{
			if (emptyTrip)
				fee = Q*seg[numVeh].Trip[idTrip].cost;
			else
			{
				if (lC2C != -1 && lP != -1) //Can create (C2C + P):
				{
				   fee = (problem->nodeSP[endSP].sTW1 - seg[numVeh].Trip[idTrip].endS) / (seg[numVeh].Trip[lC2C].capacity + seg[numVeh].Trip[idTrip].capacity);
				   fee *= (seg[numVeh].Trip[lC2C].cost + seg[numVeh].Trip[idTrip].cost);
				}
				else if (lC2C == -1) //can create only P:
				{
				   fee = (problem->nodeSP[endSP].sTW1 - seg[numVeh].Trip[idTrip].endS) / seg[numVeh].Trip[idTrip].capacity;
				   fee *= seg[numVeh].Trip[idTrip].cost;
				}
				else //can create only C2C
				{
				   fee = (problem->nodeSP[endSP].sTW2 - seg[numVeh].Trip[lC2C].endS) / seg[numVeh].Trip[lC2C].capacity;
				   fee *= seg[numVeh].Trip[lC2C].cost;
				}
			}
	}
	else if (typeofINIT==2)
	{
			if (emptyTrip)
				fee = Q*seg[numVeh].Trip[idTrip].cost;
			else
			{
				if (lC2C != -1 && lP != -1)
				{
				   fee = valueFEE*((problem->nodeSP[endSP].sTW1 - seg[numVeh].Trip[idTrip].endS)/(seg[numVeh].Trip[lC2C].capacity + seg[numVeh].Trip[idTrip].capacity));
				   fee += (seg[numVeh].Trip[lC2C].cost + seg[numVeh].Trip[idTrip].cost);
				}
				else if (lC2C == -1) //can create only P:
				{
				   fee = valueFEE*((problem->nodeSP[endSP].sTW1 - seg[numVeh].Trip[idTrip].endS)/seg[numVeh].Trip[idTrip].capacity);
				   fee += seg[numVeh].Trip[idTrip].cost;
				}
				else //create only C2C:
				{
				   fee = valueFEE*((problem->nodeSP[endSP].sTW2 - seg[numVeh].Trip[lC2C].endS)/seg[numVeh].Trip[lC2C].capacity);
				   fee += seg[numVeh].Trip[lC2C].cost;
				}
			}
	}

	if (feeMIN > fee)
	{
		    feeMIN=fee; NULLTrip = emptyTrip;
			int ll; canRoute = 0;
			if (emptyTrip)
			{
				//cout<<"CREATE EMPTY TRIP CONNECTING 2 SP "<<departSP<<" and "<<endSP<<endl;
				canRoute = 2;
			}
			if (lC2C != -1)
			{
				ll = idTrip + 1;
				seg[numVeh].Trip[ll] = seg[numVeh].Trip[lC2C];
				int curC = seg[numVeh].Trip[lC2C].firstCus;
				while (curC >0)
				{
					nextArrB[curC] = nextArrTemp[curC];
					curC = nextArrB[curC];
				}
				seg[numVeh].Trip[ll].Type = 2; canRoute = 1;
			}
			if (lP != -1)
			{
				ll = idTrip + 2; if (lC2C == -1) canRoute = 2; else canRoute = 3;
				seg[numVeh].Trip[ll] = seg[numVeh].Trip[idTrip];
				int curC = seg[numVeh].Trip[idTrip].firstCus;
				while (curC >0)
				{
					nextArrB[curC] = nextArrTemp[curC];
					curC = nextArrB[curC];
				}
				seg[numVeh].Trip[ll].Type = 0;
			}
		    nextSP = endSP;
	}
}

void Solution::updateStartS_pos_FCAP_FEASIBLETRIP(int idVeh, int idTrip, int preC, int idCus, int pre_pos) //update startSP and departP array from idCus on feasible pickup trip(idVeh, idTrip): idCus is not the first customer
{
	double ArrTime;
	while (idCus > 0)
	{
		ArrTime = depart[preC] + problem->c[preC][idCus];
		startS[idCus] = PDS_MAX(ArrTime, problem->node[idCus].sTW);
		depart[idCus] = startS[idCus] + problem->node[idCus].duration;
		pre_pos++; pos[idCus] = pre_pos;
		FCAP[idCus] = FCAP[preC] + problem->node[idCus].capacity;
		//cout<<"FCAP["<<idCus<<"] = "<<FCAP[idCus]<<"; ";
		preC = idCus; idCus = nextArr[idCus];
	}
	//cout<<endl;
}
void Solution::updateStartS_pos_FCAP_FEASIBLETRIP_Temp(int idVeh, int idTrip, int preC, int idCus, int pre_pos) //update startSP and departP array from idCus on feasible pickup trip(idVeh, idTrip): idCus is not the first customer
{
	double ArrTime;
	while (idCus > 0)
	{
		ArrTime = depart[preC] + problem->c[preC][idCus];
		startS[idCus] = PDS_MAX(ArrTime, problem->node[idCus].sTW);
		depart[idCus] = startS[idCus] + problem->node[idCus].duration;
		//cout<<"startS[idCus = "<<idCus<<"] = "<<startS[idCus]<<"; [sTW, eTW] = ["<<problem->node[idCus].sTW<<", "<<problem->node[idCus].eTW<<"]; depart[preC="<<preC<<"] = "<<depart[preC]<<"; dis = "<<problem->c[preC][idCus]<<endl;
		pre_pos++; pos[idCus] = pre_pos;
		FCAP[idCus] = FCAP[preC] + problem->node[idCus].capacity;
		preC = idCus; idCus = nextArrTemp[idCus];
	}
}
void Solution::updatePTrip_InitSol(int idVeh, int idTrip, int preC, int idCus, bool changed)
{
	//Update startS, depart of all customers, leaveSP in PTrip(idVeh, idTrip)
	double ArrTime, cStartS;

	//cout<<"Update PTrip("<<idVeh<<", "<<idTrip<<"): ";
	while (idCus > 0)
	{
		ArrTime = depart[preC] + problem->c[preC][idCus];
		cStartS = PDS_MAX(ArrTime, problem->node[idCus].sTW);
		if (PDSDIF(cStartS, startS[idCus]) == 0) return; 
		startS[idCus] = cStartS;
		depart[idCus] = cStartS + problem->node[idCus].duration;
		//cout<<idCus<<"(depart = "<<depart[idCus]<<"); ";
		preC = idCus; idCus = nextArr[idCus];
	}

	seg[idVeh].Trip[idTrip].endS = depart[preC];
	//cout<<"endS of trip = "<<depart[preC]<<endl;
	int assSP = seg[idVeh].Trip[idTrip].assSP;
	if (changed) //PTrip(idVeh, idTrip) before go through WS now go to sp directly
	{
		seg[idVeh].Trip[idTrip].waitingS = NO_WS;
		seg[idVeh].Trip[idTrip].cost += (problem->c[preC][assSP] - problem->disCWSSP[preC][assSP]);
		seg[idVeh].Trip[idTrip].leaveSP = depart[preC] + problem->c[preC][assSP] + problem->nodeSP[assSP].unload;
	}
	else //still go to SP directly OR still go through WS:
	{
		if (seg[idVeh].Trip[idTrip].waitingS == NO_WS)
		{
			seg[idVeh].Trip[idTrip].leaveSP = depart[preC] + problem->c[preC][assSP] + problem->nodeSP[assSP].unload;
		}
		else
		{
			ArrTime = PDS_MAX(depart[preC] + problem->disCWSSP[preC][assSP], problem->nodeSP[assSP].sTW1);
			seg[idVeh].Trip[idTrip].leaveSP = ArrTime + problem->nodeSP[assSP].unload;
		}
	}
}

void Solution::updatePTrip_InitSol_Temp(int idVeh, int idTrip, int preC, int idCus, bool changed)
{
	//Update startS, depart of all customers, leaveSP in PTrip(idVeh, idTrip)
	double ArrTime, cStartS;

	while (idCus > 0)
	{
		ArrTime = depart[preC] + problem->c[preC][idCus];
		cStartS = PDS_MAX(ArrTime, problem->node[idCus].sTW);
		if (PDSDIF(cStartS, startS[idCus]) == 0) return; 
		startS[idCus] = cStartS;
		depart[idCus] = cStartS + problem->node[idCus].duration;
		//cout<<idCus<<"(depart = "<<depart[idCus]<<"); ";
		preC = idCus; idCus = nextArrTemp[idCus];
	}

	seg[idVeh].Trip[idTrip].endS = depart[preC];
	
	int assSP = seg[idVeh].Trip[idTrip].assSP;
	if (changed) //PTrip(idVeh, idTrip) before go through WS now go to sp directly
	{
		seg[idVeh].Trip[idTrip].waitingS = NO_WS;
		seg[idVeh].Trip[idTrip].cost += (problem->c[preC][assSP] - problem->disCWSSP[preC][assSP]);
		seg[idVeh].Trip[idTrip].leaveSP = depart[preC] + problem->c[preC][assSP] + problem->nodeSP[assSP].unload;
	}
	else //still go to SP directly OR still go through WS:
	{
		if (seg[idVeh].Trip[idTrip].waitingS == NO_WS)
		{
			seg[idVeh].Trip[idTrip].leaveSP = depart[preC] + problem->c[preC][assSP] + problem->nodeSP[assSP].unload;
		}
		else
		{
			ArrTime = PDS_MAX(depart[preC] + problem->disCWSSP[preC][assSP], problem->nodeSP[assSP].sTW1);
			seg[idVeh].Trip[idTrip].leaveSP = ArrTime + problem->nodeSP[assSP].unload;
		}
	}
}
void Solution::CalInfromationTripC2C(int idVeh, int idTrip) 
{
   	int nextTrip = idTrip + 1;

	double cArrTime, cArrTimeI;
	int curC, nextC;
	int i;
	double temp, tempC;

	//Update predArr, route_num, trip_num, pos, 
	//startSP, depart, waitTime, vioTWCus, CAPCus
	//endS, leaveSP, arriveSP (if avail:SP-d-SP)
	//FCAP, BCAP
	//connectCost, cost, fitness, vioTWSP, vioTWC, vioCAP, FvioTWC

	//Create predArr:
	curC = seg[idVeh].Trip[idTrip].firstCus;
	predArr[curC]=-1;
	route_num[curC] = idVeh; trip_num[curC] = idTrip; pos[curC] = 1;

	if (idTrip==0)
	{
		if (seg[idVeh].numTrips > 1)
		{
			if (seg[idVeh].Trip[1].Type == 1)  seg[idVeh].Trip[0].nextSP = seg[idVeh].Trip[1].assSP;
			else seg[idVeh].Trip[0].nextSP = -1;
		}
		else seg[idVeh].Trip[0].nextSP = 0;
		tempC = problem->c[0][curC];

		if (seg[idVeh].Trip[0].numCus == 2 && seg[idVeh].Trip[0].nextSP > 0)
		{
			startS[curC] = problem->startSOneP[curC][seg[idVeh].Trip[0].nextSP];
			depart[curC] = startS[curC] + problem->node[curC].duration;
			vioTWCus[curC] = 0; FvioTWCus[curC] = 0; 
			vioCAPCus[curC] = 0; FCAP[curC] = 0; //FvioCAPCus[curC] = 0;
			/*CAPCus[curC] = problem->node[curC].capacity;
			int delID = problem->node[curC].delID;
			startS[delID] = problem->startSOneP[delID][seg[idVeh].Trip[0].nextSP];
			depart[delID] = startS[delID] + problem->node[delID].duration;
			vioTWCus[delID] = 0; FvioTWCus[delID] = 0; CAPCus[delID] = 0;*/
		}
		else
		{
			cArrTime = PDS_MAX(problem->c[0][curC], problem->node[curC].sTW);
			//Update startS and waitTime for each customer:
			vioTWCus[curC] = PDS_MAX(0, cArrTime - problem->node[curC].eTW);
			FvioTWCus[curC] = vioTWCus[curC]; 
			vioCAPCus[curC] = 0; FCAP[curC] = 0; //FvioCAPCus[curC] = 0;
			if (vioTWCus[curC] > eps)
			{
					startS[curC] = problem->node[curC].eTW;
					depart[curC] = startS[curC] + problem->node[curC].duration;
			}
			else
			{
					startS[curC] = PDS_MAX(cArrTime, problem->node[curC].sTW);
					depart[curC] = startS[curC] + problem->node[curC].duration;
			}
		}
		CAPCus[curC] = problem->node[curC].capacity;
		nextC = nextArr[curC];
		seg[idVeh].Trip[0].assSP = 0;
	}
	else //idTrip > 0
	{
		tempC = 0;
	    int preT = idTrip - 1;
		if (seg[idVeh].Trip[preT].Type == 0)
		{
			cArrTime = seg[idVeh].Trip[preT].leaveSP + problem->c[seg[idVeh].Trip[preT].assSP][curC];
			seg[idVeh].Trip[idTrip].assSP = seg[idVeh].Trip[preT].assSP;
		}
		else //if (seg[idVeh].Trip[preT].Type == 1 || 2)
		{
		    cArrTime = depart[seg[idVeh].Trip[preT].lastCus] + problem->c[seg[idVeh].Trip[preT].lastCus][curC];
			seg[idVeh].Trip[idTrip].assSP = -1;
		}
		//else//cout<<"ERROR CalInfromationTripC2C: preT is C2C, curT is C2C"<<endl;
		
		//Update startS and waitTime for each customer:
		vioTWCus[curC] = PDS_MAX(0, cArrTime - problem->node[curC].eTW);
		FvioTWCus[curC] = vioTWCus[curC];
		if (vioTWCus[curC] > eps)
		{
				startS[curC] = problem->node[curC].eTW;
				depart[curC] = startS[curC] + problem->node[curC].duration;
		}
		else
		{
				startS[curC] = PDS_MAX(cArrTime, problem->node[curC].sTW);
				depart[curC] = startS[curC] + problem->node[curC].duration;
		}
		CAPCus[curC] = problem->node[curC].capacity;
		vioCAPCus[curC] = 0; FCAP[curC] = 0; //FvioCAPCus[curC] = 0;
		nextC = nextArr[curC];
	}



		int tQ;
		int numC = seg[idVeh].Trip[idTrip].numCus; 
		for (i=2;i<=numC;i++)
		{
			predArr[nextC] = curC; route_num[nextC] = idVeh; trip_num[nextC] = idTrip;
			pos[nextC] = i; 
			CAPCus[nextC] = CAPCus[curC] + problem->node[nextC].capacity;
			tQ = CAPCus[nextC] - Q;
			if (tQ > 0) 
			{
				vioCAPCus[nextC] = tQ;
				CAPCus[nextC] = Q;
				FCAP[nextC] = FCAP[curC] + tQ;
				//FvioCAPCus[nextC] = FvioCAPCus[curC] + tQ;
			}
			else
			{
				vioCAPCus[nextC] = 0;
				FCAP[nextC] = FCAP[curC];
				//FvioCAPCus[nextC] = FvioCAPCus[curC];
			}
			cArrTime = depart[curC] + problem->c[curC][nextC];
			vioTWCus[nextC] = PDS_MAX(0, cArrTime - problem->node[nextC].eTW);
            if (vioTWCus[nextC] > eps)
			{
				FvioTWCus[nextC] = FvioTWCus[curC] + vioTWCus[nextC];
				startS[nextC] = problem->node[nextC].eTW;
				depart[nextC] = problem->node[nextC].depart;
			}
			else
			{
			    FvioTWCus[nextC] = FvioTWCus[curC];
				startS[nextC] = PDS_MAX(cArrTime, problem->node[nextC].sTW);
			    depart[nextC] = startS[nextC] + problem->node[nextC].duration;
			}
			tempC += problem->c[curC][nextC];
			curC = nextC; nextC=nextArr[curC];
		}
		nextArr[curC] = -1;

		bool check = 1;
		if (idTrip == 0 && seg[idVeh].Trip[0].numCus == 2 && seg[idVeh].Trip[0].nextSP > 0) check = 0;
		
        if (check)
		if (PDSDIF(depart[curC], seg[idVeh].Trip[idTrip].endS))
		{
			cout<<"ERROR CalInfromationTripC2C("<<idVeh<<", "<<idTrip<<"): correct endS = "<<depart[curC]<<"; wrong from init sol= "<<seg[idVeh].Trip[idTrip].endS<<endl;
			showTripCus(idVeh, idTrip);
			exit(-1);
		}

		seg[idVeh].Trip[idTrip].endS = depart[curC];
		seg[idVeh].Trip[idTrip].vioTWC = FvioTWCus[curC];
		seg[idVeh].Trip[idTrip].vioCAP = FCAP[curC];
		//seg[idVeh].Trip[idTrip].vioCAP = FvioCAPCus[curC];

		if (nextTrip < seg[idVeh].numTrips) //idTrip is not the last trip
		{
			if (seg[idVeh].Trip[nextTrip].Type == 1) //next trip is delivery trip
			{	
				int nextSP = seg[idVeh].Trip[nextTrip].assSP;
				seg[idVeh].Trip[idTrip].nextSP = nextSP;
				cArrTime = depart[curC] + problem->c[curC][nextSP];
				if (PDSINRANGE(cArrTime, problem->nodeSP[nextSP].sTW2, problem->nodeSP[nextSP].eTW2))
				{
					if (check)
					if (seg[idVeh].Trip[idTrip].waitingS != NO_WS)
					{	cout<<"Solution::CalInfromationTripC2C("<<idVeh<<", "<<idTrip<<") ERRROR: correct: noWS, wrong from init sol: waitS = "<<seg[idVeh].Trip[idTrip].waitingS<<endl;exit(-1);}
					seg[idVeh].Trip[idTrip].waitingS = NO_WS;
					seg[idVeh].Trip[idTrip].connectCost = problem->c[curC][nextSP];
					seg[idVeh].Trip[idTrip].arriveSP = cArrTime;

					seg[idVeh].Trip[nextTrip].leaveSP = cArrTime + problem->nodeSP[nextSP].load;
					seg[idVeh].Trip[nextTrip].vioTWSP = 0;
				}
				else
				{
					temp = cArrTime - problem->nodeSP[nextSP].eTW2;
					if (temp > eps) //too late to go to sp directly:
					{
						if (check)
						if (seg[idVeh].Trip[idTrip].waitingS != NO_WS)
						{	cout<<"Solution::CalInfromationTripC2C("<<idVeh<<", "<<idTrip<<" ERRROR: correct: noWS, wrong from init sol: waitS = "<<seg[idVeh].Trip[idTrip].waitingS<<endl;exit(-1);}
						seg[idVeh].Trip[idTrip].waitingS = NO_WS;
						seg[idVeh].Trip[idTrip].connectCost = problem->c[curC][nextSP];
						seg[idVeh].Trip[idTrip].arriveSP = problem->nodeSP[nextSP].eTW2;

						seg[idVeh].Trip[nextTrip].leaveSP = problem->leaveSP[nextSP][1]; //just load
						seg[idVeh].Trip[nextTrip].vioTWSP = temp;
					}
					else // too soon to go to sp directly:
					{
						cArrTimeI = depart[curC] + problem->disCWSSP[curC][nextSP];
						temp = cArrTimeI - problem->nodeSP[nextSP].eTW2;
						if (temp > eps) // too soon to go to sp directly, too late to go through WS: --> go to sp directly INFEASIBILITY
						{
							if (check)
							if (seg[idVeh].Trip[idTrip].waitingS != NO_WS)
							{	cout<<"Solution::CalInfromationTripC2C("<<idVeh<<", "<<idTrip<<") ERRROR: correct: NO_WS, wrong from init sol: waitS = "<<seg[idVeh].Trip[idTrip].waitingS<<endl;exit(-1);}
							seg[idVeh].Trip[idTrip].waitingS = NO_WS;
							seg[idVeh].Trip[idTrip].connectCost = problem->c[curC][nextSP];
							seg[idVeh].Trip[idTrip].arriveSP = problem->nodeSP[nextSP].eTW2;

							seg[idVeh].Trip[nextTrip].leaveSP = problem->leaveSP[nextSP][1]; //just load
							seg[idVeh].Trip[nextTrip].vioTWSP = problem->nodeSP[nextSP].sTW2 - cArrTime;
						}
						else //go to sp through WS: feasibility
						{
							if (check)
							if (seg[idVeh].Trip[idTrip].waitingS != problem->CWSSP[curC][nextSP])
							{	cout<<"Solution::CalInfromationTripC2C("<<idVeh<<", "<<idTrip<<") ERRROR: correct: "<<problem->CWSSP[curC][nextSP]<<", wrong from init sol: waitS = "<<seg[idVeh].Trip[idTrip].waitingS<<endl;exit(-1);}

							seg[idVeh].Trip[idTrip].waitingS = problem->CWSSP[curC][nextSP];
							seg[idVeh].Trip[idTrip].connectCost = problem->disCWSSP[curC][nextSP];
						
							seg[idVeh].Trip[idTrip].arriveSP = PDS_MAX(cArrTimeI, problem->nodeSP[nextSP].sTW2);
							seg[idVeh].Trip[nextTrip].leaveSP =  seg[idVeh].Trip[idTrip].arriveSP + problem->nodeSP[nextSP].load; //just load
							seg[idVeh].Trip[nextTrip].vioTWSP = 0;
						}
					}
				}
				//seg[idVeh].Trip[idTrip].arriveSP = PDS_MAX(depart[curC] + seg[idVeh].Trip[idTrip].connectCost, problem->nodeSP[nextSP].sTW2);
			}
			else //if (seg[idVeh].Trip[nextTrip].Type == 0 || 2) //next trip is pickup trip
			{
				seg[idVeh].Trip[idTrip].waitingS = NO_WS;
				seg[idVeh].Trip[idTrip].connectCost = problem->c[curC][seg[idVeh].Trip[nextTrip].firstCus];
				seg[idVeh].Trip[idTrip].nextSP = -1;
			}
			//else cout<<"ERROR CalInfromationTripC2C: curT is C2C; nextTrip is C2C"<<endl;
		}
		else seg[idVeh].Trip[idTrip].connectCost = problem->c[curC][0]; //lastTrip --> connectCost = dis(lastCus, depot)
		tempC += seg[idVeh].Trip[idTrip].connectCost;
		seg[idVeh].Trip[idTrip].cost = tempC;
		if (seg[idVeh].Trip[idTrip].assSP > 0)
		{
			if (seg[idVeh].Trip[idTrip].nextSP > 0) seg[idVeh].Trip[idTrip].coordinate = 1;
			else seg[idVeh].Trip[idTrip].coordinate = 2;
		}
		else
		{
			if (seg[idVeh].Trip[idTrip].nextSP > 0) seg[idVeh].Trip[idTrip].coordinate = 3;
			else seg[idVeh].Trip[idTrip].coordinate = 0;
		}
		
		seg[idVeh].Trip[idTrip].fitness = tempC + COEFCAP * seg[idVeh].Trip[idTrip].vioCAP + COEFTWC * seg[idVeh].Trip[idTrip].vioTWC + COEFTWSP * seg[idVeh].Trip[idTrip].vioTWSP;
	 
		int lC = seg[idVeh].Trip[idTrip].lastCus; int BCTemp=0; double BvioTWTemp = 0;
		int BvioCAPTemp = 0;
		for (int kk=1; kk <= numC; kk++)
		{
		   BvioCAPTemp += vioCAPCus[lC];
		   BCAP[lC] = BvioCAPTemp;
		   //BvioCAPCus[lC] = BvioCAPTemp;
		   BvioTWTemp += vioTWCus[lC];
		   BvioTWCus[lC] = BvioTWTemp;
		   lC = predArr[lC];
		}
}

void Solution::showTripCus(int idVeh, int idTrip)
{
	int i;
	if (seg[idVeh].Trip[idTrip].Type==1) //delivery trip
	{
		int firstCus= seg[idVeh].Trip[idTrip].firstCus;
	    int lastCus = seg[idVeh].Trip[idTrip].lastCus;
		i=firstCus;
		while (i!=lastCus)
		{
				cout<<i<<"("<<depart[i]<<"), ";
				i = nextArr[i];
		}
		cout<<lastCus;
		int nextTrip = idTrip+1;
		if (seg[idVeh].numTrips == nextTrip) cout<<", depot"<<endl;
		else
			if (seg[idVeh].Trip[nextTrip].Type)
			{
				if (seg[idVeh].Trip[idTrip].waitingS != NO_WS) cout<<", (WS = "<<seg[idVeh].Trip[idTrip].waitingS<<")"<<endl;
				else cout<<endl;
			}
			else cout<<", pickcus = "<<seg[idVeh].Trip[nextTrip].firstCus<<endl;
	}
	else if (seg[idVeh].Trip[idTrip].Type==0)//pickup trip:
	{
		int firstCus= seg[idVeh].Trip[idTrip].firstCus;
		i=firstCus;
		while (i > 0)
		{
				cout<<i<<"("<<depart[i]<<"), ";
				i = nextArr[i];
		}
		if (seg[idVeh].Trip[idTrip].waitingS != NO_WS) cout<<"("<<seg[idVeh].Trip[idTrip].waitingS<<"), ";
		cout<<" sp = "<<seg[idVeh].Trip[idTrip].assSP<<endl;
	}
	else if (seg[idVeh].Trip[idTrip].Type==2)//C2C trip:
	{
		int firstCus= seg[idVeh].Trip[idTrip].firstCus;
		i=firstCus;
		while (i > 0)
		{
			if (i <= problem->endidC2CP) cout<<i<<", ";
			else cout<<i<<"(p = "<<problem->node[i].pickID<<"), ";
			i = nextArr[i];
		}
		cout<<endl;
	}
}
void Solution::showSolutionTempToCheck()
{
   int i,j,curC;
    int nCM=0, VM,TM;
  
   cout<<fitness<<"   "<<cost<<"   "<<numVehUsed<<"   numVehINIT = "<<numVeh<<endl;
   for (i=0;i<numVeh;i++)
   {
       cout<<seg[i].numTrips<<endl;
	   for (j=0;j<seg[i].numTrips;j++)
	   {
   		   if (seg[i].Trip[j].numCus > nCM) {nCM = seg[i].Trip[j].numCus; VM = i; TM = j;}
		   if (seg[i].Trip[j].Type == 1)
		   {
			   cout<<i<<"   "<<j<<" DTrip:\t"<<seg[i].Trip[j].fitness<<" \t "<<seg[i].Trip[j].cost<<" \t "<<seg[i].Trip[j].capacity<<" \t "<<seg[i].Trip[j].leaveSP<<" \t (nCus ="<<seg[i].Trip[j].numCus<<") \t";
			   cout<<"SP = "<<seg[i].Trip[j].assSP<<"\t";
			   curC = seg[i].Trip[j].firstCus;
			   while (curC > 0)
			   {
				   cout<<curC<<"\t"; //cout<<problem->node[curC].id<<"\t";
				   curC = nextArr[curC];
			   }
			   cout<<"("<<seg[i].Trip[j].waitingS<<")"<<endl;
		   }
		   else if (seg[i].Trip[j].Type == 0)
		   {
			   cout<<i<<"   "<<j<<"   PTrip:\t"<<seg[i].Trip[j].fitness<<" \t "<<seg[i].Trip[j].cost<<" \t "<<seg[i].Trip[j].capacity<<" \t "<<seg[i].Trip[j].leaveSP<<" \t (nCus ="<<seg[i].Trip[j].numCus<<") \t";
			   curC = seg[i].Trip[j].firstCus;
			   
			   while (curC > 0)
			   {
				   cout<<curC<<"\t"; //cout<<problem->node[curC].id<<"\t";
				   if (curC > endidP)
			     	   cout<<"ERROR: idCusP = "<<curC<<" exceed limit = "<<endidP<<endl;
			   	   curC = nextArr[curC];
			   }
			   cout<<"("<<seg[i].Trip[j].waitingS<<")\t ";
			   cout<<"SP = "<<seg[i].Trip[j].assSP<<endl;
		   }
		   else
		   {
			   int nextT = j + 1;
			   if (nextT < seg[i].numTrips)
			   {
				   if (seg[i].Trip[nextT].Type)
				   {
					   cout<<i<<"   "<<j<<"   C2C\t"<<seg[i].Trip[j].fitness<<" \t "<<seg[i].Trip[j].cost<<" \t "<<seg[i].Trip[j].arriveSP<<" \t (nCus = "<<seg[i].Trip[j].numCus<<") \t";
					   curC = seg[i].Trip[j].firstCus;
					   while (curC > 0)
					   {
						   cout<<curC<<"\t"; //cout<<problem->node[curC].id<<"\t";
						   curC = nextArr[curC];
					   }
					   cout<<"("<<seg[i].Trip[j].waitingS<<")\t";
					   cout<<"SP = "<<seg[i].Trip[nextT].assSP<<endl;
				   }
				   else
				   {
					   cout<<i<<"   "<<j<<"   C2C\t"<<seg[i].Trip[j].fitness<<" \t "<<seg[i].Trip[j].cost<<" \t "<<seg[i].Trip[j].endS<<" \t (nCus = "<<seg[i].Trip[j].numCus<<") \t";
					   curC = seg[i].Trip[j].firstCus;
					   while (curC > 0)
					   {
						   cout<<curC<<"\t"; //cout<<problem->node[curC].id<<"\t";
						   curC = nextArr[curC];
					   }
					   cout<<"("<<seg[i].Trip[j].waitingS<<")"<<endl;
				   }
			   }
			   else
			   {
				   cout<<i<<"   "<<j<<"   C2C\t"<<seg[i].Trip[j].fitness<<" \t "<<seg[i].Trip[j].cost<<" \t "<<seg[i].Trip[j].endS<<" \t (nCus = "<<seg[i].Trip[j].numCus<<") \t";
				   curC = seg[i].Trip[j].firstCus;
				   while (curC > 0)
				   {
					   cout<<curC<<"\t"; //cout<<problem->node[curC].id<<"\t";
					   curC = nextArr[curC];
				   }
				   cout<<"("<<seg[i].Trip[j].waitingS<<")"<<endl;
			   }
		   }
	   }
   }
   cout<<fitness<<"   "<<cost<<"   "<<numVehUsed<<endl;
   if (seg[VM].Trip[TM].Type == 1)
	   cout<<"DTrip("<<VM<<", "<<TM<<") has maxCus = "<<nCM<<endl;
   if (seg[VM].Trip[TM].Type == 0)
	   cout<<"PTrip("<<VM<<", "<<TM<<") has maxCus = "<<nCM<<endl;
   else
	   cout<<"C2CTrip("<<VM<<", "<<TM<<") has maxCus = "<<nCM<<endl;

}
#endif
